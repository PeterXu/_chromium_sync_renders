From 9401570e18af49e61c3e7401cea75d30db89c06f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 03:45:47 -0800
Subject: [PATCH 01/34] a. fix revision of .DEPS.git; b. simulate mmt:// as
 file://

---
 .DEPS.git                                      |    2 +-
 build/common.gypi                              |    7 +
 components/cronet/tools/cr_cronet.py           |    2 +-
 net/BUILD.gn                                   |   17 ++
 net/url_request/mmt_protocol_handler.cc        |   57 +++++
 net/url_request/mmt_protocol_handler.h         |   44 ++++
 net/url_request/url_request_context_builder.cc |   15 ++
 net/url_request/url_request_context_builder.h  |   11 +
 net/url_request/url_request_mmt_job.cc         |  326 ++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h          |  110 ++++++++
 10 files changed, 589 insertions(+), 2 deletions(-)
 create mode 100644 net/url_request/mmt_protocol_handler.cc
 create mode 100644 net/url_request/mmt_protocol_handler.h
 create mode 100644 net/url_request/url_request_mmt_job.cc
 create mode 100644 net/url_request/url_request_mmt_job.h

diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..ffd9746 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,19 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "base/directory_lister.cc",
+      "base/directory_lister.h",
+      "url_request/url_request_file_dir_job.cc",
+      "url_request/url_request_file_dir_job.h",
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..3b62225
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request->url(), &file_path);
+
+  // Check file access permissions.
+  if (!network_delegate ||
+      !network_delegate->CanAccessFile(*request, file_path)) {
+    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
+  }
+
+  // We need to decide whether to create URLRequestFileJob for file access or
+  // URLRequestFileDirJob for directory access. To avoid accessing the
+  // filesystem, we only look at the path string here.
+  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // which doesn't end with a slash, should really be treated as a directory,
+  // and it then redirects to the URLRequestFileDirJob.
+  if (is_file &&
+      file_path.EndsWithSeparator() &&
+      file_path.IsAbsolute()) {
+    return new URLRequestFileDirJob(request, network_delegate, file_path);
+  }
+
+  // Use a regular file request job for all non-directories (including invalid
+  // file names).
+  return new URLRequestFileJob(request, network_delegate, file_path,
+                               file_task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..28ca9b6
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
+// then all file requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..efb9e5c 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+    if (mmt_enabled_) {
+      job_factory->SetProtocolHandler(
+      "mmt",
+      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+    }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..2aff0dd 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -117,6 +117,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +209,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..4443c1b
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,326 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
+// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_file_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/files/file_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace net {
+
+URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequesetMmtJob::URLRequesetMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const base::FilePath& file_path,
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : URLRequestJob(request, network_delegate),
+      file_path_(file_path),
+      stream_(new FileStream(file_task_runner)),
+      file_task_runner_(file_task_runner),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void URLRequesetMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  file_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequesetMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequesetMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+Filter* URLRequesetMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
+
+bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
+  return false;
+}
+
+void URLRequesetMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
+}
+
+void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+}
+
+void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
+
+URLRequesetMmtJob::~URLRequesetMmtJob() {
+}
+
+void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
+}
+
+void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+
+  // We use URLRequesetMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequesetMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequesetMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
+  }
+}
+
+void URLRequesetMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
+
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..1ff88d2
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,110 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const base::FilePath& file_path,
+                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
+
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  HttpByteRange byte_range_;
+  int64 remaining_bytes_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
-- 
1.7.9.5


From 819ebb00f5f4b906fa46955091a2613e2f22f1be Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 05:57:57 -0800
Subject: [PATCH 02/34] fix building error for mmt protocol

---
 net/BUILD.gn                            |    4 ---
 net/net.gyp                             |   12 +++++++
 net/net.gypi                            |    4 +++
 net/url_request/mmt_protocol_handler.cc |    6 ++--
 net/url_request/url_request_mmt_job.cc  |   60 +++++++++++++++----------------
 5 files changed, 49 insertions(+), 37 deletions(-)

diff --git a/net/BUILD.gn b/net/BUILD.gn
index ffd9746..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -143,10 +143,6 @@ component("net") {
 
   if (disable_mmt_support) {
     sources -= [
-      "base/directory_lister.cc",
-      "base/directory_lister.h",
-      "url_request/url_request_file_dir_job.cc",
-      "url_request/url_request_file_dir_job.h",
       "url_request/url_request_mmt_job.cc",
       "url_request/url_request_mmt_job.h",
       "url_request/mmt_protocol_handler.cc",
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..1597f24 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,18 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'base/directory_lister.cc',
+            'base/directory_lister.h',
+            'url_request/url_request_file_dir_job.cc',
+            'url_request/url_request_file_dir_job.h',
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..ee879d2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1135,6 +1135,8 @@
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1178,6 +1180,8 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 3b62225..86afe03 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -32,10 +32,10 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
   }
 
-  // We need to decide whether to create URLRequestFileJob for file access or
+  // We need to decide whether to create URLRequestMmtJob for file access or
   // URLRequestFileDirJob for directory access. To avoid accessing the
   // filesystem, we only look at the path string here.
-  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // The code in the URLRequestMmtJob::Start() method discovers that a path,
   // which doesn't end with a slash, should really be treated as a directory,
   // and it then redirects to the URLRequestFileDirJob.
   if (is_file &&
@@ -46,7 +46,7 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
 
   // Use a regular file request job for all non-directories (including invalid
   // file names).
-  return new URLRequestFileJob(request, network_delegate, file_path,
+  return new URLRequestMmtJob(request, network_delegate, file_path,
                                file_task_runner_);
 }
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4443c1b..c5b8f9c 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -9,15 +9,15 @@
 // to do background file reads for us.
 //
 // Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
-// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
 // attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
 // signal from the OS that the overlapped read has completed.  It does so by
 // leveraging the MessageLoop::WatchObject API.
 
-#include "net/url_request/url_request_file_job.h"
+#include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
@@ -47,14 +47,14 @@
 
 namespace net {
 
-URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
     : file_size(0),
       mime_type_result(false),
       file_exists(false),
       is_directory(false) {
 }
 
-URLRequesetMmtJob::URLRequesetMmtJob(
+URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
     const base::FilePath& file_path,
@@ -66,25 +66,25 @@ URLRequesetMmtJob::URLRequesetMmtJob(
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
-void URLRequesetMmtJob::Start() {
+void URLRequestMmtJob::Start() {
   FileMetaInfo* meta_info = new FileMetaInfo();
   file_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
                  base::Unretained(meta_info)),
-      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(meta_info)));
 }
 
-void URLRequesetMmtJob::Kill() {
+void URLRequestMmtJob::Kill() {
   stream_.reset();
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
 }
 
-bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
@@ -103,7 +103,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
 
   int rv = stream_->Read(dest,
                          dest_size,
-                         base::Bind(&URLRequesetMmtJob::DidRead,
+                         base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
   if (rv >= 0) {
@@ -123,7 +123,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   if (meta_info_.is_directory) {
     // This happens when we discovered the file is a directory, so needs a
@@ -160,13 +160,13 @@ bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
 #endif
 }
 
-Filter* URLRequesetMmtJob::SetupFilter() const {
+Filter* URLRequestMmtJob::SetupFilter() const {
   // Bug 9936 - .svgz files needs to be decompressed.
   return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
       ? Filter::GZipFactory() : NULL;
 }
 
-bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
   if (meta_info_.mime_type_result) {
     *mime_type = meta_info_.mime_type;
@@ -175,7 +175,7 @@ bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
   return false;
 }
 
-void URLRequesetMmtJob::SetExtraRequestHeaders(
+void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
@@ -196,16 +196,16 @@ void URLRequesetMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
 }
 
-void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
 }
 
-URLRequesetMmtJob::~URLRequesetMmtJob() {
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                       FileMetaInfo* meta_info) {
   base::File::Info file_info;
   meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
@@ -219,10 +219,10 @@ void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                                     &meta_info->mime_type);
 }
 
-void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
   meta_info_ = *meta_info;
 
-  // We use URLRequesetMmtJob to handle files as well as directories without
+  // We use URLRequestMmtJob to handle files as well as directories without
   // trailing slash.
   // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
   // we will append trailing slash and redirect to FileDirJob.
@@ -243,16 +243,16 @@ void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
               base::File::FLAG_READ |
               base::File::FLAG_ASYNC;
   int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
                                     weak_ptr_factory_.GetWeakPtr()));
   if (rv != ERR_IO_PENDING)
     DidOpen(rv);
 }
 
-void URLRequesetMmtJob::DidOpen(int result) {
+void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -273,11 +273,11 @@ void URLRequesetMmtJob::DidOpen(int result) {
     // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
     tracked_objects::ScopedTracker tracking_profile1(
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequesetMmtJob::DidOpen 1"));
+            "423948 URLRequestMmtJob::DidOpen 1"));
 
     int rv = stream_->Seek(base::File::FROM_BEGIN,
                            byte_range_.first_byte_position(),
-                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                           base::Bind(&URLRequestMmtJob::DidSeek,
                                       weak_ptr_factory_.GetWeakPtr()));
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
@@ -292,7 +292,7 @@ void URLRequesetMmtJob::DidOpen(int result) {
   }
 }
 
-void URLRequesetMmtJob::DidSeek(int64 result) {
+void URLRequestMmtJob::DidSeek(int64 result) {
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -304,7 +304,7 @@ void URLRequesetMmtJob::DidSeek(int64 result) {
   NotifyHeadersComplete();
 }
 
-void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
-- 
1.7.9.5


From 1f5976f34f579f4c08029b399da98dd8943d4a07 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 25 Dec 2014 20:59:17 -0800
Subject: [PATCH 03/34] register mmt:// into chromium

---
 .../api/web_navigation/frame_navigation_state.cc   |    1 +
 chrome/browser/history/in_memory_url_index.cc      |    1 +
 chrome/browser/prerender/prerender_util.cc         |    3 +++
 chrome/browser/profiles/profile_io_data.cc         |   14 ++++++++++++++
 .../supervised_user/supervised_user_url_filter.cc  |    1 +
 chrome/browser/ui/location_bar/origin_chip_info.cc |    1 +
 chrome/browser/web_applications/web_app.cc         |    1 +
 .../navigation_metrics/navigation_metrics.cc       |    2 ++
 content/browser/browser_url_handler_impl.cc        |    1 +
 .../browser/child_process_security_policy_impl.cc  |    1 +
 content/common/savable_url_schemes.cc              |    1 +
 .../browser/api/web_request/web_request_api.cc     |    2 +-
 .../api/web_request/web_request_permissions.cc     |    2 +-
 extensions/common/extension.cc                     |    3 ++-
 extensions/common/url_pattern.cc                   |    2 ++
 extensions/common/url_pattern.h                    |    7 ++++---
 extensions/common/user_script.cc                   |    3 ++-
 extensions/renderer/dispatcher.cc                  |    1 +
 url/url_constants.cc                               |    1 +
 url/url_constants.h                                |    1 +
 url/url_util.cc                                    |    3 ++-
 21 files changed, 44 insertions(+), 8 deletions(-)

diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..d76a909 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+          content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..e4ed0ad 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,9 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_CHROMEUI   = 1 << 4,
-    SCHEME_EXTENSION  = 1 << 5,
-    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 4,
+    SCHEME_CHROMEUI   = 1 << 5,
+    SCHEME_EXTENSION  = 1 << 6,
+    SCHEME_FILESYSTEM = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
-- 
1.7.9.5


From b6a5c50865dee23020da0b887d3cd5da9d3f29da Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 31 Dec 2014 18:21:04 -0800
Subject: [PATCH 04/34] implement mmt protocol's framework

---
 chrome/browser/profiles/profile_io_data.cc     |    5 +-
 extensions/common/url_pattern.h                |    8 +-
 media/filters/ffmpeg_glue.cc                   |    2 +-
 net/mmt/mmt_information.h                      |   25 +++
 net/mmt/mmt_transaction.cc                     |   37 +++++
 net/mmt/mmt_transaction.h                      |   71 +++++++++
 net/mmt/mmt_transaction_factory.h              |   31 ++++
 net/mmt/mmt_transaction_impl.cc                |  195 ++++++++++++++++++++++++
 net/mmt/mmt_transaction_impl.h                 |   81 ++++++++++
 net/net.gyp                                    |    4 -
 net/net.gypi                                   |   10 +-
 net/url_request/mmt_protocol_handler.cc        |   34 +----
 net/url_request/mmt_protocol_handler.h         |   11 +-
 net/url_request/url_request_context_builder.cc |    2 +-
 net/url_request/url_request_mmt_job.cc         |  165 +++++---------------
 net/url_request/url_request_mmt_job.h          |   47 +-----
 16 files changed, 498 insertions(+), 230 deletions(-)
 create mode 100644 net/mmt/mmt_information.h
 create mode 100644 net/mmt/mmt_transaction.cc
 create mode 100644 net/mmt/mmt_transaction.h
 create mode 100644 net/mmt/mmt_transaction_factory.h
 create mode 100644 net/mmt/mmt_transaction_impl.cc
 create mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index d76a909..9d89cb3 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1219,10 +1219,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #if !defined(DISABLE_MMT_SUPPORT)
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(
-          content::BrowserThread::GetBlockingPool()->
-              GetTaskRunnerWithShutdownBehavior(
-                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+      new net::MmtProtocolHandler());
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index e4ed0ad..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,10 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_MMT        = 1 << 4,
-    SCHEME_CHROMEUI   = 1 << 5,
-    SCHEME_EXTENSION  = 1 << 6,
-    SCHEME_FILESYSTEM = 1 << 7,
+    SCHEME_CHROMEUI   = 1 << 4,
+    SCHEME_EXTENSION  = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..dabd7d5 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 256 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
new file mode 100644
index 0000000..60ed7e4
--- /dev/null
+++ b/net/mmt/mmt_information.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_INFORMATION_H_
+#define NET_MMT_MMT_INFORMATION_H_
+
+#include "url/gurl.h"
+
+namespace net {
+
+class MmtRequestInfo {
+ public:
+  // The requested URL.
+  GURL url;
+};
+
+class MmtResponseInfo {
+ public:
+
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
new file mode 100644
index 0000000..1f0e8c7
--- /dev/null
+++ b/net/mmt/mmt_transaction.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2008 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction.h"
+#include "net/mmt/mmt_transaction_impl.h"
+#include "net/mmt/mmt_transaction_factory.h"
+
+namespace net {
+
+class MmtTransactionFactoryImpl : public MmtTransactionFactory {
+public:
+  MmtTransactionFactoryImpl() : suspended_(false) {
+  }
+  virtual ~MmtTransactionFactoryImpl() override {
+  }
+
+  virtual MmtTransaction* CreateTransaction() override {
+    if (suspended_)
+      return NULL;
+
+    return new MmtTransactionImpl();
+  }
+
+  virtual void Suspend(bool suspend) override {
+    suspended_ = suspend;
+  }
+
+private:
+  bool suspended_;
+};
+
+MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
+  return new MmtTransactionFactoryImpl();
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
new file mode 100644
index 0000000..d3c225d
--- /dev/null
+++ b/net/mmt/mmt_transaction.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_H_
+#define NET_MMT_MMT_TRANSACTION_H_
+
+#include "net/base/completion_callback.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_states.h"
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtResponseInfo;
+class MmtRequestInfo;
+class BoundNetLog;
+
+// Represents a single MMT transaction.
+class NET_EXPORT_PRIVATE MmtTransaction {
+ public:
+  // Stops any pending IO and destroys the transaction object.
+  virtual ~MmtTransaction() {}
+
+  // Starts the MMT transaction (i.e., sends the MMT request).
+  //
+  // Returns OK if the transaction could be started synchronously, which means
+  // that the request was served from the cache (only supported for directory
+  // listings).  ERR_IO_PENDING is returned to indicate that the
+  // CompletionCallback will be notified once response info is available or if
+  // an IO error occurs.  Any other return value indicates that the transaction
+  // could not be started.
+  //
+  // Regardless of the return value, the caller is expected to keep the
+  // request_info object alive until Destroy is called on the transaction.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  // Profiling information for the request is saved to |net_log| if non-NULL.
+  virtual int Start(const MmtRequestInfo* request_info,
+                    const CompletionCallback& callback,
+                    const BoundNetLog& net_log) = 0;
+
+  // Once response info is available for the transaction, response data may be
+  // read by calling this method.
+  //
+  // Response data is copied into the given buffer and the number of bytes
+  // copied is returned.  ERR_IO_PENDING is returned if response data is not
+  // yet available.  The CompletionCallback is notified when the data copy
+  // completes, and it is passed the number of bytes that were successfully
+  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
+  // the error.  Any other negative return value indicates that the transaction
+  // could not be read.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  virtual int Read(IOBuffer* buf,
+                   int buf_len,
+                   const CompletionCallback& callback) = 0;
+
+  // Returns the response info for this transaction or NULL if the response
+  // info is not available.
+  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
+
+  // Returns the load state for this transaction.
+  virtual LoadState GetLoadState() const = 0;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
new file mode 100644
index 0000000..b9b1e6a
--- /dev/null
+++ b/net/mmt/mmt_transaction_factory.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
+#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
+
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtTransaction;
+
+// An interface to a class that can create MmtTransaction objects.
+class NET_EXPORT MmtTransactionFactory {
+ public:
+  virtual ~MmtTransactionFactory() {}
+
+  // Creates a MmtTransaction object.
+  virtual MmtTransaction* CreateTransaction() = 0;
+
+  // Suspends the creation of new transactions. If |suspend| is false, creation
+  // of new transactions is resumed.
+  virtual void Suspend(bool suspend) = 0;
+
+  static MmtTransactionFactory* CreateFactory();
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
new file mode 100644
index 0000000..2e512b5
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction_impl.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/compiler_specific.h"
+#include "base/metrics/histogram.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "net/base/address_list.h"
+#include "net/base/connection_type_histograms.h"
+#include "net/base/escape.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_log.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+
+//const int kMmtBufLen = 256*1024;
+
+namespace net {
+
+MmtTransactionImpl::MmtTransactionImpl() :
+      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
+                              base::Unretained(this))),
+      request_(NULL),
+      read_data_buf_len_(0),
+      next_state_(STATE_NONE)
+{}
+
+MmtTransactionImpl::~MmtTransactionImpl() {
+}
+
+int MmtTransactionImpl::Stop(int error) {
+  LOG(INFO) << "Stop";
+  next_state_ = STATE_STOP;
+  last_error_ = error;
+  return OK;
+}
+
+int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+  return ERR_NOT_IMPLEMENTED;
+}
+
+int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
+                                 const CompletionCallback& callback,
+                                 const BoundNetLog& net_log) {
+  LOG(INFO) << "Start, url=" << request_info->url;
+
+  net_log_ = net_log;
+  request_ = request_info;
+  next_state_ = STATE_CONNECT;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+
+  return OK;
+}
+
+int MmtTransactionImpl::Read(IOBuffer* buf,
+                                int buf_len,
+                                const CompletionCallback& callback) {
+  LOG(INFO) << "Read, buf_len=" << buf_len;
+  DCHECK(buf);
+  DCHECK_GT(buf_len, 0);
+
+  read_data_buf_ = buf;
+  read_data_buf_len_ = buf_len;
+
+  next_state_ = STATE_READ;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+  return rv;
+}
+
+const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
+  LOG(INFO) << "GetResponseInfo";
+  return &response_;
+}
+
+LoadState MmtTransactionImpl::GetLoadState() const {
+  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
+  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
+  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  return LOAD_STATE_IDLE;
+}
+
+void MmtTransactionImpl::ResetStateForRestart() {
+  user_callback_.Reset();
+  response_ = MmtResponseInfo();
+  read_data_buf_ = NULL;
+  read_data_buf_len_ = 0;
+  last_error_ = OK;
+  next_state_ = STATE_NONE;
+}
+
+void MmtTransactionImpl::DoCallback(int rv) {
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
+
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
+}
+
+void MmtTransactionImpl::OnIOComplete(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION(
+          "436634 MmtTransactionImpl::OnIOComplete"));
+
+  int rv = DoLoop(result);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
+}
+
+int MmtTransactionImpl::DoLoop(int result) {
+  DCHECK(next_state_ != STATE_NONE);
+
+  int rv = result;
+  do {
+    State state = next_state_;
+    next_state_ = STATE_NONE;
+    switch (state) {
+      case STATE_STOP:
+        DCHECK(rv == OK);
+        rv = DoStop();
+        break;
+      case STATE_CONNECT:
+        DCHECK(rv == OK);
+        rv = DoConnect();
+        break;
+      case STATE_CONNECT_COMPLETE:
+        rv = DoConnectComplete(rv);
+        break;
+      case STATE_READ:
+        DCHECK(rv == OK);
+        rv = DoRead();
+        break;
+      case STATE_READ_COMPLETE:
+        rv = DoReadComplete(rv);
+        break;
+      default:
+        NOTREACHED() << "bad state";
+        rv = ERR_UNEXPECTED;
+        break;
+    }
+  } while (rv != ERR_IO_PENDING);
+  return rv;
+}
+
+
+// Data Connection
+
+int MmtTransactionImpl::DoStop() {
+  next_state_ = STATE_READ;
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnect() {
+  next_state_ = STATE_CONNECT_COMPLETE;
+  // TODO: open file/network and then call io_callback_
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnectComplete(int result) {
+  if (result != OK)
+    return Stop(result);
+  return OK;
+}
+
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+
+  next_state_ = STATE_READ_COMPLETE;
+  read_data_buf_->data()[0] = 0;
+  //TODO: read data from network/file
+  return 0;
+}
+
+int MmtTransactionImpl::DoReadComplete(int result) {
+  return result;
+}
+
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
new file mode 100644
index 0000000..098ee53
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
+#define NET_MMT_MMT_TRANSACTION_IMPL_H_
+
+#include <string>
+#include <utility>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "net/base/address_list.h"
+#include "net/base/auth.h"
+#include "net/base/net_log.h"
+#include "net/dns/host_resolver.h"
+#include "net/dns/single_request_host_resolver.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+
+namespace net {
+
+class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
+ public:
+  MmtTransactionImpl();
+  virtual ~MmtTransactionImpl() override;
+
+  virtual int Stop(int error);
+  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
+
+  // MmtTransaction methods:
+  virtual int Start(const MmtRequestInfo* request_info,
+            const CompletionCallback& callback,
+            const BoundNetLog& net_log) override;
+  virtual int Read(IOBuffer* buf,
+           int buf_len,
+           const CompletionCallback& callback) override;
+  virtual const MmtResponseInfo* GetResponseInfo() const override;
+  virtual LoadState GetLoadState() const override;
+
+ private:
+  void ResetStateForRestart();
+  void DoCallback(int result);
+  void OnIOComplete(int result);
+  int DoLoop(int result);
+
+  int DoStop();
+  int DoConnect();
+  int DoConnectComplete(int result);
+  int DoRead();
+  int DoReadComplete(int result);
+
+  enum State {
+    STATE_STOP,
+    STATE_CONNECT,
+    STATE_CONNECT_COMPLETE,
+    STATE_READ,
+    STATE_READ_COMPLETE,
+    STATE_NONE
+  };
+
+private:
+  CompletionCallback io_callback_;
+  CompletionCallback user_callback_;
+
+  BoundNetLog net_log_;
+  const MmtRequestInfo* request_;
+  MmtResponseInfo response_;
+
+  scoped_refptr<IOBuffer> read_data_buf_;
+  int read_data_buf_len_;
+
+  int last_error_;
+  State next_state_;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gyp b/net/net.gyp
index 1597f24..eb27320 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -182,10 +182,6 @@
         }],
         ['disable_mmt_support==1', {
           'sources!': [
-            'base/directory_lister.cc',
-            'base/directory_lister.h',
-            'url_request/url_request_file_dir_job.cc',
-            'url_request/url_request_file_dir_job.h',
             'url_request/url_request_mmt_job.cc',
             'url_request/url_request_mmt_job.h',
             'url_request/mmt_protocol_handler.cc',
diff --git a/net/net.gypi b/net/net.gypi
index ee879d2..0d6cbf7 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1131,12 +1131,16 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1180,8 +1184,6 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 86afe03..416660f 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,48 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
-#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "net/url_request/url_request_mmt_job.h"
+#include "url/gurl.h"
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
+MmtProtocolHandler::MmtProtocolHandler() {}
 
 MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request->url(), &file_path);
-
-  // Check file access permissions.
-  if (!network_delegate ||
-      !network_delegate->CanAccessFile(*request, file_path)) {
-    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
-  }
-
-  // We need to decide whether to create URLRequestMmtJob for file access or
-  // URLRequestFileDirJob for directory access. To avoid accessing the
-  // filesystem, we only look at the path string here.
-  // The code in the URLRequestMmtJob::Start() method discovers that a path,
-  // which doesn't end with a slash, should really be treated as a directory,
-  // and it then redirects to the URLRequestFileDirJob.
-  if (is_file &&
-      file_path.EndsWithSeparator() &&
-      file_path.IsAbsolute()) {
-    return new URLRequestFileDirJob(request, network_delegate, file_path);
-  }
-
-  // Use a regular file request job for all non-directories (including invalid
-  // file names).
-  return new URLRequestMmtJob(request, network_delegate, file_path,
-                               file_task_runner_);
+  LOG(INFO) << "mmt url: " << request->url();
+  return new URLRequestMmtJob(request, network_delegate);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 28ca9b6..237c703 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,22 +12,16 @@
 
 class GURL;
 
-namespace base {
-class TaskRunner;
-}
-
 namespace net {
 
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
-// then all file requests will fail with ERR_ACCESS_DENIED.
+// Implements a ProtocolHandler for MMT jobs. 
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  explicit MmtProtocolHandler();
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +29,6 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index efb9e5c..1eda830 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -411,7 +411,7 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     if (mmt_enabled_) {
       job_factory->SetProtocolHandler(
       "mmt",
-      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+      new MmtProtocolHandler());
     }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c5b8f9c..b53b76e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -21,16 +21,12 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
-#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
@@ -38,47 +34,25 @@
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate,
-    const base::FilePath& file_path,
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    NetworkDelegate* network_delegate)
     : URLRequestJob(request, network_delegate),
-      file_path_(file_path),
-      stream_(new FileStream(file_task_runner)),
-      file_task_runner_(file_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
 void URLRequestMmtJob::Start() {
-  FileMetaInfo* meta_info = new FileMetaInfo();
-  file_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+  // TODO
+  LOG(INFO) << "Start";
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  // TODO
+  LOG(INFO) << "Kill";
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -87,6 +61,7 @@ void URLRequestMmtJob::Kill() {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
+  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
   DCHECK_GE(remaining_bytes_, 0);
@@ -101,11 +76,13 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
+  int rv = 0;
+  // TODO
+  //int rv = StreamRead(dest,
+  //                    dest_size,
+  //                    base::Bind(&URLRequestMmtJob::DidRead,
+  //                               weak_ptr_factory_.GetWeakPtr(),
+  //                               make_scoped_refptr(dest)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -125,58 +102,27 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
+  // TODO
+  LOG(INFO) << "IsRedirectResponse";
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  // TODO
+  LOG(INFO) << "SetupFilter";
+  return NULL; 
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
+  // TODO
+  LOG(INFO) << "GetMimeType";
+  *mime_type = std::string("application/x-mmt");
+  return true;
 }
 
-void URLRequestMmtJob::SetExtraRequestHeaders(
-    const HttpRequestHeaders& headers) {
+void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
+  LOG(INFO) << "SetExtraRequestHeaders";
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -197,59 +143,18 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::OnSeekComplete(int64 result) {
+  LOG(INFO) << "OnSeekComplete";
 }
 
 void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+  LOG(INFO) << "OnReadComplete";
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
-}
-
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
-  }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
 void URLRequestMmtJob::DidOpen(int result) {
+  LOG(INFO) << "DidOpen";
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
@@ -259,7 +164,8 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  int total_size = 0;
+  if (!byte_range_.ComputeBounds(total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -275,10 +181,13 @@ void URLRequestMmtJob::DidOpen(int result) {
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "423948 URLRequestMmtJob::DidOpen 1"));
 
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
+    int rv = 0; 
+    // TODO: seek to byte_range_.first_byte_position()
+    // int rv = StreamSeek(FROM_BEGIN,
+    //                     byte_range_.first_byte_position(),
+    //                     base::Bind(&URLRequestMmtJob::DidSeek,
+    //                                weak_ptr_factory_.GetWeakPtr()));
+    //  
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
       // into DidSeek().
@@ -293,6 +202,7 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
+  LOG(INFO) << "DidSeek";
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -305,6 +215,7 @@ void URLRequestMmtJob::DidSeek(int64 result) {
 }
 
 void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  LOG(INFO) << "DidRead";
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 1ff88d2..b9e871f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,7 +8,6 @@
 #include <string>
 #include <vector>
 
-#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
@@ -16,24 +15,13 @@
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
-namespace base {
-class TaskRunner;
-}
-namespace file_util {
-struct FileInfo;
-}
-
 namespace net {
 
-class FileStream;
-
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate,
-                    const base::FilePath& file_path,
-                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+                    NetworkDelegate* network_delegate);
 
   // URLRequestJob:
   void Start() override;
@@ -53,36 +41,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   int64 remaining_bytes() const { return remaining_bytes_; }
 
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
@@ -93,10 +52,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
 
-- 
1.7.9.5


From 31d7185f5b54cef7759d7a428bcc41f507c605aa Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 1 Jan 2015 00:11:27 -0800
Subject: [PATCH 05/34] write mmt module like ftp

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 +
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 +
 chrome/browser/profiles/profile_io_data.cc         |    6 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/mmt/mmt_information.h                          |    7 +
 net/mmt/mmt_transaction_impl.cc                    |   37 ++-
 net/net.gypi                                       |   12 +-
 net/url_request/mmt_protocol_handler.cc            |   13 +-
 net/url_request/mmt_protocol_handler.h             |    5 +-
 net/url_request/url_request_context_builder.cc     |   12 +-
 net/url_request/url_request_context_builder.h      |    2 +
 net/url_request/url_request_mmt_job.cc             |  255 ++++++++------------
 net/url_request/url_request_mmt_job.h              |   42 ++--
 15 files changed, 213 insertions(+), 216 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index 798bea3..d47b636 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,6 +261,11 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -270,7 +275,8 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -328,7 +334,8 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -368,7 +375,8 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get());
+                                            ftp_factory_.get(),
+                                            mmt_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index 900dbfc..fa54638 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,6 +21,7 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -146,6 +147,7 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 8b39439..4f21760 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,6 +54,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -581,6 +582,11 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -597,7 +603,8 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -662,7 +669,8 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -749,7 +757,8 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get()));
+                              ftp_factory_.get(),
+                              mmt_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 383fc40..505da31 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,6 +34,7 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -229,6 +230,7 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 9d89cb3..2b8537b 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,7 +1162,8 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory,
+    net::MmtTransactionFactory* mmt_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1217,9 +1218,10 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
+  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler());
+      new net::MmtProtocolHandler(mmt_transaction_factory));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index 244107f..fcc9fef 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,6 +34,7 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
+#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -60,6 +61,7 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -358,7 +360,8 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory,
+      net::MmtTransactionFactory* mmt_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 60ed7e4..92d7e17 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -17,7 +17,14 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
+  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  }
 
+  // Expected content size, in bytes, as reported by SIZE command. Only valid
+  // for file downloads. -1 means unknown size.
+  int64 expected_content_size;
+
+  bool is_local;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index 2e512b5..aef7733 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -38,7 +38,7 @@ MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << "Stop";
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
@@ -51,14 +51,16 @@ int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callb
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                                  const CompletionCallback& callback,
                                  const BoundNetLog& net_log) {
-  LOG(INFO) << "Start, url=" << request_info->url;
+  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
 
   net_log_ = net_log;
   request_ = request_info;
   next_state_ = STATE_CONNECT;
+#if 0
   int rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
 
   return OK;
 }
@@ -66,7 +68,7 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
 int MmtTransactionImpl::Read(IOBuffer* buf,
                                 int buf_len,
                                 const CompletionCallback& callback) {
-  LOG(INFO) << "Read, buf_len=" << buf_len;
+  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
@@ -74,21 +76,32 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_len_ = buf_len;
 
   next_state_ = STATE_READ;
-  int rv = DoLoop(OK);
+  int rv = OK;
+#if 0
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << "GetResponseInfo";
+  LOG(INFO) << __FUNCTION__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
-  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
-  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  switch (next_state_) {
+    case STATE_NONE: 
+      return LOAD_STATE_IDLE;
+    case STATE_CONNECT:
+      return LOAD_STATE_CONNECTING; 
+    case STATE_READ:
+      return LOAD_STATE_READING_RESPONSE;
+    default: 
+      break;
+  }
   return LOAD_STATE_IDLE;
 }
 
@@ -112,6 +125,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -161,35 +175,40 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_CONNECT_COMPLETE;
   // TODO: open file/network and then call io_callback_
   return OK;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
+  LOG(INFO) << __FUNCTION__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
   //TODO: read data from network/file
+  // impement one callback to mmt receiver
   return 0;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   return result;
 }
 
-
 }  // namespace net
diff --git a/net/net.gypi b/net/net.gypi
index 0d6cbf7..0335fc6 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,8 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1131,12 +1133,6 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
@@ -1145,6 +1141,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1190,6 +1188,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 416660f..a671486 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,21 @@
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler() {}
+MmtProtocolHandler::MmtProtocolHandler(
+    MmtTransactionFactory* mmt_transaction_factory)
+    : mmt_transaction_factory_(mmt_transaction_factory) {
+  DCHECK(mmt_transaction_factory_);
+}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
   LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request, network_delegate);
+  return new URLRequestMmtJob(request,
+                              network_delegate,
+                              mmt_transaction_factory_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 237c703..10bfe1d 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -14,6 +14,7 @@ class GURL;
 
 namespace net {
 
+class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
@@ -21,7 +22,7 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler();
+  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -29,6 +30,8 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
+  MmtTransactionFactory* mmt_transaction_factory_;
+
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 1eda830..dee151e 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,6 +18,7 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -408,11 +409,12 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-    if (mmt_enabled_) {
-      job_factory->SetProtocolHandler(
-      "mmt",
-      new MmtProtocolHandler());
-    }
+  if (mmt_enabled_) {
+    mmt_transaction_factory_.reset(
+        MmtTransactionFactory::CreateFactory());
+    job_factory->SetProtocolHandler("mmt",
+        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+  }
 #endif
 
   storage->set_job_factory(job_factory);
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index 2aff0dd..c2cec99 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -226,6 +227,7 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
+  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b53b76e..6b14fdd 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,8 +31,15 @@
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_transaction_factory.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
 #include "url/gurl.h"
 
@@ -40,198 +47,126 @@ namespace net {
 
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate)
+    NetworkDelegate* network_delegate,
+    MmtTransactionFactory* mmt_transaction_factory)
     : URLRequestJob(request, network_delegate),
-      remaining_bytes_(0),
-      weak_ptr_factory_(this) {}
-
-void URLRequestMmtJob::Start() {
-  // TODO
-  LOG(INFO) << "Start";
-}
-
-void URLRequestMmtJob::Kill() {
-  // TODO
-  LOG(INFO) << "Kill";
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
+      read_in_progress_(false),
+      mmt_transaction_factory_(mmt_transaction_factory),
+      weak_ptr_factory_(this) {
+  DCHECK(mmt_transaction_factory);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
-                                    int dest_size,
-                                    int* bytes_read) {
-  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
-  DCHECK_NE(dest_size, 0);
-  DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size) {
-    *bytes_read = 0;
-    return true;
-  }
-
-  int rv = 0;
-  // TODO
-  //int rv = StreamRead(dest,
-  //                    dest_size,
-  //                    base::Bind(&URLRequestMmtJob::DidRead,
-  //                               weak_ptr_factory_.GetWeakPtr(),
-  //                               make_scoped_refptr(dest)));
-  if (rv >= 0) {
-    // Data is immediately available.
-    *bytes_read = rv;
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-    return true;
-  }
-
-  // Otherwise, a read error occured.  We may just need to wait...
-  if (rv == ERR_IO_PENDING) {
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
-  return false;
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  // TODO
-  LOG(INFO) << "IsRedirectResponse";
+#if 0
+bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
+  // Disallow all redirects.
   return false;
 }
-
-Filter* URLRequestMmtJob::SetupFilter() const {
-  // TODO
-  LOG(INFO) << "SetupFilter";
-  return NULL; 
-}
+#endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  DCHECK(request_);
-  // TODO
   LOG(INFO) << "GetMimeType";
-  *mime_type = std::string("application/x-mmt");
-  return true;
-}
-
-void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
-  LOG(INFO) << "SetExtraRequestHeaders";
-  std::string range_header;
-  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
-    // We only care about "Range" header here.
-    std::vector<HttpByteRange> ranges;
-    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        // We don't support multiple range requests in one single URL request,
-        // because we need to do multipart encoding here.
-        // TODO(hclam): decide whether we want to support multiple range
-        // requests.
-        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-      }
-    }
+  DCHECK(request_);
+  if (mmt_transaction_->GetResponseInfo()->is_local) {
+    *mime_type = "text/vnd.chromium.local";
+    return true;
   }
+  return false;
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-  LOG(INFO) << "OnSeekComplete";
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << "Start";
+  DCHECK(!mmt_transaction_);
+  StartMmtTransaction();
 }
 
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-  LOG(INFO) << "OnReadComplete";
-}
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << "Kill";
+  if (mmt_transaction_)
+    mmt_transaction_.reset();
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
-void URLRequestMmtJob::DidOpen(int result) {
-  LOG(INFO) << "DidOpen";
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
-
-  if (result != OK) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-    return;
+int URLRequestMmtJob::StartMmtTransaction() {
+  // Create a transaction.
+  DCHECK(!mmt_transaction_);
+  mmt_request_info_.url = request_->url();
+  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+
+  // No matter what, we want to report our status as IO pending since we will
+  // be notifying our consumer asynchronously via OnStartCompleted.
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  int rv = ERR_FAILED;
+  if (mmt_transaction_) {
+    rv = mmt_transaction_->Start(
+        &mmt_request_info_,
+        base::Bind(&URLRequestMmtJob::OnStartCompleted,
+                   base::Unretained(this)),
+        request_->net_log());
+    if (rv == ERR_IO_PENDING)
+      return rv;
   }
+  return rv;
+}
 
-  int total_size = 0;
-  if (!byte_range_.ComputeBounds(total_size)) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
+void URLRequestMmtJob::OnStartCompleted(int result) {
+  // Clear the IO_PENDING status
+  SetStatus(URLRequestStatus());
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
-                     byte_range_.first_byte_position() + 1;
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = 0; 
-    // TODO: seek to byte_range_.first_byte_position()
-    // int rv = StreamSeek(FROM_BEGIN,
-    //                     byte_range_.first_byte_position(),
-    //                     base::Bind(&URLRequestMmtJob::DidSeek,
-    //                                weak_ptr_factory_.GetWeakPtr()));
-    //  
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
+  // Note that mmt_transaction_ may be NULL due to a creation failure.
+  if (mmt_transaction_) {
+    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+    // the content size information manually.
+    set_expected_content_size(
+        mmt_transaction_->GetResponseInfo()->expected_content_size);
   }
-}
 
-void URLRequestMmtJob::DidSeek(int64 result) {
-  LOG(INFO) << "DidSeek";
-  OnSeekComplete(result);
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
+  if (result == OK) {
+    NotifyHeadersComplete();
+  }else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
   }
-
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  LOG(INFO) << "DidRead";
-  if (result > 0) {
-    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  OnReadComplete(buf.get(), result);
-  buf = NULL;
-
+void URLRequestMmtJob::OnReadCompleted(int result) {
+  read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  } else {
+    // Clear the IO_PENDING status
+    SetStatus(URLRequestStatus());
+  }
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
+                                    int buf_size,
+                                    int* bytes_read) {
+  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  DCHECK_NE(buf_size, 0);
+  DCHECK(bytes_read);
+  DCHECK(!read_in_progress_);
+
+  int rv = mmt_transaction_->Read(buf, buf_size,
+                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
+                                             base::Unretained(this)));
+  if (rv >= 0) {
+    *bytes_read = rv;
+    return true;
   }
 
-  NotifyReadComplete(result);
+  if (rv == ERR_IO_PENDING) {
+    read_in_progress_ = true;
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index b9e871f..cf3036e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -11,50 +11,46 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
 namespace net {
 
+class NetworkDelegate;
+class MmtTransactionFactory;
+
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate);
+                   NetworkDelegate* network_delegate,
+                   MmtTransactionFactory* mmt_transaction_factory);
+
+ protected:
+  ~URLRequestMmtJob() override;
 
-  // URLRequestJob:
+  // Overridden from URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
-
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
- protected:
-  ~URLRequestMmtJob() override;
-
-  int64 remaining_bytes() const { return remaining_bytes_; }
 
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
+  int StartMmtTransaction();
+  void OnStartCompleted(int result);
+  void OnReadCompleted(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+ private:
+  MmtRequestInfo mmt_request_info_;
+  scoped_ptr<MmtTransaction> mmt_transaction_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
+  bool read_in_progress_;
 
+  MmtTransactionFactory* mmt_transaction_factory_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From 98f736ef3da53d6612b334658ba702e4ee2fcd1f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 2 Jan 2015 21:03:24 -0800
Subject: [PATCH 06/34] to implement mmt with the support of local file

---
 .gitignore                             |    2 +
 net/mmt/mmt_transaction_impl.cc        |   86 +++++++++++++++++++++-----------
 net/mmt/mmt_transaction_impl.h         |    4 ++
 net/url_request/url_request_mmt_job.cc |   26 ++++++----
 4 files changed, 80 insertions(+), 38 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8fa6763..a0181c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -437,3 +437,5 @@ v8.log
 /win8/metro_driver/metro_driver_version_resources.xml
 /x86-generic_out/
 /xcodebuild
+.xtags
+diff.log
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index aef7733..d927ab4 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -14,6 +14,12 @@
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
 #include "net/base/address_list.h"
 #include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
@@ -31,67 +37,66 @@ MmtTransactionImpl::MmtTransactionImpl() :
                               base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
-      next_state_(STATE_NONE)
-{}
+      next_state_(STATE_NONE) {
+}
 
 MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", error=" << error;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
 }
 
-int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+int MmtTransactionImpl::RestartIgnoringLastError(
+    const CompletionCallback& callback) {
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                                 const CompletionCallback& callback,
-                                 const BoundNetLog& net_log) {
-  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
-
+                              const CompletionCallback& callback,
+                              const BoundNetLog& net_log) {
+  LOG(INFO) << __func__ << ", url=" << request_info->url;
   net_log_ = net_log;
   request_ = request_info;
+
+  int rv = OK;
   next_state_ = STATE_CONNECT;
-#if 0
-  int rv = DoLoop(OK);
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
 
-  return OK;
+  return rv;
 }
 
+// @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
-                                int buf_len,
-                                const CompletionCallback& callback) {
-  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
+                             int buf_len,
+                             const CompletionCallback& callback) {
+  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
 
-  next_state_ = STATE_READ;
   int rv = OK;
-#if 0
+  next_state_ = STATE_READ;
   rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,7 +130,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -175,39 +180,62 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  LOG(INFO) << __func__ << ", is_file=" << is_file;
+  if (!is_file) {
+    return ERR_FAILED;
+  }
+
   next_state_ = STATE_CONNECT_COMPLETE;
-  // TODO: open file/network and then call io_callback_
-  return OK;
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path, flags, io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoConnectComplete(rv);
+  }
+  LOG(INFO) << __func__ << ", rv=" << rv;
+  return rv;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
+
   //TODO: read data from network/file
   // impement one callback to mmt receiver
-  return 0;
+  int rv = stream_->Read(read_data_buf_.get(),
+                         read_data_buf_len_,
+                         io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoReadComplete(rv);
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   return result;
 }
 
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 098ee53..fc25de2 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -22,6 +22,8 @@
 
 namespace net {
 
+class FileStream;
+
 class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
  public:
   MmtTransactionImpl();
@@ -69,6 +71,8 @@ private:
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
 
+  scoped_ptr<FileStream> stream_;
+
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6b14fdd..0fdb5a9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,8 +67,8 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << "GetMimeType";
-  DCHECK(request_);
+  LOG(INFO) << __FUNCTION__;
+  DCHECK(!mmt_transaction_);
   if (mmt_transaction_->GetResponseInfo()->is_local) {
     *mime_type = "text/vnd.chromium.local";
     return true;
@@ -77,13 +77,12 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << "Start";
-  DCHECK(!mmt_transaction_);
+  LOG(INFO) << __FUNCTION__;
   StartMmtTransaction();
 }
 
 void URLRequestMmtJob::Kill() {
-  LOG(INFO) << "Kill";
+  LOG(INFO) << __FUNCTION__;
   if (mmt_transaction_)
     mmt_transaction_.reset();
 
@@ -92,8 +91,12 @@ void URLRequestMmtJob::Kill() {
 }
 
 int URLRequestMmtJob::StartMmtTransaction() {
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(!mmt_transaction_);
+
+  // Create a transaction.
+  DCHECK(request_);
+  DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
 
@@ -107,13 +110,15 @@ int URLRequestMmtJob::StartMmtTransaction() {
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-    if (rv == ERR_IO_PENDING)
-      return rv;
   }
+  
+  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
   return rv;
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
@@ -133,6 +138,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -147,7 +154,8 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
+
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-- 
1.7.9.5


From 703dcc0d46897a4fce93a647879bc12bb546ec7e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 5 Jan 2015 07:06:50 -0800
Subject: [PATCH 07/34] done to support mmt local file

---
 net/mmt/mmt_information.h              |   15 ++-
 net/mmt/mmt_transaction.h              |    3 +
 net/mmt/mmt_transaction_impl.cc        |  224 ++++++++++++++++++--------------
 net/mmt/mmt_transaction_impl.h         |   17 +--
 net/url_request/url_request_mmt_job.cc |   80 ++++++------
 net/url_request/url_request_mmt_job.h  |    2 +-
 6 files changed, 189 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 92d7e17..3cf1f4d 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -6,6 +6,8 @@
 #define NET_MMT_MMT_INFORMATION_H_
 
 #include "url/gurl.h"
+#include "base/files/file_path.h"
+#include "net/http/http_byte_range.h"
 
 namespace net {
 
@@ -17,14 +19,17 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
-  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  MmtResponseInfo() {
+    total_size = 0;
+    read_offset = 0;
+    expected_content_size = 0;
   }
 
-  // Expected content size, in bytes, as reported by SIZE command. Only valid
-  // for file downloads. -1 means unknown size.
+  int64 total_size;
+  int64 read_offset;
   int64 expected_content_size;
-
-  bool is_local;
+  HttpByteRange byte_range;
+  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index d3c225d..9e45cbf 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -15,6 +15,7 @@ namespace net {
 class MmtResponseInfo;
 class MmtRequestInfo;
 class BoundNetLog;
+class HttpByteRange;
 
 // Represents a single MMT transaction.
 class NET_EXPORT_PRIVATE MmtTransaction {
@@ -64,6 +65,8 @@ class NET_EXPORT_PRIVATE MmtTransaction {
 
   // Returns the load state for this transaction.
   virtual LoadState GetLoadState() const = 0;
+
+  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index d927ab4..a090386 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -16,78 +16,92 @@
 #include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "base/threading/thread.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/address_list.h"
-#include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
 #include "net/mmt/mmt_information.h"
 
-//const int kMmtBufLen = 256*1024;
 
 namespace net {
 
 MmtTransactionImpl::MmtTransactionImpl() :
-      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
-                              base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
+  base::ThreadRestrictions::SetIOAllowed(true);
+  thread_.reset(new base::Thread("MMT Thread"));
+  thread_->StartWithOptions(
+      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
+  response_ = MmtResponseInfo();
+  stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
+  LOG(INFO) << __func__;
+  Stop(OK);
 }
 
 int MmtTransactionImpl::Stop(int error) {
   LOG(INFO) << __func__ << ", error=" << error;
-  next_state_ = STATE_STOP;
+
   last_error_ = error;
-  return OK;
+  next_state_ = STATE_STOP;
+  int rv = DoStop();
+  return rv;
 }
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
+  LOG(INFO) << __func__;
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                               const CompletionCallback& callback,
                               const BoundNetLog& net_log) {
-  LOG(INFO) << __func__ << ", url=" << request_info->url;
-  net_log_ = net_log;
   request_ = request_info;
+  user_callback_ = callback;
+  net_log_ = net_log;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_CONNECT;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  int rv = DoConnect();
+  DoCallback(rv);
+  return true;
+#endif
 }
 
 // @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
                              int buf_len,
                              const CompletionCallback& callback) {
-  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
-
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
+  user_callback_ = callback;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_READ;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOComplete,
+                   base::Unretained(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  return DoRead();
+#endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
@@ -110,7 +124,15 @@ LoadState MmtTransactionImpl::GetLoadState() const {
   return LOAD_STATE_IDLE;
 }
 
+void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
+  LOG(INFO) << __func__ 
+    << " range[" << range.first_byte_position() 
+    << ", "  << range.last_byte_position() << "]";
+  response_.byte_range = range;
+}
+
 void MmtTransactionImpl::ResetStateForRestart() {
+  LOG(INFO) << __func__ ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -119,26 +141,76 @@ void MmtTransactionImpl::ResetStateForRestart() {
   next_state_ = STATE_NONE;
 }
 
-void MmtTransactionImpl::DoCallback(int rv) {
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
+int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __func__;
+  next_state_ = STATE_NONE;
+  if (stream_) {
+    fclose((FILE*)stream_);
+    stream_ = nullptr;
+  }
+  return OK;
+}
 
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
+int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  if (!is_file) {
+    LOG(ERROR) << __func__ << ", invalid file";
+    return ERR_FAILED;
+  }
+  response_.file_path = file_path;
+
+  int64 file_size = 0;
+  if(!base::GetFileSize(file_path, &file_size)) {
+    LOG(ERROR) << __func__ << ", invalid file size";
+    return ERR_FAILED;
+  }
+
+  response_.total_size = file_size;
+  HttpByteRange byte_range = response_.byte_range;
+  if (!byte_range.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+  }
+
+  if (byte_range.first_byte_position() >= 0) {
+    response_.read_offset = byte_range.first_byte_position();
+  }else {
+    response_.read_offset = 0;
+  }
+  response_.expected_content_size = response_.total_size - response_.read_offset;
+  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
+        << ", total_size=" << response_.total_size
+        << ", content_size=" << response_.expected_content_size;
+
+  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  if (!fp) {
+    LOG(ERROR) << __func__ << ", fail to open file";
+    return ERR_FAILED;
+  }
+  stream_ = (void*)fp;
+
+  return OK;
 }
 
-void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION(
-          "436634 MmtTransactionImpl::OnIOComplete"));
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+  DCHECK(stream_);
+  read_data_buf_->data()[0] = 0;
 
-  int rv = DoLoop(result);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
+  FILE *fp = (FILE *)stream_;
+  int64 offset = response_.read_offset;
+  fseek(fp, offset, SEEK_SET);
+  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
+  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  if (rv > 0) {
+    response_.read_offset += rv;
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoLoop(int result) {
@@ -157,86 +229,38 @@ int MmtTransactionImpl::DoLoop(int result) {
         DCHECK(rv == OK);
         rv = DoConnect();
         break;
-      case STATE_CONNECT_COMPLETE:
-        rv = DoConnectComplete(rv);
-        break;
       case STATE_READ:
         DCHECK(rv == OK);
         rv = DoRead();
         break;
-      case STATE_READ_COMPLETE:
-        rv = DoReadComplete(rv);
-        break;
       default:
         NOTREACHED() << "bad state";
         rv = ERR_UNEXPECTED;
         break;
     }
-  } while (rv != ERR_IO_PENDING);
+  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
   return rv;
 }
 
-
-// Data Connection
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
-  next_state_ = STATE_READ;
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
-
-  // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  LOG(INFO) << __func__ << ", is_file=" << is_file;
-  if (!is_file) {
-    return ERR_FAILED;
-  }
-
-  next_state_ = STATE_CONNECT_COMPLETE;
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path, flags, io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoConnectComplete(rv);
-  }
+void MmtTransactionImpl::DoCallback(int rv) {
   LOG(INFO) << __func__ << ", rv=" << rv;
-  return rv;
-}
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
 
-int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  if (result != OK)
-    return Stop(result);
-  return OK;
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
 }
 
-int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __func__;
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-
-  next_state_ = STATE_READ_COMPLETE;
-  read_data_buf_->data()[0] = 0;
-
-  //TODO: read data from network/file
-  // impement one callback to mmt receiver
-  int rv = stream_->Read(read_data_buf_.get(),
-                         read_data_buf_len_,
-                         io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoReadComplete(rv);
-  }
-  return rv;
+void MmtTransactionImpl::OnIOPrepare() {
 }
 
-int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  return result;
+void MmtTransactionImpl::OnIOComplete() {
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  int rv = DoLoop(OK);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
 }
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index fc25de2..1f98423 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,6 +20,10 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
+namespace base {
+class Thread;
+}
+
 namespace net {
 
 class FileStream;
@@ -41,25 +45,22 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
            const CompletionCallback& callback) override;
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
+  virtual void SetRequestHeaders(HttpByteRange &range) override;
 
  private:
   void ResetStateForRestart();
+  void OnIOPrepare();
+  void OnIOComplete();
   void DoCallback(int result);
-  void OnIOComplete(int result);
   int DoLoop(int result);
-
   int DoStop();
   int DoConnect();
-  int DoConnectComplete(int result);
   int DoRead();
-  int DoReadComplete(int result);
 
   enum State {
     STATE_STOP,
     STATE_CONNECT,
-    STATE_CONNECT_COMPLETE,
     STATE_READ,
-    STATE_READ_COMPLETE,
     STATE_NONE
   };
 
@@ -70,9 +71,9 @@ private:
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
+  scoped_ptr<base::Thread> thread_;
 
-  scoped_ptr<FileStream> stream_;
-
+  void* stream_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0fdb5a9..051fcba 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,31 +67,33 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(!mmt_transaction_);
-  if (mmt_transaction_->GetResponseInfo()->is_local) {
-    *mime_type = "text/vnd.chromium.local";
-    return true;
-  }
   return false;
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  StartMmtTransaction();
-}
-
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  if (mmt_transaction_)
-    mmt_transaction_.reset();
-
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  LOG(INFO) << __func__;
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
 }
 
-int URLRequestMmtJob::StartMmtTransaction() {
-  LOG(INFO) << __FUNCTION__;
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << __func__;
   DCHECK(!mmt_transaction_);
 
   // Create a transaction.
@@ -99,36 +101,38 @@ int URLRequestMmtJob::StartMmtTransaction() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  int rv = ERR_FAILED;
-  if (mmt_transaction_) {
-    rv = mmt_transaction_->Start(
+  mmt_transaction_->Start(
         &mmt_request_info_,
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-  }
-  
-  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
-  return rv;
+}
+
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << __FUNCTION__;
+  mmt_transaction_.reset();
+
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  DCHECK(mmt_transaction_);
+
+  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
-  // Note that mmt_transaction_ may be NULL due to a creation failure.
-  if (mmt_transaction_) {
-    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-    // the content size information manually.
-    set_expected_content_size(
-        mmt_transaction_->GetResponseInfo()->expected_content_size);
-  }
+  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+  // the content size information manually.
+  set_expected_content_size(content_size);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -141,7 +145,7 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
   LOG(INFO) << __FUNCTION__ << ", result=" << result;
 
   read_in_progress_ = false;
-  if (result == 0) {
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -149,16 +153,16 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
     // Clear the IO_PENDING status
     SetStatus(URLRequestStatus());
   }
+  NotifyReadComplete(result);
 }
 
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
-
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
+  DCHECK(mmt_transaction_);
 
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cf3036e..6630861 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -37,9 +37,9 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
-  int StartMmtTransaction();
   void OnStartCompleted(int result);
   void OnReadCompleted(int result);
 
-- 
1.7.9.5


From c104100b2c0308afa500558d75b42b8a9bf488ac Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 05:58:52 -0800
Subject: [PATCH 08/34] TODO: support async io

---
 chrome/browser/profiles/profile_io_data.cc     |    6 +-
 net/mmt/mmt_information.h                      |    4 +-
 net/mmt/mmt_transaction.h                      |    6 ++
 net/mmt/mmt_transaction_impl.cc                |  122 ++++++++++++------------
 net/mmt/mmt_transaction_impl.h                 |    9 +-
 net/url_request/mmt_protocol_handler.cc        |    9 +-
 net/url_request/mmt_protocol_handler.h         |    9 +-
 net/url_request/url_request_context_builder.cc |    3 +-
 net/url_request/url_request_mmt_job.cc         |   12 ++-
 net/url_request/url_request_mmt_job.h          |    5 +-
 10 files changed, 110 insertions(+), 75 deletions(-)

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 2b8537b..7cb34a4 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1221,7 +1221,11 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
   DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(mmt_transaction_factory));
+      new net::MmtProtocolHandler(
+            mmt_transaction_factory,
+            content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 3cf1f4d..514a185 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -22,14 +22,14 @@ class MmtResponseInfo {
   MmtResponseInfo() {
     total_size = 0;
     read_offset = 0;
+    remaining_bytes = 0;
     expected_content_size = 0;
   }
 
   int64 total_size;
   int64 read_offset;
+  int64 remaining_bytes;
   int64 expected_content_size;
-  HttpByteRange byte_range;
-  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index 9e45cbf..05a07fd 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -10,6 +10,11 @@
 #include "net/base/load_states.h"
 #include "net/base/net_export.h"
 
+
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtResponseInfo;
@@ -67,6 +72,7 @@ class NET_EXPORT_PRIVATE MmtTransaction {
   virtual LoadState GetLoadState() const = 0;
 
   virtual void SetRequestHeaders(HttpByteRange &range) = 0;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index a090386..ee2274c 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -6,23 +6,15 @@
 
 #include "base/bind.h"
 #include "base/bind_helpers.h"
-#include "base/compiler_specific.h"
-#include "base/metrics/histogram.h"
-#include "base/profiler/scoped_tracker.h"
-#include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/thread_task_runner_handle.h"
-#include "base/threading/thread.h"
+#include "base/threading/thread_restrictions.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
@@ -31,25 +23,26 @@
 
 namespace net {
 
+#ifndef TAG
+#define TAG "["<<__func__<<" thiz="<<this<<"]"
+#endif
+
 MmtTransactionImpl::MmtTransactionImpl() :
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
   base::ThreadRestrictions::SetIOAllowed(true);
-  thread_.reset(new base::Thread("MMT Thread"));
-  thread_->StartWithOptions(
-      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
   response_ = MmtResponseInfo();
   stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
-  LOG(INFO) << __func__;
   Stop(OK);
+  LOG(INFO) << TAG;
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __func__ << ", error=" << error;
+  LOG(INFO) << TAG << ", error=" << error;
 
   last_error_ = error;
   next_state_ = STATE_STOP;
@@ -59,7 +52,7 @@ int MmtTransactionImpl::Stop(int error) {
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return ERR_NOT_IMPLEMENTED;
 }
 
@@ -69,13 +62,15 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
   request_ = request_info;
   user_callback_ = callback;
   net_log_ = net_log;
-
-#if 0
   next_state_ = STATE_CONNECT;
-  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
         base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
-  return bpost ? OK : ERR_FAILED;
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   int rv = DoConnect();
   DoCallback(rv);
@@ -92,25 +87,33 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
   user_callback_ = callback;
-
-#if 0
   next_state_ = STATE_READ;
-  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOComplete,
-                   base::Unretained(this)));
-  return bpost ? OK : ERR_FAILED;
+
+  if (response_.remaining_bytes < buf_len)
+    buf_len = static_cast<int>(response_.remaining_bytes);
+    
+  if (buf_len <= 0)
+    return 0;
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   return DoRead();
 #endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,14 +128,18 @@ LoadState MmtTransactionImpl::GetLoadState() const {
 }
 
 void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << __func__ 
+  LOG(INFO) << TAG 
     << " range[" << range.first_byte_position() 
     << ", "  << range.last_byte_position() << "]";
-  response_.byte_range = range;
+  byte_range_ = range;
+}
+
+void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
+  task_runner_ = runner;
 }
 
 void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << __func__ ;
+  LOG(INFO) << TAG ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -142,7 +149,7 @@ void MmtTransactionImpl::ResetStateForRestart() {
 }
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   next_state_ = STATE_NONE;
   if (stream_) {
     fclose((FILE*)stream_);
@@ -152,46 +159,42 @@ int MmtTransactionImpl::DoStop() {
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
+  LOG(INFO) << TAG << ", url=" << request_->url;
 
   // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  if (!is_file) {
-    LOG(ERROR) << __func__ << ", invalid file";
+  if(!FileURLToFilePath(request_->url, &file_path_)) {
+    LOG(ERROR) << TAG << ", invalid file";
     return ERR_FAILED;
   }
-  response_.file_path = file_path;
 
-  int64 file_size = 0;
-  if(!base::GetFileSize(file_path, &file_size)) {
-    LOG(ERROR) << __func__ << ", invalid file size";
+  response_.total_size = 0;
+  if(!base::GetFileSize(file_path_, &response_.total_size)) {
+    LOG(ERROR) << TAG << ", invalid file size";
     return ERR_FAILED;
   }
 
-  response_.total_size = file_size;
-  HttpByteRange byte_range = response_.byte_range;
-  if (!byte_range.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+  if (!byte_range_.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
     return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
   }
 
-  if (byte_range.first_byte_position() >= 0) {
-    response_.read_offset = byte_range.first_byte_position();
-  }else {
-    response_.read_offset = 0;
-  }
-  response_.expected_content_size = response_.total_size - response_.read_offset;
-  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
-        << ", total_size=" << response_.total_size
-        << ", content_size=" << response_.expected_content_size;
+  response_.read_offset = byte_range_.first_byte_position();
+  response_.remaining_bytes = byte_range_.last_byte_position() -
+    byte_range_.first_byte_position() + 1;
+  DCHECK_GE(response_.remaining_bytes, 0);
+
+  LOG(INFO) << TAG 
+    << ", total_size=" << response_.total_size
+    << ", read_offset=" << response_.read_offset
+    << ", content_size=" << response_.expected_content_size;
 
-  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  FILE *fp = base::OpenFile(file_path_, "rb");
   if (!fp) {
-    LOG(ERROR) << __func__ << ", fail to open file";
+    LOG(ERROR) << TAG << ", fail to open file";
     return ERR_FAILED;
   }
   stream_ = (void*)fp;
+  response_.expected_content_size = response_.remaining_bytes;
 
   return OK;
 }
@@ -206,9 +209,10 @@ int MmtTransactionImpl::DoRead() {
   int64 offset = response_.read_offset;
   fseek(fp, offset, SEEK_SET);
   int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
   if (rv > 0) {
     response_.read_offset += rv;
+    response_.remaining_bytes -= rv;
   }
   return rv;
 }
@@ -243,7 +247,7 @@ int MmtTransactionImpl::DoLoop(int result) {
 }
 
 void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << __func__ << ", rv=" << rv;
+  LOG(INFO) << TAG << ", rv=" << rv;
   DCHECK(rv != ERR_IO_PENDING);
   DCHECK(!user_callback_.is_null());
 
@@ -257,7 +261,7 @@ void MmtTransactionImpl::OnIOPrepare() {
 }
 
 void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   int rv = DoLoop(OK);
   if (rv != ERR_IO_PENDING)
     DoCallback(rv);
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 1f98423..adbe735 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,9 +20,6 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
-namespace base {
-class Thread;
-}
 
 namespace net {
 
@@ -46,6 +43,7 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
   virtual void SetRequestHeaders(HttpByteRange &range) override;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
 
  private:
   void ResetStateForRestart();
@@ -65,15 +63,16 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   };
 
 private:
-  CompletionCallback io_callback_;
   CompletionCallback user_callback_;
+  scoped_refptr<base::TaskRunner> task_runner_;
 
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
-  scoped_ptr<base::Thread> thread_;
+  HttpByteRange byte_range_;
 
   void* stream_;
+  base::FilePath file_path_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index a671486..be497ff 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -15,8 +15,10 @@
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory)
-    : mmt_transaction_factory_(mmt_transaction_factory) {
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner) {
   DCHECK(mmt_transaction_factory_);
 }
 
@@ -28,7 +30,8 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
   LOG(INFO) << "mmt url: " << request->url();
   return new URLRequestMmtJob(request,
                               network_delegate,
-                              mmt_transaction_factory_);
+                              mmt_transaction_factory_,
+                              task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 10bfe1d..185ac8f 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,6 +12,10 @@
 
 class GURL;
 
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtTransactionFactory;
@@ -22,7 +26,9 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
+  explicit MmtProtocolHandler(
+      MmtTransactionFactory* mmt_transaction_factory,
+      const scoped_refptr<base::TaskRunner>& task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -31,6 +37,7 @@ class NET_EXPORT MmtProtocolHandler :
 
  private:
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index dee151e..4e5018f 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -413,7 +413,8 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     mmt_transaction_factory_.reset(
         MmtTransactionFactory::CreateFactory());
     job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
+                               context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 051fcba..2806657 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -48,10 +48,12 @@ namespace net {
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory)
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
       mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   DCHECK(mmt_transaction_factory);
 }
@@ -72,7 +74,6 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
-  LOG(INFO) << __func__;
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -101,6 +102,7 @@ void URLRequestMmtJob::Start() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetTaskRunner(task_runner_);
   mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
@@ -167,6 +169,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
                                              base::Unretained(this)));
+  LOG(INFO) << __func__ << ", rv=" << rv;
   if (rv >= 0) {
     *bytes_read = rv;
     return true;
@@ -181,4 +184,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   return false;
 }
 
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  return false;
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6630861..7defe8f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -27,7 +27,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
                    NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory);
+                   MmtTransactionFactory* mmt_transaction_factory,
+                   const scoped_refptr<base::TaskRunner> task_runner);
 
  protected:
   ~URLRequestMmtJob() override;
@@ -36,6 +37,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
@@ -51,6 +53,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool read_in_progress_;
 
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From a4756644ac026b657ab354dd256b0fba042e58a9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:10:33 -0800
Subject: [PATCH 09/34] remove seperate mmt

---
 net/mmt/mmt_information.h              |   37 -----
 net/mmt/mmt_transaction.cc             |   37 -----
 net/mmt/mmt_transaction.h              |   80 ----------
 net/mmt/mmt_transaction_factory.h      |   31 ----
 net/mmt/mmt_transaction_impl.cc        |  270 --------------------------------
 net/mmt/mmt_transaction_impl.h         |   85 ----------
 net/net.gypi                           |    2 -
 net/url_request/url_request_mmt_job.cc |   81 +++++-----
 net/url_request/url_request_mmt_job.h  |   12 +-
 9 files changed, 51 insertions(+), 584 deletions(-)
 delete mode 100644 net/mmt/mmt_information.h
 delete mode 100644 net/mmt/mmt_transaction.cc
 delete mode 100644 net/mmt/mmt_transaction.h
 delete mode 100644 net/mmt/mmt_transaction_factory.h
 delete mode 100644 net/mmt/mmt_transaction_impl.cc
 delete mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
deleted file mode 100644
index 514a185..0000000
--- a/net/mmt/mmt_information.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2010 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_INFORMATION_H_
-#define NET_MMT_MMT_INFORMATION_H_
-
-#include "url/gurl.h"
-#include "base/files/file_path.h"
-#include "net/http/http_byte_range.h"
-
-namespace net {
-
-class MmtRequestInfo {
- public:
-  // The requested URL.
-  GURL url;
-};
-
-class MmtResponseInfo {
- public:
-  MmtResponseInfo() {
-    total_size = 0;
-    read_offset = 0;
-    remaining_bytes = 0;
-    expected_content_size = 0;
-  }
-
-  int64 total_size;
-  int64 read_offset;
-  int64 remaining_bytes;
-  int64 expected_content_size;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
deleted file mode 100644
index 1f0e8c7..0000000
--- a/net/mmt/mmt_transaction.cc
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2008 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction.h"
-#include "net/mmt/mmt_transaction_impl.h"
-#include "net/mmt/mmt_transaction_factory.h"
-
-namespace net {
-
-class MmtTransactionFactoryImpl : public MmtTransactionFactory {
-public:
-  MmtTransactionFactoryImpl() : suspended_(false) {
-  }
-  virtual ~MmtTransactionFactoryImpl() override {
-  }
-
-  virtual MmtTransaction* CreateTransaction() override {
-    if (suspended_)
-      return NULL;
-
-    return new MmtTransactionImpl();
-  }
-
-  virtual void Suspend(bool suspend) override {
-    suspended_ = suspend;
-  }
-
-private:
-  bool suspended_;
-};
-
-MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
-  return new MmtTransactionFactoryImpl();
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
deleted file mode 100644
index 05a07fd..0000000
--- a/net/mmt/mmt_transaction.h
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_H_
-#define NET_MMT_MMT_TRANSACTION_H_
-
-#include "net/base/completion_callback.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_states.h"
-#include "net/base/net_export.h"
-
-
-namespace base {
-class TaskRunner;
-}
-
-namespace net {
-
-class MmtResponseInfo;
-class MmtRequestInfo;
-class BoundNetLog;
-class HttpByteRange;
-
-// Represents a single MMT transaction.
-class NET_EXPORT_PRIVATE MmtTransaction {
- public:
-  // Stops any pending IO and destroys the transaction object.
-  virtual ~MmtTransaction() {}
-
-  // Starts the MMT transaction (i.e., sends the MMT request).
-  //
-  // Returns OK if the transaction could be started synchronously, which means
-  // that the request was served from the cache (only supported for directory
-  // listings).  ERR_IO_PENDING is returned to indicate that the
-  // CompletionCallback will be notified once response info is available or if
-  // an IO error occurs.  Any other return value indicates that the transaction
-  // could not be started.
-  //
-  // Regardless of the return value, the caller is expected to keep the
-  // request_info object alive until Destroy is called on the transaction.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  // Profiling information for the request is saved to |net_log| if non-NULL.
-  virtual int Start(const MmtRequestInfo* request_info,
-                    const CompletionCallback& callback,
-                    const BoundNetLog& net_log) = 0;
-
-  // Once response info is available for the transaction, response data may be
-  // read by calling this method.
-  //
-  // Response data is copied into the given buffer and the number of bytes
-  // copied is returned.  ERR_IO_PENDING is returned if response data is not
-  // yet available.  The CompletionCallback is notified when the data copy
-  // completes, and it is passed the number of bytes that were successfully
-  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
-  // the error.  Any other negative return value indicates that the transaction
-  // could not be read.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  virtual int Read(IOBuffer* buf,
-                   int buf_len,
-                   const CompletionCallback& callback) = 0;
-
-  // Returns the response info for this transaction or NULL if the response
-  // info is not available.
-  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
-
-  // Returns the load state for this transaction.
-  virtual LoadState GetLoadState() const = 0;
-
-  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
deleted file mode 100644
index b9b1e6a..0000000
--- a/net/mmt/mmt_transaction_factory.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
-#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
-
-#include "net/base/net_export.h"
-
-namespace net {
-
-class MmtTransaction;
-
-// An interface to a class that can create MmtTransaction objects.
-class NET_EXPORT MmtTransactionFactory {
- public:
-  virtual ~MmtTransactionFactory() {}
-
-  // Creates a MmtTransaction object.
-  virtual MmtTransaction* CreateTransaction() = 0;
-
-  // Suspends the creation of new transactions. If |suspend| is false, creation
-  // of new transactions is resumed.
-  virtual void Suspend(bool suspend) = 0;
-
-  static MmtTransactionFactory* CreateFactory();
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
deleted file mode 100644
index ee2274c..0000000
--- a/net/mmt/mmt_transaction_impl.cc
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction_impl.h"
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/strings/string_util.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/thread_task_runner_handle.h"
-#include "base/threading/thread_restrictions.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
-#include "net/base/net_log.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-
-
-namespace net {
-
-#ifndef TAG
-#define TAG "["<<__func__<<" thiz="<<this<<"]"
-#endif
-
-MmtTransactionImpl::MmtTransactionImpl() :
-      request_(NULL),
-      read_data_buf_len_(0),
-      next_state_(STATE_NONE) {
-  base::ThreadRestrictions::SetIOAllowed(true);
-  response_ = MmtResponseInfo();
-  stream_ = nullptr;
-}
-
-MmtTransactionImpl::~MmtTransactionImpl() {
-  Stop(OK);
-  LOG(INFO) << TAG;
-}
-
-int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << TAG << ", error=" << error;
-
-  last_error_ = error;
-  next_state_ = STATE_STOP;
-  int rv = DoStop();
-  return rv;
-}
-
-int MmtTransactionImpl::RestartIgnoringLastError(
-    const CompletionCallback& callback) {
-  LOG(INFO) << TAG;
-  return ERR_NOT_IMPLEMENTED;
-}
-
-int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                              const CompletionCallback& callback,
-                              const BoundNetLog& net_log) {
-  request_ = request_info;
-  user_callback_ = callback;
-  net_log_ = net_log;
-  next_state_ = STATE_CONNECT;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  int rv = DoConnect();
-  DoCallback(rv);
-  return true;
-#endif
-}
-
-// @return 0 if end, >0 if normal, < 0 if waiting or error
-int MmtTransactionImpl::Read(IOBuffer* buf,
-                             int buf_len,
-                             const CompletionCallback& callback) {
-  DCHECK(buf);
-  DCHECK_GT(buf_len, 0);
-  read_data_buf_ = buf;
-  read_data_buf_len_ = buf_len;
-  user_callback_ = callback;
-  next_state_ = STATE_READ;
-
-  if (response_.remaining_bytes < buf_len)
-    buf_len = static_cast<int>(response_.remaining_bytes);
-    
-  if (buf_len <= 0)
-    return 0;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  return DoRead();
-#endif
-}
-
-const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << TAG;
-  return &response_;
-}
-
-LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  switch (next_state_) {
-    case STATE_NONE: 
-      return LOAD_STATE_IDLE;
-    case STATE_CONNECT:
-      return LOAD_STATE_CONNECTING; 
-    case STATE_READ:
-      return LOAD_STATE_READING_RESPONSE;
-    default: 
-      break;
-  }
-  return LOAD_STATE_IDLE;
-}
-
-void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << TAG 
-    << " range[" << range.first_byte_position() 
-    << ", "  << range.last_byte_position() << "]";
-  byte_range_ = range;
-}
-
-void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
-  task_runner_ = runner;
-}
-
-void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << TAG ;
-  user_callback_.Reset();
-  response_ = MmtResponseInfo();
-  read_data_buf_ = NULL;
-  read_data_buf_len_ = 0;
-  last_error_ = OK;
-  next_state_ = STATE_NONE;
-}
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << TAG;
-  next_state_ = STATE_NONE;
-  if (stream_) {
-    fclose((FILE*)stream_);
-    stream_ = nullptr;
-  }
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << TAG << ", url=" << request_->url;
-
-  // TODO: open file/network
-  if(!FileURLToFilePath(request_->url, &file_path_)) {
-    LOG(ERROR) << TAG << ", invalid file";
-    return ERR_FAILED;
-  }
-
-  response_.total_size = 0;
-  if(!base::GetFileSize(file_path_, &response_.total_size)) {
-    LOG(ERROR) << TAG << ", invalid file size";
-    return ERR_FAILED;
-  }
-
-  if (!byte_range_.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
-    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
-  }
-
-  response_.read_offset = byte_range_.first_byte_position();
-  response_.remaining_bytes = byte_range_.last_byte_position() -
-    byte_range_.first_byte_position() + 1;
-  DCHECK_GE(response_.remaining_bytes, 0);
-
-  LOG(INFO) << TAG 
-    << ", total_size=" << response_.total_size
-    << ", read_offset=" << response_.read_offset
-    << ", content_size=" << response_.expected_content_size;
-
-  FILE *fp = base::OpenFile(file_path_, "rb");
-  if (!fp) {
-    LOG(ERROR) << TAG << ", fail to open file";
-    return ERR_FAILED;
-  }
-  stream_ = (void*)fp;
-  response_.expected_content_size = response_.remaining_bytes;
-
-  return OK;
-}
-
-int MmtTransactionImpl::DoRead() {
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-  DCHECK(stream_);
-  read_data_buf_->data()[0] = 0;
-
-  FILE *fp = (FILE *)stream_;
-  int64 offset = response_.read_offset;
-  fseek(fp, offset, SEEK_SET);
-  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
-  if (rv > 0) {
-    response_.read_offset += rv;
-    response_.remaining_bytes -= rv;
-  }
-  return rv;
-}
-
-int MmtTransactionImpl::DoLoop(int result) {
-  DCHECK(next_state_ != STATE_NONE);
-
-  int rv = result;
-  do {
-    State state = next_state_;
-    next_state_ = STATE_NONE;
-    switch (state) {
-      case STATE_STOP:
-        DCHECK(rv == OK);
-        rv = DoStop();
-        break;
-      case STATE_CONNECT:
-        DCHECK(rv == OK);
-        rv = DoConnect();
-        break;
-      case STATE_READ:
-        DCHECK(rv == OK);
-        rv = DoRead();
-        break;
-      default:
-        NOTREACHED() << "bad state";
-        rv = ERR_UNEXPECTED;
-        break;
-    }
-  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
-  return rv;
-}
-
-void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << TAG << ", rv=" << rv;
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
-
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
-}
-
-void MmtTransactionImpl::OnIOPrepare() {
-}
-
-void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  int rv = DoLoop(OK);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
deleted file mode 100644
index adbe735..0000000
--- a/net/mmt/mmt_transaction_impl.h
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
-#define NET_MMT_MMT_TRANSACTION_IMPL_H_
-
-#include <string>
-#include <utility>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "net/base/address_list.h"
-#include "net/base/auth.h"
-#include "net/base/net_log.h"
-#include "net/dns/host_resolver.h"
-#include "net/dns/single_request_host_resolver.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
-
-
-namespace net {
-
-class FileStream;
-
-class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
- public:
-  MmtTransactionImpl();
-  virtual ~MmtTransactionImpl() override;
-
-  virtual int Stop(int error);
-  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
-
-  // MmtTransaction methods:
-  virtual int Start(const MmtRequestInfo* request_info,
-            const CompletionCallback& callback,
-            const BoundNetLog& net_log) override;
-  virtual int Read(IOBuffer* buf,
-           int buf_len,
-           const CompletionCallback& callback) override;
-  virtual const MmtResponseInfo* GetResponseInfo() const override;
-  virtual LoadState GetLoadState() const override;
-  virtual void SetRequestHeaders(HttpByteRange &range) override;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
-
- private:
-  void ResetStateForRestart();
-  void OnIOPrepare();
-  void OnIOComplete();
-  void DoCallback(int result);
-  int DoLoop(int result);
-  int DoStop();
-  int DoConnect();
-  int DoRead();
-
-  enum State {
-    STATE_STOP,
-    STATE_CONNECT,
-    STATE_READ,
-    STATE_NONE
-  };
-
-private:
-  CompletionCallback user_callback_;
-  scoped_refptr<base::TaskRunner> task_runner_;
-
-  BoundNetLog net_log_;
-  const MmtRequestInfo* request_;
-  MmtResponseInfo response_;
-  HttpByteRange byte_range_;
-
-  void* stream_;
-  base::FilePath file_path_;
-  scoped_refptr<IOBuffer> read_data_buf_;
-  int read_data_buf_len_;
-
-  int last_error_;
-  State next_state_;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gypi b/net/net.gypi
index 0335fc6..ad08a23 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,8 +700,6 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2806657..bd64769 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,10 +52,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
-      mmt_transaction_factory_(mmt_transaction_factory),
+      total_bytes_(0),
+      read_offset_(0),
+      remaining_bytes_(0),
       task_runner_(task_runner),
       weak_ptr_factory_(this) {
-  DCHECK(mmt_transaction_factory);
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
@@ -94,47 +95,39 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << __func__;
-  DCHECK(!mmt_transaction_);
-
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(request_);
-  DCHECK(mmt_transaction_factory_);
-  mmt_request_info_.url = request_->url();
-  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
-  mmt_transaction_->SetTaskRunner(task_runner_);
-  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  mmt_transaction_->Start(
-        &mmt_request_info_,
-        base::Bind(&URLRequestMmtJob::OnStartCompleted,
-                   base::Unretained(this)),
-        request_->net_log());
+
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoStart, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidStart, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
 }
 
 void URLRequestMmtJob::Kill() {
   LOG(INFO) << __FUNCTION__;
-  mmt_transaction_.reset();
-
   URLRequestJob::Kill();
   weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  DCHECK(mmt_transaction_);
-
-  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
-  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
   // MMT obviously doesn't have HTTP Content-Length header. We have to pass
   // the content size information manually.
-  set_expected_content_size(content_size);
+  set_expected_content_size(remaining_bytes_);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -144,7 +137,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   read_in_progress_ = false;
   if (result == OK) {
@@ -164,23 +158,25 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-  DCHECK(mmt_transaction_);
-
-  int rv = mmt_transaction_->Read(buf, buf_size,
-                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
-                                             base::Unretained(this)));
-  LOG(INFO) << __func__ << ", rv=" << rv;
-  if (rv >= 0) {
-    *bytes_read = rv;
+
+  if (remaining_bytes_ < buf_len)
+    buf_len = static_cast<int>(remaining_bytes_);
+
+  if (buf_len == 0) {
+    *bytes_read = 0;
     return true;
   }
 
-  if (rv == ERR_IO_PENDING) {
-    read_in_progress_ = true;
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoRead, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidRead, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
+  read_in_progress_ = true;
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
   return false;
 }
 
@@ -189,4 +185,13 @@ bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
   return false;
 }
 
+void URLRequestMmtJob::DoStart(int* result) {
+}
+void URLRequestMmtJob::DidStart(const int* result) {
+}
+void URLRequestMmtJob::DoRead(int* result) {
+}
+void URLRequestMmtJob::DidRead(const int* result) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 7defe8f..d00ca95 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -42,17 +42,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
+  void DoStart(int* result);
+  void DidStart(const int* result);
   void OnStartCompleted(int result);
+
+  void DoRead(int* result);
+  void DidRead(const int* result);
   void OnReadCompleted(int result);
 
  private:
-  MmtRequestInfo mmt_request_info_;
-  scoped_ptr<MmtTransaction> mmt_transaction_;
-
   HttpByteRange byte_range_;
   bool read_in_progress_;
+  int64 total_bytes_;
+  int64 read_offset_;
+  int64 remaining_bytes_;
 
-  MmtTransactionFactory* mmt_transaction_factory_;
   const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9140756855d7ba36e0346996e9ac7f1ce82667de Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:32:07 -0800
Subject: [PATCH 10/34] add mmt local support

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 -
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 -
 chrome/browser/profiles/profile_io_data.cc         |    5 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/url_request/mmt_protocol_handler.cc            |   20 +-
 net/url_request/mmt_protocol_handler.h             |   11 +-
 net/url_request/url_request_context_builder.cc     |    9 +-
 net/url_request/url_request_context_builder.h      |    1 -
 net/url_request/url_request_mmt_job.cc             |  327 +++++++++++++-------
 net/url_request/url_request_mmt_job.h              |   87 ++++--
 12 files changed, 304 insertions(+), 194 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index d47b636..798bea3 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,11 +261,6 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -275,8 +270,7 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -334,8 +328,7 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -375,8 +368,7 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get(),
-                                            mmt_factory_.get());
+                                            ftp_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index fa54638..900dbfc 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,7 +21,6 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -147,7 +146,6 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 4f21760..8b39439 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,7 +54,6 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -582,11 +581,6 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -603,8 +597,7 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -669,8 +662,7 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -757,8 +749,7 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get(),
-                              mmt_factory_.get()));
+                              ftp_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 505da31..383fc40 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,7 +34,6 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -230,7 +229,6 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 7cb34a4..fee77fb 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,8 +1162,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory,
-    net::MmtTransactionFactory* mmt_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1218,11 +1217,9 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
       new net::MmtProtocolHandler(
-            mmt_transaction_factory,
             content::BrowserThread::GetBlockingPool()->
               GetTaskRunnerWithShutdownBehavior(
                   base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index fcc9fef..244107f 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,7 +34,6 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
-#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -61,7 +60,6 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -360,8 +358,7 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory,
-      net::MmtTransactionFactory* mmt_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index be497ff..19a5fbb 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,32 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
+#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
-#include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_mmt_job.h"
-#include "url/gurl.h"
 
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner>& task_runner)
-    : mmt_transaction_factory_(mmt_transaction_factory),
-      task_runner_(task_runner) {
-  DCHECK(mmt_transaction_factory_);
-}
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    : mmt_task_runner_(mmt_task_runner) {}
 
-MmtProtocolHandler::~MmtProtocolHandler() {
-}
+MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request,
-                              network_delegate,
-                              mmt_transaction_factory_,
-                              task_runner_);
+  return new URLRequestMmtJob(request, network_delegate, mmt_task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 185ac8f..a823916 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -18,17 +18,16 @@ class TaskRunner;
 
 namespace net {
 
-class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for MMT jobs. 
+// Implements a ProtocolHandler for Mmt jobs. If |network_delegate_| is NULL,
+// then all mmt requests will fail with ERR_ACCESS_DENIED.
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
   explicit MmtProtocolHandler(
-      MmtTransactionFactory* mmt_transaction_factory,
-      const scoped_refptr<base::TaskRunner>& task_runner);
+      const scoped_refptr<base::TaskRunner>& mmt_task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -36,9 +35,7 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  MmtTransactionFactory* mmt_transaction_factory_;
-  const scoped_refptr<base::TaskRunner> task_runner_;
-
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 4e5018f..cbdf642 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,7 +18,6 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -410,11 +409,9 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 
 #if !defined(DISABLE_MMT_SUPPORT)
   if (mmt_enabled_) {
-    mmt_transaction_factory_.reset(
-        MmtTransactionFactory::CreateFactory());
-    job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
-                               context->GetFileThread()->message_loop_proxy()));
+    job_factory->SetProtocolHandler(
+        "mmt",
+        new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index c2cec99..bb4d30a 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -227,7 +227,6 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
-  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index bd64769..9d157d9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -2,74 +2,160 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// For loading files, we make use of overlapped i/o to ensure that reading from
-// the filesystem (e.g., a network filesystem) does not block the calling
-// thread.  An alternative approach would be to use a background thread or pool
-// of threads, but it seems better to leverage the operating system's ability
-// to do background file reads for us.
-//
-// Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
-// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequestMmtJob
-// attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequestMmtJob waits for a
-// signal from the OS that the overlapped read has completed.  It does so by
-// leveraging the MessageLoop::WatchObject API.
-
 #include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
+#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
+#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
-#include "net/http/http_response_headers.h"
-#include "net/http/http_transaction_factory.h"
-#include "net/url_request/url_request.h"
-#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
 namespace net {
 
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner> task_runner)
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      read_in_progress_(false),
-      total_bytes_(0),
-      read_offset_(0),
+      stream_(new FileStream(mmt_task_runner)),
+      mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
-      task_runner_(task_runner),
       weak_ptr_factory_(this) {
 }
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+void URLRequestMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequestMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
 }
 
-#if 0
-bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
-  // Disallow all redirects.
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
   return false;
 }
+
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
 #endif
+}
+
+Filter* URLRequestMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
   return false;
 }
 
@@ -94,104 +180,131 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(request_);
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
+}
 
-  // No matter what, we want to report our status as IO pending since we will
-  // be notifying our consumer asynchronously via OnStartCompleted.
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoStart, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidStart, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
 }
 
-void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
 
-  // Clear the IO_PENDING status
-  SetStatus(URLRequestStatus());
+  // We use URLRequestMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
 
-  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-  // the content size information manually.
-  set_expected_content_size(remaining_bytes_);
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
-  if (result == OK) {
-    NotifyHeadersComplete();
-  }else {
+  if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
   }
-}
 
-void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  read_in_progress_ = false;
-  if (result == OK) {
-    NotifyDone(URLRequestStatus());
-  } else if (result < 0) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequestMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequestMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
   } else {
-    // Clear the IO_PENDING status
-    SetStatus(URLRequestStatus());
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
   }
-  NotifyReadComplete(result);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
-                                    int buf_size,
-                                    int* bytes_read) {
-  DCHECK_NE(buf_size, 0);
-  DCHECK(bytes_read);
-  DCHECK(!read_in_progress_);
+void URLRequestMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  if (remaining_bytes_ < buf_len)
-    buf_len = static_cast<int>(remaining_bytes_);
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
 
-  if (buf_len == 0) {
-    *bytes_read = 0;
-    return true;
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
   }
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoRead, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidRead, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
-  read_in_progress_ = true;
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  return false;
-}
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  return false;
-}
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
 
-void URLRequestMmtJob::DoStart(int* result) {
-}
-void URLRequestMmtJob::DidStart(const int* result) {
-}
-void URLRequestMmtJob::DoRead(int* result) {
-}
-void URLRequestMmtJob::DidRead(const int* result) {
+  NotifyReadComplete(result);
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index d00ca95..5e93f97 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,56 +8,97 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
 namespace net {
 
-class NetworkDelegate;
-class MmtTransactionFactory;
+class FileStream;
 
-// A request job that handles reading mmt URLs
+// A request job that handles reading file URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                   NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory,
-                   const scoped_refptr<base::TaskRunner> task_runner);
+                    NetworkDelegate* network_delegate,
+                    const scoped_refptr<base::TaskRunner>& mmt_task_runner);
 
- protected:
-  ~URLRequestMmtJob() override;
-
-  // Overridden from URLRequestJob:
+  // URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
- private:
-  void DoStart(int* result);
-  void DidStart(const int* result);
-  void OnStartCompleted(int result);
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
 
-  void DoRead(int* result);
-  void DidRead(const int* result);
-  void OnReadCompleted(int result);
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
 
  private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+
   HttpByteRange byte_range_;
-  bool read_in_progress_;
-  int64 total_bytes_;
-  int64 read_offset_;
   int64 remaining_bytes_;
 
-  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From c9c8fc65c620b3909a80f0434818bef397a90dfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:41:00 -0800
Subject: [PATCH 11/34] OK for mmt local file

---
 net/url_request/url_request_mmt_job.cc |   50 ++------------------------------
 net/url_request/url_request_mmt_job.h  |    4 ---
 2 files changed, 2 insertions(+), 52 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 9d157d9..3e01eca 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
+  FileURLToFilePath(request_->url(), &file_path_);
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -109,53 +110,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  return NULL;
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
   return false;
 }
 
@@ -180,12 +143,6 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-}
-
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-}
-
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
@@ -277,7 +234,6 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
-  OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                                 ERR_REQUEST_RANGE_NOT_SATISFIABLE));
@@ -294,8 +250,6 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
     remaining_bytes_ -= result;
     DCHECK_GE(remaining_bytes_, 0);
   }
-
-  OnReadComplete(buf.get(), result);
   buf = NULL;
 
   if (result == 0) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 5e93f97..046bffe 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -43,10 +43,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
  protected:
   ~URLRequestMmtJob() override;
 
-- 
1.7.9.5


From 9db8aa65f97993cd6e1022f01c3fd934b87c398c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 09:07:06 -0800
Subject: [PATCH 12/34] save 1

---
 net/url_request/url_request_mmt_job.cc |   41 ++++++++++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h  |   11 +++++++++
 2 files changed, 52 insertions(+)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3e01eca..0eb13a1 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -39,6 +39,13 @@ URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
       is_directory(false) {
 }
 
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
+    : read_offset(0),
+      remaining_bytes(0),
+      dest(nullptr),
+      dest_size(0) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
@@ -52,6 +59,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
+  read_info_.file_path = file_path_;
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -86,15 +94,32 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
+#if 0
   int rv = stream_->Read(dest,
                          dest_size,
                          base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
+#endif
+  int rv = ERR_IO_PENDING;
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  read_info->file_path = read_info_.file_path;
+  read_info->read_offset = read_info_.read_offset;
+  read_info->dest = dest;
+  read_info->dest_size = dest_size;
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::DoRead, 
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidRead2,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
     remaining_bytes_ -= rv;
+    read_info_.remaining_bytes -= rv;
+    read_info_.read_offset += rv;
     DCHECK_GE(remaining_bytes_, 0);
     return true;
   }
@@ -108,6 +133,18 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
+  DidRead(read_info->dest, read_info->dest_size);
+}
+
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -208,6 +245,8 @@ void URLRequestMmtJob::DidOpen(int result) {
 
   remaining_bytes_ = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
+  read_info_.remaining_bytes = remaining_bytes_;
+  read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
   if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
@@ -248,6 +287,8 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
+    read_info_.remaining_bytes -= result;
+    read_info_.read_offset += result;
     DCHECK_GE(remaining_bytes_, 0);
   }
   buf = NULL;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 046bffe..82cc67f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -86,6 +86,16 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidSeek(int64 result);
 
   // Callback after data is asynchronously read from the file into |buf|.
+  struct ReadMetaInfo {
+    ReadMetaInfo();
+    int64 read_offset;
+    int64 remaining_bytes;
+    IOBuffer* dest;
+    int32 dest_size;
+    base::FilePath file_path;
+  };
+  static void DoRead(ReadMetaInfo* read_info);
+  void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
   scoped_ptr<FileStream> stream_;
@@ -94,6 +104,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
+  ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 476f6960e893cb2485861d2c4e9b23a314653228 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 22:53:52 -0800
Subject: [PATCH 13/34] [ok] for async read

---
 net/url_request/url_request_mmt_job.cc |  117 +++++++-------------------------
 net/url_request/url_request_mmt_job.h  |   37 ++--------
 2 files changed, 29 insertions(+), 125 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0eb13a1..c0c35e2 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -32,15 +32,12 @@
 
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
+// TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : read_offset(0),
+    : is_started(false),
+      handle(nullptr),
+      total_size(0),
+      read_offset(0),
       remaining_bytes(0),
       dest(nullptr),
       dest_size(0) {
@@ -51,7 +48,6 @@ URLRequestMmtJob::URLRequestMmtJob(
     NetworkDelegate* network_delegate,
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      stream_(new FileStream(mmt_task_runner)),
       mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {
@@ -60,18 +56,20 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
   read_info_.file_path = file_path_;
-  FileMetaInfo* meta_info = new FileMetaInfo();
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DoStart,
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidStart,
                  weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+                 base::Owned(read_info)));
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  if (read_info_.handle) fclose((FILE*)read_info_.handle);
+  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -94,17 +92,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-#if 0
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
-#endif
   int rv = ERR_IO_PENDING;
   ReadMetaInfo* read_info = new ReadMetaInfo;
-  read_info->file_path = read_info_.file_path;
-  read_info->read_offset = read_info_.read_offset;
+  *read_info = read_info_;
   read_info->dest = dest;
   read_info->dest_size = dest_size;
   mmt_task_runner_->PostTaskAndReply(
@@ -134,7 +124,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
   if (fp) {
     fseek(fp, read_info->read_offset, SEEK_SET);
     read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
@@ -183,48 +173,19 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
+void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
+  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
+void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  read_info_ = *read_info;
+
+  if (!read_info_.is_started) {
     DidOpen(ERR_FILE_NOT_FOUND);
     return;
   }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
+  DidOpen(OK);
 }
 
 void URLRequestMmtJob::DidOpen(int result) {
@@ -237,7 +198,7 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -249,36 +210,6 @@ void URLRequestMmtJob::DidOpen(int result) {
   read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
-  }
-}
-
-void URLRequestMmtJob::DidSeek(int64 result) {
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-
   set_expected_content_size(remaining_bytes_);
   NotifyHeadersComplete();
 }
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 82cc67f..50cf98f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -52,54 +52,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   base::FilePath file_path_;
 
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
+    bool is_started;
+    void* handle;
+    int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+  static void DoStart(ReadMetaInfo* read_info);
+  void DidStart(ReadMetaInfo* read_info);
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-- 
1.7.9.5


From c998a008a6dd587dac8c808247690530213e3a95 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 23:08:50 -0800
Subject: [PATCH 14/34] [ok] refine base on 476f696

---
 net/url_request/url_request_mmt_job.cc |   69 +++++++++++++-------------------
 net/url_request/url_request_mmt_job.h  |   17 +++-----
 2 files changed, 32 insertions(+), 54 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c0c35e2..2537c62 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -35,7 +35,6 @@ namespace net {
 // TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
     : is_started(false),
-      handle(nullptr),
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -49,13 +48,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
-      remaining_bytes_(0),
       weak_ptr_factory_(this) {
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &file_path_);
-  read_info_.file_path = file_path_;
+  FileURLToFilePath(request_->url(), &read_info_.file_path);
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -68,8 +65,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  if (read_info_.handle) fclose((FILE*)read_info_.handle);
-  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -80,12 +75,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
+  if (read_info_.remaining_bytes < dest_size)
+    dest_size = static_cast<int>(read_info_.remaining_bytes);
 
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // If we should copy zero bytes because |remaining_bytes| is zero, short
   // circuit here.
   if (!dest_size) {
     *bytes_read = 0;
@@ -101,16 +96,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoRead, 
                  base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead2,
+      base::Bind(&URLRequestMmtJob::DidRead,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
-    remaining_bytes_ -= rv;
     read_info_.remaining_bytes -= rv;
     read_info_.read_offset += rv;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
     return true;
   }
 
@@ -123,18 +117,6 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
-  }
-}
-void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
-  DidRead(read_info->dest, read_info->dest_size);
-}
-
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -146,7 +128,8 @@ Filter* URLRequestMmtJob::SetupFilter() const {
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  return false;
+  *mime_type = std::string("text/html");
+  return true;
 }
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
@@ -175,23 +158,18 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
   read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
-  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  int result = OK;
   read_info_ = *read_info;
-
   if (!read_info_.is_started) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
+    result = ERR_FAILED;
   }
-  DidOpen(OK);
-}
 
-void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidStart"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -204,25 +182,32 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
+  read_info_.remaining_bytes = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
-  read_info_.remaining_bytes = remaining_bytes_;
   read_info_.read_offset = byte_range_.first_byte_position();
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  set_expected_content_size(remaining_bytes_);
+  set_expected_content_size(read_info_.remaining_bytes);
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+
+void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
+  int result = read_info->dest_size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
     read_info_.remaining_bytes -= result;
     read_info_.read_offset += result;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  buf = NULL;
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 50cf98f..15e7600 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -46,37 +46,30 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  protected:
   ~URLRequestMmtJob() override;
 
-  int64 remaining_bytes() const { return remaining_bytes_; }
-
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
     bool is_started;
-    void* handle;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
+
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+
   static void DoStart(ReadMetaInfo* read_info);
   void DidStart(ReadMetaInfo* read_info);
+
   static void DoRead(ReadMetaInfo* read_info);
-  void DidRead2(ReadMetaInfo* read_info);
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+  void DidRead(ReadMetaInfo* read_info);
 
+ private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
   ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
-- 
1.7.9.5


From 3301a59dd29064a4c664bb210f1250b7d43bb2b9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:10:18 -0800
Subject: [PATCH 15/34] prepare to use mmt stream

---
 net/url_request/url_request_mmt_job.cc |   20 +++++++++++++-------
 net/url_request/url_request_mmt_job.h  |    3 ++-
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2537c62..59ce61d 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -52,7 +53,9 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &read_info_.file_path);
+  base::FilePath file_path;
+  FileURLToFilePath(request_->url(), &file_path);
+  read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -157,7 +160,8 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  read_info->is_started = base::GetFileSize(
+    base::FilePath(read_info->uri), &read_info->total_size);
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
@@ -192,12 +196,14 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
+#if 0
+  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
+  if (stream) {
+    read_info->dest_size = stream->Read(read_info->dest->data(), 
+                                      read_info->dest_size, 
+                                      read_info->read_offset);
   }
+#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 15e7600..227cf51 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,6 +7,7 @@
 
 #include <string>
 #include <vector>
+#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
@@ -57,7 +58,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    base::FilePath file_path;
+    std::string uri;
   };
 
   static void DoStart(ReadMetaInfo* read_info);
-- 
1.7.9.5


From 5419132e1312ea615b586cd218280c46b53869fe Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:41:53 -0800
Subject: [PATCH 16/34] add net/mmt module

---
 net/mmt/mmt_stream.cc                 |   40 ++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                  |   51 +++++++++++++++++++++++++++++++++
 net/net.gypi                          |    1 +
 net/url_request/url_request_mmt_job.h |    1 -
 4 files changed, 92 insertions(+), 1 deletion(-)
 create mode 100644 net/mmt/mmt_stream.cc
 create mode 100644 net/mmt/mmt_stream.h

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
new file mode 100644
index 0000000..28c19d8
--- /dev/null
+++ b/net/mmt/mmt_stream.cc
@@ -0,0 +1,40 @@
+#include "net/mmt/mmt_stream.h"
+
+namespace mmt {
+
+Stream::Stream(const std::string &uri) 
+    : uri_(uri), file_(nullptr) { 
+}
+
+Stream::~Stream() {
+}
+
+std::string Stream::getUri() {
+  return uri_;
+}
+
+int Stream::Read(char *buf, int size, int offset) {
+  return 0; 
+}
+
+StreamPool* StreamPool::ginst_ = nullptr;
+
+StreamPool::StreamPool() {
+}
+StreamPool::~StreamPool() {
+}
+
+StreamPtr StreamPool::getStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter == streams_.end()) {
+        return nullptr;
+    }
+    return iter->second;
+}
+
+StreamPtr StreamPool::addStream(std::string &uri) {
+    StreamPtr stream = getStream(uri);
+    return stream;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
new file mode 100644
index 0000000..d4761cf
--- /dev/null
+++ b/net/mmt/mmt_stream.h
@@ -0,0 +1,51 @@
+#ifndef NET_MMT_MMT_STREAM_H_
+#define NET_MMT_MMT_STREAM_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+
+namespace mmt {
+
+class Stream : public base::RefCounted<Stream> {
+public:
+    friend class StreamPool;
+    Stream(const std::string &uri);
+    std::string getUri();
+    int Read(char *buf, int size, int offset);
+
+protected:
+    virtual ~Stream();
+
+private:
+    std::string uri_;
+    FILE *file_;
+};
+
+//typedef scoped_refptr<Stream> StreamPtr;
+typedef Stream* StreamPtr;
+typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::map<std::string, StreamPtr>  streams_t;
+
+class StreamPool {
+public:
+    StreamPool();
+    ~StreamPool();
+
+    StreamPtr getStream(std::string &uri);
+    StreamPtr addStream(std::string &uri);
+    static StreamPool *inst();
+
+protected:
+    static StreamPool *ginst_; 
+
+private:
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+#endif
diff --git a/net/net.gypi b/net/net.gypi
index ad08a23..cc6c1b2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,7 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_stream.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 227cf51..3488cee 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,7 +7,6 @@
 
 #include <string>
 #include <vector>
-#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
-- 
1.7.9.5


From f35f026c2661c87da64c55512453e856b79a57ba Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:58:49 -0800
Subject: [PATCH 17/34] fix for compile

---
 net/mmt/mmt_stream.cc                  |   40 ++++++++++++++++++++++++++++++--
 net/mmt/mmt_stream.h                   |   14 +++++++----
 net/url_request/url_request_mmt_job.cc |    8 +++----
 3 files changed, 52 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 28c19d8..66e074f 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -7,16 +7,34 @@ Stream::Stream(const std::string &uri)
 }
 
 Stream::~Stream() {
+    Uninit();
 }
 
 std::string Stream::getUri() {
-  return uri_;
+    return uri_;
+}
+
+bool Stream::Init() {
+    if (file_) return true;
+    file_ = fopen(uri_.c_str(), "rb");
+    if (file_) return true;
+    return true;
 }
 
 int Stream::Read(char *buf, int size, int offset) {
-  return 0; 
+    if (!Init()) return -1;
+    fseek(file_, offset, SEEK_SET);
+    int iret = fread(buf, 1, size, file_);
+    return iret; 
+}
+
+void Stream::Uninit() {
+    LOG(INFO) << "Stream::Uninit";
+    if (file_) fclose(file_);
+    file_ = nullptr;
 }
 
+
 StreamPool* StreamPool::ginst_ = nullptr;
 
 StreamPool::StreamPool() {
@@ -34,7 +52,25 @@ StreamPtr StreamPool::getStream(std::string &uri) {
 
 StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
+    if (!stream.get()) {
+        stream = new Stream(uri);
+        streams_.insert(pair_t(uri, stream));
+    }
     return stream;
 }
 
+void StreamPool::delStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter != streams_.end()) {
+        streams_.erase(iter);
+    }
+}
+ 
+StreamPool *StreamPool::inst() {
+    if (!ginst_) {
+        ginst_ = new StreamPool;
+    }
+    return ginst_;
+}
+
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d4761cf..b8ba20b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -5,6 +5,7 @@
 #include <string>
 #include <vector>
 
+#include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 
@@ -12,21 +13,24 @@ namespace mmt {
 
 class Stream : public base::RefCounted<Stream> {
 public:
-    friend class StreamPool;
-    Stream(const std::string &uri);
+    explicit Stream(const std::string &uri);
     std::string getUri();
+    bool Init();
     int Read(char *buf, int size, int offset);
+    void Uninit();
 
 protected:
+    friend class base::RefCounted<Stream>;
     virtual ~Stream();
 
 private:
     std::string uri_;
     FILE *file_;
+
+    DISALLOW_COPY_AND_ASSIGN(Stream);
 };
 
-//typedef scoped_refptr<Stream> StreamPtr;
-typedef Stream* StreamPtr;
+typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
@@ -37,6 +41,8 @@ public:
 
     StreamPtr getStream(std::string &uri);
     StreamPtr addStream(std::string &uri);
+    void delStream(std::string &uri);
+
     static StreamPool *inst();
 
 protected:
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 59ce61d..05611a0 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+#include "net/mmt/mmt_stream.h"
 
 namespace net {
 
@@ -68,6 +69,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -196,14 +198,12 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-#if 0
-  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
-  if (stream) {
+  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
+  if (stream.get()) {
     read_info->dest_size = stream->Read(read_info->dest->data(), 
                                       read_info->dest_size, 
                                       read_info->read_offset);
   }
-#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-- 
1.7.9.5


From 1e6109a0a81a10ae15836801f854c4991dac4ec7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 06:51:25 -0800
Subject: [PATCH 18/34] [ok] add lock to proctection

---
 net/mmt/mmt_stream.cc |   20 +++++++++++++++++++-
 net/mmt/mmt_stream.h  |    3 +++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 66e074f..5a75700 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,6 +4,7 @@ namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
+    LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
 }
 
 Stream::~Stream() {
@@ -18,6 +19,14 @@ bool Stream::Init() {
     if (file_) return true;
     file_ = fopen(uri_.c_str(), "rb");
     if (file_) return true;
+    return false;
+}
+
+bool Stream::Prepare(int64 *size) {
+    if (!Init()) return false;
+    fseek(file_, 0L, SEEK_END);
+    int64 lret = ftell(file_);
+    *size = lret;
     return true;
 }
 
@@ -29,7 +38,7 @@ int Stream::Read(char *buf, int size, int offset) {
 }
 
 void Stream::Uninit() {
-    LOG(INFO) << "Stream::Uninit";
+    LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     if (file_) fclose(file_);
     file_ = nullptr;
 }
@@ -43,10 +52,13 @@ StreamPool::~StreamPool() {
 }
 
 StreamPtr StreamPool::getStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter == streams_.end()) {
+        lock_.Release();
         return nullptr;
     }
+    lock_.Release();
     return iter->second;
 }
 
@@ -54,16 +66,22 @@ StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
     if (!stream.get()) {
         stream = new Stream(uri);
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
+        lock_.Acquire();
         streams_.insert(pair_t(uri, stream));
+        lock_.Release();
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
     }
     return stream;
 }
 
 void StreamPool::delStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter != streams_.end()) {
         streams_.erase(iter);
     }
+    lock_.Release();
 }
  
 StreamPool *StreamPool::inst() {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b8ba20b..0d5e6eb 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -8,6 +8,7 @@
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
 
 namespace mmt {
 
@@ -16,6 +17,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
+    bool Prepare(int64 *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
@@ -50,6 +52,7 @@ protected:
 
 private:
     streams_t streams_;
+    base::Lock lock_;
 };
 
 } // namespace mmt
-- 
1.7.9.5


From c50f50a14b7cab3b699306a95c39c0ae505a4d35 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 12 Jan 2015 06:55:46 -0800
Subject: [PATCH 19/34] how to get web_contents from internal

---
 net/mmt/mmt_stream.cc                  |   96 ++++++++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                   |   13 +++++
 net/net.gyp                            |    4 ++
 net/url_request/url_request_mmt_job.cc |   11 ++++
 net/url_request/url_request_mmt_job.h  |    5 ++
 5 files changed, 129 insertions(+)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5a75700..e0dac96 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,7 +1,103 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/resource_context.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+
+using namespace content;
+
 namespace mmt {
 
+#if 0
+    //content::ResourceContext* rcontext = rinfo->GetContext();
+    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
+    //content::RenderThread::Get()->Send(message);
+    //ContentClient* client = GetContentClient();
+    //ContentBrowserClient* browser = client->browser();
+#endif
+
+bool GetRequestID(const net::URLRequest* request, Content* content) {
+    LOG(INFO) << __func__;
+    if (!content) return false;
+
+    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
+    }
+
+    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    if (is_ok) {
+        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
+            << ", render_frame_id: " << content->frame_id;
+    }
+
+    return is_ok;
+}
+
+static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
+    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
+    if (rfh) {
+        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+    }
+    return rfh;
+}
+
+#if 0
+static RenderView* Get_RenderView(int routing_id) {
+    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    if (rv) {
+        blink::WebView* web_view = rv->GetWebView();
+        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
+    }
+    return rv;
+}
+#endif
+
+static void Post_Fullscreen(int process_id, int frame_id) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    if (rfh) {
+        rfh = nullptr;
+    }
+}
+
+void PostTask(int msg_type, const Content* content) {
+    if (content) {
+        Post_Fullscreen(content->process_id, content->frame_id);
+    }
+}
+
+#if 0
+void Run_Javascript(const string js) {
+    // => RenderFrame
+    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        //content::ResourceContext* rcontext = rinfo->GetContext();
+        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
+            << ", frame id: " << rinfo->GetRenderFrameID();
+        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
+            js,
+            rinfo->GetRouteID(), 
+            false);
+        content::RenderThread::Get()->Send(message);
+    }
+}
+#endif
+
+
+///======================
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0d5e6eb..0ba5b97 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,8 +10,21 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+namespace net {
+class URLRequest;
+}
+
 namespace mmt {
 
+struct Content {
+    int process_id;
+    int frame_id;
+    int routing_id;
+};
+
+bool GetRequestID(const net::URLRequest* request, Content* content);
+void PostTask(int msg_type, const Content* content);
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/net.gyp b/net/net.gyp
index eb27320..242582f 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -101,6 +101,10 @@
         '<@(net_nacl_common_sources)',
         '<@(net_non_nacl_sources)',
       ],
+      'include_dirs': [
+         '../skia/config',
+         '../third_party/skia/include/core',
+      ],
       'defines': [
         'NET_IMPLEMENTATION',
       ],
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 05611a0..3437a6e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,6 +31,7 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
+#include "content/public/browser/browser_thread.h"
 
 namespace net {
 
@@ -51,6 +52,8 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::GetRequestID(request_, &content_);
+  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -59,6 +62,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoStart,
@@ -224,4 +228,11 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+}
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 3488cee..468db82 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,6 +15,7 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+#include "net/mmt/mmt_stream.h"
 
 namespace base {
 class TaskRunner;
@@ -66,11 +67,15 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
 
+  static void DoTest(void* ptr);
+  void DidTest(void* ptr);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
+  mmt::Content content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 491388d5953265f11bd2504c64cdb7e29f7cf986 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 06:16:27 -0800
Subject: [PATCH 20/34] try on for web_contents

---
 net/mmt/mmt_stream.cc                  |  118 +++++++++++++++++++++++++++++---
 net/mmt/mmt_stream.h                   |   10 +++
 net/url_request/url_request_mmt_job.cc |    3 +
 3 files changed, 121 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e0dac96..7572ae2 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,17 +1,24 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/browser_thread.h"
 #include "content/public/browser/resource_request_info.h"
 #include "content/public/browser/resource_context.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
+#include "content/public/browser/render_view_host.h"
+
 #include "content/public/common/content_client.h"
-#include "content/public/browser/browser_thread.h"
 #include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
 
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
+
 using namespace content;
 
 namespace mmt {
@@ -41,6 +48,13 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
             << ", render_frame_id: " << content->frame_id;
     }
 
+    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
+        << ", frame id=" << rinfo->GetRenderFrameID()
+        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
+        << ", is main frame=" << rinfo->IsMainFrame()
+        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
+        << "";
+
     return is_ok;
 }
 
@@ -48,14 +62,17 @@ static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
     if (rfh) {
         WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+        RenderViewHost* rvh = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
+        contents = nullptr;
+        rvh = nullptr;
     }
     return rfh;
 }
 
 #if 0
 static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
     if (rv) {
         blink::WebView* web_view = rv->GetWebView();
         LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
@@ -64,17 +81,93 @@ static RenderView* Get_RenderView(int routing_id) {
 }
 #endif
 
-static void Post_Fullscreen(int process_id, int frame_id) {
+void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
+    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
+    LOG(INFO) << __func__ << " rfh=" << rfh;
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+
+    if (rfh) {
+        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
+        content::WebUI* webui = web_contents->GetWebUI();
+        LOG(INFO) << __func__ << " webui=" << webui;
+
+        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view1=" << render_view1;
+        if (render_view1) {
+            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
+            LOG(INFO) << __func__ << " view1=" << view1;
+        }
+
+        WebContentsDelegate* delegate = web_contents->GetDelegate();
+        LOG(INFO) << __func__ << " delegate=" << delegate;
+
+        RenderFrameHost* main_frame = web_contents->GetMainFrame();
+        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
+        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
+        RenderViewHost* main_view = main_frame->GetRenderViewHost();
+        LOG(INFO) << __func__ << " main_view=" << main_view;
+        if (main_view) {
+            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
+            LOG(INFO) << __func__ << " view=" << view;
+        }
+
+        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
+        LOG(INFO) << __func__ << " browser_context=" << browser_context;
+
+        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view2=" << render_view2;
+        if (render_view2) {
+            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
+            LOG(INFO) << __func__ << " view2=" << view2;
+        }
+
+        GURL url = web_contents->GetURL();
+        LOG(INFO) << __func__ << " url=" << url;
+
+        js = "console.log(document.getElementById(\"Video1\"));";
+        LOG(INFO) << __func__ << " js=" << js;
+        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+
+        std::string css = "<style>"
+            "body{"
+                "font-family: Verdana, Cursor;"
+                "font-size: 10px;"
+                "font-weight: bold;"
+            "}"
+            "</style>";
+        web_contents->InsertCSS(css);
+
+        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //web_contents->ViewSource();
+        LOG(INFO) << __func__ << " END";
+    }
+}
+
+void Do_Fullscreen(const Content* content) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     if (rfh) {
         rfh = nullptr;
     }
 }
 
 void PostTask(int msg_type, const Content* content) {
-    if (content) {
-        Post_Fullscreen(content->process_id, content->frame_id);
+    switch(msg_type) {
+    case Msg_RunJavaScript:
+        static bool _brun = false;
+        if (content && !_brun) {
+            _brun = true;
+            Do_JavaScript(content, content->data);
+        }
+        break;
     }
 }
 
@@ -95,8 +188,13 @@ void Run_Javascript(const string js) {
 }
 #endif
 
+} // namespace mmt
 
-///======================
+
+///===============================
+/// for class Stream and StreamPool
+
+namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0ba5b97..2c937d3 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,15 +16,25 @@ class URLRequest;
 
 namespace mmt {
 
+enum {
+    Msg_RunJavaScript,
+};
+
 struct Content {
     int process_id;
     int frame_id;
     int routing_id;
+    std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
 
+} // namespace mmt
+
+
+namespace mmt {
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3437a6e..cdbd903 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
   DoTest((void*)&content_);
 }
 
@@ -62,6 +63,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -232,6 +234,7 @@ void URLRequestMmtJob::DoTest(void* ptr) {
     content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
                           base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 }
+
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
-- 
1.7.9.5


From d39bf190e6c5de4cf2f7fefb2fdb796c47dc228a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 16:48:22 -0800
Subject: [PATCH 21/34] add extension of cimsg

---
 .../docs/examples/api/cimsg/background.js          |   87 ++++++++++++
 .../docs/examples/api/cimsg/install_host.sh        |   40 ++++++
 .../docs/examples/api/cimsg/manifest.json          |   24 ++++
 .../docs/examples/api/cimsg/native-messaging-cimsg |  142 ++++++++++++++++++++
 .../examples/api/cimsg/org.chromium.cimsg.json     |   13 ++
 5 files changed, 306 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/background.js
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/manifest.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
new file mode 100644
index 0000000..11a23b8
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -0,0 +1,87 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+var port = null;
+var tabid = -1;
+
+var getKeys = function(obj){
+  var keys = [];
+  for(var key in obj){
+    keys.push(key);
+  }
+  return keys;
+}
+
+function parseJSON(data) {
+  return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function("return " + data))(); 
+}
+
+function logMsg(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript({
+        code: js
+    });
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS({
+        code: css
+    });
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cimsg";
+  port = chrome.runtime.connectNative(hostName);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+
+/// events
+chrome.tabs.onCreated.addListener(function(tab) {
+});
+chrome.tabs.onActivated.addListener(function(info) {
+  //chrome.tabs.executeScript({file: "ci.js"});
+});
+chrome.browserAction.onClicked.addListener(function(tab) {
+  chrome.tabs.executeScript({
+    code: 'document.body.style.backgroundColor="red"'
+  });
+});
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
+    tabid = tab.id;
+    connect();
+  }
+});
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
new file mode 100755
index 0000000..da7105e
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cimsg
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cimsg
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
new file mode 100644
index 0000000..fea9000
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
@@ -0,0 +1,24 @@
+{
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
+    "name": "org.chromium.cimsg",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium native messaging for ci",
+    "permissions": [
+        "tabs",
+        "nativeMessaging",
+        "activeTab",
+        "notifications",
+        "http://*/",
+        "https://*/",
+        "file://*/",
+        "mmt://*/"
+    ],
+   "browser_action": {
+        "default_title": "Make this page red"
+    },
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    }
+}
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
new file mode 100755
index 0000000..b321a25
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -0,0 +1,142 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  try:
+    jdata = JSONDecoder().decode(message);
+    if not jdata: return
+  except:
+    return
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  sys.stdout.flush()
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.bind((host, port))
+  while True:
+    try:
+      msg, addr = sock.recvfrom(65536)
+      send_message(msg.strip())
+    except: 
+      break
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  pass
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
new file mode 100644
index 0000000..2118005
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cimsg",
+  "description": "Chromium Native Messaging For CI",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
-- 
1.7.9.5


From e604015ed16aaabe322aa0ca2ac86e07e4ca9e34 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 00:18:10 -0800
Subject: [PATCH 22/34] refine cimsg extension

---
 .../docs/examples/api/cimsg/background.js          |    1 -
 .../docs/examples/api/cimsg/native-messaging-cimsg |   31 +++++---
 net/mmt/mmt_stream.cc                              |   83 ++++++++------------
 net/mmt/mmt_stream.h                               |    1 +
 net/url_request/url_request_mmt_job.cc             |    9 +--
 5 files changed, 56 insertions(+), 69 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
index 11a23b8..daf7dd5 100644
--- a/chrome/common/extensions/docs/examples/api/cimsg/background.js
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -79,7 +79,6 @@ chrome.browserAction.onClicked.addListener(function(tab) {
 });
 chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
   if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
-    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
     tabid = tab.id;
     connect();
   }
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
index b321a25..05279a2 100755
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -10,6 +10,8 @@ import struct
 import sys
 import threading
 import Queue
+
+import time
 import socket
 from json import JSONDecoder
 
@@ -23,29 +25,36 @@ except ImportError:
 # Helper function that sends a message to the webapp.
 def send_message(message):
   # message must be JSON string
-  try:
-    jdata = JSONDecoder().decode(message);
-    if not jdata: return
-  except:
-    return
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
   # Write message size.
   sys.stdout.write(struct.pack('I', len(message)))
   # Write the message itself.
   sys.stdout.write(message)
-  sys.stdout.flush()
+  try:
+    sys.stdout.flush()
+  except: return
 
 # Thread that reads messages from control point
 def read_ctrl_func():
   host = "localhost"
   port = 54321
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   sock.bind((host, port))
   while True:
-    try:
-      msg, addr = sock.recvfrom(65536)
-      send_message(msg.strip())
-    except: 
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
       break
+    send_message(msg)
+  sock.close()
 
 # Thread that reads messages from the webapp.
 def read_thread_func(queue):
@@ -115,7 +124,7 @@ def Daemon():
   rthread.daemon = True
   rthread.start()
   read_ctrl_func()
-  pass
+  sys.exit(0)
 
 def Main():
   if not Tkinter:
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7572ae2..996b6a0 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -17,19 +17,41 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/threading/thread_restrictions.h"
+#include "net/udp/udp_socket.h"
+#include "net/base/io_buffer.h"
+#include "base/memory/ref_counted.h"
 
 
 using namespace content;
 
 namespace mmt {
 
-#if 0
-    //content::ResourceContext* rcontext = rinfo->GetContext();
-    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
-    //content::RenderThread::Get()->Send(message);
-    //ContentClient* client = GetContentClient();
-    //ContentBrowserClient* browser = client->browser();
-#endif
+void PostCtrl(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+}
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
@@ -58,32 +80,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
-    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
-    if (rfh) {
-        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        RenderViewHost* rvh = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
-        contents = nullptr;
-        rvh = nullptr;
-    }
-    return rfh;
-}
-
-#if 0
-static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
-    if (rv) {
-        blink::WebView* web_view = rv->GetWebView();
-        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
-    }
-    return rv;
-}
-#endif
-
 void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
@@ -153,12 +151,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
 void Do_Fullscreen(const Content* content) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
-    if (rfh) {
-        rfh = nullptr;
-    }
 }
 
+//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 void PostTask(int msg_type, const Content* content) {
     switch(msg_type) {
     case Msg_RunJavaScript:
@@ -171,23 +167,6 @@ void PostTask(int msg_type, const Content* content) {
     }
 }
 
-#if 0
-void Run_Javascript(const string js) {
-    // => RenderFrame
-    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        //content::ResourceContext* rcontext = rinfo->GetContext();
-        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
-            << ", frame id: " << rinfo->GetRenderFrameID();
-        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
-            js,
-            rinfo->GetRouteID(), 
-            false);
-        content::RenderThread::Get()->Send(message);
-    }
-}
-#endif
-
 } // namespace mmt
 
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 2c937d3..4abe1d2 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -29,6 +29,7 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
+void PostCtrl(std::string msg);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index cdbd903..0a54267 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,8 +53,6 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
-  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
-  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -63,7 +61,6 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
-  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -228,11 +225,13 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
+
+  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
+  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From 94263660d2c90151eaf57ed68df115e6c73acc62 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 05:50:16 -0800
Subject: [PATCH 23/34] add ctrl center

---
 net/mmt/mmt_stream.cc                  |   87 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |    5 +-
 net/url_request/url_request_mmt_job.cc |    3 --
 3 files changed, 89 insertions(+), 6 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 996b6a0..7f7b98a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -16,16 +16,98 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
-#include "base/threading/thread_restrictions.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+
+#include "base/threading/thread_restrictions.h"
 #include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
 
 
 using namespace content;
 
 namespace mmt {
 
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        std::string head;
+        std::string body;
+    };
+
+    CtrlCenter() : SimpleThread("ctrlcenter"){}
+    virtual ~CtrlCenter() {}
+
+    virtual void Run() override {
+        running_ = true;
+        while(loop_) {
+            Message msg;
+            if (!Pop(msg)) {
+                Wait(500);
+                continue;
+            }
+
+            if (msg.head == "@ctrl") {
+                PostCtrl(msg.body);
+            }else if (msg.head == "@uri") {
+                std::string uri = msg.body;
+                StreamPtr stream = new Stream(uri);
+                streams_.insert(pair_t(uri, stream));
+            }
+            Wait(100);
+        };
+        running_ = false;
+    }
+
+    void Wait(int ms) {
+        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    }
+    void Reset() {
+        loop_ = true;
+    }
+    bool IsRunning() {
+        return running_;
+    }
+
+    bool Pop(Message &msg) {
+        if (queue_.empty())
+            return false;
+        lock_.Acquire();
+        msg = queue_.back();
+        queue_.pop_back();
+        lock_.Release();
+        return true;
+    }
+
+    void Push(Message &msg) {
+        lock_.Acquire();
+        queue_.insert(queue_.begin(), msg);
+        lock_.Release();
+    }
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+static CtrlCenter *gCenter = nullptr;
+
+void StartCtrlCenter() {
+    if (!gCenter) {
+        gCenter = new CtrlCenter;
+    }
+    if (gCenter->IsRunning()) {
+        return;
+    }
+    gCenter->Reset();
+    gCenter->Start();
+}
+
 void PostCtrl(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
@@ -37,6 +119,7 @@ void PostCtrl(std::string msg) {
     std::string szaddr = "127.0.0.1";
     net::IPAddressNumber ipnum;
     if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
         LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
         return;
     }
@@ -45,12 +128,14 @@ void PostCtrl(std::string msg) {
     struct sockaddr addr;
     socklen_t addrlen;
     if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
         LOG(INFO) << __func__ << " ToSockAddr failed";
         return;
     }
 
     int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
     LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
 }
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 4abe1d2..c574235 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,6 +16,9 @@ class URLRequest;
 
 namespace mmt {
 
+void StartCtrlCenter();
+void PostCtrl(std::string msg);
+
 enum {
     Msg_RunJavaScript,
 };
@@ -29,8 +32,6 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
-void PostCtrl(std::string msg);
-
 } // namespace mmt
 
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0a54267..62e2a0b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -225,9 +225,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
-
-  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
-  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-- 
1.7.9.5


From 9dc889f35c23920985fccce016609b431856b6ad Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 06:53:00 -0800
Subject: [PATCH 24/34] refine ctrl center 1

---
 net/mmt/mmt_stream.cc                  |  282 ++++++++++----------------------
 net/mmt/mmt_stream.h                   |   64 +++++---
 net/url_request/url_request_mmt_job.cc |   10 +-
 3 files changed, 135 insertions(+), 221 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7f7b98a..6aa5855 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -12,6 +12,7 @@
 #include "content/public/renderer/render_thread.h"
 #include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
@@ -19,84 +20,18 @@
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
 
-#include "base/threading/thread_restrictions.h"
-#include "base/memory/ref_counted.h"
-#include "base/threading/simple_thread.h"
-#include "base/synchronization/lock.h"
-#include "base/threading/platform_thread.h"
-#include "base/time/time.h"
-
 
 using namespace content;
 
 namespace mmt {
 
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        std::string head;
-        std::string body;
-    };
-
-    CtrlCenter() : SimpleThread("ctrlcenter"){}
-    virtual ~CtrlCenter() {}
-
-    virtual void Run() override {
-        running_ = true;
-        while(loop_) {
-            Message msg;
-            if (!Pop(msg)) {
-                Wait(500);
-                continue;
-            }
-
-            if (msg.head == "@ctrl") {
-                PostCtrl(msg.body);
-            }else if (msg.head == "@uri") {
-                std::string uri = msg.body;
-                StreamPtr stream = new Stream(uri);
-                streams_.insert(pair_t(uri, stream));
-            }
-            Wait(100);
-        };
-        running_ = false;
-    }
-
-    void Wait(int ms) {
-        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
-    }
-    void Reset() {
-        loop_ = true;
-    }
-    bool IsRunning() {
-        return running_;
-    }
-
-    bool Pop(Message &msg) {
-        if (queue_.empty())
-            return false;
-        lock_.Acquire();
-        msg = queue_.back();
-        queue_.pop_back();
-        lock_.Release();
-        return true;
-    }
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+}
+void PostNativeMsg(std::string msg);
 
-    void Push(Message &msg) {
-        lock_.Acquire();
-        queue_.insert(queue_.begin(), msg);
-        lock_.Release();
-    }
 
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
 static CtrlCenter *gCenter = nullptr;
-
 void StartCtrlCenter() {
     if (!gCenter) {
         gCenter = new CtrlCenter;
@@ -108,7 +43,77 @@ void StartCtrlCenter() {
     gCenter->Start();
 }
 
-void PostCtrl(std::string msg) {
+void PostCtrlMsg(CtrlCenter::Message &msg) {
+    if (!gCenter) return;
+    gCenter->Push(msg);
+}
+
+CtrlCenter::Message::Message() {}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::~CtrlCenter() {}
+
+void CtrlCenter::Run() {
+    running_ = true;
+    while(loop_) {
+        Message msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        if (msg.head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (msg.head == "@open") {
+            std::string uri = msg.uri;
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(pair_t(uri, stream));
+            int64 size;
+            stream->Prepare(&size);
+            if (msg.func1) {
+                msg.func1(msg.thiz, size);
+            }
+        }else if (msg.head == "@read") {
+            std::string uri = msg.uri;
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                char* buf = new char[msg.size];
+                int iret = stream->Read(buf, msg.size, msg.offset);
+                if (iret > 0 && msg.func2) {
+                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                }
+                delete buf;
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+}
+
+void CtrlCenter::Reset() {
+    loop_ = true;
+}
+bool CtrlCenter::IsRunning() {
+    return running_;
+}
+
+bool CtrlCenter::Pop(Message &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void CtrlCenter::Push(Message &msg) {
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+void PostNativeMsg(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
         LOG(INFO) << __func__ << " Open failed sock=" << sock;
@@ -138,6 +143,11 @@ void PostCtrl(std::string msg) {
     close(sock);
 }
 
+} // namespace mmt
+
+
+namespace mmt {
+
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
     if (!content) return false;
@@ -165,10 +175,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void Do_JavaScript(const Content* content, std::string js) {
-    LOG(INFO) << __func__;
+void GetRenderFrameInfo(Content* content) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
@@ -176,79 +184,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        content::WebUI* webui = web_contents->GetWebUI();
-        LOG(INFO) << __func__ << " webui=" << webui;
-
-        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view1=" << render_view1;
-        if (render_view1) {
-            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
-            LOG(INFO) << __func__ << " view1=" << view1;
-        }
-
-        WebContentsDelegate* delegate = web_contents->GetDelegate();
-        LOG(INFO) << __func__ << " delegate=" << delegate;
-
-        RenderFrameHost* main_frame = web_contents->GetMainFrame();
-        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
-        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
-        RenderViewHost* main_view = main_frame->GetRenderViewHost();
-        LOG(INFO) << __func__ << " main_view=" << main_view;
-        if (main_view) {
-            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
-            LOG(INFO) << __func__ << " view=" << view;
-        }
-
-        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
-        LOG(INFO) << __func__ << " browser_context=" << browser_context;
-
-        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view2=" << render_view2;
-        if (render_view2) {
-            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
-            LOG(INFO) << __func__ << " view2=" << view2;
+        if (web_contents) {
+            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+            content->url = web_contents->GetURL();
         }
-
-        GURL url = web_contents->GetURL();
-        LOG(INFO) << __func__ << " url=" << url;
-
-        js = "console.log(document.getElementById(\"Video1\"));";
-        LOG(INFO) << __func__ << " js=" << js;
-        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-
-        std::string css = "<style>"
-            "body{"
-                "font-family: Verdana, Cursor;"
-                "font-size: 10px;"
-                "font-weight: bold;"
-            "}"
-            "</style>";
-        web_contents->InsertCSS(css);
-
-        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //web_contents->ViewSource();
-        LOG(INFO) << __func__ << " END";
-    }
-}
-
-void Do_Fullscreen(const Content* content) {
-    LOG(INFO) << __func__;
-}
-
-//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
-void PostTask(int msg_type, const Content* content) {
-    switch(msg_type) {
-    case Msg_RunJavaScript:
-        static bool _brun = false;
-        if (content && !_brun) {
-            _brun = true;
-            Do_JavaScript(content, content->data);
-        }
-        break;
     }
 }
 
@@ -260,6 +199,9 @@ void PostTask(int msg_type, const Content* content) {
 
 namespace mmt {
 
+Content::Content() {
+}
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -301,52 +243,4 @@ void Stream::Uninit() {
     file_ = nullptr;
 }
 
-
-StreamPool* StreamPool::ginst_ = nullptr;
-
-StreamPool::StreamPool() {
-}
-StreamPool::~StreamPool() {
-}
-
-StreamPtr StreamPool::getStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter == streams_.end()) {
-        lock_.Release();
-        return nullptr;
-    }
-    lock_.Release();
-    return iter->second;
-}
-
-StreamPtr StreamPool::addStream(std::string &uri) {
-    StreamPtr stream = getStream(uri);
-    if (!stream.get()) {
-        stream = new Stream(uri);
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
-        lock_.Acquire();
-        streams_.insert(pair_t(uri, stream));
-        lock_.Release();
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
-    }
-    return stream;
-}
-
-void StreamPool::delStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter != streams_.end()) {
-        streams_.erase(iter);
-    }
-    lock_.Release();
-}
- 
-StreamPool *StreamPool::inst() {
-    if (!ginst_) {
-        ginst_ = new StreamPool;
-    }
-    return ginst_;
-}
-
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c574235..f01bf95 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,28 +10,33 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+#include "base/threading/thread_restrictions.h"
+#include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
+
+#include "url/gurl.h"
+
 namespace net {
 class URLRequest;
 }
 
 namespace mmt {
 
-void StartCtrlCenter();
-void PostCtrl(std::string msg);
-
-enum {
-    Msg_RunJavaScript,
-};
-
 struct Content {
+    Content();
     int process_id;
     int frame_id;
     int routing_id;
+    int tab_id;
+    GURL url;
     std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void PostTask(int msg_type, const Content* content);
+void GetRenderFrameInfo(Content* content);
 } // namespace mmt
 
 
@@ -61,25 +66,46 @@ typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
-class StreamPool {
-public:
-    StreamPool();
-    ~StreamPool();
+} // namespace mmt
 
-    StreamPtr getStream(std::string &uri);
-    StreamPtr addStream(std::string &uri);
-    void delStream(std::string &uri);
 
-    static StreamPool *inst();
 
-protected:
-    static StreamPool *ginst_; 
+namespace mmt {
+
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        Message();
+        std::string head;
+        std::string body;
+        std::string uri;
+        int   size;
+        int   offset;
+        void* thiz;
+        void (*func1)(void*, int);
+        void (*func2)(void*, unsigned char*, int);
+    };
+
+    CtrlCenter();
+    virtual ~CtrlCenter();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(Message &msg);
+    void Push(Message &msg);
 
 private:
-    streams_t streams_;
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
     base::Lock lock_;
+    streams_t streams_;
 };
 
+void StartCtrlCenter();
+void PostCtrlMsg(CtrlCenter::Message &msg);
+
 } // namespace mmt
 
 #endif
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 62e2a0b..484e885 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,8 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
@@ -72,7 +74,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -201,12 +202,6 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
-  if (stream.get()) {
-    read_info->dest_size = stream->Read(read_info->dest->data(), 
-                                      read_info->dest_size, 
-                                      read_info->read_offset);
-  }
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
@@ -228,7 +223,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From f49992582f0ff00df30003dc978cd37e78f3eb9c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 08:24:21 -0800
Subject: [PATCH 25/34] refine ctrl center 2 [thread]

---
 net/mmt/mmt_stream.cc                  |   56 ++++++++++++++++++++++++--------
 net/mmt/mmt_stream.h                   |   16 ++++++---
 net/url_request/url_request_mmt_job.cc |   29 ++++++-----------
 net/url_request/url_request_mmt_job.h  |    4 +--
 4 files changed, 66 insertions(+), 39 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6aa5855..59be61b 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -19,6 +19,7 @@
 #include "base/files/file_util.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
 
 
 using namespace content;
@@ -26,7 +27,7 @@ using namespace content;
 namespace mmt {
 
 void Wait(int ms) {
-    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
 void PostNativeMsg(std::string msg);
 
@@ -41,6 +42,7 @@ void StartCtrlCenter() {
     }
     gCenter->Reset();
     gCenter->Start();
+    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
 }
 
 void PostCtrlMsg(CtrlCenter::Message &msg) {
@@ -48,11 +50,33 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+
+#if 1
+    base::FilePath file_path;
+    net::FileURLToFilePath(gurl, &file_path);
+    msg.url = file_path.value();
+#else
+    std::ostringstream sstr;
+    sstr << gurl;
+    msg.url = sstr.str();
+#endif
+
+    PostCtrlMsg(msg);
+}
+
 CtrlCenter::Message::Message() {}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
+    running_ = false;
+}
 CtrlCenter::~CtrlCenter() {}
 
 void CtrlCenter::Run() {
+    LOG(INFO) << __func__ << " begin";
     running_ = true;
     while(loop_) {
         Message msg;
@@ -60,27 +84,28 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
+        LOG(INFO) << __func__ << " head=" << msg.head;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
-            std::string uri = msg.uri;
-            StreamPtr stream = new Stream(uri);
-            streams_.insert(pair_t(uri, stream));
-            int64 size;
+            std::string url = msg.url;
+            StreamPtr stream = new Stream(url);
+            streams_.insert(pair_t(url, stream));
+            int64 size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
-                msg.func1(msg.thiz, size);
+                msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@read") {
-            std::string uri = msg.uri;
-            streams_t::iterator iter = streams_.find(uri);
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 char* buf = new char[msg.size];
                 int iret = stream->Read(buf, msg.size, msg.offset);
-                if (iret > 0 && msg.func2) {
-                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                if (msg.func2) {
+                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
                 }
                 delete buf;
             }
@@ -88,6 +113,7 @@ void CtrlCenter::Run() {
         Wait(100);
     };
     running_ = false;
+    LOG(INFO) << __func__ << " end";
 }
 
 void CtrlCenter::Reset() {
@@ -108,6 +134,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
+    LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -149,7 +176,6 @@ void PostNativeMsg(std::string msg) {
 namespace mmt {
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
-    LOG(INFO) << __func__;
     if (!content) return false;
 
     const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
@@ -186,7 +212,11 @@ void GetRenderFrameInfo(Content* content) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
             content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            content->url = web_contents->GetURL();
+            std::ostringstream sstr;
+            sstr << web_contents->GetURL();
+            content->tab_url = sstr.str();
+            LOG(INFO) << __func__ << " tab id=" << content->tab_id
+                << ", tab url=" << content->tab_url;
         }
     }
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index f01bf95..fc9fa5c 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -4,6 +4,7 @@
 #include <map>
 #include <string>
 #include <vector>
+#include <sstream>
 
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
@@ -31,7 +32,7 @@ struct Content {
     int frame_id;
     int routing_id;
     int tab_id;
-    GURL url;
+    std::string tab_url;
     std::string data;
 };
 
@@ -72,18 +73,22 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 
 namespace mmt {
 
+typedef void (*func1_t)(void*, int);
+typedef void (*func2_t)(void*, unsigned char*, int);
+
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
         std::string head;
         std::string body;
-        std::string uri;
+        std::string url;
+        int   tab_id;
         int   size;
         int   offset;
-        void* thiz;
-        void (*func1)(void*, int);
-        void (*func2)(void*, unsigned char*, int);
+        func1_t func1;
+        func2_t func2;
+        void* ptr;
     };
 
     CtrlCenter();
@@ -105,6 +110,7 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 484e885..5694a52 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,25 +52,14 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
-  base::FilePath file_path;
-  FileURLToFilePath(request_->url(), &file_path);
-  read_info_.uri = file_path.value();
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoStart,
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidStart,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -165,15 +154,16 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(
-    base::FilePath(read_info->uri), &read_info->total_size);
+void URLRequestMmtJob::DoStart(void* thiz, int iret) {
+    LOG(INFO) << __func__ << " iret=" << iret;
+    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
+    if (job)
+        job->DidStart(iret);
 }
 
-void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+void URLRequestMmtJob::DidStart(int iret) {
   int result = OK;
-  read_info_ = *read_info;
-  if (!read_info_.is_started) {
+  if (iret <= 0) {
     result = ERR_FAILED;
   }
 
@@ -186,6 +176,7 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
     return;
   }
 
+  read_info_.total_size = iret;
   if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 468db82..eaf4cb7 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -61,8 +61,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(ReadMetaInfo* read_info);
-  void DidStart(ReadMetaInfo* read_info);
+  static void DoStart(void *thiz, int iret);
+  void DidStart(int iret);
 
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
-- 
1.7.9.5


From c27370eb2691b633941da8f62d7f13384a62baa0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 10:03:03 -0800
Subject: [PATCH 26/34] refine ctrl center 3

---
 net/mmt/mmt_stream.cc                  |   65 +++++++++++++++++++++++++-------
 net/mmt/mmt_stream.h                   |    9 ++++-
 net/url_request/url_request_mmt_job.cc |   42 ++++++++++-----------
 net/url_request/url_request_mmt_job.h  |    7 ++--
 4 files changed, 82 insertions(+), 41 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 59be61b..9aee8d5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -50,26 +50,57 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-
+std::string GURL2string(GURL& gurl) {
+    std::string url;
 #if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    msg.url = file_path.value();
+    url = file_path.value();
 #else
     std::ostringstream sstr;
     sstr << gurl;
-    msg.url = sstr.str();
+    url = sstr.str();
 #endif
+    return url;
+}
 
+void PostCtrlTask(std::string head, GURL gurl) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+void PostCtrlTask(std::string head, GURL gurl, 
+    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.buf = iobuf;
+    msg.size = size;
+    msg.offset = offset;
+    msg.func2 = func2;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
 
-CtrlCenter::Message::Message() {}
+CtrlCenter::Message::Message() {
+    tab_id = -1;
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func1 = nullptr;
+    func2 = nullptr;
+    ptr = nullptr;
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -84,7 +115,7 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head;
+        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
@@ -97,17 +128,23 @@ void CtrlCenter::Run() {
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
+        }else if (msg.head == "@close") {
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                stream->Uninit();
+                streams_.erase(iter);
+            }
         }else if (msg.head == "@read") {
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                char* buf = new char[msg.size];
-                int iret = stream->Read(buf, msg.size, msg.offset);
+                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
                 if (msg.func2) {
-                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
+                    msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
-                delete buf;
             }
         }
         Wait(100);
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index fc9fa5c..5e52510 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -22,6 +22,7 @@
 
 namespace net {
 class URLRequest;
+class IOBuffer;
 }
 
 namespace mmt {
@@ -74,7 +75,7 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, unsigned char*, int);
+typedef void (*func2_t)(void*, void*, int);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -84,6 +85,8 @@ public:
         std::string body;
         std::string url;
         int   tab_id;
+
+        net::IOBuffer* buf;
         int   size;
         int   offset;
         func1_t func1;
@@ -110,7 +113,9 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
-void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl);
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 5694a52..eb5177b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -36,8 +36,7 @@
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
-URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : is_started(false),
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -63,6 +62,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::PostCtrlTask("@close", request_->url());
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -86,17 +86,8 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-  read_info->dest = dest;
-  read_info->dest_size = dest_size;
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoRead, 
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
+    &URLRequestMmtJob::DoRead, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -154,11 +145,13 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(void* thiz, int iret) {
-    LOG(INFO) << __func__ << " iret=" << iret;
-    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
-    if (job)
-        job->DidStart(iret);
+void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
+  }
 }
 
 void URLRequestMmtJob::DidStart(int iret) {
@@ -192,11 +185,18 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+  }
 }
 
-void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-  int result = read_info->dest_size;
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     read_info_.remaining_bytes -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index eaf4cb7..093763e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -51,7 +51,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
-    bool is_started;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
@@ -61,11 +60,11 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void *thiz, int iret);
+  static void DoStart(void* ptr, int iret);
   void DidStart(int iret);
 
-  static void DoRead(ReadMetaInfo* read_info);
-  void DidRead(ReadMetaInfo* read_info);
+  static void DoRead(void* ptr, void* data, int size);
+  void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
-- 
1.7.9.5


From 520ecb646b1cc59e1cc4c058f2b7907919084c4a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:28 -0800
Subject: [PATCH 27/34] enhance log for ctrl

---
 net/mmt/mmt_stream.cc                  |   16 ++++++++++------
 net/mmt/mmt_stream.h                   |    2 +-
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 9aee8d5..780490a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -115,25 +115,26 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             StreamPtr stream = new Stream(url);
             streams_.insert(pair_t(url, stream));
-            int64 size = -1;
+            long size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@close") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                stream->Uninit();
+                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -142,6 +143,9 @@ void CtrlCenter::Run() {
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
+                LOG(INFO) << __func__ << " head=" << msg.head 
+                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
+                    << " size=" << msg.size << " ptr=" << msg.ptr;
                 if (msg.func2) {
                     msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
@@ -171,7 +175,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
-    LOG(INFO) << __func__;
+    //LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -289,10 +293,10 @@ bool Stream::Init() {
     return false;
 }
 
-bool Stream::Prepare(int64 *size) {
+bool Stream::Prepare(long *size) {
     if (!Init()) return false;
     fseek(file_, 0L, SEEK_END);
-    int64 lret = ftell(file_);
+    long lret = ftell(file_);
     *size = lret;
     return true;
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 5e52510..bfb6711 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -49,7 +49,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
-    bool Prepare(int64 *size);
+    bool Prepare(long *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index eb5177b..493c6bb 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-- 
1.7.9.5


From da105b21fbc0786947a0d42355247ef1caa21577 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:54 -0800
Subject: [PATCH 28/34] add cictrl module

---
 .../docs/examples/api/cictrl/background.js         |   15 +++++++++
 .../docs/examples/api/cictrl/content_scripts.js    |   33 ++++++++++++++++++++
 .../docs/examples/api/cictrl/manifest.json         |   24 ++++++++++++++
 3 files changed, 72 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/background.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/manifest.json

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
new file mode 100644
index 0000000..e6b3978
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -0,0 +1,15 @@
+
+function log(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
+    log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
+    if (request.greeting == "hello" && sender.tab) {
+        sendResponse({farewell: "goodbye"});
+        chrome.tabs.executeScript(sender.tab.id, {
+            code: 'document.body.style.backgroundColor="red"'
+        });
+    }
+});
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
new file mode 100644
index 0000000..a73420c
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -0,0 +1,33 @@
+// detect the changes of storage and apply them into current page
+
+function log(msg) {
+    //alert(msg);
+    console.log(msg);
+}
+
+// for chrome.storage.local
+chrome.storage.onChanged.addListener(function(changes, namespace) {
+    if (namespace != "local") {
+        log("donot process the namespace = " + namespace);
+        return;
+    }
+
+    for (key in changes) {
+        var storageChange = changes[key];
+        log('Storage key "%s" in namespace "%s" changed. ' +
+            'Old value was "%s", new value is "%s".',
+            key,
+            namespace,
+            storageChange.oldValue,
+            storageChange.newValue);
+    }
+});
+
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
+// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+window.onload = function() {
+    log("window.onload");
+    chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
+        log(response.farewell);
+    });
+};
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
new file mode 100644
index 0000000..e955013
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -0,0 +1,24 @@
+{
+    "name" : "org.chromium.cictrl",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium ci control",
+    "permissions": [
+        "file://*/*",
+        "http://*/*",
+        "mmt://*/*",
+        "tabs", 
+        "storage"
+    ],
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    },
+    "content_scripts": [
+        {
+            "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
+            "run_at" : "document_end",
+            "js" : ["content_scripts.js"]
+        }
+    ]
+}
-- 
1.7.9.5


From d687ea44a680a4e9f951f085fb9b4522d30ac902 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 23:34:23 -0800
Subject: [PATCH 29/34] try chrome.storage module

---
 net/mmt/mmt_stream.cc                  |   66 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |   30 ++++++++++++++-
 net/url_request/url_request_mmt_job.cc |   38 +++++++++++++++++-
 net/url_request/url_request_mmt_job.h  |    4 ++
 4 files changed, 133 insertions(+), 5 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 780490a..1861832 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -21,6 +21,14 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 
 using namespace content;
 
@@ -91,6 +99,18 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
+// for @store
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.key = key;
+    msg.value = value;
+    msg.func3 = func3;
+    msg.ptr = ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
 
 CtrlCenter::Message::Message() {
     tab_id = -1;
@@ -101,6 +121,8 @@ CtrlCenter::Message::Message() {
     func2 = nullptr;
     ptr = nullptr;
 }
+CtrlCenter::Message::~Message() {
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -118,6 +140,12 @@ void CtrlCenter::Run() {
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
+        }else if (msg.head == "@test") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
+            Wait(5000);
+            if (msg.func3) {
+                msg.func3(msg.ptr, msg.key, msg.value);
+            }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
@@ -134,7 +162,6 @@ void CtrlCenter::Run() {
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -242,13 +269,43 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void GetRenderFrameInfo(Content* content) {
+void GetExtension(Content* content, BrowserContext* context) {
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    LOG(INFO) << __func__ << " frontend=" << frontend;
+    if (!frontend) {
+        return;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    LOG(INFO) << __func__ << " registry=" << registry;
+    if (registry) {
+        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+            LOG(INFO) << __func__ << " name=" << extension->name()
+                << " id=" << extension->id();
+            if (extension->name() == "org.chromium.cictrl") {
+                frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, content->storage_callback);
+                break;
+            }
+        }
+    }
+}
+
+
+void GetRenderFrameInfo(Content* content, bool has_storage) {
+    LOG(INFO) << __func__ << " begin";
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    LOG(INFO) << __func__ << " get rfh";
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
     }
 
+    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
@@ -258,6 +315,9 @@ void GetRenderFrameInfo(Content* content) {
             content->tab_url = sstr.str();
             LOG(INFO) << __func__ << " tab id=" << content->tab_id
                 << ", tab url=" << content->tab_url;
+            if (has_storage) {
+                GetExtension(content, web_contents->GetBrowserContext());
+            }
         }
     }
 }
@@ -272,6 +332,8 @@ namespace mmt {
 
 Content::Content() {
 }
+Content::~Content() {
+}
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index bfb6711..60e7979 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,6 +20,16 @@
 
 #include "url/gurl.h"
 
+#include "extensions/browser/api/storage/value_store_cache.h"
+
+class ValueStore;
+
+namespace extensions {
+class Extension;
+class StorageFrontend;
+class ValueStoreCache;
+}
+
 namespace net {
 class URLRequest;
 class IOBuffer;
@@ -29,16 +39,18 @@ namespace mmt {
 
 struct Content {
     Content();
+    ~Content();
+
     int process_id;
     int frame_id;
     int routing_id;
     int tab_id;
     std::string tab_url;
-    std::string data;
+    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content);
+void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -76,16 +88,25 @@ namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
+typedef void (*func3_t)(void*, std::string, std::string);
 
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
+        ~Message();
+
         std::string head;
         std::string body;
         std::string url;
         int   tab_id;
+        
+        // for storage
+        std::string key;
+        std::string value;
+        func3_t func3;
 
+        // for stream I/O
         net::IOBuffer* buf;
         int   size;
         int   offset;
@@ -113,9 +134,14 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+
 void PostCtrlTask(std::string head, GURL gurl);
+// for @open
 void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+// for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 493c6bb..4a8f832 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -33,6 +33,14 @@
 #include "net/mmt/mmt_stream.h"
 #include "content/public/browser/browser_thread.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -54,8 +62,9 @@ URLRequestMmtJob::URLRequestMmtJob(
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
+  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_));
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -204,6 +213,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
+  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
+  //  &URLRequestMmtJob::DoStore, (void*)this);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -214,6 +227,29 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+  }
+}
+void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
+    LOG(INFO) << __func__ << " set value";
+    std::string szkey = "xyz";
+    std::string szvalue = "test yzxu 123";
+    scoped_ptr<base::Value> value;
+    value.reset(new base::StringValue(szvalue));
+    storage->Set(ValueStore::DEFAULTS, szkey, *value);
+}
+void URLRequestMmtJob::DidStore() {
+  LOG(INFO) << __func__;
+  GetRenderFrameInfo(&content_);
+  //content_.frontend->RunWithStorage(content_.extension, 
+  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+}
+
 void URLRequestMmtJob::DoTest(void* ptr) {
 }
 
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 093763e..cfc23a1 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -69,6 +69,10 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
+  static void StorageCallback(ValueStore* storage);
+  static void DoStore(void* ptr, std::string key, std::string value);
+  void DidStore();
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
-- 
1.7.9.5


From 044d7229a379aa7a199cc5a089e9b13f9aac9bfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 00:51:36 -0800
Subject: [PATCH 30/34] testing failed for chrome.storage

---
 net/mmt/mmt_stream.cc                  |  115 ++---------------------------
 net/mmt/mmt_stream.h                   |   32 ++++----
 net/url_request/url_request_mmt_job.cc |  127 +++++++++++++++++++++++++-------
 net/url_request/url_request_mmt_job.h  |   11 ++-
 4 files changed, 133 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1861832..8bedeaf 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,19 +1,5 @@
 #include "net/mmt/mmt_stream.h"
 
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/resource_context.h"
-#include "content/public/browser/content_browser_client.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/render_view_host.h"
-
-#include "content/public/common/content_client.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
-#include "content/public/renderer/render_view.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -21,15 +7,6 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-
-
 using namespace content;
 
 namespace mmt {
@@ -99,12 +76,14 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
-// for @store
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, 
+    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
     CtrlCenter::Message msg;
     msg.head = head;
     msg.key = key;
     msg.value = value;
+    msg.content = *content;
     msg.func3 = func3;
     msg.ptr = ptr;
     msg.url = GURL2string(gurl);
@@ -144,7 +123,7 @@ void CtrlCenter::Run() {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             Wait(5000);
             if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value);
+                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
             }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
@@ -241,90 +220,6 @@ void PostNativeMsg(std::string msg) {
 } // namespace mmt
 
 
-namespace mmt {
-
-bool GetRequestID(const net::URLRequest* request, Content* content) {
-    if (!content) return false;
-
-    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        content->routing_id = rinfo->GetRouteID();
-        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
-    }
-
-    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
-            &content->process_id, &content->frame_id);
-    if (is_ok) {
-        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
-            << ", render_frame_id: " << content->frame_id;
-    }
-
-    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
-        << ", frame id=" << rinfo->GetRenderFrameID()
-        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
-        << ", is main frame=" << rinfo->IsMainFrame()
-        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
-        << "";
-
-    return is_ok;
-}
-
-void GetExtension(Content* content, BrowserContext* context) {
-    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
-    LOG(INFO) << __func__ << " frontend=" << frontend;
-    if (!frontend) {
-        return;
-    }
-
-    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
-    LOG(INFO) << __func__ << " registry=" << registry;
-    if (registry) {
-        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
-        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
-            LOG(INFO) << __func__ << " name=" << extension->name()
-                << " id=" << extension->id();
-            if (extension->name() == "org.chromium.cictrl") {
-                frontend->RunWithStorage(extension, 
-                    extensions::settings_namespace::LOCAL, content->storage_callback);
-                break;
-            }
-        }
-    }
-}
-
-
-void GetRenderFrameInfo(Content* content, bool has_storage) {
-    LOG(INFO) << __func__ << " begin";
-    content->tab_id = -1;
-    content->tab_url = "";
-
-    LOG(INFO) << __func__ << " get rfh";
-    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    if (rfh && rfh->GetParent()) {
-        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
-        rfh = rfh->GetParent();
-    }
-
-    LOG(INFO) << __func__ << " rfh=" << rfh;
-    if (rfh) {
-        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        if (web_contents) {
-            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            std::ostringstream sstr;
-            sstr << web_contents->GetURL();
-            content->tab_url = sstr.str();
-            LOG(INFO) << __func__ << " tab id=" << content->tab_id
-                << ", tab url=" << content->tab_url;
-            if (has_storage) {
-                GetExtension(content, web_contents->GetBrowserContext());
-            }
-        }
-    }
-}
-
-} // namespace mmt
-
-
 ///===============================
 /// for class Stream and StreamPool
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 60e7979..c725f0d 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,15 +20,22 @@
 
 #include "url/gurl.h"
 
-#include "extensions/browser/api/storage/value_store_cache.h"
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
 
-class ValueStore;
-
-namespace extensions {
-class Extension;
-class StorageFrontend;
-class ValueStoreCache;
-}
 
 namespace net {
 class URLRequest;
@@ -46,11 +53,8 @@ struct Content {
     int routing_id;
     int tab_id;
     std::string tab_url;
-    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
-bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -83,12 +87,11 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 } // namespace mmt
 
 
-
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string);
+typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -104,6 +107,7 @@ public:
         // for storage
         std::string key;
         std::string value;
+        mmt::Content content;
         func3_t func3;
 
         // for stream I/O
@@ -141,7 +145,7 @@ void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
 // for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 // for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4a8f832..6f79339 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,15 +31,6 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
-#include "content/public/browser/browser_thread.h"
-
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
 
 namespace net {
 
@@ -61,10 +52,9 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
-  mmt::GetRequestID(request_, &content_);
-  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
+  GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -213,10 +203,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
-  //  &URLRequestMmtJob::DoStore, (void*)this);
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
+  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
+    &URLRequestMmtJob::DoStore, (void*)this);
+  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -227,14 +217,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-  }
-}
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -243,11 +225,23 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    thiz->kvstoring_.first = key;
+    thiz->kvstoring_.second = value;
+    mmt::Content* pcontent = new mmt::Content;
+    *pcontent = *content;
+    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
+  }
+}
 void URLRequestMmtJob::DidStore() {
   LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_);
-  //content_.frontend->RunWithStorage(content_.extension, 
-  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+  GetRenderFrameInfo(&content_, true);
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
@@ -256,4 +250,83 @@ void URLRequestMmtJob::DoTest(void* ptr) {
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
+bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+    if (!content) return false;
+    const content::ResourceRequestInfo* rinfo = 
+        content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+    }
+
+    bool is_ok = content::ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    LOG(INFO) << __func__ 
+        << ", render_process_id: " << content->process_id
+        << ", render_frame_id: " << content->frame_id
+        << ", routing ID: " << content->routing_id;
+    return is_ok;
+}
+
+bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+    if (!content) return false;
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    if (!frontend) {
+        LOG(INFO) << __func__ << " frontend is nullptr";
+        return false;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    if (!registry) {
+        LOG(INFO) << __func__ << " registry is nullptr";
+        return false;
+    }
+
+    const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+    for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+        if (extension->name() == "org.chromium.cictrl") {
+            LOG(INFO) << __func__ 
+                << " extension name=" << extension->name()
+                << " extension id=" << extension->id();
+            frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, base::Bind(&URLRequestMmtJob::StorageCallback));
+            break;
+        }
+    }
+    return true;
+}
+
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+    if (!content) return;
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    content::RenderFrameHost* rfh = 
+        content::RenderFrameHost::FromID(content->process_id, content->frame_id);
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+    if (!rfh) {
+        LOG(INFO) << __func__ << " rfh is nullptr";
+        return;
+    }
+
+    content::WebContents* web_contents = 
+        content::WebContents::FromRenderFrameHost(rfh);
+    if (!web_contents) {
+        LOG(INFO) << __func__ << " web_contents is nullptr";
+        return;
+    }
+    content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+    std::ostringstream sstr;
+    sstr << web_contents->GetURL();
+    content->tab_url = sstr.str();
+    LOG(INFO) << __func__ 
+        << " tab id=" << content->tab_id
+        << ", tab url=" << content->tab_url;
+    if (has_storage) {
+        GetExtension(content, web_contents->GetBrowserContext());
+    }
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cfc23a1..6d3e3da 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -23,6 +23,9 @@ class TaskRunner;
 namespace file_util {
 struct FileInfo;
 }
+namespace content {
+class BrowserContext;
+}
 
 namespace net {
 
@@ -70,15 +73,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidTest(void* ptr);
 
   static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value);
+  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
   void DidStore();
 
+  // get info for render
+  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
+  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
   mmt::Content content_;
+  std::pair<std::string, std::string> kvstoring_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9c7e96016284709461f6c4fbff887242724cfff8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 01:45:22 -0800
Subject: [PATCH 31/34] refine for native messaging

---
 net/mmt/mmt_control.cc                 |  189 +++++++++++++++++++++++++++
 net/mmt/mmt_control.h                  |   71 ++++++++++
 net/mmt/mmt_inc.h                      |   40 ++++++
 net/mmt/mmt_stream.cc                  |  222 ++------------------------------
 net/mmt/mmt_stream.h                   |   89 +------------
 net/net.gypi                           |    1 +
 net/url_request/url_request_mmt_job.cc |   77 +++++------
 net/url_request/url_request_mmt_job.h  |   22 ++--
 8 files changed, 358 insertions(+), 353 deletions(-)
 create mode 100644 net/mmt/mmt_control.cc
 create mode 100644 net/mmt/mmt_control.h
 create mode 100644 net/mmt/mmt_inc.h

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
new file mode 100644
index 0000000..cd6274c
--- /dev/null
+++ b/net/mmt/mmt_control.cc
@@ -0,0 +1,189 @@
+#include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+static MmtControl *g_ctrl = nullptr;
+
+void StartMmtCtrl() {
+    if (!g_ctrl) {
+        g_ctrl = new MmtControl;
+    }
+    if (g_ctrl->IsRunning()) {
+        return;
+    }
+    g_ctrl->Reset();
+    g_ctrl->Start();
+    LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
+}
+
+void PostCtrlMsg(ctrl_msg_t &msg) {
+    if (!g_ctrl) return;
+    g_ctrl->Push(msg);
+}
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.body = body;
+    msg.tabid = tabid;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.sinfo = sinfo;
+    msg.ptr= ptr;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+} // namespace mmt
+
+
+/// for class MmtControl
+namespace mmt {
+
+ctrl_msg_t::ctrl_msg_t() {
+    head = "";
+    body = "";
+    uri = "";
+    tabid = -1;
+    ptr = nullptr;
+
+    sinfo.buf = nullptr;
+    sinfo.size = 0;
+    sinfo.offset = 0;
+    sinfo.func = nullptr;
+}
+ctrl_msg_t::~ctrl_msg_t() {
+}
+
+MmtControl::MmtControl() : SimpleThread("mmt_control"){
+    running_ = false;
+}
+MmtControl::~MmtControl() {}
+
+void MmtControl::Run() {
+    LOG(INFO) << __func__ << " begin";
+    running_ = true;
+    while(loop_) {
+        ctrl_msg_t msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        std::string head = msg.head;
+        std::string uri = msg.uri;
+        LOG(INFO) << __func__ << " head=" << head << " uri=" << uri;
+
+        if (head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (head == "@test") {
+            //..
+        }else if (msg.head == "@open") {
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(stream_t(uri, stream));
+            long lsize = -1;
+            stream->Prepare(&lsize);
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+            }
+        }else if (msg.head == "@close") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                streams_.erase(iter);
+            }
+        }else if (msg.head == "@read") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+                LOG(INFO) << __func__ 
+                    << " head=" << head 
+                    << " iret=" << iret 
+                    << " uri=" << uri
+                    << " size=" << msg.sinfo.size 
+                    << " offset=" << msg.sinfo.offset 
+                    << " ptr=" << msg.ptr;
+                if (msg.sinfo.func) {
+                    msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+                }
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+    LOG(INFO) << __func__ << " end";
+}
+
+void MmtControl::Reset() {
+    loop_ = true;
+}
+bool MmtControl::IsRunning() {
+    return running_;
+}
+
+bool MmtControl::Pop(ctrl_msg_t &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void MmtControl::Push(ctrl_msg_t &msg) {
+    //LOG(INFO) << __func__;
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+
+void PostNativeMsg(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
+}
+
+} // namespace mmt
+
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
new file mode 100644
index 0000000..f02c47c
--- /dev/null
+++ b/net/mmt/mmt_control.h
@@ -0,0 +1,71 @@
+#ifndef NET_MMT_MMT_CONTROL_H_
+#define NET_MMT_MMT_CONTROL_H_
+
+#include <string>
+#include "net/mmt/mmt_stream.h"
+
+namespace net {
+class IOBuffer;
+}
+
+namespace mmt {
+
+struct stream_info_t;
+// (ptr, stream_info_t, errno)
+typedef void (*stream_func_t)(void*, stream_info_t&, int);
+struct stream_info_t {
+    net::IOBuffer*  buf;
+    int             size;
+    int             offset;
+    stream_func_t   func;
+};
+
+struct ctrl_msg_t {
+    ctrl_msg_t();
+    ~ctrl_msg_t();
+
+    std::string head;
+    std::string body;
+    std::string uri;
+    int   tabid;
+    void* ptr;
+
+    stream_info_t sinfo;
+};
+
+class MmtControl : public base::SimpleThread {
+public:
+    MmtControl();
+    virtual ~MmtControl();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(ctrl_msg_t& msg);
+    void Push(ctrl_msg_t& msg);
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<ctrl_msg_t> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+
+namespace mmt {
+
+void StartMmtCtrl();
+void PostNativeMsg(std::string msg);
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl);
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+} // namespace mmt
+
+#endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
new file mode 100644
index 0000000..f5ba4f7
--- /dev/null
+++ b/net/mmt/mmt_inc.h
@@ -0,0 +1,40 @@
+#ifndef NET_MMT_MMT_INC_H_
+#define NET_MMT_MMT_INC_H_
+
+#include <string>
+#include <sstream>
+
+#include "base/values.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+
+#include "net/base/file_stream.h"
+#include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
+#include "net/udp/udp_socket.h"
+
+#include "extensions/common/extension.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "url/gurl.h"
+
+namespace mmt{
+void Wait(int ms);
+std::string GURL2FilePath(GURL& gurl);
+std::string GURL2String(GURL& gurl);
+}
+
+#endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 8bedeaf..6e5be76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,235 +1,34 @@
 #include "net/mmt/mmt_stream.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "net/udp/udp_socket.h"
-#include "net/base/io_buffer.h"
-#include "net/base/filename_util.h"
-
-using namespace content;
+#include "net/mmt/mmt_inc.h"
 
 namespace mmt {
 
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-void PostNativeMsg(std::string msg);
-
-
-static CtrlCenter *gCenter = nullptr;
-void StartCtrlCenter() {
-    if (!gCenter) {
-        gCenter = new CtrlCenter;
-    }
-    if (gCenter->IsRunning()) {
-        return;
-    }
-    gCenter->Reset();
-    gCenter->Start();
-    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
-}
-
-void PostCtrlMsg(CtrlCenter::Message &msg) {
-    if (!gCenter) return;
-    gCenter->Push(msg);
-}
-
-std::string GURL2string(GURL& gurl) {
+std::string GURL2FilePath(GURL& gurl) {
     std::string url;
-#if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    url = file_path.value();
-#else
+    return file_path.value();
+}
+std::string GURL2String(GURL& gurl) {
     std::ostringstream sstr;
     sstr << gurl;
-    url = sstr.str();
-#endif
-    return url;
-}
-
-void PostCtrlTask(std::string head, GURL gurl) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-void PostCtrlTask(std::string head, GURL gurl, 
-    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.buf = iobuf;
-    msg.size = size;
-    msg.offset = offset;
-    msg.func2 = func2;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, 
-    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.key = key;
-    msg.value = value;
-    msg.content = *content;
-    msg.func3 = func3;
-    msg.ptr = ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-
-CtrlCenter::Message::Message() {
-    tab_id = -1;
-    buf = nullptr;
-    size = 0;
-    offset = 0;
-    func1 = nullptr;
-    func2 = nullptr;
-    ptr = nullptr;
-}
-CtrlCenter::Message::~Message() {
-}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
-    running_ = false;
-}
-CtrlCenter::~CtrlCenter() {}
-
-void CtrlCenter::Run() {
-    LOG(INFO) << __func__ << " begin";
-    running_ = true;
-    while(loop_) {
-        Message msg;
-        if (!Pop(msg)) {
-            Wait(500);
-            continue;
-        }
-
-        if (msg.head == "@ctrl") {
-            PostNativeMsg(msg.body);
-        }else if (msg.head == "@test") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            Wait(5000);
-            if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
-            }
-        }else if (msg.head == "@open") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            StreamPtr stream = new Stream(url);
-            streams_.insert(pair_t(url, stream));
-            long size = -1;
-            stream->Prepare(&size);
-            if (msg.func1) {
-                msg.func1(msg.ptr, size);
-            }
-        }else if (msg.head == "@close") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                streams_.erase(iter);
-            }
-        }else if (msg.head == "@read") {
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
-                LOG(INFO) << __func__ << " head=" << msg.head 
-                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
-                    << " size=" << msg.size << " ptr=" << msg.ptr;
-                if (msg.func2) {
-                    msg.func2(msg.ptr, (void*)msg.buf, iret);
-                }
-            }
-        }
-        Wait(100);
-    };
-    running_ = false;
-    LOG(INFO) << __func__ << " end";
+    return sstr.str();
 }
 
-void CtrlCenter::Reset() {
-    loop_ = true;
+content_t::content_t() {
 }
-bool CtrlCenter::IsRunning() {
-    return running_;
-}
-
-bool CtrlCenter::Pop(Message &msg) {
-    if (queue_.empty())
-        return false;
-    lock_.Acquire();
-    msg = queue_.back();
-    queue_.pop_back();
-    lock_.Release();
-    return true;
-}
-
-void CtrlCenter::Push(Message &msg) {
-    //LOG(INFO) << __func__;
-    lock_.Acquire();
-    queue_.insert(queue_.begin(), msg);
-    lock_.Release();
-}
-
-void PostNativeMsg(std::string msg) {
-    int sock = socket(AF_INET, SOCK_DGRAM, 0);
-    if(sock <= 0) {
-        LOG(INFO) << __func__ << " Open failed sock=" << sock;
-        return;
-    }
-    
-    int port = 54321;
-    std::string szaddr = "127.0.0.1";
-    net::IPAddressNumber ipnum;
-    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
-        return;
-    }
-
-    net::IPEndPoint ip(ipnum, port);
-    struct sockaddr addr;
-    socklen_t addrlen;
-    if(!ip.ToSockAddr(&addr, &addrlen)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ToSockAddr failed";
-        return;
-    }
-
-    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
-    LOG(INFO) << __func__ << " sendto iret=" << iret;
-    close(sock);
+content_t::~content_t() {
 }
 
 } // namespace mmt
 
 
-///===============================
 /// for class Stream and StreamPool
-
 namespace mmt {
 
-Content::Content() {
-}
-Content::~Content() {
-}
-
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -260,8 +59,11 @@ bool Stream::Prepare(long *size) {
 
 int Stream::Read(char *buf, int size, int offset) {
     if (!Init()) return -1;
-    fseek(file_, offset, SEEK_SET);
+    int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
+    if (iret <= 0) {
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+    }
     return iret; 
 }
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c725f0d..b4d11b9 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -17,36 +17,19 @@
 #include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
 #include "base/time/time.h"
-
 #include "url/gurl.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-
 
+class ValueStore;
 namespace net {
-class URLRequest;
 class IOBuffer;
 }
 
 namespace mmt {
 
-struct Content {
-    Content();
-    ~Content();
+struct content_t {
+    content_t();
+    ~content_t();
 
     int process_id;
     int frame_id;
@@ -81,72 +64,10 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::pair<std::string, StreamPtr> stream_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
 } // namespace mmt
 
 
-namespace mmt {
-
-typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
-
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        Message();
-        ~Message();
-
-        std::string head;
-        std::string body;
-        std::string url;
-        int   tab_id;
-        
-        // for storage
-        std::string key;
-        std::string value;
-        mmt::Content content;
-        func3_t func3;
-
-        // for stream I/O
-        net::IOBuffer* buf;
-        int   size;
-        int   offset;
-        func1_t func1;
-        func2_t func2;
-        void* ptr;
-    };
-
-    CtrlCenter();
-    virtual ~CtrlCenter();
-    virtual void Run() override;
-
-    void Reset();
-    bool IsRunning();
-    bool Pop(Message &msg);
-    void Push(Message &msg);
-
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
-
-void StartCtrlCenter();
-void PostCtrlMsg(CtrlCenter::Message &msg);
-
-void PostCtrlTask(std::string head, GURL gurl);
-// for @open
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
-// for @read
-void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
-
-} // namespace mmt
-
 #endif
diff --git a/net/net.gypi b/net/net.gypi
index cc6c1b2..99959ba 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -701,6 +701,7 @@
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
       'mmt/mmt_stream.cc',
+      'mmt/mmt_control.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6f79339..b985b58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -6,7 +6,6 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
@@ -14,9 +13,6 @@
 #include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
@@ -24,13 +20,12 @@
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_file_dir_job.h"
-#include "url/gurl.h"
 
 #if defined(OS_WIN)
 #include "base/win/shortcut.h"
 #endif
 
-#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
 
 namespace net {
 
@@ -46,19 +41,21 @@ URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    const scoped_refptr<base::TaskRunner>& task_runner)
     : URLRequestJob(request, network_delegate),
-      mmt_task_runner_(mmt_task_runner),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::StartCtrlCenter();
+  mmt::StartMmtCtrl();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
-  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.func = &URLRequestMmtJob::DoStart;
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -86,8 +83,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
-    &URLRequestMmtJob::DoRead, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.buf = dest;
+  sinfo.size = dest_size;
+  sinfo.offset = read_info_.read_offset;
+  sinfo.func = &URLRequestMmtJob::DoRead;
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -143,9 +144,10 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
@@ -185,12 +187,13 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
-  LOG(INFO) << __func__ << " data size=" << size;
+void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret << 
+    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
   }
 }
 
@@ -203,10 +206,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
-    &URLRequestMmtJob::DoStore, (void*)this);
-  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -217,6 +216,14 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+}
+
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
+
+/// for storage testing
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -225,32 +232,8 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    thiz->kvstoring_.first = key;
-    thiz->kvstoring_.second = value;
-    mmt::Content* pcontent = new mmt::Content;
-    *pcontent = *content;
-    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
-  }
-}
-void URLRequestMmtJob::DidStore() {
-  LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_, true);
-}
-
-void URLRequestMmtJob::DoTest(void* ptr) {
-}
-
-void URLRequestMmtJob::DidTest(void* ptr) {
-}
 
-bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+bool URLRequestMmtJob::GetRequestID(mmt::content_t* content, const URLRequest* request) {
     if (!content) return false;
     const content::ResourceRequestInfo* rinfo = 
         content::ResourceRequestInfo::ForRequest(request);
@@ -267,7 +250,7 @@ bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* req
     return is_ok;
 }
 
-bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserContext* context) {
     if (!content) return false;
     extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
     if (!frontend) {
@@ -295,7 +278,7 @@ bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserConte
     return true;
 }
 
-void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
     if (!content) return;
     content->tab_id = -1;
     content->tab_url = "";
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6d3e3da..25ee072 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,7 +15,9 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_control.h"
 
 namespace base {
 class TaskRunner;
@@ -63,31 +65,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void* ptr, int iret);
+  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, void* data, int size);
+  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
-  static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
-  void DidStore();
-
   // get info for render
-  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
-  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
-  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+  static void StorageCallback(ValueStore* storage);
+  static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
+  static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
 
  private:
-  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
-  mmt::Content content_;
-  std::pair<std::string, std::string> kvstoring_;
+  mmt::content_t content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 3e265c6c92f0a6ce0b9006f8fa1bed688c8072c9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 02:41:17 -0800
Subject: [PATCH 32/34] refine cictrl to support native msg

---
 .../docs/examples/api/cictrl/background.js         |   60 +++++++-
 .../docs/examples/api/cictrl/content_scripts.js    |   16 +--
 .../docs/examples/api/cictrl/manifest.json         |    6 +-
 .../docs/examples/api/cictrl/res/install_host.sh   |   40 ++++++
 .../api/cictrl/res/native-messaging-cictrl         |  151 ++++++++++++++++++++
 .../api/cictrl/res/org.chromium.cictrl.json        |   13 ++
 .../docs/examples/api/cictrl/res/uninstall_host.sh |   25 ++++
 7 files changed, 297 insertions(+), 14 deletions(-)
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
index e6b3978..7f2c324 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/background.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -1,15 +1,69 @@
+var port = null;
 
 function log(msg) {
+  msg = "[CI] " + msg;
   //alert(msg);
   console.log(msg);
 }
 
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  tabid = message["tabid"];
+  if (tabid == undefined) {
+    logMsg("no valid tabid");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript(tabid, {code: js});
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS(tabid, {code: css});
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cictrl";
+  port = chrome.runtime.connectNative(hostName);
+  log("port=" + port);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+// listen tab event
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    log("tabs complete id=" + tab.id);
+  }
+});
+
+// listen message
 chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
     log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
     if (request.greeting == "hello" && sender.tab) {
+        log("recv msg from tabs id=" + sender.tab.id);
+        connect();
         sendResponse({farewell: "goodbye"});
-        chrome.tabs.executeScript(sender.tab.id, {
-            code: 'document.body.style.backgroundColor="red"'
-        });
     }
 });
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
index a73420c..745d2ff 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -1,12 +1,12 @@
-// detect the changes of storage and apply them into current page
-
 function log(msg) {
     //alert(msg);
     console.log(msg);
 }
 
 // for chrome.storage.local
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
 chrome.storage.onChanged.addListener(function(changes, namespace) {
+    log("storage.onChanged");
     if (namespace != "local") {
         log("donot process the namespace = " + namespace);
         return;
@@ -14,17 +14,13 @@ chrome.storage.onChanged.addListener(function(changes, namespace) {
 
     for (key in changes) {
         var storageChange = changes[key];
-        log('Storage key "%s" in namespace "%s" changed. ' +
-            'Old value was "%s", new value is "%s".',
-            key,
-            namespace,
-            storageChange.oldValue,
-            storageChange.newValue);
+        log("Storage key " + key + " in namespace " + namespace + " changed. " +
+            "Old value was " + storageChange.oldValue + ", new value is " + storageChange.newValue);
     }
 });
 
-// chrome.storage.StorageArea.get()/set()/remove()/clear()
-// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+// document.readyState == "loading/interactive/complete"; 
+// it can ensure this script to be ran after window.onload
 window.onload = function() {
     log("window.onload");
     chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
index e955013..e86769b 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -1,12 +1,16 @@
 {
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
     "name" : "org.chromium.cictrl",
     "version": "1.0",
     "manifest_version": 2,
     "description": "chromium ci control",
     "permissions": [
+        "mmt://*/*",
         "file://*/*",
         "http://*/*",
-        "mmt://*/*",
+        "https://*/",
+        "nativeMessaging",
+        "notifications",
         "tabs", 
         "storage"
     ],
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
new file mode 100755
index 0000000..85f19b0
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cictrl
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
new file mode 100755
index 0000000..05279a2
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -0,0 +1,151 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+
+import time
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  try:
+    sys.stdout.flush()
+  except: return
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+  sock.bind((host, port))
+  while True:
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
+      break
+    send_message(msg)
+  sock.close()
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  sys.exit(0)
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
new file mode 100644
index 0000000..26aaa64
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cictrl",
+  "description": "Chromium Native Messaging For CI Control",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
new file mode 100755
index 0000000..52f9909
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Google/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromoium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR='$HOME/.config/chromium/NativeMessagingHosts'
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+rm $TARGET_DIR/org.chromium.cictrl.json
+echo Native messaging host $HOST_NAME has been uninstalled.
-- 
1.7.9.5


From 4150cc290d8ebe02dba5b62153cefac877814b7a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 03:06:43 -0800
Subject: [PATCH 33/34] try to fix mmt_stream read error

---
 net/mmt/mmt_control.cc                 |    2 +-
 net/mmt/mmt_stream.cc                  |    9 ++++++---
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index cd6274c..f7eba41 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -124,7 +124,7 @@ void MmtControl::Run() {
                 }
             }
         }
-        Wait(100);
+        Wait(10);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6e5be76..1674c20 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -51,9 +51,11 @@ bool Stream::Init() {
 
 bool Stream::Prepare(long *size) {
     if (!Init()) return false;
-    fseek(file_, 0L, SEEK_END);
+    int ierr = fseek(file_, 0L, SEEK_END);
     long lret = ftell(file_);
-    *size = lret;
+    if (size)
+        *size = lret;
+    LOG(INFO) << __func__ << " ierr=" << ierr << " lret=" << lret;
     return true;
 }
 
@@ -62,7 +64,8 @@ int Stream::Read(char *buf, int size, int offset) {
     int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
     if (iret <= 0) {
-        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret 
+            << " size=" << size << " offset=" << offset;
     }
     return iret; 
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b985b58..85bbe58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -145,6 +145,7 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 
 URLRequestMmtJob::~URLRequestMmtJob() {
   LOG(INFO) << __func__ << " thiz=" << this;
+  mmt::PostCtrlTask("@close", request_->url());
 }
 
 void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
-- 
1.7.9.5


From 22e6e75525838282b935c22dd7b98433b7706ce4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 04:59:30 -0800
Subject: [PATCH 34/34] fix read error

---
 net/mmt/mmt_control.cc                 |    6 +++---
 net/mmt/mmt_control.h                  |    9 ++++++---
 net/mmt/mmt_inc.h                      |    1 +
 net/url_request/url_request_mmt_job.cc |   16 +++++++++-------
 net/url_request/url_request_mmt_job.h  |    6 +++---
 5 files changed, 22 insertions(+), 16 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index f7eba41..516dee8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -40,11 +40,11 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     PostCtrlMsg(msg);
 }
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.sinfo = sinfo;
-    msg.ptr= ptr;
+    msg.ptr = ptr;
     msg.uri = GURL2FilePath(gurl);
     PostCtrlMsg(msg);
 }
@@ -118,7 +118,7 @@ void MmtControl::Run() {
                     << " uri=" << uri
                     << " size=" << msg.sinfo.size 
                     << " offset=" << msg.sinfo.offset 
-                    << " ptr=" << msg.ptr;
+                    << " ptr=" << msg.ptr.get();
                 if (msg.sinfo.func) {
                     msg.sinfo.func(msg.ptr, msg.sinfo, iret);
                 }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f02c47c..635328e 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -6,13 +6,16 @@
 
 namespace net {
 class IOBuffer;
+class URLRequestJob;
 }
 
 namespace mmt {
 
 struct stream_info_t;
+typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
+
 // (ptr, stream_info_t, errno)
-typedef void (*stream_func_t)(void*, stream_info_t&, int);
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
 struct stream_info_t {
     net::IOBuffer*  buf;
     int             size;
@@ -28,7 +31,7 @@ struct ctrl_msg_t {
     std::string body;
     std::string uri;
     int   tabid;
-    void* ptr;
+    job_refptr_t ptr;
 
     stream_info_t sinfo;
 };
@@ -65,7 +68,7 @@ void PostCtrlTask(std::string head, GURL gurl);
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index f5ba4f7..6bec3f4 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -13,6 +13,7 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 #include "net/udp/udp_socket.h"
+#include "net/url_request/url_request_job.h"
 
 #include "extensions/common/extension.h"
 #include "extensions/browser/extension_system.h"
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 85bbe58..a3d4b6f 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -47,6 +47,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartMmtCtrl();
+  read_info_.url = request_->url();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
@@ -55,7 +56,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   mmt::stream_info_t sinfo;
   sinfo.func = &URLRequestMmtJob::DoStart;
-  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -88,7 +89,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
-  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -144,13 +145,14 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " begin thiz=" << this;
+  mmt::PostCtrlTask("@close", read_info_.url);
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::PostCtrlTask("@close", request_->url());
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
@@ -188,10 +190,10 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 25ee072..dd34d13 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -62,13 +62,13 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    std::string uri;
+    GURL url;
   };
 
-  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
-- 
1.7.9.5

