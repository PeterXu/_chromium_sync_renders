diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index 798bea3..d47b636 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,6 +261,11 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -270,7 +275,8 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -328,7 +334,8 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -368,7 +375,8 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get());
+                                            ftp_factory_.get(),
+                                            mmt_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index 900dbfc..fa54638 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,6 +21,7 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -146,6 +147,7 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 8b39439..4f21760 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,6 +54,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -581,6 +582,11 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -597,7 +603,8 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -662,7 +669,8 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -749,7 +757,8 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get()));
+                              ftp_factory_.get(),
+                              mmt_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 383fc40..505da31 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,6 +34,7 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -229,6 +230,7 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..2b8537b 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1158,7 +1162,8 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory,
+    net::MmtTransactionFactory* mmt_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1212,6 +1217,14 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  DCHECK(mmt_transaction_factory);
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(mmt_transaction_factory));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index 244107f..fcc9fef 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,6 +34,7 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
+#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -60,6 +61,7 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -358,7 +360,8 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory,
+      net::MmtTransactionFactory* mmt_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -53,6 +53,7 @@ class URLPattern {
     SCHEME_CHROMEUI   = 1 << 4,
     SCHEME_EXTENSION  = 1 << 5,
     SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..dabd7d5 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 256 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,15 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
new file mode 100644
index 0000000..92d7e17
--- /dev/null
+++ b/net/mmt/mmt_information.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_INFORMATION_H_
+#define NET_MMT_MMT_INFORMATION_H_
+
+#include "url/gurl.h"
+
+namespace net {
+
+class MmtRequestInfo {
+ public:
+  // The requested URL.
+  GURL url;
+};
+
+class MmtResponseInfo {
+ public:
+  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  }
+
+  // Expected content size, in bytes, as reported by SIZE command. Only valid
+  // for file downloads. -1 means unknown size.
+  int64 expected_content_size;
+
+  bool is_local;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
new file mode 100644
index 0000000..1f0e8c7
--- /dev/null
+++ b/net/mmt/mmt_transaction.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2008 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction.h"
+#include "net/mmt/mmt_transaction_impl.h"
+#include "net/mmt/mmt_transaction_factory.h"
+
+namespace net {
+
+class MmtTransactionFactoryImpl : public MmtTransactionFactory {
+public:
+  MmtTransactionFactoryImpl() : suspended_(false) {
+  }
+  virtual ~MmtTransactionFactoryImpl() override {
+  }
+
+  virtual MmtTransaction* CreateTransaction() override {
+    if (suspended_)
+      return NULL;
+
+    return new MmtTransactionImpl();
+  }
+
+  virtual void Suspend(bool suspend) override {
+    suspended_ = suspend;
+  }
+
+private:
+  bool suspended_;
+};
+
+MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
+  return new MmtTransactionFactoryImpl();
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
new file mode 100644
index 0000000..d3c225d
--- /dev/null
+++ b/net/mmt/mmt_transaction.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_H_
+#define NET_MMT_MMT_TRANSACTION_H_
+
+#include "net/base/completion_callback.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_states.h"
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtResponseInfo;
+class MmtRequestInfo;
+class BoundNetLog;
+
+// Represents a single MMT transaction.
+class NET_EXPORT_PRIVATE MmtTransaction {
+ public:
+  // Stops any pending IO and destroys the transaction object.
+  virtual ~MmtTransaction() {}
+
+  // Starts the MMT transaction (i.e., sends the MMT request).
+  //
+  // Returns OK if the transaction could be started synchronously, which means
+  // that the request was served from the cache (only supported for directory
+  // listings).  ERR_IO_PENDING is returned to indicate that the
+  // CompletionCallback will be notified once response info is available or if
+  // an IO error occurs.  Any other return value indicates that the transaction
+  // could not be started.
+  //
+  // Regardless of the return value, the caller is expected to keep the
+  // request_info object alive until Destroy is called on the transaction.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  // Profiling information for the request is saved to |net_log| if non-NULL.
+  virtual int Start(const MmtRequestInfo* request_info,
+                    const CompletionCallback& callback,
+                    const BoundNetLog& net_log) = 0;
+
+  // Once response info is available for the transaction, response data may be
+  // read by calling this method.
+  //
+  // Response data is copied into the given buffer and the number of bytes
+  // copied is returned.  ERR_IO_PENDING is returned if response data is not
+  // yet available.  The CompletionCallback is notified when the data copy
+  // completes, and it is passed the number of bytes that were successfully
+  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
+  // the error.  Any other negative return value indicates that the transaction
+  // could not be read.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  virtual int Read(IOBuffer* buf,
+                   int buf_len,
+                   const CompletionCallback& callback) = 0;
+
+  // Returns the response info for this transaction or NULL if the response
+  // info is not available.
+  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
+
+  // Returns the load state for this transaction.
+  virtual LoadState GetLoadState() const = 0;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
new file mode 100644
index 0000000..b9b1e6a
--- /dev/null
+++ b/net/mmt/mmt_transaction_factory.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
+#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
+
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtTransaction;
+
+// An interface to a class that can create MmtTransaction objects.
+class NET_EXPORT MmtTransactionFactory {
+ public:
+  virtual ~MmtTransactionFactory() {}
+
+  // Creates a MmtTransaction object.
+  virtual MmtTransaction* CreateTransaction() = 0;
+
+  // Suspends the creation of new transactions. If |suspend| is false, creation
+  // of new transactions is resumed.
+  virtual void Suspend(bool suspend) = 0;
+
+  static MmtTransactionFactory* CreateFactory();
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
new file mode 100644
index 0000000..aef7733
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -0,0 +1,214 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction_impl.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/compiler_specific.h"
+#include "base/metrics/histogram.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "net/base/address_list.h"
+#include "net/base/connection_type_histograms.h"
+#include "net/base/escape.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_log.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+
+//const int kMmtBufLen = 256*1024;
+
+namespace net {
+
+MmtTransactionImpl::MmtTransactionImpl() :
+      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
+                              base::Unretained(this))),
+      request_(NULL),
+      read_data_buf_len_(0),
+      next_state_(STATE_NONE)
+{}
+
+MmtTransactionImpl::~MmtTransactionImpl() {
+}
+
+int MmtTransactionImpl::Stop(int error) {
+  LOG(INFO) << __FUNCTION__;
+  next_state_ = STATE_STOP;
+  last_error_ = error;
+  return OK;
+}
+
+int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+  return ERR_NOT_IMPLEMENTED;
+}
+
+int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
+                                 const CompletionCallback& callback,
+                                 const BoundNetLog& net_log) {
+  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
+
+  net_log_ = net_log;
+  request_ = request_info;
+  next_state_ = STATE_CONNECT;
+#if 0
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+#endif
+
+  return OK;
+}
+
+int MmtTransactionImpl::Read(IOBuffer* buf,
+                                int buf_len,
+                                const CompletionCallback& callback) {
+  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
+  DCHECK(buf);
+  DCHECK_GT(buf_len, 0);
+
+  read_data_buf_ = buf;
+  read_data_buf_len_ = buf_len;
+
+  next_state_ = STATE_READ;
+  int rv = OK;
+#if 0
+  rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+#endif
+  return rv;
+}
+
+const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
+  LOG(INFO) << __FUNCTION__;
+  return &response_;
+}
+
+LoadState MmtTransactionImpl::GetLoadState() const {
+  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  switch (next_state_) {
+    case STATE_NONE: 
+      return LOAD_STATE_IDLE;
+    case STATE_CONNECT:
+      return LOAD_STATE_CONNECTING; 
+    case STATE_READ:
+      return LOAD_STATE_READING_RESPONSE;
+    default: 
+      break;
+  }
+  return LOAD_STATE_IDLE;
+}
+
+void MmtTransactionImpl::ResetStateForRestart() {
+  user_callback_.Reset();
+  response_ = MmtResponseInfo();
+  read_data_buf_ = NULL;
+  read_data_buf_len_ = 0;
+  last_error_ = OK;
+  next_state_ = STATE_NONE;
+}
+
+void MmtTransactionImpl::DoCallback(int rv) {
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
+
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
+}
+
+void MmtTransactionImpl::OnIOComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION(
+          "436634 MmtTransactionImpl::OnIOComplete"));
+
+  int rv = DoLoop(result);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
+}
+
+int MmtTransactionImpl::DoLoop(int result) {
+  DCHECK(next_state_ != STATE_NONE);
+
+  int rv = result;
+  do {
+    State state = next_state_;
+    next_state_ = STATE_NONE;
+    switch (state) {
+      case STATE_STOP:
+        DCHECK(rv == OK);
+        rv = DoStop();
+        break;
+      case STATE_CONNECT:
+        DCHECK(rv == OK);
+        rv = DoConnect();
+        break;
+      case STATE_CONNECT_COMPLETE:
+        rv = DoConnectComplete(rv);
+        break;
+      case STATE_READ:
+        DCHECK(rv == OK);
+        rv = DoRead();
+        break;
+      case STATE_READ_COMPLETE:
+        rv = DoReadComplete(rv);
+        break;
+      default:
+        NOTREACHED() << "bad state";
+        rv = ERR_UNEXPECTED;
+        break;
+    }
+  } while (rv != ERR_IO_PENDING);
+  return rv;
+}
+
+
+// Data Connection
+
+int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __FUNCTION__;
+  next_state_ = STATE_READ;
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __FUNCTION__;
+  next_state_ = STATE_CONNECT_COMPLETE;
+  // TODO: open file/network and then call io_callback_
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnectComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
+  if (result != OK)
+    return Stop(result);
+  return OK;
+}
+
+int MmtTransactionImpl::DoRead() {
+  LOG(INFO) << __FUNCTION__;
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+
+  next_state_ = STATE_READ_COMPLETE;
+  read_data_buf_->data()[0] = 0;
+  //TODO: read data from network/file
+  // impement one callback to mmt receiver
+  return 0;
+}
+
+int MmtTransactionImpl::DoReadComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
+  return result;
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
new file mode 100644
index 0000000..098ee53
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
+#define NET_MMT_MMT_TRANSACTION_IMPL_H_
+
+#include <string>
+#include <utility>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "net/base/address_list.h"
+#include "net/base/auth.h"
+#include "net/base/net_log.h"
+#include "net/dns/host_resolver.h"
+#include "net/dns/single_request_host_resolver.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+
+namespace net {
+
+class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
+ public:
+  MmtTransactionImpl();
+  virtual ~MmtTransactionImpl() override;
+
+  virtual int Stop(int error);
+  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
+
+  // MmtTransaction methods:
+  virtual int Start(const MmtRequestInfo* request_info,
+            const CompletionCallback& callback,
+            const BoundNetLog& net_log) override;
+  virtual int Read(IOBuffer* buf,
+           int buf_len,
+           const CompletionCallback& callback) override;
+  virtual const MmtResponseInfo* GetResponseInfo() const override;
+  virtual LoadState GetLoadState() const override;
+
+ private:
+  void ResetStateForRestart();
+  void DoCallback(int result);
+  void OnIOComplete(int result);
+  int DoLoop(int result);
+
+  int DoStop();
+  int DoConnect();
+  int DoConnectComplete(int result);
+  int DoRead();
+  int DoReadComplete(int result);
+
+  enum State {
+    STATE_STOP,
+    STATE_CONNECT,
+    STATE_CONNECT_COMPLETE,
+    STATE_READ,
+    STATE_READ_COMPLETE,
+    STATE_NONE
+  };
+
+private:
+  CompletionCallback io_callback_;
+  CompletionCallback user_callback_;
+
+  BoundNetLog net_log_;
+  const MmtRequestInfo* request_;
+  MmtResponseInfo response_;
+
+  scoped_refptr<IOBuffer> read_data_buf_;
+  int read_data_buf_len_;
+
+  int last_error_;
+  State next_state_;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..eb27320 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,14 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..0335fc6 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,8 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1139,6 +1141,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1184,6 +1188,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..a671486
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,38 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+#include "url/gurl.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    MmtTransactionFactory* mmt_transaction_factory)
+    : mmt_transaction_factory_(mmt_transaction_factory) {
+  DCHECK(mmt_transaction_factory_);
+}
+
+MmtProtocolHandler::~MmtProtocolHandler() {
+}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  LOG(INFO) << "mmt url: " << request->url();
+  return new URLRequestMmtJob(request,
+                              network_delegate,
+                              mmt_transaction_factory_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..10bfe1d
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace net {
+
+class MmtTransactionFactory;
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for MMT jobs. 
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  MmtTransactionFactory* mmt_transaction_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..dee151e 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,6 +18,7 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -44,6 +45,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +213,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +408,15 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  if (mmt_enabled_) {
+    mmt_transaction_factory_.reset(
+        MmtTransactionFactory::CreateFactory());
+    job_factory->SetProtocolHandler("mmt",
+        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+  }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..c2cec99 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -117,6 +118,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +210,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
@@ -215,6 +227,7 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
+  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..6b14fdd
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,172 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_mmt_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction_factory.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_transaction_factory.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_error_job.h"
+#include "url/gurl.h"
+
+namespace net {
+
+URLRequestMmtJob::URLRequestMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    MmtTransactionFactory* mmt_transaction_factory)
+    : URLRequestJob(request, network_delegate),
+      read_in_progress_(false),
+      mmt_transaction_factory_(mmt_transaction_factory),
+      weak_ptr_factory_(this) {
+  DCHECK(mmt_transaction_factory);
+}
+
+URLRequestMmtJob::~URLRequestMmtJob() {
+}
+
+#if 0
+bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
+  // Disallow all redirects.
+  return false;
+}
+#endif
+
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  LOG(INFO) << "GetMimeType";
+  DCHECK(request_);
+  if (mmt_transaction_->GetResponseInfo()->is_local) {
+    *mime_type = "text/vnd.chromium.local";
+    return true;
+  }
+  return false;
+}
+
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << "Start";
+  DCHECK(!mmt_transaction_);
+  StartMmtTransaction();
+}
+
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << "Kill";
+  if (mmt_transaction_)
+    mmt_transaction_.reset();
+
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+}
+
+int URLRequestMmtJob::StartMmtTransaction() {
+  // Create a transaction.
+  DCHECK(!mmt_transaction_);
+  mmt_request_info_.url = request_->url();
+  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+
+  // No matter what, we want to report our status as IO pending since we will
+  // be notifying our consumer asynchronously via OnStartCompleted.
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  int rv = ERR_FAILED;
+  if (mmt_transaction_) {
+    rv = mmt_transaction_->Start(
+        &mmt_request_info_,
+        base::Bind(&URLRequestMmtJob::OnStartCompleted,
+                   base::Unretained(this)),
+        request_->net_log());
+    if (rv == ERR_IO_PENDING)
+      return rv;
+  }
+  return rv;
+}
+
+void URLRequestMmtJob::OnStartCompleted(int result) {
+  // Clear the IO_PENDING status
+  SetStatus(URLRequestStatus());
+
+  // Note that mmt_transaction_ may be NULL due to a creation failure.
+  if (mmt_transaction_) {
+    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+    // the content size information manually.
+    set_expected_content_size(
+        mmt_transaction_->GetResponseInfo()->expected_content_size);
+  }
+
+  if (result == OK) {
+    NotifyHeadersComplete();
+  }else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+}
+
+void URLRequestMmtJob::OnReadCompleted(int result) {
+  read_in_progress_ = false;
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  } else {
+    // Clear the IO_PENDING status
+    SetStatus(URLRequestStatus());
+  }
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
+                                    int buf_size,
+                                    int* bytes_read) {
+  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  DCHECK_NE(buf_size, 0);
+  DCHECK(bytes_read);
+  DCHECK(!read_in_progress_);
+
+  int rv = mmt_transaction_->Read(buf, buf_size,
+                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
+                                             base::Unretained(this)));
+  if (rv >= 0) {
+    *bytes_read = rv;
+    return true;
+  }
+
+  if (rv == ERR_IO_PENDING) {
+    read_in_progress_ = true;
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..cf3036e
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace net {
+
+class NetworkDelegate;
+class MmtTransactionFactory;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                   NetworkDelegate* network_delegate,
+                   MmtTransactionFactory* mmt_transaction_factory);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  // Overridden from URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool GetMimeType(std::string* mime_type) const override;
+
+ private:
+  int StartMmtTransaction();
+  void OnStartCompleted(int result);
+  void OnReadCompleted(int result);
+
+ private:
+  MmtRequestInfo mmt_request_info_;
+  scoped_ptr<MmtTransaction> mmt_transaction_;
+
+  HttpByteRange byte_range_;
+  bool read_in_progress_;
+
+  MmtTransactionFactory* mmt_transaction_factory_;
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
