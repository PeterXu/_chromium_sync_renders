From 9401570e18af49e61c3e7401cea75d30db89c06f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 03:45:47 -0800
Subject: [PATCH 1/7] a. fix revision of .DEPS.git; b. simulate mmt:// as
 file://

---
 .DEPS.git                                      |    2 +-
 build/common.gypi                              |    7 +
 components/cronet/tools/cr_cronet.py           |    2 +-
 net/BUILD.gn                                   |   17 ++
 net/url_request/mmt_protocol_handler.cc        |   57 +++++
 net/url_request/mmt_protocol_handler.h         |   44 ++++
 net/url_request/url_request_context_builder.cc |   15 ++
 net/url_request/url_request_context_builder.h  |   11 +
 net/url_request/url_request_mmt_job.cc         |  326 ++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h          |  110 ++++++++
 10 files changed, 589 insertions(+), 2 deletions(-)
 create mode 100644 net/url_request/mmt_protocol_handler.cc
 create mode 100644 net/url_request/mmt_protocol_handler.h
 create mode 100644 net/url_request/url_request_mmt_job.cc
 create mode 100644 net/url_request/url_request_mmt_job.h

diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..ffd9746 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,19 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "base/directory_lister.cc",
+      "base/directory_lister.h",
+      "url_request/url_request_file_dir_job.cc",
+      "url_request/url_request_file_dir_job.h",
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..3b62225
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request->url(), &file_path);
+
+  // Check file access permissions.
+  if (!network_delegate ||
+      !network_delegate->CanAccessFile(*request, file_path)) {
+    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
+  }
+
+  // We need to decide whether to create URLRequestFileJob for file access or
+  // URLRequestFileDirJob for directory access. To avoid accessing the
+  // filesystem, we only look at the path string here.
+  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // which doesn't end with a slash, should really be treated as a directory,
+  // and it then redirects to the URLRequestFileDirJob.
+  if (is_file &&
+      file_path.EndsWithSeparator() &&
+      file_path.IsAbsolute()) {
+    return new URLRequestFileDirJob(request, network_delegate, file_path);
+  }
+
+  // Use a regular file request job for all non-directories (including invalid
+  // file names).
+  return new URLRequestFileJob(request, network_delegate, file_path,
+                               file_task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..28ca9b6
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
+// then all file requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..efb9e5c 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+    if (mmt_enabled_) {
+      job_factory->SetProtocolHandler(
+      "mmt",
+      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+    }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..2aff0dd 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -117,6 +117,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +209,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..4443c1b
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,326 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
+// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_file_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/files/file_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace net {
+
+URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequesetMmtJob::URLRequesetMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const base::FilePath& file_path,
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : URLRequestJob(request, network_delegate),
+      file_path_(file_path),
+      stream_(new FileStream(file_task_runner)),
+      file_task_runner_(file_task_runner),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void URLRequesetMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  file_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequesetMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequesetMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+Filter* URLRequesetMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
+
+bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
+  return false;
+}
+
+void URLRequesetMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
+}
+
+void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+}
+
+void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
+
+URLRequesetMmtJob::~URLRequesetMmtJob() {
+}
+
+void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
+}
+
+void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+
+  // We use URLRequesetMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequesetMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequesetMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
+  }
+}
+
+void URLRequesetMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
+
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..1ff88d2
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,110 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const base::FilePath& file_path,
+                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
+
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  HttpByteRange byte_range_;
+  int64 remaining_bytes_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
-- 
1.7.9.5


From 819ebb00f5f4b906fa46955091a2613e2f22f1be Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 05:57:57 -0800
Subject: [PATCH 2/7] fix building error for mmt protocol

---
 net/BUILD.gn                            |    4 ---
 net/net.gyp                             |   12 +++++++
 net/net.gypi                            |    4 +++
 net/url_request/mmt_protocol_handler.cc |    6 ++--
 net/url_request/url_request_mmt_job.cc  |   60 +++++++++++++++----------------
 5 files changed, 49 insertions(+), 37 deletions(-)

diff --git a/net/BUILD.gn b/net/BUILD.gn
index ffd9746..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -143,10 +143,6 @@ component("net") {
 
   if (disable_mmt_support) {
     sources -= [
-      "base/directory_lister.cc",
-      "base/directory_lister.h",
-      "url_request/url_request_file_dir_job.cc",
-      "url_request/url_request_file_dir_job.h",
       "url_request/url_request_mmt_job.cc",
       "url_request/url_request_mmt_job.h",
       "url_request/mmt_protocol_handler.cc",
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..1597f24 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,18 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'base/directory_lister.cc',
+            'base/directory_lister.h',
+            'url_request/url_request_file_dir_job.cc',
+            'url_request/url_request_file_dir_job.h',
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..ee879d2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1135,6 +1135,8 @@
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1178,6 +1180,8 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 3b62225..86afe03 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -32,10 +32,10 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
   }
 
-  // We need to decide whether to create URLRequestFileJob for file access or
+  // We need to decide whether to create URLRequestMmtJob for file access or
   // URLRequestFileDirJob for directory access. To avoid accessing the
   // filesystem, we only look at the path string here.
-  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // The code in the URLRequestMmtJob::Start() method discovers that a path,
   // which doesn't end with a slash, should really be treated as a directory,
   // and it then redirects to the URLRequestFileDirJob.
   if (is_file &&
@@ -46,7 +46,7 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
 
   // Use a regular file request job for all non-directories (including invalid
   // file names).
-  return new URLRequestFileJob(request, network_delegate, file_path,
+  return new URLRequestMmtJob(request, network_delegate, file_path,
                                file_task_runner_);
 }
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4443c1b..c5b8f9c 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -9,15 +9,15 @@
 // to do background file reads for us.
 //
 // Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
-// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
 // attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
 // signal from the OS that the overlapped read has completed.  It does so by
 // leveraging the MessageLoop::WatchObject API.
 
-#include "net/url_request/url_request_file_job.h"
+#include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
@@ -47,14 +47,14 @@
 
 namespace net {
 
-URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
     : file_size(0),
       mime_type_result(false),
       file_exists(false),
       is_directory(false) {
 }
 
-URLRequesetMmtJob::URLRequesetMmtJob(
+URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
     const base::FilePath& file_path,
@@ -66,25 +66,25 @@ URLRequesetMmtJob::URLRequesetMmtJob(
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
-void URLRequesetMmtJob::Start() {
+void URLRequestMmtJob::Start() {
   FileMetaInfo* meta_info = new FileMetaInfo();
   file_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
                  base::Unretained(meta_info)),
-      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(meta_info)));
 }
 
-void URLRequesetMmtJob::Kill() {
+void URLRequestMmtJob::Kill() {
   stream_.reset();
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
 }
 
-bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
@@ -103,7 +103,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
 
   int rv = stream_->Read(dest,
                          dest_size,
-                         base::Bind(&URLRequesetMmtJob::DidRead,
+                         base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
   if (rv >= 0) {
@@ -123,7 +123,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   if (meta_info_.is_directory) {
     // This happens when we discovered the file is a directory, so needs a
@@ -160,13 +160,13 @@ bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
 #endif
 }
 
-Filter* URLRequesetMmtJob::SetupFilter() const {
+Filter* URLRequestMmtJob::SetupFilter() const {
   // Bug 9936 - .svgz files needs to be decompressed.
   return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
       ? Filter::GZipFactory() : NULL;
 }
 
-bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
   if (meta_info_.mime_type_result) {
     *mime_type = meta_info_.mime_type;
@@ -175,7 +175,7 @@ bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
   return false;
 }
 
-void URLRequesetMmtJob::SetExtraRequestHeaders(
+void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
@@ -196,16 +196,16 @@ void URLRequesetMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
 }
 
-void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
 }
 
-URLRequesetMmtJob::~URLRequesetMmtJob() {
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                       FileMetaInfo* meta_info) {
   base::File::Info file_info;
   meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
@@ -219,10 +219,10 @@ void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                                     &meta_info->mime_type);
 }
 
-void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
   meta_info_ = *meta_info;
 
-  // We use URLRequesetMmtJob to handle files as well as directories without
+  // We use URLRequestMmtJob to handle files as well as directories without
   // trailing slash.
   // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
   // we will append trailing slash and redirect to FileDirJob.
@@ -243,16 +243,16 @@ void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
               base::File::FLAG_READ |
               base::File::FLAG_ASYNC;
   int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
                                     weak_ptr_factory_.GetWeakPtr()));
   if (rv != ERR_IO_PENDING)
     DidOpen(rv);
 }
 
-void URLRequesetMmtJob::DidOpen(int result) {
+void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -273,11 +273,11 @@ void URLRequesetMmtJob::DidOpen(int result) {
     // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
     tracked_objects::ScopedTracker tracking_profile1(
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequesetMmtJob::DidOpen 1"));
+            "423948 URLRequestMmtJob::DidOpen 1"));
 
     int rv = stream_->Seek(base::File::FROM_BEGIN,
                            byte_range_.first_byte_position(),
-                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                           base::Bind(&URLRequestMmtJob::DidSeek,
                                       weak_ptr_factory_.GetWeakPtr()));
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
@@ -292,7 +292,7 @@ void URLRequesetMmtJob::DidOpen(int result) {
   }
 }
 
-void URLRequesetMmtJob::DidSeek(int64 result) {
+void URLRequestMmtJob::DidSeek(int64 result) {
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -304,7 +304,7 @@ void URLRequesetMmtJob::DidSeek(int64 result) {
   NotifyHeadersComplete();
 }
 
-void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
-- 
1.7.9.5


From 1f5976f34f579f4c08029b399da98dd8943d4a07 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 25 Dec 2014 20:59:17 -0800
Subject: [PATCH 3/7] register mmt:// into chromium

---
 .../api/web_navigation/frame_navigation_state.cc   |    1 +
 chrome/browser/history/in_memory_url_index.cc      |    1 +
 chrome/browser/prerender/prerender_util.cc         |    3 +++
 chrome/browser/profiles/profile_io_data.cc         |   14 ++++++++++++++
 .../supervised_user/supervised_user_url_filter.cc  |    1 +
 chrome/browser/ui/location_bar/origin_chip_info.cc |    1 +
 chrome/browser/web_applications/web_app.cc         |    1 +
 .../navigation_metrics/navigation_metrics.cc       |    2 ++
 content/browser/browser_url_handler_impl.cc        |    1 +
 .../browser/child_process_security_policy_impl.cc  |    1 +
 content/common/savable_url_schemes.cc              |    1 +
 .../browser/api/web_request/web_request_api.cc     |    2 +-
 .../api/web_request/web_request_permissions.cc     |    2 +-
 extensions/common/extension.cc                     |    3 ++-
 extensions/common/url_pattern.cc                   |    2 ++
 extensions/common/url_pattern.h                    |    7 ++++---
 extensions/common/user_script.cc                   |    3 ++-
 extensions/renderer/dispatcher.cc                  |    1 +
 url/url_constants.cc                               |    1 +
 url/url_constants.h                                |    1 +
 url/url_util.cc                                    |    3 ++-
 21 files changed, 44 insertions(+), 8 deletions(-)

diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..d76a909 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+          content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..e4ed0ad 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,9 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_CHROMEUI   = 1 << 4,
-    SCHEME_EXTENSION  = 1 << 5,
-    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 4,
+    SCHEME_CHROMEUI   = 1 << 5,
+    SCHEME_EXTENSION  = 1 << 6,
+    SCHEME_FILESYSTEM = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
-- 
1.7.9.5


From b6a5c50865dee23020da0b887d3cd5da9d3f29da Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 31 Dec 2014 18:21:04 -0800
Subject: [PATCH 4/7] implement mmt protocol's framework

---
 chrome/browser/profiles/profile_io_data.cc     |    5 +-
 extensions/common/url_pattern.h                |    8 +-
 media/filters/ffmpeg_glue.cc                   |    2 +-
 net/mmt/mmt_information.h                      |   25 +++
 net/mmt/mmt_transaction.cc                     |   37 +++++
 net/mmt/mmt_transaction.h                      |   71 +++++++++
 net/mmt/mmt_transaction_factory.h              |   31 ++++
 net/mmt/mmt_transaction_impl.cc                |  195 ++++++++++++++++++++++++
 net/mmt/mmt_transaction_impl.h                 |   81 ++++++++++
 net/net.gyp                                    |    4 -
 net/net.gypi                                   |   10 +-
 net/url_request/mmt_protocol_handler.cc        |   34 +----
 net/url_request/mmt_protocol_handler.h         |   11 +-
 net/url_request/url_request_context_builder.cc |    2 +-
 net/url_request/url_request_mmt_job.cc         |  165 +++++---------------
 net/url_request/url_request_mmt_job.h          |   47 +-----
 16 files changed, 498 insertions(+), 230 deletions(-)
 create mode 100644 net/mmt/mmt_information.h
 create mode 100644 net/mmt/mmt_transaction.cc
 create mode 100644 net/mmt/mmt_transaction.h
 create mode 100644 net/mmt/mmt_transaction_factory.h
 create mode 100644 net/mmt/mmt_transaction_impl.cc
 create mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index d76a909..9d89cb3 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1219,10 +1219,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #if !defined(DISABLE_MMT_SUPPORT)
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(
-          content::BrowserThread::GetBlockingPool()->
-              GetTaskRunnerWithShutdownBehavior(
-                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+      new net::MmtProtocolHandler());
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index e4ed0ad..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,10 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_MMT        = 1 << 4,
-    SCHEME_CHROMEUI   = 1 << 5,
-    SCHEME_EXTENSION  = 1 << 6,
-    SCHEME_FILESYSTEM = 1 << 7,
+    SCHEME_CHROMEUI   = 1 << 4,
+    SCHEME_EXTENSION  = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..dabd7d5 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 256 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
new file mode 100644
index 0000000..60ed7e4
--- /dev/null
+++ b/net/mmt/mmt_information.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_INFORMATION_H_
+#define NET_MMT_MMT_INFORMATION_H_
+
+#include "url/gurl.h"
+
+namespace net {
+
+class MmtRequestInfo {
+ public:
+  // The requested URL.
+  GURL url;
+};
+
+class MmtResponseInfo {
+ public:
+
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
new file mode 100644
index 0000000..1f0e8c7
--- /dev/null
+++ b/net/mmt/mmt_transaction.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2008 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction.h"
+#include "net/mmt/mmt_transaction_impl.h"
+#include "net/mmt/mmt_transaction_factory.h"
+
+namespace net {
+
+class MmtTransactionFactoryImpl : public MmtTransactionFactory {
+public:
+  MmtTransactionFactoryImpl() : suspended_(false) {
+  }
+  virtual ~MmtTransactionFactoryImpl() override {
+  }
+
+  virtual MmtTransaction* CreateTransaction() override {
+    if (suspended_)
+      return NULL;
+
+    return new MmtTransactionImpl();
+  }
+
+  virtual void Suspend(bool suspend) override {
+    suspended_ = suspend;
+  }
+
+private:
+  bool suspended_;
+};
+
+MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
+  return new MmtTransactionFactoryImpl();
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
new file mode 100644
index 0000000..d3c225d
--- /dev/null
+++ b/net/mmt/mmt_transaction.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_H_
+#define NET_MMT_MMT_TRANSACTION_H_
+
+#include "net/base/completion_callback.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_states.h"
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtResponseInfo;
+class MmtRequestInfo;
+class BoundNetLog;
+
+// Represents a single MMT transaction.
+class NET_EXPORT_PRIVATE MmtTransaction {
+ public:
+  // Stops any pending IO and destroys the transaction object.
+  virtual ~MmtTransaction() {}
+
+  // Starts the MMT transaction (i.e., sends the MMT request).
+  //
+  // Returns OK if the transaction could be started synchronously, which means
+  // that the request was served from the cache (only supported for directory
+  // listings).  ERR_IO_PENDING is returned to indicate that the
+  // CompletionCallback will be notified once response info is available or if
+  // an IO error occurs.  Any other return value indicates that the transaction
+  // could not be started.
+  //
+  // Regardless of the return value, the caller is expected to keep the
+  // request_info object alive until Destroy is called on the transaction.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  // Profiling information for the request is saved to |net_log| if non-NULL.
+  virtual int Start(const MmtRequestInfo* request_info,
+                    const CompletionCallback& callback,
+                    const BoundNetLog& net_log) = 0;
+
+  // Once response info is available for the transaction, response data may be
+  // read by calling this method.
+  //
+  // Response data is copied into the given buffer and the number of bytes
+  // copied is returned.  ERR_IO_PENDING is returned if response data is not
+  // yet available.  The CompletionCallback is notified when the data copy
+  // completes, and it is passed the number of bytes that were successfully
+  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
+  // the error.  Any other negative return value indicates that the transaction
+  // could not be read.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  virtual int Read(IOBuffer* buf,
+                   int buf_len,
+                   const CompletionCallback& callback) = 0;
+
+  // Returns the response info for this transaction or NULL if the response
+  // info is not available.
+  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
+
+  // Returns the load state for this transaction.
+  virtual LoadState GetLoadState() const = 0;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
new file mode 100644
index 0000000..b9b1e6a
--- /dev/null
+++ b/net/mmt/mmt_transaction_factory.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
+#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
+
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtTransaction;
+
+// An interface to a class that can create MmtTransaction objects.
+class NET_EXPORT MmtTransactionFactory {
+ public:
+  virtual ~MmtTransactionFactory() {}
+
+  // Creates a MmtTransaction object.
+  virtual MmtTransaction* CreateTransaction() = 0;
+
+  // Suspends the creation of new transactions. If |suspend| is false, creation
+  // of new transactions is resumed.
+  virtual void Suspend(bool suspend) = 0;
+
+  static MmtTransactionFactory* CreateFactory();
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
new file mode 100644
index 0000000..2e512b5
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction_impl.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/compiler_specific.h"
+#include "base/metrics/histogram.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "net/base/address_list.h"
+#include "net/base/connection_type_histograms.h"
+#include "net/base/escape.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_log.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+
+//const int kMmtBufLen = 256*1024;
+
+namespace net {
+
+MmtTransactionImpl::MmtTransactionImpl() :
+      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
+                              base::Unretained(this))),
+      request_(NULL),
+      read_data_buf_len_(0),
+      next_state_(STATE_NONE)
+{}
+
+MmtTransactionImpl::~MmtTransactionImpl() {
+}
+
+int MmtTransactionImpl::Stop(int error) {
+  LOG(INFO) << "Stop";
+  next_state_ = STATE_STOP;
+  last_error_ = error;
+  return OK;
+}
+
+int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+  return ERR_NOT_IMPLEMENTED;
+}
+
+int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
+                                 const CompletionCallback& callback,
+                                 const BoundNetLog& net_log) {
+  LOG(INFO) << "Start, url=" << request_info->url;
+
+  net_log_ = net_log;
+  request_ = request_info;
+  next_state_ = STATE_CONNECT;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+
+  return OK;
+}
+
+int MmtTransactionImpl::Read(IOBuffer* buf,
+                                int buf_len,
+                                const CompletionCallback& callback) {
+  LOG(INFO) << "Read, buf_len=" << buf_len;
+  DCHECK(buf);
+  DCHECK_GT(buf_len, 0);
+
+  read_data_buf_ = buf;
+  read_data_buf_len_ = buf_len;
+
+  next_state_ = STATE_READ;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+  return rv;
+}
+
+const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
+  LOG(INFO) << "GetResponseInfo";
+  return &response_;
+}
+
+LoadState MmtTransactionImpl::GetLoadState() const {
+  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
+  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
+  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  return LOAD_STATE_IDLE;
+}
+
+void MmtTransactionImpl::ResetStateForRestart() {
+  user_callback_.Reset();
+  response_ = MmtResponseInfo();
+  read_data_buf_ = NULL;
+  read_data_buf_len_ = 0;
+  last_error_ = OK;
+  next_state_ = STATE_NONE;
+}
+
+void MmtTransactionImpl::DoCallback(int rv) {
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
+
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
+}
+
+void MmtTransactionImpl::OnIOComplete(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION(
+          "436634 MmtTransactionImpl::OnIOComplete"));
+
+  int rv = DoLoop(result);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
+}
+
+int MmtTransactionImpl::DoLoop(int result) {
+  DCHECK(next_state_ != STATE_NONE);
+
+  int rv = result;
+  do {
+    State state = next_state_;
+    next_state_ = STATE_NONE;
+    switch (state) {
+      case STATE_STOP:
+        DCHECK(rv == OK);
+        rv = DoStop();
+        break;
+      case STATE_CONNECT:
+        DCHECK(rv == OK);
+        rv = DoConnect();
+        break;
+      case STATE_CONNECT_COMPLETE:
+        rv = DoConnectComplete(rv);
+        break;
+      case STATE_READ:
+        DCHECK(rv == OK);
+        rv = DoRead();
+        break;
+      case STATE_READ_COMPLETE:
+        rv = DoReadComplete(rv);
+        break;
+      default:
+        NOTREACHED() << "bad state";
+        rv = ERR_UNEXPECTED;
+        break;
+    }
+  } while (rv != ERR_IO_PENDING);
+  return rv;
+}
+
+
+// Data Connection
+
+int MmtTransactionImpl::DoStop() {
+  next_state_ = STATE_READ;
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnect() {
+  next_state_ = STATE_CONNECT_COMPLETE;
+  // TODO: open file/network and then call io_callback_
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnectComplete(int result) {
+  if (result != OK)
+    return Stop(result);
+  return OK;
+}
+
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+
+  next_state_ = STATE_READ_COMPLETE;
+  read_data_buf_->data()[0] = 0;
+  //TODO: read data from network/file
+  return 0;
+}
+
+int MmtTransactionImpl::DoReadComplete(int result) {
+  return result;
+}
+
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
new file mode 100644
index 0000000..098ee53
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
+#define NET_MMT_MMT_TRANSACTION_IMPL_H_
+
+#include <string>
+#include <utility>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "net/base/address_list.h"
+#include "net/base/auth.h"
+#include "net/base/net_log.h"
+#include "net/dns/host_resolver.h"
+#include "net/dns/single_request_host_resolver.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+
+namespace net {
+
+class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
+ public:
+  MmtTransactionImpl();
+  virtual ~MmtTransactionImpl() override;
+
+  virtual int Stop(int error);
+  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
+
+  // MmtTransaction methods:
+  virtual int Start(const MmtRequestInfo* request_info,
+            const CompletionCallback& callback,
+            const BoundNetLog& net_log) override;
+  virtual int Read(IOBuffer* buf,
+           int buf_len,
+           const CompletionCallback& callback) override;
+  virtual const MmtResponseInfo* GetResponseInfo() const override;
+  virtual LoadState GetLoadState() const override;
+
+ private:
+  void ResetStateForRestart();
+  void DoCallback(int result);
+  void OnIOComplete(int result);
+  int DoLoop(int result);
+
+  int DoStop();
+  int DoConnect();
+  int DoConnectComplete(int result);
+  int DoRead();
+  int DoReadComplete(int result);
+
+  enum State {
+    STATE_STOP,
+    STATE_CONNECT,
+    STATE_CONNECT_COMPLETE,
+    STATE_READ,
+    STATE_READ_COMPLETE,
+    STATE_NONE
+  };
+
+private:
+  CompletionCallback io_callback_;
+  CompletionCallback user_callback_;
+
+  BoundNetLog net_log_;
+  const MmtRequestInfo* request_;
+  MmtResponseInfo response_;
+
+  scoped_refptr<IOBuffer> read_data_buf_;
+  int read_data_buf_len_;
+
+  int last_error_;
+  State next_state_;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gyp b/net/net.gyp
index 1597f24..eb27320 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -182,10 +182,6 @@
         }],
         ['disable_mmt_support==1', {
           'sources!': [
-            'base/directory_lister.cc',
-            'base/directory_lister.h',
-            'url_request/url_request_file_dir_job.cc',
-            'url_request/url_request_file_dir_job.h',
             'url_request/url_request_mmt_job.cc',
             'url_request/url_request_mmt_job.h',
             'url_request/mmt_protocol_handler.cc',
diff --git a/net/net.gypi b/net/net.gypi
index ee879d2..0d6cbf7 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1131,12 +1131,16 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1180,8 +1184,6 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 86afe03..416660f 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,48 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
-#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "net/url_request/url_request_mmt_job.h"
+#include "url/gurl.h"
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
+MmtProtocolHandler::MmtProtocolHandler() {}
 
 MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request->url(), &file_path);
-
-  // Check file access permissions.
-  if (!network_delegate ||
-      !network_delegate->CanAccessFile(*request, file_path)) {
-    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
-  }
-
-  // We need to decide whether to create URLRequestMmtJob for file access or
-  // URLRequestFileDirJob for directory access. To avoid accessing the
-  // filesystem, we only look at the path string here.
-  // The code in the URLRequestMmtJob::Start() method discovers that a path,
-  // which doesn't end with a slash, should really be treated as a directory,
-  // and it then redirects to the URLRequestFileDirJob.
-  if (is_file &&
-      file_path.EndsWithSeparator() &&
-      file_path.IsAbsolute()) {
-    return new URLRequestFileDirJob(request, network_delegate, file_path);
-  }
-
-  // Use a regular file request job for all non-directories (including invalid
-  // file names).
-  return new URLRequestMmtJob(request, network_delegate, file_path,
-                               file_task_runner_);
+  LOG(INFO) << "mmt url: " << request->url();
+  return new URLRequestMmtJob(request, network_delegate);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 28ca9b6..237c703 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,22 +12,16 @@
 
 class GURL;
 
-namespace base {
-class TaskRunner;
-}
-
 namespace net {
 
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
-// then all file requests will fail with ERR_ACCESS_DENIED.
+// Implements a ProtocolHandler for MMT jobs. 
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  explicit MmtProtocolHandler();
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +29,6 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index efb9e5c..1eda830 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -411,7 +411,7 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     if (mmt_enabled_) {
       job_factory->SetProtocolHandler(
       "mmt",
-      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+      new MmtProtocolHandler());
     }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c5b8f9c..b53b76e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -21,16 +21,12 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
-#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
@@ -38,47 +34,25 @@
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate,
-    const base::FilePath& file_path,
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    NetworkDelegate* network_delegate)
     : URLRequestJob(request, network_delegate),
-      file_path_(file_path),
-      stream_(new FileStream(file_task_runner)),
-      file_task_runner_(file_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
 void URLRequestMmtJob::Start() {
-  FileMetaInfo* meta_info = new FileMetaInfo();
-  file_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+  // TODO
+  LOG(INFO) << "Start";
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  // TODO
+  LOG(INFO) << "Kill";
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -87,6 +61,7 @@ void URLRequestMmtJob::Kill() {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
+  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
   DCHECK_GE(remaining_bytes_, 0);
@@ -101,11 +76,13 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
+  int rv = 0;
+  // TODO
+  //int rv = StreamRead(dest,
+  //                    dest_size,
+  //                    base::Bind(&URLRequestMmtJob::DidRead,
+  //                               weak_ptr_factory_.GetWeakPtr(),
+  //                               make_scoped_refptr(dest)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -125,58 +102,27 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
+  // TODO
+  LOG(INFO) << "IsRedirectResponse";
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  // TODO
+  LOG(INFO) << "SetupFilter";
+  return NULL; 
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
+  // TODO
+  LOG(INFO) << "GetMimeType";
+  *mime_type = std::string("application/x-mmt");
+  return true;
 }
 
-void URLRequestMmtJob::SetExtraRequestHeaders(
-    const HttpRequestHeaders& headers) {
+void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
+  LOG(INFO) << "SetExtraRequestHeaders";
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -197,59 +143,18 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::OnSeekComplete(int64 result) {
+  LOG(INFO) << "OnSeekComplete";
 }
 
 void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+  LOG(INFO) << "OnReadComplete";
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
-}
-
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
-  }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
 void URLRequestMmtJob::DidOpen(int result) {
+  LOG(INFO) << "DidOpen";
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
@@ -259,7 +164,8 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  int total_size = 0;
+  if (!byte_range_.ComputeBounds(total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -275,10 +181,13 @@ void URLRequestMmtJob::DidOpen(int result) {
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "423948 URLRequestMmtJob::DidOpen 1"));
 
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
+    int rv = 0; 
+    // TODO: seek to byte_range_.first_byte_position()
+    // int rv = StreamSeek(FROM_BEGIN,
+    //                     byte_range_.first_byte_position(),
+    //                     base::Bind(&URLRequestMmtJob::DidSeek,
+    //                                weak_ptr_factory_.GetWeakPtr()));
+    //  
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
       // into DidSeek().
@@ -293,6 +202,7 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
+  LOG(INFO) << "DidSeek";
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -305,6 +215,7 @@ void URLRequestMmtJob::DidSeek(int64 result) {
 }
 
 void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  LOG(INFO) << "DidRead";
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 1ff88d2..b9e871f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,7 +8,6 @@
 #include <string>
 #include <vector>
 
-#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
@@ -16,24 +15,13 @@
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
-namespace base {
-class TaskRunner;
-}
-namespace file_util {
-struct FileInfo;
-}
-
 namespace net {
 
-class FileStream;
-
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate,
-                    const base::FilePath& file_path,
-                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+                    NetworkDelegate* network_delegate);
 
   // URLRequestJob:
   void Start() override;
@@ -53,36 +41,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   int64 remaining_bytes() const { return remaining_bytes_; }
 
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
@@ -93,10 +52,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
 
-- 
1.7.9.5


From 31d7185f5b54cef7759d7a428bcc41f507c605aa Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 1 Jan 2015 00:11:27 -0800
Subject: [PATCH 5/7] write mmt module like ftp

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 +
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 +
 chrome/browser/profiles/profile_io_data.cc         |    6 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/mmt/mmt_information.h                          |    7 +
 net/mmt/mmt_transaction_impl.cc                    |   37 ++-
 net/net.gypi                                       |   12 +-
 net/url_request/mmt_protocol_handler.cc            |   13 +-
 net/url_request/mmt_protocol_handler.h             |    5 +-
 net/url_request/url_request_context_builder.cc     |   12 +-
 net/url_request/url_request_context_builder.h      |    2 +
 net/url_request/url_request_mmt_job.cc             |  255 ++++++++------------
 net/url_request/url_request_mmt_job.h              |   42 ++--
 15 files changed, 213 insertions(+), 216 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index 798bea3..d47b636 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,6 +261,11 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -270,7 +275,8 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -328,7 +334,8 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -368,7 +375,8 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get());
+                                            ftp_factory_.get(),
+                                            mmt_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index 900dbfc..fa54638 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,6 +21,7 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -146,6 +147,7 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 8b39439..4f21760 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,6 +54,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -581,6 +582,11 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -597,7 +603,8 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -662,7 +669,8 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -749,7 +757,8 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get()));
+                              ftp_factory_.get(),
+                              mmt_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 383fc40..505da31 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,6 +34,7 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -229,6 +230,7 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 9d89cb3..2b8537b 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,7 +1162,8 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory,
+    net::MmtTransactionFactory* mmt_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1217,9 +1218,10 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
+  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler());
+      new net::MmtProtocolHandler(mmt_transaction_factory));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index 244107f..fcc9fef 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,6 +34,7 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
+#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -60,6 +61,7 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -358,7 +360,8 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory,
+      net::MmtTransactionFactory* mmt_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 60ed7e4..92d7e17 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -17,7 +17,14 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
+  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  }
 
+  // Expected content size, in bytes, as reported by SIZE command. Only valid
+  // for file downloads. -1 means unknown size.
+  int64 expected_content_size;
+
+  bool is_local;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index 2e512b5..aef7733 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -38,7 +38,7 @@ MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << "Stop";
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
@@ -51,14 +51,16 @@ int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callb
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                                  const CompletionCallback& callback,
                                  const BoundNetLog& net_log) {
-  LOG(INFO) << "Start, url=" << request_info->url;
+  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
 
   net_log_ = net_log;
   request_ = request_info;
   next_state_ = STATE_CONNECT;
+#if 0
   int rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
 
   return OK;
 }
@@ -66,7 +68,7 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
 int MmtTransactionImpl::Read(IOBuffer* buf,
                                 int buf_len,
                                 const CompletionCallback& callback) {
-  LOG(INFO) << "Read, buf_len=" << buf_len;
+  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
@@ -74,21 +76,32 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_len_ = buf_len;
 
   next_state_ = STATE_READ;
-  int rv = DoLoop(OK);
+  int rv = OK;
+#if 0
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << "GetResponseInfo";
+  LOG(INFO) << __FUNCTION__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
-  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
-  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  switch (next_state_) {
+    case STATE_NONE: 
+      return LOAD_STATE_IDLE;
+    case STATE_CONNECT:
+      return LOAD_STATE_CONNECTING; 
+    case STATE_READ:
+      return LOAD_STATE_READING_RESPONSE;
+    default: 
+      break;
+  }
   return LOAD_STATE_IDLE;
 }
 
@@ -112,6 +125,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -161,35 +175,40 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_CONNECT_COMPLETE;
   // TODO: open file/network and then call io_callback_
   return OK;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
+  LOG(INFO) << __FUNCTION__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
   //TODO: read data from network/file
+  // impement one callback to mmt receiver
   return 0;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   return result;
 }
 
-
 }  // namespace net
diff --git a/net/net.gypi b/net/net.gypi
index 0d6cbf7..0335fc6 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,8 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1131,12 +1133,6 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
@@ -1145,6 +1141,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1190,6 +1188,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 416660f..a671486 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,21 @@
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler() {}
+MmtProtocolHandler::MmtProtocolHandler(
+    MmtTransactionFactory* mmt_transaction_factory)
+    : mmt_transaction_factory_(mmt_transaction_factory) {
+  DCHECK(mmt_transaction_factory_);
+}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
   LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request, network_delegate);
+  return new URLRequestMmtJob(request,
+                              network_delegate,
+                              mmt_transaction_factory_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 237c703..10bfe1d 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -14,6 +14,7 @@ class GURL;
 
 namespace net {
 
+class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
@@ -21,7 +22,7 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler();
+  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -29,6 +30,8 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
+  MmtTransactionFactory* mmt_transaction_factory_;
+
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 1eda830..dee151e 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,6 +18,7 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -408,11 +409,12 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-    if (mmt_enabled_) {
-      job_factory->SetProtocolHandler(
-      "mmt",
-      new MmtProtocolHandler());
-    }
+  if (mmt_enabled_) {
+    mmt_transaction_factory_.reset(
+        MmtTransactionFactory::CreateFactory());
+    job_factory->SetProtocolHandler("mmt",
+        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+  }
 #endif
 
   storage->set_job_factory(job_factory);
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index 2aff0dd..c2cec99 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -226,6 +227,7 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
+  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b53b76e..6b14fdd 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,8 +31,15 @@
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_transaction_factory.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
 #include "url/gurl.h"
 
@@ -40,198 +47,126 @@ namespace net {
 
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate)
+    NetworkDelegate* network_delegate,
+    MmtTransactionFactory* mmt_transaction_factory)
     : URLRequestJob(request, network_delegate),
-      remaining_bytes_(0),
-      weak_ptr_factory_(this) {}
-
-void URLRequestMmtJob::Start() {
-  // TODO
-  LOG(INFO) << "Start";
-}
-
-void URLRequestMmtJob::Kill() {
-  // TODO
-  LOG(INFO) << "Kill";
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
+      read_in_progress_(false),
+      mmt_transaction_factory_(mmt_transaction_factory),
+      weak_ptr_factory_(this) {
+  DCHECK(mmt_transaction_factory);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
-                                    int dest_size,
-                                    int* bytes_read) {
-  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
-  DCHECK_NE(dest_size, 0);
-  DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size) {
-    *bytes_read = 0;
-    return true;
-  }
-
-  int rv = 0;
-  // TODO
-  //int rv = StreamRead(dest,
-  //                    dest_size,
-  //                    base::Bind(&URLRequestMmtJob::DidRead,
-  //                               weak_ptr_factory_.GetWeakPtr(),
-  //                               make_scoped_refptr(dest)));
-  if (rv >= 0) {
-    // Data is immediately available.
-    *bytes_read = rv;
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-    return true;
-  }
-
-  // Otherwise, a read error occured.  We may just need to wait...
-  if (rv == ERR_IO_PENDING) {
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
-  return false;
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  // TODO
-  LOG(INFO) << "IsRedirectResponse";
+#if 0
+bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
+  // Disallow all redirects.
   return false;
 }
-
-Filter* URLRequestMmtJob::SetupFilter() const {
-  // TODO
-  LOG(INFO) << "SetupFilter";
-  return NULL; 
-}
+#endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  DCHECK(request_);
-  // TODO
   LOG(INFO) << "GetMimeType";
-  *mime_type = std::string("application/x-mmt");
-  return true;
-}
-
-void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
-  LOG(INFO) << "SetExtraRequestHeaders";
-  std::string range_header;
-  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
-    // We only care about "Range" header here.
-    std::vector<HttpByteRange> ranges;
-    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        // We don't support multiple range requests in one single URL request,
-        // because we need to do multipart encoding here.
-        // TODO(hclam): decide whether we want to support multiple range
-        // requests.
-        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-      }
-    }
+  DCHECK(request_);
+  if (mmt_transaction_->GetResponseInfo()->is_local) {
+    *mime_type = "text/vnd.chromium.local";
+    return true;
   }
+  return false;
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-  LOG(INFO) << "OnSeekComplete";
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << "Start";
+  DCHECK(!mmt_transaction_);
+  StartMmtTransaction();
 }
 
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-  LOG(INFO) << "OnReadComplete";
-}
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << "Kill";
+  if (mmt_transaction_)
+    mmt_transaction_.reset();
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
-void URLRequestMmtJob::DidOpen(int result) {
-  LOG(INFO) << "DidOpen";
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
-
-  if (result != OK) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-    return;
+int URLRequestMmtJob::StartMmtTransaction() {
+  // Create a transaction.
+  DCHECK(!mmt_transaction_);
+  mmt_request_info_.url = request_->url();
+  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+
+  // No matter what, we want to report our status as IO pending since we will
+  // be notifying our consumer asynchronously via OnStartCompleted.
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  int rv = ERR_FAILED;
+  if (mmt_transaction_) {
+    rv = mmt_transaction_->Start(
+        &mmt_request_info_,
+        base::Bind(&URLRequestMmtJob::OnStartCompleted,
+                   base::Unretained(this)),
+        request_->net_log());
+    if (rv == ERR_IO_PENDING)
+      return rv;
   }
+  return rv;
+}
 
-  int total_size = 0;
-  if (!byte_range_.ComputeBounds(total_size)) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
+void URLRequestMmtJob::OnStartCompleted(int result) {
+  // Clear the IO_PENDING status
+  SetStatus(URLRequestStatus());
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
-                     byte_range_.first_byte_position() + 1;
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = 0; 
-    // TODO: seek to byte_range_.first_byte_position()
-    // int rv = StreamSeek(FROM_BEGIN,
-    //                     byte_range_.first_byte_position(),
-    //                     base::Bind(&URLRequestMmtJob::DidSeek,
-    //                                weak_ptr_factory_.GetWeakPtr()));
-    //  
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
+  // Note that mmt_transaction_ may be NULL due to a creation failure.
+  if (mmt_transaction_) {
+    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+    // the content size information manually.
+    set_expected_content_size(
+        mmt_transaction_->GetResponseInfo()->expected_content_size);
   }
-}
 
-void URLRequestMmtJob::DidSeek(int64 result) {
-  LOG(INFO) << "DidSeek";
-  OnSeekComplete(result);
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
+  if (result == OK) {
+    NotifyHeadersComplete();
+  }else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
   }
-
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  LOG(INFO) << "DidRead";
-  if (result > 0) {
-    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  OnReadComplete(buf.get(), result);
-  buf = NULL;
-
+void URLRequestMmtJob::OnReadCompleted(int result) {
+  read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  } else {
+    // Clear the IO_PENDING status
+    SetStatus(URLRequestStatus());
+  }
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
+                                    int buf_size,
+                                    int* bytes_read) {
+  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  DCHECK_NE(buf_size, 0);
+  DCHECK(bytes_read);
+  DCHECK(!read_in_progress_);
+
+  int rv = mmt_transaction_->Read(buf, buf_size,
+                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
+                                             base::Unretained(this)));
+  if (rv >= 0) {
+    *bytes_read = rv;
+    return true;
   }
 
-  NotifyReadComplete(result);
+  if (rv == ERR_IO_PENDING) {
+    read_in_progress_ = true;
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index b9e871f..cf3036e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -11,50 +11,46 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
 namespace net {
 
+class NetworkDelegate;
+class MmtTransactionFactory;
+
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate);
+                   NetworkDelegate* network_delegate,
+                   MmtTransactionFactory* mmt_transaction_factory);
+
+ protected:
+  ~URLRequestMmtJob() override;
 
-  // URLRequestJob:
+  // Overridden from URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
-
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
- protected:
-  ~URLRequestMmtJob() override;
-
-  int64 remaining_bytes() const { return remaining_bytes_; }
 
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
+  int StartMmtTransaction();
+  void OnStartCompleted(int result);
+  void OnReadCompleted(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+ private:
+  MmtRequestInfo mmt_request_info_;
+  scoped_ptr<MmtTransaction> mmt_transaction_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
+  bool read_in_progress_;
 
+  MmtTransactionFactory* mmt_transaction_factory_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From 98f736ef3da53d6612b334658ba702e4ee2fcd1f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 2 Jan 2015 21:03:24 -0800
Subject: [PATCH 6/7] to implement mmt with the support of local file

---
 .gitignore                             |    2 +
 net/mmt/mmt_transaction_impl.cc        |   86 +++++++++++++++++++++-----------
 net/mmt/mmt_transaction_impl.h         |    4 ++
 net/url_request/url_request_mmt_job.cc |   26 ++++++----
 4 files changed, 80 insertions(+), 38 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8fa6763..a0181c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -437,3 +437,5 @@ v8.log
 /win8/metro_driver/metro_driver_version_resources.xml
 /x86-generic_out/
 /xcodebuild
+.xtags
+diff.log
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index aef7733..d927ab4 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -14,6 +14,12 @@
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
 #include "net/base/address_list.h"
 #include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
@@ -31,67 +37,66 @@ MmtTransactionImpl::MmtTransactionImpl() :
                               base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
-      next_state_(STATE_NONE)
-{}
+      next_state_(STATE_NONE) {
+}
 
 MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", error=" << error;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
 }
 
-int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+int MmtTransactionImpl::RestartIgnoringLastError(
+    const CompletionCallback& callback) {
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                                 const CompletionCallback& callback,
-                                 const BoundNetLog& net_log) {
-  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
-
+                              const CompletionCallback& callback,
+                              const BoundNetLog& net_log) {
+  LOG(INFO) << __func__ << ", url=" << request_info->url;
   net_log_ = net_log;
   request_ = request_info;
+
+  int rv = OK;
   next_state_ = STATE_CONNECT;
-#if 0
-  int rv = DoLoop(OK);
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
 
-  return OK;
+  return rv;
 }
 
+// @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
-                                int buf_len,
-                                const CompletionCallback& callback) {
-  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
+                             int buf_len,
+                             const CompletionCallback& callback) {
+  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
 
-  next_state_ = STATE_READ;
   int rv = OK;
-#if 0
+  next_state_ = STATE_READ;
   rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,7 +130,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -175,39 +180,62 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  LOG(INFO) << __func__ << ", is_file=" << is_file;
+  if (!is_file) {
+    return ERR_FAILED;
+  }
+
   next_state_ = STATE_CONNECT_COMPLETE;
-  // TODO: open file/network and then call io_callback_
-  return OK;
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path, flags, io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoConnectComplete(rv);
+  }
+  LOG(INFO) << __func__ << ", rv=" << rv;
+  return rv;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
+
   //TODO: read data from network/file
   // impement one callback to mmt receiver
-  return 0;
+  int rv = stream_->Read(read_data_buf_.get(),
+                         read_data_buf_len_,
+                         io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoReadComplete(rv);
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   return result;
 }
 
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 098ee53..fc25de2 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -22,6 +22,8 @@
 
 namespace net {
 
+class FileStream;
+
 class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
  public:
   MmtTransactionImpl();
@@ -69,6 +71,8 @@ private:
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
 
+  scoped_ptr<FileStream> stream_;
+
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6b14fdd..0fdb5a9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,8 +67,8 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << "GetMimeType";
-  DCHECK(request_);
+  LOG(INFO) << __FUNCTION__;
+  DCHECK(!mmt_transaction_);
   if (mmt_transaction_->GetResponseInfo()->is_local) {
     *mime_type = "text/vnd.chromium.local";
     return true;
@@ -77,13 +77,12 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << "Start";
-  DCHECK(!mmt_transaction_);
+  LOG(INFO) << __FUNCTION__;
   StartMmtTransaction();
 }
 
 void URLRequestMmtJob::Kill() {
-  LOG(INFO) << "Kill";
+  LOG(INFO) << __FUNCTION__;
   if (mmt_transaction_)
     mmt_transaction_.reset();
 
@@ -92,8 +91,12 @@ void URLRequestMmtJob::Kill() {
 }
 
 int URLRequestMmtJob::StartMmtTransaction() {
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(!mmt_transaction_);
+
+  // Create a transaction.
+  DCHECK(request_);
+  DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
 
@@ -107,13 +110,15 @@ int URLRequestMmtJob::StartMmtTransaction() {
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-    if (rv == ERR_IO_PENDING)
-      return rv;
   }
+  
+  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
   return rv;
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
@@ -133,6 +138,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -147,7 +154,8 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
+
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-- 
1.7.9.5


From 703dcc0d46897a4fce93a647879bc12bb546ec7e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 5 Jan 2015 07:06:50 -0800
Subject: [PATCH 7/7] done to support mmt local file

---
 net/mmt/mmt_information.h              |   15 ++-
 net/mmt/mmt_transaction.h              |    3 +
 net/mmt/mmt_transaction_impl.cc        |  224 ++++++++++++++++++--------------
 net/mmt/mmt_transaction_impl.h         |   17 +--
 net/url_request/url_request_mmt_job.cc |   80 ++++++------
 net/url_request/url_request_mmt_job.h  |    2 +-
 6 files changed, 189 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 92d7e17..3cf1f4d 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -6,6 +6,8 @@
 #define NET_MMT_MMT_INFORMATION_H_
 
 #include "url/gurl.h"
+#include "base/files/file_path.h"
+#include "net/http/http_byte_range.h"
 
 namespace net {
 
@@ -17,14 +19,17 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
-  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  MmtResponseInfo() {
+    total_size = 0;
+    read_offset = 0;
+    expected_content_size = 0;
   }
 
-  // Expected content size, in bytes, as reported by SIZE command. Only valid
-  // for file downloads. -1 means unknown size.
+  int64 total_size;
+  int64 read_offset;
   int64 expected_content_size;
-
-  bool is_local;
+  HttpByteRange byte_range;
+  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index d3c225d..9e45cbf 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -15,6 +15,7 @@ namespace net {
 class MmtResponseInfo;
 class MmtRequestInfo;
 class BoundNetLog;
+class HttpByteRange;
 
 // Represents a single MMT transaction.
 class NET_EXPORT_PRIVATE MmtTransaction {
@@ -64,6 +65,8 @@ class NET_EXPORT_PRIVATE MmtTransaction {
 
   // Returns the load state for this transaction.
   virtual LoadState GetLoadState() const = 0;
+
+  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index d927ab4..a090386 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -16,78 +16,92 @@
 #include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "base/threading/thread.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/address_list.h"
-#include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
 #include "net/mmt/mmt_information.h"
 
-//const int kMmtBufLen = 256*1024;
 
 namespace net {
 
 MmtTransactionImpl::MmtTransactionImpl() :
-      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
-                              base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
+  base::ThreadRestrictions::SetIOAllowed(true);
+  thread_.reset(new base::Thread("MMT Thread"));
+  thread_->StartWithOptions(
+      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
+  response_ = MmtResponseInfo();
+  stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
+  LOG(INFO) << __func__;
+  Stop(OK);
 }
 
 int MmtTransactionImpl::Stop(int error) {
   LOG(INFO) << __func__ << ", error=" << error;
-  next_state_ = STATE_STOP;
+
   last_error_ = error;
-  return OK;
+  next_state_ = STATE_STOP;
+  int rv = DoStop();
+  return rv;
 }
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
+  LOG(INFO) << __func__;
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                               const CompletionCallback& callback,
                               const BoundNetLog& net_log) {
-  LOG(INFO) << __func__ << ", url=" << request_info->url;
-  net_log_ = net_log;
   request_ = request_info;
+  user_callback_ = callback;
+  net_log_ = net_log;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_CONNECT;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  int rv = DoConnect();
+  DoCallback(rv);
+  return true;
+#endif
 }
 
 // @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
                              int buf_len,
                              const CompletionCallback& callback) {
-  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
-
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
+  user_callback_ = callback;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_READ;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOComplete,
+                   base::Unretained(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  return DoRead();
+#endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
@@ -110,7 +124,15 @@ LoadState MmtTransactionImpl::GetLoadState() const {
   return LOAD_STATE_IDLE;
 }
 
+void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
+  LOG(INFO) << __func__ 
+    << " range[" << range.first_byte_position() 
+    << ", "  << range.last_byte_position() << "]";
+  response_.byte_range = range;
+}
+
 void MmtTransactionImpl::ResetStateForRestart() {
+  LOG(INFO) << __func__ ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -119,26 +141,76 @@ void MmtTransactionImpl::ResetStateForRestart() {
   next_state_ = STATE_NONE;
 }
 
-void MmtTransactionImpl::DoCallback(int rv) {
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
+int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __func__;
+  next_state_ = STATE_NONE;
+  if (stream_) {
+    fclose((FILE*)stream_);
+    stream_ = nullptr;
+  }
+  return OK;
+}
 
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
+int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  if (!is_file) {
+    LOG(ERROR) << __func__ << ", invalid file";
+    return ERR_FAILED;
+  }
+  response_.file_path = file_path;
+
+  int64 file_size = 0;
+  if(!base::GetFileSize(file_path, &file_size)) {
+    LOG(ERROR) << __func__ << ", invalid file size";
+    return ERR_FAILED;
+  }
+
+  response_.total_size = file_size;
+  HttpByteRange byte_range = response_.byte_range;
+  if (!byte_range.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+  }
+
+  if (byte_range.first_byte_position() >= 0) {
+    response_.read_offset = byte_range.first_byte_position();
+  }else {
+    response_.read_offset = 0;
+  }
+  response_.expected_content_size = response_.total_size - response_.read_offset;
+  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
+        << ", total_size=" << response_.total_size
+        << ", content_size=" << response_.expected_content_size;
+
+  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  if (!fp) {
+    LOG(ERROR) << __func__ << ", fail to open file";
+    return ERR_FAILED;
+  }
+  stream_ = (void*)fp;
+
+  return OK;
 }
 
-void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION(
-          "436634 MmtTransactionImpl::OnIOComplete"));
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+  DCHECK(stream_);
+  read_data_buf_->data()[0] = 0;
 
-  int rv = DoLoop(result);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
+  FILE *fp = (FILE *)stream_;
+  int64 offset = response_.read_offset;
+  fseek(fp, offset, SEEK_SET);
+  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
+  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  if (rv > 0) {
+    response_.read_offset += rv;
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoLoop(int result) {
@@ -157,86 +229,38 @@ int MmtTransactionImpl::DoLoop(int result) {
         DCHECK(rv == OK);
         rv = DoConnect();
         break;
-      case STATE_CONNECT_COMPLETE:
-        rv = DoConnectComplete(rv);
-        break;
       case STATE_READ:
         DCHECK(rv == OK);
         rv = DoRead();
         break;
-      case STATE_READ_COMPLETE:
-        rv = DoReadComplete(rv);
-        break;
       default:
         NOTREACHED() << "bad state";
         rv = ERR_UNEXPECTED;
         break;
     }
-  } while (rv != ERR_IO_PENDING);
+  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
   return rv;
 }
 
-
-// Data Connection
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
-  next_state_ = STATE_READ;
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
-
-  // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  LOG(INFO) << __func__ << ", is_file=" << is_file;
-  if (!is_file) {
-    return ERR_FAILED;
-  }
-
-  next_state_ = STATE_CONNECT_COMPLETE;
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path, flags, io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoConnectComplete(rv);
-  }
+void MmtTransactionImpl::DoCallback(int rv) {
   LOG(INFO) << __func__ << ", rv=" << rv;
-  return rv;
-}
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
 
-int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  if (result != OK)
-    return Stop(result);
-  return OK;
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
 }
 
-int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __func__;
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-
-  next_state_ = STATE_READ_COMPLETE;
-  read_data_buf_->data()[0] = 0;
-
-  //TODO: read data from network/file
-  // impement one callback to mmt receiver
-  int rv = stream_->Read(read_data_buf_.get(),
-                         read_data_buf_len_,
-                         io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoReadComplete(rv);
-  }
-  return rv;
+void MmtTransactionImpl::OnIOPrepare() {
 }
 
-int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  return result;
+void MmtTransactionImpl::OnIOComplete() {
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  int rv = DoLoop(OK);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
 }
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index fc25de2..1f98423 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,6 +20,10 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
+namespace base {
+class Thread;
+}
+
 namespace net {
 
 class FileStream;
@@ -41,25 +45,22 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
            const CompletionCallback& callback) override;
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
+  virtual void SetRequestHeaders(HttpByteRange &range) override;
 
  private:
   void ResetStateForRestart();
+  void OnIOPrepare();
+  void OnIOComplete();
   void DoCallback(int result);
-  void OnIOComplete(int result);
   int DoLoop(int result);
-
   int DoStop();
   int DoConnect();
-  int DoConnectComplete(int result);
   int DoRead();
-  int DoReadComplete(int result);
 
   enum State {
     STATE_STOP,
     STATE_CONNECT,
-    STATE_CONNECT_COMPLETE,
     STATE_READ,
-    STATE_READ_COMPLETE,
     STATE_NONE
   };
 
@@ -70,9 +71,9 @@ private:
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
+  scoped_ptr<base::Thread> thread_;
 
-  scoped_ptr<FileStream> stream_;
-
+  void* stream_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0fdb5a9..051fcba 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,31 +67,33 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(!mmt_transaction_);
-  if (mmt_transaction_->GetResponseInfo()->is_local) {
-    *mime_type = "text/vnd.chromium.local";
-    return true;
-  }
   return false;
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  StartMmtTransaction();
-}
-
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  if (mmt_transaction_)
-    mmt_transaction_.reset();
-
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  LOG(INFO) << __func__;
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
 }
 
-int URLRequestMmtJob::StartMmtTransaction() {
-  LOG(INFO) << __FUNCTION__;
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << __func__;
   DCHECK(!mmt_transaction_);
 
   // Create a transaction.
@@ -99,36 +101,38 @@ int URLRequestMmtJob::StartMmtTransaction() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  int rv = ERR_FAILED;
-  if (mmt_transaction_) {
-    rv = mmt_transaction_->Start(
+  mmt_transaction_->Start(
         &mmt_request_info_,
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-  }
-  
-  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
-  return rv;
+}
+
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << __FUNCTION__;
+  mmt_transaction_.reset();
+
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  DCHECK(mmt_transaction_);
+
+  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
-  // Note that mmt_transaction_ may be NULL due to a creation failure.
-  if (mmt_transaction_) {
-    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-    // the content size information manually.
-    set_expected_content_size(
-        mmt_transaction_->GetResponseInfo()->expected_content_size);
-  }
+  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+  // the content size information manually.
+  set_expected_content_size(content_size);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -141,7 +145,7 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
   LOG(INFO) << __FUNCTION__ << ", result=" << result;
 
   read_in_progress_ = false;
-  if (result == 0) {
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -149,16 +153,16 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
     // Clear the IO_PENDING status
     SetStatus(URLRequestStatus());
   }
+  NotifyReadComplete(result);
 }
 
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
-
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
+  DCHECK(mmt_transaction_);
 
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cf3036e..6630861 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -37,9 +37,9 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
-  int StartMmtTransaction();
   void OnStartCompleted(int result);
   void OnReadCompleted(int result);
 
-- 
1.7.9.5

