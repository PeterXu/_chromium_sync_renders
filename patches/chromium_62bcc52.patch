diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/.gitignore b/.gitignore
index 8fa6763..a0181c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -437,3 +437,5 @@ v8.log
 /win8/metro_driver/metro_driver_version_resources.xml
 /x86-generic_out/
 /xcodebuild
+.xtags
+diff.log
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..fee77fb 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+            content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
new file mode 100644
index 0000000..7f2c324
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -0,0 +1,69 @@
+var port = null;
+
+function log(msg) {
+  msg = "[CI] " + msg;
+  //alert(msg);
+  console.log(msg);
+}
+
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  tabid = message["tabid"];
+  if (tabid == undefined) {
+    logMsg("no valid tabid");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript(tabid, {code: js});
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS(tabid, {code: css});
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cictrl";
+  port = chrome.runtime.connectNative(hostName);
+  log("port=" + port);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+// listen tab event
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    log("tabs complete id=" + tab.id);
+  }
+});
+
+// listen message
+chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
+    log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
+    if (request.greeting == "hello" && sender.tab) {
+        log("recv msg from tabs id=" + sender.tab.id);
+        connect();
+        sendResponse({farewell: "goodbye"});
+    }
+});
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
new file mode 100644
index 0000000..d22f883
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -0,0 +1,30 @@
+function log(msg) {
+    msg = "[CI] " + msg;
+    //alert(msg);
+    console.log(msg);
+}
+
+// for chrome.storage.local
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
+chrome.storage.onChanged.addListener(function(changes, namespace) {
+    log("storage.onChanged");
+    if (namespace != "local") {
+        log("donot process the namespace = " + namespace);
+        return;
+    }
+
+    for (key in changes) {
+        var storageChange = changes[key];
+        log("Storage key " + key + " in namespace " + namespace + " changed. " +
+            "Old value was " + storageChange.oldValue + ", new value is " + storageChange.newValue);
+    }
+});
+
+// document.readyState == "loading/interactive/complete"; 
+// it can ensure this script to be ran after window.onload
+window.onload = function() {
+    log("window.onload");
+    chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
+        log(response.farewell);
+    });
+};
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
new file mode 100644
index 0000000..15a90c6
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -0,0 +1,28 @@
+{
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
+    "name" : "org.chromium.cictrl",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium ci control",
+    "permissions": [
+        "mmt://*/*",
+        "file://*/*",
+        "http://*/*",
+        "https://*/",
+        "nativeMessaging",
+        "notifications",
+        "tabs", 
+        "storage"
+    ],
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    },
+    "content_scripts": [
+        {
+            "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
+            "run_at" : "document_start",
+            "js" : ["content_scripts.js"]
+        }
+    ]
+}
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
new file mode 100644
index 0000000..85f19b0
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cictrl
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
new file mode 100644
index 0000000..94d6a43
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -0,0 +1,161 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+
+import time
+import socket
+import signal
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  if len(message) < 16: return
+  try:
+    jdata = JSONDecoder().decode(message)
+  except:
+    jdata = None
+  if not jdata: return
+
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  try:
+    sys.stdout.flush()
+  except: return
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(1)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+  sock.bind((host, port))
+  while True:
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
+      break
+    send_message(msg)
+  sock.close()
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  sys.exit(0)
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+def OnSignal(a, b):
+    sys.exit(0)
+    pass
+
+if __name__ == '__main__':
+  signal.signal(signal.SIGTERM, OnSignal)
+  signal.signal(signal.SIGINT, OnSignal)
+
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
new file mode 100644
index 0000000..26aaa64
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cictrl",
+  "description": "Chromium Native Messaging For CI Control",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
new file mode 100644
index 0000000..b03bddc
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Google/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromoium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+rm $TARGET_DIR/org.chromium.cictrl.json
+echo Native messaging host $HOST_NAME has been uninstalled.
diff --git a/chrome/common/extensions/docs/examples/api/ciscreen/icon.png b/chrome/common/extensions/docs/examples/api/ciscreen/icon.png
new file mode 100644
index 0000000..4924db1
Binary files /dev/null and b/chrome/common/extensions/docs/examples/api/ciscreen/icon.png differ
diff --git a/chrome/common/extensions/docs/examples/api/ciscreen/manifest.json b/chrome/common/extensions/docs/examples/api/ciscreen/manifest.json
new file mode 100644
index 0000000..0b1b942
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/ciscreen/manifest.json
@@ -0,0 +1,14 @@
+{
+  "name": "Screen Remote",
+  "description": "Send Screen Remote Request",
+  "version": "1.0",
+  "permissions": [
+    "tabs", "http://*/*", "https://*/*", "mmt://*/*"
+  ],
+  "browser_action": {
+      "default_title": "Screen Remote",
+      "default_icon": "icon.png",
+      "default_popup": "popup.html"
+  },
+  "manifest_version": 2
+}
diff --git a/chrome/common/extensions/docs/examples/api/ciscreen/popup.html b/chrome/common/extensions/docs/examples/api/ciscreen/popup.html
new file mode 100644
index 0000000..ab70f65
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/ciscreen/popup.html
@@ -0,0 +1,66 @@
+<!doctype html>
+<html>
+  <head>
+    <title>Screen Remote</title>
+    <style>
+    body {
+      overflow: hidden;
+      margin: 0px;
+      padding: 0px;
+      background: white;
+    }
+
+    div:first-child {
+      margin-top: 0px;
+    }
+
+    div {
+      cursor: pointer;
+      text-align: center;
+      padding: 1px 3px;
+      font-family: sans-serif;
+      font-size: 1em;
+      width: 220px;
+      height: 50px;
+      margin-top: 1px;
+    }
+
+    input {
+      cursor: pointer;
+      text-align: center;
+      padding: 1px 3px;
+      font-family: sans-serif;
+      font-size: 1em;
+      width: 160px;
+      margin-top: 1px;
+    }
+
+    #id_main:hover,#id_second:hover {
+      background: #cccccc;
+      background: #aaaaaa;
+    }
+    #id_main,#id_second,#id_third {
+      cursor: pointer;
+      text-align: center;
+      padding: 1px 3px;
+      font-family: sans-serif;
+      font-size: 1em;
+      width: 52px;
+      height: 20px;
+      margin-top: 1px;
+    }
+    #ms_share {
+    }
+    </style>
+    <script src="popup.js"></script>
+  </head>
+  <body>
+    <div id="ms_share">
+        <b>Remote:</b><input id="id_addr" type="text">
+        <b>Action:</b>
+        <input id="id_main" type="button" value="Share">
+        <input id="id_second" type="button" value="Request">
+        <input id="id_third" type="button" value="Listen">
+    </div>
+  </body>
+</html>
diff --git a/chrome/common/extensions/docs/examples/api/ciscreen/popup.js b/chrome/common/extensions/docs/examples/api/ciscreen/popup.js
new file mode 100644
index 0000000..b2f3d3f
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/ciscreen/popup.js
@@ -0,0 +1,46 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+
+function click_main(e) {
+    addr = document.getElementById('id_addr').value;
+    if(addr.length > 8) {
+        uri = "mmt://" + addr + "?proto=ms0";
+        js = "";
+        js+= "var div = document.createElement('div');";
+        js+= "div.innerHTML=\"<iframe width=10 height=10 src='" + uri + "'/>;\";";
+        js+= "document.body.appendChild(div);"
+        chrome.tabs.executeScript(null, {code:js});
+        window.close();
+    }
+}
+
+function click_second(e) {
+    addr = document.getElementById('id_addr').value;
+    if(addr.length > 8) {
+        uri = "mmt://" + addr + "?proto=ms1";
+        chrome.tabs.update({url:uri});
+        window.close();
+    }
+}
+
+function click_third(e) {
+    addr = document.getElementById('id_addr').value;
+    uri = "mmt://localhost?proto=ms";
+    chrome.tabs.update({url:uri});
+    window.close();
+}
+
+
+document.addEventListener('DOMContentLoaded', function () {
+  input1 = document.getElementById('id_main');
+  input1.addEventListener('click', click_main);
+
+  input2 = document.getElementById('id_second');
+  input2.addEventListener('click', click_second);
+
+  input3 = document.getElementById('id_third');
+  input3.addEventListener('click', click_third);
+});
+
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/browser/loader/async_resource_handler.cc b/content/browser/loader/async_resource_handler.cc
index 51b0a744..241384d 100644
--- a/content/browser/loader/async_resource_handler.cc
+++ b/content/browser/loader/async_resource_handler.cc
@@ -39,7 +39,7 @@ namespace {
 
 static int kBufferSize = 1024 * 512;
 static int kMinAllocationSize = 1024 * 4;
-static int kMaxAllocationSize = 1024 * 32;
+static int kMaxAllocationSize = 1024 * 128;
 
 void GetNumericArg(const std::string& name, int* result) {
   const std::string& value =
@@ -57,6 +57,9 @@ void InitializeResourceBufferConstants() {
   GetNumericArg("resource-buffer-size", &kBufferSize);
   GetNumericArg("resource-buffer-min-allocation-size", &kMinAllocationSize);
   GetNumericArg("resource-buffer-max-allocation-size", &kMaxAllocationSize);
+  LOG(INFO) << __func__ << " kBufferSize=" << kBufferSize
+    << " kMinAllocationSize=" << kMinAllocationSize
+    << " kMaxAllocationSize" << kMaxAllocationSize;
 }
 
 int CalcUsedPercentage(int bytes_read, int buffer_size) {
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 27fca3f..ffd7e86 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1812,6 +1812,7 @@ blink::WebMediaPlayer* RenderFrameImpl::createMediaPlayer(
         *render_thread->GetAudioHardwareConfig()));
   }
 
+  LOG(INFO) << __func__ << " media::WebMediaPlayerImpl";
   return new media::WebMediaPlayerImpl(
       frame, client, weak_factory_.GetWeakPtr(), media_renderer_factory.Pass(),
       cdm_factory.Pass(), params);
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -53,6 +53,7 @@ class URLPattern {
     SCHEME_CHROMEUI   = 1 << 4,
     SCHEME_EXTENSION  = 1 << 5,
     SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/media/base/audio_buffer.h b/media/base/audio_buffer.h
index f81c2f6..3132e46 100644
--- a/media/base/audio_buffer.h
+++ b/media/base/audio_buffer.h
@@ -115,6 +115,8 @@ class MEDIA_EXPORT AudioBuffer
   // data is grouped by channel. There is only 1 entry for interleaved formats.
   const std::vector<uint8*>& channel_data() const { return channel_data_; }
 
+  SampleFormat sample_format() const { return sample_format_;}
+
  private:
   friend class base::RefCountedThreadSafe<AudioBuffer>;
 
diff --git a/media/base/audio_renderer.h b/media/base/audio_renderer.h
index 668d919..c88578f 100644
--- a/media/base/audio_renderer.h
+++ b/media/base/audio_renderer.h
@@ -19,6 +19,13 @@ class TimeSource;
 
 class MEDIA_EXPORT AudioRenderer {
  public:
+  // Used to provide AudioBuffer/AudioBus.
+#ifdef ECHO_AUDIOBUS
+  typedef base::Callback<void(const AudioBus*)> EchoCB;
+#else
+  typedef base::Callback<void(const scoped_refptr<AudioBuffer>&)> EchoCB;
+#endif
+
   AudioRenderer();
 
   // Stop all operations and fire all pending callbacks.
@@ -43,6 +50,7 @@ class MEDIA_EXPORT AudioRenderer {
                           const SetDecryptorReadyCB& set_decryptor_ready_cb,
                           const StatisticsCB& statistics_cb,
                           const BufferingStateCB& buffering_state_cb,
+                          const EchoCB& echo_cb,
                           const base::Closure& ended_cb,
                           const PipelineStatusCB& error_cb) = 0;
 
diff --git a/media/base/pipeline.cc b/media/base/pipeline.cc
index d6ed651..4788005 100644
--- a/media/base/pipeline.cc
+++ b/media/base/pipeline.cc
@@ -70,6 +70,7 @@ void Pipeline::Start(Demuxer* demuxer,
                      const PipelineMetadataCB& metadata_cb,
                      const BufferingStateCB& buffering_state_cb,
                      const PaintCB& paint_cb,
+                     const EchoCB& echo_cb,
                      const base::Closure& duration_change_cb,
                      const AddTextTrackCB& add_text_track_cb) {
   DCHECK(!ended_cb.is_null());
@@ -78,6 +79,7 @@ void Pipeline::Start(Demuxer* demuxer,
   DCHECK(!metadata_cb.is_null());
   DCHECK(!buffering_state_cb.is_null());
   DCHECK(!paint_cb.is_null());
+  //DCHECK(!echo_cb.is_null());
 
   base::AutoLock auto_lock(lock_);
   CHECK(!running_) << "Media pipeline is already running";
@@ -91,6 +93,7 @@ void Pipeline::Start(Demuxer* demuxer,
   metadata_cb_ = metadata_cb;
   buffering_state_cb_ = buffering_state_cb;
   paint_cb_ = paint_cb;
+  echo_cb_ = echo_cb;
   duration_change_cb_ = duration_change_cb;
   add_text_track_cb_ = add_text_track_cb;
 
@@ -740,6 +743,7 @@ void Pipeline::InitializeRenderer(const base::Closure& done_cb) {
       base::Bind(&Pipeline::OnUpdateStatistics, weak_this),
       base::Bind(&Pipeline::BufferingStateChanged, weak_this),
       base::ResetAndReturn(&paint_cb_),
+      base::ResetAndReturn(&echo_cb_),
       base::Bind(&Pipeline::OnRendererEnded, weak_this),
       base::Bind(&Pipeline::OnError, weak_this));
 }
diff --git a/media/base/pipeline.h b/media/base/pipeline.h
index 6cbb5e7..d4c43d1 100644
--- a/media/base/pipeline.h
+++ b/media/base/pipeline.h
@@ -35,6 +35,8 @@ class TextRenderer;
 class TextTrackConfig;
 class TimeDeltaInterpolator;
 class VideoFrame;
+class AudioBuffer;
+class AudioBus;
 
 // Metadata describing a pipeline once it has been initialized.
 struct PipelineMetadata {
@@ -81,6 +83,12 @@ class MEDIA_EXPORT Pipeline : public DemuxerHost {
  public:
   // Used to paint VideoFrame.
   typedef base::Callback<void(const scoped_refptr<VideoFrame>&)> PaintCB;
+  // For audio
+#ifdef ECHO_AUDIOBUS
+  typedef base::Callback<void(const AudioBus*)> EchoCB;
+#else
+  typedef base::Callback<void(const scoped_refptr<AudioBuffer>&)> EchoCB;
+#endif
 
   // Constructs a media pipeline that will execute on |task_runner|.
   Pipeline(const scoped_refptr<base::SingleThreadTaskRunner>& task_runner,
@@ -114,6 +122,7 @@ class MEDIA_EXPORT Pipeline : public DemuxerHost {
              const PipelineMetadataCB& metadata_cb,
              const BufferingStateCB& buffering_state_cb,
              const PaintCB& paint_cb,
+             const EchoCB& echo_cb,
              const base::Closure& duration_change_cb,
              const AddTextTrackCB& add_text_track_cb);
 
@@ -361,6 +370,7 @@ class MEDIA_EXPORT Pipeline : public DemuxerHost {
   PipelineMetadataCB metadata_cb_;
   BufferingStateCB buffering_state_cb_;
   PaintCB paint_cb_;
+  EchoCB echo_cb_;
   base::Closure duration_change_cb_;
   AddTextTrackCB add_text_track_cb_;
 
diff --git a/media/base/renderer.h b/media/base/renderer.h
index f909350..282db9c5 100644
--- a/media/base/renderer.h
+++ b/media/base/renderer.h
@@ -17,12 +17,20 @@ namespace media {
 
 class DemuxerStreamProvider;
 class VideoFrame;
+class AudioBuffer;
+class AudioBus;
 
 class MEDIA_EXPORT Renderer {
  public:
   typedef base::Callback<void(const scoped_refptr<VideoFrame>&)> PaintCB;
   typedef base::Callback<base::TimeDelta()> TimeDeltaCB;
 
+#ifdef ECHO_AUDIOBUS
+  typedef base::Callback<void(const AudioBus*)> EchoCB;
+#else
+  typedef base::Callback<void(const scoped_refptr<AudioBuffer>&)> EchoCB;
+#endif
+
   Renderer();
 
   // Stops rendering and fires any pending callbacks.
@@ -46,6 +54,7 @@ class MEDIA_EXPORT Renderer {
                           const StatisticsCB& statistics_cb,
                           const BufferingStateCB& buffering_state_cb,
                           const PaintCB& paint_cb,
+                          const EchoCB& echo_cb,
                           const base::Closure& ended_cb,
                           const PipelineStatusCB& error_cb) = 0;
 
diff --git a/media/blink/buffered_data_source.cc b/media/blink/buffered_data_source.cc
index e3e12e0..af69dc2 100644
--- a/media/blink/buffered_data_source.cc
+++ b/media/blink/buffered_data_source.cc
@@ -18,7 +18,7 @@ namespace {
 // BufferedDataSource has an intermediate buffer, this value governs the initial
 // size of that buffer. It is set to 32KB because this is a typical read size
 // of FFmpeg.
-const int kInitialReadBufferSize = 32768;
+const int kInitialReadBufferSize = 32768 * 4;
 
 // Number of cache misses or read failures we allow for a single Read() before
 // signaling an error.
@@ -264,6 +264,7 @@ bool BufferedDataSource::GetSize(int64* size_out) {
 }
 
 bool BufferedDataSource::IsStreaming() {
+  LOG(INFO) << __func__ << " streaming_=" << streaming_;
   return streaming_;
 }
 
diff --git a/media/blink/buffered_data_source.h b/media/blink/buffered_data_source.h
index b047c19..0b08887 100644
--- a/media/blink/buffered_data_source.h
+++ b/media/blink/buffered_data_source.h
@@ -105,7 +105,7 @@ class MEDIA_EXPORT BufferedDataSource : public DataSource {
   void MediaIsPaused();
 
   // Returns true if the resource is local.
-  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS(); }
+  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS() && !url_.SchemeIs(url::kMmtScheme); }
 
   // DataSource implementation.
   // Called from demuxer thread.
diff --git a/media/blink/buffered_resource_loader.cc b/media/blink/buffered_resource_loader.cc
index d88266d..a3afd89 100644
--- a/media/blink/buffered_resource_loader.cc
+++ b/media/blink/buffered_resource_loader.cc
@@ -320,6 +320,7 @@ int64 BufferedResourceLoader::instance_size() {
 }
 
 bool BufferedResourceLoader::range_supported() {
+  LOG(INFO) << "BufferedResourceLoader::range_supported() = " << range_supported_;
   return range_supported_;
 }
 
@@ -426,7 +427,13 @@ void BufferedResourceLoader::didReceiveResponse(
         return;
       }
     }
-
+  } else if (url_.SchemeIs(url::kMmtScheme)){
+    instance_size_ = content_length_;
+    LOG(INFO) << "BufferedResourceLoader::didReceiveResponse" 
+        << " content_length_=" << content_length_
+        << " first_byte_position_=" << first_byte_position_
+        << " last_byte_position_=" << last_byte_position_
+        << " instance_size_=" << instance_size_; 
   } else {
     CHECK_EQ(instance_size_, kPositionNotSpecified);
     if (content_length_ != kPositionNotSpecified) {
diff --git a/media/blink/webmediaplayer_impl.cc b/media/blink/webmediaplayer_impl.cc
index d712f95..1654227 100644
--- a/media/blink/webmediaplayer_impl.cc
+++ b/media/blink/webmediaplayer_impl.cc
@@ -44,6 +44,7 @@
 #include "media/blink/webmediasource_impl.h"
 #include "media/filters/chunk_demuxer.h"
 #include "media/filters/ffmpeg_demuxer.h"
+#include "media/cast/cast_streaming.h"
 #include "third_party/WebKit/public/platform/WebMediaSource.h"
 #include "third_party/WebKit/public/platform/WebRect.h"
 #include "third_party/WebKit/public/platform/WebSize.h"
@@ -188,6 +189,8 @@ WebMediaPlayerImpl::WebMediaPlayerImpl(
 }
 
 WebMediaPlayerImpl::~WebMediaPlayerImpl() {
+  DVLOG(1) << __FUNCTION__;
+  media::cast::DestroyStreaming(cast_streaming_);
   client_->setWebLayer(NULL);
 
   DCHECK(main_task_runner_->BelongsToCurrentThread());
@@ -268,6 +271,9 @@ void WebMediaPlayerImpl::DoLoad(LoadType load_type,
 }
 
 void WebMediaPlayerImpl::play() {
+  //blink::WebString ip="127.0.0.1";
+  //cast(true, ip, 2344);
+
   DVLOG(1) << __FUNCTION__;
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
@@ -406,6 +412,26 @@ void WebMediaPlayerImpl::setPreload(WebMediaPlayer::Preload preload) {
     data_source_->SetPreload(preload_);
 }
 
+void WebMediaPlayerImpl::cast(bool enabled) {
+  if (!cast_streaming_) return;
+  if (enabled) {
+      cast_streaming_->Start();
+  }else {
+      cast_streaming_->Stop();
+  }
+}
+
+void WebMediaPlayerImpl::cast(bool enabled, const blink::WebString& ip, unsigned short port) { 
+  LOG(INFO) << "WebMediaPlayerImpl::cast, enabled=" << enabled 
+    << " ip=" << ip.utf8().data() << " port=" << port;
+  if (!ip.isEmpty() && port > 0) {
+    cast_streaming_ = media::cast::CreateStreaming(ip.utf8().data(), port);
+    cast_streaming_->Init();
+  }
+
+  cast(enabled);
+}
+
 bool WebMediaPlayerImpl::hasVideo() const {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
@@ -923,6 +949,7 @@ void WebMediaPlayerImpl::StartPipeline() {
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnPipelineMetadata),
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnPipelineBufferingStateChanged),
       base::Bind(&WebMediaPlayerImpl::FrameReady, base::Unretained(this)),
+      base::Bind(&WebMediaPlayerImpl::EchoReady, base::Unretained(this)),
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnDurationChanged),
       BIND_TO_RENDER_LOOP(&WebMediaPlayerImpl::OnAddTextTrack));
 }
@@ -994,6 +1021,7 @@ void WebMediaPlayerImpl::OnOpacityChanged(bool opaque) {
 
 void WebMediaPlayerImpl::FrameReady(
     const scoped_refptr<VideoFrame>& frame) {
+  if (cast_streaming_) cast_streaming_->InputRawVideo(frame);
   compositor_task_runner_->PostTask(
       FROM_HERE,
       base::Bind(&VideoFrameCompositor::UpdateCurrentFrame,
@@ -1001,6 +1029,15 @@ void WebMediaPlayerImpl::FrameReady(
                  frame));
 }
 
+#ifdef ECHO_AUDIOBUS
+void WebMediaPlayerImpl::EchoReady(const AudioBus* data)
+#else
+void WebMediaPlayerImpl::EchoReady(const scoped_refptr<AudioBuffer>& data)
+#endif
+{
+  if (cast_streaming_) cast_streaming_->InputRawAudio(data);
+}
+
 static void GetCurrentFrameAndSignal(
     VideoFrameCompositor* compositor,
     scoped_refptr<VideoFrame>* video_frame_out,
diff --git a/media/blink/webmediaplayer_impl.h b/media/blink/webmediaplayer_impl.h
index 07f1932..8f90be1 100644
--- a/media/blink/webmediaplayer_impl.h
+++ b/media/blink/webmediaplayer_impl.h
@@ -45,6 +45,10 @@ class WebLayerImpl;
 
 namespace media {
 
+namespace cast {
+class CastStreaming;
+}
+
 class AudioHardwareConfig;
 class ChunkDemuxer;
 class GpuVideoAcceleratorFactories;
@@ -87,6 +91,8 @@ class MEDIA_EXPORT WebMediaPlayerImpl
   virtual void setRate(double rate);
   virtual void setVolume(double volume);
   virtual void setPreload(blink::WebMediaPlayer::Preload preload);
+  virtual void cast(bool enabled);
+  virtual void cast(bool enabled, const blink::WebString& ip, unsigned short port);
   virtual blink::WebTimeRanges buffered() const;
   virtual blink::WebTimeRanges seekable() const;
 
@@ -203,6 +209,11 @@ class MEDIA_EXPORT WebMediaPlayerImpl
   // Called by VideoRendererImpl on its internal thread with the new frame to be
   // painted.
   void FrameReady(const scoped_refptr<VideoFrame>& frame);
+#ifdef ECHO_AUDIOBUS
+  void EchoReady(const AudioBus* bus);
+#else
+  void EchoReady(const scoped_refptr<AudioBuffer>& buffer);
+#endif
 
   // Returns the current video frame from |compositor_|. Blocks until the
   // compositor can return the frame.
@@ -310,6 +321,8 @@ class MEDIA_EXPORT WebMediaPlayerImpl
 
   scoped_ptr<RendererFactory> renderer_factory_;
 
+  scoped_refptr<media::cast::CastStreaming> cast_streaming_;
+
   DISALLOW_COPY_AND_ASSIGN(WebMediaPlayerImpl);
 };
 
diff --git a/media/cast/cast.gyp b/media/cast/cast.gyp
index 8962e76..cf50f38 100644
--- a/media/cast/cast.gyp
+++ b/media/cast/cast.gyp
@@ -144,11 +144,16 @@
         '<(DEPTH)/media/media.gyp:shared_memory_support',
         '<(DEPTH)/third_party/opus/opus.gyp:opus',
         '<(DEPTH)/third_party/libvpx/libvpx.gyp:libvpx',
+        '<(DEPTH)/third_party/libyuv/libyuv.gyp:libyuv',
       ], # dependencies
       'sources': [
         'cast_sender.h',
         'cast_sender_impl.cc',
         'cast_sender_impl.h',
+        'cast_source.h',
+        'cast_source.cc',
+        'cast_streaming.h',
+        'cast_streaming.cc',
         'sender/audio_encoder.h',
         'sender/audio_encoder.cc',
         'sender/audio_sender.h',
diff --git a/media/cast/cast_sender_impl.cc b/media/cast/cast_sender_impl.cc
index 83048d7..9e1f81e 100644
--- a/media/cast/cast_sender_impl.cc
+++ b/media/cast/cast_sender_impl.cc
@@ -182,6 +182,7 @@ void CastSenderImpl::OnVideoInitialized(
     const CastInitializationCallback& initialization_cb,
     media::cast::CastInitializationStatus result) {
   DCHECK(cast_environment_->CurrentlyOn(CastEnvironment::MAIN));
+  LOG(INFO) << __func__ << " result=" << result;
   if (result == STATUS_VIDEO_INITIALIZED) {
     video_frame_input_ =
         new LocalVideoFrameInput(cast_environment_, video_sender_->AsWeakPtr(),
diff --git a/media/cast/cast_source.cc b/media/cast/cast_source.cc
new file mode 100644
index 0000000..c511547
--- /dev/null
+++ b/media/cast/cast_source.cc
@@ -0,0 +1,349 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/cast/cast_source.h"
+
+#include "base/files/memory_mapped_file.h"
+#include "base/files/scoped_file.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "media/audio/audio_parameters.h"
+#include "media/base/audio_buffer.h"
+#include "media/base/audio_bus.h"
+#include "media/base/audio_fifo.h"
+#include "media/base/audio_timestamp_helper.h"
+#include "media/base/media.h"
+#include "media/base/multi_channel_resampler.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "media/cast/cast_sender.h"
+#include "media/cast/test/utility/audio_utility.h"
+#include "media/cast/test/utility/video_utility.h"
+#include "media/filters/audio_renderer_algorithm.h"
+#include "media/filters/ffmpeg_demuxer.h"
+#include "media/filters/ffmpeg_glue.h"
+#include "media/filters/in_memory_url_protocol.h"
+#include "ui/gfx/size.h"
+
+#include "third_party/libyuv/include/libyuv/convert_from.h"
+#include "third_party/libyuv/include/libyuv/scale.h"
+
+
+namespace media {
+namespace cast {
+
+static const int kMaxAudioBusNumber = 64; // max number of audio bus in queue. 
+static const int kMaxVideoFrameNumber = 10; // max number of video frame in queue. 
+
+static const int kAudioFrameMs = 10;  // Each audio frame is exactly 10ms.
+static const int kAudioPacketsPerSecond = 1000 / kAudioFrameMs;
+
+CastSource::CastSource(
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+    base::TickClock* clock,
+    const AudioSenderConfig& audio_config,
+    const VideoSenderConfig& video_config)
+    : task_runner_(task_runner),
+      audio_config_(audio_config),
+      video_config_(video_config),
+      clock_(clock),
+      weak_factory_(this) {
+    playback_rate_ = 1.0;
+}
+
+CastSource::~CastSource() {
+}
+
+void CastSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
+                       scoped_refptr<VideoFrameInput> video_frame_input) {
+    audio_frame_input_ = audio_frame_input;
+    video_frame_input_ = video_frame_input;
+
+    LOG(INFO) << __func__ 
+        << " audio_frame_input=" << audio_frame_input
+        << " video_frame_input=" << video_frame_input;
+    if (!audio_frame_input && !video_frame_input) return;
+
+    LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
+    if (start_time_.is_null())
+        start_time_ = clock_->NowTicks();
+
+    task_runner_->PostTask(
+            FROM_HERE,
+            base::Bind(&CastSource::SendNextFrame, base::Unretained(this)));
+}
+
+void CastSource::InitAudioAlgo() {
+    if (!audio_params_.IsValid()) return;
+
+    audio_algo_.Initialize(audio_params_);
+    audio_algo_.FlushBuffers();
+
+    audio_fifo_input_bus_ = AudioBus::Create(
+            audio_params_.channels(), audio_params_.frames_per_buffer());
+    // Audio FIFO can carry all data fron AudioRendererAlgorithm.
+    audio_fifo_.reset(
+            new AudioFifo(audio_params_.channels(),
+                audio_algo_.QueueCapacity()));
+
+    audio_resampler_.reset(new media::MultiChannelResampler(
+                audio_params_.channels(),
+                static_cast<double>(audio_params_.sample_rate()) / audio_config_.frequency,
+                audio_params_.frames_per_buffer(),
+                base::Bind(&CastSource::ProvideData, base::Unretained(this))));
+}
+
+bool CastSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
+    if (!is_transcoding_video())
+        return false;
+
+    if (video_frame_queue_.empty()) 
+        return false;
+
+    video_lock_.Acquire();
+    scoped_refptr<VideoFrame> video_frame = video_frame_queue_.front();
+    video_frame_queue_.pop();
+    video_lock_.Release();
+
+    if (!video_frame) return false;
+
+    LOG(INFO) << __func__ << " Get video frame"
+        << " start_time_=" << start_time_
+        << " elapsed_time=" << elapsed_time
+        << " frame_time=" << video_frame->timestamp()
+        << " format=" << video_frame->format() 
+        << " width=" << video_frame->natural_size().width()
+        << " height=" << video_frame->natural_size().height()
+        << "";
+
+    if (video_frame_input_) {
+        video_frame_input_->InsertRawVideoFrame(video_frame, start_time_ + elapsed_time);
+    }
+
+    return true;
+}
+
+bool CastSource::SendNextTranscodedAudio(base::TimeDelta elapsed_time) {
+    if (!is_transcoding_audio())
+        return false;
+
+    if (audio_bus_queue_.empty()) 
+        return false;
+
+    audio_lock_.Acquire();
+    scoped_ptr<AudioBus> bus(audio_bus_queue_.front());
+    base::TimeDelta timestamp = audio_ts_queue_.front();
+    audio_bus_queue_.pop();
+    audio_ts_queue_.pop();
+    audio_lock_.Release();
+
+    if (!bus.get()) return false;
+
+    base::TimeDelta audio_time;
+    audio_time = audio_sent_ts_->GetTimestamp();
+    //audio_time = audio_sent_ts_->frame_count() * base::TimeDelta::FromMilliseconds(kAudioFrameMs);
+    audio_sent_ts_->AddFrames(bus->frames());
+
+    LOG(INFO) << __func__ << " Get Audio Bus"
+        << " timestamp=" << timestamp
+        << " frame num=" << bus->frames()
+        << " start_time=" << start_time_
+        << " audio_time=" << audio_time 
+        << " elapsed_time=" << elapsed_time;
+
+    if (audio_frame_input_) {
+        audio_frame_input_->InsertAudio(bus.Pass(), start_time_ + elapsed_time);
+    }
+
+    return true;
+}
+
+void CastSource::SendNextFrame() {
+    // Send as much as possible. Audio is sent according to system time.
+    while (SendNextTranscodedAudio(clock_->NowTicks() - start_time_));
+
+    // Video is sync'ed to audio.
+    while (SendNextTranscodedVideo(clock_->NowTicks() - start_time_));
+
+    // Send next send.
+    task_runner_->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&CastSource::SendNextFrame, base::Unretained(this)),
+            base::TimeDelta::FromMilliseconds(kAudioFrameMs));
+}
+
+void CastSource::InputRawAudio(const scoped_refptr<AudioBuffer> buffer) {
+    int frame_count = buffer->frame_count();
+    int channel_count = buffer->channel_count();
+    int sample_rate = buffer->sample_rate();
+    SampleFormat sample_format = buffer->sample_format();
+    media::ChannelLayout channel_layout = buffer->channel_layout();
+    base::TimeDelta timestamp = buffer->timestamp();
+    base::TimeDelta duration = buffer->duration();
+
+    LOG(INFO) << __func__ << " Add audio buffer," 
+        << " frame_count=" << frame_count
+        << " channel_count=" << channel_count
+        << " sample_rate=" << sample_rate
+        << " sample_format=" << sample_format
+        << " channel_layout=" << channel_layout
+        << " duration=" << duration
+        << " timestamp=" << timestamp;
+
+    if (!audio_sent_ts_.get()) {
+        audio_sent_ts_.reset(new AudioTimestampHelper(audio_config_.frequency));
+        base::TimeDelta base_ts;
+        audio_sent_ts_->SetBaseTimestamp(base_ts);
+    }
+
+#if 0
+    scoped_ptr<media::AudioBus> bus(
+            media::AudioBus::Create(channel_count, frame_count));
+    buffer->ReadFrames(frame_count, 0, 0, bus.get());
+
+    audio_lock_.Acquire();
+    audio_bus_queue_.push(bus.release());
+    audio_ts_queue_.push(timestamp);
+    audio_lock_.Release();
+    return;
+#endif
+
+    if (!audio_params_.IsValid()) {
+        int bytes_per_channel = 
+            media::SampleFormatToBytesPerChannel(sample_format);
+        audio_params_.Reset(
+                AudioParameters::AUDIO_PCM_LINEAR,
+                channel_layout,
+                channel_count,
+                sample_rate,
+                bytes_per_channel * 8,
+                sample_rate / kAudioPacketsPerSecond);
+        InitAudioAlgo();
+    }
+    audio_algo_.EnqueueBuffer(buffer);
+
+    const int frames_needed_to_scale = playback_rate_ * sample_rate / kAudioPacketsPerSecond;
+    const int required_frames = 2* audio_params_.sample_rate() / kAudioPacketsPerSecond;
+
+    LOG(INFO) << __func__ 
+        << " frames_scale=" << frames_needed_to_scale
+        << " required_frames=" << required_frames
+        << " frames_buffered=" << audio_algo_.frames_buffered();
+
+    while (frames_needed_to_scale <= audio_algo_.frames_buffered()) {
+        if (!audio_algo_.FillBuffer(audio_fifo_input_bus_.get(), 0,
+                                audio_fifo_input_bus_->frames(),
+                                playback_rate_)) {
+            LOG(WARNING)<< __func__ << " Nothing can be scaled and Need to Decode some more";
+            return;
+        }
+
+        // Prevent overflow of audio data in the FIFO.
+        if (audio_fifo_input_bus_->frames() + audio_fifo_->frames() <= 
+                audio_fifo_->max_frames()) {
+            audio_fifo_->Push(audio_fifo_input_bus_.get());
+        } else {
+            LOG(WARNING)<< __func__ << " Audio FIFO full; dropping samples.";
+        }
+
+        // Make sure there's enough data to resample audio.
+        LOG(INFO)<< __func__ 
+            << " audio_fifo_frames=" << audio_fifo_->frames()
+            << " required_frames=" << required_frames;
+        if (audio_fifo_->frames() < required_frames) {
+            continue;
+        }
+
+        scoped_ptr<media::AudioBus> resampled_bus(
+                media::AudioBus::Create(
+                    audio_params_.channels(),
+                    audio_config_.frequency / kAudioPacketsPerSecond));
+        audio_resampler_->Resample(resampled_bus->frames(), resampled_bus.get());
+        LOG(INFO) << __func__ << " frames=" << resampled_bus->frames();
+
+        audio_lock_.Acquire();
+        audio_bus_queue_.push(resampled_bus.release());
+        audio_ts_queue_.push(timestamp);
+        audio_lock_.Release();
+    }
+}
+
+void CastSource::InputRawAudio(const AudioBus* bus) {
+    LOG(INFO) << __func__ << " Add one audio bus";
+    if (!bus) return;
+
+    scoped_ptr<media::AudioBus> bus1 = AudioBus::Create(bus->channels(), bus->frames());
+    if (!bus1.get()) return;
+    bus->CopyTo(bus1.get());
+
+    audio_lock_.Acquire();
+    if (audio_bus_queue_.size() > kMaxAudioBusNumber) {
+        LOG(INFO) << __func__ << " queue is full and pop the oldest frame.";
+        audio_bus_queue_.pop();
+    }
+    audio_bus_queue_.push(bus1.release());
+    audio_lock_.Release();
+}
+
+void CastSource::InputRawVideo(const scoped_refptr<VideoFrame>& frame) {
+    LOG(INFO) << __func__ << " Add one video frame,"
+        << " format=" << frame->format() 
+        << " width=" << frame->natural_size().width()
+        << " height=" << frame->natural_size().height();
+    if (frame->format() != media::VideoFrame::YV12 && 
+        frame->format() != media::VideoFrame::I420) {
+        return;
+    }
+
+    scoped_refptr<media::VideoFrame> scaled_frame = frame;
+#if 1
+    int output_width = video_config_.width;
+    int output_height = video_config_.height;
+    gfx::Size output_size(output_width, output_height);
+    scaled_frame = scaled_frame_pool_.CreateFrame(media::VideoFrame::YV12, output_size,
+                                       gfx::Rect(output_size), output_size,
+                                       frame->timestamp());
+
+    libyuv::I420Scale(frame->data(media::VideoFrame::kYPlane),
+                      frame->stride(media::VideoFrame::kYPlane),
+                      frame->data(media::VideoFrame::kUPlane),
+                      frame->stride(media::VideoFrame::kUPlane),
+                      frame->data(media::VideoFrame::kVPlane),
+                      frame->stride(media::VideoFrame::kVPlane),
+                      frame->natural_size().width(),
+                      frame->natural_size().height(),
+                      scaled_frame->data(media::VideoFrame::kYPlane),
+                      scaled_frame->stride(media::VideoFrame::kYPlane),
+                      scaled_frame->data(media::VideoFrame::kUPlane),
+                      scaled_frame->stride(media::VideoFrame::kUPlane),
+                      scaled_frame->data(media::VideoFrame::kVPlane),
+                      scaled_frame->stride(media::VideoFrame::kVPlane),
+                      output_size.width(), 
+                      output_size.height(), 
+                      libyuv::kFilterNone);
+#endif
+
+    video_lock_.Acquire();
+    if (video_frame_queue_.size() > kMaxVideoFrameNumber) {
+        LOG(INFO) << __func__ << " queue is full and pop the oldest frame.";
+        video_frame_queue_.pop();
+    }
+    video_frame_queue_.push(scaled_frame);
+    video_lock_.Release();
+}
+
+void CastSource::ProvideData(int frame_delay, media::AudioBus* output_bus) {
+    if (audio_fifo_->frames() >= output_bus->frames()) {
+        LOG(INFO) << __func__ 
+            << " frames1=" << audio_fifo_->frames()
+            << " frames2=" << output_bus->frames();
+        audio_fifo_->Consume(output_bus, 0, output_bus->frames());
+    } else {
+        LOG(WARNING) << __func__ << "Not enough audio data for resampling.";
+        output_bus->Zero();
+    }
+}
+
+}  // namespace cast
+}  // namespace media
diff --git a/media/cast/cast_source.h b/media/cast/cast_source.h
new file mode 100644
index 0000000..765e638
--- /dev/null
+++ b/media/cast/cast_source.h
@@ -0,0 +1,120 @@
+// A fake media source that generates video and audio frames to a cast
+// sender.
+// This class can transcode a WebM file using FFmpeg. It can also
+// generate an animation and audio of fixed frequency.
+
+#ifndef MEDIA_CAST_CAST_SOURCE_H_
+#define MEDIA_CAST_CAST_SOURCE_H_
+
+#include <queue>
+
+#include "base/files/file_path.h"
+#include "base/files/memory_mapped_file.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/single_thread_task_runner.h"
+#include "base/time/tick_clock.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_frame_pool.h"
+#include "media/base/channel_layout.h"
+#include "media/audio/audio_parameters.h"
+#include "media/cast/cast_config.h"
+#include "media/filters/audio_renderer_algorithm.h"
+#include "media/filters/ffmpeg_demuxer.h"
+
+struct AVCodecContext;
+struct AVFormatContext;
+
+namespace media {
+
+class AudioBus;
+class AudioFifo;
+class AudioTimestampHelper;
+class FFmpegGlue;
+class InMemoryUrlProtocol;
+class MultiChannelResampler;
+
+namespace cast {
+
+class AudioFrameInput;
+class VideoFrameInput;
+class TestAudioBusFactory;
+
+class CastSource {
+public:
+    // |task_runner| is to schedule decoding tasks.
+    // |clock| is used by this source but is not owned.
+    // |video_config| is the desired video config.
+    CastSource(scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+            base::TickClock* clock,
+            const AudioSenderConfig& audio_config,
+            const VideoSenderConfig& video_config);
+    ~CastSource();
+
+    void Start(scoped_refptr<AudioFrameInput> audio_frame_input,
+            scoped_refptr<VideoFrameInput> video_frame_input);
+
+    void InputRawAudio(const scoped_refptr<AudioBuffer> buffer);
+    void InputRawAudio(const AudioBus* bus);
+    void InputRawVideo(const scoped_refptr<VideoFrame>& frame);
+
+    const AudioSenderConfig& get_audio_config() const { return audio_config_; }
+    const VideoSenderConfig& get_video_config() const { return video_config_; }
+
+protected:
+    void InitAudioAlgo();
+    void ProvideData(int frame_delay, media::AudioBus* output_bus);
+
+    bool is_transcoding_audio() {return true;}
+    bool is_transcoding_video() {return true;}
+
+    void SendNextFrame();
+    // Return true if a frame was sent.
+    bool SendNextTranscodedVideo(base::TimeDelta elapsed_time);
+    // Return true if a frame was sent.
+    bool SendNextTranscodedAudio(base::TimeDelta elapsed_time);
+
+
+private:
+    const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+    AudioSenderConfig audio_config_;
+    VideoSenderConfig video_config_;
+
+    scoped_refptr<AudioFrameInput> audio_frame_input_;
+    scoped_refptr<VideoFrameInput> video_frame_input_;
+    mutable media::VideoFramePool scaled_frame_pool_;
+
+    base::TickClock* const clock_;  // Not owned by this class.
+    // Time when the stream starts.
+    base::TimeTicks start_time_;
+
+    // for transcoding video frame
+    base::Lock video_lock_;
+    std::queue<scoped_refptr<VideoFrame> > video_frame_queue_;
+
+    // for transcoding audio buffer
+    base::Lock audio_lock_;
+    std::queue<AudioBus*> audio_bus_queue_;
+    std::queue<base::TimeDelta> audio_ts_queue_;
+    AudioParameters audio_params_;
+    double playback_rate_;
+
+    // Track the timestamp of audio sent to the receiver.
+    scoped_ptr<media::AudioTimestampHelper> audio_sent_ts_;
+
+    // These are used for audio resampling.
+    scoped_ptr<media::MultiChannelResampler> audio_resampler_;
+    scoped_ptr<media::AudioFifo> audio_fifo_;
+    scoped_ptr<media::AudioBus> audio_fifo_input_bus_;
+    media::AudioRendererAlgorithm audio_algo_;
+
+    // NOTE: Weak pointers must be invalidated before all other member variables.
+    base::WeakPtrFactory<CastSource> weak_factory_;
+
+    DISALLOW_COPY_AND_ASSIGN(CastSource);
+};
+
+}  // namespace cast
+}  // namespace media
+
+#endif // MEDIA_CAST_CAST_SOURCE_H_
diff --git a/media/cast/cast_streaming.cc b/media/cast/cast_streaming.cc
new file mode 100644
index 0000000..6f9f851
--- /dev/null
+++ b/media/cast/cast_streaming.cc
@@ -0,0 +1,512 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/cast/cast_streaming.h"
+
+#include <functional>
+#include <iterator>
+
+#include "base/logging.h"
+#include "base/values.h"
+#include "base/json/json_writer.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/threading/thread_restrictions.h"
+
+#include "media/cast/logging/encoding_event_subscriber.h"
+#include "media/cast/logging/log_serializer.h"
+#include "media/cast/logging/logging_defines.h"
+#include "media/cast/logging/proto/raw_events.pb.h"
+#include "media/cast/logging/receiver_time_offset_estimator_impl.h"
+#include "media/cast/logging/stats_event_subscriber.h"
+
+namespace media {
+namespace cast {
+
+static const int kAudioChannels = 2;
+static const int kAudioSamplingFrequency = 48000;
+// The max allowed size of serialized log.
+const int kMaxSerializedLogBytes = 10 * 1000 * 1000;
+
+
+static void CreateVideoEncodeAccelerator(const media::cast::ReceiveVideoEncodeAcceleratorCallback& callback) {
+    // Do nothing.
+}
+
+static void CreateVideoEncodeMemory(size_t size, const media::cast::ReceiveVideoEncodeMemoryCallback& callback) {
+    // Do nothing.
+}
+
+static CreateVideoEncodeAcceleratorCallback CreateDefaultVideoEncodeAcceleratorCallback() {
+    return base::Bind(&CreateVideoEncodeAccelerator);
+}
+
+static CreateVideoEncodeMemoryCallback CreateDefaultVideoEncodeMemoryCallback() {
+  return base::Bind(&CreateVideoEncodeMemory);
+}
+
+static media::cast::AudioSenderConfig GetAudioSenderConfig() {
+    media::cast::AudioSenderConfig audio_config;
+
+    audio_config.use_external_encoder = false;
+    audio_config.frequency = kAudioSamplingFrequency;
+    audio_config.channels = kAudioChannels;
+    audio_config.bitrate = 0;  // Use Opus auto-VBR mode.
+    audio_config.codec = media::cast::CODEC_AUDIO_OPUS;
+    audio_config.ssrc = 1;
+    audio_config.receiver_ssrc = 2;
+    audio_config.rtp_payload_type = 127;
+    // TODO(miu): The default in cast_defines.h is 100.  Should this be 100, and
+    // should receiver.cc's config also be 100?
+    audio_config.max_playout_delay = base::TimeDelta::FromMilliseconds(300);
+    return audio_config;
+}
+
+static media::cast::VideoSenderConfig GetVideoSenderConfig() {
+    media::cast::VideoSenderConfig video_config;
+    video_config.use_external_encoder = false;
+
+    // Resolution.
+    video_config.width = 320;
+    video_config.height = 180;
+    video_config.max_frame_rate = 20;
+
+    // Bitrates.
+    video_config.max_bitrate = 1500000; // 1.5mbps
+    video_config.min_bitrate = 100000;  // 100kbps
+    video_config.start_bitrate = video_config.min_bitrate;
+
+    // Codec.
+    video_config.codec = media::cast::CODEC_VIDEO_VP8;
+    video_config.max_number_of_video_buffers_used = 1;
+    video_config.number_of_encode_threads = 2;
+
+    // Quality options.
+    video_config.min_qp = 4;
+    video_config.max_qp = 40;
+
+    // SSRCs and payload type. Don't change them.
+    video_config.ssrc = 11;
+    video_config.receiver_ssrc = 12;
+    video_config.rtp_payload_type = 96;
+    // TODO(miu): The default in cast_defines.h is 100.  Should this be 100, and
+    // should receiver.cc's config also be 100?
+    video_config.max_playout_delay = base::TimeDelta::FromMilliseconds(300);
+    return video_config;
+}
+
+static void UpdateCastTransportStatus(media::cast::CastTransportStatus status) {
+    LOG(INFO) << __func__ << " Transport status: " << status;
+}
+
+static void LogRawEvents(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        const std::vector<media::cast::PacketEvent>& packet_events,
+        const std::vector<media::cast::FrameEvent>& frame_events) {
+    VLOG(1) << "Got packet events from transport, size: " << packet_events.size();
+    for (std::vector<media::cast::PacketEvent>::const_iterator it =
+            packet_events.begin();
+            it != packet_events.end();
+            ++it) {
+        cast_environment->Logging()->InsertPacketEvent(it->timestamp,
+                it->type,
+                it->media_type,
+                it->rtp_timestamp,
+                it->frame_id,
+                it->packet_id,
+                it->max_packet_id,
+                it->size);
+    }
+
+    VLOG(1) << "Got frame events from transport, size: " << frame_events.size();
+    for (std::vector<media::cast::FrameEvent>::const_iterator it =
+           frame_events.begin();
+           it != frame_events.end();
+           ++it) {
+        cast_environment->Logging()->InsertFrameEvent(it->timestamp,
+                it->type,
+                it->media_type,
+                it->rtp_timestamp,
+                it->frame_id);
+    }
+}
+
+static void InitializationResult(media::cast::CastInitializationStatus result) {
+  bool end_result = result == media::cast::STATUS_AUDIO_INITIALIZED ||
+                    result == media::cast::STATUS_VIDEO_INITIALIZED;
+  CHECK(end_result) << "Cast sender uninitialized";
+  LOG(INFO) << __func__ << " result=" << result;
+}
+
+static net::IPEndPoint CreateUDPAddress(std::string ip_str, uint16 port) {
+    if (ip_str.empty()) ip_str = "127.0.0.1";
+    if (port < 0 || port > 65535) port = 2344;
+    net::IPAddressNumber ip_number;
+    CHECK(net::ParseIPLiteralToNumber(ip_str, &ip_number));
+    return net::IPEndPoint(ip_number, port);
+}
+
+static void DumpLoggingData(const media::cast::proto::LogMetadata& log_metadata,
+                     const media::cast::FrameEventList& frame_events,
+                     const media::cast::PacketEventList& packet_events,
+                     base::ScopedFILE log_file) {
+    VLOG(0) << "Frame map size: " << frame_events.size();
+    VLOG(0) << "Packet map size: " << packet_events.size();
+    scoped_ptr<char[]> event_log(new char[kMaxSerializedLogBytes]);
+    int event_log_bytes;
+    if (!media::cast::SerializeEvents(log_metadata,
+                frame_events,
+                packet_events,
+                true,
+                kMaxSerializedLogBytes,
+                event_log.get(),
+                &event_log_bytes)) {
+        VLOG(0) << "Failed to serialize events.";
+        return;
+    }
+
+    VLOG(0) << "Events serialized length: " << event_log_bytes;
+    int ret = fwrite(event_log.get(), 1, event_log_bytes, log_file.get());
+    if (ret != event_log_bytes) {
+        VLOG(0) << "Failed to write logs to file.";
+    }
+}
+
+static void WriteLogsToFileAndDestroySubscribers(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        scoped_ptr<media::cast::EncodingEventSubscriber> video_event_subscriber,
+        scoped_ptr<media::cast::EncodingEventSubscriber> audio_event_subscriber,
+        base::ScopedFILE video_log_file,
+        base::ScopedFILE audio_log_file) {
+    cast_environment->Logging()->RemoveRawEventSubscriber(video_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(audio_event_subscriber.get());
+
+    VLOG(0) << "Dumping logging data for video stream.";
+    media::cast::proto::LogMetadata log_metadata;
+    media::cast::FrameEventList frame_events;
+    media::cast::PacketEventList packet_events;
+    video_event_subscriber->GetEventsAndReset(&log_metadata, &frame_events, &packet_events);
+    DumpLoggingData(log_metadata, frame_events, packet_events, video_log_file.Pass());
+
+    VLOG(0) << "Dumping logging data for audio stream.";
+    audio_event_subscriber->GetEventsAndReset(&log_metadata, &frame_events, &packet_events);
+    DumpLoggingData(log_metadata, frame_events, packet_events,audio_log_file.Pass());
+}
+
+static void WriteStatsAndDestroySubscribers(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        scoped_ptr<media::cast::StatsEventSubscriber> video_event_subscriber,
+        scoped_ptr<media::cast::StatsEventSubscriber> audio_event_subscriber,
+        scoped_ptr<media::cast::ReceiverTimeOffsetEstimatorImpl> estimator) {
+    cast_environment->Logging()->RemoveRawEventSubscriber(video_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(audio_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(estimator.get());
+
+#if 0
+    scoped_ptr<base::DictionaryValue> stats = video_event_subscriber->GetStats();
+    std::string json;
+    base::JSONWriter::WriteWithOptions(
+            stats.get(), base::JSONWriter::OPTIONS_PRETTY_PRINT, &json);
+    VLOG(0) << "Video stats: " << json;
+
+    stats = audio_event_subscriber->GetStats();
+    json.clear();
+    base::JSONWriter::WriteWithOptions(
+            stats.get(), base::JSONWriter::OPTIONS_PRETTY_PRINT, &json);
+    VLOG(0) << "Audio stats: " << json;
+#endif
+}
+
+} // namespace cast
+} // namespace media
+
+
+namespace media {
+namespace cast {
+
+#define __xinfo__ " CastStreaming::"<<__func__
+
+CastStreaming::CastStreaming() : weak_factory_(this) {
+    status_ = E_Unknown;
+    remote_endpoint_ = CreateUDPAddress("", 0);
+    main_thread_.reset(new base::Thread("Cast Streaming Main Thread"));
+    base::Thread::Options options(base::MessageLoop::TYPE_IO, 0);
+    main_thread_->StartWithOptions(options);
+}
+
+CastStreaming::~CastStreaming() {
+    Uninit();
+    main_thread_->Stop();
+}
+
+void CastStreaming::SetAddress(std::string ipstr, int port) {
+    LOG(INFO) << __xinfo__ << " status=" << status_ << " ip=" << ipstr << " port=" << port;
+    remote_endpoint_ = CreateUDPAddress(ipstr, static_cast<uint16>(port));
+}
+
+int CastStreaming::GetStatus() {
+    return status_;
+}
+
+void CastStreaming::Init() {
+    main_thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&CastStreaming::DoInit, base::Unretained(this)));
+}
+
+void CastStreaming::Start() {
+    main_thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&CastStreaming::DoStart, base::Unretained(this)));
+}
+
+void CastStreaming::Stop() {
+    main_thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&CastStreaming::DoStop, base::Unretained(this)));
+}
+
+void CastStreaming::Uninit() {
+    main_thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&CastStreaming::DoUninit, base::Unretained(this)));
+}
+
+void CastStreaming::InputRawAudio(const scoped_refptr<AudioBuffer> buffer) {
+#ifdef CAST_LOG_V
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+#endif
+    if (status_ == E_Start && cast_source_) {
+        cast_source_->InputRawAudio(buffer);
+    }
+}
+void CastStreaming::InputRawAudio(const AudioBus* bus) {
+#ifdef CAST_LOG_V
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+#endif
+    if (status_ == E_Start && cast_source_) {
+        cast_source_->InputRawAudio(bus);
+    }
+}
+void CastStreaming::InputRawVideo(const scoped_refptr<VideoFrame>& frame) {
+#ifdef CAST_LOG_V
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+#endif
+    if (status_ == E_Start && cast_source_) {
+        cast_source_->InputRawVideo(frame);
+    }
+}
+
+void CastStreaming::DoInit() {
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+    //base::ThreadRestrictions::SetIOAllowed(true);
+    if (status_ < E_Init) {
+        InitCast();
+        AddEvents();
+        status_ = E_Init;
+    }
+}
+void CastStreaming::DoStart() {
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+    if (status_ >= E_Init && status_ != E_Start) {
+        Prepare(true, true);
+        Play();
+        //usleep(500*1000);
+    }
+}
+void CastStreaming::DoStop() {
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+    status_ = E_Stop;
+}
+void CastStreaming::DoUninit() {
+    LOG(INFO) << __xinfo__ << " status=" << status_;
+    if (status_ >= E_Init) {
+        DoStop();
+        test_thread_->Stop();
+        audio_thread_->Stop();
+        video_thread_->Stop();
+        status_ = E_Unknown;
+    }
+}
+
+
+///
+///================================================================
+
+void CastStreaming::InitCast() {
+    test_thread_.reset(new base::Thread("Cast sender test thread"));
+    audio_thread_.reset(new base::Thread("Cast audio encoder thread"));
+    video_thread_.reset(new base::Thread("Cast video encoder thread"));
+    test_thread_->Start();
+    audio_thread_->Start();
+    video_thread_->Start();
+
+    // Get default audio/video config
+    media::cast::AudioSenderConfig audio_config = GetAudioSenderConfig();
+    media::cast::VideoSenderConfig video_config = GetVideoSenderConfig();
+
+    // Enable raw event and stats logging.
+    // Running transport on the main thread.
+    cast_environment_ = new media::cast::CastEnvironment(
+            make_scoped_ptr<base::TickClock>(new base::DefaultTickClock()),
+            main_thread_->message_loop_proxy(),
+            audio_thread_->message_loop_proxy(),
+            video_thread_->message_loop_proxy());
+
+    // SendProcess initialization.
+    cast_source_.reset(new media::cast::CastSource(
+                test_thread_->message_loop_proxy(),
+                cast_environment_->Clock(),
+                audio_config,
+                video_config));
+
+    // Running transport on the main thread.
+    // Setting up transport config.
+    // CastTransportSender initialization.
+    LOG(INFO) << __xinfo__  << " ip address=" << remote_endpoint_.ToString();
+    transport_sender_ = media::cast::CastTransportSender::Create(
+                NULL,  // net log.
+                cast_environment_->Clock(),
+                net::IPEndPoint(),
+                remote_endpoint_,
+                make_scoped_ptr(new base::DictionaryValue),  // options
+                base::Bind(&UpdateCastTransportStatus),
+                base::Bind(&LogRawEvents, cast_environment_),
+                base::TimeDelta::FromSeconds(1),
+                media::cast::PacketReceiverCallback(),
+                main_thread_->message_loop_proxy());
+
+    // CastSender create
+    cast_sender_ = media::cast::CastSender::Create(cast_environment_, transport_sender_.get());
+}
+
+void CastStreaming::AddEvents() {
+    // Set up event subscribers.
+    video_event_subscriber_.reset(new media::cast::EncodingEventSubscriber(media::cast::VIDEO_EVENT, 10000));
+    audio_event_subscriber_.reset(new media::cast::EncodingEventSubscriber(media::cast::AUDIO_EVENT, 10000));
+    cast_environment_->Logging()->AddRawEventSubscriber(video_event_subscriber_.get());
+    cast_environment_->Logging()->AddRawEventSubscriber(audio_event_subscriber_.get());
+
+    // Subscribers for stats.
+    offset_estimator_.reset(new media::cast::ReceiverTimeOffsetEstimatorImpl());
+    cast_environment_->Logging()->AddRawEventSubscriber(offset_estimator_.get());
+
+    video_stats_subscriber_.reset(new media::cast::StatsEventSubscriber(
+                media::cast::VIDEO_EVENT,
+                cast_environment_->Clock(),
+                offset_estimator_.get()));
+    audio_stats_subscriber_.reset(new media::cast::StatsEventSubscriber(
+                media::cast::AUDIO_EVENT,
+                cast_environment_->Clock(),
+                offset_estimator_.get()));
+    cast_environment_->Logging()->AddRawEventSubscriber(video_stats_subscriber_.get());
+    cast_environment_->Logging()->AddRawEventSubscriber(audio_stats_subscriber_.get());
+}
+
+void CastStreaming::Prepare(bool hasaudio, bool hasvideo) {
+    // CastSender initialization.
+    if (hasvideo) {
+        cast_sender_->InitializeVideo(
+            cast_source_->get_video_config(),
+            base::Bind(&InitializationResult),
+            media::cast::CreateDefaultVideoEncodeAcceleratorCallback(),
+            media::cast::CreateDefaultVideoEncodeMemoryCallback());
+    }
+
+    if (hasaudio) {
+        cast_sender_->InitializeAudio(
+            cast_source_->get_audio_config(),
+            base::Bind(&InitializationResult));
+    }
+}
+
+void CastStreaming::Play() {
+    std::string video_log_file_name("/tmp/video_events.log.gz");
+    std::string audio_log_file_name("/tmp/audio_events.log.gz");
+    LOG(INFO) << "Logging audio events to: " << audio_log_file_name;
+    LOG(INFO) << "Logging video events to: " << video_log_file_name;
+
+    base::ScopedFILE video_log_file(fopen(video_log_file_name.c_str(), "w"));
+    if (!video_log_file) {
+        VLOG(1) << "Failed to open video log file for writing.";
+    }
+
+    base::ScopedFILE audio_log_file(fopen(audio_log_file_name.c_str(), "w"));
+    if (!audio_log_file) {
+        VLOG(1) << "Failed to open audio log file for writing.";
+    }
+
+    const int logging_duration_seconds = 10;
+    main_thread_->message_loop_proxy()->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&WriteLogsToFileAndDestroySubscribers,
+                cast_environment_,
+                base::Passed(&video_event_subscriber_),
+                base::Passed(&audio_event_subscriber_),
+                base::Passed(&video_log_file),
+                base::Passed(&audio_log_file)),
+            base::TimeDelta::FromSeconds(logging_duration_seconds));
+
+    main_thread_->message_loop_proxy()->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&WriteStatsAndDestroySubscribers,
+                cast_environment_,
+                base::Passed(&video_stats_subscriber_),
+                base::Passed(&audio_stats_subscriber_),
+                base::Passed(&offset_estimator_)),
+            base::TimeDelta::FromSeconds(logging_duration_seconds));
+
+    cast_environment_->PostTask(
+            media::cast::CastEnvironment::MAIN,
+            FROM_HERE,
+            base::Bind(&CastStreaming::Run, base::Unretained(this)));
+}
+
+void CastStreaming::Run() {
+    cast_source_->Start(
+        cast_sender_->audio_frame_input(), 
+        cast_sender_->video_frame_input());
+    status_ = E_Start;
+}
+
+
+base::Lock g_castlock;
+std::map<std::string, CastStreamingPtr> g_casts;
+
+CastStreamingPtr CreateStreaming(std::string ip, int port) {
+    std::string ipaddr;
+    std::stringstream sstr;
+    sstr << ip << ":" << port;
+    sstr >> ipaddr;
+    LOG(INFO) << __func__ << " ipaddr=" << ipaddr;
+
+    CastStreamingPtr cast;
+    g_castlock.Acquire();
+    auto iter = g_casts.find(ipaddr);
+    if (iter != g_casts.end()) {
+        cast = iter->second;
+    }else {
+        cast = new CastStreaming();
+        cast->SetAddress(ip, port);
+        g_casts[ipaddr] = cast;
+    }
+    g_castlock.Release();
+
+    return cast;
+}
+void DestroyStreaming(CastStreamingPtr ptr) {
+    if (!ptr) return;
+    g_castlock.Acquire();
+    auto iter = g_casts.begin();
+    for (; iter != g_casts.end(); iter++) {
+        if (iter->second.get() == ptr.get()){
+            g_casts.erase(iter);
+            break;
+        }
+    }
+    g_castlock.Release();
+}
+
+} // namespace cast
+} // namespace media
diff --git a/media/cast/cast_streaming.h b/media/cast/cast_streaming.h
new file mode 100644
index 0000000..6fd85bc
--- /dev/null
+++ b/media/cast/cast_streaming.h
@@ -0,0 +1,100 @@
+#ifndef MEDIA_CAST_CAST_STREAMING_H_
+#define MEDIA_CAST_CAST_STREAMING_H_
+
+#include <map>
+
+#include "base/memory/linked_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/simple_thread.h"
+
+#include "media/base/media.h"
+#include "media/base/video_frame.h"
+#include "media/cast/cast_config.h"
+#include "media/cast/cast_environment.h"
+#include "media/cast/cast_sender.h"
+#include "media/cast/net/cast_transport_defines.h"
+#include "media/cast/net/cast_transport_sender.h"
+#include "media/cast/net/udp_transport.h"
+#include "media/cast/cast_source.h"
+#include "net/base/host_port_pair.h"
+
+
+namespace media {
+namespace cast {
+
+class EncodingEventSubscriber;
+class ReceiverTimeOffsetEstimatorImpl;
+class StatsEventSubscriber;
+
+// Native code that handle <video>/<audio>'s casting.
+class CastStreaming : public base::RefCounted<CastStreaming> {
+public:
+    enum {
+        E_Unknown,
+        E_Init,
+        E_Start,
+        E_Stop,
+    };
+
+    explicit CastStreaming();
+    void SetAddress(std::string ipstr, int port);
+    void GetAddress(net::IPEndPoint& ip);
+    int  GetStatus();
+
+    void Init();
+    void Start();
+    void Stop();
+    void Uninit();
+
+    void InputRawAudio(const scoped_refptr<AudioBuffer> buffer);
+    void InputRawAudio(const AudioBus* bus);
+    void InputRawVideo(const scoped_refptr<VideoFrame>& frame);
+
+protected:
+    void DoInit();
+    void DoStart();
+    void DoStop();
+    void DoUninit();
+
+    void InitCast();
+    void AddEvents();
+    void Prepare(bool audio, bool video);
+    void Play();
+    void Run();
+
+    friend class base::RefCounted<CastStreaming>;
+    virtual ~CastStreaming();
+
+private:
+    int status_;
+    //base::Lock lock_;
+    net::IPEndPoint remote_endpoint_;
+    scoped_refptr<media::cast::CastEnvironment> cast_environment_;
+    scoped_ptr<media::cast::CastSource> cast_source_;
+    scoped_ptr<media::cast::CastTransportSender> transport_sender_;
+    scoped_ptr<media::cast::CastSender> cast_sender_;
+
+    scoped_ptr<media::cast::EncodingEventSubscriber> video_event_subscriber_;
+    scoped_ptr<media::cast::EncodingEventSubscriber> audio_event_subscriber_;
+    scoped_ptr<media::cast::ReceiverTimeOffsetEstimatorImpl> offset_estimator_;
+    scoped_ptr<media::cast::StatsEventSubscriber> video_stats_subscriber_;
+    scoped_ptr<media::cast::StatsEventSubscriber> audio_stats_subscriber_;
+
+    scoped_ptr<base::Thread> main_thread_;
+    scoped_ptr<base::Thread> test_thread_;
+    scoped_ptr<base::Thread> audio_thread_;
+    scoped_ptr<base::Thread> video_thread_;
+    scoped_ptr<base::MessageLoopForIO> io_message_loop_;
+
+    base::WeakPtrFactory<CastStreaming> weak_factory_;
+    DISALLOW_COPY_AND_ASSIGN(CastStreaming);
+};
+typedef scoped_refptr<CastStreaming> CastStreamingPtr;
+
+CastStreamingPtr CreateStreaming(std::string ip, int port);
+void DestroyStreaming(CastStreamingPtr ptr);
+
+}  // namespace cast
+}  // namespace media
+
+#endif  // MEDIA_CAST_CAST_STREAMING_H_
diff --git a/media/cast/sender/video_sender.cc b/media/cast/sender/video_sender.cc
index 0e9b72f..8213b01 100644
--- a/media/cast/sender/video_sender.cc
+++ b/media/cast/sender/video_sender.cc
@@ -101,6 +101,7 @@ VideoSender::VideoSender(
   }
 #endif  // !defined(OS_IOS)
 
+  LOG(INFO) << __func__ << " cast_initialization_status=" << cast_initialization_status_;
   if (cast_initialization_status_ == STATUS_VIDEO_INITIALIZED) {
     cast_environment->PostTask(
         CastEnvironment::MAIN,
diff --git a/media/cast/test/fake_media_source.cc b/media/cast/test/fake_media_source.cc
index 918f7bb..b23d3a7 100644
--- a/media/cast/test/fake_media_source.cc
+++ b/media/cast/test/fake_media_source.cc
@@ -194,6 +194,11 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
   audio_frame_input_ = audio_frame_input;
   video_frame_input_ = video_frame_input;
 
+  LOG(INFO) << __func__ 
+            << " audio_frame_input=" << audio_frame_input
+            << " video_frame_input=" << video_frame_input;
+  if (!audio_frame_input && !video_frame_input) return;
+
   LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
   LOG(INFO) << "Source Frame rate: "
             << video_frame_rate_numerator_ << "/"
@@ -214,6 +219,7 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
   }
 
   // Send transcoding streams.
+  if (audio_params_.IsValid()) {
   audio_algo_.Initialize(audio_params_);
   audio_algo_.FlushBuffers();
   audio_fifo_input_bus_ =
@@ -229,6 +235,8 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
       kAudioSamplingFrequency,
       audio_params_.frames_per_buffer(),
       base::Bind(&FakeMediaSource::ProvideData, base::Unretained(this))));
+  }
+
   task_runner_->PostTask(
       FROM_HERE,
       base::Bind(
@@ -249,6 +257,7 @@ void FakeMediaSource::SendNextFakeFrame() {
   video_frame->set_timestamp(video_time);
   if (keep_frames_)
     inserted_video_frame_queue_.push(video_frame);
+  if (video_frame_input_)
   video_frame_input_->InsertRawVideoFrame(video_frame,
                                           start_time_ + video_time);
 
@@ -298,6 +307,11 @@ bool FakeMediaSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
 
   scoped_refptr<VideoFrame> decoded_frame =
       video_frame_queue_.front();
+#if 0
+  LOG(INFO) << __func__ 
+            << " elapsed_time=" << elapsed_time
+            << " video timestamp=" << decoded_frame->timestamp();
+#endif
   if (elapsed_time < decoded_frame->timestamp())
     return false;
 
@@ -325,6 +339,8 @@ bool FakeMediaSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
   video_frame->set_timestamp(ScaleTimestamp(decoded_frame->timestamp()));
   if (keep_frames_)
     inserted_video_frame_queue_.push(video_frame);
+
+  if (video_frame_input_)
   video_frame_input_->InsertRawVideoFrame(
       video_frame, start_time_ + video_frame->timestamp());
 
@@ -360,6 +376,16 @@ void FakeMediaSource::SendNextFrame() {
   // system time.
   while (SendNextTranscodedAudio(clock_->NowTicks() - start_time_));
 
+  // fix video play without audio track
+  if (!is_transcoding_audio()) {
+    if(!audio_sent_ts_) {
+      audio_sent_ts_.reset(new AudioTimestampHelper(30));
+      base::TimeDelta base_ts;
+      audio_sent_ts_->SetBaseTimestamp(base_ts);
+    }
+    audio_sent_ts_->AddFrames(1);
+    //LOG(INFO) << __func__ << " audio timestamp=" << audio_sent_ts_->GetTimestamp();
+  }
   // Video is sync'ed to audio.
   while (SendNextTranscodedVideo(audio_sent_ts_->GetTimestamp()));
 
@@ -393,8 +419,7 @@ base::TimeDelta FakeMediaSource::AudioFrameTime(int frame_number) {
 }
 
 void FakeMediaSource::Rewind() {
-  CHECK(av_seek_frame(av_format_context_, -1, 0, AVSEEK_FLAG_BACKWARD) >= 0)
-      << "Failed to rewind to the beginning.";
+  av_seek_frame(av_format_context_, -1, 0, AVSEEK_FLAG_BACKWARD);
 }
 
 ScopedAVPacket FakeMediaSource::DemuxOnePacket(bool* audio) {
diff --git a/media/cast/test/sender.cc b/media/cast/test/sender.cc
index b61bd3a..53870ad 100644
--- a/media/cast/test/sender.cc
+++ b/media/cast/test/sender.cc
@@ -153,6 +153,7 @@ void InitializationResult(media::cast::CastInitializationStatus result) {
   bool end_result = result == media::cast::STATUS_AUDIO_INITIALIZED ||
                     result == media::cast::STATUS_VIDEO_INITIALIZED;
   CHECK(end_result) << "Cast sender uninitialized";
+  LOG(INFO) << __func__ << " result=" << result;
 }
 
 net::IPEndPoint CreateUDPAddress(std::string ip_str, uint16 port) {
@@ -245,6 +246,12 @@ void WriteStatsAndDestroySubscribers(
   VLOG(0) << "Audio stats: " << json;
 }
 
+void StartMain(media::cast::FakeMediaSource* source, media::cast::CastSender* sender) {
+  LOG(INFO) << __func__;
+  if (!source || !sender) return;
+  source->Start(sender->audio_frame_input(), sender->video_frame_input());
+}
+
 }  // namespace
 
 int main(int argc, char** argv) {
@@ -405,9 +412,12 @@ int main(int argc, char** argv) {
                  base::Passed(&offset_estimator)),
       base::TimeDelta::FromSeconds(logging_duration_seconds));
 
-  fake_media_source->Start(cast_sender->audio_frame_input(),
-                           cast_sender->video_frame_input());
+  cast_environment->PostTask(
+        media::cast::CastEnvironment::MAIN,
+        FROM_HERE,
+        base::Bind(StartMain, fake_media_source.get(), cast_sender.get()));
 
+  LOG(INFO) << __func__ << " run io_message_loop ..";
   io_message_loop.Run();
   return 0;
 }
diff --git a/media/filters/audio_renderer_impl.cc b/media/filters/audio_renderer_impl.cc
index 0430370..ba2bfe5 100644
--- a/media/filters/audio_renderer_impl.cc
+++ b/media/filters/audio_renderer_impl.cc
@@ -256,6 +256,7 @@ void AudioRendererImpl::Initialize(
     const SetDecryptorReadyCB& set_decryptor_ready_cb,
     const StatisticsCB& statistics_cb,
     const BufferingStateCB& buffering_state_cb,
+    const EchoCB& echo_cb,
     const base::Closure& ended_cb,
     const PipelineStatusCB& error_cb) {
   DVLOG(1) << __FUNCTION__;
@@ -265,6 +266,7 @@ void AudioRendererImpl::Initialize(
   DCHECK(!init_cb.is_null());
   DCHECK(!statistics_cb.is_null());
   DCHECK(!buffering_state_cb.is_null());
+  //DCHECK(!echo_cb.is_null());
   DCHECK(!ended_cb.is_null());
   DCHECK(!error_cb.is_null());
   DCHECK_EQ(kUninitialized, state_);
@@ -277,6 +279,9 @@ void AudioRendererImpl::Initialize(
   init_cb_ = BindToCurrentLoop(init_cb);
 
   buffering_state_cb_ = buffering_state_cb;
+
+  echo_cb_ = echo_cb,
+
   ended_cb_ = ended_cb;
   error_cb_ = error_cb;
 
@@ -459,6 +464,10 @@ bool AudioRendererImpl::HandleSplicerBuffer_Locked(
 
     if (state_ != kUninitialized)
       algorithm_->EnqueueBuffer(buffer);
+
+#ifndef ECHO_AUDIOBUS
+      if (!echo_cb_.is_null()) echo_cb_.Run(buffer);
+#endif
   }
 
   // Store the timestamp of the first packet so we know when to start actual
@@ -566,6 +575,11 @@ int AudioRendererImpl::Render(AudioBus* audio_bus,
   const int delay_frames = static_cast<int>(playback_delay.InSecondsF() *
                                             audio_parameters_.sample_rate());
   int frames_written = 0;
+
+#ifdef ECHO_AUDIOBUS
+  if (!echo_cb_.is_null()) echo_cb_.Run(audio_bus);
+#endif
+
   {
     base::AutoLock auto_lock(lock_);
     last_render_ticks_ = base::TimeTicks::Now();
diff --git a/media/filters/audio_renderer_impl.h b/media/filters/audio_renderer_impl.h
index ff22710..c72f034 100644
--- a/media/filters/audio_renderer_impl.h
+++ b/media/filters/audio_renderer_impl.h
@@ -79,6 +79,7 @@ class MEDIA_EXPORT AudioRendererImpl
                   const SetDecryptorReadyCB& set_decryptor_ready_cb,
                   const StatisticsCB& statistics_cb,
                   const BufferingStateCB& buffering_state_cb,
+                  const EchoCB& echo_cb,
                   const base::Closure& ended_cb,
                   const PipelineStatusCB& error_cb) override;
   TimeSource* GetTimeSource() override;
@@ -249,6 +250,9 @@ class MEDIA_EXPORT AudioRendererImpl
   // SetMediaTime().
   base::TimeDelta start_timestamp_;
 
+  // Embedder callback for notifying a new audiobuffer is available for echoing.
+  EchoCB echo_cb_;
+
   // The media timestamp to signal end of audio playback. Determined during
   // Render() when writing the final frames of decoded audio data.
   base::TimeDelta ended_timestamp_;
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..6c77ba4 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 128 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/media/filters/ffmpeg_video_decoder.cc b/media/filters/ffmpeg_video_decoder.cc
index 93dcee2..dc75e38 100644
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -224,9 +224,10 @@ void FFmpegVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
   do {
     has_produced_frame = false;
     if (!FFmpegDecode(buffer, &has_produced_frame)) {
-      state_ = kError;
-      decode_cb_bound.Run(kDecodeError);
-      return;
+      // FIXME: continue to decode next frame when kDecodeError for invalid mpu
+      //state_ = kError;
+      //decode_cb_bound.Run(kDecodeError);
+      //return;
     }
     // Repeat to flush the decoder after receiving EOS buffer.
   } while (buffer->end_of_stream() && has_produced_frame);
diff --git a/media/filters/renderer_impl.cc b/media/filters/renderer_impl.cc
index e15ad6e..3483549 100644
--- a/media/filters/renderer_impl.cc
+++ b/media/filters/renderer_impl.cc
@@ -57,6 +57,7 @@ void RendererImpl::Initialize(DemuxerStreamProvider* demuxer_stream_provider,
                               const StatisticsCB& statistics_cb,
                               const BufferingStateCB& buffering_state_cb,
                               const PaintCB& paint_cb,
+                              const EchoCB& echo_cb,
                               const base::Closure& ended_cb,
                               const PipelineStatusCB& error_cb) {
   DVLOG(1) << __FUNCTION__;
@@ -66,6 +67,7 @@ void RendererImpl::Initialize(DemuxerStreamProvider* demuxer_stream_provider,
   DCHECK(!statistics_cb.is_null());
   DCHECK(!buffering_state_cb.is_null());
   DCHECK(!paint_cb.is_null());
+  //DCHECK(!echo_cb.is_null());
   DCHECK(!ended_cb.is_null());
   DCHECK(!error_cb.is_null());
   DCHECK(demuxer_stream_provider->GetStream(DemuxerStream::AUDIO) ||
@@ -75,6 +77,7 @@ void RendererImpl::Initialize(DemuxerStreamProvider* demuxer_stream_provider,
   statistics_cb_ = statistics_cb;
   buffering_state_cb_ = buffering_state_cb;
   paint_cb_ = paint_cb;
+  echo_cb_ = echo_cb;
   ended_cb_ = ended_cb;
   error_cb_ = error_cb;
 
@@ -253,6 +256,7 @@ void RendererImpl::InitializeAudioRenderer() {
       base::Bind(&RendererImpl::OnUpdateStatistics, weak_this_),
       base::Bind(&RendererImpl::OnBufferingStateChanged, weak_this_,
                  &audio_buffering_state_),
+      echo_cb_,
       base::Bind(&RendererImpl::OnAudioRendererEnded, weak_this_),
       base::Bind(&RendererImpl::OnError, weak_this_));
 }
diff --git a/media/filters/renderer_impl.h b/media/filters/renderer_impl.h
index 6a65bc0..f0beea8 100644
--- a/media/filters/renderer_impl.h
+++ b/media/filters/renderer_impl.h
@@ -48,6 +48,7 @@ class MEDIA_EXPORT RendererImpl : public Renderer {
                   const StatisticsCB& statistics_cb,
                   const BufferingStateCB& buffering_state_cb,
                   const PaintCB& paint_cb,
+                  const EchoCB& echo_cb,
                   const base::Closure& ended_cb,
                   const PipelineStatusCB& error_cb) final;
   void SetCdm(CdmContext* cdm_context,
@@ -135,6 +136,7 @@ class MEDIA_EXPORT RendererImpl : public Renderer {
   PipelineStatusCB error_cb_;
   BufferingStateCB buffering_state_cb_;
   PaintCB paint_cb_;
+  EchoCB echo_cb_;
 
   // Temporary callback used for Initialize() and Flush().
   base::Closure init_cb_;
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,15 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
new file mode 100644
index 0000000..bf27852
--- /dev/null
+++ b/net/mmt/mmt_control.cc
@@ -0,0 +1,620 @@
+#include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+static const int kMmtLoopInterval = 100; // ms
+static const int kMmtReadInterval = 10; // ms
+static const int kMmtXmlInterval = 30; 
+static const int kMmtCiInterval = 10;
+static const char kMmtDefaultXml[] = "mmt://localhost/tmp/ci.xml";
+
+static MmtControl *g_ctrl = nullptr;
+
+void StartMmtCtrl() {
+    if (!g_ctrl) {
+        g_ctrl = new MmtControl;
+    }
+    if (g_ctrl->IsRunning()) {
+        return;
+    }
+    g_ctrl->Reset();
+    g_ctrl->Start();
+    LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
+}
+
+/**
+ * The algorithm to generate unique key for UrlRequestMmtJob
+ */
+static std::string mmtjob_key(GURL& url, void* ptr) {
+    std::string name = url.spec();
+    std::stringstream sstr;
+    sstr << name << "@" << ptr;
+    std::string key;
+    sstr >> key;
+    return key;
+}
+
+static int PostCtrlMsg(ctrl_msg_t &msg) {
+    if (!g_ctrl) return net::ERR_FAILED;
+    return g_ctrl->Push(msg);
+}
+static int PostCtrlTask(std::string head, std::string body,
+    job_refptr_t job, GURL url, tab_t& tab, stream_info_t sinfo) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.body = body;
+    msg.job = job;
+    msg.url = url;
+    msg.tab = tab;
+    msg.sinfo = sinfo;
+    msg.key = mmtjob_key(msg.url, msg.job.get());
+    return PostCtrlMsg(msg);
+}
+
+int PostCtrlTask(std::string head, tab_t& tab) {
+    return PostCtrlTask(head, "", nullptr, GURL(), tab, stream_info_t());
+}
+
+int PostCtrlTask(std::string head, GURL url, std::string body, tab_t& tab) {
+    return PostCtrlTask(head, body, nullptr, url, tab, stream_info_t());
+}
+
+int PostCtrlTask(std::string head, GURL url, job_refptr_t job, tab_t& tab) {
+    return PostCtrlTask(head, "", job, url, tab, stream_info_t());
+}
+
+int PostCtrlTask(std::string head, GURL url, stream_info_t& sinfo, job_refptr_t job, tab_t& tab) {
+    return PostCtrlTask(head, "", job, url, tab, sinfo);
+}
+
+} // namespace mmt
+
+
+namespace mmt {
+
+tab_t::tab_t() {
+    routing_id = 0;
+    process_id = 0;
+    frame_id = 0;
+    tab_id = -1;
+    proto = "";
+    postui = nullptr;
+}
+content_t::content_t() {
+}
+tabscript_t::tabscript_t() {
+}
+void tabscript_t::posttab(std::string head, std::string body) {
+    if (tab.postui) {
+        this->head = head;
+        this->body = body;
+        tab.postui(*this);
+    }
+}
+
+stream_info_t::stream_info_t() {
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func = nullptr;
+}
+stream_info_t::~stream_info_t() {
+    buf = nullptr;
+    func = nullptr;
+}
+
+ctrl_msg_t::ctrl_msg_t() {
+    job = nullptr;
+}
+ctrl_msg_t::~ctrl_msg_t() {
+    job = nullptr;
+}
+
+cixml_t::cixml_t() {
+    status = E_Unknown;
+    waiting = kMmtCiInterval;
+    update = 0;
+    fname = "";
+    parser = nullptr;
+}
+cixml_t::~cixml_t() {
+    parser = nullptr;
+}
+
+} // namespace mmt
+
+
+/// for class MmtControl
+namespace mmt {
+
+MmtControl::MmtControl() : SimpleThread("mmt_control"){
+    running_ = false;
+    delaythread_.reset(new base::Thread("Control Delay Thread"));
+}
+
+MmtControl::~MmtControl() {
+    loop_ = false;
+    cixmls_.clear();
+    streams_.clear();
+}
+
+bool MmtControl::ProcStream(StreamPtr stream) {
+    if (!stream) return false;
+
+    int tabid = stream->GetTabId();
+    //LOG(INFO) << __func__ << " stream's tabid=" << tabid;
+    if (stream->IsMmtMedia()) {
+        cixmlptr_t cixml;
+       // cilock_.Acquire();
+        if (cixmls_.find(tabid) != cixmls_.end()) {
+            //LOG(INFO) << __func__ << " find cixml";
+            cixml = cixmls_[tabid];
+        }
+        //cilock_.Release();
+
+        if (cixml && cixml->parser) {
+            //LOG(INFO) << __func__ << " find xml parser";
+            // for clip
+            auto clip = cixml->parser->GetHtmlClip(stream->GetHtmlId());
+            stream->SetHtmlClip(clip);
+
+            // for sub xml
+            // delay to process sub xml in CheckEvent
+            // ci xml stream which should be processed in ProcCiXml, not here.
+            if (stream->GetMtype() == kMmtMediaCI) {
+                std::string spec = stream->url().spec();
+                LOG(INFO) << __func__ << " find one sub xml=" << spec;
+                xmlinfo_t xml; 
+                xml.fname = spec; 
+                xml.timeout = 0;
+                cixml->subxmls.push_back(xml); 
+                return false; 
+            }
+        }
+    }
+    return true; // normal stream
+}
+void MmtControl::ProcJobs(ctrl_msg_t& msg) {
+    //joblock_.Acquire();
+    auto iter = jobs_.begin();
+    for (; iter != jobs_.end(); iter++) {
+        if (iter->get() == msg.job.get()) {
+            jobs_.erase(iter);
+            break;
+        }
+    }
+    jobs_.push_back(msg.job);
+    if (jobs_.size() > 8) {
+        jobs_.erase(jobs_.begin());
+    }
+    //joblock_.Release();
+}
+void MmtControl::StreamOpen(ctrl_msg_t msg) {
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << msg.key 
+        << " msg's tabid=" << msg.tab.tab_id;
+
+    // TODO: for local file testing
+    long lsize = -1;
+    do {
+        StreamPtr stream = new Stream(msg.url);
+        if (!stream->Init()) break;
+        std::string proto = stream->GetProto();
+
+        // For send sharing to remote
+        if (proto == kMmtProtoMs0) {
+            int port;
+            std::string host;
+            GURL2Address(msg.url, host, port);
+            screen_->SendMsg(proto, host, port);
+            lsize = 0;
+            Wait(100);
+            break;
+        }
+
+        // For recv remote request of multi-screen
+        if (proto == kMmtProtoMs1 || proto == kMmtProtoMs) {
+            LOG(INFO) << __func__ << " proto=" << proto;
+            ssres_t res = screen_->GetRRes();
+            if (res.bcast.empty() || res.ci.empty() || res.html.empty()) {
+                if (msg.body != kMmtProtoMs1 && proto == kMmtProtoMs1) {
+                    // donot send request for kMmtProtoMs
+                    int port;
+                    std::string host;
+                    GURL2Address(msg.url, host, port);
+                    screen_->SendMsg(proto, host, port);
+                    msg.body = kMmtProtoMs1;
+                }
+                PushDelay(msg, 1000);
+                return;
+            }else {
+                lsize = res.html.size();
+            }
+        }
+
+        if (!ProcStream(stream)) break;
+        //streamlock_.Acquire();
+        streams_[msg.key] = stream;
+        //streamlock_.Release();
+
+        // waiting and push the msg into queue by return directly
+        if (lsize < 0) {
+            if(stream->Prepare(&lsize) == -3) { 
+                std::string mtype = stream->GetMtype();
+                LOG(INFO) << __func__ << " waiting for mtype=" << mtype;
+                int iret = 1000;
+                if (mtype == kMmtMediaVideo || mtype == kMmtMediaAudio) {
+                    iret = 3000;
+                }
+                PushDelay(msg, iret);
+                return;
+            }
+        }
+    }while(false);
+
+    LOG(INFO) << __func__ << " lsize=" << lsize;
+    if (msg.sinfo.func) {
+        msg.sinfo.func(msg.job, msg.sinfo, lsize);
+    }
+}
+void MmtControl::StreamRead(ctrl_msg_t msg) {
+    auto& key = msg.key;
+    StreamPtr stream;
+    //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    //streamlock_.Acquire();
+    auto iter = streams_.find(key);
+    if (iter != streams_.end()) {
+        stream = iter->second;
+    }
+    //streamlock_.Release();
+    if (!stream) return;
+
+    int tabid = stream->GetTabId();
+    if (tabid < 0 && !stream->IsMmtMedia() && msg.tab.postui) { 
+        // send it to chrome for getting TAB id
+        mmt::tabscript_t script;
+        script.head = kMmtTagTab;
+        script.tab = msg.tab;
+        script.tab.proto = stream->GetProto(); // should update proto
+        msg.tab.postui(script);
+    }
+    ProcJobs(msg);
+
+    memset(msg.sinfo.buf->data(), 0, msg.sinfo.size);
+
+    int iret = -1;
+    std::string proto = stream->GetProto();
+    if (proto == kMmtProtoMs1 || proto == kMmtProtoMs) {
+        ssres_t res = screen_->GetRRes();
+        iret = std::min((int)res.html.size(), msg.sinfo.size);
+        memcpy(msg.sinfo.buf->data(), res.html.c_str(), iret);
+
+        int pos = res.bcast.find(":");
+        if (pos != -1) {
+            std::string host = res.bcast.substr(0, pos);
+            std::string port = res.bcast.substr(pos+1);;
+            LOG(INFO) << __func__ << " MmtpStart, host=" << host << " port=" << port;
+            if (!host.empty() && !port.empty()) {
+                MmtpStart(host, String2Int(port), "ci");
+            }
+        }
+    }else {
+        iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
+    }
+
+    if (iret == -3) { // waiting 
+        std::string mtype = stream->GetMtype();
+        LOG(INFO) << __func__ << " waiting for mtype=" << mtype;
+        int delay = 100;
+        PushDelay(msg, delay);
+    }else {
+        // For mmt://224.1.1.101:6080?proto=mmtp, Set bcast and html for screen.
+        if (iret > 0) {
+            if (stream->GetMtype() == kMmtMediaHtml) { 
+                if (proto != kMmtProtoMs1 && proto != kMmtProtoMs) { // request(ms1/ms) donot set html
+                    screen_->SetBcast(msg.url.host(), msg.url.port());
+                    std::string szhtml = std::string(msg.sinfo.buf->data());
+                    screen_->SetHtml(szhtml);
+                }
+            }
+
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.job, msg.sinfo, iret);
+            }
+        }
+    }
+}
+void MmtControl::StreamCi(ctrl_msg_t msg) {
+    // save information of current tab of chrome
+    int tabid = msg.tab.tab_id;
+    LOG(INFO) << __func__ << " head=" << msg.head << 
+        " tabid=" << tabid << " proto=" << msg.tab.proto;
+    if (tabid <= 0) return;
+
+    cixmlptr_t cixml = new cixml_t;
+    cixml->fname = "";
+    if (msg.tab.proto != kMmtProtoMmtp)
+        cixml->fname = kMmtDefaultXml;
+    cixml->script.tab = msg.tab;
+
+    //cilock_.Acquire();
+    cixmls_[tabid] = cixml;
+    //cilock_.Release();
+}
+void MmtControl::StreamClose(ctrl_msg_t msg) {
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << msg.key 
+        << " tabid=" << msg.tab.tab_id;
+
+    StreamPtr stream;
+    //streamlock_.Acquire();
+    StreamPtrs_t::iterator iter = streams_.find(msg.key);
+    if (iter != streams_.end()) {
+        stream = iter->second;
+        streams_.erase(iter);
+    }
+    //streamlock_.Release();
+}
+void MmtControl::ProcCiXml(cixmlptr_t cixml, int tabid) {
+    if (!cixml) return;
+
+    //> Process Mult-Screen Xml;
+    std::string proto = cixml->script.tab.proto;
+    bool master = (proto != kMmtProtoMs1 && proto != kMmtProtoMs); 
+    bool master_xml = master;
+    if (proto == kMmtProtoMsMmtp || proto == kMmtProtoMsLocal) {
+        master_xml = false;
+    }
+
+    std::string xml_name = cixml->fname;
+    if (!cixml->parser) { // first load
+        cixml->parser = new CiParser(xml_name);
+        if (!master) {
+            ssres_t res = screen_->GetRRes();
+            cixml->parser->SetXmlStr(res.ci);
+        }
+
+        cixml->parser->SetTabId(tabid);
+        if(!cixml->parser->ParseXml(master_xml) || !cixml->parser->ParseHtml()) {
+            LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
+            cixml->parser = nullptr;
+            cixml->update = kMmtXmlInterval;
+        }else {
+            cixml->parser->PrintHtmlJS(); // print html js
+            if (cixml->parser->IsMultiple()) {
+                if (proto != kMmtProtoMs1 && proto != kMmtProtoMs) {
+                    // update screen's xml, but not for ms/ms1
+                    screen_->SetCi(cixml->parser->GetXmlStr());
+                }
+            }
+        }
+    }
+
+    int64 ntp = GetNTPTime();
+    // Porcess update of ci xml
+    if (master && cixml->parser && (cixml->update--) <= 0) {
+        int64 timestamp = cixml->parser->GetTimestamp();
+        std::string version = cixml->parser->GetVersion();
+        CiParserPtr parser2 = new CiParser(xml_name);
+        LOG(INFO) << __func__ << " [ParseXML] xml=" << xml_name;
+        if(parser2->ParseXml(master_xml)) {
+            int64 timestamp2 = parser2->GetTimestamp();
+            std::string version2 = parser2->GetVersion();
+            LOG(INFO) << __func__ << " to update xml, ntp=" << ntp
+                << " old timestamp=" << timestamp << " version=" << version
+                << " new timestamp=" << timestamp2 << " version=" << version2;
+
+            if (ntp >= timestamp2 && timestamp < timestamp2) {
+                parser2->SetTabId(tabid);
+                if(parser2->ParseHtml()) {
+                    parser2->MergeCI(cixml->parser.get());
+                    cixml->parser = parser2;
+                    LOG(INFO) << __func__ << " to update xml, OK";
+
+                    if (cixml->parser->IsMultiple()) {
+                        if (proto != kMmtProtoMs1 && proto != kMmtProtoMs) {
+                            // update screen's xml, but not for ms/ms1
+                            screen_->SetCi(cixml->parser->GetXmlStr());
+                        }
+                    }
+                }
+            }
+            cixml->update = kMmtXmlInterval;
+        }else {
+            LOG(INFO) << __func__ << " fail to parse xml";
+        }
+        parser2 = nullptr;
+    }
+
+    // Process subset xml
+    if (master && cixml->parser && !cixml->subxmls.empty()) {
+        for (auto& iter : cixml->subxmls) {
+            if (iter.timeout != 0) continue;
+            LOG(INFO) << __func__ << " [ParseXML] xml=" << iter.fname;
+
+            CiParserPtr parser2 = new CiParser(iter.fname);
+            if(parser2->ParseXml(master_xml)) { // if failed maybe not got this xml, waiting for next time
+                parser2->SetTabId(tabid); // should be called before ParserHtml
+                if(parser2->ParseHtml()) {
+                    parser2->MergeCI2(cixml->parser.get());
+                    cixml->parser = parser2;
+                }
+                iter.timeout = 1;
+            }
+            parser2 = nullptr;
+        }
+    }
+
+    // process tab events(css/js)
+    if (cixml->parser) {
+        std::string css;
+        std::string js0, js1;
+        cixml->parser->GetSubXmlJS(ntp, js0);
+        if (!js0.empty()) {
+            LOG(INFO) << __func__ << " js0 => " << js0;
+        }
+        cixml->parser->GetHtmlJS(ntp, js1, css);
+        if (!js1.empty()) {
+            LOG(INFO) << __func__ << " js1 => " << js1;
+        }
+
+        // for css
+        if (!css.empty()) {
+            LOG(INFO) << __func__ << " css => " << css;
+            cixml->script.posttab(kMmtTagCSS, css);
+        }
+
+        // for js
+        std::string js = js0 + js1;
+        if(!js.empty()) {
+            cixml->script.posttab(kMmtTagJS, js);
+        }
+
+        // for ms
+        if (screen_->IsSharing()) {
+            std::string js2;
+            cixml->parser->GetScreenJS(js2);
+            if(!js2.empty()) {
+                LOG(INFO) << __func__ << " js2 => " << js2;
+                cixml->script.posttab(kMmtTagJS, js2);
+            }
+        }
+    }
+}
+
+void MmtControl::CheckEvent() {
+    std::vector<int> tabs;
+    //cilock_.Acquire();
+    for(auto& item: cixmls_) {
+        tabs.push_back(item.first);
+    }
+    //cilock_.Release();
+    
+    for(auto& tabid: tabs) {
+        if (tabid <= 0) continue;
+        cixmlptr_t cixml;
+        //cilock_.Acquire();
+        if (cixmls_.find(tabid) != cixmls_.end()) {
+            cixml = cixmls_[tabid];
+        }
+        //cilock_.Release();
+        ProcEvent(tabid, cixml);
+    }
+}
+
+void MmtControl::ProcEvent(int tabid, cixmlptr_t cixml) {
+    if (!cixml) return;
+    if (cixml->status == cixml_t::E_End) return;
+    if (cixml->status == cixml_t::E_Unknown) {
+        if (cixml->waiting-- <= 0) {
+            cixml->status = cixml_t::E_Initing;
+        }
+        return;
+    }
+
+    std::string proto = cixml->script.tab.proto;
+    if (proto == kMmtProtoMmtp && cixml->fname.empty()) {
+        mmtp_info_t mmtp;
+        mmtp.id = "";
+        mmtp.url = "";
+        mmtp.mtype = kMmtMediaCI;
+        mmtp.index = -1;
+        if(MmtpPop(mmtp) == 0) {
+            cixml->fname = mmtp.fname;
+        }
+        LOG(INFO) << __func__ << " get xml file=" << cixml->fname;
+    }else if (proto == kMmtProtoMs1 || proto == kMmtProtoMs) {
+        cixml->fname = proto;
+    }
+    if (cixml->fname.empty()) return;
+
+    int next_status = cixml->status;
+    //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
+    if (cixml->status == cixml_t::E_Initing) {
+        next_status = cixml_t::E_Loading;
+        Wait(300);
+    }else if (cixml->status == cixml_t::E_Loading) {
+        next_status = cixml_t::E_Loaded;
+        Wait(500);
+    }else if (cixml->status == cixml_t::E_Loaded) {
+        ProcCiXml(cixml, tabid);
+        //next_status = E_End;
+    }
+    cixml->status = next_status;
+}
+
+void MmtControl::Run() {
+    LOG(INFO) << __func__ << " begin";
+
+    running_ = true;
+    delaythread_->Start();
+    int ms = kMmtLoopInterval;
+
+    while(loop_) {
+        // check ci event
+        CheckEvent();
+
+        // get one msg
+        ctrl_msg_t msg;
+        if (!Pop(msg)) {
+            Wait(ms);
+            continue;
+        }
+
+        // process msg
+        ms = kMmtLoopInterval;
+        if (msg.head == kMmtTagCtrl) {
+            SendToHost(msg.body, "127.0.0.1", 54321);
+        }else if (msg.head == kMmtTagOpen) {
+            StreamOpen(msg);
+        }else if (msg.head == kMmtTagClose) {
+            StreamClose(msg);
+        }else if (msg.head == kMmtTagRead) {
+            //TODO: if io pending, should re-push this msg again.
+            StreamRead(msg);
+            ms = kMmtReadInterval;
+        }else if (msg.head == kMmtTagCI) {
+            StreamCi(msg);
+        }
+    };
+    running_ = false;
+    LOG(INFO) << __func__ << " end";
+}
+
+void MmtControl::Reset() {
+    loop_ = true;
+    screen_ = new Screen();
+    screen_->Start(kMmtScreenPort);
+}
+
+bool MmtControl::IsRunning() {
+    return running_;
+}
+
+bool MmtControl::Pop(ctrl_msg_t &msg) {
+    if (queue_.empty()) return false;
+    msg = queue_.front();
+    queue_.pop();
+    return true;
+}
+
+int MmtControl::Push(ctrl_msg_t& msg) {
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << msg.key;
+    int iret = net::ERR_IO_PENDING;
+    queue_.push(msg);
+    return iret;
+}
+
+void MmtControl::DoPush(ctrl_msg_t msg) {
+    Push(msg);
+}
+
+void MmtControl::PushDelay(ctrl_msg_t& msg, int delay) {
+    delaythread_->message_loop_proxy()->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&MmtControl::DoPush, base::Unretained(this), msg),
+            base::TimeDelta::FromMilliseconds(delay));
+}
+
+} // namespace mmt
+
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
new file mode 100644
index 0000000..80d3fa0
--- /dev/null
+++ b/net/mmt/mmt_control.h
@@ -0,0 +1,242 @@
+#ifndef NET_MMT_MMT_CONTROL_H_
+#define NET_MMT_MMT_CONTROL_H_
+
+/**
+ * Control center, 
+ *  which process mmt protocol, CI, Stream IO(mmtp) and A/V sync.
+ *  It will be activated by mmt:// protocol and only start one seperate thread.
+ */
+
+#include <string>
+#include <queue>
+#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_parser.h"
+#include "net/mmt/mmt_screen.h"
+
+namespace net {
+class IOBuffer;
+class URLRequestJob;
+}
+
+namespace mmt {
+
+/**
+ * Post task over UI thread, which is used to execute JS scripts in UrlRequestMmtJob.
+ */
+struct tabscript_t;
+typedef void (*postui_func_t) (const tabscript_t& script);
+
+/**
+ * To collect the information of chome tab
+ */
+struct tab_t {
+    tab_t();
+    int routing_id; //> render host routing id 
+    int process_id; //> render process id
+    int frame_id;   //> render frame id
+    int tab_id;     //> chrome's tab id
+    GURL tab_url;   //> chrome's tab url
+    std::string proto;      //> "local" or "mmtp"
+    postui_func_t postui;   //> post task function
+};
+
+struct content_t {
+    content_t();
+    tab_t tab;
+};
+
+struct tabscript_t {
+    tabscript_t();
+    tab_t tab;
+    std::string head;
+    std::string body;
+    void posttab(std::string head, std::string body);
+};
+
+
+///===============================================
+
+struct stream_info_t;
+typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
+
+/**
+ * Stream IO callback function, which is used to pass data to UrlRequestMmtJob.
+ *  three parameters: (job object, stream_info_t, errno)
+ */
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, long);
+
+
+/**
+ * Stream IO Information
+ */
+struct stream_info_t {
+    stream_info_t();
+    ~stream_info_t();
+
+    net::IOBuffer*  buf;        // media buffer
+    int             size;       // data size
+    int             offset;     // data offset from the beginning
+    stream_func_t   func;       // stream io callback function
+};
+
+/**
+ * The message for Control Center.
+ */
+struct ctrl_msg_t {
+    ctrl_msg_t();
+    ~ctrl_msg_t();
+
+    std::string key;
+    std::string head;   //> msg tag: @open, @read, @close, @ctrl and etc.
+    std::string body;   //> msg body: only valid for @ctrl
+    job_refptr_t job;   //> job(UrlRequestMmtJob) object
+
+    GURL url;           //> access url
+    tab_t tab;          //> chrome's tab id
+    stream_info_t sinfo;    //> only valid for @open, @read and @close
+};
+
+/**
+ * Structure for CI XML. 
+ */
+struct xmlinfo_t {
+    std::string fname;   //> xml file name, but is url actually
+    int timeout;
+};
+
+struct cixml_t : public base::RefCounted<cixml_t> {
+public:
+    enum {
+        E_Unknown,
+        E_Initing,
+        E_Loading,
+        E_Loaded,
+        E_End,
+    };
+
+    cixml_t();
+
+    int status;             //> ci status: unknwon, initing,loading,loaded
+    int waiting;            //> waiting interval for next status
+    int update;             //> check interval of updating xml
+
+    std::string fname;      //> xml file name, but is url actually
+    tabscript_t script;     //> For @js and @css
+    std::vector<xmlinfo_t> subxmls; //> sub xmls
+    CiParserPtr parser;     //> xml parser for ci
+
+protected:
+    friend class base::RefCounted<cixml_t>;
+    virtual ~cixml_t();
+};
+typedef scoped_refptr<cixml_t> cixmlptr_t;
+
+} // namespace mmt
+
+
+namespace mmt {
+
+/**
+ * class for Control Center
+ */
+class MmtControl : public base::SimpleThread {
+public:
+    MmtControl();
+    virtual ~MmtControl();
+
+    /**
+     * Thread Main Loop
+     */
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(ctrl_msg_t& msg);
+    int  Push(ctrl_msg_t& msg);
+
+    void DoPush(ctrl_msg_t msg);
+    void PushDelay(ctrl_msg_t& msg, int delay);
+
+protected:
+    /**
+     * Process Stream of url I/O by callback of notifying chrome with value:
+     *   0: close the process of current url 
+     *  -1: pending and re-try 
+     *  >0: possible real size
+     *  <-1: failed and maybe crash for debugging
+     */
+    void StreamOpen(ctrl_msg_t msg);
+
+    /**
+     * Read data from stream to return it to chrome by callback.
+     *  if return -1 - fail. if return 0 - close.
+     *  For audio/video sequence, if current file read EOF, then goto open the next file automatically.
+     */
+    void StreamRead(ctrl_msg_t msg);
+
+    /**
+     * Close Stream for url.
+     */
+    void StreamClose(ctrl_msg_t msg);
+
+    /**
+     * Process CI only when get a valid tab id successfully.
+     */
+    void StreamCi(ctrl_msg_t msg);
+
+    // Check CI events.
+    void CheckEvent();
+    void ProcEvent(int tabid, cixmlptr_t cixml);
+    void ProcCiXml(cixmlptr_t cixml, int tabid);
+
+    // Process stream when Open
+    bool ProcStream(StreamPtr stream);
+
+    // Process jobs
+    void ProcJobs(ctrl_msg_t& msg);
+
+private:
+    bool loop_;
+    bool running_;
+    std::queue<ctrl_msg_t> queue_;
+    scoped_ptr<base::Thread> delaythread_;
+
+    //base::Lock joblock_;
+    std::vector<job_refptr_t> jobs_;
+
+    //base::Lock cilock_;
+    std::map<int, cixmlptr_t> cixmls_;  //> key/value: tabid => cixml_t
+
+    //base::Lock streamlock_;
+    StreamPtrs_t streams_;
+
+    ScreenPtr screen_; //> multi-screen
+};
+
+} // namespace mmt
+
+
+namespace mmt {
+
+// Start control center
+void StartMmtCtrl();
+
+/**
+ * param head: @ctrl/@ci
+ */
+int PostCtrlTask(std::string head, GURL url, std::string body, tab_t& tab);
+
+/**
+ * param head: @close
+ */
+int PostCtrlTask(std::string head, GURL url, job_refptr_t job, tab_t& tab);
+
+/**
+ * param head: @open or @read
+ * default return IO_PENDING(-1) which means open/read async
+ */
+int PostCtrlTask(std::string head, GURL url, stream_info_t& sinfo, job_refptr_t job, tab_t& tab);
+
+} // namespace mmt
+
+#endif // NET_MMT_MMT_CONTROL_H_
diff --git a/net/mmt/mmt_http.cc b/net/mmt/mmt_http.cc
new file mode 100644
index 0000000..aa39d6b
--- /dev/null
+++ b/net/mmt/mmt_http.cc
@@ -0,0 +1,226 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include "net/mmt/mmt_http.h"
+#include "net/mmt/mmt_inc.h"
+#include "neon/src/ne_session.h"
+#include "neon/src/ne_request.h"
+#include "neon/src/ne_auth.h"
+
+namespace mmt {
+
+/**
+ * usage: 
+ *  ne_session_create(scheme, hostname, port);
+ *  ne_request_create(session, method, path);
+ *  ne_add_request_header(..); 
+ *   => Host/Accept/User-Agent/Authorization,
+ *      Content-Type/Content-Length/body, 
+ *  ne_request_dispatch(..); => got Content/Content-Length
+ *  ne_get_status(..); => 200
+ *  ne_request_destroy()
+ *  ne_close_connection();
+ *  ne_session_destroy();
+ *
+ */
+
+HttpClient::HttpClient(std::string product) : product_(product){
+    request_ = nullptr;
+    session_ = nullptr;
+    file_ = nullptr;
+    memset(userdata_, 0, sizeof(userdata_));
+}
+
+HttpClient::~HttpClient() {
+    Uninit();
+}
+
+bool HttpClient::Get(GURL& url, std::string fname) {
+    std::string scheme = url.scheme();
+    if (scheme == "mmt") scheme = "http";
+
+    int port;
+    std::string hostname;
+    GURL2Address(url, hostname, port);
+
+    // only by GET
+    std::string method = "GET";
+    std::string path = url.path();
+
+    LOG(INFO) << __func__ << " HttpClient => "
+        << " scheme=" << scheme << " hostname=" << hostname
+        << " port=" << port << " method=" << method << " path=" << path; 
+
+    bool isok = false;
+    do {
+        //LOG(INFO) << __func__ << " open file";
+        if (!file_) {
+            file_ = fopen(fname.c_str(), "wb");
+            if (!file_) break;
+        }
+
+        LOG(INFO) << __func__ << " init http lib";
+        if (!Init(scheme, hostname, port)) break;
+        //LOG(INFO) << __func__ << " request http";
+        if (!Request(method, path)) break;
+
+        //LOG(INFO) << __func__ << " add header";
+        AddRequestHeader("Host", hostname);
+        AddRequestHeader("Accept", "*/*");
+        AddRequestHeader("User-Agent", product_);
+        AddRequestHeader("Content-Length", "0");
+        LOG(INFO) << __func__ << " request dispatch";
+        RequestDispatch();
+        isok = true;
+    }while(false);
+    Uninit();
+    
+    return isok;
+}
+
+bool HttpClient::Init(std::string scheme, std::string hostname, int port) {
+    ne_session* session = ne_session_create(scheme.c_str(), hostname.c_str(), port);
+    if (!session) return false;
+    session_ = (void*)session;
+
+    if (!product_.empty()) {
+        //ne_set_useragent((ne_session *)session_, product_.c_str());
+    }
+    return true;
+}
+
+int HttpClient::OnReaderCallback(const char *buf, size_t len) {
+    if (!buf || len <= 0) return 0;
+    if (file_) {
+        fwrite(buf, 1, len, file_);
+    }
+    return 0;
+}
+
+static int ne_block_reader_callback(void *userdata, const char *buf, size_t len) {
+    HttpClient* thiz = (HttpClient*)userdata;
+    if (thiz) {
+        thiz->OnReaderCallback(buf, len);
+    }
+    
+    return 0;
+}
+
+bool HttpClient::Request(std::string method, std::string path) {
+    if (!session_) return false;
+    ne_request* request = ne_request_create((ne_session *)session_, method.c_str(), path.c_str());
+    if (!request) return false;
+    request_ = (void*)request;
+    return true;
+}
+
+void HttpClient::Uninit() {
+    if (request_) {
+        ne_request_destroy((ne_request *)request_);
+        request_ = nullptr;
+    }
+
+    if (session_) {
+        ne_close_connection((ne_session *)session_);
+        ne_session_destroy((ne_session *)session_);
+        session_ = nullptr;
+    }
+
+    if (file_) {
+        fclose(file_);
+        file_ = nullptr;
+    }
+}
+
+int HttpClient::RequestDispatch() {
+    if (!request_) return -1;
+    ne_add_response_body_reader((ne_request *)request_, 
+            ne_accept_always, ne_block_reader_callback, (void*)this);
+    int iret = ne_request_dispatch((ne_request *)request_);
+    return iret;
+}
+
+int HttpClient::AddRequestHeader(std::string name, std::string value) {
+    if (!request_ || name.empty()) return -1;
+    ne_add_request_header((ne_request *)request_, name.c_str(), value.c_str());
+    return 0;
+}
+
+int HttpClient::GetResponseHeader(std::string name, std::string& value) {
+    if (!request_ || name.empty()) return -1;
+    const char* pval = ne_get_response_header((ne_request *)request_, name.c_str());
+    if (pval) {
+        value = pval;
+    }
+    return 0;
+}
+
+int HttpClient::SetReadTimeout(int timeout) {
+    if (!session_) return -1;
+    ne_set_read_timeout((ne_session *)session_, timeout);
+    return 0;
+}
+
+int HttpClient::SetConnectTimeout(int timeout) {
+    if (!session_) return -1;
+    ne_set_connect_timeout((ne_session *)session_, timeout);
+    return 0;
+}
+
+/**
+ * void ne_set_request_body_buffer(ne_request *req, const char *buf, size_t count);
+ */
+int HttpClient::SetRequestBodyBuffer(const char* buffer, int count) {
+    if (!buffer || count <= 0) return -1;
+    if (!request_) return -1;
+    ne_set_request_body_buffer((ne_request *)request_, buffer, count);
+    return 0;
+}
+
+/**
+ * const ne_status *ne_get_status(const ne_request *request);
+ */
+int HttpClient::GetStatus(){
+    if (!request_) return -1;
+
+    const ne_status* status = ne_get_status((const ne_request *)request_);
+    if (status) {
+        //status->major_version,status->minor_version, status->code, status->klass,status->reason_phrase 
+        return status->code;
+    }
+    return -1;
+}
+
+static int ne_auth_creds_callback(void *userdata, const char* realm, int attempt, 
+    char *username, char *password)
+{
+    HttpClient* thiz = (HttpClient*) userdata;
+    if (thiz) {
+        thiz->OnAuthCreds(username, password);
+    }
+    return attempt;
+}
+
+int HttpClient::OnAuthCreds(char *username, char *password) {
+    char *sep = strstr((char *)userdata_, ":");
+    if (sep) {
+        int ilen = (int)(sep - (char *)userdata_);
+        int ulen = (ilen <= NE_ABUFSIZ) ? ilen : NE_ABUFSIZ;
+        strncpy(username, userdata_, ulen);
+        strncpy(password, userdata_+(ilen+1), NE_ABUFSIZ);
+    }
+    return 0;
+}
+
+int HttpClient::SetServerAuth(const char* userdata) {
+    if (!session_) return -1;
+    ne_set_server_auth((ne_session*)session_, ne_auth_creds_callback, (void *)this);
+    return 0;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_http.h b/net/mmt/mmt_http.h
new file mode 100644
index 0000000..78f40de
--- /dev/null
+++ b/net/mmt/mmt_http.h
@@ -0,0 +1,47 @@
+#ifndef NET_MMT_MMT_HTTP_H_
+#define NET_MMT_MMT_HTTP_H_
+
+#include "base/memory/ref_counted.h"
+#include "url/gurl.h"
+
+namespace mmt {
+
+class HttpClient : public base::RefCounted<HttpClient> {
+public:
+    explicit HttpClient(std::string product);
+    bool Get(GURL& url, std::string fname);
+
+    bool Init(std::string scheme, std::string hostname, int port);
+    bool Request(std::string method, std::string path);
+    void Uninit();
+
+    int RequestDispatch();
+    int AddRequestHeader(std::string name, std::string value);
+    int GetResponseHeader(std::string name, std::string& value);
+
+    int SetConnectTimeout(int timeout);
+    int SetReadTimeout(int timeout);
+    int SetRequestBodyBuffer(const char* buffer, int count);
+    int GetStatus();
+    int SetServerAuth(const char* userdata);
+
+    int OnReaderCallback(const char *buf, size_t len);
+    int OnAuthCreds(char *username, char *password);
+
+protected:
+    friend class base::RefCounted<HttpClient>;
+    virtual ~HttpClient();
+
+private:
+    std::string product_;
+    char  userdata_[1024];
+
+    void* session_;
+    void* request_;
+    FILE* file_;
+};
+typedef scoped_refptr<HttpClient> HttpClientPtr;
+
+}
+
+#endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
new file mode 100644
index 0000000..c087d25
--- /dev/null
+++ b/net/mmt/mmt_inc.h
@@ -0,0 +1,143 @@
+#ifndef NET_MMT_MMT_INC_H_
+#define NET_MMT_MMT_INC_H_
+
+#include <string>
+#include <sstream>
+#include <iomanip>
+#include <vector>
+#include <algorithm>
+
+#include "base/logging.h"
+#include "base/values.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/threading/thread.h"
+
+#include "net/base/net_errors.h"
+#include "net/base/file_stream.h"
+#include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
+#include "net/udp/udp_socket.h"
+#include "net/url_request/url_request_job.h"
+
+#include "extensions/common/extension.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "url/gurl.h"
+
+
+namespace mmt{
+
+#define USE_NTP_TIME 1
+//#define MMT_MULTI_IO 1
+//#define MMT_LOG_V 1
+//#define USE_MMT_NATIVE_MESSAGE 1
+
+
+
+/**
+ * Wait millseconds
+ */
+void Wait(int ms);
+
+/**
+ * Convert int to string with fill 0 of width.
+ */
+std::string Int2String(int value, int width=0);
+std::string Ptr2String(void* ptr);
+
+/**
+ * Convert string to int
+ */
+int String2Int(std::string value);
+
+/**
+ * Convert GURL to file path/net address
+ */
+std::string GURL2FilePath(GURL gurl);
+std::string GURL2FilePath(GURL gurl, std::string& dname, std::string& bname);
+void GURL2Address(const GURL& gurl, std::string& host, int& port);
+
+/**
+ * Parse models with ?k1=v1&k2=v2
+ */
+std::string GetQueryValue(std::string query, std::string key);
+
+/**
+ * Parse models with n1-n2, n1-.
+ */
+bool GetRangeValue(std::string range, std::pair<int,int>& item);
+bool GetClipValue(std::string clip, std::vector<std::pair<int,int> >& items);
+
+/**
+ * Send to some host with msg over UDP
+ */
+int SendToHost(std::string msg, std::string szaddr, int port);
+int SendToHost(const char* data, int len, std::string szaddr, int port);
+
+/**
+ * Get local/ntp time (ms)
+ */
+int64 GetLocalTime();
+int64 GetNTPTime();
+
+/**
+ * media/proto constants
+ */
+extern const char kMmtNtpServer[];      //> ntp server
+
+extern const char kMmtMediaAudio[];
+extern const char kMmtMediaVideo[];
+extern const char kMmtMediaImage[];
+extern const char kMmtMediaHtml[];
+extern const char kMmtMediaCI[];
+
+extern const char kMmtProtoMmtp[];      //> Get data from mmtp receiver
+extern const char kMmtProtoLocal[];
+extern const char kMmtProtoExtra[];     //> the same with http
+extern const char kMmtProtoHttp[];      //> http for subset xml/index.html
+
+extern const char kMmtProtoMs[];        //> multi-screen: Listen for remote sharing.
+extern const char kMmtProtoMsMmtp[];    //> ms mmtp
+extern const char kMmtProtoMsLocal[];   //> ms local
+
+extern const char kMmtProtoMs0[];       //> multi-screen: Share to remote.
+extern const char kMmtProtoMs1[];       //> multi-screen: Request to share.
+extern const char kMmtDefaultUrl[];
+
+// for url query
+extern const char kMmtHtmlId[];
+extern const char kMmtXmlIdPrefix[];
+extern const char kMmtDivIdPrefix[];
+
+// tags for mmt control
+extern const char kMmtTagCtrl[];
+extern const char kMmtTagOpen[];
+extern const char kMmtTagRead[];
+extern const char kMmtTagClose[];
+extern const char kMmtTagCI[];
+
+// tags for chrome tab
+extern const char kMmtTagTab[];
+extern const char kMmtTagCSS[];
+extern const char kMmtTagJS[];
+
+// for multi-screen
+extern const int kMmtScreenPort;
+
+}
+
+#endif
diff --git a/net/mmt/mmt_packet.cc b/net/mmt/mmt_packet.cc
new file mode 100644
index 0000000..2969e25
--- /dev/null
+++ b/net/mmt/mmt_packet.cc
@@ -0,0 +1,44 @@
+#include "net/mmt/mmt_packet.h"
+#include <string.h>
+#include <stdio.h>
+
+namespace mmt {
+
+ms_packet_t* init_header(char* buffer, int type, const char* bcast) {
+    ms_packet_t* pkt = (ms_packet_t*) buffer;
+    assert_returnv(pkt, nullptr);
+    memset((void*)pkt, 0, HEAD_SIZE);
+    pkt->ver  = DEFAULT_VERSION;
+    pkt->type = type;
+    if (bcast && strlen(bcast) > 0) {
+        strncpy(pkt->bcast, bcast, sizeof(pkt->bcast)-1);
+    }
+    return pkt;
+}
+
+int set_packet_ms_request(char* buffer) {
+    ms_packet_t* pkt = init_header(buffer, E_MS_Request, nullptr);
+    assert_returnv(pkt, -1);
+    return HEAD_SIZE + pkt->size;
+}
+
+int set_packet_ms_cihtml(char* buffer, const char* bcast, const char* ci, const char* html) {
+    ms_packet_t* pkt = init_header(buffer, E_MS_CiHtml, bcast);
+    assert_returnv(pkt, -1);
+
+    int pos = 0;
+    char data[MAX_BODY_SIZE];
+    memset(data, 0, sizeof(data));
+    if (ci && strlen(ci) > 0)
+        pos += snprintf(data+pos, sizeof(data)-pos, "[ci]:%s", ci);
+    if (html && strlen(html) > 0)
+        pos += snprintf(data+pos, sizeof(data)-pos, "[html]:%s", html);
+    assert_returnv(pos > 0, -1);
+
+    pkt->size = pos;
+    memcpy(pkt->body, data, pkt->size);
+    return HEAD_SIZE + pkt->size;
+}
+
+
+} // namespace mmt
diff --git a/net/mmt/mmt_packet.h b/net/mmt/mmt_packet.h
new file mode 100644
index 0000000..bfda029
--- /dev/null
+++ b/net/mmt/mmt_packet.h
@@ -0,0 +1,61 @@
+#ifndef NET_MMT_MMT_PACKET_H_
+#define NET_MMT_MMT_PACKET_H_
+
+namespace mmt {
+
+/**
+ * The type of multi-screen message.
+ */
+enum ms_type_t{
+    E_MS_Unknown    = 0,
+
+    E_MS_Request    = 0x0001,
+    E_MS_CiHtml     = 0x0002,
+
+    E_MS_All        = 0xffff
+};
+
+/** 
+ * ms packet structure: not include <body>.
+ */
+#pragma pack(1)
+typedef struct ms_packet_t {
+    char        ver;
+    int         type;       //> packet type
+    char        bcast[64];  //> broadcast address
+    int         size;       //> packet body size
+    char        body[1];
+}ms_packet_t;
+#pragma pack()
+
+#define DEFAULT_VERSION             1
+#define HEAD_SIZE                   (sizeof(ms_packet_t)-1)
+#define MAX_BODY_SIZE               (1024*16-HEAD_SIZE)
+
+#define assert_return(p)            if(!(p)) return;
+#define assert_returnv(p, v)        if(!(p)) return (v);
+
+/**
+ * Init commom header of ms packet
+ */
+ms_packet_t* init_header(char* buffer, int type, const char* bcast);
+
+
+/**
+ * Request sharing from main screen.
+ */
+int set_packet_ms_request(char* buffer);
+
+/**
+ * send multi-screen(ms) html/xml to second screen
+ * @param bcast: broadcast address
+ * @param ci: ci xml content
+ * @param html: html content
+ */
+int set_packet_ms_cihtml(char* buffer, const char* bcast, const char* ci, const char* html);
+
+
+} // namespace mmt
+
+
+#endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
new file mode 100644
index 0000000..dcc9d4f
--- /dev/null
+++ b/net/mmt/mmt_parser.cc
@@ -0,0 +1,1287 @@
+#include "net/mmt/mmt_parser.h"
+#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
+
+#include "libxml/parser.h"
+
+namespace mmt {
+
+static const char kNoValue[] = "no-value";
+
+/**
+ * For the node name of ci xml
+ */
+static const char kCI[]             = "CI";
+static const char kview[]           = "view";
+static const char kdivLocation[]    = "area";
+static const char kMediaSync[]      = "MediaSync";
+static const char ksourceList[]     = "sourceList";
+
+/**
+ * For the attr name of ci xml's node
+ */
+static const char kversion[]    = "version";
+static const char ktimestamp[]  = "timestamp";
+
+static const char krefId[]      = "refId";
+static const char krefDiv[]     = "refDiv";
+static const char kmediaSrc[]   = "mediaSrc";
+static const char kstyle[]      = "style";
+
+static const char kbegin[]      = "begin";
+static const char kend[]        = "end";
+static const char kdur[]        = "dur"; // TODO
+static const char kclipBegin[]  = "clipBegin";
+static const char kclipEnd[]    = "clipEnd";
+static const char kclipList[]   = "clipList";
+
+static const char kxlinkhref[]  = "xlink:href";
+static const char kxlinkactuate[] = "xlink:actuate";
+
+// TODO for multi-screen
+static const char kviewRole[]   = "viewRole";
+static const char kplungeOut[]  = "plungeOut";
+static const char kplungeIn[]   = "plungeIn";
+
+
+/**
+ * For the value of kviewRole
+ */
+static const char kdefault[]    = "default"; 
+static const char kmultiple[]   = "multiple"; 
+static const char kreceptiple[] = "receptiple";    //>case 7, recv one from another device.
+
+/**
+ * For the value of kplungeOut
+ */
+static const char kdisable[]       = "disable";
+static const char kcomplementary[] = "complementary";  //>case5/6, split one to another device.
+static const char ksharable[]      = "sharable";       //>case3, share one to another device.
+static const char kdynamic[]       = "dynamic";        //>case4, move one to another device.
+static const char kuserselect[]    = "userselect";
+
+/**
+ * For the value of kbegin/kend/kdur
+ */
+static const char kevinf[]      = "indefinite";
+static const char kevbegin[]    = ".begin";
+static const char kevend[]      = ".end";
+static const char kevclick[]    = ".click";
+
+/**
+ * For value of kxlinkactuate
+ */
+static const char konLoad[]     = "onLoad";    //> auto-load when window.document is load
+static const char konRequest[]  = "onRequest"; //> it will be acturated when user click the body of browser.
+
+
+
+/**
+ * callback functions for libxml2's sax parser
+ */
+static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->AddNode((const char*)name);
+
+    while (NULL != atts && NULL != *atts) {
+        if (atts[0] && atts[1]) {
+            if (ptr) ptr->AddAttr((const char*)atts[0], (const char*)atts[1]);
+        }else if (atts[0]) {
+            if (ptr) ptr->AddAttr((const char*)atts[0], kNoValue);
+        }
+        atts += 2;
+    }
+}
+static void sax_end_element(void *x,const xmlChar *name){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->EndNode((const char*)name);
+}
+static void sax_characters(void *x,const xmlChar *ch,int len){
+}
+static void sax_pi(void *x,const xmlChar *target,const xmlChar *data){
+    fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
+}
+static void sax_comment(void *x,const xmlChar *value) {
+#ifdef MMT_LOG_V
+    fprintf(stdout, "[xml][comment] %s\n", value);
+#endif
+}
+static void sax_error(void *x,const char *msg,...) {
+#ifdef MMT_LOG_V
+    va_list ap;
+    va_start(ap,msg);
+    fputs("[xml][error] ",stderr);
+    vfprintf(stderr,msg,ap);
+    va_end(ap);
+#endif
+}
+
+static void init_sax(xmlSAXHandlerPtr sax) {
+    sax->startElement = sax_start_element;
+    sax->endElement = sax_end_element;
+    sax->characters = sax_characters;
+    sax->processingInstruction = sax_pi;
+    sax->comment = sax_comment;
+    sax->warning = sax_error;
+    sax->error = sax_error;
+    sax->fatalError = sax_error;
+}
+
+/**
+ * Utils for generating javascript 
+ */
+static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
+    if (src.empty() || id.empty()) return "";
+    std::string url = src;
+    if(src.find("?") == std::string::npos) {
+        url += "?";
+    }else {
+        url += "&";
+    }
+    url = url + kMmtHtmlId+"="+id + "&tabid="+Int2String(tabid);
+    return url;
+}
+inline std::string CreateJSObject(std::string id, std::string name) {
+    std::string js;
+    js += "if(g_"+id+" == undefined) {";
+    js += "g_"+id+" = document.createElement('"+name+"');"; // create element
+    js += "g_"+id+".id='"+id+"';";                          // set element id
+    js += "document.body.appendChild(g_"+id+");";
+    js += "}\n";
+    return js;
+}
+inline std::string GetJSObject(std::string id) {
+    return "g_"+id+" = getNode('"+id+"');";
+}
+inline std::string SetJSAttr(std::string id, std::string attr, std::string value) {
+    std::string js;
+    js += "attrVal = '"+value+"';\n";
+    js += "trySetAttr(g_"+id+", '"+attr+"', attrVal);\n";
+    return js;
+}
+inline std::string SetJSEventBegin(std::string id, std::string name) {
+    std::string js;
+    js += "if(g_"+id+" != undefined) {\n";
+    js += "g_"+id+"."+name+" = function() {\n";  
+    return js;
+}
+inline std::string SetJSEventEnd() {
+    return "}}\n";  
+}
+
+inline std::string ProcMediaJS(std::string id) {
+    return "procMediaNode(g_"+id+");\n";
+}
+inline std::string SetDivJSStatus(std::string id, std::string st) {
+    return "procChildNodes(g_"+id+", "+st+");\n";
+}
+inline std::string SetDivJSClear(std::string id) {
+    return "procChildNodes(g_"+id+", 0);\n";
+}
+inline std::string SetDivJSPlay(std::string id) {
+    return "procChildNodes(g_"+id+", 1);\n";
+}
+inline std::string SetJSDisplay(std::string id, std::string value) {
+    return "setDisplay(g_"+id+", '"+value+"');\n";
+}
+inline std::string SetCSSStyle(std::string id, std::string value) {
+    return "#"+id+"{"+value+"}\n";
+}
+
+inline std::string SetCastStatus(std::string id, std::string ip, std::string port, std::string st) {
+    std::string gid = "g_"+id;
+    return "procDivCast("+gid+", '"+ip+"', "+port+", '"+st+"');\n";
+}
+inline std::string SetMSStatus(std::string id, std::string st) {
+    std::string gid = "g_"+id;
+    return "procDivMS("+gid+", '"+st+"');\n";
+}
+
+inline std::string AddJSAttr(std::string id, std::string attr, std::string value) {
+    return "tryNewAttr(g_"+id+", '"+attr+"', '"+value+"');\n";
+}
+
+std::string SetJSUtils() {
+    std::string js;
+    js += "function getNode(eid) {return document.getElementById(eid);}\n";
+    js += "function setDisplay(id, val) {if (id != undefined) {id.style.display = val;}}\n";
+    js += "function trySetAttr(id, attr, val) {pre = id.getAttribute(attr);";
+    js += "if (!pre || (pre != val && !(val == 1 && pre == 2))) {id.setAttribute(attr, val);}}\n";
+    js += "function tryNewAttr(id, attr, val)";
+    js += "{if (id != undefined && !id.getAttribute(attr)) {id.setAttribute(attr, val);}}\n";
+    return js;
+}
+std::string SetMediaJSUtils() {
+    std::string js;
+#ifdef USE_CAST
+    js += "function procCastNode(e, ip, port, kind) {";
+    js += "if (e != undefined && !e.getAttribute('cast')) {";
+    js += "e.oncanplay = function() {";
+    js += "if (kind == 'compl') e.style.visibility = 'hidden';";
+    js += "if (kind == 'dynam') e.style.display = 'none';";
+    js += "e.cast(true, ip, port);";
+    js += "}}}\n";
+#endif
+    js += "function procMSNode(e, kind) {";
+    js += "if (e != undefined) {";
+    js += "if (kind == 'compl') {e.style.visibility = 'hidden'; e.setAttribute('mstate', 0);}";
+    js += "if (kind == 'dynam') {e.setAttribute('mstate', 0);}";
+    js += "if (kind == 'plin0') {e.setAttribute('mstate', 0);}";
+    js += "if (kind == 'plin1') {e.setAttribute('mstate', 1);}";
+    js += "}}\n";
+    js += "function procMediaNode(e1) {";
+    js += "if (e1 == undefined || !e1.getAttribute('mstate')) return;";
+    js += "mstate = e1.getAttribute('mstate');";
+    js += "if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
+    js += "    if (mstate == 2) {";      // played
+    js += "        e1.style.display = 'block';";
+    js += "    }else if (mstate == 1) {";      // playing
+    js += "        e1.src = e1.getAttribute('srcuri');";
+    js += "        if (e1.play != undefined) e1.play(); e1.style.display = 'block';";
+    js += "        e1.setAttribute('mstate', 2);";
+    js += "    }else if(mstate == 0) {";  // pause
+    js += "        e1.style.display = 'none';if (e1.pause != undefined) {e1.pause(); e1.src='';}";
+    js += "    }";
+    js += "}}\n";
+    return js;
+}
+std::string SetDivJSUtils() {
+    std::string js;
+    js += "var domedia = 0;";
+    js += "function procChildNodes(e0, st) {";
+    js += "if(e0)";
+    js += "{if(st >= 1) {e0.style.display = 'block';} else {e0.style.display = 'none';}}";
+    js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
+    js += " if (e1.nodeType == 1) {";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
+    js += "         pre = e1.getAttribute('mstate');";
+    js += "         if (st != -1) {if (!(st == 1 && pre == 2)) e1.setAttribute('mstate', st);";
+    js += "         if (domedia == 1) procMediaNode(e1);}";
+    js += "     }";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'DIV') {";
+    js += "         procChildNodes(e1, st);";
+    js += "     }";
+    js += "}}}\n";
+#ifdef USE_CAST
+    js += "function procDivCast(e0, ip, port, kind) {";
+    js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
+    js += " if (e1.nodeType == 1) {";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO') {";
+    js += "         procCastNode(e1, ip, port, kind);";
+    js += "     }";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'DIV') {";
+    js += "         procDivCast(e1, ip, port, kind);";
+    js += "     }";
+    js += "}}}\n";
+#endif
+    js += "function procDivMS(e0, kind) {";
+    js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
+    js += " if (e1.nodeType == 1) {";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO') {";
+    js += "         procMSNode(e1, kind);";
+    js += "     }";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'DIV') {";
+    js += "         procDivMS(e1, kind);";
+    js += "     }";
+    js += "}}}\n";
+    return js;
+}
+std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
+    std::string js;
+    href = href + "&type=" + kMmtMediaCI;
+    js = "var div = document.createElement('div');";
+    js+= "div.innerHTML=\"<iframe id='"+id+"' width=10 height=10/>\";";
+    js+= "document.body.appendChild(div);";
+
+    js+= GetJSObject(id);
+    if (action == konRequest) {
+        js+= "document.onclick = function() {";
+        js+= SetJSAttr(id, "src", href);
+        js+= "}";
+    }else if (action == konLoad){
+        js+= SetJSAttr(id, "src", href);
+    }else { // auto load
+        js+= SetJSAttr(id, "src", href);
+    }
+    js+= "\n";
+    return js;
+}
+
+
+/**
+ * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
+ */
+int64 ParseTimeStr(std::string timestr) {
+    int64 ms = 0;
+    if (timestr == kevinf) {
+        return -1;
+    }
+
+#ifdef USE_NTP_TIME
+    base::Time time;
+    if(!base::Time::FromString(timestr.c_str(), &time))
+        return 0;
+    ms = (int64)time.ToJsTime(); //milliseconds
+#else
+    int64 sec = atoi(timestr.c_str());
+    std::string::size_type lpos, rpos;
+    lpos = timestr.find(":");
+    rpos = timestr.rfind(":");
+    if (lpos != std::string::npos) {
+        if (lpos != rpos) {
+            sec = sec * 3600;
+            sec = sec + 60 * atol(timestr.substr(lpos+1).c_str());
+            sec = sec + atol(timestr.substr(rpos+1).c_str());
+        }else {
+            sec = sec * 60;
+            sec = sec + atol(timestr.substr(lpos+1).c_str());
+        }
+    }
+    ms = sec * 1000;
+#endif
+    return ms;
+}
+
+} // namespace mmt
+
+
+namespace mmt {
+
+event_t::event_t() {
+    is_event = false;   // default is time
+    is_timeout = 0;     // default non-timeout, that will be processed next time
+    time = -1;          // default infinite
+}
+std::string event_t::str() {
+    std::string str;
+    std::stringstream ss;
+    ss << "@is_event=" << is_event;
+    ss << "@is_timeout=" << is_timeout;
+    ss << "@id=" << id;
+    ss << "@event=" << event;
+    ss << "@time=" << time;
+    ss >> str;
+    return str;
+}
+
+node_t::node_t(std::string name) 
+    : name(name), parent(nullptr) {
+}
+node_t::~node_t() {
+    nodes.clear();
+    parent = nullptr;
+}
+
+html_t::html_t() : node(nullptr), icss(0), iscreen(0) {
+}
+html_t::~html_t() {
+    js.clear();
+    node = nullptr;
+}
+
+
+CiParser::CiParser(const std::string& fname) 
+    : fname_(fname), root_(nullptr), cur_(nullptr) {
+    tabid_ = 0;
+    timestamp_ = 0;
+    ms_ = true;
+    multiple_ = false;
+}
+
+CiParser::~CiParser() {
+    root_ = nullptr;
+    cur_ = nullptr;
+}
+
+bool CiParser::ParseXml(bool ms) {
+    if (fname_.empty() && xmlstr_.empty()) return false;
+
+    ms_ = ms;
+    root_ = nullptr;
+    cur_ = nullptr;
+
+    xmlSAXHandler sax;
+    xmlParserCtxtPtr ctxt;
+
+    xmlSubstituteEntitiesDefault(1);
+    memset(&sax,'\0',sizeof(sax));
+    init_sax(&sax);
+
+    ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
+    ctxt->_private = (void *)this;
+
+    if (xmlstr_.empty()) {
+        StreamPtr stream = new Stream(fname_);
+        if (!stream->Init()) {
+            LOG(INFO) << __func__ << " fail to Init, fname=" << fname_;
+            return false;
+        }
+        if (stream->Prepare(nullptr) != 0) {
+            LOG(INFO) << __func__ << " fail to Prepare, fname=" << fname_;
+            return false;
+        }
+
+        int num = 0;
+        char buffer[4096];
+        memset(buffer, 0, sizeof(buffer));
+        while ((num=stream->Read(buffer,sizeof(buffer))) > 0) { 
+            xmlstr_ += std::string(buffer);
+            if (num < (int)sizeof(buffer)) break;
+            memset(buffer, 0, sizeof(buffer));
+        }
+    }
+    
+    bool isok = (0 == xmlParseChunk(ctxt,xmlstr_.c_str(),xmlstr_.size(),0));
+    xmlParseChunk(ctxt,NULL,0,1);
+    xmlFreeParserCtxt(ctxt);
+    LOG(INFO) << __func__ << " isok=" << isok
+        << " fname=" << fname_
+        << " xmlstr=" << xmlstr_.size();
+    return isok;
+}
+
+static std::string GetHtmlId(nodeptr_t node) {
+    if (!node) return "";
+    std::string id;
+    if (node->name == kdivLocation)     // div
+        id = node->attrs[krefDiv];
+    else if (node->name == kMediaSync)  // <audio><video><image>
+        id = node->attrs[krefId];
+    else if (node->name == kview) {
+        if (node->attrs.find(krefDiv) != node->attrs.end())
+            id = node->attrs[krefDiv];
+        else {
+            id = node->name;
+            if (node->attrs.find("id") != node->attrs.end())
+                id = node->attrs["id"];
+            id = kMmtDivIdPrefix + id + "_";
+            id = id + Int2String(GetLocalTime()%100000);
+            node->attrs[krefDiv] = id;
+        }
+    }
+    return id;
+}
+
+void CiParser::InitHtmlJS(nodeptr_t node, std::string role) {
+    std::string id = GetHtmlId(node);
+    if (id.empty()) return;
+
+    std::string css;            // for css style
+    std::string js0, js1;       // for time of begin and end
+    std::string js2;            // for event, e.g. onclick
+    std::string js3;            // for EHtmlClear
+    std::string js4, js5, js6, js7, js8;  // for EHtmlScreen, EHtmlScreenDyna, EHtmlScreenComp, EHtmlScreenPlin0/1
+
+    std::string style = node->attrs[kstyle];
+    js0 = js1 = js2 = js3 = "";
+    //js0 += SetJSDisplay(id, "block");
+    js2 += SetJSEventBegin(id, "onclick");
+    js2 += "domedia = 1;\n";
+    js3 += SetJSDisplay(id, "none");
+    if (!style.empty()) css = SetCSSStyle(id, style);
+
+    if (node->name == kview) {
+        js0 = js1 = js2 = js3 = "";
+        css = "";
+        for (auto& sub1 : node->nodes) {
+            std::string id2 = GetHtmlId(sub1);
+            if (id2.empty()) continue;
+            //js0 += SetJSDisplay(id2, "block");    // begin
+            //js0 += SetDivJSStatus(id2, "-1");     // begin
+            //js1 += SetDivJSStatus(id2, "-1");     // end
+            //js3 += SetJSDisplay(id2, "none");     // clear
+            js3 += SetDivJSClear(id2);              // clear 
+        }
+    }
+
+    if (node->name == kdivLocation) { // <area> node
+        // no-op for begin, but have op for end
+        js0 += SetDivJSPlay(id);
+        js1 += SetDivJSClear(id);
+
+        // process multiple screen
+        if (!role.empty()) {
+            std::string plout, plin, ipstr, port;
+            if (role == kdefault) {}
+            else if (role == kreceptiple) {}
+                auto iter_in = node->attrs.find(kplungeIn);
+                if (iter_in != node->attrs.end()) plin = iter_in->second;
+            else if (role == kmultiple) {
+                auto iter_out = node->attrs.find(kplungeOut);
+                if (iter_out != node->attrs.end()) plout = iter_out->second;
+
+#ifdef USE_CAST
+                auto iter_ip = node->attrs.find("ip");
+                if (iter_ip != node->attrs.end()) ipstr = iter_ip->second;
+                auto iter_port = node->attrs.find("port");
+                if (iter_port != node->attrs.end()) port = iter_port->second;
+#endif
+            }
+
+            LOG(INFO) << __func__ << " process mulitple screen, id=" << id
+                << " plout=" << plout << " plin=" << plin
+                << " ipstr=" << ipstr << " port=" << port;
+            if (plout == kdisable) {
+            }else if (plout == kcomplementary) {
+                js4 = SetCastStatus(id, ipstr, port, "compl");
+                js6 = SetMSStatus(id, "compl");
+            }else if (plout == ksharable) {
+                js4 = SetCastStatus(id, ipstr, port, "share");
+            }else if (plout == kdynamic) {
+                js4 = SetCastStatus(id, ipstr, port, "dynam");
+                js5 = SetMSStatus(id, "dynam");
+            }else if (plout == kuserselect) {
+            }else if (!plin.empty()) {
+                LOG(INFO) << __func__ << " set plin";
+                js7 = SetMSStatus(id, "plin0");
+                js8 = SetMSStatus(id, "plin1");
+            }
+        }
+    }
+
+    // set media src
+    if (node->name == kMediaSync) {
+        bool bfind = false;
+        // for <img>, <audio> <video>
+        for (auto& sub : node->nodes) {
+            if (sub->name != ksourceList) continue;
+            if (sub->attrs.find(kmediaSrc) == sub->attrs.end()) continue;
+            std::string src = GetMediaSrc(sub->attrs[kmediaSrc], id, tabid_);
+            if (src.empty()) continue;
+
+            js0 += SetJSAttr(id, "srcuri", src);
+            js1 += SetJSAttr(id, "srcuri", "");
+            bfind = true;
+            break;
+        }
+
+        if (!bfind) {
+            if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
+                std::string src = GetMediaSrc(node->attrs[kmediaSrc], id, tabid_);
+                if (!src.empty()) {
+                    js0 += SetJSAttr(id, "srcuri", src);
+                    js1 += SetJSAttr(id, "srcuri", "");
+                    bfind = true;
+                }
+            }
+        }
+
+        if (bfind) {
+            js0 += SetJSAttr(id, "mstate", "1");  // playing
+            js1 += SetJSAttr(id, "mstate", "0");  // pause
+        }
+    }
+
+    htmlptr_t html = new html_t;
+    html->node = node;
+    html->id = id;                    //> html tag id
+    html->js[EHtmlCSS] = css;         //> html css
+    html->js[EHtmlBegin] = js0;       //> self's begin
+    html->js[EHtmlEnd] = js1;         //> self's end
+    html->js[EHtmlClick] = js2;       //> other use this click.
+    html->js[EHtmlClear] = js3;
+    html->js[EHtmlScreen] = js4;
+    html->js[EHtmlScreenDyna] = js5;
+    html->js[EHtmlScreenComp] = js6;
+    html->js[EHtmlScreenPlin0] = js7;
+    html->js[EHtmlScreenPlin1] = js8;
+    htmls_[id] = html;
+}
+
+void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
+    if (!event.is_event || (event.event != kevbegin && event.event != kevend)) 
+        return;
+
+    event.is_event = false;
+    event.time = -1;
+    if (htmls_.find(event.id) != htmls_.end()) {
+        htmlptr_t html = htmls_[event.id];
+        //TODO: only support 1 level's event
+        if (event.event == kevbegin)
+            event.time = html->node->time.begin.time;
+        else
+            event.time = html->node->time.end.time; 
+    }
+}
+
+void CiParser::ProcEvent(htmlptr_t html, nodeptr_t node) {
+    event_t begin = node->time.begin;
+    if (begin.is_event) {
+        if (begin.event == kevclick) { // for event click
+            if (htmls_.find(begin.id) != htmls_.end()) {
+                if (node->name == kview) {
+                    for (auto& sub1 : node->nodes) {
+                        std::string id = GetHtmlId(sub1);
+                        if (htmls_.find(id) != htmls_.end()) {
+                            htmlptr_t html2 = htmls_[id];
+                            htmls_[begin.id]->js[EHtmlClick] += html2->js[EHtmlBegin];
+                        }
+                    }
+                }else {
+                    htmls_[begin.id]->js[EHtmlClick] += html->js[EHtmlBegin];
+                }
+            }
+        }else if (begin.event == kevbegin || begin.event == kevend) {
+            SetNodeTime(node->time.begin, node); // for event begin/end
+        }
+    }
+
+    event_t end = node->time.end;
+    if (end.is_event) {
+        if (end.event == kevclick) {
+            if (htmls_.find(end.id) != htmls_.end()) {
+                if (node->name == kview) {
+                    for (auto& sub1 : node->nodes) {
+                        std::string id = GetHtmlId(sub1);
+                        if (htmls_.find(id) != htmls_.end()) {
+                            htmlptr_t html2 = htmls_[id];
+                            htmls_[end.id]->js[EHtmlClick] += html2->js[EHtmlEnd];
+                        }
+                    }
+                }else {
+                    htmls_[end.id]->js[EHtmlClick] += html->js[EHtmlEnd];
+                }
+            }
+        }else if (end.event == kevbegin || end.event == kevend) {
+            SetNodeTime(node->time.end, node);
+        }
+    }
+}
+
+bool CiParser::ParseHtml() {
+    nodeptr_t node = root_;
+    if (!node) return false;
+    htmls_.clear();
+
+    // init html js
+    for (auto& sub1 : node->nodes) {
+        if (sub1->name == kview) {
+            std::string role = "";
+            auto iter_role = sub1->attrs.find(kviewRole);
+            if (iter_role != sub1->attrs.end()) role = iter_role->second;
+
+            // To create one new <div> for kview
+            InitHtmlJS(sub1);
+            
+            if (sub1->nodes.empty()) { // for subset xml nodes
+                std::string href, actuate;
+                if(sub1->attrs.find(kxlinkhref) != sub1->attrs.end()) {
+                    href = sub1->attrs[kxlinkhref];
+                }
+                if (sub1->attrs.find(kxlinkactuate) != sub1->attrs.end()) {
+                    actuate = sub1->attrs[kxlinkactuate];
+                }
+                if (actuate.empty()) actuate = konLoad;
+
+                if (href.empty() || actuate.empty()) continue;
+                htmlptr_t html = new html_t;
+                html->node = sub1;
+                std::string id = kMmtXmlIdPrefix + Int2String(GetLocalTime()%100000);
+                std::string xmllink = GetMediaSrc(href, id, tabid_);
+                html->js[EHtmlSubXml] = SetSubXmlJS(id, xmllink, actuate);
+                htmls_["html"] = html;
+            }else { // process multi-view here
+                if (role == kmultiple || role == kreceptiple) multiple_ = true;
+                for (auto& sub2 : sub1->nodes) {
+                    if (sub2->name == kdivLocation) {
+                        LOG(INFO) << __func__ << " process view's " << kdivLocation;
+                        InitHtmlJS(sub2, role);
+                    }
+                }
+            }
+        }else if (sub1->name == kdivLocation) { // krefDiv of <div>
+#ifdef MMT_LOG_V
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+#endif
+            InitHtmlJS(sub1);
+        }else if (sub1->name == kMediaSync) {   // krefId of <img>, <audio>, <video>
+#ifdef MMT_LOG_V
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+#endif
+            InitHtmlJS(sub1);
+        }
+    }
+
+
+    ///===================
+
+    // process end of time js
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        htmlptr_t html = iter.second;
+    }
+
+    // process interaction events: begin/end/click
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        ProcEvent(html, node);
+    }
+
+    // process end of event click, EHtmlClear
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        htmlptr_t html = iter.second;
+        html->js[EHtmlClick] += "domedia=0;";
+        html->js[EHtmlClick] += SetJSEventEnd();
+    }
+    return true;
+}
+
+void CiParser::PrintHtmlJS() {
+    htmlmap_t::iterator iter;
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
+        htmlptr_t html = iter->second;
+#ifdef MMT_LOG_V
+        LOG(INFO) << __func__ 
+            << " node=" << html->node->name 
+            << " id=" << html->id
+            << " time1=" << html->node->time.begin.str()
+            << " time2=" << html->node->time.end.str()
+            << " parent time1=" << html->node->parent->time.begin.str()
+            << " parent time2=" << html->node->parent->time.end.str();
+#endif
+#ifdef MMT_LOG_V
+        LOG(INFO) << __func__ 
+            << " css=" << html->js[EHtmlCSS]
+            << " begin=" << html->js[EHtmlBegin]
+            << " end=" << html->js[EHtmlEnd]
+            << " click=" << html->js[EHtmlClick]
+            << " clear=" << html->js[EHtmlClear];
+#endif
+    }
+}
+
+// merge ev2 into ev1
+void MergeEvent(event_t& ev1, event_t& ev2) {
+    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
+    if (ev1.is_event == ev2.is_event) {
+        // if no changes, set with previous timeout
+        if (!ev1.is_event && ev1.time == ev2.time)
+            ev1.is_timeout = ev2.is_timeout;
+        else if (ev1.is_event && ev1.id == ev2.id && ev1.event == ev2.event)
+            ev1.is_timeout = ev2.is_timeout;
+    }
+}
+// merge attrs2 into attrs1
+void MergeAttrs(attrs_t& attrs1, attrs_t& attrs2) {
+    for (auto& iter1 : attrs1) {
+        if (attrs2.find(iter1.first) == attrs2.end()) 
+            continue;
+        std::string value1 = iter1.second;
+        std::string value2 = attrs2[iter1.first];
+        if (value1 != value2) {
+            LOG(INFO) << __func__ << " key=" << iter1.first 
+                << " value1=" << value1 << " value2=" << value2;
+            attrs1[iter1.first] = value2;
+        } 
+    }
+}
+
+// merge node2 into node1
+bool MergeNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false; 
+
+    LOG(INFO) << __func__ << " update node name=" << node1->name;
+    //MergeAttrs(node1->attrs, node2->attrs);
+    MergeEvent(node1->time.begin, node2->time.begin);
+    MergeEvent(node1->time.end, node2->time.end);
+    return 0;
+}
+
+/**
+ * Check similar node
+ */
+bool IsSameNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false;
+
+    std::string id1, refId1, refDiv1;
+    if (node1->attrs.find("id") != node1->attrs.end())
+        id1 = node1->attrs["id"];
+    if (node1->attrs.find(krefId) != node1->attrs.end())
+        refId1 = node1->attrs[krefId];
+    if (node1->attrs.find(krefDiv) != node1->attrs.end())
+        refDiv1 = node1->attrs[krefDiv];
+
+    std::string id2, refId2, refDiv2;
+    if (node2->attrs.find("id") != node2->attrs.end())
+        id2 = node2->attrs["id"];
+    if (node2->attrs.find(krefId) != node2->attrs.end())
+        refId2 = node2->attrs[krefId];
+    if (node2->attrs.find(krefDiv) != node2->attrs.end())
+        refDiv2 = node2->attrs[krefDiv];
+
+    if (id1 != id2 || refId1 != refId2 || refDiv1 != refDiv2) return false;
+    return true;
+}
+
+/**
+ * find node2 from node1's subnodes
+ */
+nodeptr_t FindSubNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return nullptr;
+
+    for (auto& sub1 : node1->nodes) {
+        if (sub1->name == kview) {
+            for (auto& sub2 : sub1->nodes) {
+                if (IsSameNode(sub2, node2)) return sub2;
+            }
+        }
+        if (IsSameNode(sub1, node2)) return sub1;
+    }
+    return nullptr;
+}
+
+/**
+ *  Replace current<this>'s node status with one from old xml<@param parser>.
+ */
+bool CiParser::MergeCI(CiParser* parser) {
+    if (!root_ || !parser || !parser->root_) return false;
+    nodeptr_t node = root_;
+    nodeptr_t oldnode = parser->root_;
+
+    for (auto& sub1 : node->nodes) {
+        if (sub1->name == kview) {
+            for (auto& sub2 : sub1->nodes) {
+                nodeptr_t sub3 = FindSubNode(oldnode, sub2);
+                if (sub2 && sub3) MergeNode(sub2, sub3);
+            }
+        }
+        nodeptr_t sub2 = FindSubNode(oldnode, sub1);
+        if (sub1 && sub2) MergeNode(sub1, sub2);  // merge old into new
+    }
+
+    return true;
+}
+
+/**
+ *  add new node into current<this> from another xml(@param parser).
+ */
+bool CiParser::MergeCI2(CiParser* parser) {
+    if (!parser) return false;
+
+    nodeptr_t oldroot = parser->root_;
+    for (auto& iter : parser->htmls_) {
+        if (iter.first == "html") continue;
+        std::string id = iter.first;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        if (htmls_.find(id) == htmls_.end()) {
+            htmls_[id] = html;
+            do{
+                if (!node || !node->parent) break;
+                if (node->parent.get() == oldroot.get()) {
+                    node->parent = root_;
+                    break;
+                }
+                node = node->parent;
+            }while(true);
+        }
+    }
+    return true;
+}
+
+
+/**
+ * To process both @begin and @end
+ */
+int CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
+    ev = EHtmlNone;
+    if (!cnode) return -2;
+
+    event_t begin = cnode->time.begin;
+    if (begin.is_timeout > 0) return 1;
+
+    if (begin.event == kevclick) {
+        ev = EHtmlClick;
+        cnode->time.begin.is_timeout = 1;
+        return 0;
+    }else {
+        ev = EHtmlBegin;
+        curtime = begin.time;
+    }
+
+    // search cnode's parent
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.begin.is_event) {
+            if (node->time.begin.time >= 0 && node->time.begin.time > curtime)
+                curtime = node->time.begin.time;
+        }
+    }while(true);
+
+    LOG(INFO) << __func__ << " node name=" << begin.id << " curtime=" << curtime << " current=" << current;
+
+    if (curtime < 0 || curtime <= current) {
+        cnode->time.begin.is_timeout = 1;
+        return 0;
+    }
+    return -1;
+}
+
+int CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
+    if (!cnode) return -2;
+
+    event_t end = cnode->time.end;
+    if (end.is_timeout > 0) return 1;
+
+    if (end.event == kevclick) {
+        ev = EHtmlClick;
+        cnode->time.end.is_timeout = 1;
+        return 0;
+    }else {
+        ev = EHtmlEnd;
+        curtime = end.time;
+    }
+
+    // search cnode's parent and process it
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.end.is_event) {
+            if (node->time.end.time >= 0 && node->time.end.time <= curtime)
+                curtime = node->time.end.time;
+        }
+    }while(true);
+
+#ifdef MMT_LOG_V
+    LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
+#endif
+    if (curtime >= 0 && curtime <= current) {
+        cnode->time.end.is_timeout = 1;
+        return 0;
+    }
+    return -1;
+}
+
+/**
+ * TODO: try to split js to execute seperately to avoid failure.
+ */
+bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
+    js = "";
+    css = "";
+    if (htmls_.empty()) return false;
+
+    std::string js1, js2, js3;
+    std::string js_screen, js_screen2;
+
+    /// step1: add util function
+    js1 += SetJSUtils(); 
+    js1 += SetMediaJSUtils(); 
+    js1 += SetDivJSUtils(); 
+
+    /// step2: init js object
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        std::string id = iter.first;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        if (node->name == kview) { // create this extra div
+            //js1 += GetJSObject(id);
+            //js1 += CreateJSObject(id, "div");
+        }else {
+            js1 += GetJSObject(id);
+            if (node->name == kMediaSync) { // add new attr
+                js1 += AddJSAttr(id, "mstate", "0"); // 0 - uninit, 1 - playing, 2 - paused
+                js3 = ProcMediaJS(id) + js3;
+            }
+        }
+    }
+
+    /// step3: process screen event
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        std::string id = iter.first;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        if (html->iscreen <= 0) {
+#ifdef USE_CAST
+            js_screen += html->js[EHtmlScreen];
+#endif
+            if (ms_)
+                js_screen2 += html->js[EHtmlScreenComp];
+
+            if (ms_)
+                js_screen2 += html->js[EHtmlScreenPlin0];
+            else
+                js_screen2 += html->js[EHtmlScreenPlin1];
+            html->iscreen = 1;
+        }
+    }
+
+    /// step4: add js process(begin/end event), TODO: try to remove repeated scripts.
+    int ev;
+    std::map<std::string, int> jsmap;
+    std::vector<std::string> js2vec;
+    js2vec.resize(3);
+
+    // process end event
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        int index = 0;
+        if (node->name == kdivLocation) index = 1;
+        else if (node->name == kview) index = 2;
+
+        int iret = ShouldEndTime(current, node, ev);
+        if (iret == 0) {
+            if (ev == EHtmlClick)
+                html = htmls_[node->time.end.id];
+            if (html) {
+                std::string key = html->id+"@"+Int2String(ev,2);
+                if (jsmap.find(key) == jsmap.end()) {
+                    js2vec[index] += html->js[ev];
+                    jsmap[key] = 1;
+                }else {
+                    LOG(INFO) << __func__ << " begin exist, key=" << key;
+                }
+            }
+        }
+    }
+
+    // process begin event
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+
+        // for js2vec's key
+        int index = 0;
+        if (node->name == kdivLocation) index = 1;
+        else if (node->name == kview) index = 2;
+
+        int iret = ShouldBeginTime(current, node, ev);
+        if (iret >= -1 && html->icss <= 0) { // process css only once at frist
+            css += html->js[EHtmlCSS];
+            html->icss = 1;
+        }
+        if (iret == -1 || (iret == 0 && ev == EHtmlClick)) {
+            js2vec[index] += html->js[EHtmlClear];
+            //LOG(INFO) << __func__ << " set js clear=" << html->js[EHtmlClear];
+        }
+
+        if (iret == 0) {
+            if (ev == EHtmlClick)
+                html = htmls_[node->time.begin.id];
+            if (html) {
+                std::string key = html->id+"@"+Int2String(ev,2);
+                if (jsmap.find(key) == jsmap.end()) {
+                    js2vec[index] += html->js[ev];
+                    jsmap[key] = 1;
+                }else {
+                    LOG(INFO) << __func__ << " end exist, key=" << key;
+                }
+
+                // second screen
+                if (!ms_) {
+                    std::string plout, plin, role;
+                    if (node->name == kdivLocation) {
+                        auto iter_out = node->attrs.find(kplungeOut);
+                        if (iter_out != node->attrs.end()) plout = iter_out->second;
+                        auto iter_in = node->attrs.find(kplungeIn);
+                        if (iter_in != node->attrs.end()) plin = iter_in->second;
+                    }else if (node->name == kview) {
+                        auto iter_role = node->attrs.find(kviewRole);
+                        if (iter_role != node->attrs.end()) role = iter_role->second;
+                    }
+                    if (role.empty() && plout.empty() && plin.empty())  {
+                        js2vec[index] += html->js[EHtmlClear];
+                    }
+                }
+            }
+        }
+    }
+    js2 = js2vec[0] + js2vec[1] + js2vec[2];
+
+    if (!js2.empty() || !js_screen.empty()) {
+        js = js1 + js_screen + js2 + js_screen2 + js3;
+    }
+
+    return true;
+}
+
+std::string CiParser::GetHtmlClip(std::string id) {
+    LOG(INFO) << __func__ << " get tag id=" << id;
+    if (htmls_.find(id) == htmls_.end()) return "";
+    htmlptr_t html = htmls_[id];
+    nodeptr_t node = html->node;
+    if (!node) return "";
+
+    std::string clip;
+    std::string begin, end;
+
+    auto iter = node->attrs.find(kclipBegin);
+    if (iter != node->attrs.end()) {
+        begin = iter->second;
+    }
+    iter = node->attrs.find(kclipEnd);
+    if (iter != node->attrs.end()) {
+        end = iter->second;
+    }
+
+    if (!begin.empty() || !end.empty()) {
+        if (!begin.empty()) clip += begin;       
+        clip += "-";
+        if (!end.empty()) clip += end;
+    }else {
+        std::string list;
+        iter = node->attrs.find(kclipList);
+        if (iter != node->attrs.end()) {
+            list = iter->second;
+        }
+        if (!list.empty()) {
+            clip = list;
+        }
+    }
+    return clip;
+}
+
+bool CiParser::GetScreenJS(std::string& js) {
+    std::string js1, js2, js3;
+    js1 += SetJSUtils(); 
+    js1 += SetMediaJSUtils(); 
+    js1 += SetDivJSUtils(); 
+
+    /// step2: init js object
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        std::string id = iter.first;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        if (node->name == kview) { // create this extra div
+            //js1 += GetJSObject(id);
+            //js1 += CreateJSObject(id, "div");
+        }else {
+            js1 += GetJSObject(id);
+            if (node->name == kMediaSync) { // add new attr
+                js1 += AddJSAttr(id, "mstate", "0"); // 0 - uninit, 1 - playing, 2 - paused
+                js3 = ProcMediaJS(id) + js3;
+            }
+        }
+    }
+
+    for (auto& iter : htmls_) {
+        if (iter.first == "html") continue;
+        std::string id = iter.first;
+        htmlptr_t html = iter.second;
+        nodeptr_t node = html->node;
+        if (html->iscreen <= 1) {
+            js2 += html->js[EHtmlScreenDyna];
+            js2 += html->js[EHtmlScreenPlin1];
+            html->iscreen = 2;
+        }
+    }
+        
+    if (!js2.empty()) {
+        js = js1 + js2 + js3;
+    }
+
+    return true;
+}
+
+bool CiParser::GetSubXmlJS(int64 current, std::string& js) {
+    if(htmls_.find("html") == htmls_.end()) return false;
+    htmlptr_t html = htmls_["html"];
+    js = html->js[EHtmlSubXml];
+    html->js[EHtmlSubXml] = "";
+    return true;
+}
+
+bool CiParser::AddNode(std::string name) {
+#ifdef MMT_LOG_V
+    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+#endif
+    nodeptr_t node = new node_t(name);
+    if (!root_)  {
+        root_ = node;
+        cur_ = root_;
+        if (name != kCI) {
+            LOG(INFO) << __func__ << " invalid root node=" << name;
+        }
+        return true;
+    }
+
+    if (!cur_) return false; // the end of xml file
+    node->parent = cur_;
+    cur_->nodes.push_back(node);
+    cur_ = node;
+    return true;
+}
+
+bool CiParser::EndNode(std::string name) {
+    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
+    if (!cur_) return false;
+    if (name != cur_->name) {
+        LOG(INFO) << __func__ << " name=" << name;
+    }
+    cur_ = cur_->parent;
+    return true;
+}
+
+/**
+ * To parse the content of mmtci::begin or mmtci:end to event_t
+ */
+bool ParseTimeEvent(std::string value, event_t& event) {
+    // time's event
+    std::string::size_type pos;
+    do {
+        pos = value.find(kevclick);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevbegin);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevend);
+        if (pos != std::string::npos) break;
+    }while(false);
+
+    if (pos != std::string::npos) {
+        event.is_event = true;
+        event.id = value.substr(0, pos);
+        event.event = value.substr(pos);
+#ifdef MMT_LOG_V
+        LOG(INFO) << __func__ << " event.id=" << event.id << " event.event=" << event.event;
+#endif
+    }else {
+        event.is_event = false;
+        event.time = ParseTimeStr(value);
+#ifdef MMT_LOG_V
+        LOG(INFO) << __func__ << " event.time=" << event.time;
+#endif
+    }
+    return true;
+}
+
+bool CiParser::AddAttr(std::string name, std::string value) {
+    if (!cur_) return false;
+    cur_->attrs[name] = value;
+    if (name == kbegin || name == kend || name == kdur) {
+        //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+        //    << " attr: " << name << " => " << value;
+    }
+    if (name == kbegin) {
+        ParseTimeEvent(value, cur_->time.begin);
+    }else if (name == kend) {
+        ParseTimeEvent(value, cur_->time.end);
+    }else if (cur_->name == kCI) {
+        if (name == kversion) {
+            version_ = value;
+            LOG(INFO) << __func__ << " xml version=" << version_;
+        }else if (name == ktimestamp) {
+            timestamp_ = ParseTimeStr(value);
+            LOG(INFO) << __func__ << " xml timestamp=" << timestamp_ << " local=" << GetLocalTime();
+        }
+    }
+
+    return true;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
new file mode 100644
index 0000000..bb700aa
--- /dev/null
+++ b/net/mmt/mmt_parser.h
@@ -0,0 +1,202 @@
+#ifndef NET_MMT_MMT_PARSER_H_
+#define NET_MMT_MMT_PARSER_H_
+
+/**
+ * XML Parser for CI files which is based on libxml2.
+ */
+
+#include <map>
+#include <string>
+#include <vector>
+#include "base/memory/ref_counted.h"
+
+namespace mmt {
+
+struct node_t; // xml node
+typedef scoped_refptr<node_t> nodeptr_t;
+typedef std::vector<nodeptr_t> nodeptrs_t;
+typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name => value
+
+
+/**
+ * Event type for the value of mmtci:begin or mmtci:end
+ */
+enum EHtmlEvent{
+    EHtmlNone = 0,
+    EHtmlClear,
+    EHtmlCSS,
+    EHtmlBegin,         //> mmtci:begin
+    EHtmlEnd,           //> mmtci:end
+    EHtmlClick,
+    EHtmlSubXml,
+    EHtmlScreen,        //> multiple screen
+    EHtmlScreenDyna,    //> dynamic
+    EHtmlScreenComp,    //> complementary
+    EHtmlScreenPlin0,    //> plungeIn 0
+    EHtmlScreenPlin1,    //> plungeIn 1
+    EHtmlLast,
+    EHtmlAll
+};
+
+/**
+ * The value of mmtci:begin or mmtci:end
+ */
+struct event_t {
+    event_t();
+    std::string str();
+
+    bool is_event;      //> event or time
+    int is_timeout;     //> 0 if un-processed, non-0 if processed
+    std::string id;     //> event id
+    std::string event;  //> event type
+    int64 time;         //> ms, valid if id is empty
+};
+
+/**
+ * For node's time (begin/end)
+ */
+struct citime_t {
+    event_t begin;
+    event_t end;
+    event_t dur;
+};
+
+
+/**
+ * The structure for xml node
+ */
+struct node_t : public base::RefCounted<node_t>{
+public:
+    explicit node_t(std::string name);
+
+    std::string name;   //> node's name
+    attrs_t attrs;      //> node's attr
+    citime_t time;      //> for time range(begin/end/dur)
+
+    nodeptrs_t nodes;   //> sub nodes
+    nodeptr_t parent;   //> parent node
+
+protected:
+    friend class base::RefCounted<node_t>;
+    virtual ~node_t();
+};
+
+/**
+ * The xml node will be mapped to html's tag by [struct html_t].
+ */
+typedef std::map<int, std::string> jsmap_t; 
+struct html_t : public base::RefCounted<html_t>{
+public:
+    explicit html_t();
+    std::string id;     //> html tag id
+    jsmap_t js;         //> key/value: EHtmlEvent => js
+    nodeptr_t node;     //> xml node
+    int icss;           //> used count of css
+    int iscreen;        //> used count of screen
+
+protected:
+    friend class base::RefCounted<html_t>;
+    virtual ~html_t();
+};
+typedef scoped_refptr<html_t> htmlptr_t;
+typedef std::map<std::string, htmlptr_t> htmlmap_t; // key/value: html tag id => html_t
+
+
+/** 
+ * class for parsing xml  
+ */
+class CiParser : public base::RefCounted<CiParser> {
+public:
+    explicit CiParser(const std::string& fname);
+
+    /**
+     * To parse xml with libxml2 tools
+     * @param ms: is master screen? default master.
+     */
+    bool ParseXml(bool ms=true);
+    bool IsMultiple() {return multiple_;}
+
+    void SetXmlStr(const std::string& xmlstr) {xmlstr_ = xmlstr;}
+    std::string GetXmlStr() {return xmlstr_;}
+
+    /**
+     * To parse html tags based on parsed xml nodes.
+     *  So it should be called after ParseXml().
+     */
+    void SetTabId(int tabid) {tabid_=tabid;}
+    bool ParseHtml();
+    void PrintHtmlJS();
+
+    /**
+     * To Merge another parser
+     */
+    bool MergeCI(CiParser* parser);
+    bool MergeCI2(CiParser* parser);
+
+    /**
+     * To get current css/js to operate
+     *
+     * @param current[in]: current time(ms) (ntp or ntp diff)
+     * @param js[out]: returned js 
+     * @param css[out]: returned css 
+     * @return true if success.
+     */
+    bool GetHtmlJS(int64 current, std::string& js, std::string& css);
+    bool GetSubXmlJS(int64 current, std::string& js);
+
+    bool GetScreenJS(std::string& js);
+
+    /**
+     * Get Xml's timestamp and version.
+     */
+    int64 GetTimestamp() {return timestamp_;}
+    std::string GetVersion() {return version_;}
+
+    /**
+     * Get Html tag's clip info
+     */
+    std::string GetHtmlClip(std::string id);
+
+    /**
+     * To parse xml's node and its attr
+     */
+    bool AddNode(std::string name);
+    bool EndNode(std::string name);
+    bool AddAttr(std::string name, std::string value);
+
+protected:
+    void InitHtmlJS(nodeptr_t node, std::string role="");
+    void SetNodeTime(event_t& event, nodeptr_t node);
+    void ProcEvent(htmlptr_t html, nodeptr_t node);
+
+    /**
+     * @return: invalid node if -2, too early if -1, doing if 0, done if 1.
+     */
+    int ShouldBeginTime(int64 current, nodeptr_t node, int& ev);
+    int ShouldEndTime(int64 current, nodeptr_t node, int& ev);
+    
+protected:
+    friend class base::RefCounted<CiParser>;
+    virtual ~CiParser();
+
+private:
+    std::string fname_; //> xml file name
+    nodeptr_t root_;    //> xml's root node
+    nodeptr_t cur_;     //> only work for AddNode/AddAttr
+    htmlmap_t htmls_;   //> html tags
+
+    int tabid_;
+    std::string version_;
+    int64 timestamp_;
+
+    bool ms_;      //> main screen(default) or second screen
+    bool multiple_;
+    std::string xmlstr_;
+};
+typedef scoped_refptr<CiParser> CiParserPtr;
+
+
+} // namespace mmt
+
+
+#endif // NET_MMT_MMT_PARSER_H_
diff --git a/net/mmt/mmt_screen.cc b/net/mmt/mmt_screen.cc
new file mode 100644
index 0000000..87473ad
--- /dev/null
+++ b/net/mmt/mmt_screen.cc
@@ -0,0 +1,184 @@
+#include "net/mmt/mmt_screen.h"
+
+#include "net/mmt/mmt_inc.h"
+#include "net/mmt/mmt_packet.h"
+
+#include "base/sys_byteorder.h"
+#include <netinet/in.h>
+
+namespace mmt {
+
+ssres_t::ssres_t(){}
+
+Screen::Screen() {
+    thread_.reset(new base::Thread("Multi-screen Thread"));
+    base::Thread::Options options(base::MessageLoop::TYPE_IO, 0);
+    thread_->StartWithOptions(options);
+
+    port_ = 0;
+    sock_ = -1;
+    length_ = 1024*16;
+    buffer_.reset(new char[length_+1]);
+    sharing_ = false;
+}
+
+Screen::~Screen() {
+    thread_->Stop();
+    close(sock_);
+    sock_ = -1;
+}
+
+void Screen::Start(int port) {
+    assert_return(port > 0 && port < 65535);
+
+    sock_ = socket(AF_INET, SOCK_DGRAM, 0);
+    assert_return(sock_ > 0);
+
+    std::string szaddr = "0.0.0.0";
+    net::IPAddressNumber ipnum;
+    assert_return(net::ParseIPLiteralToNumber(szaddr, &ipnum));
+
+    struct sockaddr addr;
+    socklen_t addrlen = sizeof(addr);
+    net::IPEndPoint ip(ipnum, port);
+    assert_return(ip.ToSockAddr(&addr, &addrlen));
+
+    assert_return(!bind(sock_, &addr, addrlen));
+    port_ = port;
+
+    LOG(INFO) << __func__ << " listen for remote request: port=" << port;
+    thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&Screen::Run, base::Unretained(this)));
+}
+
+void Screen::Stop() {
+}
+
+void Screen::Run() {
+    ProcData();
+    thread_->message_loop_proxy()->PostTask(
+            FROM_HERE,
+            base::Bind(&Screen::Run, base::Unretained(this)));
+}
+
+void Screen::ProcData() {
+    fd_set rfds;
+    FD_ZERO(&rfds);
+    FD_SET(sock_, &rfds);
+    struct timeval tv = {10, 0};
+    int iret = select(sock_+1, &rfds, nullptr, nullptr, &tv);
+    if (iret == 0) return;
+
+    struct sockaddr raddr;
+    socklen_t addrlen = sizeof(raddr);
+    memset(buffer_.get(), 0, length_);
+    ms_packet_t* pkt = (ms_packet_t*)buffer_.get();
+
+    if (FD_ISSET(sock_, &rfds)) {
+        iret = recvfrom(sock_, buffer_.get(), length_, 0, &raddr, &addrlen);
+        if (iret <= 0) {
+            LOG(INFO) << __func__ << " fail to recvfrom, iret=" << iret;
+            return;
+        }
+
+        if (pkt->size + HEAD_SIZE != iret) {
+            LOG(INFO) << __func__ << " Invalid packet "
+                << " size=" << pkt->size
+                << " iret=" << iret;
+            return;
+        }
+
+        LOG(INFO) << __func__ << " recv msg type=" << pkt->type << " iret=" << iret;
+        switch(pkt->type) {
+        case E_MS_Request: {
+            int pktlen = 0;
+            if (!lres_.bcast.empty() && !lres_.ci.empty() && !lres_.html.empty()) {
+                pktlen = set_packet_ms_cihtml(buffer_.get(), 
+                    lres_.bcast.c_str(), lres_.ci.c_str(), lres_.html.c_str());
+
+                struct sockaddr_in* addr_in = reinterpret_cast<struct sockaddr_in*>(&raddr);
+                addr_in->sin_port = base::HostToNet16(port_);
+                iret = sendto(sock_, buffer_.get(), pktlen, 0, &raddr, addrlen);
+                sharing_ = true;
+                LOG(INFO) << __func__ 
+                    << " cilen=" << lres_.ci.size() 
+                    << " htmllen=" << lres_.html.size()
+                    << " bcast=" << lres_.bcast
+                    << " pktlen=" << pktlen << " iret=" << iret;
+            }
+            break;
+        }
+        case E_MS_CiHtml: {
+            std::string cihtml = pkt->body;
+            int cipos = cihtml.find("[ci]:");
+            assert_return(cipos != (int)std::string::npos);
+            int htmlpos = cihtml.find("[html]:");
+            assert_return(htmlpos != (int)std::string::npos);
+
+            int cilen, htmllen;
+            if (cipos < htmlpos) {
+                cilen = htmlpos - cipos;
+                htmllen = cihtml.size() - htmlpos;
+            }else {
+                htmllen = cipos - htmlpos;
+                cilen = cihtml.size() - cipos;
+            }
+            rres_.bcast = pkt->bcast;
+            rres_.ci = cihtml.substr(cipos+5, cilen-5);
+            rres_.html = cihtml.substr(htmlpos+7, htmllen-7);
+            LOG(INFO) << __func__ 
+                << " cilen=" << rres_.ci.size() 
+                << " htmllen=" << rres_.html.size()
+                << " bcast=" << rres_.bcast;
+            break;
+        }
+        }
+    }
+}
+
+void Screen::SetBcast(std::string ip, std::string port) {
+    LOG(INFO) << __func__ << " ip=" << ip << " port=" << port;
+    lres_.bcast = ip + ":" + port;
+}
+
+void Screen::SetHtml(std::string html) {
+    LOG(INFO) << __func__ << " html len=" << html.size();
+    lres_.html = html;
+}
+
+void Screen::SetCi(std::string ci) {
+    LOG(INFO) << __func__ << " ci len=" << ci.size();
+    lres_.ci = ci;
+}
+
+void Screen::SendMsg(std::string proto, std::string host, int port) {
+    int iret = 0;
+    char buffer[16*1024+1];
+    memset(buffer, 0, sizeof(buffer));
+    ms_packet_t* pkt = (ms_packet_t*)buffer;
+
+    if (proto == kMmtProtoMs0) { // share with remote
+        if (!lres_.bcast.empty() && !lres_.ci.empty() && !lres_.html.empty()) {
+            iret = set_packet_ms_cihtml(buffer, 
+                lres_.bcast.c_str(), lres_.ci.c_str(), lres_.html.c_str());
+            sharing_ = true;
+        }
+    }else if (proto == kMmtProtoMs1) { // request to share
+        iret = set_packet_ms_request(buffer);
+    }
+
+    LOG(INFO) << __func__
+        << " sharing=" << sharing_
+        << " proto=" << proto 
+        << " host=" << host 
+        << " port=" << port
+        << " size=" << pkt->size
+        << " iret=" << iret;
+    if (iret > 0) {
+        iret = SendToHost(buffer, iret, host, port);
+    }
+}
+
+
+} //namespace mmt
diff --git a/net/mmt/mmt_screen.h b/net/mmt/mmt_screen.h
new file mode 100644
index 0000000..a7015d0
--- /dev/null
+++ b/net/mmt/mmt_screen.h
@@ -0,0 +1,59 @@
+#ifndef NET_MMT_MMT_SCREEN_H_
+#define NET_MMT_MMT_SCREEN_H_
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/simple_thread.h"
+#include "base/threading/thread.h"
+
+namespace mmt {
+
+// screen share resouce
+typedef struct ssres_t {
+    ssres_t();
+    std::string bcast;
+    std::string ci;
+    std::string html;
+}ssres_t;
+
+class Screen : public base::RefCounted<Screen> {
+public:
+    Screen();
+
+    void Start(int port);
+    void Run();
+    void ProcData();
+    void Stop();
+
+    
+    void SetBcast(std::string ip, std::string port);
+    void SetCi(std::string ci);
+    void SetHtml(std::string html);
+    ssres_t GetRRes() {return rres_;}
+    bool IsSharing() {return sharing_;}
+
+    void SendMsg(std::string proto, std::string host, int port);
+
+protected:
+    virtual ~Screen();
+    friend class base::RefCounted<Screen>;
+
+private:
+    scoped_ptr<base::Thread> thread_;
+
+    int   port_;
+    int   sock_;
+    int   length_;
+    scoped_ptr<char> buffer_;
+
+    ssres_t lres_;  //> local resouces sharing for remote request
+    ssres_t rres_;  //> received remote resouces
+    bool sharing_;
+};
+typedef scoped_refptr<Screen> ScreenPtr;
+
+
+} // namespace mmt
+
+#endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
new file mode 100644
index 0000000..0cfe876
--- /dev/null
+++ b/net/mmt/mmt_stream.cc
@@ -0,0 +1,663 @@
+#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
+#include "net/mmt/mpu/mp4.h"
+#include "net/mmt/mmtp/mmtp.h"
+#include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_http.h"
+
+namespace mmt {
+
+static const long kMmtMediaSize = 0x7fffffff;
+static const char kMmtLocalAudioPrefix[] = "_Audio1_MPU_";
+static const char kMmtLocalVideoPrefix[] = "_Video1_MPU_";
+
+
+/**
+ * For mpu's stream io
+ */
+static void* mmtp_open(stream_t *s, const char* filename, int mode) {
+    return ((Stream*)s->opaque)->Open(filename, mode);
+}
+static int mmtp_read(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Read(buf, size);
+}
+static int mmtp_write(stream_t *s, void *buf, int size) {
+    return ((Stream*)s->opaque)->Write(buf, size);
+}
+static int mmtp_peek(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Peek(buf, size);
+}
+static uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
+    return ((Stream*)s->opaque)->Seek(offset, whence);
+}
+static uint64_t mmtp_tell(stream_t *s) {
+    return ((Stream*)s->opaque)->Tell();
+}
+static int mmtp_close(stream_t *s) {
+    return ((Stream*)s->opaque)->Close();
+}
+
+stream_t* InitMpuStream(Stream* ptr) {
+    stream_t* s = (stream_t*)malloc(sizeof(stream_t));
+    s->opaque = (void*)ptr;
+    s->open = mmtp_open;
+    s->read = mmtp_read;
+    s->write = mmtp_write;
+    s->peek = mmtp_peek;
+    s->seek = mmtp_seek;
+    s->tell = mmtp_tell;
+    s->close = mmtp_close;
+    return s;
+}
+
+} // namespace mmt
+
+
+namespace mmt {
+
+static MmtpStream* g_mmtp = new MmtpStream;
+
+void MmtpStart(const std::string ip, int port, const std::string mtype) {
+    g_mmtp->Start(ip, port, mtype);
+}
+void MmtpStop() {
+    if (g_mmtp) g_mmtp->Stop();
+}
+int MmtpPop(mmtp_info_t& mmtp) {
+    int iret = -1;
+    if (g_mmtp) iret = g_mmtp->Pop(mmtp);
+    return iret;
+}
+void MmtpPush(const mmtp_info_t& mmtp) {
+    if (g_mmtp) g_mmtp->Push(mmtp);
+}
+
+void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
+    if (!rinfo) return;
+
+    std::string mtype;
+    if(rinfo->res & Res_Signal) {
+#if 1   // for test
+        static bool _had_html = false;
+        static bool _had_ci = false;
+        if ((rinfo->res & Res_Html) && _had_html) return;
+        if ((rinfo->res & Res_CI) && _had_ci) return;
+        _had_html = (rinfo->res & Res_Html);
+        _had_ci = (rinfo->res & Res_CI);
+#endif
+        mtype = (rinfo->res & Res_Html) ? kMmtMediaHtml : kMmtMediaCI;
+    }else if (rinfo->res & Res_Media){
+        if (rinfo->res & Res_Audio)
+            mtype = kMmtMediaAudio;
+        else if (rinfo->res & Res_Video)
+            mtype = kMmtMediaVideo;
+        else
+            mtype = kMmtMediaImage;
+    }else {
+        return;
+    }
+
+    base::FilePath cpath(rinfo->fname);
+    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
+#ifdef MMT_LOG_V
+    LOG(INFO) << __func__ << " fname=" << rinfo->fname << 
+        " ftype=" << ftype << " fpath=" << fpath.value() << " seq=" << rinfo->index;
+#endif
+
+    mmtp_info_t mmtp;
+    mmtp.mtype = mtype;
+    mmtp.id = rinfo->id;
+    mmtp.url = rinfo->url;
+    mmtp.fname = kMmtDefaultUrl + fpath.value();
+    mmtp.index = rinfo->index;
+    MmtpPush(mmtp);
+}
+
+//=======================================
+
+mmtp_info_t::mmtp_info_t() {
+    index = -1;
+}
+mmtp_info_t::~mmtp_info_t() {
+}
+
+//=======================================
+
+mmtp_media_t::mmtp_media_t() {
+    first = true;
+}
+mmtp_media_t::~mmtp_media_t() {}
+
+//=======================================
+
+MmtpStream::MmtpStream(){
+    running_ = false;
+    audiostart_ = false;
+}
+MmtpStream::~MmtpStream(){
+}
+
+int MmtpStream::Pop(mmtp_info_t& mmtp) {
+    if (mlist_.empty()) return -1;
+
+    int iret = -1;
+    int index = mmtp.index;
+    std::string key = mmtp.id + "@" + mmtp.mtype;
+
+    do {
+        int isize = 0;
+        mmtp_media_ptr_t media;
+
+        lock_.Acquire();
+        auto iter = mlist_.find(key);
+        if (iter != mlist_.end()) {
+            media = iter->second;
+            isize = media->flist.size();
+        }
+        lock_.Release();
+
+        if (isize <= 0) break;
+
+#if 0
+        if (!audiostart_) {
+            if(mmtp.mtype == kMmtMediaVideo) {
+                LOG(INFO) << __func__ << " video isize=" << isize << " first=" << media->first;
+                if (media->first) {
+                    if (isize < 10) break;
+                    media->first = false;
+                }
+            }else if (mmtp.mtype == kMmtMediaAudio) {
+                LOG(INFO) << __func__ << " audio isize=" << isize;
+                audiostart_ = true;
+            }
+        }
+#endif
+
+        // To get the old media file, which will not be used next time
+        medialock_.Acquire();
+        mmtp = media->flist.front();
+        if (index < 0 || mmtp.index <= index) {
+            media->flist.pop();
+            //TODO: remove this file when done
+        }
+        medialock_.Release();
+
+        if (index < 0 || mmtp.index == index) {
+            iret = 0;   // found the sequence index
+        }else {
+            iret = 1;   // exists but not required this time
+        }
+    }while(false);
+    return iret;
+}
+
+void MmtpStream::Push(const mmtp_info_t& mmtp) {
+    mmtp_media_ptr_t media;
+    std::string key = mmtp.id + "@" + mmtp.mtype;
+
+    lock_.Acquire();
+    auto iter = mlist_.find(key);
+    if (iter != mlist_.end()) {
+        media = iter->second;
+    }else {
+        media = new mmtp_media_t;;
+        mlist_[key] = media;
+    }
+    lock_.Release();
+    if (!media) return;
+
+    medialock_.Acquire();
+    if (media->flist.size() >= 100) {
+        media->flist.pop();
+    }
+    media->flist.push(mmtp);
+    medialock_.Release();
+}
+
+void MmtpStream::Start(const std::string ip, int port, const std::string mtype) {
+    lock_.Acquire();
+    if (!running_) {
+        LOG(INFO) << "MmtpStream::Start";
+        init_mmtp();
+        set_mmtp_callback(MmtpRecvCallback);
+        set_mmtp_assets(NULL, NULL, 0);
+        start_mmtp(ip.c_str(), port);
+        running_ = true;
+    }
+    lock_.Release();
+}
+
+void MmtpStream::Stop() {
+    lock_.Acquire();
+    if (running_) {
+        LOG(INFO) << "MmtpStream::Stop";
+        stop_mmtp();
+        uninit_mmtp();
+        running_ = false;
+    }
+    lock_.Release();
+    audiostart_ = false;
+}
+
+} // namespace mmt
+
+
+namespace mmt {
+
+Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
+}
+
+Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
+}
+
+Stream::~Stream() {
+    if (proto_ == kMmtProtoMmtp) { 
+        // for mmt streaming
+        // MmtpStop();
+    }
+    Uninit();
+}
+
+bool Stream::ParseSequence() {
+    // if exists query in URL, then should redirect to real filename
+    std::string query = url_.query();
+    if (!query.empty()) { // media sequence
+        std::string mtype = GetQueryValue(query, "type");
+        std::string range = GetQueryValue(query, "sequence_num");
+        std::string proto = GetQueryValue(query, "proto");
+        std::string htmlid = GetQueryValue(query, kMmtHtmlId);
+        std::string tabid = GetQueryValue(query, "tabid");
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range 
+            << " proto=" << proto << " htmlid=" << htmlid << " tabid=" << tabid; 
+
+        //
+        // if "proto" is empty, it will use <local> file default.
+        // else process as below <multicast>.
+        //
+
+        //
+        // For multicast index html, which can be acquired by http:// or mmt://..?proto=http 
+        // here process like: mmt://apache-address/index.html?proto=http
+        if (proto == kMmtProtoHttp) {
+            if (mtype.empty()) mtype = kMmtMediaHtml; // default is html for mmtp
+        }
+
+        //
+        // (1) For multicast play html: mmt://224.1.1.101:6080?proto=mmtp[&type=html]
+        // (2) For multicast play media: mmt://asset_id1?proto=mmtp&type=audio/video/image
+        if (proto == kMmtProtoMmtp || proto == kMmtProtoMsMmtp || proto == kMmtProtoMsLocal) {
+            if (mtype.empty()) mtype = kMmtMediaHtml; // default is html for mmtp
+        }
+
+        //
+        // (3) For multicast subset xml, there are two ways: 
+        //      mmt://apache-address/subset.xml?proto=extra
+        //      mmt://apache-address/subset.xml?proto=http
+        // (4) For multicast main xml, it is got by mmtp receiver directly
+
+
+        //
+        // The value of "mtype" should not be empty.
+        // (1) For audio/video/image/subset ci, should have htmlid which is located in ci.xml
+        // (2) For html, it has no htmlid
+        if (mtype == kMmtMediaAudio || mtype == kMmtMediaVideo || 
+            mtype == kMmtMediaImage || mtype == kMmtMediaCI) { 
+            // for kMmtMediaCI, this CI is sub ci xml here, 
+            // and main ci is got by mmtp receiver in mmt_control.
+            if (htmlid.empty()) return false;
+        }else if (mtype == kMmtMediaHtml) {
+            // ..
+        }else if (proto == kMmtProtoMs || 
+                  proto == kMmtProtoMs0 || 
+                  proto == kMmtProtoMs1) {
+        }else {
+            LOG(INFO) << __func__ << " unsupported!";
+            return false;
+        }
+        if (!proto.empty()) proto_ = proto;
+        if (!mtype.empty()) mtype_ = mtype;
+        if (!tabid.empty()) tabid_ = String2Int(tabid);
+        if (!htmlid.empty()) htmlid_ = htmlid;
+
+        // compute the sequence of media and get current index
+        if (!range.empty()) {
+            if(!GetRangeValue(range, idxurl_)) return false;
+            LOG(INFO) << __func__ << " range begin=" << idxurl_.first << " end=" << idxurl_.second;
+        }
+    }
+    return true;
+}
+
+bool Stream::SetHtmlClip(std::string clip) {
+    LOG(INFO) << __func__ << " clip=" << clip;
+    if (!clip.empty()) {
+        idxclip_.clear();
+        if (!GetClipValue(clip, idxclip_)) {
+            LOG(INFO) << __func__ << " fail to parse clip=" << clip;
+            return false;
+        }
+    }
+    return true;
+}
+
+int Stream::Prepare(long *size) {
+    if (!Open(nullptr, 0)) return lasterr_;
+
+    //
+    // For audio/video, it contains many media sequences with unknown size.
+    // For other resouces, only one file/block with known size.
+    long lret = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
+        lret = kMmtMediaSize;
+    }else {
+        lret = offmap_[idxcur_.second].total; 
+    }
+    if (size)   *size = lret;
+    //LOG(INFO) << __func__ << " lret=" << lret;
+    return 0;
+}
+
+long Stream::ParseMpu(long& lret) {
+    // TODO: process image of mp4 here
+    // check moof box and other
+    stream_t* s = InitMpuStream(this);
+    mp4_box_t* root = MP4_BoxGetRoot(s);
+    if (!root) return -1;
+    mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+    if (!box0) return -1;
+
+    long offset = -1;
+    long ipos = -1; //get the pos of the 1st moof-box or idat-box
+    do {
+        mp4_box_t* box = nullptr;
+        if (mtype_ == kMmtMediaImage) {
+            box = MP4_BoxSearchBox(box0, ATOM_idat);
+            offset = 8;
+        }else {
+            box = MP4_BoxSearchBox(box0, ATOM_moof);
+            offset = 0;
+        }
+        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+        if (!box) break;
+        ipos = box->i_pos;
+
+        if (mtype_ != kMmtMediaImage) { // check mdat, assume only one moof and one mdat
+            box = MP4_BoxSearchBox(box, ATOM_mdat);
+            if (!box) break;
+            long pos1 = box->i_pos;
+            long size1 = box->i_size;
+            if (pos1 + size1 != lret) {
+                LOG(INFO) << __func__ << " invalid mdat, pos="<<pos1<<" size="<<size1<<" total="<<lret;
+#if 0 // one ugly way: fix media file data
+                uint32_t real = Swap32((uint32_t)(lret - pos1));
+                stream_seek(s, pos1, SEEK_SET);
+                stream_write(s, &real, 4);
+#else // another way: fix media file size
+                lret = pos1 + size1;
+#endif
+            }
+        }
+    }while(false);
+    MP4_BoxFree(s, root);
+    free(s);
+
+    if (ipos == -1) return -1;
+    offset += ipos;
+    return offset;
+}
+
+bool Stream::CheckIndex(int last, int& index) {
+    if (last < 0) { 
+        // It is not audio/video or Open audio/video at the first time
+
+        // Open the first media sequence
+        if (index < 0) index = idxurl_.first;
+
+        // If exists the property of "clip", should redirect to the first sequece by "clip".
+        if (!idxclip_.empty()) index = idxclip_[0].first;
+    }else {
+        // Open audio/video not the 1st time.
+
+        // Check the legal of the using sequence index
+        if (idxurl_.first >= 0 && idxurl_.first <= idxurl_.second) {
+            if (index < idxurl_.first || index > idxurl_.second) {
+                return false;
+            }
+        }
+
+        // If exists the "clip", location right section of the using index in "clip".
+        int pos = -1;
+        auto iter = idxclip_.begin();
+        for (int loop=0; iter != idxclip_.end(); iter++, loop++) {
+            if (last >= iter->first && last <= iter->second) {
+                pos = loop;
+            }
+        }
+
+        // Then redirect the using index to the right value.
+        if (pos >= 0) {
+            bool bok = false;
+            for (; pos < (int)idxclip_.size(); pos++) {
+                std::pair<int,int> item = idxclip_[pos];
+                if (index < item.first) {
+                    index = item.first;
+                    bok = true;
+                    break; 
+                }else if (index >= item.first && index <= item.second) {
+                    bok = true;
+                    break;
+                }
+            }
+            if (!bok) return false;
+        }
+    }
+
+    //
+    // if not audio/video or the audio/video index is right, 
+    // then return true
+    return true;
+}
+
+void* Stream::Open(const char* filename, int mode) {
+    lasterr_ = 0;
+    if (file_) return (void *)file_;
+
+    lasterr_ = -2;
+    if (!init_) return nullptr;
+
+    //
+    // For audio/video sequences, should check its sequence index.
+    LOG(INFO) << __func__ << " mtype=" << mtype_
+        << " min=" << idxurl_.first << " max=" << idxurl_.second
+        << " last=" << idxcur_.first << " next=" << idxcur_.second;
+    int index = idxcur_.second;
+    if(!CheckIndex(idxcur_.first, index)) {
+        LOG(INFO) << __func__ << " fail to CheckIndex";
+        return nullptr;
+    }
+    //LOG(INFO) << __func__ << " index=" << index;
+
+    std::string fname;
+    if (proto_ == kMmtProtoMmtp || proto_ == kMmtProtoMsMmtp) { 
+        // for mmt streaming
+        int port;
+        std::string host;
+        GURL2Address(url_, host, port);
+        // If has been started, have no-op
+        MmtpStart(host, port, mtype_);
+
+        mmtp_info_t mmtp;
+        mmtp.id = "";  // TODO: now do not support url in mmtp receiver.
+        mmtp.url = ""; 
+        mmtp.mtype = mtype_;
+
+        // find one available resource(html/audio/video), if not then waiting(-3)
+        do {
+            mmtp.index = index;
+            int ist = MmtpPop(mmtp);
+            if (ist < 0) {
+                lasterr_ = -3;
+                return nullptr;
+            }else if (ist == 0) { // success
+                break;
+            }else {
+                // (index >= 0) if (ist > 0), redirect to next sequence
+                idxcur_.first = idxcur_.second;
+                idxcur_.second++;
+                index = idxcur_.second;
+                if(!CheckIndex(idxcur_.first, index)) {
+                    return nullptr;
+                }
+            }
+        }while(true);
+        GURL url(mmtp.fname);
+        fname = GURL2FilePath(url);
+    }else if (proto_ == kMmtProtoLocal || proto_ == kMmtProtoMsLocal) { 
+        // for local media: audio/video/image/html/xml
+        std::string dname, bname;
+        fname = GURL2FilePath(url_, dname, bname);
+        if (mtype_ == kMmtMediaAudio) { 
+            bname = bname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4";
+            fname = fname + "/audio/" + bname;
+        }else if (mtype_ == kMmtMediaVideo) {
+            bname = bname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4";
+            fname = fname + "/video/" + bname;
+        }
+    }else if (proto_ == kMmtProtoHttp || proto_ == kMmtProtoExtra) {
+        // TODO: For kMmtProtoExtra which is desperated and replaced by kMmtProtoHttp
+        base::FilePath cpath;
+        base::GetCurrentDirectory(&cpath);
+        cpath = base::MakeAbsoluteFilePath(cpath);
+
+        std::string szpath = cpath.value() + "/.mmtdata";
+        base::FilePath fpath(szpath);
+        base::CreateDirectory(fpath);
+
+        fname = fpath.value() + "/http_" + Ptr2String(this) + ".dat";
+        HttpClientPtr http = new HttpClient("mmtp/1.0");
+        http->Get(url_, fname);
+    }else {
+        LOG(INFO) << __func__ << " invalid proto=" << proto_;
+        return nullptr;
+    }
+    //LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
+
+    // open and get file size for the 1st seq
+    file_ = fopen(fname.c_str(), "rb");
+    if (!file_) return nullptr;
+
+    // get file size
+    int ierr = fseek(file_, 0L, SEEK_END);
+    if (ierr != 0) return nullptr; 
+    long lret = ftell(file_);
+    ierr = fseek(file_, 0L, SEEK_SET);
+    if (ierr != 0) return nullptr; 
+
+    long total = lret;
+    long offset = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo || mtype_ == kMmtMediaImage) {
+        // For image and the first audio/video sequence, should parse the mpu data.
+        if (mtype_ == kMmtMediaImage || !first_) {
+            offset = ParseMpu(lret);
+            if (offset == -1) return nullptr;
+            ierr = fseek(file_, offset, SEEK_SET);
+            if (ierr != 0) return nullptr; 
+        }
+    }
+    offmap_[index] = offset_t(offset, total, lret);
+    if(first_) first_ = false;
+
+    LOG(INFO) << __func__ << " index=" << index << " fname=" << fname
+        << " off=" << offmap_[index].off << " total=" << offmap_[index].total << " required=" << lret;
+    idxcur_.second = index;
+    lasterr_ = 0;
+    return (void *)file_;
+}
+
+int Stream::Read(void *buf, int size) {
+    // If read EOF and closed last time, 
+    // then re-open the next valid media sequence for continue reading. 
+    if (!Open(nullptr, 0)) return lasterr_;
+
+    int iret = fread(buf, 1, size, file_);
+    if (iret < 0) iret = 0;
+    offset_t& off = offmap_[idxcur_.second];
+    off.off += iret;
+
+    // Read EOF 
+    if (iret < size && off.total < off.required) {
+        LOG(INFO) << __func__ << " fix mpu err, total=" << off.total << " required=" << off.required
+            << " off=" << off.off << " iret=" << iret;
+        int imin = std::min(int(off.required-off.off), size-iret);
+        if (imin > 0) {
+            iret += imin;
+            off.off += imin;
+        }
+    }
+
+    // Read EOF and close current file to prepare for next media sequence.
+    if (iret < size) { 
+        Close();
+        if (idxcur_.second >= 0) {
+            idxcur_.first = idxcur_.second;
+            idxcur_.second++;
+        }
+    }
+    return iret; 
+}
+
+int Stream::Write(void *buf, int size) {
+    return -1; // unsupported
+}
+
+int Stream::Peek(void *buf, int size) {
+    long offset = ftell(file_);
+    int iret = fread(buf, 1, size, file_);
+    fseek(file_, offset, SEEK_SET);
+    return iret;
+}
+
+uint64_t Stream::Seek(int64_t offset, int whence) {
+    return fseek(file_, offset, whence);
+}
+
+uint64_t Stream::Tell() {
+    return ftell(file_);
+}
+
+int Stream::Close() {
+    if (file_) fclose(file_);
+    file_ = nullptr;
+    return 0;
+}
+
+void Stream::Uninit() {
+    Close();
+}
+
+bool Stream::Init() {
+    lasterr_ = 0;
+    idxcur_.first = -1;     // last index
+    idxcur_.second = -1;    // current index
+    idxurl_.first = -1;
+    idxurl_.second = -1;
+
+    mtype_ = kMmtMediaHtml;     // default "html"
+    proto_ = kMmtProtoLocal;    // default "local"
+    htmlid_ = "";
+    tabid_ = -1;
+    first_ = true;
+    init_ = false;
+    firstwait_ = true;
+
+    init_ = ParseSequence();
+    return init_;
+}
+bool Stream::IsMmtMedia() { 
+    // These "mmt://.." which comes from ci.xml, 
+    // it have two features at least: htmlid=xx&type=xx.
+    return (!htmlid_.empty() && !mtype_.empty());
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
new file mode 100644
index 0000000..97c644b
--- /dev/null
+++ b/net/mmt/mmt_stream.h
@@ -0,0 +1,191 @@
+#ifndef NET_MMT_MMT_STREAM_H_
+#define NET_MMT_MMT_STREAM_H_
+
+#include <map>
+#include <string>
+#include <vector>
+#include <sstream>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
+
+#include "base/threading/thread_restrictions.h"
+#include "base/threading/simple_thread.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
+#include "url/gurl.h"
+
+
+namespace mmt {
+
+/**
+ * Mmtp media information
+ */
+struct mmtp_info_t {
+    mmtp_info_t();
+    ~mmtp_info_t();
+    std::string id;     //> asset id
+    std::string url;    //> asset url
+    std::string mtype;  //> "audio"/"video"/"image"/"ci"/"html" 
+    std::string fname;  //> asset media filename
+    int index;          //> sequence index
+};
+
+/**
+ * Mmtp media list
+ */
+struct mmtp_media_t : public base::RefCounted<mmtp_media_t>{
+    mmtp_media_t();
+    bool first;
+    std::queue<mmtp_info_t> flist;
+
+protected:
+    friend class base::RefCounted<mmtp_media_t>;
+    virtual ~mmtp_media_t();
+};
+typedef scoped_refptr<mmtp_media_t> mmtp_media_ptr_t;
+
+/**
+ * For mmtp receiver's resource: audio/video/image/
+ */
+class MmtpStream {
+public:
+    MmtpStream();
+    virtual ~MmtpStream();
+
+    /**
+     * @param mmtp: [in] should contain mtype and url, [out] return fname
+     */
+    int Pop(mmtp_info_t& mmtp);
+
+    /**
+     * @param mmtp: [in] should contain mtype, url and fname
+     */
+    void Push(const mmtp_info_t& mmtp);
+
+    /**
+     * for mmtp control
+     */
+    void Start(const std::string ip, int port, const std::string mtype);
+    void Stop();
+
+private:
+    bool running_;
+    base::Lock lock_;
+    base::Lock medialock_;
+    std::map<std::string, mmtp_media_ptr_t> mlist_; // id@mtype => ..
+    bool audiostart_;
+};
+
+/**
+ * The control of mmtp receiver
+ */
+void MmtpStart(const std::string ip, int port, const std::string mtype);
+void MmtpStop();
+int  MmtpPop(mmtp_info_t& mmtp);
+void MmtpPush(const mmtp_info_t& mmtp);
+
+
+
+//=========================================================
+
+/**
+ * stream read offset/size
+ */
+struct offset_t {
+    offset_t() : off(0), total(0), required(0) {}
+    offset_t(long off, long total, long required) : off(off), total(total), required(required) {}
+
+    long off;       //> offset of reading 
+    long total;     //> total size for current media index
+    long required;  //> required size
+};
+
+/**
+ * Stream IO interfaces
+ */
+class IStream {
+public:
+   virtual void*    Open(const char* filename, int mode) = 0;
+   virtual int      Read(void* buf, int size) = 0;
+   virtual int      Write(void *buf, int size) = 0;
+   virtual int      Peek(void* buf, int size) = 0;
+   virtual uint64_t Seek(int64_t offset, int whence) = 0;
+   virtual uint64_t Tell() = 0;
+   virtual int      Close() = 0;
+
+   virtual ~IStream() {}
+};
+
+/**
+ * Stream IO for both local file and mmtp receiver
+ */
+class Stream : public IStream, public base::RefCounted<Stream> {
+public:
+    virtual void*    Open(const char* fname, int mode) override;
+    virtual int      Read(void* buf, int size) override;
+    virtual int      Write(void *buf, int size) override;
+    virtual int      Peek(void* buf, int size) override;
+    virtual uint64_t Seek(int64_t offset, int whence) override;
+    virtual uint64_t Tell() override;
+    virtual int      Close() override;
+
+    explicit Stream(const GURL& url);
+    explicit Stream(const std::string& szurl);
+
+    /**
+     * if success, set size with the data length
+     */
+    int Prepare(long* size);
+
+    bool Init();
+    void Uninit();
+    bool IsMmtMedia();
+    long ParseMpu(long &lret);
+    bool ParseSequence();
+    bool CheckIndex(int last, int& index);
+
+    GURL& url() {return url_;}
+    std::string GetMtype() {return mtype_;}
+    std::string GetProto() {return proto_;}
+    std::string GetHtmlId() {return htmlid_;}
+    int GetTabId() {return tabid_;}
+    bool SetHtmlClip(std::string clip);
+
+    void SetFirstWait(bool wait) {firstwait_ = wait;}
+    bool GetFirstWait() {return firstwait_;}
+
+protected:
+    friend class base::RefCounted<Stream>;
+    virtual ~Stream();
+
+private:
+    GURL url_;
+    std::string mtype_;
+    std::string proto_;
+    std::string htmlid_;
+    int tabid_;
+
+    int lasterr_;
+    bool first_;
+    bool init_;
+
+    std::pair<int,int> idxcur_; //> last used and current using media index
+    std::pair<int,int> idxurl_; //> idx range from url
+    std::vector<std::pair<int,int> > idxclip_; // idx range from ci xml
+    std::map<int, offset_t> offmap_; //> read offset for current media index
+    FILE *file_;
+
+    bool firstwait_;
+
+    DISALLOW_COPY_AND_ASSIGN(Stream);
+};
+
+typedef scoped_refptr<Stream> StreamPtr;
+typedef std::map<std::string, StreamPtr> StreamPtrs_t;
+
+} // namespace mmt
+
+
+#endif
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
new file mode 100644
index 0000000..be89646
--- /dev/null
+++ b/net/mmt/mmt_utils.cc
@@ -0,0 +1,227 @@
+#include "net/mmt/mmt_inc.h"
+
+#include "net/mmt/ntp/ntpclient.h"
+
+namespace mmt {
+
+const char kMmtNtpServer[] = "time.apple.com";
+
+const char kMmtMediaAudio[] = "audio";
+const char kMmtMediaVideo[] = "video";
+const char kMmtMediaImage[] = "image";
+const char kMmtMediaHtml[] = "html";
+const char kMmtMediaCI[] = "ci";
+
+const char kMmtProtoMmtp[] = "mmtp";
+const char kMmtProtoLocal[] = "local";
+const char kMmtProtoExtra[] = "extra";
+const char kMmtProtoHttp[] = "http";
+
+const char kMmtProtoMs[] = "ms";
+const char kMmtProtoMsMmtp[] = "msmmtp";
+const char kMmtProtoMsLocal[] = "mslocal";
+const char kMmtProtoMs0[] = "ms0";
+const char kMmtProtoMs1[] = "ms1";
+const char kMmtDefaultUrl[] = "mmt://localhost";
+
+const char kMmtHtmlId[] = "htmlid";
+const char kMmtXmlIdPrefix[] = "id_subxml_";
+const char kMmtDivIdPrefix[] = "id_div_";
+
+const char kMmtTagCtrl[] = "@ctrl";
+const char kMmtTagOpen[] = "@open";
+const char kMmtTagRead[] = "@read";
+const char kMmtTagClose[] = "@close";
+const char kMmtTagCI[] = "@ci";
+
+const char kMmtTagTab[] = "@tab";
+const char kMmtTagCSS[] = "@css";
+const char kMmtTagJS[] = "@js";
+
+const int kMmtScreenPort = 9590;
+
+
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
+}
+
+std::string Int2String(int value, int width) {
+    std::string szval;
+    std::stringstream sstr;
+    if (width == 0)
+        sstr << value;
+    else
+        sstr << std::setfill('0') << std::setw(width)<< value;
+    sstr >> szval;
+    return szval;
+}
+
+std::string Ptr2String(void* ptr) {
+    std::string szval;
+    std::stringstream sstr;
+    sstr << ptr;
+    sstr >> szval;
+    return szval;
+}
+
+int String2Int(std::string value) {
+    int ival = -1;
+    std::stringstream sstr;
+    sstr << value;
+    sstr >> ival;
+    return ival;
+}
+
+std::string GURL2FilePath(GURL gurl) {
+    std::string szpath, dname, bname;
+    return GURL2FilePath(gurl, dname, bname);
+}
+std::string GURL2FilePath(GURL gurl, std::string& dname, std::string& bname) {
+    std::string szpath;
+    base::FilePath file_path;
+    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
+    if (is_file) {
+        szpath = file_path.value();
+        bname = file_path.BaseName().value();
+        dname = file_path.DirName().value();
+    }
+    return szpath;
+}
+
+void GURL2Address(const GURL& gurl, std::string& host, int& port) {
+    host = gurl.host();
+    port = String2Int(gurl.port());
+    if (port <= 0) port = 80;
+}
+
+std::string GetQueryValue(std::string query, std::string key) {
+    std::string value;
+    std::string::size_type begin, end;
+
+    key += "=";
+    begin = query.find(key);
+    if (begin != std::string::npos) {
+        begin += key.size();
+        end = query.find("&", begin);
+        if (end == std::string::npos)
+            end = query.size();
+        value = query.substr(begin, end-begin);
+    }
+    return value;
+}
+
+bool GetRangeValue(std::string range, std::pair<int,int>& item) {
+    if (range.empty()) return false;
+
+    bool bok = false;
+    std::string lstr = "0";
+    std::string rstr = "9999999";
+    int begin = range.find("-");
+    if (begin >= 0) { // two element
+        lstr = range.substr(0, begin);
+        if (lstr.empty()) lstr = "-1";
+        rstr = range.substr(begin+1, range.size()-begin);
+        if (rstr.empty()) rstr = "9999999";
+        bok = true;
+    }else { // one element
+        lstr = range;
+        rstr = range;
+        bok = true;
+    }
+    item.first = String2Int(lstr);
+    item.second = String2Int(rstr);
+    if (item.first < 0 || item.first > item.second) bok = false;
+    return bok;
+}
+
+bool GetClipValue(std::string clip, std::vector<std::pair<int,int> >& items) {
+    if (clip.empty()) return false;
+
+    bool bok = false;
+    do {
+        std::pair<int, int> item;
+        int pos = clip.find(",");
+        if (pos < 0) {
+            bok = GetRangeValue(clip, item);
+            clip = "";
+        }else {
+            bok = GetRangeValue(clip.substr(0, pos), item);
+            clip = clip.substr(pos+1);
+        }
+        if (bok)  items.push_back(item);
+    }while(!clip.empty() && bok);
+    return bok;
+}
+
+int SendToHost(std::string msg, std::string szaddr, int port) {
+    return SendToHost(msg.c_str(), msg.size(), szaddr, port);
+}
+
+int SendToHost(const char* data, int len, std::string szaddr, int port) {
+    if (!data || szaddr.empty() || port <= 0) 
+        return -1;
+
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return -1;
+    }
+    
+    int iret = -1;
+    do{
+        net::IPAddressNumber ipnum;
+        if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+            LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+            break;
+        }
+
+        struct sockaddr addr;
+        socklen_t addrlen = sizeof(addr);
+        net::IPEndPoint ip(ipnum, port);
+        if(!ip.ToSockAddr(&addr, &addrlen)) {
+            LOG(INFO) << __func__ << " ToSockAddr failed";
+            break;
+        }
+
+        iret = sendto(sock, data, len, 0, &addr, sizeof(struct sockaddr));
+    }while(0);
+
+    close(sock);
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    return iret;
+}
+
+int64 GetLocalTime() {
+    struct timeval tv;
+    memset(&tv, 0, sizeof(tv));
+    gettimeofday(&tv, NULL);
+    return tv.tv_sec*1000 + tv.tv_usec/1000;
+}
+
+int64 GetNTPTime() {
+    static int64 _lastntp = 0;   // ntp time
+    static int64 _last = 0;      // local tome
+
+    if (_lastntp == 0) {
+        struct ntp_time_t ntp_time;
+        memset(&ntp_time, 0, sizeof(ntp_time));
+        int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
+        _last = GetLocalTime();
+        if (iret == 0 && ntp_time.coarse >= JAN_1970_SEC)
+            _lastntp = (ntp_time.coarse-JAN_1970_SEC)*1000 + ntp_time.fine/4294967;
+        else
+            _lastntp = _last;
+        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last
+            << " iret=" << iret
+            << " coarse=" << ntp_time.coarse << " fine=" << ntp_time.fine;
+    }
+
+    int64 diff = GetLocalTime() - _last;
+#ifdef USE_NTP_TIME
+    return _lastntp + diff;
+#else
+    return diff;
+#endif
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmtp/DList.c b/net/mmt/mmtp/DList.c
new file mode 100644
index 0000000..594da25
--- /dev/null
+++ b/net/mmt/mmtp/DList.c
@@ -0,0 +1,276 @@
+#include"DList.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+Position MakeNode(const char* i)
+{
+	PNode p = NULL;
+	p = (PNode)malloc(sizeof(Node));
+	p->data=(unsigned char *)malloc(1500*sizeof(unsigned char));
+	//memset((void*)p->data,0,1500);
+	if(p!=NULL)
+	{
+		//p->data = i;
+		memcpy((void*)p->data , &i[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void FreeNode(PNode p)
+{
+	 free(p);
+}
+/**/
+DList * InitList()
+{
+	DList *plist = (DList *)malloc(sizeof(DList));
+	PNode head = MakeNode("");
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void DestroyList(DList *plist)
+{
+	ClearList(plist);
+	free(GetHead(plist));
+	free(plist);
+}
+
+/**/
+int IsEmpty(DList *plist)
+{
+	if(GetSize(plist)==0&&GetTail(plist)==GetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void ClearList(DList *plist)
+{
+	PNode temp,p;
+	p = GetTail(plist);
+	while(!IsEmpty(plist))
+	{
+		temp = GetPrevious(p);
+		free(p->data);
+		FreeNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+Position GetHead(DList *plist)
+{
+	return plist->head;
+}
+
+/**/
+Position GetTail(DList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int GetSize(DList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+Position GetNext(Position p)
+{
+	return p->next;
+}
+
+/*p*/
+Position GetPrevious(Position p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode)
+{
+	Position head = GetHead(plist);
+
+	if(IsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+PNode DelFirst(DList *plist)
+{
+	Position head = GetHead(plist);
+
+	Position p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->data);
+
+	}
+	return p;
+}
+/*,,*/
+PNode DelFirst2(DList *plist)
+{
+	Position head = GetHead(plist);
+	Position p=head->next;
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* GetItem(Position p)
+{
+	return p->data;
+}
+
+/**/
+void SetItem(Position p,unsigned char* i)
+{
+	p->data = i;
+}
+
+/**/
+PNode Remove(DList *plist)
+{
+	Position p=NULL;
+	if(IsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = GetTail(plist);
+		free(p->data);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int RemovePnext(DList *plist,Position p)
+{
+	Position q=p->next;
+	if(IsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->data);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+PNode InsBefore(DList *plist,Position p,PNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == GetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+PNode LocatePos(DList *plist,int i)
+{
+	int cnt = 0;
+	Position p = GetHead(plist);
+	if(i>GetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)())
+{
+	Position p = GetHead(plist);
+	if(IsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->data);
+		}
+	}
+}
diff --git a/net/mmt/mmtp/DList.h b/net/mmt/mmtp/DList.h
new file mode 100644
index 0000000..0ad67ef
--- /dev/null
+++ b/net/mmt/mmtp/DList.h
@@ -0,0 +1,84 @@
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+#ifndef NET_MMT_MMTP_DLIST_H_
+#define NET_MMT_MMTP_DLIST_H_
+
+#include <string.h>
+
+typedef struct Node * PNode;
+typedef PNode Position;
+/**/
+typedef struct Node
+{
+	unsigned char * data;		/**/
+	PNode previous; /**/
+	PNode next;		/**/
+}Node;
+/**/
+typedef struct
+{
+	PNode head;		/**/
+	PNode tail;		/**/
+	volatile int size;
+}DList;
+
+/*i*/
+Position MakeNode(const char * i);
+
+/*p*/
+void FreeNode(PNode p);
+
+/**/
+DList* InitList();
+
+/**/
+void DestroyList(DList *plist);
+
+/**/
+void ClearList(DList *plist);
+
+/**/
+Position GetHead(DList *plist);
+
+/**/
+Position GetTail(DList *plist);
+
+/**/
+int GetSize(DList *plist);
+
+/*p*/
+Position GetNext(Position p);
+
+/*p*/
+Position GetPrevious(Position p);
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode);
+
+/**/
+PNode DelFirst(DList *plist);
+
+/**/
+unsigned char * GetItem(Position p);
+
+/**/
+void SetItem(Position p,unsigned char * i);
+
+/**/
+PNode Remove(DList *plist);
+
+/*P*/
+int RemovePnext(DList *plist,Position p);
+
+/*pS*/
+PNode InsBefore(DList *plist,Position p,PNode s);
+
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s);
+
+/*i*/
+PNode LocatePos(DList *plist,int i);
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)());
+
+#endif
diff --git a/net/mmt/mmtp/Makefile b/net/mmt/mmtp/Makefile
new file mode 100644
index 0000000..42b634a
--- /dev/null
+++ b/net/mmt/mmtp/Makefile
@@ -0,0 +1,21 @@
+TARGET = client
+OBJS = DList.o Mlist.o client.o getfile.o ini.o mmt.o ringq.o send.o mkdir.o mmtp.o ../mpu/stream.o ../mpu/mp4.o
+CFLAGS = -I../../../ -D_TEST
+LDFLAGS = -lm -lpthread
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mmtp/Mlist.c b/net/mmt/mmtp/Mlist.c
new file mode 100644
index 0000000..c8f0085
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.c
@@ -0,0 +1,280 @@
+#include "Mlist.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf)
+{
+	mPNode p = NULL;
+	p = (mPNode)malloc(sizeof(mNode));
+	p->mpu_buf=(mpu_buf_t*)malloc(1500*sizeof(unsigned char));
+	memset((void*)p->mpu_buf,0,1500);
+	if(p!=NULL)
+	{
+		//p->mpu_buf = i;
+		memcpy((void*)p->mpu_buf , &mpu_buf[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void mFreemNode(mPNode p)
+{
+	 free(p);
+}
+/**/
+MPUList * mInitList()
+{
+    mpu_buf_t tmpu;
+	MPUList *plist = (MPUList *)malloc(sizeof(MPUList));
+    memset(&tmpu, 0, sizeof(tmpu));
+	mPNode head = mMakeNode(&tmpu);
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void mDestroyList(MPUList *plist)
+{
+	mClearList(plist);
+	free(mGetHead(plist));
+	free(plist);
+}
+
+/**/
+int mIsEmpty(MPUList *plist)
+{
+	if(mGetSize(plist)==0&&mGetTail(plist)==mGetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void mClearList(MPUList *plist)
+{
+	mPNode temp,p;
+	p = mGetTail(plist);
+	while(!mIsEmpty(plist))
+	{
+		temp = mGetPrevious(p);
+		free(p->mpu_buf);
+		mFreemNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+mPosition mGetHead(MPUList *plist)
+{
+	return plist->head;
+}
+
+/**/
+mPosition mGetTail(MPUList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int mGetSize(MPUList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+mPosition mGetNext(mPosition p)
+{
+	return p->next;
+}
+
+/*p*/
+mPosition mGetPrevious(mPosition p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode pnode)
+{
+	mPosition head = mGetHead(plist);
+
+	if(mIsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+mPNode mDelFirst(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+
+	mPosition p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->mpu_buf);
+
+	}
+	return p;
+}
+/*,,*/
+mPNode mDelFirst2(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+	mPosition p=head->next;
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* mGetItem(mPosition p)
+{
+	return (unsigned char*)p->mpu_buf;
+}
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf)
+{
+	p->mpu_buf = mpu_buf;
+}
+
+/**/
+mPNode mRemove(MPUList *plist)
+{
+	mPosition p=NULL;
+	if(mIsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = mGetTail(plist);
+		free(p->mpu_buf);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p)
+{
+	mPosition q=p->next;
+	if(mIsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->mpu_buf);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == mGetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i)
+{
+	int cnt = 0;
+	mPosition p = mGetHead(plist);
+	if(i>mGetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)())
+{
+	mPosition p = mGetHead(plist);
+	if(mIsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->mpu_buf);
+		}
+	}
+}
+
+
diff --git a/net/mmt/mmtp/Mlist.h b/net/mmt/mmtp/Mlist.h
new file mode 100644
index 0000000..89d5028
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.h
@@ -0,0 +1,85 @@
+#ifndef NET_MMT_MMTP_MLIST_H_
+#define NET_MMT_MMTP_MLIST_H_
+
+#include "mmt.h"
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+
+typedef struct mNode * mPNode;
+typedef mPNode mPosition;
+/**/
+typedef struct mNode
+{
+	mpu_buf_t *mpu_buf;		/**/
+	mPNode previous; /**/
+	mPNode next;		/**/
+}mNode;
+/**/
+typedef struct
+{
+	mPNode head;		/**/
+	mPNode tail;		/**/
+	int size;
+}MPUList;
+
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf);
+
+/*p*/
+void mFreemNode(mPNode mp);
+
+/**/
+MPUList* mInitList();
+
+/**/
+void mDestroyList(MPUList *plist);
+
+/**/
+void mClearList(MPUList *plist);
+
+/**/
+mPosition mGetHead(MPUList *plist);
+
+/**/
+mPosition mGetTail(MPUList *plist);
+
+/**/
+int mGetSize(MPUList *plist);
+
+/*p*/
+mPosition mGetNext(mPosition p);
+
+/*p*/
+mPosition mGetPrevious(mPosition p);
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode mpnode);
+
+/**/
+mPNode mDelFirst(MPUList *plist);
+
+/**/
+unsigned char * mGetItem(mPosition p);
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf);
+
+/**/
+mPNode mRemove(MPUList *plist);
+
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p);
+
+/*pS*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode ms);
+
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode ms);
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i);
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)());
+
+#endif
+
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
new file mode 100644
index 0000000..563e4b5
--- /dev/null
+++ b/net/mmt/mmtp/client.c
@@ -0,0 +1,1070 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#include <signal.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <sched.h>
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "mkdir.h"
+#include "send.h"
+#include "ringq.h"
+#include "DList.h"
+#include "mmtp.h"
+
+
+//#define MCAST_PORT 6080
+//#define MCAST_ADDR "224.1.1.101"
+
+int MCAST_PORT;
+char MCAST_ADDR[64];
+
+extern void sig_proccess(int signo);
+extern void sig_pipe(int signo);
+
+void make_file(char *mpu_name, char *data, int len );
+int check_mpu_iscomplete(mpu_buf_t mpu_buf);
+
+void *producter_f (mmt_socket_t *mmt_socket);					/**/
+void *mpu_consumer_f (void *arg);					/**/
+void *signal_consumer_f (void *arg);					/**/
+int signal_buffer_has_item=0;							/**/
+int mpu_buffer_has_item=0;							/**/
+
+pthread_mutex_t mpu_mutex;							/**/
+pthread_mutex_t signal_mutex;							/**/
+
+pa_message_t pa_message;  //MPU,
+pthread_mutex_t message_mutex;							/**/
+int message_counter=0;
+
+int g_running = 1;								/**/
+mmt_socket_t  g_mmt_socket;
+
+
+int g_pktid_init = -1;
+int g_asset_num = 0;
+char g_asset_ids[MAX_ASSET_NUM][260];
+char g_asset_clips[MAX_ASSET_NUM][260];
+int g_pktid_asset[MAX_ID_NUM]; // pktid => g_asset_ids
+
+
+DList *signal_buff_list = NULL;
+DList *mpu_buff_list = NULL;
+mpu_buf_t mpu_buf;
+
+#define BUFF_LEN 1500
+#define CLOSESOCKET(fd) if(fd > 0){close(fd);fd=-1;}
+
+
+void sig_proccess(int signo)
+{
+	printf("catch a exit signal\n");
+	CLOSESOCKET(g_mmt_socket.ss);
+	exit(0);
+}
+
+void  sig_pipe(int signo)
+{
+	printf("catch a SIGPIPE signal\n");
+	CLOSESOCKET(g_mmt_socket.ss);
+	exit(0);
+}
+
+#ifdef _TEST
+int main(int argc, char *argv[])
+{
+    init_mmtp();
+
+    const char* ids[] = {"loveapartment_audio", "loveapartment_video"};
+    const char* clips[] = {"1-100", ""};
+    set_mmtp_assets(ids, clips, 2);
+
+    start_mmtp("224.1.1.101",6080);
+	while(1)
+		sleep(1);
+    stop_mmtp();
+    uninit_mmtp();
+
+    return 0;
+}
+#endif
+
+void *producter_f (mmt_socket_t *mmt_socket)					/**/
+{
+
+	int n;
+	char buff[BUFF_LEN];
+	socklen_t len;//x
+	PNode p = NULL;
+
+	int lastpacket,last_flag=1;
+	while(g_running)								/**/
+	{
+		len=sizeof(mmt_socket->addr);
+		n=recvfrom(mmt_socket->ss,buff,BUFF_LEN,0,(struct sockaddr *)&mmt_socket->addr,&len);
+		if(n <=0)
+		{
+			perror("recv error");
+			fprintf(stderr, "%s \n", strerror(errno));
+//			printf("stderr:[%s]\n",stderr);
+            break;
+		}
+
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		read_mmtp_header(&mmt_header,buff);
+
+
+
+//		printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+//		FILE *log;
+//		if((log=fopen("log.txt","a+"))==NULL)
+//			{
+//				printf("not open3");
+//				exit(0);
+//			}
+//		printf("not open2");
+//		fprintf(log," %d \n", mmt_header.packet_counter);
+//		fclose(log);
+
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag!=0)
+		{
+			printf("lastpacket:%d,  mmt_header.packet_counter%d, loss %d\n",lastpacket,mmt_header.packet_counter,mmt_header.packet_counter-lastpacket);
+			puts ("packet loss");
+//			exit (EXIT_FAILURE);
+		}
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag==0)
+		{
+			puts ("packet loss");
+			//exit (EXIT_FAILURE);
+            break;
+		}
+		lastpacket=mmt_header.packet_counter;
+		last_flag--;
+//		continue;
+		if(mmt_header.type==2)
+		{
+			Position node = MakeNode(buff);
+
+			pthread_mutex_lock (&signal_mutex);			/**/
+			//5000
+			p=GetTail(signal_buff_list);
+			InsAfter(signal_buff_list,p,node);
+//			printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+//			printf("%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(signal_buff_list));
+//			signal_buffer_has_item++;						/**/
+//			printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&signal_mutex);			/**/
+		}
+
+		if(mmt_header.type==0) 
+		{
+            if (g_pktid_init < 0) {
+                printf("g_pktid_init < 0\n");
+                continue;
+            }
+
+            int packet_id = mmt_header.packet_id;
+            if (packet_id < 0 || g_pktid_asset[packet_id] < 0) {
+                printf ("packet_id < 0 or no asset\n");
+                continue;
+            }
+
+			Position node = MakeNode(buff);
+
+			pthread_mutex_lock (&mpu_mutex);			/**/
+			//5000
+			if(GetSize(mpu_buff_list)==5000)
+			{
+				//
+				free(DelFirst(mpu_buff_list));
+				mpu_buffer_has_item--;						/**/
+//				printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			}
+			p=GetTail(mpu_buff_list);
+			InsAfter(mpu_buff_list,p,node);
+			p = p->next;
+			read_mmtp_header(&mmt_header,buff);
+
+			read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//			printf("recieve mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number);
+//			printf("mpu%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(mpu_buff_list));
+			mpu_buffer_has_item++;						/**/
+//			printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&mpu_mutex);			/**/
+		}
+	}
+
+//	err = setsockopt(g_sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
+//	CLOSESOCKET(g_sock);
+    return NULL;
+}
+
+void *signal_consumer_f(void *arg)						/**/
+{
+	PNode p = NULL;
+	unsigned char *signal_buf;
+	u_int32_t signal_seekpoint=0;
+	int signal_size = 0;
+	unsigned char buff[BUFF_LEN];
+
+	while(g_running)								/**/
+	{
+		//pthread_mutex_lock(&signal_mutex);				/**/
+		signal_size = GetSize(signal_buff_list);
+		//pthread_mutex_unlock(&signal_mutex);				/**/
+		if (signal_size <= 0) {
+			usleep(1000*100);
+			continue;
+		}
+
+		if(signal_size >= 5000)
+		{
+			pthread_mutex_lock(&signal_mutex);
+			//
+			free(DelFirst(signal_buff_list));
+	//				signal_buffer_has_item--;						/**/
+	//				printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&signal_mutex);
+			continue;
+		}
+
+		p=GetHead(signal_buff_list);
+		p=p->next;
+		memcpy(buff,p->data,BUFF_LEN);
+
+		//signal
+		mmt_packet_header_t mmt_header;
+		read_mmtp_header(&mmt_header,(const char*)buff);
+		if(mmt_header.type==2)
+		{
+			signal_header_t signal_header;
+			read_signal_header(&signal_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+			if(signal_header.f_i==0)
+			{
+					;
+			}
+			if(signal_header.f_i==1)
+			{
+				if(signal_header.H==0)
+				{
+					//need realize 32 bit signal head later on
+					read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+					signal_buf= (unsigned  char*) malloc((pa_message.length+PAh_BUFF_LEN)*sizeof( unsigned  char));
+					if(signal_buf==NULL)
+					{
+							puts ("Memory allocation failed.");
+							 exit (EXIT_FAILURE);
+					}
+//						printf("init mem\n");
+//						printf("pa_message.length%d\n",pa_message.length);
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+					signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+				}
+				if(signal_header.H==1)
+				{
+					read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+					signal_buf= (unsigned  char*) malloc((pa_message.length)*sizeof( unsigned  char));
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length2);
+					signal_seekpoint=signal_seekpoint+signal_header.MSG_length2;
+				}
+			}
+			if(signal_header.f_i==2)
+			{
+				memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+				signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+			}
+			if(signal_header.f_i==3)
+			{
+//					printf("signal_header.f_i==3\n");
+//					printf("seekpoint%d\n",signal_seekpoint);
+//					printf("signal_header.MSG_length1%d\n",signal_header.MSG_length1);
+				memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+				signal_seekpoint=0;
+				//if PA message
+//					if(&pa_message != NULL)
+//					free_pa_message(&pa_message);
+				
+                if (g_pktid_init < 0) 
+                { 
+                    pthread_mutex_lock(&message_mutex);				/**/
+                    if (message_counter==0)
+                    {
+                        read_pa_message(&pa_message,(const char*)&signal_buf[0]);
+						message_counter=1;
+
+                        MP_table_asset_t* assets = pa_message.mp_table.MP_table_asset;
+                        int num = pa_message.mp_table.number_of_assets;
+                        if (assets && num > 0) {
+                            int k;
+                            const char* asset_ids[] = {"loveapartment_audio", "loveapartment_video"};
+                            for (k=0; k < num; k++) {
+                            #if 1
+                                assets[k].asset_id = asset_ids[k];
+                                assets[k].packet_id = k;
+                            #endif
+
+                                char* asset_id = assets[k].asset_id;
+                                int packet_id = assets[k].packet_id;
+                                if (!asset_id || packet_id < 0) continue;
+
+                                int pos;
+                                for (pos=0; pos < g_asset_num; pos++) {
+                                    if (strcmp(g_asset_ids[pos], asset_id) == 0) {
+                                        g_pktid_asset[packet_id] = pos; // you can get asset id from g_asset_ids[pos]
+                                        printf ("find asset:%s - pktid=%d - pos=%d\n", asset_id, packet_id, pos);
+                                    }
+                                }
+                            }
+                            g_pktid_init = 0;
+                            printf ("g_pktid_init OK\n");
+                        }
+                    }
+				    pthread_mutex_unlock(&message_mutex);				/**/
+				}
+//					printf("finished recive signal\n");
+
+				if(signal_buf != NULL)
+				{
+					free(signal_buf);
+					signal_buf=NULL;
+//						printf("free signal_buf\n");
+				}
+				int i;
+				for (i=0;i<pa_message.mpi_table.PI_content_count;i++)
+				{
+                    char pfname[260];
+                    snprintf(pfname, 260, "%s/%s", MMTP_CACHE,
+                        (char *)pa_message.mpi_table.PI_content[i].PI_content_name_byte);
+					make_file(pfname,(char*)pa_message.mpi_table.PI_content[i].PI_content_byte,
+                        pa_message.mpi_table.PI_content[i].PI_content_length);
+					printf("finished recive a ci - %d - %s\n", i, 
+                        (const char *)pa_message.mpi_table.PI_content[i].PI_content_name_byte);
+
+                    int res = Res_Html;
+                    if (strstr(pfname, ".xml")) res = Res_CI;
+					push_mmtp_cihtml(res, pfname);
+				}
+				//
+				pthread_mutex_lock(&message_mutex);				/**/
+				if (message_counter==1)
+				{
+						free_pa_message(&pa_message);
+						message_counter=0;
+				}
+				pthread_mutex_unlock(&message_mutex);				/**/
+			}
+
+		}
+		//
+		pthread_mutex_lock(&signal_mutex);
+		free(DelFirst(signal_buff_list));
+		//signal_buffer_has_item--;						/**/
+//			printf(":%d\n",signal_buffer_has_item);	/**/
+		pthread_mutex_unlock(&signal_mutex);			/**/
+		usleep(1000);
+	}
+    return NULL;
+}
+
+void *mpu_consumer_f(void *arg)						/**/
+{
+	PNode p = NULL;
+	init_mpu_buf(&mpu_buf);
+	unsigned char buff[BUFF_LEN];
+
+	while(g_running)								/**/
+	{
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		mfu_time_packet_header_t mfu_time_header;
+		usleep(100);
+
+//		printf("1111mpu:%d\n",mpu_buffer_has_item); 	/**/
+		if(GetSize(mpu_buff_list)>0)
+		{
+			pthread_mutex_lock(&mpu_mutex);				/**/
+			p=GetHead(mpu_buff_list);
+			p=p->next;
+			memcpy(buff,p->data,BUFF_LEN);
+			free(DelFirst(mpu_buff_list));
+			pthread_mutex_unlock(&mpu_mutex);			/**/
+
+			read_mmtp_header(&mmt_header,(const char*)buff);
+			read_mpu_header(&mpu_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+			read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+		}else {
+			usleep(1000*100);
+			continue;
+		}
+
+			if(1)
+			{
+	//			mpu metadata
+				if(mpu_header.FT==0)
+				{
+					if(mpu_header.f_i==0)
+					{
+						mpu_buf.packet_id=mmt_header.packet_id;
+						mpu_buf.MPU_sequence_number=mpu_header.MPU_sequence_number;
+						mpu_buf.mpu_metadata_buf.data = (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+						if(mpu_buf.mpu_metadata_buf.data==NULL)
+						{
+							puts ("1Memory allocation failed.");
+							exit (EXIT_FAILURE);
+						}
+
+						memcpy(&mpu_buf.mpu_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+						mpu_buf.mpu_metadata_buf.length=mpu_header.length-6;
+						mpu_buf.mpu_metadata_buf.flag=1;
+						mpu_buf.mpu_metadata_buf.counter=1;
+					}
+					if(mpu_header.f_i==1)
+					{
+							;
+					}
+					if(mpu_header.f_i==2)
+					{
+							;
+					}
+					if(mpu_header.f_i==3)
+					{
+							;
+					}
+				}
+				//fragment metadata
+				if(mpu_header.FT==1&&mpu_buf.mpu_metadata_buf.flag==1)
+				{
+
+					if(mpu_header.f_i==0)
+					{
+						mpu_buf.fragment_metadata_buf.data= (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+						if(mpu_buf.fragment_metadata_buf.data==NULL)
+						{
+							printf("mpu_header.length:%d\n",mpu_header.length);
+							puts ("2Memory allocation failed.");
+							exit (EXIT_FAILURE);
+						}
+						memcpy(&mpu_buf.fragment_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+						mpu_buf.fragment_metadata_buf.length=mpu_header.length-6;
+						mpu_buf.fragment_metadata_buf.flag=1;
+						mpu_buf.fragment_metadata_buf.counter=1;
+
+						//analysis fragmentdata,and decide recieve how many sample
+						mpu_buf.mfu_number=ntohl(*((u_int32_t*)&mpu_buf.fragment_metadata_buf.data[76]));;
+
+						mpu_buf.mfu= (mfu_buf_t *)malloc(sizeof(mfu_buf_t)*mpu_buf.mfu_number);
+						if(mpu_buf.mfu==NULL)
+						{
+							puts ("mpu_buf.mfu Memory allocation failed.");
+							exit (EXIT_FAILURE);
+						}
+						mpu_buf.mfu_sample= (mfu_sample_t *)malloc(sizeof(mfu_sample_t)*mpu_buf.mfu_number);
+						if(mpu_buf.mfu_sample==NULL)
+						{
+							puts ("mfu_sample Memory allocation failed.");
+							exit (EXIT_FAILURE);
+						}
+						//mfu sample
+						int i;
+						for(i=0;i<mpu_buf.mfu_number;i++)
+						{
+							mpu_buf.mfu_sample[i].sequence_number=0;
+							mpu_buf.mfu_sample[i].trackrefindex=0;
+							mpu_buf.mfu_sample[i].movie_fragment_sequence_number=0;
+							mpu_buf.mfu_sample[i].sample_number=0;
+							mpu_buf.mfu_sample[i].priority=0;
+							mpu_buf.mfu_sample[i].dependency_counter=0;
+							mpu_buf.mfu_sample[i].offset=0;
+							mpu_buf.mfu_sample[i].length=0;
+							mpu_buf.mfu_sample[i].muli_length=11;
+							mpu_buf.mfu_sample[i].muli_name=ATOM_muli;
+							mpu_buf.mfu_sample[i].muli_reserved1=0;
+							mpu_buf.mfu_sample[i].muli_reserved2=0;
+
+						}
+
+						//mfu
+
+						for(i=0;i<mpu_buf.mfu_number;i++)
+						{
+							mpu_buf.mfu[i].data= (unsigned  char*) malloc(1500000);
+							if(mpu_buf.mfu[i].data==NULL)
+							{
+								puts ("3Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+							memset(mpu_buf.mfu[i].data,0,1500000);
+							mpu_buf.mfu[i].flag=0;
+							mpu_buf.mfu[i].length=0;
+							mpu_buf.mfu[i].number=0;
+							mpu_buf.mfu[i].counter=0;
+
+						}
+
+					}
+					if(mpu_header.f_i==1)
+					{
+						;
+					}
+					if(mpu_header.f_i==2)
+					{
+						;
+					}
+					if(mpu_header.f_i==3)
+					{
+						;
+					}
+
+				}
+	//			mfu_seekpoint=0;
+				//MFU
+				if(mpu_header.FT==2&&mpu_buf.mpu_metadata_buf.flag==1&&mpu_buf.fragment_metadata_buf.flag==1)
+				{
+					mfu_time_packet_header_t mfu_time_header;
+					read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+//			printf("process 		mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d ,mfu_time_header.sample_number: %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number,mfu_time_header.sample_number);
+
+						if(mpu_header.f_i==0)
+						{
+
+							memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+							mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_header.length-6-MFUh_t_BUFF_LEN;
+							mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+							mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+							mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+							(mpu_buf.mfu_counter)++;
+
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+							if(mfu_time_header.sample_number==0)
+							{
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+							}
+							else
+							{
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+							}
+
+
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+
+
+
+							if(mfu_time_header.sample_number==mpu_buf.mfu_number-1)//LAST MFU
+							{
+								int mpu_seek=0;
+								int i;
+								mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+										mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+										mpu_buf.mfu_number*34;
+
+//								printf("mpu_buf.MPU_sequence_length audio:%d\n",mpu_buf.MPU_sequence_length);
+
+								mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+								if(mpu_buf.MPU_sequence_data==NULL)
+								{
+									puts ("4MPU_sequence_data Memory allocation failed.");
+									exit (EXIT_FAILURE);
+								}
+
+								memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+								memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+									mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+								}
+								char mfu_sample_buff[34];
+
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+									mpu_seek=mpu_seek+34;
+								}
+
+								pthread_mutex_lock(&message_mutex);				/**/
+								if (message_counter==1)
+								{
+									;
+								}
+								//PA message
+								pthread_mutex_unlock(&message_mutex);				/**/
+
+//								char res_dir[100]="./res/";
+//								char mpu_name[100];
+//								char mpu_type[100];
+//								char mpu_dir[100];
+//								sprintf(mpu_name, "lovepartment");
+//								if(mpu_buf.packet_id==0)
+//								{
+//								sprintf(mpu_type, "audio");
+//								}
+//								if(mpu_buf.packet_id==1)
+//								{
+//								sprintf(mpu_type, "video");
+//								}
+//								sprintf(mpu_dir, "%s%s/%s/",res_dir,mpu_name,mpu_type);
+//								sprintf(mpu_name, "%.4d.mp4",mpu_buf.MPU_sequence_number);
+//								make_file((char*)mpu_name,mpu_dir,(char*)mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length);
+//								printf("finished recive a audio mpu :%d\n",mpu_buf.MPU_sequence_number);
+                                
+                                int pos = g_pktid_asset[mpu_buf.packet_id];
+								printf("finished recive a audio mpu :%d - %d - assetpos=%d\n",
+                                    mpu_buf.MPU_sequence_number, mpu_buf.packet_id, pos);
+                                if (pos >= 0 && pos < g_asset_num) {
+								    char mpu_name[260];
+								    snprintf(mpu_name, 260, "%s/%s_%.4d.mp4",
+                                        MMTP_CACHE, g_asset_ids[pos], mpu_buf.MPU_sequence_number);
+                                    make_file((char*)mpu_name,(char*)mpu_buf.MPU_sequence_data,
+                                        mpu_buf.MPU_sequence_length);
+
+                                    int res = Res_Image;
+                                    if (mpu_buf.packet_id==0) res = Res_Audio;
+                                    else if (mpu_buf.packet_id==1) res = Res_Video;
+                                    push_mmtp_media(res, g_asset_ids[pos], "", mpu_name, mpu_buf.MPU_sequence_number);
+                                }
+
+								free_mpu_buf(&mpu_buf );
+								init_mpu_buf(&mpu_buf );
+
+
+							}
+
+						}
+						if(mpu_header.f_i==1)
+						{
+
+							memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+							mpu_buf.mfu[mfu_time_header.sample_number].length=(mpu_header.length-6-MFUh_t_BUFF_LEN);
+							mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+							mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+
+//								printf("expect mpu_header.fragment_counter%d\n",mpu_header.fragment_counter);
+						}
+						if(mpu_header.f_i==2)
+						{
+
+							memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+							mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+							mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+							(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+						}
+						if(mpu_header.f_i==3)
+						{
+
+							memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+							mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+							mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+							(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+							if (mpu_buf.mfu[mfu_time_header.sample_number].counter==mpu_header.fragment_counter)
+							{
+								mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+							}
+							(mpu_buf.mfu_counter)++;
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+//								printf("expect %d ,finished %d ,mfu_counter %d\n",mpu_header.fragment_counter,mpu_buf.mfu[mfu_time_header.sample_number].counter,mpu_buf.mfu_counter);
+
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+							if(mfu_time_header.sample_number==0)
+							{
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+							}
+							else
+							{
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+							}
+//								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_seekpoint;
+
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+							mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+//							printf("mpu_buf.mfu_sample[mfu_time_header.sample_number].offset:%d+mpu_buf.mfu[mfu_time_header.sample_number].length%d,mpu_buf.mfu_number%d\n",mpu_buf.mfu_sample[mfu_time_header.sample_number].offset,mpu_buf.mfu[mfu_time_header.sample_number].length,mfu_time_header.sample_number);
+//							if(check_mpu_iscomplete(mpu_buf))
+//								{}
+								//printf("uncomplete\n");
+//								printf("length:%d,offset:%d\n",mpu_buf.mfu_sample[mfu_time_header.sample_number].length,mpu_buf.mfu_sample[mfu_time_header.sample_number].offset);
+							//MPU
+							if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter==mpu_buf.mfu_number)
+							{
+								int mpu_seek=0;
+								int i;
+								mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+										mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+										mpu_buf.mfu_number*34;
+
+								mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+								if(mpu_buf.MPU_sequence_data==NULL)
+								{
+									puts ("5Memory allocation failed.");
+									exit (EXIT_FAILURE);
+								}
+
+								memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+								memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+									mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+								}
+								char mfu_sample_buff[34];
+
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+									mpu_seek=mpu_seek+34;
+								}
+
+								mpu_buf.flag=1 ;
+
+
+
+								pthread_mutex_lock(&message_mutex);				/**/
+								if (message_counter==1)
+								{
+										free_pa_message(&pa_message);
+										message_counter=0;
+								}
+								//PA message
+								pthread_mutex_unlock(&message_mutex);				/**/
+
+                                int pos = g_pktid_asset[mpu_buf.packet_id];
+								printf("finished recive a vido mpu :%d - %d - assetpos=%d\n",
+                                    mpu_buf.MPU_sequence_number, mpu_buf.packet_id, pos);
+
+                                if (pos >= 0 && pos < g_asset_num) {
+								    char mpu_name[260];
+								    snprintf(mpu_name, 260, "%s/%s_%.4d.mp4",
+                                        MMTP_CACHE, g_asset_ids[pos], mpu_buf.MPU_sequence_number);
+								    make_file((char*)mpu_name,(char*)mpu_buf.MPU_sequence_data,
+                                        mpu_buf.MPU_sequence_length);
+
+                                    int res = Res_Image;
+                                    if (mpu_buf.packet_id==0) res = Res_Audio;
+                                    else if (mpu_buf.packet_id==1) res = Res_Video;
+                                    push_mmtp_media(res, g_asset_ids[pos], "", mpu_name, mpu_buf.MPU_sequence_number);
+                                }
+
+								free_mpu_buf(&mpu_buf );
+								init_mpu_buf(&mpu_buf );
+							}
+							//,,
+							if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter!=mpu_buf.mfu_number)
+							{
+#if 0//									printf("mpu_buf.MPU_sequence_number%d\n",mpu_buf.MPU_sequence_number);
+//									printf("mpu_buf.mfu_counter%d, mpu_buf.mfu_number%d\n",mpu_buf.mfu_counter,mpu_buf.mfu_number);
+
+								int mpu_seek=0;
+								int i;
+								mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+										mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+										mpu_buf.mfu_number*34;
+//									printf("				mpu_buf.MPU_sequence_length:%d\n",mpu_buf.MPU_sequence_length);
+								mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+								if(mpu_buf.MPU_sequence_data==NULL)
+								{
+									printf("mpu_buf.mfu_sample[mfu_time_header.sample_number].offset:%d+mpu_buf.mfu[mfu_time_header.sample_number].length%d,mpu_buf.mfu_number%d\n",mpu_buf.mfu_sample[mfu_time_header.sample_number].offset,mpu_buf.mfu[mfu_time_header.sample_number].length,mpu_buf.mfu_number);
+									printf("mpu_buf.mpu_metadata_buf.length:%d+mpu_buf.fragment_metadata_buf.length%d\n",mpu_buf.mpu_metadata_buf.length,mpu_buf.fragment_metadata_buf.length);
+									printf("mpu_buf.MPU_sequence_length%d\n",mpu_buf.MPU_sequence_length);
+									puts ("6Memory allocation failed.");
+									exit (EXIT_FAILURE);
+								}
+
+								memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+								memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+								mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek+mpu_buf.mfu_sample[i].offset-8] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+								}
+								mpu_seek=mpu_seek+mpu_buf.mfu_sample[mpu_buf.mfu_number-1].offset-8+mpu_buf.mfu[mpu_buf.mfu_number-1].length;
+								char mfu_sample_buff[34];
+
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+									mpu_seek=mpu_seek+34;
+								}
+
+
+								pthread_mutex_lock(&message_mutex);				/**/
+								if (message_counter==1)
+								{
+										free_pa_message(&pa_message);
+										message_counter=0;
+								}
+								//PA message
+								pthread_mutex_unlock(&message_mutex);				/**/
+
+#endif
+								free_mpu_metadata_buf(mpu_buf.mpu_metadata_buf);
+								free_fragment_metadata_buf(mpu_buf.fragment_metadata_buf);
+								int i;
+								for(i=0;i<mpu_buf.mfu_number;i++)
+								{
+									free(mpu_buf.mfu[i].data);
+								}
+								free(mpu_buf.mfu);
+								free(mpu_buf.mfu_sample);
+								//free_mpu_buf(&mpu_buf );
+								init_mpu_buf(&mpu_buf );
+							}
+						}
+//						}//RECIVE MFU
+				}//MFU end
+			}//MPU END
+	}//WHILE END
+    return NULL;
+}//FUCTION END
+
+
+void open_sock_chrome(){
+
+	;
+}
+void process_sock_chrome(){
+
+	;
+}
+void stop_sock_chrome(){
+
+	;
+}
+
+void start_sock(char *addr, u_int16_t port,mmt_socket_t * mmt_socket){
+	//
+		int ss;
+
+		struct sockaddr_in* local_addr = (struct sockaddr_in*)&(mmt_socket->addr);
+		int err=-1;
+	//	pid_t pid;
+		//sigint
+		signal(SIGINT,sig_proccess);
+		signal(SIGPIPE,sig_pipe);
+
+		//s
+		ss=socket(AF_INET, SOCK_DGRAM,0);
+		if(ss<0)
+		{
+			printf("socket error\n");
+		}
+
+	//	//
+		bzero(local_addr,sizeof(*local_addr));
+		local_addr->sin_family=AF_INET;
+		local_addr->sin_addr.s_addr=htonl(INADDR_ANY);
+		local_addr->sin_port =htons(port);
+		//bzero(&(local_addr.sin_zero),8);
+
+		//
+		err=bind(ss,(struct sockaddr*)local_addr,sizeof(struct sockaddr_in));
+		//printf("ready for listening");
+		if(err<0)
+		{
+			printf("bind error \n");
+		}
+		printf("ready for listening\n");
+
+		/**/
+		int loop = 1 ;
+		err = setsockopt(ss, IPPROTO_IP, IP_MULTICAST_LOOP,&loop, sizeof(loop));
+		if(err ==-1)
+		{
+			printf("setsockopt failed:setsockopt():IP_MULTICAST_LOOP\n");
+		}
+
+		/**/
+		struct ip_mreq mreq;
+		mreq.imr_multiaddr.s_addr = inet_addr(addr); /**/
+		mreq.imr_interface.s_addr = htonl(INADDR_ANY); /**/
+
+		/**/
+		err = setsockopt(ss, IPPROTO_IP, IP_ADD_MEMBERSHIP,&mreq, sizeof(mreq));
+		if (err < 0)
+		{
+			printf("setsockopt():IP_ADD_MEMBERSHIP");
+		}
+
+		/*
+		 * 
+		 */
+		int rcv_size=0;//64K
+		socklen_t optlen;    /*  */
+		optlen = sizeof(rcv_size);
+		if(getsockopt(ss, SOL_SOCKET, SO_RCVBUF,&rcv_size, &optlen)<0)
+		{
+			printf("\n");
+			exit(2);
+		}
+		printf(" : %d \n",rcv_size);
+		rcv_size=6400*1024;//64K
+		if (setsockopt(ss,SOL_SOCKET,SO_RCVBUF,(const char*)&rcv_size,sizeof(int)) < 0)
+		{
+			 printf("fail to change SNDbuf.\n");
+			 exit(2);
+		 }
+		 /*
+			 * 
+			 * 
+			 */
+		if(getsockopt(ss, SOL_SOCKET, SO_RCVBUF,&rcv_size, &optlen)<0)
+		{
+			printf("\n");
+			exit(2);
+		}
+		printf(" : %d \n",rcv_size);
+
+
+		mmt_socket->ss=ss;
+		//mmt_socket->addr=(struct sockaddr*)&local_addr;
+}
+
+void get_mp_table(mp_table_t mp_table){
+
+	pthread_mutex_lock(&message_mutex);				/**/
+
+	//PA message,
+	copy_mp_table(&mp_table ,&(pa_message.mp_table));
+	printf("message %d\n",pa_message.length);
+	//
+	pthread_mutex_unlock(&message_mutex);				/**/
+
+}
+
+void set_asset_list(){
+
+
+}
+
+int check_mpu_iscomplete(mpu_buf_t mpu_buf){
+	int i;
+	int total_packet=0;
+	int receive_packet=0;
+	for(i=0;i<mpu_buf.mfu_number;i++)
+		{
+		total_packet=total_packet+mpu_buf.mfu[i].number;
+		receive_packet=receive_packet+mpu_buf.mfu[i].counter;
+		};
+	if(total_packet>receive_packet)
+	{
+		return 0;
+	}
+	else
+	{
+		return 1;
+	}
+}
+
+int check_mfu_iscomplete(mfu_buf_t mfu_buf){
+	if(mfu_buf.number>mfu_buf.counter)
+	{
+		return 0;
+	}
+	else
+	{
+		return 1;
+	}
+}
+
+void make_file(char *mpu_name, char *data, int len ) {
+	FILE *fd = fopen(mpu_name,"wb+");
+    if (fd)
+	{
+	    fwrite(data,len,1,fd);
+	    fclose(fd);
+	}
+	else
+	{
+		printf("not open\n");
+	}
+}
+
+
+
+void check(){
+
+	;
+}
+
+void process_packet(){
+
+	;
+}
+
+//check current MPU status
+void check_receive_condition(){
+
+}
+//
+void is_mpumeta(){
+
+	;
+}
+
+//process mpumeta
+void add_mpumeta(){
+
+	;
+}
+void is_fragmeta(){
+
+	;
+}
+void add_fragmeta(){
+
+	;
+}
+void is_sample_data(){
+
+	;
+}
+void add_sample_data(){
+
+	;
+}
diff --git a/net/mmt/mmtp/getfile.c b/net/mmt/mmtp/getfile.c
new file mode 100644
index 0000000..4a63216
--- /dev/null
+++ b/net/mmt/mmtp/getfile.c
@@ -0,0 +1,274 @@
+#include"getfile.h"
+
+
+int cmp(char *p1,char *p2) /*  */
+{int i=0;
+while (*(p1+i)==*(p2+i))
+if (*(p1+i++)=='\0') return 0; /* *(p1+i)=='\0'i++ */
+return (*(p1+i)-*(p2+i));
+}
+
+void sort(char **fileNameList, int count) /**/
+{
+	char *temp;
+	int i,j;
+	for(i=0;i<count-1;i++)/*  */
+	for(j=i+1;j<count;j++)
+	if(cmp(fileNameList[i],fileNameList[j])>0)
+	{
+		temp=fileNameList[i];/*  */
+		fileNameList[i]=fileNameList[j];
+		fileNameList[j]=temp;
+	}
+}
+
+// author:wangchangshaui jlu
+//this function can get result in fileNameList
+int getFileNameArray(const char *path, u_int32_t* fileCount,char ***fileNameList)
+{
+    int count = 0;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if (((*fileNameList) = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return -1;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if (((*fileNameList)[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return -1;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset((*fileNameList)[i], 0, strlen(ent->d_name) + 1);
+            strcpy((*fileNameList)[i], ent->d_name);
+            printf("%d:%s\n", i, (*fileNameList)[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort((*fileNameList), count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,(*fileNameList)[i]);
+       }
+
+    return 1;
+}
+
+// author:wangchangshaui jlu
+//this function like getFileNameArray, you  can get result by return
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount)
+{
+    int count = 0;
+    char **fileNameList = NULL;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if ((fileNameList = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return NULL;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if ((fileNameList[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return NULL;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset(fileNameList[i], 0, strlen(ent->d_name) + 1);
+            strcpy(fileNameList[i], ent->d_name);
+            printf("%d:%s\n", i, fileNameList[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort(fileNameList, count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,fileNameList[i]);
+       }
+
+    return fileNameList;
+}
+
+void get_full_path(const char *path ,char * filename,char ** fullpath )
+{
+
+	char dir_buf[512];
+	memset(dir_buf, 0, 512);
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	*fullpath=dir_buf;
+	printf("fullpath%s\n",*fullpath);
+}
+
+char* get_full_path2(const char *path ,char * filename)
+{
+
+	static char dir_buf[512];
+	memset(dir_buf, 0, strlen(dir_buf));
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	//printf("fullpath%s\n",dir_buf);
+	return (char *)dir_buf;
+
+}
+
+int ReadFile(char * path, char ** fdata, u_int16_t *length)
+{
+    FILE * pfile;
+    char * data;
+
+    pfile = fopen(path, "rb");
+    if (pfile == NULL)
+    {
+        return -1;
+    }
+    fseek(pfile, 0, SEEK_END);
+    *length = ftell(pfile);
+    data = (char *)malloc((*length + 1) * sizeof(char));
+    rewind(pfile);
+    *length = fread(data, 1, *length, pfile);
+    data[*length] = '\0';
+    fclose(pfile);
+    *fdata=data;
+    return 1;
+}
+
+char* strcatex(char* str1, char* str2)
+{
+    char* buf = (char*) malloc(strlen(str1) + strlen(str2) + 1);
+    sprintf(buf, "%s", str1);
+    strcat(buf, str2);
+    return buf;
+}
diff --git a/net/mmt/mmtp/getfile.h b/net/mmt/mmtp/getfile.h
new file mode 100644
index 0000000..abcf152
--- /dev/null
+++ b/net/mmt/mmtp/getfile.h
@@ -0,0 +1,22 @@
+#ifndef NET_MMT_MMTP_GETFILE_H_
+#define NET_MMT_MMTP_GETFILE_H_
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+int getFileNameArray(const char *path, u_int32_t* fileCount,char * **fileNameList);
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount);
+void get_full_path(const char *path ,char * filename,char ** fullpath );
+char *get_full_path2(const char *path ,char * filename);
+//char * ReadFile(char * path, int *length);
+int ReadFile(char * path, char ** fdata,u_int16_t *length);
+char* strcatex(char* str1, char* str2);
+
+#endif
diff --git a/net/mmt/mmtp/ini.c b/net/mmt/mmtp/ini.c
new file mode 100644
index 0000000..798f069
--- /dev/null
+++ b/net/mmt/mmtp/ini.c
@@ -0,0 +1,692 @@
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+
+# undef  _GNU_SOURCE
+# define _GNU_SOURCE
+
+# include <stdio.h>
+# include <string.h>
+# include <stdlib.h>
+# include <stdbool.h>
+# include <ctype.h>
+# include <arpa/inet.h>
+# include <fcntl.h>
+#include <unistd.h>
+
+# include "ini.h"
+#define  MAX_PATH 260
+
+static bool is_comment(char **line)
+{
+    char *content = *line;
+    while (isspace(*content))
+        ++content;
+
+    if (*content == ';' || *content == '#' || *content == '\0')
+        return true;
+
+    char *end = content + strlen(content) - 1;
+    while (isspace(*end))
+        *end-- = '\0';
+
+    *line = content;
+
+    return false;
+}
+
+static ssize_t _getline(char **lineptr, size_t *n, FILE *stream)
+{
+    ssize_t len = getline(lineptr, n, stream);
+    if (len == -1)
+        return -1;
+
+    char  *_line = NULL;
+    size_t _n    = 0;
+
+    while (len >= 2 && (*lineptr)[len - 2] == '\\')
+    {
+        if (getline(&_line, &_n, stream) == -1)
+        {
+            free(_line);
+
+            return 0;
+        }
+
+        char *next_line = _line;
+        while (isspace(*next_line))
+            ++next_line;
+        ssize_t next_len = strlen(next_line);
+        ssize_t need_len = len - 1 + next_len + 1;
+
+        if (*n < need_len)
+        {
+            while (*n < need_len)
+                *n *= 2;
+
+            *lineptr = realloc(*lineptr, *n);
+            if (*lineptr == NULL)
+            {
+                free(_line);
+
+                return -1;
+            }
+        }
+
+        if (isspace((*lineptr)[len - 3]))
+            (*lineptr)[len - 2] = '\0';
+        else
+            (*lineptr)[len - 2] = ' ';
+        (*lineptr)[len - 1] = '\0';
+
+        strcat(*lineptr, next_line);
+        len = strlen(*lineptr);
+    }
+
+    if (_line)
+        free(_line);
+
+    return len;
+}
+
+void ini_free(ini_t *handler)
+{
+    struct ini_section *curr = handler;
+    struct ini_section *next = NULL;
+
+    while (curr)
+    {
+        next = curr->next;
+
+        struct ini_arg *arg_curr = curr->args;
+        struct ini_arg *arg_next = NULL;
+
+        while (arg_curr)
+        {
+            arg_next = arg_curr->next;
+
+            free(arg_curr->name);
+            free(arg_curr->value);
+            free(arg_curr);
+
+            arg_curr = arg_next;
+        }
+
+        free(curr->name);
+        free(curr);
+
+        curr = next;
+    }
+
+    return;
+}
+
+static void ini_print(ini_t *handler)
+{
+# ifdef DEBUG
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name == NULL)
+            continue;
+
+        printf("[%s]\n", curr->name);
+
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name == NULL || arg->value == NULL)
+                continue;
+
+            printf("    %-20s = %s\n", arg->name, arg->value);
+            arg = arg->next;
+        }
+
+        curr = curr->next;
+    }
+# endif
+
+    return;
+}
+
+static struct ini_section *create_section(struct ini_section *head, char *name)
+{
+    struct ini_section *p = calloc(1, sizeof(struct ini_section));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_section *find_section(struct ini_section *head, char *name)
+{
+    struct ini_section *curr = head;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(curr->name, name) == 0)
+            return curr;
+
+        curr = curr->next;
+    }
+
+    return NULL;
+}
+
+static struct ini_arg *create_arg(struct ini_section *head, char *name, char *value)
+{
+    struct ini_arg *p = calloc(1, sizeof(struct ini_arg));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->value = strdup(value)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_arg *find_arg(struct ini_section *curr, char *name)
+{
+    struct ini_arg *arg = curr->args;
+
+    while (arg)
+    {
+        if (arg->name && strcmp(arg->name, name) == 0)
+            return arg;
+
+        arg = arg->next;
+    }
+
+    return NULL;
+}
+
+ini_t *ini_load(char *path)
+{
+
+	char current_absolute_path[MAX_PATH];
+	memset(current_absolute_path,0,sizeof(current_absolute_path));
+	//
+	int cnt = readlink("/proc/self/exe", current_absolute_path, MAX_PATH);
+	if (cnt < 0 || cnt >= MAX_PATH)
+	{
+	    printf("***Error***\n");
+	    exit(-1);
+	}
+	//
+	int i;
+	for (i = cnt; i >=0; --i)
+	{
+	    if (current_absolute_path[i] == '/')
+	    {
+	        //current_absolute_path[i+1] = '\0';
+	    	memcpy(&current_absolute_path[i+1],path,(strlen(path)+1));
+	        break;
+	    }
+	    else
+	    	current_absolute_path[i] = '\0';
+
+	}
+
+    FILE *fp = fopen(current_absolute_path, "r");
+
+    if (fp == NULL)
+        return NULL;
+
+    struct ini_section *head = NULL;
+    struct ini_section *prev = NULL;
+    struct ini_section *curr = NULL;
+
+    struct ini_arg *arg_curr = NULL;
+    struct ini_arg *arg_prev = NULL;
+
+    char *line  = NULL;
+    size_t   n  = 0;
+    ssize_t len = 0;
+
+    while ((len = _getline(&line, &n, fp)) != -1)
+    {
+        char *s = line;
+        if (is_comment(&s))
+            continue;
+        len = strlen(s);
+
+        if (len >= 3 && s[0] == '[' && s[len - 1] == ']')
+        {
+            char *name = s + 1;
+            while (isspace(*name))
+                ++name;
+
+            char *name_end = s + len - 1;
+            *name_end-- = '\0';
+            while (isspace(*name_end))
+                *name_end-- = '\0';
+
+            if ((curr = find_section(head, name)) == NULL)
+            {
+                if ((curr = create_section(head, name)) == NULL)
+                {
+                    free(line);
+
+                    return NULL;
+                }
+
+                if (head == NULL)
+                    head = curr;
+                if (prev != NULL)
+                    prev->next = curr;
+
+                prev = curr;
+                arg_prev = NULL;
+            }
+            else
+            {
+                arg_prev = curr->args;
+                while (arg_prev->next != NULL)
+                    arg_prev = arg_prev->next;
+            }
+
+            continue;
+        }
+
+        char *delimiter = strchr(s, '=');
+        if (delimiter == NULL)
+            continue;
+        *delimiter = '\0';
+
+        char *name = s;
+        char *name_end = delimiter - 1;
+        while (isspace(*name_end))
+            *name_end-- = '\0';
+
+        char *value = delimiter + 1;
+        while (isspace(*value))
+            value++;
+
+        if (curr == NULL)
+        {
+            if ((curr = create_section(head, "global")) == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (head == NULL)
+                head = curr;
+            prev = curr;
+            arg_prev = NULL;
+        }
+
+        if ((arg_curr = find_arg(curr, name)) == NULL)
+        {
+            arg_curr = create_arg(head, name, value);
+            if (arg_curr == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (arg_prev)
+                arg_prev->next = arg_curr;
+            if (curr->args == NULL)
+                curr->args = arg_curr;
+
+            arg_prev = arg_curr;
+        }
+        else
+        {
+            char *old_value = arg_curr->value;
+
+            if ((arg_curr->value = strdup(value)) == NULL)
+            {
+                ini_free(head);
+
+                free(line);
+
+                return NULL;
+            }
+
+            free(old_value);
+        }
+    }
+
+    free(line);
+    fclose(fp);
+
+    if (head == NULL)
+    {
+        if ((head = calloc(1, sizeof(struct ini_section))) == NULL)
+            return NULL;
+    }
+
+    ini_print(head);
+
+    return head;
+}
+
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value)
+{
+    if (!handler || !name || !value)
+        return -1;
+
+    if (section == NULL || *section == 0)
+        section = "global";
+
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(section, curr->name) == 0)
+            break;
+
+        curr = curr->next;
+    }
+
+    if (curr)
+    {
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name && arg->value && strcmp(arg->name, name) == 0)
+            {
+                *value = strdup(arg->value);
+                if (*value == NULL)
+                    return -1;
+
+                return 0;
+            }
+
+            arg = arg->next;
+        }
+    }
+
+    if (default_value)
+    {
+        *value = strdup(default_value);
+        if (*value == NULL)
+            return -1;
+    }
+    else
+    {
+        *value = NULL;
+    }
+
+    return 1;
+}
+
+static char *sstrncpy(char *dest, const char *src, size_t n)
+{
+    if (n == 0)
+        return dest;
+
+    dest[0] = 0;
+
+    return strncat(dest, src, n - 1);
+}
+
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(value, 0, n);
+
+    if (s)
+    {
+        sstrncpy(value, s, n);
+        free(s);
+    }
+
+    return ret;
+}
+
+static int ini_read_num(ini_t *handler,
+        char *section, char *name, void *value, bool is_unsigned)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        if (is_unsigned)
+            *(unsigned long long int*)value = strtoull(s, NULL, 0);
+        else
+            *(long long int *)value = strtoll(s, NULL, 0);
+
+        free(s);
+    }
+
+    return ret;
+}
+
+# define INI_READ_SIGNED(type) do { \
+    long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, false); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+# define INI_READ_UNSIGNED(type) do { \
+    unsigned long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, true); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value)
+{
+    INI_READ_SIGNED(int);
+}
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value)
+{
+    INI_READ_UNSIGNED(unsigned);
+}
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value)
+{
+    INI_READ_SIGNED(int8_t);
+}
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value)
+{
+    INI_READ_UNSIGNED(uint8_t);
+}
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value)
+{
+    INI_READ_SIGNED(int16_t);
+}
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value)
+{
+    INI_READ_UNSIGNED(uint16_t);
+}
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value)
+{
+    INI_READ_SIGNED(int32_t);
+}
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value)
+{
+    INI_READ_UNSIGNED(uint32_t);
+}
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value)
+{
+    INI_READ_SIGNED(int64_t);
+}
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value)
+{
+    INI_READ_UNSIGNED(uint64_t);
+}
+
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtof(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtod(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(addr, 0, sizeof(struct sockaddr_in));
+
+    if (s)
+    {
+        char *ip = strtok(s, ": \t");
+        if (ip == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        char *port = strtok(NULL, ": \t");
+        if (port == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_family = AF_INET;
+        if (inet_aton(ip, &addr->sin_addr) == 0)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_port = htons((uint16_t)atoi(port));
+
+        free(s);
+    }
+
+    return ret;
+}
+
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        int i;
+        for (i = 0; s[i]; ++i)
+            s[i] = tolower(s[i]);
+
+        if (strcmp(s, "true") == 0)
+            *value = true;
+        else if (strcmp(s, "false") == 0)
+            *value = false;
+        else
+            *value = default_value;
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
diff --git a/net/mmt/mmtp/ini.h b/net/mmt/mmtp/ini.h
new file mode 100644
index 0000000..ab895e6
--- /dev/null
+++ b/net/mmt/mmtp/ini.h
@@ -0,0 +1,153 @@
+#ifndef NET_MMT_MMTP_INI_H_
+#define NET_MMT_MMTP_INI_H_
+
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+# include <stdint.h>
+# include <stdbool.h>
+# include <netinet/in.h>
+
+struct ini_arg
+{
+    char  *name;
+    char  *value;
+    struct ini_arg *next;
+};
+
+struct ini_section
+{
+    char  *name;
+    struct ini_arg *args;
+    struct ini_section *next;
+};
+
+typedef struct ini_section ini_t;
+
+/*
+ * Feature:
+ * 1: If a property name declared befor any section is declared, it
+ *    is in a "global" section. If the ini_read_* function argument
+ *    section is empty string or NULL, they will find the property
+ *    name in the "global" section.
+ *
+ * 2: There is no technical LIMIT on the length of section name or
+ *    property name or value, or the num of sections and properties,
+ *    the limit is the size of memory.
+ *
+ * 3: There is no special limit on the name of section and property.
+ *    Note that the surround whitespace of the name of section and
+ *    property and value is ignored, but they can contian whitespace.
+ *    Note that the name of section and property are case insensitivity.
+ *
+ * 4: Blank line is ignored.
+ *
+ * 5: Lines beginning with '#' or ';' are ignored and may be used to
+ *    provide comments.
+ *
+ * 6: The second occurrence of a property name in the same section
+ *    overwrite the previous one. The section occurrence of a section
+ *    is joined whih the previous one.
+ *
+ * 7: If a line end with '\', where a backslash followed immediately
+ *    by EOL (end-of-line) causes the line break to be ignored, and
+ *    the "logical line" to be continued on the next actual line from
+ *    the INI file. Example:
+ *        name = simple read only ini parser
+ *    is the same with:
+ *        name = simple \
+ *               read only \
+ *               ini parser
+ */
+
+/*
+ * Load a ini config file to memory, return NULL if fail.
+ */
+ini_t *ini_load(char *path);
+
+/*
+ * Return value:
+ * If the combination of section and name found in config file, return 0.
+ * Return 1 if not found, the *value will be the default_value.
+ *
+ * Fail return -1;
+ */
+
+/*
+ * Read string from ini config handler.
+ * The string is allocated using malloc, so, you need free it after use.
+ */ 
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value);
+
+/*
+ * Read string from ini config handler.
+ * If the real length of value is greater than or equal to n, n - 1
+ * characters and a null terminator will be copied to value, else
+ * the remainder of value pads with null bytes.
+ */
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value);
+
+/*
+ * Read int or unsigned int or stdint from ini config handler.
+ * Support octal or hexadecimal base ("0" or "0x"/"0X" respectively).
+ */
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value);
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value);
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value);
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value);
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value);
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value);
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value);
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value);
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value);
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value);
+
+/*
+ * Read float/double from ini config handler.
+ */
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value);
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value);
+
+/*
+ * Read a ipv4 addr such as: 127.0.0.1:8080 or 127.0.0.1 8080
+ */
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value);
+
+/*
+ * Read a bool from ini config handler. The value in the ini config file can be
+ * "true" or "false", the case are ignored.
+ */
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value);
+
+/* Free a ini config handler */
+void ini_free(ini_t *handler);
+
+#endif
diff --git a/net/mmt/mmtp/mkdir.c b/net/mmt/mmtp/mkdir.c
new file mode 100644
index 0000000..5ad34c9
--- /dev/null
+++ b/net/mmt/mmtp/mkdir.c
@@ -0,0 +1,61 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <unistd.h>  /* Many POSIX functions (but not all, by a large margin) */
+#include <fcntl.h>   /* open(), creat() - and fcntl() */
+#include <dirent.h>
+
+#define ACCESS access
+#define MKDIR(a) mkdir((a),0755)
+
+
+int CreatDir(char *pDir)
+{
+	int i = 0;
+	int iRet;
+	int iLen;
+	char* pszDir;
+
+	if(NULL == pDir)
+	{
+		return 0;
+	}
+
+	DIR *dirp = opendir(pDir);
+    if (dirp)
+    {
+	    closedir(dirp);
+        return 0;
+    }
+
+	pszDir = strdup(pDir);
+	iLen = strlen(pszDir);
+
+	// 
+	for (i = 0;i < iLen;i ++)
+	{
+		if (pszDir[i] == '\\' || pszDir[i] == '/')
+		{
+			pszDir[i] = '\0';
+
+			//,
+			iRet = ACCESS(pszDir,0);
+			if (iRet != 0)
+			{
+				iRet = MKDIR(pszDir);
+				if (iRet != 0)
+				{
+					return -1;
+				}
+			}
+			//linux,\/
+			pszDir[i] = '/';
+		}
+	}
+
+	iRet = MKDIR(pszDir);
+	free(pszDir);
+	return iRet;
+}
diff --git a/net/mmt/mmtp/mkdir.h b/net/mmt/mmtp/mkdir.h
new file mode 100644
index 0000000..5f75167
--- /dev/null
+++ b/net/mmt/mmtp/mkdir.h
@@ -0,0 +1,6 @@
+#ifndef NET_MMT_MMTP_MKDIR_H_
+#define NET_MMT_MMTP_MKDIR_H_
+
+int CreatDir(char *pDir);
+
+#endif
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
new file mode 100644
index 0000000..2371708
--- /dev/null
+++ b/net/mmt/mmtp/mmt.c
@@ -0,0 +1,1345 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#define BACKLOG 2
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "send.h"
+#include "mmtp.h"
+
+int get_send_timestamp()
+{
+	int MMT_timestamp;
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+
+	time_t timep;
+	struct tm *p;
+	time(&timep);
+	p = localtime(&timep);
+
+	MMT_timestamp=p->tm_hour*60*60*1000+p->tm_min*60*1000+p->tm_sec*1000+tv.tv_usec/1000;
+	return MMT_timestamp;
+}
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number)
+{
+	unsigned char *buff_tmp=(unsigned  char*) malloc(number*sizeof( unsigned   char));
+	memset(buff_tmp,0,number);
+	memcpy(&buff_tmp[0],srcbuff,number);
+	*dstbuff=buff_tmp;
+	return 0;
+
+}
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh)
+{
+//	mmt_packet_header_t mmt_header;
+
+//			mmt_header.version=0;
+//			mmt_header.packet_counter_flag=1;
+//			mmt_header.FEC_type=0;
+//			mmt_header.reserved_1=0;
+//			mmt_header.extension_flag=0;
+//			mmt_header.RAP_flag=0;
+//			mmt_header.reserved_2=0;
+//			mmt_header.type=2;
+//			mmt_header.packet_id=packet_id;
+//			mmt_header.timestamp=MMT_timestamp;
+//			mmt_header.packet_sequence_number=0;
+//			mmt_header.packet_counter=packet_counter;
+
+//16byte
+			memset(MMTPh,0,MMTPh_BUFF_LEN);
+			MMTPh[0]=(u_int8_t)mmt_header->version<<6
+					|(u_int8_t) mmt_header->packet_counter_flag<<5
+					|(u_int8_t) mmt_header->FEC_type<<3
+					|(u_int8_t) mmt_header->reserved_1<<2
+					|(u_int8_t) mmt_header->extension_flag<<1
+					|(u_int8_t) mmt_header->RAP_flag;
+			MMTPh[1]=(u_int8_t)mmt_header->reserved_2<<6
+					|(u_int8_t) mmt_header->type;
+			*((u_int16_t*)&MMTPh[2])=htons(mmt_header->packet_id);
+			*((u_int32_t*)&MMTPh[4])=htonl(mmt_header->present_time);
+			*((u_int32_t*)&MMTPh[8])=htonl(mmt_header->timestamp);
+			*((u_int32_t*)&MMTPh[12])=htonl(mmt_header->packet_sequence_number);
+			*((u_int32_t*)&MMTPh[16])=htonl(mmt_header->packet_counter);
+
+return 0;
+}
+
+int read_mmtp_header(mmt_packet_header_t *mmt_header, const char *MMTPh)
+{
+			mmt_header->version=(MMTPh[0]>>6)&0x03;
+			mmt_header->packet_counter_flag=(MMTPh[0]>>5)&0x01;
+			mmt_header->FEC_type=(MMTPh[0]>>3)&0x03;
+			mmt_header->reserved_1=(MMTPh[0]>>2)&0x01;
+			mmt_header->extension_flag=(MMTPh[0]>>1)&0x01;
+			mmt_header->RAP_flag=MMTPh[0]&0x01;
+			mmt_header->reserved_2=(MMTPh[1]>>6)&0x3F;
+			mmt_header->type=MMTPh[1]&0x03;
+			mmt_header->packet_id=ntohs(*((u_int16_t*)&MMTPh[2]));
+			mmt_header->present_time=ntohl(*((u_int32_t*)&MMTPh[4]));
+			mmt_header->timestamp=ntohl(*((u_int32_t*)&MMTPh[8]));
+			mmt_header->packet_sequence_number=ntohl(*((u_int32_t*)&MMTPh[12]));
+			mmt_header->packet_counter=ntohl(*((u_int32_t*)&MMTPh[16]));
+			return 0;
+}
+
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh)
+{
+			//8byte
+			memset(MPUh,0,MPUh_BUFF_LEN);
+
+//			mpu_header->length=0;
+//			mpu_header->FT=0;
+//			mpu_header->timed_Flag=0;
+//			mpu_header->f_i=0;
+//			mpu_header->aggregation_flag=0;
+//			mpu_header->fragment_counter=0;
+//			mpu_header->MPU_sequence_number=0;
+
+			*((u_int16_t*)&MPUh[0])=htons(mpu_header->length);
+			MPUh[2]=mpu_header->FT<<4
+					|(u_int8_t) mpu_header->timed_Flag<<3
+					|(u_int8_t) mpu_header->f_i<<1
+					|(u_int8_t) mpu_header->aggregation_flag;
+
+			MPUh[3]=(u_int8_t )mpu_header->fragment_counter;
+			*((u_int32_t*)&MPUh[4])=htonl(mpu_header->MPU_sequence_number);
+
+			return 0;
+}
+
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh)
+{
+	//8byte
+			mpu_header->length=ntohs(*((u_int16_t*)&MPUh[0]));
+			mpu_header->FT=(MPUh[2]>>4)&0x0F;
+			mpu_header->timed_Flag=(MPUh[2]>>3)&0x01;
+			mpu_header->f_i=(MPUh[2]>>1)&0x03;
+			mpu_header->aggregation_flag=(MPUh[2])&0x01;
+			mpu_header->fragment_counter=MPUh[3];
+			mpu_header->MPU_sequence_number=ntohl(*((u_int32_t*)&MPUh[4]));
+
+			return 0;
+}
+
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t)
+{
+	//14byte
+			memset(MFUh_t,0,MPUh_BUFF_LEN);
+
+	//		u_int32_t movie_fragment_sequence_number;
+	//			u_int32_t sample_number;
+	//			u_int32_t offset;
+	//			u_int8_t subsample_priority;
+	//			u_int8_t dependency_counter;
+//			mfu_time_header->movie_fragment_sequence_number=0;
+//			mfu_time_header->sample_number=0;
+//			mfu_time_header->offset=0;
+//			mfu_time_header->subsample_priority=0;
+//			mfu_time_header->dependency_counter=0;
+
+			*((u_int32_t*)&MFUh_t[0])=htonl(mfu_time_header->movie_fragment_sequence_number);
+			*((u_int32_t*)&MFUh_t[4])=htonl(mfu_time_header->sample_number);
+			*((u_int32_t*)&MFUh_t[8])=htonl(mfu_time_header->offset);
+			*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+			*((u_int8_t*)&MFUh_t[13])=(u_int8_t)mfu_time_header->dependency_counter;
+
+			return 0;
+}
+
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t)
+{
+			mfu_time_header->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&MFUh_t[0]));
+			mfu_time_header->sample_number=ntohl(*((u_int32_t*)&MFUh_t[4]));
+			mfu_time_header->offset=ntohl(*((u_int32_t*)&MFUh_t[8]));
+			mfu_time_header->subsample_priority=MFUh_t[12];
+			mfu_time_header->dependency_counter=MFUh_t[13];
+			return 0;
+}
+
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt)
+{
+	//4byte
+
+			memset(MFUh_nt,0,MFUh_nt_BUFF_LEN);
+
+			//u_int32_t Item_ID;
+			mfu_non_time_header->Item_ID=0;
+			*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header->Item_ID);
+
+			return 0;
+}
+
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt)
+{
+	//4byte
+			mfu_non_time_header->Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			return 0;
+}
+
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf)
+{
+	*((u_int32_t*)&mfu_sample_buf[0])=htonl(mfu_sample->sequence_number);
+	mfu_sample_buf[4]=mfu_sample->trackrefindex;
+	*((u_int32_t*)&mfu_sample_buf[5])=htonl(mfu_sample->movie_fragment_sequence_number);
+	*((u_int32_t*)&mfu_sample_buf[9])=htonl(mfu_sample->sample_number);
+	mfu_sample_buf[13]=mfu_sample->priority;
+	mfu_sample_buf[14]=mfu_sample->dependency_counter;
+	*((u_int32_t*)&mfu_sample_buf[15])=htonl(mfu_sample->offset);
+	*((u_int32_t*)&mfu_sample_buf[19])=htonl(mfu_sample->length);
+	*((u_int32_t*)&mfu_sample_buf[23])=htonl(mfu_sample->muli_length);
+	*((u_int32_t*)&mfu_sample_buf[27])=mfu_sample->muli_name;
+	*((u_int16_t*)&mfu_sample_buf[31])=htons(mfu_sample->muli_reserved1);
+	*((u_int8_t*)&mfu_sample_buf[33])=mfu_sample->muli_reserved2;
+			return 0;
+}
+
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf)
+{
+
+
+
+	mfu_sample->sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[0]));
+	mfu_sample->trackrefindex=mfu_sample_buf[4];
+	mfu_sample->sample_number=ntohl(*((u_int32_t*)&mfu_sample_buf[5]));
+	mfu_sample->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[9]));
+	mfu_sample->priority=mfu_sample_buf[13];
+	mfu_sample->dependency_counter=mfu_sample_buf[14];
+	mfu_sample->offset=ntohl(*((u_int32_t*)&mfu_sample_buf[15]));
+	mfu_sample->length=ntohl(*((u_int32_t*)&mfu_sample_buf[19]));
+	mfu_sample->muli_length=ntohl(*((u_int32_t*)&mfu_sample_buf[23]));
+	mfu_sample->muli_name=ntohl(*((u_int32_t*)&mfu_sample_buf[27]));
+	mfu_sample->muli_reserved1=ntohl(*((u_int16_t*)&mfu_sample_buf[31]));
+	mfu_sample->muli_reserved2=ntohl(*((u_int8_t*)&mfu_sample_buf[33]));
+			return 0;
+}
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh)
+{
+	//10 byte
+	*((u_int16_t*)&SMTh[0])=htons(smt_header->SPS);
+	*((u_int8_t*)&SMTh[2])=(u_int8_t)smt_header->SDC;
+	*((u_int16_t*)&SMTh[3])=htons(smt_header->LEN);
+	*((u_int16_t*)&SMTh[5])=htons(smt_header->TCH);
+	*((u_int16_t*)&SMTh[7])=htons(smt_header->RSV1);
+	*((u_int8_t*)&SMTh[9])=(u_int8_t)smt_header->RSV2;
+	return 0;
+
+}
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh)
+{
+	//10byte
+	smt_header->SPS=ntohs(*((u_int16_t*)&SMTh[0]));
+	smt_header->SPS=SMTh[2];
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[3]));
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[5]));
+	smt_header->RSV1=ntohs(*((u_int16_t*)&SMTh[7]));
+	smt_header->RSV2=SMTh[9];
+	return 0;
+
+}
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+	mp4_box_t *root = NULL;
+	mp4_box_t *moof = NULL;
+	stream_t* s = NULL;
+
+	s = create_file_stream();
+	if (stream_open(s, Fullpath, MODE_READ) == 0)
+	   return -1;
+
+	root = MP4_BoxGetRoot(s);
+	//
+	stream_seek(s, 0, 0);
+
+	mpu_metadata_t mpu_metadata;
+	fragment_metadata_t fragment_metadata;
+	mpu_metadata.start=0;
+	mpu_metadata.length=root->p_first->p_next->p_next->p_next->i_pos;
+	mpu_metadata.number=(mpu_metadata.length+MPU_BUFF_LEN-1)/(unsigned int)MPU_BUFF_LEN;
+
+	fragment_metadata.start=root->p_first->p_next->p_next->p_next->i_pos;
+	fragment_metadata.length=root->p_first->p_next->p_next->p_next->i_size+8;
+	fragment_metadata.number=(fragment_metadata.length+MPU_BUFF_LEN-1)/MPU_BUFF_LEN;
+
+	uint32_t mdat_start;
+	mdat_start=root->p_first->p_next->p_next->p_next->p_next->i_pos;
+
+	//send mpu_metadata
+	stream_seek(s, mpu_metadata.start, 0);
+	int counter;
+	for (counter=0;counter<mpu_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(mpu_metadata.number-1))
+		{
+			mpu_header.length=mpu_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=0;
+		mpu_header.timed_Flag=1;
+		if(mpu_metadata.number>1)
+		{	mpu_header.fragment_counter=mpu_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(mpu_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+		if(mpu_header.f_i==0 ||mpu_header.f_i==1 )
+		{
+			mmt_header.present_time=*MPU_present_time;
+		}
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+
+
+//		printf("send MPU_sequence_number %d mpu_metadata\n",MPU_sequence_number);
+
+	}
+	//send fragment_metadata
+	stream_seek(s, fragment_metadata.start, 0);
+	for (counter=0;counter<fragment_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(fragment_metadata.number-1))
+		{
+			mpu_header.length=fragment_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+					{
+						mpu_header.length=MPU_BUFF_LEN+6;
+					}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=1;
+		mpu_header.timed_Flag=1;
+		if(fragment_metadata.number>1)
+		{
+			mpu_header.fragment_counter=fragment_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(fragment_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+//		printf("send MPU_sequence_number %d fragment_metadata\n",MPU_sequence_number);
+
+	}
+	//send mfu
+
+	// first get sample number
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t samplenumber;
+	u_int32_t movie_fragment_sequence_number;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+
+
+	char mulibuff[34]={};
+	stream_seek(s, -34,2);
+	    int k;
+		k=stream_tell(s);
+	stream_read(s, mulibuff, 34);
+	sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+	trackrefindex=mulibuff[4];
+	movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+	samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+	priority=mulibuff[13];
+	dependency_counter=mulibuff[14];
+	//counter start from mdat (mdat position is 0)
+	offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+	length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+	int sample_total_number;
+	sample_total_number=samplenumber+1;
+
+	for (counter=0;counter<sample_total_number;counter++)
+	{
+		//get the sample
+		uint32_t mfu_time_offset=0;
+		stream_seek(s, -34*(sample_total_number-counter),2);
+		stream_read(s, mulibuff, 34);
+
+		sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+		trackrefindex=mulibuff[4];
+		movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+		samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+		priority=mulibuff[13];
+		dependency_counter=mulibuff[14];
+		//counter start from mdat (mdat position is 0)
+		offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+		length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+		stream_seek(s, offset+mdat_start, 0);
+
+		int sample_frag_number=0;
+		int sample_frag_counter=0;
+
+		sample_frag_number=(length+MFU_t_BUFF_LEN-1)/MFU_t_BUFF_LEN;
+
+		 for(sample_frag_counter=0;sample_frag_counter<sample_frag_number;sample_frag_counter++)
+		 {
+			 //8 byte
+			mpu_packet_header_t mpu_header;
+			unsigned char MPUh[MPUh_BUFF_LEN];
+
+			if(sample_frag_counter==(sample_frag_number-1))
+			{
+				mpu_header.length=length%MFU_t_BUFF_LEN+MFUh_t_BUFF_LEN+6;
+				if(length%MFU_t_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+			}
+			else
+			{
+				mpu_header.length=MPU_BUFF_LEN+6;
+			}
+
+			mpu_header.FT=2;
+			mpu_header.timed_Flag=1;
+			if(sample_frag_number>1)
+			{
+				mpu_header.fragment_counter=sample_frag_number;
+				if(sample_frag_counter==0)
+					mpu_header.f_i=1;
+				else if(sample_frag_counter==(sample_frag_number-1))
+				{
+					mpu_header.f_i=3;
+				}
+				else
+				{
+					mpu_header.f_i=2;
+				}
+			}
+			else
+			{
+				mpu_header.f_i=0;
+				mpu_header.fragment_counter=1;
+			}
+			mpu_header.aggregation_flag=0;
+			mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+			init_mpu_header(&mpu_header,MPUh);
+
+			//14byte
+			mfu_time_packet_header_t mfu_time_header;
+
+			unsigned char MFUh_t[MFUh_t_BUFF_LEN];
+
+			mfu_time_header.movie_fragment_sequence_number=movie_fragment_sequence_number;
+			mfu_time_header.sample_number=counter;
+			if(sample_frag_number==1)
+			{
+				mfu_time_header.offset=0;
+			}
+			else
+			{
+				mfu_time_header.offset=mfu_time_offset;
+				mfu_time_offset=mfu_time_offset+mpu_header.length-6-MFUh_t_BUFF_LEN;
+
+
+			}
+			mfu_time_header.subsample_priority=1;
+			mfu_time_header.dependency_counter=0;
+
+			init_mfu_time_header(&mfu_time_header,MFUh_t);
+
+	//
+	//		//4byte
+	//		mfu_non_time_packet_header_t mfu_non_time_header;
+	//		unsigned char MFUh_nt[MPUh_BUFF_LEN];
+	//
+	//
+	//		//u_int32_t Item_ID;
+	//		mfu_non_time_header.Item_ID=0;
+	//		*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header.Item_ID);
+	//
+	//		mfu_non_time_header.Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=0;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN],MFUh_t,MFUh_t_BUFF_LEN);
+//			int k;
+//			k=stream_tell(s);
+//			printf("stream_tell 1  %d ",k);
+			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN],mpu_header.length-6-MFUh_t_BUFF_LEN);
+//			k=stream_tell(s);
+//			printf("  %d ",k);
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+//			socklen_t len=sizeof(*to);
+//			sendto(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length,0,to,len);
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+			if(MPU_sequence_number==0 && counter ==0&& sample_frag_counter==86 )
+			{
+//				printf("breakpoint\n");
+			}
+//			printf("send MPU_sequence_number %d mfu counter%d  total sample %d +sample_frag_counter%d total sample_frag_number%d   fragment.length%d\n",MPU_sequence_number,counter,sample_total_number,sample_frag_counter,sample_frag_number,mpu_header.length-MFUh_t_BUFF_LEN);
+		 }
+//		 printf("finished send a sample total sample %d\n",sample_total_number);
+	  }
+	printf("finished send a mpu \n");
+
+
+   //ATOM BOX name like ATOM+Box_name,for example "ATOM_moof"
+   //moof=MP4_BoxSearchBox(root,ATOM_moof);
+   //MP4_BoxFree(s, moof);
+   //moof=NULL;
+   //int i;
+   //MP4_BoxSearchBox2(root,&moof,ATOM_moof);
+	//		   i=MP4_BoxSearchBox3(root,ATOM_moof);
+   free(moof);
+   MP4_BoxFree(s, root);
+
+   stream_close(s);
+   destory_file_stream(s);
+
+	 return 0;
+}
+
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+
+	mpu_packet_header_t mpu_header;
+	unsigned char MPUh[MPUh_BUFF_LEN];
+
+
+	mpu_header.length=6;
+	mpu_header.FT=3;
+	mpu_header.timed_Flag=0;
+
+	mpu_header.f_i=0;
+	mpu_header.fragment_counter=0;
+
+	mpu_header.aggregation_flag=0;
+	mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+	init_mpu_header(&mpu_header,MPUh);
+
+	//16byte
+	mmt_packet_header_t mmt_header;
+	unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+	mmt_header.version=0;
+	mmt_header.packet_counter_flag=1;
+	mmt_header.FEC_type=0;
+	mmt_header.reserved_1=0;
+	mmt_header.extension_flag=0;
+	mmt_header.RAP_flag=0;
+	mmt_header.reserved_2=0;
+	mmt_header.type=0;
+	mmt_header.packet_id=packet_id;
+	mmt_header.present_time=0;
+	mmt_header.timestamp=0;
+	mmt_header.packet_sequence_number=*packet_sequence_number;
+	mmt_header.packet_counter=(*packet_counter);
+
+	init_mmtp_header(&mmt_header,MMTPh);
+
+	char UDPbuff[UDP_BUFF_LEN]={};
+	memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+	memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+
+	send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+	if((*packet_counter)==maximum_value)
+		{
+			*packet_counter=0;
+		}
+	else
+		{
+		(*packet_counter)++;
+		}
+	if((*packet_sequence_number)==maximum_value)
+		{
+			*packet_sequence_number=0;
+		}
+	else
+		{
+		(*packet_sequence_number)++;
+		}
+ return 0;
+}
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh)
+{
+//	memset(PAh,0,PAh_BUFF_LEN );
+//7 byte
+	*((u_int16_t*)&PAh[0])=htons((u_int16_t)pa_header->message_id);
+	*((u_int8_t*)&PAh[2])=pa_header->version;
+	*((u_int32_t*)&PAh[3])=htonl(pa_header->length);
+	*((u_int8_t*)&PAh[7])=pa_header->number_of_tables;
+//	*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+    return 0;
+
+}
+int read_pa_message_header(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+
+    return 0;
+}
+
+int read_pa_message(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+	pa_message->table_header= (table_header_t *)malloc(sizeof(table_header_t )*pa_message->number_of_tables);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		read_table_header(&pa_message->table_header[i] ,&pa_message_buf[PAh_BUFF_LEN+sizeof(table_header_t )*i]);
+	}
+	//point to first table
+	int buff_seek=PAh_BUFF_LEN+sizeof(table_header_t )*pa_message->number_of_tables;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			read_pa_table(&pa_message->pa_table ,&pa_message_buf[buff_seek]);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			read_mp_table(&pa_message->mp_table ,&pa_message_buf[buff_seek]);
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			read_mpi_table(&pa_message->mpi_table,&pa_message_buf[buff_seek]);
+		}
+		//point to next table
+		buff_seek=buff_seek+table_header_LEN+pa_message->table_header[i].length;
+
+	}
+    return 0;
+}
+
+int free_pa_message(pa_message_t *pa_message)
+{
+	free(pa_message->table_header);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			free_pa_table(&pa_message->pa_table);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			free_mp_table(&pa_message->mp_table );
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			free_mpi_table(&pa_message->mpi_table);
+		}
+	}
+	return 0;
+}
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf)
+{
+	memset(table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&table_buf[0])=table_header->table_id;
+	*((u_int8_t*)&table_buf[1])=table_header->version;
+	*((u_int16_t*)&table_buf[2])=htons(table_header->length);
+    return 0;
+
+}
+
+int read_table_header(table_header_t *table_header ,const char *table_buf)
+{
+
+	table_header->table_id=*((u_int8_t*)&table_buf[0]);
+	table_header->version=*((u_int8_t*)&table_buf[1]);
+	table_header->length=ntohs(*((u_int16_t*)&table_buf[2]));
+	return 0;
+
+}
+
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf)
+{
+	memset(PA_table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&PA_table_buf[0])=pa_table->table_id;
+	*((u_int8_t*)&PA_table_buf[1])=pa_table->version;
+	*((u_int16_t*)&PA_table_buf[2])=htons(pa_table->length);
+
+    return 0;
+
+}
+
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf)
+{
+
+	pa_table->table_id=*((u_int8_t*)&PA_table_buf[0]);
+	pa_table->version=*((u_int8_t*)&PA_table_buf[1]);
+	pa_table->length=ntohs(*((u_int16_t*)&PA_table_buf[2]));
+	pa_table->pat_content=(unsigned  char*) malloc(pa_table->length*sizeof( unsigned  char));
+	memcpy(pa_table->pat_content,&PA_table_buf[4],pa_table->length);
+	//pa_table->pat_content=*((char *)&PA_table_buf[4]);
+    return 0;
+
+}
+int free_pa_table(pa_table_t *pa_table )
+{
+
+	free(pa_table->pat_content);
+    return 0;
+
+}
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf)
+{
+//	memset(mp_table_buf,0,1024);
+	unsigned char *mp_table_buf_tmp= (unsigned   char*) malloc((4+mp_table->length)*sizeof( unsigned   char));
+	if(mp_table_buf_tmp==NULL)
+		{
+			puts ("Memory allocation failed.");
+			 exit (EXIT_FAILURE);
+		}
+
+	*((u_int8_t*)&mp_table_buf_tmp[0])=mp_table->table_id;
+	*((u_int8_t*)&mp_table_buf_tmp[1])=mp_table->version;
+	*((u_int16_t*)&mp_table_buf_tmp[2])=htons(mp_table->length);
+
+	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->number_of_assets;
+//	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->MP_table_asset[0].Identifier_mapping.identifier_type;
+	u_int32_t  i,seekpoint=5;
+
+	for (i=0;i<mp_table->number_of_assets;i++)
+	{
+		memcpy(&mp_table_buf_tmp[seekpoint],"URL",strlen("URL"));
+		memcpy(&mp_table_buf_tmp[seekpoint+3],"\0",1);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+4])=mp_table->MP_table_asset[i].Identifier_mapping.URL_length;
+		memcpy(&mp_table_buf_tmp[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+		*((u_int32_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length])=htonl(mp_table->MP_table_asset[i].asset_type);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4])=mp_table->MP_table_asset[i].asset_clock_relation_flag;
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5])=mp_table->MP_table_asset[i].location_count;
+		*((u_int16_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6])=htons(mp_table->MP_table_asset[i].asset_descriptors_length);
+
+		memcpy(&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_byte,mp_table->MP_table_asset[i].asset_descriptors_length);
+	//	*((u_int8_t*)&mp_table_buf_tmp[3])=mp_table->Identifier_mapping->URL_length;
+		seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+	}
+	*mp_table_buf=mp_table_buf_tmp;
+ return 0;
+}
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf)
+{
+
+	mp_table->table_id=*((u_int8_t*)&mp_table_buf[0]);
+	mp_table->version=*((u_int8_t*)&mp_table_buf[1]);
+	mp_table->length=ntohs(*((u_int16_t*)&mp_table_buf[2]));
+	mp_table->number_of_assets=*((u_int8_t*)&mp_table_buf[4]);
+	mp_table->MP_table_asset= (MP_table_asset_t *)malloc(sizeof(MP_table_asset_t)*mp_table->number_of_assets);
+
+	u_int32_t  i,seekpoint=5;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			//memcpy(&mp_table_buf[seekpoint],"URL",strlen("URL"));
+			//memcpy(&mp_table_buf[seekpoint+3],"\0",1);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_length=*((u_int8_t*)&mp_table_buf[seekpoint+4]);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].Identifier_mapping.URL_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,&mp_table_buf[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+			mp_table->MP_table_asset[i].asset_type=ntohl(*((u_int32_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length]));
+			mp_table->MP_table_asset[i].asset_clock_relation_flag=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4]);
+			mp_table->MP_table_asset[i].location_count=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5]);
+			mp_table->MP_table_asset[i].asset_descriptors_length=ntohs(*((u_int16_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6]));
+			mp_table->MP_table_asset[i].asset_descriptors_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].asset_descriptors_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].asset_descriptors_byte,&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_length);
+		//	*((u_int8_t*)&mp_table_buf[3])=mp_table->Identifier_mapping->URL_length;
+			seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+
+		}
+
+
+return 0;
+}
+
+int  copy_mp_table(mp_table_t *mp_table_dst ,mp_table_t *mp_table_src)
+{
+
+	mp_table_dst->table_id=mp_table_src->table_id;
+	mp_table_dst->version=mp_table_src->version;
+	mp_table_dst->length=mp_table_src->length;
+	mp_table_dst->number_of_assets=mp_table_src->number_of_assets;
+	mp_table_dst->MP_table_asset= (MP_table_asset_t *)malloc(sizeof(MP_table_asset_t)*mp_table_src->number_of_assets);
+
+	u_int32_t  i;
+	for (i=0;i<mp_table_dst->number_of_assets;i++)
+		{
+			//memcpy(&mp_table_buf[seekpoint],"URL",strlen("URL"));
+			//memcpy(&mp_table_buf[seekpoint+3],"\0",1);
+			mp_table_dst->MP_table_asset[i].Identifier_mapping.URL_length=mp_table_src->MP_table_asset[i].Identifier_mapping.URL_length;
+			mp_table_dst->MP_table_asset[i].Identifier_mapping.URL_byte=(unsigned  char*) malloc(mp_table_src->MP_table_asset[i].Identifier_mapping.URL_length*sizeof( unsigned  char));
+			memcpy(mp_table_dst->MP_table_asset[i].Identifier_mapping.URL_byte,mp_table_src->MP_table_asset[i].Identifier_mapping.URL_byte,mp_table_src->MP_table_asset[i].Identifier_mapping.URL_length);
+			mp_table_dst->MP_table_asset[i].asset_type=mp_table_src->MP_table_asset[i].asset_type;
+			mp_table_dst->MP_table_asset[i].asset_clock_relation_flag=mp_table_src->MP_table_asset[i].asset_clock_relation_flag;
+			mp_table_dst->MP_table_asset[i].location_count=mp_table_src->MP_table_asset[i].location_count;
+			mp_table_dst->MP_table_asset[i].asset_descriptors_length=mp_table_src->MP_table_asset[i].asset_descriptors_length;
+			mp_table_dst->MP_table_asset[i].asset_descriptors_byte=(unsigned  char*) malloc(mp_table_src->MP_table_asset[i].asset_descriptors_length*sizeof( unsigned  char));
+			memcpy(mp_table_dst->MP_table_asset[i].asset_descriptors_byte,mp_table_dst->MP_table_asset[i].asset_descriptors_byte,mp_table_src->MP_table_asset[i].asset_descriptors_length);
+
+		}
+
+
+return 0;
+}
+
+int free_mp_table(mp_table_t *mp_table )
+{
+	u_int32_t  i;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			free(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte);
+			free(mp_table->MP_table_asset[i].asset_descriptors_byte);
+		}
+	free(mp_table->MP_table_asset);
+	return 0;
+
+}
+
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf)
+{
+//	memset(mpi_table_buf1,0,1024);
+
+	unsigned char *mpi_table_buf_tmp= (unsigned   char*) malloc((4+mpi_table->length)*sizeof( unsigned   char));
+	 if(mpi_table_buf_tmp==NULL)
+	 		{
+	 			puts ("Memory allocation failed.");
+	 			 exit (EXIT_FAILURE);
+	 		}
+
+	*((u_int8_t*)&mpi_table_buf_tmp[0])=mpi_table->table_id;
+	*((u_int8_t*)&mpi_table_buf_tmp[1])=mpi_table->version;
+	*((u_int16_t*)&mpi_table_buf_tmp[2])=htons(mpi_table->length);
+
+	*((u_int16_t*)&mpi_table_buf_tmp[4])=htons(mpi_table->PI_mode);
+
+	u_int32_t  i,seekpoint=6;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint])=(u_int8_t)(i+1);
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint+1])=mpi_table->PI_content[i].PI_content_name_length;
+//		memcpy(&mpi_table_buf_tmp[seekpoint+1] , mpi_table->PI_content[i].PI_content_name_length , 1);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_byte , mpi_table->PI_content[i].PI_content_name_length);
+		*((u_int16_t*)&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length])=htons(mpi_table->PI_content[i].PI_content_length);
+//		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length] , mpi_table->PI_content[i].PI_content_length , 2);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_byte , mpi_table->PI_content[i].PI_content_length);
+		seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+	}
+//	printf("seekpoint%d\n",seekpoint);
+//	printf("seek%s\n",mpi_table_buf_tmp);
+//	printf("seek%c\n",mpi_table_buf_tmp[8]);
+
+
+
+//	pseudogram = malloc(psize);
+//	memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+//	memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+	*mpi_table_buf=mpi_table_buf_tmp;
+//	int j;
+//	for(j=0;j<mpi_table->length+4;j++)
+//		{
+//			printf("%c",*mpi_table_buf_tmp++);
+//		}
+//	printf("\n");
+ return 0;
+}
+
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
+{
+		mpi_table->table_id=*((u_int8_t*)&mpi_table_buf[0]);
+		mpi_table->version=*((u_int8_t*)&mpi_table_buf[1]);
+		mpi_table->length=htons(*((u_int16_t*)&mpi_table_buf[2]));
+
+		mpi_table->PI_mode=htons(*((u_int16_t*)&mpi_table_buf[4]));
+		//temp var
+		mpi_table->PI_content_count=2;
+		mpi_table->PI_content= (PI_content_t *)malloc(sizeof(PI_content_t )*mpi_table->PI_content_count);
+		u_int32_t  i,seekpoint=6;
+
+		for (i=0;i<mpi_table->PI_content_count;i++)
+		{
+			//*((u_int8_t*)&mpi_table_buf[seekpoint])=(u_int8_t)(i+1);
+			mpi_table->PI_content[i].PI_content_name_length=*((u_int8_t*)&mpi_table_buf[seekpoint+1]);
+			mpi_table->PI_content[i].PI_content_name_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_name_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_name_byte,0,(mpi_table->PI_content[i].PI_content_name_length+1));
+//			printf("mpi_table->PI_content[i].PI_content_name_length%d\n",mpi_table->PI_content[i].PI_content_name_length);
+			memcpy(mpi_table->PI_content[i].PI_content_name_byte , &mpi_table_buf[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_length);
+			mpi_table->PI_content[i].PI_content_length=htons(*((u_int16_t*)&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length]));
+			mpi_table->PI_content[i].PI_content_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_byte,0,(mpi_table->PI_content[i].PI_content_length+1));
+			memcpy( mpi_table->PI_content[i].PI_content_byte ,&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_length);
+			seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+
+
+        }
+	 return 0;
+
+}
+
+int copy_mpi_table(mpi_table_t *mpi_table_dst, mpi_table_t  *mpi_table_src)
+{
+		mpi_table_dst->table_id=mpi_table_src->table_id;
+		mpi_table_dst->version=mpi_table_src->version;
+		mpi_table_dst->length=mpi_table_src->length;
+
+		mpi_table_dst->PI_mode=mpi_table_src->PI_mode;
+		//temp var
+		mpi_table_dst->PI_content_count=mpi_table_src->PI_content_count;
+		mpi_table_dst->PI_content= (PI_content_t *)malloc(sizeof(PI_content_t )*mpi_table_src->PI_content_count);
+		u_int32_t  i;
+
+		for (i=0;i<mpi_table_src->PI_content_count;i++)
+		{
+			//*((u_int8_t*)&mpi_table_buf[seekpoint])=(u_int8_t)(i+1);
+			mpi_table_dst->PI_content[i].PI_content_name_length=mpi_table_src->PI_content[i].PI_content_name_length;
+			mpi_table_dst->PI_content[i].PI_content_name_byte=(unsigned  char*) malloc((mpi_table_src->PI_content[i].PI_content_name_length+1)*sizeof( unsigned  char));
+			memset(mpi_table_dst->PI_content[i].PI_content_name_byte,0,(mpi_table_src->PI_content[i].PI_content_name_length+1));
+//			printf("mpi_table_dst->PI_content[i].PI_content_name_length%d\n",mpi_table_dst->PI_content[i].PI_content_name_length);
+			memcpy(mpi_table_dst->PI_content[i].PI_content_name_byte , mpi_table_src->PI_content[i].PI_content_name_byte , mpi_table_src->PI_content[i].PI_content_name_length);
+			mpi_table_dst->PI_content[i].PI_content_length=mpi_table_src->PI_content[i].PI_content_length;
+			mpi_table_dst->PI_content[i].PI_content_byte=(unsigned  char*) malloc((mpi_table_src->PI_content[i].PI_content_length+1)*sizeof( unsigned  char));
+			memset(mpi_table_dst->PI_content[i].PI_content_byte,0,(mpi_table_dst->PI_content[i].PI_content_length+1));
+			memcpy( mpi_table_dst->PI_content[i].PI_content_byte ,mpi_table_src->PI_content[i].PI_content_byte , mpi_table_src->PI_content[i].PI_content_length);
+
+        }
+	 return 0;
+
+}
+int free_mpi_table(mpi_table_t *mpi_table)
+{
+	u_int32_t  i;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		free(mpi_table->PI_content[i].PI_content_name_byte);
+		free(mpi_table->PI_content[i].PI_content_byte);
+
+	}
+	free(mpi_table->PI_content);
+	return 0;
+}
+int init_signal_header(signal_header_t *signal_header,unsigned char *Signal_h)
+
+{
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->res<<2
+								|(u_int8_t) signal_header->H<<1
+								|(u_int8_t) signal_header->A;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+int read_signal_header(signal_header_t *signal_header,const char *Signal_h)
+
+{
+	signal_header->f_i=(Signal_h[0]>>6)&0x03;
+	signal_header->res=(Signal_h[0]>>2)&0x0f;
+	signal_header->H=(Signal_h[0]>>1)&0x01;
+	signal_header->A=(Signal_h[0])&0x01;
+	signal_header->frag_counter=Signal_h[1];
+	signal_header->MSG_length1=ntohs(*((u_int16_t*)&Signal_h[2]));
+
+
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->H<<2
+								|(u_int8_t) signal_header->A<<1;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id)
+{
+		int pa_sequence_number=(pa_header->length+4+MMTP_BUFF_LEN-1)/(unsigned int)MMTP_BUFF_LEN;;
+		int pa_length=pa_header->length+PAh_BUFF_LEN;
+		u_int32_t buf_seekpoint=0;
+
+		int counter;
+		for (counter=0;counter<pa_sequence_number;counter++)
+		{
+			signal_header_t signal_header;
+			if(counter==(pa_sequence_number-1))
+			{
+				signal_header.MSG_length1=pa_length%signal_BUFF_LEN;
+				//
+				if(pa_length%MMTP_BUFF_LEN==0)
+					{
+					signal_header.MSG_length1=signal_BUFF_LEN;
+					}
+			}
+			else
+			{
+				signal_header.MSG_length1=signal_BUFF_LEN;
+			}
+			signal_header.f_i=0;
+			signal_header.res=0;
+			signal_header.H=0;
+			signal_header.A=0;
+			signal_header.frag_counter=0;
+
+			if(pa_sequence_number>1)
+			{	signal_header.frag_counter=pa_sequence_number;
+				if(counter==0)
+					signal_header.f_i=1;
+				else if(counter==(pa_sequence_number-1))
+				{
+					signal_header.f_i=3;
+				}
+				else
+				{
+					signal_header.f_i=2;
+				}
+			}
+			else
+			{
+				signal_header.f_i=0;
+				signal_header.frag_counter=1;
+			}
+			signal_header.A=0;
+
+			unsigned char Signal_h[Signal_h_BUFF_LEN]={};
+			init_signal_header(&signal_header,Signal_h);
+
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=2;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			//diyige jia tou
+			if (signal_header.f_i==1)
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+			}
+			else
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+
+			}
+			buf_seekpoint=buf_seekpoint+signal_header.MSG_length1;
+//			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length);
+
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+Signal_h_BUFF_LEN+signal_header.MSG_length1,to);
+
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+		}
+		printf("finished send signal\n");
+return 0;
+
+}
+
+
+
+
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to)
+
+{
+
+	int n;
+	struct timeval udp_delay;
+	udp_delay.tv_sec = 0;
+	udp_delay.tv_usec = 50; // 50 us
+	select(0, NULL, NULL, NULL, &udp_delay);
+//	printf("tmp%s/n",*tmp[1]);
+	socklen_t len=sizeof(*to);
+	n=sendto(ss,UDPbuff,length,0,to,len);
+	if(n <=0)
+	{
+		perror("send error");
+		puts ("send error");
+		exit (EXIT_FAILURE);
+		return -1;
+	}
+
+//	send_raw_udp(UDPbuff,length);
+	return 0;
+}
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf )
+//{
+//	free(mfu_buf->data);
+//	return 0;
+//}
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf )
+{
+	free(mpu_metadata_buf.data);
+	return 0;
+}
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf )
+{
+	free(fragment_metadata_buf.data);
+	return 0;
+}
+int free_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	free_mpu_metadata_buf(mpu_buf->mpu_metadata_buf);
+	free_fragment_metadata_buf(mpu_buf->fragment_metadata_buf);
+	int i;
+	for(i=0;i<mpu_buf->mfu_number;i++)
+	{
+		free(mpu_buf->mfu[i].data);
+	}
+	free(mpu_buf->mfu);
+	free(mpu_buf->mfu_sample);
+	free(mpu_buf->MPU_sequence_data);
+	return 0;
+}
+int init_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	mpu_buf->packet_id=0;
+	mpu_buf->MPU_sequence_number=0;
+	mpu_buf->flag=0;
+	mpu_buf->mfu_number=0;
+	mpu_buf->mfu_counter=0;
+	mpu_buf->MPU_sequence_length=0;
+	return 0;
+}
diff --git a/net/mmt/mmtp/mmt.h b/net/mmt/mmtp/mmt.h
new file mode 100644
index 0000000..9824875
--- /dev/null
+++ b/net/mmt/mmtp/mmt.h
@@ -0,0 +1,475 @@
+#ifndef NET_MMT_MMTP_MMT_H_
+#define NET_MMT_MMTP_MMT_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "DList.h"
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+
+#define eth_BUFF_LEN 1500
+
+#define IPh_BUFF_LEN 20
+#define IP_BUFF_LEN 1480
+
+#define UDPh_BUFF_LEN 8
+#define UDP_BUFF_LEN 1472
+
+#define MMTPh_BUFF_LEN 20
+#define MMTP_BUFF_LEN 1452
+
+#define signalh_BUFF_LEN 4
+#define signal_BUFF_LEN 1448
+#define MPUh_BUFF_LEN 8
+#define MPU_BUFF_LEN 1444
+#define MFUh_t_BUFF_LEN 14
+#define MFU_t_BUFF_LEN 1430
+#define MFUh_nt_BUFF_LEN 4
+#define MFU_nt_BUFF_LEN 1440
+//#define maximum_value 4294967295
+//#define SMTh_BUFF_LEN 10
+//
+//#define PAh_BUFF_LEN 7
+//#define PAth_BUFF_LEN 4
+//#define th_BUFF_LEN 4
+//#define Signal_h_BUFF_LEN 4
+//
+//#define table_header_LEN 4
+//#define PA_message_header_LEN 7
+
+//#define eth_BUFF_LEN 1500
+//
+//#define IPh_BUFF_LEN 20
+//#define IP_BUFF_LEN 1480
+//
+//#define UDPh_BUFF_LEN 8
+//#define UDP_BUFF_LEN 1500
+//
+//#define MMTPh_BUFF_LEN 20
+//#define MMTP_BUFF_LEN 1480
+//
+//#define signalh_BUFF_LEN 4
+//#define signal_BUFF_LEN 1476
+//#define MPUh_BUFF_LEN 8
+//#define MPU_BUFF_LEN 1472
+//#define MFUh_t_BUFF_LEN 14
+//#define MFU_t_BUFF_LEN 1458
+//#define MFUh_nt_BUFF_LEN 4
+//#define MFU_nt_BUFF_LEN 1428
+
+
+#define maximum_value 4294967295
+#define SMTh_BUFF_LEN 10
+
+#define PAh_BUFF_LEN 8
+#define PAth_BUFF_LEN 4
+#define th_BUFF_LEN 4
+#define Signal_h_BUFF_LEN 4
+
+#define table_header_LEN 4
+
+
+typedef struct MMT_config //16Byte
+{
+	char *video_dir;
+	char **video_List;
+	//char **video_Fullpath;
+	int32_t video_id;
+	u_int32_t videoCount;
+
+	char *audio_dir;
+	char **audio_List;
+	//char **audio_Fullpath;
+	u_int32_t audioCount;
+	int32_t audio_id;
+
+	char *ci_dir;
+	int32_t ci_id;
+	char *to_addr;
+	int16_t to_port;
+
+//samsung
+	int32_t session_num;
+	char *mode;
+	int16_t listen_port;
+	char *multicast_ip;
+	int16_t multicast_port;
+	int32_t time_delay;
+	char *broadband_root;
+	char *broadcast_root;
+	int32_t fec ;
+	int32_t qos ;
+	char *log_path;
+	char *controller;
+	int32_t max_client_num;
+	char *res_map_file;
+	char *broadcast_default_ci;
+	char *broadcast_default_html;
+	int16_t multiview_port;
+
+}mmt_config_t;
+
+typedef struct MPU_metadata_s //Byte
+{
+	 u_int32_t start;
+	 u_int32_t length;
+	 u_int32_t number;
+}mpu_metadata_t;
+
+typedef struct Fragment_metadata_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}fragment_metadata_t;
+
+typedef struct MFU_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}mfu_t;
+
+typedef struct MMT_packet_header_s //16Byte
+{
+    u_int8_t version:2;
+    u_int8_t packet_counter_flag:1;
+    u_int8_t FEC_type:2;
+    u_int8_t reserved_1:1;
+    u_int8_t extension_flag:1;
+    u_int8_t RAP_flag:1;
+    u_int8_t reserved_2:2;
+    u_int8_t type:6;
+    u_int16_t packet_id;
+    u_int32_t present_time;
+    u_int32_t timestamp;
+    u_int32_t packet_sequence_number;
+    u_int32_t packet_counter;
+}mmt_packet_header_t,*pmmt_packet_header_t;
+
+typedef struct MMT_packet_header_extension_header_s//4Byte
+{
+	u_int16_t type;
+	u_int16_t length;
+    //no header extension
+    //no FEC
+}mmt_packet_header_extension_header_t,*pmmt_packet_header_extension_header_t;
+
+
+typedef struct MPU_packet_header_s //8Byte
+{
+
+	u_int16_t length;
+	u_int8_t FT:4;//mpu_fragment_type
+	u_int8_t timed_Flag:1;
+	u_int8_t f_i:2;//fragmentation_indicator
+	u_int8_t aggregation_flag:1;
+	u_int8_t fragment_counter;
+	u_int32_t MPU_sequence_number;
+    //no MFU
+    //for non-time
+
+}mpu_packet_header_t,*pmpu_packet_header_t;
+
+typedef struct MFU_time_packet_header_s //14Byte
+{
+	u_int32_t movie_fragment_sequence_number;
+	u_int32_t sample_number;
+	u_int32_t offset;
+	u_int8_t subsample_priority;
+	u_int8_t dependency_counter;
+    //for time
+}mfu_time_packet_header_t,*pmfu_time_packet_header_t;
+
+typedef struct MFU_non_time_packet_header_s //4Byte
+{
+	u_int32_t Item_ID;
+    //for time
+}mfu_non_time_packet_header_t,*pmfu_non_time_packet_header_t;
+
+typedef struct SMT_packet_header_s //4Byte
+{
+	u_int16_t SPS;
+	u_int8_t SDC;
+	u_int16_t LEN;
+	u_int16_t TCH;
+	u_int16_t RSV1;
+	u_int8_t RSV2;
+    //for time
+}smt_packet_header_t;
+
+typedef struct signal_header_s //4Byte
+{
+	u_int8_t f_i:2;
+	u_int8_t res:4;
+	u_int8_t H:1;
+	u_int8_t A:1;
+	u_int8_t frag_counter;
+	u_int16_t MSG_length1;
+	u_int32_t MSG_length2;
+
+    //for time
+}signal_header_t;
+
+typedef struct table_header_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+}table_header_t;
+
+
+typedef struct Identifier_mapping_s //4Byte
+{
+	u_int8_t identifier_type;
+	u_int8_t URL_length;
+	unsigned  char *URL_byte;
+
+
+}Identifier_mapping_t;
+
+typedef struct pa_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	unsigned char *pat_content;
+}pa_table_t;
+
+
+
+typedef struct MP_table_asset_s
+{
+	Identifier_mapping_t Identifier_mapping;
+	u_int32_t asset_type;
+	u_int8_t asset_clock_relation_flag;
+	u_int8_t location_count;
+	u_int16_t asset_descriptors_length;
+    u_int32_t packet_id;
+	unsigned char *asset_descriptors_byte;
+    unsigned char *asset_id;
+}MP_table_asset_t;
+
+typedef struct mp_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	u_int8_t number_of_assets;
+	MP_table_asset_t *MP_table_asset;
+}mp_table_t;
+
+
+typedef struct PI_content_s //4Byte
+{
+//	u_int8_t PI_content_type_length;
+//	char * PI_content_type_length_byte;
+	//yes
+	u_int8_t PI_content_name_length;
+	unsigned char * PI_content_name_byte;
+	//no use
+//	u_int8_t PI_content_descriptors_length;
+//	char * PI_content_descriptors_byte;
+	//yes
+	u_int16_t PI_content_length;
+	unsigned char * PI_content_byte;
+}PI_content_t,*pPI_content_t;
+
+typedef struct mpi_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	//bu dui
+//	u_int8_t PI_mode:2;
+	u_int16_t PI_mode;
+	//use wrong
+	u_int8_t PI_content_count;
+	PI_content_t *PI_content;
+}mpi_table_t;
+
+//client
+
+typedef struct pa_message_s //8Byte
+{
+	u_int16_t message_id;
+	u_int8_t version;
+	u_int32_t length;// new version
+	u_int8_t number_of_tables;
+	table_header_t *table_header;
+	pa_table_t pa_table ;
+	mp_table_t mp_table;
+	mpi_table_t mpi_table;
+}pa_message_t;
+
+typedef struct signal_buf_s //4Byte
+{
+
+	char * buf_pool;
+	char * block_fill_flag;
+	u_int32_t block_number;
+	u_int8_t buff_status; 
+	u_int16_t packet_id; 
+}signal_buf_t,*psignal_buf_t;
+
+typedef struct mfu_buf_s //30Byte
+{
+	unsigned  char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mfu_buf_t,*pmfu_buf_t;
+
+// first get sample number
+typedef struct mfu_sample_s //30Byte
+{
+u_int32_t sequence_number;
+u_int8_t trackrefindex;
+u_int32_t movie_fragment_sequence_number;
+u_int32_t sample_number;
+u_int8_t priority;
+u_int8_t dependency_counter;
+u_int32_t offset;
+u_int32_t length;
+u_int32_t muli_length;
+u_int32_t muli_name;
+u_int16_t muli_reserved1;
+u_int8_t muli_reserved2;
+
+}mfu_sample_t,*pmfu_sample_t;
+
+typedef struct mpu_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mpu_metadata_buf_t,*pmpu_metadata_buf_t;
+
+typedef struct fragment_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}fragment_metadata_buf_t,*pfragment_metadata_buf_t;
+
+typedef struct mpu_buf_s //
+{
+	u_int16_t packet_id; 
+	u_int32_t MPU_sequence_number; 
+
+	mpu_metadata_buf_t  mpu_metadata_buf;
+	fragment_metadata_buf_t fragment_metadata_buf;
+
+	u_int8_t flag ;
+	u_int32_t mfu_number;
+	u_int32_t mfu_counter;
+	mfu_buf_t *mfu;
+	mfu_sample_t *mfu_sample;
+	u_int32_t MPU_sequence_length;
+	unsigned char * MPU_sequence_data;
+}mpu_buf_t,*pmpu_buf_t;
+
+typedef struct mmt_socket_s //
+{
+	int ss;
+	struct sockaddr addr;
+}mmt_socket_t,*pmmt_socket_t;
+
+//typedef struct mpu_s //
+//{
+//
+//	char * buf_pool;
+//	char *buf_pool_end; // end of data buffer
+//	char * block_fill_flag;
+//	u_int32_t capacity;// maximum number of items in the buffer
+//	u_int32_t count;// number of items in the buffer
+//	u_int32_t block_size;// size of each item in the buffer
+//	u_int8_t buff_status;
+//	u_int16_t packet_id;
+//	u_int32_t MPU_sequence_number;
+//	DList *mpu_metadata;
+//	DList *fragmen_metadata;
+//	DList *mfu;
+//}mpu_t,*pmpu_t;
+
+
+
+int get_MMT_timestamp();
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh);
+int read_mmtp_header(mmt_packet_header_t *mmt_header,const char *MMTPh);
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh);
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh);
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t);
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t);
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt);
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt);
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf);
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf);
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh);
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh);
+
+int init_signal_header(signal_header_t *signal_header,unsigned char *signal_h);
+int read_signal_header(signal_header_t *signal_header,const char *signal_h);
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh);
+int read_pa_message_header(pa_message_t *pa_header,const char *PAh);
+int read_pa_message(pa_message_t *pa_header,const char *PAh);
+int free_pa_message(pa_message_t *pa_header);
+
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf);
+int read_table_header(table_header_t *table_header ,const char *table_buf);
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf);
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf);
+int copy_mp_table(mp_table_t *mp_table_dst ,mp_table_t *mp_table_src);
+int free_pa_table(pa_table_t *pa_table);
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf);
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf);
+int free_mp_table(mp_table_t *mp_table );
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf);
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf);
+int copy_mpi_table(mpi_table_t *mpi_table_dst, mpi_table_t *mpi_table_src);
+int free_mpi_table(mpi_table_t *mpi_table);
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id);
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number);
+
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf );
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf );
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf );
+int free_mpu_buf(mpu_buf_t *mpu_buf );
+int init_mpu_buf(mpu_buf_t *mpu_buf );
+
+#endif
diff --git a/net/mmt/mmtp/mmtp.c b/net/mmt/mmtp/mmtp.c
new file mode 100644
index 0000000..a363679
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.c
@@ -0,0 +1,147 @@
+#include "mmtp.h"
+#include "DList.h"
+#include "mmt.h"
+#include "mkdir.h"
+
+#include <pthread.h>
+
+//> extern vars
+extern int MCAST_PORT;
+extern char MCAST_ADDR[64];
+extern DList* signal_buff_list;
+extern DList* mpu_buff_list;
+extern pthread_mutex_t signal_mutex;
+extern pthread_mutex_t  mpu_mutex;
+extern mmt_socket_t g_mmt_socket;
+extern int g_running;
+
+extern void *producter_f (mmt_socket_t *mmt_socket);
+extern void *mpu_consumer_f (void *arg);
+extern void *signal_consumer_f (void *arg);
+extern void start_sock(char *addr, u_int16_t port,mmt_socket_t * mmt_socket);
+
+//>
+mmtp_callback_t g_mmtp_cb;
+
+extern int g_pktid_init;
+extern int g_asset_num;
+extern char g_asset_ids[MAX_ASSET_NUM][260];
+extern char g_asset_clips[MAX_ASSET_NUM][260];
+extern int g_pktid_asset[MAX_ID_NUM]; // pktid => g_asset_ids
+
+
+///
+/// API for using in chrome
+
+void init_mmtp() {
+	signal_buff_list=InitList();
+	mpu_buff_list=InitList();
+	pthread_mutex_init (&signal_mutex,NULL);
+	pthread_mutex_init (&mpu_mutex,NULL);
+
+    g_mmtp_cb = NULL;
+    MCAST_PORT = 0;
+    memset(MCAST_ADDR, 0, sizeof(MCAST_ADDR));
+    // create cache dir
+    CreatDir(MMTP_CACHE);
+
+    g_asset_num = 0;
+    g_pktid_init = -1;
+    int k;
+    for (k=0; k < MAX_ID_NUM; k++) {
+        g_pktid_asset[k] = -1;
+    }
+}
+
+void set_mmtp_assets(const char* ids[], const char* clips[], int num) {
+    if (!ids || num <= 0) return;
+    if (num > MAX_ASSET_NUM) num = MAX_ASSET_NUM; 
+
+    g_asset_num = num;
+    int k;
+    for (k=0; k < num; k++) {
+        if (ids)
+            strncpy(g_asset_ids[k], ids[k], 260);
+        if (clips)
+            strncpy(g_asset_clips[k], clips[k], 260);
+    }
+
+    g_pktid_init = -1;
+    for (k=0; k < MAX_ID_NUM; k++) {
+        g_pktid_asset[k] = -1;
+    }
+}
+
+void start_mmtp(const char* mcast_ip, int mcast_port) {
+    if (!mcast_ip || mcast_port <= 0 || mcast_port > 65535) return;
+
+    strncpy(MCAST_ADDR, mcast_ip, sizeof(MCAST_ADDR));
+    MCAST_PORT = mcast_port;
+
+    pthread_t signal_consumer_t;
+    pthread_t mpu_consumer_t;
+    pthread_t producter_t;
+
+    start_sock((char *)mcast_ip, mcast_port, &g_mmt_socket);
+
+	pthread_create(&producter_t, NULL,(void*)producter_f, &g_mmt_socket);
+	usleep(10);
+	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
+	usleep(10);
+	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
+	usleep(10);
+    g_running = 1;
+}
+
+void stop_mmtp() {
+    close(g_mmt_socket.ss);
+    g_mmt_socket.ss = -1;
+    g_running = 0;
+}
+
+void uninit_mmtp() {
+	pthread_mutex_destroy(&signal_mutex);
+	pthread_mutex_destroy(&mpu_mutex);
+    DestroyList(signal_buff_list);
+    DestroyList(mpu_buff_list);
+}
+
+void set_mmtp_callback(mmtp_callback_t cb) {
+    g_mmtp_cb = cb;
+}
+
+
+
+///
+/// API for using in mmtp
+
+void push_mmtp_cihtml(int res, const char* fname) {
+    if (!g_mmtp_cb || !fname) return;
+
+    // should be Res_CI or Res_Html
+    if (!(res & Res_Signal)) return;
+
+    struct mmtp_rinfo_t rinfo;
+    memset(&rinfo, 0, sizeof(rinfo));
+    rinfo.res = res;
+    strncpy(rinfo.fname, fname, sizeof(rinfo.fname));
+    g_mmtp_cb(&rinfo); // callback
+}
+
+void push_mmtp_media(int res, const char* id, const char* url, const char* fname, int index) {
+    if (!g_mmtp_cb || !fname) return;
+
+    // should be Res_Audio/Res_Video/Res_Image
+    if (!(res & Res_Media)) return;
+
+    struct mmtp_rinfo_t rinfo;
+    memset(&rinfo, 0, sizeof(rinfo));
+
+    rinfo.res = res;
+    if (id) strncpy(rinfo.id, id, sizeof(rinfo.id));
+    if (url) strncpy(rinfo.url, url, sizeof(rinfo.url));
+    strncpy(rinfo.fname, fname, sizeof(rinfo.fname));
+    rinfo.index = index;
+    g_mmtp_cb(&rinfo); // callback
+}
+
diff --git a/net/mmt/mmtp/mmtp.gyp b/net/mmt/mmtp/mmtp.gyp
new file mode 100644
index 0000000..d2540e3
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.gyp
@@ -0,0 +1,95 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmmtp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mmtp',
+      'sources': [
+        'mmtp.c',
+        'DList.c',
+        'Mlist.c',
+        'client.c',
+        'getfile.c',
+        'ini.c',
+        'mmt.c',
+        'ringq.c',  
+        'send.c',
+        'mkdir.c',
+        ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
new file mode 100644
index 0000000..fa8b8dd
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.h
@@ -0,0 +1,104 @@
+#ifndef NET_MMT_MMTP_MMTP_H_
+#define NET_MMT_MMTP_MMTP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MMTP_CACHE      "./cache"
+#define MAX_ASSET_NUM   128
+#define MAX_ID_NUM      (MAX_ASSET_NUM*3)
+
+
+//================================================
+
+/**
+ * Chrome init mmtp receiver: do some initilization for receiver
+ */
+void init_mmtp();
+
+/**
+ * Chrome set asset ids
+ */
+void set_mmtp_assets(const char* ids[], const char* clips[], int num);
+
+/**
+ * Chrome start mmtp receiver with multicast address
+ */
+void start_mmtp(const char* mcast_ip, int mcast_port);
+
+/**
+ * Chrome stop current mmtp receiver
+ */
+void stop_mmtp();
+
+/**
+ * Chrome uninit mmtp receiver, release all allocated resources
+ */
+void uninit_mmtp();
+
+/**
+ * Chrome set mmtp callback, it will be called to notify chrome
+ *  When receiving ci/html/audio/video/image
+ * 
+ */
+struct mmtp_rinfo_t;
+typedef void (*mmtp_callback_t) (struct mmtp_rinfo_t* rinfo);
+void set_mmtp_callback(mmtp_callback_t cb);
+
+
+
+//===============================================================
+
+/**
+ * mmtp resource type
+ */
+enum mmtp_res_t {
+    Res_Unknown   = 0,
+    Res_CI        = 0x0001,
+    Res_Html      = 0x0002,
+    Res_Signal    = Res_CI + Res_Html,
+
+    Res_Video     = 0x0004,
+    Res_Audio     = 0x0008,
+    Res_Image     = 0x0010,
+    Res_Media     = Res_Video + Res_Audio + Res_Image,
+};
+
+
+/**
+ * The info of received data
+ */
+struct mmtp_rinfo_t {
+    int  res;           //> @refer mmtp_res_t
+    char id[512];       //> asset id
+    char url[512];      //> asset url
+    char fname[512];    //> received filename
+    int  index;         //> reserverd for sequence index
+};
+
+/**
+ * When receiving ci/html, MMTP should call it to notify chrome
+ * @param res: Res_CI or Res_Html.
+ * @param fname: the file path of ci/html
+ */
+void push_mmtp_cihtml(int res, const char* fname);
+
+/**
+ * When receiving audio/video/image, MMTP should call it to notify chrome
+ * @param res: Res_Video, Res_Audio or Res_Image
+ * @param id: asset id
+ * @param url: asset url
+ * @param fname: the file path of video/audio/image
+ */
+void push_mmtp_media(int res, const char* id, const char* url, const char* fname, int index);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/net/mmt/mmtp/ringq.c b/net/mmt/mmtp/ringq.c
new file mode 100644
index 0000000..8eca6b2
--- /dev/null
+++ b/net/mmt/mmtp/ringq.c
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include "ringq.h"
+#include <stdlib.h>
+#include <string.h>
+
+int ringq_init(RINGQ * p_queue)
+{
+   p_queue->size = QUEUE_MAX ;
+   
+   p_queue->head = 0;
+   p_queue->tail = 0;
+   
+   p_queue->tag = 0;
+   
+   return 0;
+}
+
+int ringq_free(RINGQ * p_queue)
+{
+  return 0;
+}
+
+
+int ringq_push(RINGQ * p_queue,int data)
+{
+//  print_ringq(p_queue);
+  
+  if(ringq_is_full(p_queue))
+   {
+     
+     printf("ringq is full\n");
+     return -1;
+   }
+      
+   p_queue->space[p_queue->tail] = data;
+   
+   p_queue->tail = (p_queue->tail + 1) % p_queue->size ;
+   
+   /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 1;
+    }
+
+    return p_queue->tag ;  
+}
+
+int ringq_poll(RINGQ * p_queue,int * p_data)
+{
+//   print_ringq(p_queue);
+  if(ringq_is_empty(p_queue))
+   {
+      
+      printf("ringq is empty\n");
+     return -1;
+   }
+   
+   *p_data = p_queue->space[p_queue->head];
+   
+   p_queue->head = (p_queue->head + 1) % p_queue->size ;
+   
+    /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 0;
+    }    
+    return p_queue->tag ;
+}
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+
+
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz)
+{
+    cb->buffer = malloc(capacity * sz);
+    if(cb->buffer == NULL)
+        // handle error
+    cb->buffer_end = (char *)cb->buffer + capacity * sz;
+    cb->capacity = capacity;
+    cb->count = 0;
+    cb->sz = sz;
+    cb->head = cb->buffer;
+    cb->tail = cb->buffer;
+}
+
+void cb_free(circular_buffer *cb)
+{
+    free(cb->buffer);
+    // clear out other fields too, just to be safe
+}
+
+void cb_push_back(circular_buffer *cb, const void *item)
+{
+    if(cb->count == cb->capacity)
+        // handle error
+    memcpy(cb->head, item, cb->sz);
+    cb->head = (char*)cb->head + cb->sz;
+    if(cb->head == cb->buffer_end)
+        cb->head = cb->buffer;
+    cb->count++;
+}
+
+void cb_pop_front(circular_buffer *cb, void *item)
+{
+    if(cb->count == 0)
+        // handle error
+    memcpy(item, cb->tail, cb->sz);
+    cb->tail = (char*)cb->tail + cb->sz;
+    if(cb->tail == cb->buffer_end)
+        cb->tail = cb->buffer;
+    cb->count--;
+}
diff --git a/net/mmt/mmtp/ringq.h b/net/mmt/mmtp/ringq.h
new file mode 100644
index 0000000..f6241c9
--- /dev/null
+++ b/net/mmt/mmtp/ringq.h
@@ -0,0 +1,65 @@
+#ifndef NET_MMT_MMTP_RINGQ_H_
+#define NET_MMT_MMTP_RINGQ_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+#define QUEUE_MAX 1500
+/*
+
+http://blog.csdn.net/sking002007/article/details/6584590
+
+*/
+typedef struct ringq{
+   int head; /* */
+   int tail; /* */ 
+   int tag ; /* */
+    int size ; /*  */
+   int space[QUEUE_MAX]; /*  */
+}RINGQ;
+
+/* 
+  :
+     head == tail tag = 0  = 1 
+*/
+
+extern int ringq_init(RINGQ * p_queue);
+
+extern int ringq_free(RINGQ * p_queue);
+
+
+/*  */
+extern int ringq_push(RINGQ * p_queue,int data);
+
+/*  */
+extern int ringq_poll(RINGQ * p_queue,int *p_data);
+
+
+#define ringq_is_empty(q) ( (q->head == q->tail) && (q->tag == 0))
+
+#define ringq_is_full(q) ( (q->head == q->tail) && (q->tag == 1))
+
+#define print_ringq(q) printf("ring head %d,tail %d,tag %d\n", q->head,q->tail,q->tag);
+#ifdef __cplusplus
+}
+#endif 
+
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+typedef struct circular_buffer
+{
+    void *buffer;     // data buffer
+    void *buffer_end; // end of data buffer
+    size_t capacity;  // maximum number of items in the buffer
+    size_t count;     // number of items in the buffer
+    size_t sz;        // size of each item in the buffer
+    void *head;       // pointer to head
+    void *tail;       // pointer to tail
+} circular_buffer;
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz);
+void cb_free(circular_buffer *cb);
+void cb_push_back(circular_buffer *cb, const void *item);
+void cb_pop_front(circular_buffer *cb, void *item);
+
+#endif
diff --git a/net/mmt/mmtp/send.c b/net/mmt/mmtp/send.c
new file mode 100644
index 0000000..7a783d0
--- /dev/null
+++ b/net/mmt/mmtp/send.c
@@ -0,0 +1,199 @@
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+#include "send.h"
+#include <arpa/inet.h>
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "mmt.h"
+/*
+    Generic checksum calculation function
+*/
+unsigned short csum(unsigned short *ptr,int nbytes)
+{
+    register long sum;
+    unsigned short oddbyte;
+    register short answer;
+
+    sum=0;
+    while(nbytes>1) {
+        sum+=*ptr++;
+        nbytes-=2;
+    }
+    if(nbytes==1) {
+        oddbyte=0;
+        *((u_char*)&oddbyte)=*(u_char*)ptr;
+        sum+=oddbyte;
+    }
+
+    sum = (sum>>16)+(sum & 0xffff);
+    sum = sum + (sum>>16);
+    answer=(short)~sum;
+
+    return(answer);
+}
+
+int send_raw_udp(char *UDPbuff,int length)
+{
+    //Create a raw socket of type IPPROTO
+    int s = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
+
+    if(s == -1)
+    {
+        //socket creation failed, may be because of non-root privileges
+        perror("Failed to create raw socket");
+        exit(1);
+    }
+
+    //Datagram to represent the packet
+    char datagram[4096] , source_ip[32] , *data , *pseudogram;
+
+    //zero out the packet buffer
+    memset (datagram, 0, 4096);
+
+    //IP header
+    struct iphdr *iph = (struct iphdr *) datagram;
+
+    //UDP header
+    struct udphdr *udph = (struct udphdr *) (datagram + sizeof (struct ip));
+
+    struct sockaddr_in sin;
+    struct pseudo_header psh;
+
+    //Data part
+
+
+
+    memcpy(&datagram[sizeof(struct iphdr) + sizeof(struct udphdr)],UDPbuff,length);
+    data = &datagram[sizeof(struct iphdr) + sizeof(struct udphdr)];
+    //some address resolution
+    strcpy(source_ip , "172.16.7.44");
+
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons(80);
+    sin.sin_addr.s_addr = inet_addr ("224.1.1.100");
+
+    //Fill in the IP Header
+    iph->ihl = 5;
+    iph->version = 4;
+    iph->tos = 0;
+    iph->tot_len = sizeof (struct iphdr) + sizeof (struct udphdr) + length;
+    iph->id = htonl (54321); //Id of this packet
+    iph->frag_off = 0;
+    iph->ttl = 1;
+    iph->protocol = IPPROTO_UDP;
+    iph->check = 0;      //Set to 0 before calculating checksum
+    iph->saddr = inet_addr ( source_ip );    //Spoof the source ip address
+    iph->daddr = sin.sin_addr.s_addr;
+
+    //Ip checksum
+    iph->check = csum ((unsigned short *) datagram, sizeof (struct iphdr));
+
+    //UDP header
+    udph->source = htons (6666);
+    udph->dest = htons (6080);
+    udph->len = htons(8 + length); //tcp header size
+    udph->check = 0; //leave checksum 0 now, filled later by pseudo header
+
+    //Now the UDP checksum using the pseudo header
+    psh.source_address = inet_addr( source_ip );
+    psh.dest_address = sin.sin_addr.s_addr;
+    psh.placeholder = 0;
+    psh.protocol = IPPROTO_UDP;
+    psh.udp_length = htons(sizeof(struct udphdr) + length );
+
+    int psize = sizeof(struct pseudo_header) + sizeof(struct udphdr) + length;
+    pseudogram = malloc(psize);
+
+    memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+    memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+
+    udph->check = csum( (unsigned short*) pseudogram , psize);
+
+    //loop if you want to flood :)
+//     while (1)
+    {
+        //Send the packet
+        if (sendto (s, datagram, iph->tot_len ,  0, (struct sockaddr *) &sin, sizeof (sin)) < 0)
+        {
+            perror("sendto failed");
+        }
+        //Data send successfully
+        else
+        {
+            printf ("Packet Send. Length : %d \n" , iph->tot_len);
+            close(s);
+        }
+
+
+
+        smt_packet_header_t smt_header;
+        unsigned char SMTh[SMTh_BUFF_LEN];
+        smt_header.SPS=0X4D54;
+        smt_header.SDC=0X01;
+        smt_header.LEN=10+iph->tot_len;
+        smt_header.TCH=1;
+        smt_header.RSV1=0;
+        smt_header.RSV2=0;
+        init_smt_header(&smt_header,SMTh);
+
+        char smt_datagram[4096];
+        memcpy(&smt_datagram[10],datagram,iph->tot_len);
+        memcpy(&smt_datagram[0],SMTh,SMTh_BUFF_LEN);
+    	//
+    	int ss2;
+    	struct sockaddr_in sendto_addr;
+    	//
+    	ss2=socket(AF_INET, SOCK_DGRAM,0);
+    	if(ss2<0)
+    	{
+    		printf("socket error\n");
+    		return -1;
+    	}
+    	//
+    	bzero(&sendto_addr,sizeof(sendto_addr));
+    	sendto_addr.sin_family=AF_INET;
+//    	sendto_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+    	sendto_addr.sin_addr.s_addr=inet_addr("224.1.0.100");
+    	sendto_addr.sin_port =htons(6080);
+
+    	int addr_len =sizeof(struct sockaddr_in);
+
+//        send_udp2(ss,datagram,iph->tot_len,sendto_addr);
+//    	while(1){
+//    		int a =0;
+//    		printf("udp\n");
+//    		if(sendto(ss2,datagram,iph->tot_len,0,(struct sockaddr *)&sendto_addr,addr_len)<0)
+//
+//    			printf("send fail error\n");
+//    		}
+
+    	sendto(ss2,smt_datagram,smt_header.LEN,0,(struct sockaddr *)&sendto_addr,addr_len);
+        close(ss2);
+
+    }
+
+    return 0;
+}
+
+//Complete
diff --git a/net/mmt/mmtp/send.h b/net/mmt/mmtp/send.h
new file mode 100644
index 0000000..46c6b3b
--- /dev/null
+++ b/net/mmt/mmtp/send.h
@@ -0,0 +1,32 @@
+#ifndef NET_MMT_MMTP_SEND_H_
+#define NET_MMT_MMTP_SEND_H_
+
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+/*
+    96 bit (12 bytes) pseudo header needed for udp header checksum calculation
+*/
+struct pseudo_header
+{
+    u_int32_t source_address;
+    u_int32_t dest_address;
+    u_int8_t placeholder;
+    u_int8_t protocol;
+    u_int16_t udp_length;
+};
+
+unsigned short csum(unsigned short *ptr,int nbytes);
+int send_raw_udp(char *UDPbuff,int length);
+int send_udp2(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+#endif
diff --git a/net/mmt/mpu/Makefile b/net/mmt/mpu/Makefile
new file mode 100644
index 0000000..cfb990c
--- /dev/null
+++ b/net/mmt/mpu/Makefile
@@ -0,0 +1,21 @@
+TARGET = parser
+OBJS = stream.o mp4.o test_parser.o
+CFLAGS = -I../../../
+LDFLAGS = -lm
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mpu/cutfile.c b/net/mmt/mpu/cutfile.c
new file mode 100644
index 0000000..d977505
--- /dev/null
+++ b/net/mmt/mpu/cutfile.c
@@ -0,0 +1,29 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]) {
+    if (argc != 4) {
+        printf("usage: %s infile offset outfile\n", argv[0]);
+        return 1;
+    }
+
+    int offset = atoi(argv[2]);
+    if (offset < 0) return -1;
+    FILE* infp = fopen(argv[1], "rb");
+    if (!infp) return 1;
+    int ierr = fseek(infp, offset, SEEK_SET);
+    if (ierr != 0)  return -1;
+
+    FILE* outfp = fopen(argv[3], "wb");
+    if (!outfp) return 1;
+
+    char data[128*1024];
+    while(1) {
+        int iret = fread(data, 1, sizeof(data), infp);
+        if (iret <= 0) break;
+        fwrite(data, 1, iret, outfp);
+    }
+    fclose(infp);
+    fclose(outfp);
+    return 0;
+}
diff --git a/net/mmt/mpu/moof_combine.sh b/net/mmt/mpu/moof_combine.sh
new file mode 100644
index 0000000..ab70139
--- /dev/null
+++ b/net/mmt/mpu/moof_combine.sh
@@ -0,0 +1,36 @@
+apath="$HOME/Downloads/MPUFile/"
+apath="$HOME/Videos/mmt/loveapartment_0203/audio"
+from=10
+to=100
+
+offset=1037
+dstdir=./audio
+dstname=/tmp/test_audio.mp4
+prefix="loveapartment_Audio1_MPU"
+
+
+rm -rf $dstdir
+mkdir -p $dstdir
+
+for i in `seq 1 250`; do
+    [ $i -le $from -o $i -gt $to ] && continue
+
+    srcname=""
+    if [ $i -lt 10 ]; then   
+        srcname=$apath/${prefix}_000$i.mp4
+    elif [ $i -lt 100 ]; then
+        srcname=$apath/${prefix}_00$i.mp4
+    elif [ $i -lt 250 ]; then
+        srcname=$apath/${prefix}_0$i.mp4
+    fi
+    [ ! -f $srcname ] && continue
+    ./cutfile $srcname $offset $dstdir/t$i.mp4 
+done
+
+cp -f $apath/${prefix}_00$from.mp4 $dstname
+for i in `seq 1 250`; do
+    [ ! -f $dstdir/t$i.mp4 ] && continue
+    cat $dstdir/t$i.mp4 >> $dstname
+done
+
+exit 0
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
new file mode 100644
index 0000000..282d2c7
--- /dev/null
+++ b/net/mmt/mpu/mp4.c
@@ -0,0 +1,4059 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include <math.h>
+#include <stdarg.h>
+#include "mp4.h"
+
+void *debug_malloc(size_t size, const char *file, int line, const char *func)
+{
+        void *p;
+
+        p = malloc(size);
+        printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
+            file, line, func, size, (unsigned long)p);
+        return p;
+}
+
+//#define malloc(s) debug_malloc(s, __FILE__, __LINE__, __func__)
+void *debug_free(char *p)
+{
+        //printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,  __func__, (unsigned long)p);
+            if(NULL!=(p))
+            {
+            	free(p) ;
+                p = NULL;
+            }
+            return p;
+}
+
+//#define free(p)  do {                                                                                   \
+//        printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,            \
+//            __func__, (unsigned long)p);                                                       \
+//        if (p) {                                                                                                     \
+//          free(p);                                                                                                 \
+//          p = NULL;                                                                                           \
+//       }                                                                                                               \
+//} while (0)
+
+//#define free(p) debug_free(p)
+
+
+#define msg_Dbg(x) do {} while (0)
+#define msg_Warn(x) do {} while (0)
+#define msg_Err(x) do {} while (0)
+
+#ifndef M_PI
+#define M_PI       3.14159265358979323846
+#endif
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+#define FREENULL(a) do { free( a ); a = NULL; } while(0)
+
+#define MP4_GETX_PRIVATE(dst, code, size) do { \
+    if( (i_read) >= (size) ) { dst = (code); p_peek += (size); } \
+    else { dst = 0; }   \
+    i_read -= (size);   \
+  } while(0)
+
+static uint32_t mp4_box_headersize( mp4_box_t *p_box )
+{
+   return 8
+      + ( p_box->i_shortsize == 1 ? 8 : 0 )
+      + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
+}
+
+static uint32_t Get24bBE( const uint8_t *p )
+{
+   return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
+}
+
+#define MP4_GET1BYTE( dst )  MP4_GETX_PRIVATE( dst, *p_peek, 1 )
+#define MP4_GET2BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE16(*(uint16_t*)p_peek), 2 )
+#define MP4_GET3BYTES( dst ) MP4_GETX_PRIVATE( dst, Get24bBE(p_peek), 3 )
+#define MP4_GET4BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE32(*(uint32_t*)p_peek), 4 )
+#define MP4_GET8BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE64(*(uint64_t*)p_peek), 8 )
+#define MP4_GETFOURCC( dst ) MP4_GETX_PRIVATE( dst, \
+                MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
+
+#define MP4_GETVERSIONFLAGS( p_void ) \
+    MP4_GET1BYTE( p_void->version ); \
+    MP4_GET3BYTES( p_void->flags )
+
+#define MP4_GETSTRINGZ( p_str )         \
+    if( (i_read > 0) && (p_peek[0]) )   \
+    {       \
+        const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
+        p_str = malloc( __i_copy__+1 );               \
+        if( p_str ) \
+        { \
+             memcpy( p_str, p_peek, __i_copy__ ); \
+             p_str[__i_copy__] = 0; \
+        } \
+        p_peek += __i_copy__ + 1;   \
+        i_read -= __i_copy__ + 1;   \
+    }       \
+    else    \
+    {       \
+        p_str = NULL; \
+    }
+
+#define MP4_READBOX_ENTER( mp4_box_data_TYPE_t ) \
+    int64_t  i_read = p_box->i_size; \
+    uint8_t *p_peek, *p_buff; \
+    int i_actually_read; \
+    if( !( p_peek = p_buff = malloc( i_read ) ) ) \
+    { \
+        return( 0 ); \
+    } \
+    i_actually_read = stream_read( p_stream, p_peek, i_read ); \
+    if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    } \
+    p_peek += mp4_box_headersize( p_box ); \
+    i_read -= mp4_box_headersize( p_box ); \
+    if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    }
+
+#define MP4_READBOX_EXIT( i_code ) \
+    do \
+    { \
+        free( p_buff ); \
+        if( i_read < 0 ) \
+            printf( "Not enough data" ); \
+        return( i_code ); \
+    } while (0)
+
+
+/* Some assumptions:
+ * The input method HAS to be seekable
+ */
+
+/* This macro is used when we want to printf the box type
+ * APPLE annotation box is :
+ *  either 0xA9 + 24-bit ASCII text string (and 0xA9 isn't printable)
+ *  either 32-bit ASCII text string
+ */
+#define MP4_BOX_TYPE_ASCII() ( ((char*)&p_box->i_type)[0] != (char)0xA9 )
+
+
+static void CreateUUID( uuid_t *p_uuid, uint32_t i_fourcc )
+{
+   /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
+   /* FIXME implement this */
+   (void)p_uuid;
+   (void)i_fourcc;
+}
+
+static int drms_init( void *_p_drms, uint32_t i_type,
+              uint8_t *p_info, uint32_t i_len )
+{
+   return 1;
+}
+
+static void GetUUID( uuid_t *p_uuid, const uint8_t *p_buff )
+{
+   memcpy( p_uuid, p_buff, 16 );
+}
+
+/* convert 16.16 fixed point to floating point */
+static double conv_fx( int32_t fx ) {
+   double fp = fx;
+   fp /= 65536.0;
+   return fp;
+}
+
+/* some functions for mp4 encoding of variables */
+#ifdef MP4_VERBOSE
+static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
+{
+   int i_day;
+   int i_hour;
+   int i_min;
+   int i_sec;
+
+   /* date begin at 1 jan 1904 */
+   i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
+
+   i_day = i_date / ( 60*60*24);
+   i_hour = ( i_date /( 60*60 ) ) % 60;
+   i_min  = ( i_date / 60 ) % 60;
+   i_sec =  i_date % 60;
+   sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
+}
+#endif
+
+/*****************************************************************************
+ * MP4_ReadBoxCommon : Load only common parameters for all boxes
+ *****************************************************************************
+ * p_box need to be an already allocated mp4_box_t, and all data
+ *  will only be peek not read
+ *
+ * RETURN : 0 if it fail, 1 otherwise
+ *****************************************************************************/
+int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
+{
+   int      i_read;
+   const uint8_t *p_buff = malloc(32);
+   const uint8_t *p_peek = p_buff;
+
+   if( ( ( i_read = stream_peek( p_stream, (void*)p_peek, 32 ) ) < 8 ) )
+   {
+      free((void*)p_buff);
+      return 0;
+   }
+
+   p_box->i_pos = stream_tell( p_stream );
+
+   p_box->data.p_data = NULL;
+   p_box->p_father = NULL;
+   p_box->p_first  = NULL;
+   p_box->p_last  = NULL;
+   p_box->p_next   = NULL;
+
+   MP4_GET4BYTES( p_box->i_shortsize );
+   MP4_GETFOURCC( p_box->i_type );
+
+   /* Now special case */
+
+   if( p_box->i_shortsize == 1 )
+   {
+      /* get the true size on 64 bits */
+      MP4_GET8BYTES( p_box->i_size );
+   }
+   else
+   {
+      p_box->i_size = p_box->i_shortsize;
+      /* XXX size of 0 means that the box extends to end of file */
+   }
+
+   if( p_box->i_type == ATOM_uuid )
+   {
+      /* get extented type on 16 bytes */
+      GetUUID( &p_box->i_uuid, p_peek );
+      p_peek += 16; i_read -= 16;
+   }
+   else
+   {
+      CreateUUID( &p_box->i_uuid, p_box->i_type );
+   }
+
+   free((void*)p_buff);
+
+// #ifdef MP4_VERBOSE
+//    if( p_box->i_size )
+//    {
+//       if MP4_BOX_TYPE_ASCII()
+//           printf( "found Box: %4.4s size %"PRId64,
+//          (char*)&p_box->i_type, p_box->i_size );
+//       else
+//           printf( "found Box: c%3.3s size %"PRId64,
+//          (char*)&p_box->i_type+1, p_box->i_size );
+//    }
+// #endif
+
+   return 1;
+}
+
+/*****************************************************************************
+ * MP4_NextBox : Go to the next box
+ *****************************************************************************
+ * if p_box == NULL, go to the next box in which we are( at the begining ).
+ *****************************************************************************/
+static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
+{
+   mp4_box_t box;
+
+   if( !p_box )
+   {
+      MP4_ReadBoxCommon( p_stream, &box );
+      p_box = &box;
+   }
+
+   if( !p_box->i_size )
+   {
+      return 2; /* Box with infinite size */
+   }
+
+   if( p_box->p_father )
+   {
+      const int64_t i_box_end = p_box->i_size + p_box->i_pos;
+      const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
+
+      /* check if it's within p-father */
+      if( i_box_end >= i_father_end )
+      {
+         if( i_box_end > i_father_end )
+        	 printf(  "out of bound child" );
+         return 0; /* out of bound */
+      }
+   }
+
+   if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
+   {
+      return 0;
+   }
+
+   return 1;
+}
+
+/*****************************************************************************
+ * For all known box a loader is given,
+ *  XXX: all common struct have to be already read by MP4_ReadBoxCommon
+ *       after called one of theses functions, file position is unknown
+ *       you need to call MP4_GotoBox to go where you want
+ *****************************************************************************/
+static int MP4_ReadBoxContainerRaw( stream_t *p_stream, mp4_box_t *p_container )
+{
+   mp4_box_t *p_box;
+
+   if( stream_tell( p_stream ) + 8 >
+      (int64_t)(p_container->i_pos + p_container->i_size) )
+   {
+      /* there is no box to load */
+      return 0;
+   }
+
+   do
+   {
+      if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
+
+      /* chain this box with the father and the other at same level */
+      if( !p_container->p_first ) p_container->p_first = p_box;
+      else p_container->p_last->p_next = p_box;
+      p_container->p_last = p_box;
+
+   } while( MP4_NextBox( p_stream, p_box ) == 1 );
+
+   return 1;
+}
+
+static int MP4_ReadBoxContainer( stream_t *p_stream, mp4_box_t *p_container )
+{
+   if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
+   {
+      /* container is empty, 8 stand for the first header in this box */
+      return 1;
+   }
+
+   /* enter box */
+   stream_seek( p_stream, p_container->i_pos +
+      mp4_box_headersize( p_container ), SEEK_SET );
+ 
+   return MP4_ReadBoxContainerRaw( p_stream, p_container );
+}
+
+static void MP4_FreeBox_Common( mp4_box_t *p_box )
+{
+   /* Up to now do nothing */
+   (void)p_box;
+}
+
+static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
+{
+   /* XXX sometime moov is hiden in a free box */
+   if( p_box->p_father &&
+      p_box->p_father->i_type == ATOM_root &&
+      p_box->i_type == ATOM_free )
+   {
+      const uint8_t *p_buff = malloc(44);
+      const uint8_t *p_peek = p_buff;
+      int     i_read;
+      uint32_t i_fcc;
+
+      i_read  = stream_peek( p_stream, (void *)p_peek, 44 );
+
+      p_peek += mp4_box_headersize( p_box ) + 4;
+      i_read -= mp4_box_headersize( p_box ) + 4;
+
+      if( i_read >= 8 )
+      {
+         i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
+
+         if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
+         {
+            printf( "detected moov hidden in a free box ..." );
+
+            p_box->i_type = ATOM_foov;
+            free((void *)p_buff);
+            return MP4_ReadBoxContainer( p_stream, p_box );
+         }
+      }
+      free((void *)p_buff);
+   }
+
+   /* Nothing to do */
+// #ifdef MP4_VERBOSE
+//    if MP4_BOX_TYPE_ASCII()
+//        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
+//    else
+//        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
+// #endif
+
+   return 1;
+}
+
+#   define likely(p)   (!!(p))
+#   define unlikely(p) (!!(p))
+
+static int MP4_ReadBox_ftyp( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
+
+   MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
+   MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
+
+   if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
+   {
+      unsigned int i = 0;
+      uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
+         calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
+
+      if( unlikely( tab == NULL ) )
+         MP4_READBOX_EXIT( 0 );
+
+      for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
+      {
+         MP4_GETFOURCC( tab[i] );
+      }
+   }
+   else
+   {
+      p_box->data.p_ftyp->compatible_brands = NULL;
+   }
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_ftyp( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_ftyp->compatible_brands );
+}
+
+static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int mmpu_buf;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
+   MP4_GET1BYTE(mmpu_buf);
+   p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
+   p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
+   MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
+   MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
+   p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
+   for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
+   {
+
+	   MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
+   }
+
+
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+//Read infe box
+static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
+{
+	int i;
+	char *name,*type,*encoding;
+	int64_t item_name_end_pos = -1;
+	int64_t content_type_end_pos = -1;
+    MP4_READBOX_ENTER( mp4_box_data_infe_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_infe );
+
+    MP4_GET2BYTES( p_box->data.p_infe->item_ID );
+    MP4_GET2BYTES( p_box->data.p_infe->item_protection_index );
+
+    p_box->data.p_infe->item_name = NULL;
+
+    if( i_read > 0 )
+    {
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				item_name_end_pos = i;
+				break;
+			}
+		}
+        name = p_box->data.p_infe->item_name = (char *)malloc( item_name_end_pos + 1 );
+        if( unlikely( name == NULL )|| item_name_end_pos < 0)
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( name, p_peek, item_name_end_pos );
+        p_box->data.p_infe->item_name[item_name_end_pos] = '\0';
+
+		p_peek += item_name_end_pos;
+		i_read -= item_name_end_pos;
+
+		p_box->data.p_infe->content_type = NULL;
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				content_type_end_pos = i;
+				break;
+			}
+		}
+		type = p_box->data.p_infe->content_type = malloc( content_type_end_pos + 1 );
+        if( unlikely( type == NULL || item_name_end_pos < 0))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( type, p_peek, content_type_end_pos );
+        p_box->data.p_infe->content_type[content_type_end_pos] = '\0';
+
+		p_peek += content_type_end_pos;
+		i_read -= content_type_end_pos;
+
+		p_box->data.p_infe->content_encoding = NULL;
+		encoding = p_box->data.p_infe->content_encoding = malloc( i_read + 1 );
+        if( unlikely( encoding == NULL ))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( encoding, p_peek, i_read );
+        p_box->data.p_infe->content_encoding[i_read] = '\0';
+    }
+
+#ifdef MP4_VERBOSE
+         printf( "read box: \"infe\" item_name: \"%s\" content_type: \"%s\"",
+                   (char*)&p_box->data.p_infe->item_name,
+                   p_box->data.p_infe->content_type );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iinf box
+static int MP4_ReadBox_iinf( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_iinf_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_iinf );
+
+    MP4_GET2BYTES( p_box->data.p_iinf->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 6, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"iinf\" entry-count %d",
+                      p_box->data.p_iinf->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iloc box
+static int MP4_ReadBox_iloc( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   unsigned char offset_size_and_length_size = 0;
+   unsigned char base_offset_size_and_index_size_or_reserved = 0;
+   MP4_READBOX_ENTER( mp4_box_data_iloc_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_iloc);
+   MP4_GET1BYTE(offset_size_and_length_size);
+   p_box->data.p_iloc->offset_size=(offset_size_and_length_size>>4)&0x0f;
+   p_box->data.p_iloc->length_size=offset_size_and_length_size&0x0f;
+   MP4_GET1BYTE(base_offset_size_and_index_size_or_reserved);
+   p_box->data.p_iloc->base_offset_size=(base_offset_size_and_index_size_or_reserved>>4)&0x0f;
+   p_box->data.p_iloc->index_size_or_reserved=base_offset_size_and_index_size_or_reserved&0x0f;
+   MP4_GET2BYTES( p_box->data.p_iloc->item_count );
+   p_box->data.p_iloc->item_ID =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->data_reference_index =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->base_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_count =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->extent_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_length =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_iloc->item_ID == NULL
+      || p_box->data.p_iloc->data_reference_index == NULL
+      || p_box->data.p_iloc->base_offset == NULL 
+	  || p_box->data.p_iloc->extent_count == NULL
+	  || p_box->data.p_iloc->extent_offset == NULL
+	  || p_box->data.p_iloc->extent_length == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_iloc->item_count )&&( i_read >= 18 );i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_iloc->item_ID[i] );
+      MP4_GET2BYTES( p_box->data.p_iloc->data_reference_index[i] );
+      MP4_GET4BYTES( p_box->data.p_iloc->base_offset[i] );
+	  MP4_GET2BYTES( p_box->data.p_iloc->extent_count[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"iloc\" item-count %d",
+      p_box->data.p_iloc->item_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+//Read pitm box
+static int MP4_ReadBox_pitm( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_pitm_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_pitm );
+
+    MP4_GET2BYTES( p_box->data.p_pitm->item_ID );
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+static int MP4_ReadBox_idat( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_idat_t );
+
+    p_box->data.p_idat->data =
+      calloc( i_read, sizeof( uint8_t ) );
+	memcpy(  p_box->data.p_idat->data, p_peek, i_read);
+
+	if( unlikely( p_box->data.p_idat->data == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_iloc( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_iloc->item_ID );
+   FREENULL( p_box->data.p_iloc->data_reference_index );
+   FREENULL( p_box->data.p_iloc->base_offset );
+   FREENULL( p_box->data.p_iloc->extent_count );
+   FREENULL( p_box->data.p_iloc->extent_offset );
+   FREENULL( p_box->data.p_iloc->extent_length );
+}
+
+static void MP4_FreeBox_infe( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_infe->item_name );
+   FREENULL( p_box->data.p_infe->content_type );
+   FREENULL( p_box->data.p_infe->content_encoding );
+}
+
+static void MP4_FreeBox_idat( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_idat->data );
+}
+static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
+
+       if( p_box->data.p_tfdt->version )
+       {
+           MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+       }
+       else
+       {
+           MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+       }
+
+
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_mmpu( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_mmpu->asset_id_value );
+}
+
+
+static int MP4_ReadBox_mvhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_mvhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );
+
+    if( p_box->data.p_mvhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mvhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mvhd->duration );
+    }
+    MP4_GET4BYTES( p_box->data.p_mvhd->rate );
+    MP4_GET2BYTES( p_box->data.p_mvhd->volume );
+    MP4_GET2BYTES( p_box->data.p_mvhd->reserved1 );
+
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->reserved2[i] );
+    }
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->matrix[i] );
+    }
+    for( i = 0; i < 6; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->predefined[i] );
+    }
+
+    MP4_GET4BYTES( p_box->data.p_mvhd->next_track_id );
+
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time,
+                         p_box->data.p_mvhd->modification_time );
+    if( p_box->data.p_mvhd->rate )
+    {
+        MP4_ConvertDate2Str( s_duration,
+                 p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
+    }
+    else
+    {
+        s_duration[0] = 0;
+    }
+     printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
+                  s_creation_time,
+                  s_modification_time,
+                  (uint32_t)p_box->data.p_mvhd->timescale,
+                  s_duration,
+                  (float)p_box->data.p_mvhd->rate / (1<<16 ),
+                  (float)p_box->data.p_mvhd->volume / 256 ,
+                  (uint32_t)p_box->data.p_mvhd->next_track_id );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mfhd_t );
+
+    MP4_GET4BYTES( p_box->data.p_mfhd->sequence_number );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"mfhd\" sequence number %d",
+                  p_box->data.p_mfhd->sequence_number );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_tfhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfhd );
+
+    MP4_GET4BYTES( p_box->data.p_tfhd->track_ID );
+
+    if( p_box->data.p_tfhd->version == 0 )
+    {
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_BASE_DATA_OFFSET )
+            MP4_GET8BYTES( p_box->data.p_tfhd->base_data_offset );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            MP4_GET4BYTES( p_box->data.p_tfhd->sample_description_index );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_duration );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_size );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_flags );
+
+#ifdef MP4_VERBOSE
+        char psz_base[128] = "\0";
+        char psz_desc[128] = "\0";
+        char psz_dura[128] = "\0";
+        char psz_size[128] = "\0";
+        char psz_flag[128] = "\0";
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )
+            snprintf(psz_base, sizeof(psz_base), "base offset %"PRId64, p_box->data.p_tfhd->base_data_offset);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            snprintf(psz_desc, sizeof(psz_desc), "sample description index %d", p_box->data.p_tfhd->sample_description_index);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            snprintf(psz_dura, sizeof(psz_dura), "sample duration %d", p_box->data.p_tfhd->default_sample_duration);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            snprintf(psz_size, sizeof(psz_size), "sample size %d", p_box->data.p_tfhd->default_sample_size);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            snprintf(psz_flag, sizeof(psz_flag), "sample flags 0x%x", p_box->data.p_tfhd->default_sample_flags);
+
+         printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
+                    p_box->data.p_tfhd->i_version,
+                    p_box->data.p_tfhd->i_flags,
+                    p_box->data.p_tfhd->track_ID,
+                    psz_base, psz_desc, psz_dura, psz_size, psz_flag );
+#endif
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_trun_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_trun );
+
+    MP4_GET4BYTES( p_box->data.p_trun->sample_count );
+
+    if( p_box->data.p_trun->flags & MP4_TRUN_DATA_OFFSET )
+        MP4_GET4BYTES( p_box->data.p_trun->data_offset );
+    if( p_box->data.p_trun->flags & MP4_TRUN_FIRST_FLAGS )
+        MP4_GET4BYTES( p_box->data.p_trun->first_sample_flags );
+
+    p_box->data.p_trun->samples =
+      calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
+    if ( p_box->data.p_trun->samples == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_sample->duration );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_sample->size );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_sample->flags );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_TIME_OFFSET )
+            MP4_GET4BYTES( p_sample->composition_time_offset );
+    }
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
+                  p_box->data.p_trun->version,
+                  p_box->data.p_trun->flags,
+                  p_box->data.p_trun->sample_count );
+
+    for( unsigned int i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+         printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
+                        i, p_sample->i_flags, p_sample->duration,
+                        p_sample->i_size, p_sample->composition_time_offset );
+    }
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_trun( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_trun->samples );
+}
+
+
+static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    double rotation;    //angle in degrees to be rotated clockwise
+    double scale[2];    // scale factor; sx = scale[0] , sy = scale[1]
+    double translate[2];// amount to translate; tx = translate[0] , ty = translate[1]
+    int *matrix = NULL;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_tkhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tkhd );
+
+    if( p_box->data.p_tkhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET8BYTES( p_box->data.p_tkhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET4BYTES( p_box->data.p_tkhd->duration );
+    }
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved2[i] );
+    }
+    MP4_GET2BYTES( p_box->data.p_tkhd->layer );
+    MP4_GET2BYTES( p_box->data.p_tkhd->predefined );
+    MP4_GET2BYTES( p_box->data.p_tkhd->volume );
+    MP4_GET2BYTES( p_box->data.p_tkhd->reserved3 );
+
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->matrix[i] );
+    }
+    MP4_GET4BYTES( p_box->data.p_tkhd->width );
+    MP4_GET4BYTES( p_box->data.p_tkhd->height );
+
+    
+    matrix = p_box->data.p_tkhd->matrix;
+    
+    translate[0] = conv_fx(matrix[6]);
+    translate[1] = conv_fx(matrix[7]);
+    
+    scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +
+                    conv_fx(matrix[3]) * conv_fx(matrix[3]));
+    scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +
+                    conv_fx(matrix[4]) * conv_fx(matrix[4]));
+    
+    rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;
+    
+    if (rotation < 0)
+        rotation += 360.;
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->modification_time );
+    MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->duration );
+
+     printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
+            "Matrix: %i %i %i %i %i %i %i %i %i",
+                  s_creation_time,
+                  s_modification_time,
+                  s_duration,
+                  p_box->data.p_tkhd->track_ID,
+                  p_box->data.p_tkhd->layer,
+                  (float)p_box->data.p_tkhd->volume / 256 ,
+                  rotation,
+                  scale[0],
+                  scale[1],
+                  translate[0],
+                  translate[1],
+                  (float)p_box->data.p_tkhd->width / 65536,
+                  (float)p_box->data.p_tkhd->height / 65536,
+                  p_box->data.p_tkhd->matrix[0],
+                  p_box->data.p_tkhd->matrix[1],
+                  p_box->data.p_tkhd->matrix[2],
+                  p_box->data.p_tkhd->matrix[3],
+                  p_box->data.p_tkhd->matrix[4],
+                  p_box->data.p_tkhd->matrix[5],
+                  p_box->data.p_tkhd->matrix[6],
+                  p_box->data.p_tkhd->matrix[7],
+                  p_box->data.p_tkhd->matrix[8] );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hint( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_hint_t );
+
+   MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint16_t i_language;
+    unsigned int i = 0;
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    MP4_READBOX_ENTER( mp4_box_data_mdhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mdhd );
+
+    if( p_box->data.p_mdhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mdhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mdhd->duration );
+    }
+    p_box->data.p_mdhd->language_code = i_language = SwapBE16( (uint16_t)p_peek );
+    for( i = 0; i < 3; i++ )
+    {
+        p_box->data.p_mdhd->language[i] =
+                    ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_mdhd->predefined );
+
+// #ifdef MP4_VERBOSE
+//     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
+//     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
+//     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
+//      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
+//                   s_creation_time,
+//                   s_modification_time,
+//                   (uint32_t)p_box->data.p_mdhd->timescale,
+//                   s_duration,
+//                   p_box->data.p_mdhd->language[0],
+//                   p_box->data.p_mdhd->language[1],
+//                   p_box->data.p_mdhd->language[2] );
+// #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hdlr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_hdlr_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hdlr );
+
+    MP4_GETFOURCC( p_box->data.p_hdlr->predefined );
+    MP4_GETFOURCC( p_box->data.p_hdlr->handler_type );
+
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    p_box->data.p_hdlr->psz_name = NULL;
+
+    if( i_read > 0 )
+    {
+        uint8_t *psz = p_box->data.p_hdlr->psz_name = malloc( i_read + 1 );
+        if( unlikely( psz == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        if( p_box->data.p_hdlr->predefined == MP4_FOURCC( 'm', 'h', 'l', 'r' ) )
+        {
+            uint8_t i_len;
+            int i_copy;
+
+            MP4_GET1BYTE( i_len );
+            i_copy = min( i_read, i_len );
+
+            memcpy( psz, p_peek, i_copy );
+            p_box->data.p_hdlr->psz_name[i_copy] = '\0';
+        }
+        else
+        {
+            memcpy( psz, p_peek, i_read );
+            p_box->data.p_hdlr->psz_name[i_read] = '\0';
+        }
+    }
+
+#ifdef MP4_VERBOSE
+         printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
+                   (char*)&p_box->data.p_hdlr->handler_type,
+                   p_box->data.p_hdlr->psz_name );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_hdlr( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_hdlr->psz_name );
+}
+
+static int MP4_ReadBox_vmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
+
+   MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
+   for( i = 0; i < 3; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
+   }
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
+                      p_box->data.p_vmhd->i_graphics_mode,
+                      p_box->data.p_vmhd->i_opcolor[0],
+                      p_box->data.p_vmhd->i_opcolor[1],
+                      p_box->data.p_vmhd->i_opcolor[2] );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_smhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_smhd );
+
+
+
+    MP4_GET2BYTES( p_box->data.p_smhd->balance );
+
+    MP4_GET2BYTES( p_box->data.p_smhd->reserved );
+
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"smhd\" balance %f",
+//                       (float)p_box->data.p_smhd->balance / 256 );
+// #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_hmhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hmhd );
+
+    MP4_GET2BYTES( p_box->data.p_hmhd->max_PDU_size );
+    MP4_GET2BYTES( p_box->data.p_hmhd->avg_PDU_size );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->max_bitrate );
+    MP4_GET4BYTES( p_box->data.p_hmhd->avg_bitrate );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->reserved );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
+                      p_box->data.p_hmhd->max_PDU_size,
+                      p_box->data.p_hmhd->avg_PDU_size,
+                      p_box->data.p_hmhd->max_bitrate,
+                      p_box->data.p_hmhd->avg_bitrate );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_url( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_url_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_url );
+    MP4_GETSTRINGZ( p_box->data.p_url->psz_location );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"url\" url: %s",
+                       p_box->data.p_url->psz_location );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_url( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_url->psz_location );
+}
+
+static int MP4_ReadBox_urn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_urn_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_urn );
+
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_name );
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"urn\" name %s location %s",
+                      p_box->data.p_urn->psz_name,
+                      p_box->data.p_urn->psz_location );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_urn( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_urn->psz_name );
+    FREENULL( p_box->data.p_urn->psz_location );
+}
+
+
+static int MP4_ReadBox_dref( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_dref_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_dref );
+
+    MP4_GET4BYTES( p_box->data.p_dref->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"dref\" entry-count %d",
+                      p_box->data.p_dref->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stts->sample_count );
+    FREENULL( p_box->data.p_stts->sample_delta );
+}
+
+static int MP4_ReadBox_stts( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_stts_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stts );
+   MP4_GET4BYTES( p_box->data.p_stts->entry_count );
+
+   p_box->data.p_stts->sample_count =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stts->sample_delta =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_stts->sample_count == NULL
+      || p_box->data.p_stts->sample_delta == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stts\" entry-count %d",
+      p_box->data.p_stts->entry_count );
+
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_ctts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_ctts->sample_count );
+    FREENULL( p_box->data.p_ctts->sample_offset );
+}
+
+static int MP4_ReadBox_ctts( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_ctts_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
+
+   MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
+
+   p_box->data.p_ctts->sample_count =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_ctts->sample_offset =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   if( ( p_box->data.p_ctts->sample_count == NULL )
+      || ( p_box->data.p_ctts->sample_offset == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"ctts\" entry-count %d",
+      p_box->data.p_ctts->entry_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadLengthDescriptor( uint8_t **pp_peek, int64_t  *i_read )
+{
+    unsigned int i_b;
+    unsigned int i_len = 0;
+    do
+    {
+        i_b = **pp_peek;
+
+        (*pp_peek)++;
+        (*i_read)--;
+        i_len = ( i_len << 7 ) + ( i_b&0x7f );
+    } while( i_b&0x80 );
+    return( i_len );
+}
+
+
+static void MP4_FreeBox_esds( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_esds->es_descriptor.psz_URL );
+    if( p_box->data.p_esds->es_descriptor.decConfigDescr )
+    {
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr->decoder_specific_info );
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr );
+    }
+}
+
+static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
+{
+#define es_descriptor p_box->data.p_esds->es_descriptor
+    unsigned int i_len;
+    unsigned int i_flags;
+    unsigned int i_type;
+
+    MP4_READBOX_ENTER( mp4_box_data_esds_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_esds );
+
+
+    MP4_GET1BYTE( i_type );
+    if( i_type == 0x03 ) /* MP4ESDescrTag */
+    {
+        i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+         printf( "found esds MPEG4ESDescr (%dBytes)",
+                 i_len );
+#endif
+
+        MP4_GET2BYTES( es_descriptor.ES_ID );
+        MP4_GET1BYTE( i_flags );
+        es_descriptor.b_stream_dependence = ( (i_flags&0x80) != 0);
+        es_descriptor.b_url = ( (i_flags&0x40) != 0);
+        es_descriptor.b_OCRstream = ( (i_flags&0x20) != 0);
+
+        es_descriptor.stream_priority = i_flags&0x1f;
+        if( es_descriptor.b_stream_dependence )
+        {
+            MP4_GET2BYTES( es_descriptor.depend_on_ES_ID );
+        }
+        if( es_descriptor.b_url )
+        {
+            unsigned int i_len;
+
+            MP4_GET1BYTE( i_len );
+            es_descriptor.psz_URL = malloc( i_len + 1 );
+            if( es_descriptor.psz_URL )
+            {
+                memcpy( es_descriptor.psz_URL, p_peek, i_len );
+                es_descriptor.psz_URL[i_len] = 0;
+            }
+            p_peek += i_len;
+            i_read -= i_len;
+        }
+        else
+        {
+            es_descriptor.psz_URL = NULL;
+        }
+        if( es_descriptor.b_OCRstream )
+        {
+            MP4_GET2BYTES( es_descriptor.OCR_ES_ID );
+        }
+        MP4_GET1BYTE( i_type ); /* get next type */
+    }
+
+    if( i_type != 0x04)/* MP4DecConfigDescrTag */
+    {
+         es_descriptor.decConfigDescr = NULL;
+         MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+         printf( "found esds MP4DecConfigDescr (%dBytes)",
+                 i_len );
+#endif
+
+    es_descriptor.decConfigDescr =
+            calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
+    if( unlikely( es_descriptor.decConfigDescr == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET1BYTE( es_descriptor.decConfigDescr->objectTypeIndication );
+    MP4_GET1BYTE( i_flags );
+    es_descriptor.decConfigDescr->streamType = i_flags >> 2;
+    es_descriptor.decConfigDescr->b_upStream = ( i_flags >> 1 )&0x01;
+    MP4_GET3BYTES( es_descriptor.decConfigDescr->buffer_sizeDB );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->max_bitrate );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->avg_bitrate );
+    MP4_GET1BYTE( i_type );
+    if( i_type !=  0x05 )/* MP4DecSpecificDescrTag */
+    {
+        es_descriptor.decConfigDescr->decoder_specific_info_len = 0;
+        es_descriptor.decConfigDescr->decoder_specific_info  = NULL;
+        MP4_READBOX_EXIT( 1 );
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+         printf( "found esds MP4DecSpecificDescr (%dBytes)",
+                 i_len );
+#endif
+    if( i_len > i_read )
+        MP4_READBOX_EXIT( 0 );
+
+    es_descriptor.decConfigDescr->decoder_specific_info_len = i_len;
+    es_descriptor.decConfigDescr->decoder_specific_info = malloc( i_len );
+    if( unlikely( es_descriptor.decConfigDescr->decoder_specific_info == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    memcpy( es_descriptor.decConfigDescr->decoder_specific_info,
+            p_peek, i_len );
+
+    MP4_READBOX_EXIT( 1 );
+#undef es_descriptor
+}
+
+static void MP4_FreeBox_avcC( mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC = p_box->data.p_avcC;
+    int i;
+
+    if( p_avcC->avcC > 0 ) FREENULL( p_avcC->p_avcC );
+
+    if( p_avcC->p_sps )
+    {
+        for( i = 0; i < p_avcC->sps; i++ )
+            FREENULL( p_avcC->p_sps[i] );
+    }
+    if( p_avcC->p_pps )
+    {
+        for( i = 0; i < p_avcC->pps; i++ )
+            FREENULL( p_avcC->p_pps[i] );
+    }
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->p_sps );
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->sps_length );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->p_pps );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->pps_length );
+}
+
+static int MP4_ReadBox_avcC( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC;
+    int i;
+
+    MP4_READBOX_ENTER( mp4_box_data_avcC_t );
+    p_avcC = p_box->data.p_avcC;
+
+    p_avcC->avcC = i_read;
+    if( p_avcC->avcC > 0 )
+    {
+        uint8_t * p = p_avcC->p_avcC = malloc( p_avcC->avcC );
+        if( p )
+            memcpy( p, p_peek, i_read );
+    }
+
+    MP4_GET1BYTE( p_avcC->version );
+    MP4_GET1BYTE( p_avcC->profile );
+    MP4_GET1BYTE( p_avcC->profile_compatibility );
+    MP4_GET1BYTE( p_avcC->level );
+    MP4_GET1BYTE( p_avcC->reserved1 );
+    p_avcC->length_size = (p_avcC->reserved1&0x03) + 1;
+    p_avcC->reserved1 >>= 2;
+
+    MP4_GET1BYTE( p_avcC->reserved2 );
+    p_avcC->sps = p_avcC->reserved2&0x1f;
+    p_avcC->reserved2 >>= 5;
+
+    if( p_avcC->sps > 0 )
+    {
+        p_avcC->sps_length = calloc( p_avcC->sps, sizeof( uint16_t ) );
+        p_avcC->p_sps = calloc( p_avcC->sps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->sps_length || !p_avcC->p_sps )
+            goto error;
+
+        for( i = 0; i < p_avcC->sps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->sps_length[i] );
+            p_avcC->p_sps[i] = malloc( p_avcC->sps_length[i] );
+            if( p_avcC->p_sps[i] )
+                memcpy( p_avcC->p_sps[i], p_peek, p_avcC->sps_length[i] );
+
+            p_peek += p_avcC->sps_length[i];
+            i_read -= p_avcC->sps_length[i];
+        }
+    }
+
+    MP4_GET1BYTE( p_avcC->pps );
+    if( p_avcC->pps > 0 )
+    {
+        p_avcC->pps_length = calloc( p_avcC->pps, sizeof( uint16_t ) );
+        p_avcC->p_pps = calloc( p_avcC->pps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->pps_length || !p_avcC->p_pps )
+            goto error;
+
+        for( i = 0; i < p_avcC->pps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->pps_length[i] );
+            p_avcC->p_pps[i] = malloc( p_avcC->pps_length[i] );
+            if( p_avcC->p_pps[i] )
+                memcpy( p_avcC->p_pps[i], p_peek, p_avcC->pps_length[i] );
+
+            p_peek += p_avcC->pps_length[i];
+            i_read -= p_avcC->pps_length[i];
+        }
+    }
+// #ifdef MP4_VERBOSE
+//      printf(
+//              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
+//              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
+//              p_avcC->i_length_size,
+//              p_avcC->i_sps, p_avcC->i_pps );
+//     for( i = 0; i < p_avcC->i_sps; i++ )
+//     {
+//          printf( "         - sps[%d] length=%d",
+//                  i, p_avcC->i_sps_length[i] );
+//     }
+//     for( i = 0; i < p_avcC->i_pps; i++ )
+//     {
+//          printf( "         - pps[%d] length=%d",
+//                  i, p_avcC->i_pps_length[i] );
+//     }
+// #endif
+
+    MP4_READBOX_EXIT( 1 );
+
+error:
+    MP4_READBOX_EXIT( 0 );
+}
+
+static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_dac3_t *p_dac3;
+    unsigned i_header;
+
+    MP4_READBOX_ENTER( mp4_box_data_dac3_t );
+
+    p_dac3 = p_box->data.p_dac3;
+    
+    MP4_GET3BYTES( i_header );
+
+    p_dac3->fscod = ( i_header >> 22 ) & 0x03;
+    p_dac3->bsid  = ( i_header >> 17 ) & 0x01f;
+    p_dac3->bsmod = ( i_header >> 14 ) & 0x07;
+    p_dac3->acmod = ( i_header >> 11 ) & 0x07;
+    p_dac3->lfeon = ( i_header >> 10 ) & 0x01;
+    p_dac3->bitrate_code = ( i_header >> 5) & 0x1f;
+
+#ifdef MP4_VERBOSE
+     printf(
+             "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
+             p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_enda( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_enda_t *p_enda;
+    MP4_READBOX_ENTER( mp4_box_data_enda_t );
+
+    p_enda = p_box->data.p_enda;
+
+    MP4_GET2BYTES( p_enda->little_endian );
+
+#ifdef MP4_VERBOSE
+     printf(
+             "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_gnre( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_gnre_t *p_gnre;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_gnre_t );
+
+    p_gnre = p_box->data.p_gnre;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 10 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET2BYTES( p_gnre->genre );
+    if( p_gnre->genre == 0 )
+        MP4_READBOX_EXIT( 0 );
+#ifdef MP4_VERBOSE
+     printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_trkn_t *p_trkn;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_trkn_t );
+
+    p_trkn = p_box->data.p_trkn;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 12 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( p_trkn->track_number );
+
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
+// #endif
+
+    if( i_data_len > 15 )
+    {
+       MP4_GET4BYTES( p_trkn->track_total );
+
+// #ifdef MP4_VERBOSE
+//         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
+// #endif
+
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
+   p_box->data.p_sample_soun->qt_description = 0;
+
+   /* Sanity check needed because the "wave" box does also contain an
+   * "mp4a" box that we don't understand. */
+   if( i_read < 28 )
+   {
+      i_read -= 30;
+      MP4_READBOX_EXIT( 1 );
+   }
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   p_box->data.p_sample_soun->qt_description = 0;
+   p_box->data.p_sample_soun->p_qt_description = NULL;
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
+      if( p_box->data.p_sample_soun->p_qt_description )
+      {
+         p_box->data.p_sample_soun->qt_description = i_read;
+         memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
+      }
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
+
+   if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
+   {
+      /* SoundDescriptionV1 */
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
+
+#ifdef MP4_VERBOSE
+       printf(
+         "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
+         "bytes/frame=%d bytes/sample=%d",
+         p_box->data.p_sample_soun->i_sample_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_frame,
+         p_box->data.p_sample_soun->i_bytes_per_sample );
+#endif
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 44, SEEK_SET );
+   }
+   else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
+   {
+      /* SoundDescriptionV2 */
+      double f_sample_rate;
+      int64_t dummy;
+      uint32_t i_channel;
+
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET8BYTES( dummy );
+      memcpy( &f_sample_rate, &dummy, 8 );
+
+       printf( "read box: %f Hz", f_sample_rate );
+      p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
+      p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
+
+      MP4_GET4BYTES( i_channel );
+      p_box->data.p_sample_soun->channelcount = i_channel;
+
+#ifdef MP4_VERBOSE
+       printf( "read box: \"soun\" V2" );
+#endif
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
+   }
+   else
+   {
+      p_box->data.p_sample_soun->sample_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_frame = 0;
+      p_box->data.p_sample_soun->bytes_per_sample = 0;
+
+#ifdef MP4_VERBOSE
+       printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
+         i_read );
+#endif
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28, SEEK_SET );
+   }
+
+   if( p_box->i_type == ATOM_drms )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_soun->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
+   {
+      /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
+      p_box->data.p_sample_soun->channelcount = 1;
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"soun\" in stsd channel %d "
+      "sample size %d sample rate %f",
+      p_box->data.p_sample_soun->channelcount,
+      p_box->data.p_sample_soun->samplesize,
+      (float)p_box->data.p_sample_soun->sampleratehi +
+      (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+/*****************************************************************************
+* aes_s: AES keys structure
+*****************************************************************************
+* This structure stores a set of keys usable for encryption and decryption
+* with the AES/Rijndael algorithm.
+*****************************************************************************/
+#define AES_KEY_COUNT 10
+#define PATH_MAX 260
+struct aes_s
+{
+   uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+   uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+};
+
+/*****************************************************************************
+* drms_s: DRMS structure
+*****************************************************************************
+* This structure stores the static information needed to decrypt DRMS data.
+*****************************************************************************/
+struct drms_s
+{
+   uint32_t i_user;
+   uint32_t i_key;
+   uint8_t  p_iviv[ 16 ];
+   uint8_t *p_name;
+
+   uint32_t p_key[ 4 ];
+   struct aes_s aes;
+
+   char     psz_homedir[ PATH_MAX ];
+};
+
+/*****************************************************************************
+* drms_free: free a previously allocated DRMS structure
+*****************************************************************************/
+void drms_free( void *_p_drms )
+{
+   struct drms_s *p_drms = (struct drms_s *)_p_drms;
+
+   //free( (void *)p_drms->p_name );
+   free( p_drms->p_name );
+   free( p_drms );
+}
+
+
+static void MP4_FreeBox_sample_soun( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_sample_soun->p_qt_description );
+
+   if( p_box->i_type == ATOM_drms )
+   {
+      if( p_box->data.p_sample_soun->drms )
+      {
+         drms_free( p_box->data.p_sample_soun->drms );
+      }
+   }
+}
+
+
+int MP4_ReadBox_sample_vide( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
+      if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
+         MP4_READBOX_EXIT( 0 );
+      p_box->data.p_sample_vide->qt_image_description = i_read;
+      memcpy( p_box->data.p_sample_vide->p_qt_image_description,
+         p_peek, i_read );
+   }
+   else
+   {
+      p_box->data.p_sample_vide->qt_image_description = 0;
+      p_box->data.p_sample_vide->p_qt_image_description = NULL;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->width );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->height );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
+
+   memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
+   p_peek += 32; i_read -= 32;
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
+
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
+
+   if( p_box->i_type == ATOM_drmi )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_vide->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"vide\" in stsd %dx%d depth %d",
+      p_box->data.p_sample_vide->width,
+      p_box->data.p_sample_vide->height,
+      p_box->data.p_sample_vide->depth );
+
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+void MP4_FreeBox_sample_vide( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
+
+   if( p_box->i_type == ATOM_drmi )
+   {
+      if( p_box->data.p_sample_vide->drms )
+      {
+         drms_free( p_box->data.p_sample_vide->drms );
+      }
+   }
+}
+
+
+int MP4_ReadBox_sample_mmth( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   unsigned int  mmth_buf;
+   int j;
+   MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
+
+
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
+   MP4_GET1BYTE(mmth_buf);
+   p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
+   p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
+   p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
+
+   /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
+   p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
+   for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
+	  {
+
+	   MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
+	  }*/
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_mp4s( stream_t *p_stream, mp4_box_t *p_box )
+{
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
+   return 1;
+}
+
+static int MP4_ReadBox_sample_text( stream_t *p_stream, mp4_box_t *p_box )
+{
+   int32_t t;
+
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+   MP4_GET4BYTES( t );
+   switch( t )
+   {
+      /* FIXME search right signification */
+   case 1: // Center
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = 1;
+      break;
+   case -1:    // Flush Right
+      p_box->data.p_sample_text->justification_horizontal = -1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   case -2:    // Flush p_first
+      p_box->data.p_sample_text->justification_horizontal = 0;
+      p_box->data.p_sample_text->justification_vertical = 0;
+      break;
+   case 0: // Flush Default
+   default:
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
+   p_box->data.p_sample_text->background_color[3] = 0;
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"text\" in stsd text" );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
+
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"tx3g\" in stsd text" );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+#if 0
+/* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */
+static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_sample_text->psz_text_name );
+}
+#endif
+
+
+static int MP4_ReadBox_stsd( stream_t *p_stream, mp4_box_t *p_box )
+{
+
+   MP4_READBOX_ENTER( mp4_box_data_stsd_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
+
+   MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
+
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsd\" entry-count %d",
+      p_box->data.p_stsd->entry_count );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stsz( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsz_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
+
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
+
+   if( p_box->data.p_stsz->sample_size == 0 )
+   {
+      p_box->data.p_stsz->entry_size =
+         calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
+      if( unlikely( !p_box->data.p_stsz->entry_size ) )
+         MP4_READBOX_EXIT( 0 );
+
+      for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
+      {
+         MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
+      }
+   }
+   else
+      p_box->data.p_stsz->entry_size = NULL;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsz\" sample-size %d sample-count %d",
+      p_box->data.p_stsz->sample_size,
+      p_box->data.p_stsz->sample_count );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stsz( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_stsz->entry_size );
+}
+
+static void MP4_FreeBox_stsc( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_stsc->first_chunk );
+   FREENULL( p_box->data.p_stsc->samples_per_chunk );
+   FREENULL( p_box->data.p_stsc->sample_description_index );
+}
+
+static int MP4_ReadBox_stsc( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsc_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
+
+   MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
+
+   p_box->data.p_stsc->first_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->samples_per_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->sample_description_index =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stsc->first_chunk == NULL
+      || p_box->data.p_stsc->samples_per_chunk == NULL
+      || p_box->data.p_stsc->sample_description_index == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsc\" entry-count %d",
+      p_box->data.p_stsc->entry_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_stco_co64( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_co64_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
+
+   MP4_GET4BYTES( p_box->data.p_co64->entry_count );
+
+   p_box->data.p_co64->chunk_offset =
+      calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
+   if( p_box->data.p_co64->chunk_offset == NULL )
+      MP4_READBOX_EXIT( 0 );
+
+   for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
+   {
+      if( p_box->i_type == ATOM_stco )
+      {
+         if( i_read < 4 )
+         {
+            break;
+         }
+         MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+      else
+      {
+         if( i_read < 8 )
+         {
+            break;
+         }
+         MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"co64\" entry-count %d",
+      p_box->data.p_co64->entry_count );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stco_co64( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_co64->chunk_offset );
+}
+
+static int MP4_ReadBox_stss( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stss_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stss );
+
+   MP4_GET4BYTES( p_box->data.p_stss->entry_count );
+
+   p_box->data.p_stss->sample_number =
+      calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
+      MP4_READBOX_EXIT( 0 );
+
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
+   {
+
+      MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
+      /* XXX in libmp4 sample begin at 0 */
+      p_box->data.p_stss->sample_number[i]--;
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stss\" entry-count %d",
+      p_box->data.p_stss->i_entry_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stss( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_stss->sample_number );
+}
+
+static void MP4_FreeBox_stsh( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_stsh->shadowed_sample_number );
+   FREENULL( p_box->data.p_stsh->sync_sample_number );
+}
+
+static int MP4_ReadBox_stsh( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsh_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
+
+
+   MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
+
+   p_box->data.p_stsh->shadowed_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsh->sync_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+
+   if( p_box->data.p_stsh->shadowed_sample_number == NULL
+      || p_box->data.p_stsh->sync_sample_number == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
+      MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsh\" entry-count %d",
+      p_box->data.p_stsh->i_entry_count );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stdp( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stdp_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
+
+   p_box->data.p_stdp->priority =
+      calloc( i_read / 2, sizeof(uint16_t) );
+
+   if( unlikely( !p_box->data.p_stdp->priority ) )
+      MP4_READBOX_EXIT( 0 );
+
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+      i_read / 2 );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stdp( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_stdp->priority );
+}
+
+static void MP4_FreeBox_padb( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_padb->reserved1 );
+   FREENULL( p_box->data.p_padb->pad2 );
+   FREENULL( p_box->data.p_padb->reserved2 );
+   FREENULL( p_box->data.p_padb->pad1 );
+}
+
+static int MP4_ReadBox_padb( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint32_t count;
+   unsigned int i = 0;
+
+   MP4_READBOX_ENTER( mp4_box_data_padb_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_padb );
+
+   MP4_GET4BYTES( p_box->data.p_padb->sample_count );
+   count = (p_box->data.p_padb->sample_count + 1) / 2;
+
+   p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
+   if( p_box->data.p_padb->reserved1 == NULL
+      || p_box->data.p_padb->pad2 == NULL
+      || p_box->data.p_padb->reserved2 == NULL
+      || p_box->data.p_padb->pad1 == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      if( i >= count )
+      {
+         MP4_READBOX_EXIT( 0 );
+      }
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
+      p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
+      p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
+
+      p_peek += 1; i_read -= 1;
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+      i_read / 2 );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_elst( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_elst->segment_duration );
+   FREENULL( p_box->data.p_elst->media_time );
+   FREENULL( p_box->data.p_elst->media_rate_integer );
+   FREENULL( p_box->data.p_elst->media_rate_fraction );
+}
+
+static int MP4_ReadBox_elst( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_elst_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_elst );
+
+
+   MP4_GET4BYTES( p_box->data.p_elst->entry_count );
+
+   p_box->data.p_elst->segment_duration =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_time =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_rate_integer =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   p_box->data.p_elst->media_rate_fraction =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   if( p_box->data.p_elst->segment_duration == NULL
+      || p_box->data.p_elst->media_time == NULL
+      || p_box->data.p_elst->media_rate_integer == NULL
+      || p_box->data.p_elst->media_rate_fraction == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+
+   for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
+   {
+      if( p_box->data.p_elst->version == 1 )
+      {
+
+         MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
+
+         MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
+      }
+      else
+      {
+
+         MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
+
+         MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
+         p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
+      }
+
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"elst\" entry-count %lu",
+      (unsigned long)p_box->data.p_elst->entry_count );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i_language;
+   unsigned int i = 0;
+
+   MP4_READBOX_ENTER( mp4_box_data_cprt_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
+
+   i_language = SwapBE16( (uint16_t)p_peek );
+   for( i = 0; i < 3; i++ )
+   {
+      p_box->data.p_cprt->language[i] =
+         ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+   }
+   p_peek += 2; i_read -= 2;
+   MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cprt\" language %c%c%c notice %s",
+      p_box->data.p_cprt->language[0],
+      p_box->data.p_cprt->language[1],
+      p_box->data.p_cprt->language[2],
+      p_box->data.p_cprt->psz_notice );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_cprt( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_cprt->psz_notice );
+}
+
+
+static int MP4_ReadBox_dcom( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_dcom_t );
+
+   MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"dcom\" compression algorithm : %4.4s",
+      (char*)&p_box->data.p_dcom->algorithm );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cmvd( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
+
+   MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
+
+   p_box->data.p_cmvd->compressed_size = i_read;
+
+   if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
+      MP4_READBOX_EXIT( 0 );
+
+   /* now copy compressed data */
+   memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
+
+   p_box->data.p_cmvd->b_compressed = 1;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmvd\" compressed data size %d",
+      p_box->data.p_cmvd->compressed_size );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_cmvd( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_cmvd->data );
+}
+
+
+static int MP4_ReadBox_cmov( stream_t *p_stream, mp4_box_t *p_box )
+{
+   mp4_box_t *p_dcom;
+   mp4_box_t *p_cmvd;
+
+#ifdef HAVE_ZLIB_H
+   stream_t *p_stream_memory;
+   z_stream z_data;
+   uint8_t *p_data;
+   int i_result;
+#endif
+
+   if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
+      return 0;
+
+   if( !p_box->p_father ||
+      ( p_box->p_father->i_type != ATOM_moov &&
+      p_box->p_father->i_type != ATOM_foov ) )
+   {
+      printf( "Read box: \"cmov\" box alone" );
+      return 1;
+   }
+
+   if( !MP4_ReadBoxContainer( p_stream, p_box ) )
+   {
+      return 0;
+   }
+
+   if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
+      ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
+      p_cmvd->data.p_cmvd->data == NULL )
+   {
+      printf( "read box: \"cmov\" incomplete" );
+      return 0;
+   }
+
+   if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
+   {
+      printf( "read box: \"cmov\" compression algorithm : %4.4s "
+         "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
+      return 0;
+   }
+
+#ifndef HAVE_ZLIB_H
+   printf(  "read box: \"cmov\" zlib unsupported" );
+   return 0;
+#else
+
+   /* decompress data */
+   /* allocate a new buffer */
+   if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
+      return 0;
+   /* init default structures */
+   z_data.next_in   = p_cmvd->data.p_cmvd->data;
+   z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
+   z_data.next_out  = p_data;
+   z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
+   z_data.zalloc    = (alloc_func)Z_NULL;
+   z_data.zfree     = (free_func)Z_NULL;
+   z_data.opaque    = (voidpf)Z_NULL;
+
+   /* init zlib */
+   if( inflateInit( &z_data ) != Z_OK )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   /* uncompress */
+   i_result = inflate( &z_data, Z_NO_FLUSH );
+   if( i_result != Z_OK && i_result != Z_STREAM_END )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
+   {
+      printf( "read box: \"cmov\" uncompressing data size "
+         "mismatch" );
+   }
+   p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
+
+   /* close zlib */
+   if( inflateEnd( &z_data ) != Z_OK )
+   {
+      printf( "read box: \"cmov\" error while uncompressing "
+         "data (ignored)" );
+   }
+
+   free( p_cmvd->data.p_cmvd->p_data );
+   p_cmvd->data.p_cmvd->data = p_data;
+   p_cmvd->data.p_cmvd->b_compressed = 0;
+
+    printf( "read box: \"cmov\" box successfully uncompressed" );
+
+   /* now create a memory stream */
+   p_stream_memory =
+      stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
+      p_cmvd->data.p_cmvd->uncompressed_size, true );
+
+   /* and read uncompressd moov */
+   p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
+
+   stream_Delete( p_stream_memory );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmov\" compressed movie header completed");
+#endif
+
+   return p_box->data.p_cmov->moov ? 1 : 0;
+#endif /* HAVE_ZLIB_H */
+}
+
+static int MP4_ReadBox_rdrf( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint32_t i_len;
+   unsigned i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
+   MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
+   MP4_GET4BYTES( i_len );
+   i_len++;
+
+   if( i_len > 0 )
+   {
+      p_box->data.p_rdrf->psz_ref = malloc( i_len );
+      if( p_box->data.p_rdrf->psz_ref == NULL )
+         MP4_READBOX_EXIT( 0 );
+      i_len--;
+
+      for( i = 0; i < i_len; i++ )
+      {
+         MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
+      }
+      p_box->data.p_rdrf->psz_ref[i_len] = '\0';
+   }
+   else
+   {
+      p_box->data.p_rdrf->psz_ref = NULL;
+   }
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"rdrf\" type:%4.4s ref %s",
+      (char*)&p_box->data.p_rdrf->ref_type,
+      p_box->data.p_rdrf->psz_ref );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_rdrf( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_rdrf->psz_ref );
+}
+
+
+static int MP4_ReadBox_rmdr( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
+
+   MP4_GET4BYTES( p_box->data.p_rmdr->rate );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"rmdr\" rate:%d",
+      p_box->data.p_rmdr->rate );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmqu( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
+
+   MP4_GET4BYTES( p_box->data.p_rmqu->quality );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"rmqu\" quality:%d",
+      p_box->data.p_rmqu->quality );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmvc( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
+
+   MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
+   MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
+      (char*)&p_box->data.p_rmvc->gestaltType,
+      p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
+      p_box->data.p_rmvc->checkType );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_frma( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_frma_t );
+
+   MP4_GETFOURCC( p_box->data.p_frma->type );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"frma\" i_type:%4.4s",
+      (char *)&p_box->data.p_frma->i_type );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_skcr( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_skcr_t );
+
+   MP4_GET4BYTES( p_box->data.p_skcr->init );
+   MP4_GET4BYTES( p_box->data.p_skcr->encr );
+   MP4_GET4BYTES( p_box->data.p_skcr->decr );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"skcr\" i_init:%d i_encr:%d i_decr:%d",
+      p_box->data.p_skcr->init,
+      p_box->data.p_skcr->encr,
+      p_box->data.p_skcr->decr );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_drms( stream_t *p_stream, mp4_box_t *p_box )
+{
+   mp4_box_t *p_drms_box = p_box;
+   void *p_drms = NULL;
+
+   MP4_READBOX_ENTER( uint8_t );
+
+   do
+   {
+      p_drms_box = p_drms_box->p_father;
+   } while( p_drms_box && p_drms_box->i_type != ATOM_drms
+      && p_drms_box->i_type != ATOM_drmi );
+
+   if( p_drms_box && p_drms_box->i_type == ATOM_drms )
+      p_drms = p_drms_box->data.p_sample_soun->drms;
+   else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
+      p_drms = p_drms_box->data.p_sample_vide->drms;
+
+   if( p_drms_box && p_drms )
+   {
+      int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
+      if( i_ret )
+      {
+         assert(0);
+         //             const char *psz_error;
+         // 
+         //             switch( i_ret )
+         //             {
+         //                 case -1: psz_error = "unimplemented"; break;
+         //                 case -2: psz_error = "invalid argument"; break;
+         //                 case -3: psz_error = "could not get system key"; break;
+         //                 case -4: psz_error = "could not get SCI data"; break;
+         //                 case -5: psz_error = "no user key found in SCI data"; break;
+         //                 case -6: psz_error = "invalid user key"; break;
+         //                 default: psz_error = "unknown error"; break;
+         //             }
+         //             if MP4_BOX_TYPE_ASCII()
+         //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
+         //                         (char *)&p_box->i_type, psz_error );
+         //             else
+         //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
+         //                         (char *)&p_box->i_type+1, psz_error );
+         // 
+         //             drms_free( p_drms );
+         // 
+         //             if( p_drms_box->i_type == ATOM_drms )
+         //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
+         //             else if( p_drms_box->i_type == ATOM_drmi )
+         //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
+      }
+   }
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_name( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_name_t );
+
+   p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
+   if( p_box->data.p_name->psz_text == NULL )
+      MP4_READBOX_EXIT( 0 );
+
+   memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
+   p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"name\" text=`%s'",
+      p_box->data.p_name->psz_text );
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_name( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_name->psz_text );
+}
+
+static int MP4_ReadBox_0xa9xxx( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint16_t i16;
+
+   MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
+
+   p_box->data.p_0xa9xxx->psz_text = NULL;
+
+   MP4_GET2BYTES( i16 );
+
+   if( i16 > 0 )
+   {
+      int i_length = i16;
+
+      MP4_GET2BYTES( i16 );
+      if( i_length >= i_read ) i_length = i_read + 1;
+
+      p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
+      if( p_box->data.p_0xa9xxx->psz_text == NULL )
+         MP4_READBOX_EXIT( 0 );
+
+      i_length--;
+      memcpy( p_box->data.p_0xa9xxx->psz_text,
+         p_peek, i_length );
+      p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
+
+#ifdef MP4_VERBOSE
+       printf(
+         "read box: \"c%3.3s\" text=`%s'",
+         ((char*)&p_box->i_type + 1),
+         p_box->data.p_0xa9xxx->psz_text );
+#endif
+   }
+   else
+   {
+      uint32_t i_data_len;
+      uint32_t i_data_tag;
+      /* try iTune/Quicktime format, rewind to start */
+      p_peek -= 2; i_read += 2;
+      // we are expecting a 'data' box
+
+      MP4_GET4BYTES( i_data_len );
+      if( i_data_len > i_read ) i_data_len = i_read;
+      MP4_GETFOURCC( i_data_tag );
+      if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
+      {
+         /* data box contains a version/flags field */
+         uint32_t i_version;
+         uint32_t i_reserved;
+         MP4_GET4BYTES( i_version );
+         MP4_GET4BYTES( i_reserved );
+         // version should be 0, flags should be 1 for text, 0 for data
+         if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
+         {
+            // the rest is the text
+            i_data_len -= 12;
+            p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
+            if( p_box->data.p_0xa9xxx->psz_text == NULL )
+               MP4_READBOX_EXIT( 0 );
+
+            memcpy( p_box->data.p_0xa9xxx->psz_text,
+               p_peek, i_data_len );
+            p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
+#ifdef MP4_VERBOSE
+             printf(
+               "read box: \"c%3.3s\" text=`%s'",
+               ((char*)&p_box->i_type+1),
+               p_box->data.p_0xa9xxx->psz_text );
+#endif
+         }
+         else
+         {
+            // TODO: handle data values for ID3 tag values, track num or cover art,etc...
+         }
+      }
+   }
+
+   MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_0xa9xxx( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_0xa9xxx->psz_text );
+}
+
+/* Chapter support */
+static void MP4_FreeBox_chpl( mp4_box_t *p_box )
+{
+   mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
+   unsigned int i;
+   for(  i = 0; i < p_chpl->chapter; i++ )
+      free( p_chpl->p_chapter[i].psz_name );
+}
+
+static int MP4_ReadBox_chpl( stream_t *p_stream, mp4_box_t *p_box )
+{
+   mp4_box_data_chpl_t *p_chpl;
+   uint32_t i_dummy;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_chpl_t );
+
+   p_chpl = p_box->data.p_chpl;
+
+   MP4_GETVERSIONFLAGS( p_chpl );
+
+   MP4_GET4BYTES( i_dummy );
+
+   MP4_GET1BYTE( p_chpl->chapter );
+
+   for( i = 0; i < p_chpl->chapter; i++ )
+   {
+      uint64_t i_start;
+      uint8_t i_len;
+      int i_copy;
+      MP4_GET8BYTES( i_start );
+      MP4_GET1BYTE( i_len );
+
+      p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
+      if( !p_chpl->p_chapter[i].psz_name )
+         MP4_READBOX_EXIT( 0 );
+
+      i_copy = min( i_len, i_read );
+      if( i_copy > 0 )
+         memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
+      p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
+      p_chpl->p_chapter[i].start = i_start;
+
+      p_peek += i_copy;
+      i_read -= i_copy;
+   }
+   /* Bubble sort by increasing start date */
+   do
+   {
+      for( i = 0; i < p_chpl->chapter - 1; i++ )
+      {
+         if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
+         {
+            char *psz = p_chpl->p_chapter[i+1].psz_name;
+            int64_t i64 = p_chpl->p_chapter[i+1].start;
+
+            p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
+            p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
+
+            p_chpl->p_chapter[i].psz_name = psz;
+            p_chpl->p_chapter[i].start = i64;
+
+            i = -1;
+            break;
+         }
+      }
+   } while( i == -1 );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chpl\" %d chapters",
+      p_chpl->chapter );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tref_generic( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
+
+   p_box->data.p_tref_generic->track_ID = NULL;
+   p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
+   if( p_box->data.p_tref_generic->entry_count > 0 )
+      p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_tref_generic->track_ID == NULL )
+      MP4_READBOX_EXIT( 0 );
+
+   for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chap\" %d references",
+      p_box->data.p_tref_generic->entry_count );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_tref_generic( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_tref_generic->track_ID );
+}
+
+static int MP4_ReadBox_meta( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint8_t meta_data[8];
+   int i_actually_read;
+
+   // skip over box header
+   i_actually_read = stream_read( p_stream, meta_data, 8 );
+   if( i_actually_read < 8 )
+      return 0;
+
+   /* meta content starts with a 4 byte version/flags value (should be 0) */
+   i_actually_read = stream_read( p_stream, meta_data, 4 );
+   if( i_actually_read < 4 )
+      return 0;
+
+   /* then it behaves like a container */
+   return MP4_ReadBoxContainerRaw( p_stream, p_box );
+}
+
+static int MP4_ReadBox_iods( stream_t *p_stream, mp4_box_t *p_box )
+{
+   char i_unused;
+
+   MP4_READBOX_ENTER( mp4_box_data_iods_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_iods );
+
+   MP4_GET1BYTE( i_unused ); /* tag */
+   MP4_GET1BYTE( i_unused ); /* length */
+
+   MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
+                                                           are used for other flags */
+   MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
+      "visual: %i, graphics: %i",
+      p_box->data.p_iods->object_descriptor >> 6,
+      p_box->data.p_iods->OD_profile_level,
+      p_box->data.p_iods->scene_profile_level,
+      p_box->data.p_iods->audio_profile_level,
+      p_box->data.p_iods->visual_profile_level,
+      p_box->data.p_iods->graphics_profile_level );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_pasp( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_pasp_t );
+
+   MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
+   MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"paps\" %dx%d",
+      p_box->data.p_pasp->horizontal_spacing,
+      p_box->data.p_pasp->vertical_spacing);
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mehd( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_mehd_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
+   if( p_box->data.p_mehd->version == 1 )
+      MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
+   else /* version == 0 */
+      MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
+
+#ifdef MP4_VERBOSE
+    printf(
+      "read box: \"mehd\" frag dur. %"PRIu64"",
+      p_box->data.p_mehd->fragment_duration );
+#endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trex( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_trex_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_trex );
+
+   MP4_GET4BYTES( p_box->data.p_trex->track_ID );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
+
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"trex\" trackID: %"PRIu32"",
+   //              p_box->data.p_trex->track_ID );
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sdtp( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint32_t i_sample_count;
+   uint32_t i;
+   mp4_box_data_sdtp_t *p_sdtp = NULL;
+   MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
+   p_sdtp = p_box->data.p_sdtp;
+   MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
+   i_sample_count = i_read;
+
+   p_sdtp->sample_table = calloc( i_sample_count, 1 );
+
+   if( !p_sdtp->sample_table )
+      MP4_READBOX_EXIT( 0 );
+
+   for( i = 0; i < i_sample_count; i++ )
+      MP4_GET1BYTE( p_sdtp->sample_table[i] );
+
+   // #ifdef MP4_VERBOSE
+   //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
+   //      printf(
+   //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
+   //                  p_sdtp->sample_table[0],
+   //                  p_sdtp->sample_table[1],
+   //                  p_sdtp->sample_table[2],
+   //                  p_sdtp->sample_table[3] );
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_sdtp( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_sdtp->sample_table );
+}
+
+static int MP4_ReadBox_mfro( stream_t *p_stream, mp4_box_t *p_box )
+{
+   MP4_READBOX_ENTER( mp4_box_data_mfro_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
+   MP4_GET4BYTES( p_box->data.p_mfro->size );
+
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"mfro\" size: %"PRIu32"",
+   //              p_box->data.p_mfro->i_size);
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfra( stream_t *p_stream, mp4_box_t *p_box )
+{
+   uint32_t i_number_of_entries;
+   mp4_box_data_tfra_t *p_tfra;
+   uint32_t i_lengths;
+   size_t size;
+   uint32_t i;
+   MP4_READBOX_ENTER( mp4_box_data_tfra_t );
+   p_tfra = p_box->data.p_tfra;
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
+
+   MP4_GET4BYTES( p_tfra->track_ID );
+   i_lengths = 0;
+   MP4_GET4BYTES( i_lengths );
+   MP4_GET4BYTES( p_tfra->number_of_entries );
+   i_number_of_entries = p_tfra->number_of_entries;
+   p_tfra->length_size_of_traf_num = i_lengths >> 4;
+   p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
+   p_tfra->length_size_of_sample_num = i_lengths & 0x03;
+
+   size = 4 + 4*p_tfra->version; /* size in {4, 8} */
+   p_tfra->time = calloc( i_number_of_entries, size );
+   p_tfra->moof_offset = calloc( i_number_of_entries, size );
+
+   size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
+   p_tfra->traf_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_trun_num;
+   p_tfra->trun_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_sample_num;
+   p_tfra->sample_number = calloc( i_number_of_entries, size );
+
+   if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
+      || !p_tfra->trun_number || !p_tfra->sample_number )
+      goto error;
+
+   for( i = 0; i < i_number_of_entries; i++ )
+   {
+      if( p_tfra->version == 1 )
+      {
+         MP4_GET8BYTES( p_tfra->time[i*2] );
+         MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
+      }
+      else
+      {
+         MP4_GET4BYTES( p_tfra->time[i] );
+         MP4_GET4BYTES( p_tfra->moof_offset[i] );
+      }
+      switch (p_tfra->length_size_of_traf_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->traf_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->traf_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->traf_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->traf_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_trun_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->trun_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->trun_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->trun_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->trun_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_sample_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->sample_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->sample_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->sample_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->sample_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+   }
+
+   // #ifdef MP4_VERBOSE
+   //     if( p_tfra->version == 0 )
+   //     {
+   //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
+   //                          p_tfra->time[0], p_tfra->moof_offset[0] );
+   // 
+   //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
+   //                          p_tfra->time[1], p_tfra->moof_offset[1] );
+   //     }
+   //     else
+   //     {
+   //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[0],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
+   // 
+   //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[1],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
+   //     }
+   // 
+   //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
+   //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
+error:
+   MP4_READBOX_EXIT( 0 );
+}
+
+static void MP4_FreeBox_tfra( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_tfra->time );
+   FREENULL( p_box->data.p_tfra->moof_offset );
+   FREENULL( p_box->data.p_tfra->traf_number );
+   FREENULL( p_box->data.p_tfra->trun_number );
+   FREENULL( p_box->data.p_tfra->sample_number );
+}
+
+
+/* For generic */
+static int MP4_ReadBox_default( stream_t *p_stream, mp4_box_t *p_box )
+{
+   if( !p_box->p_father )
+   {
+      goto unknown;
+   }
+   if( p_box->p_father->i_type == ATOM_stsd )
+   {
+      mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
+      mp4_box_t *p_hdlr;
+
+      if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
+         (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
+      {
+         goto unknown;
+      }
+      switch( p_hdlr->data.p_hdlr->handler_type )
+      {
+      case ATOM_soun:
+         return MP4_ReadBox_sample_soun( p_stream, p_box );
+      case ATOM_vide:
+         return MP4_ReadBox_sample_vide( p_stream, p_box );
+      case ATOM_text:
+         return MP4_ReadBox_sample_text( p_stream, p_box );
+      case ATOM_mmth:
+         return MP4_ReadBox_sample_mmth( p_stream, p_box );
+      case ATOM_tx3g:
+      case ATOM_sbtl:
+         return MP4_ReadBox_sample_tx3g( p_stream, p_box );
+      default:
+    	  printf(
+            "unknown handler type in stsd (incompletely loaded1)" );
+         return 1;
+      }
+   }
+
+unknown:
+   if MP4_BOX_TYPE_ASCII()
+      printf(
+      "unknown box type %4.4s (incompletely loaded2)",
+      (char*)&p_box->i_type );
+   else
+	   printf(
+      "unknown box type c%3.3s (incompletely loaded3)",
+      (char*)&p_box->i_type+1 );
+
+   return 1;
+}
+
+static const struct
+{
+   uint32_t i_type;
+   int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
+   void (*MP4_FreeBox_function )( mp4_box_t *p_box );
+} MP4_Box_Function [] =
+{
+   /* Containers */
+   { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+
+   /* specific box */
+   { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
+   { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
+   { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
+   { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
+   { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
+   { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
+   { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
+   { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
+   { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
+   { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
+   { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
+   { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
+   { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
+   { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
+   { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
+   { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
+   { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
+   { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
+   { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
+   { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
+   { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
+   { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
+   { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
+   { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
+   { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
+   { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
+   { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
+   { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
+   { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
+   { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
+   { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
+   { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
+   { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
+   { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
+   { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
+   { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
+
+   /* Nothing to do with this box */
+   { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+
+   /* for codecs */
+   { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+
+   { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
+   { ATOM_mjht,    MP4_ReadBox_default,      NULL },
+
+   { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
+
+   /* XXX there is 2 box where we could find this entry stbl and tref*/
+   { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
+   { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
+
+   /* found in tref box */
+   { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
+   { ATOM_ipir,    MP4_ReadBox_default,      NULL },
+   { ATOM_mpod,    MP4_ReadBox_default,      NULL },
+   { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
+
+   /* found in hnti */
+   { ATOM_rtp,     MP4_ReadBox_default,      NULL },
+
+   /* found in rmra */
+   { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
+   { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
+   { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
+   { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
+
+   { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
+   { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
+
+   /* found in udta */
+   { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+
+   { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
+
+   /* iTunes/Quicktime meta info */
+   { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
+   { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
+
+   /* found in smoothstreaming */
+   { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
+   { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
+   { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
+   { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
+   { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
+   { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
+   { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
+   { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
+
+   { ATOM_pitm,    MP4_ReadBox_pitm,         MP4_FreeBox_Common},
+   { ATOM_iloc,    MP4_ReadBox_iloc,         MP4_FreeBox_iloc},
+   { ATOM_iinf,    MP4_ReadBox_iinf,         MP4_FreeBox_Common},
+   { ATOM_infe,    MP4_ReadBox_infe,         MP4_FreeBox_infe},
+   { ATOM_idat,    MP4_ReadBox_idat,         MP4_FreeBox_idat},
+   /* Last entry */
+   { 0,              MP4_ReadBox_default,      NULL }
+};
+
+
+//get full struct of the mp4,main function
+mp4_box_t *MP4_BoxGetRoot(stream_t * s)
+{
+   mp4_box_t *p_root;
+   stream_t *p_stream;
+   int i_result;
+
+   p_root = malloc( sizeof( mp4_box_t ) );
+   if( p_root == NULL )
+      return NULL;
+
+   p_root->i_pos = 0;
+   p_root->i_type = ATOM_root;
+   p_root->i_shortsize = 1;
+
+   stream_seek(s, 0, SEEK_END);
+   p_root->i_size = stream_tell(s);
+   stream_seek(s, 0, SEEK_SET);
+
+   CreateUUID( &p_root->i_uuid, p_root->i_type );
+
+   //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
+   p_root->data.p_data = NULL;
+   p_root->p_father    = NULL;
+   p_root->p_first     = NULL;
+   p_root->p_last      = NULL;
+   p_root->p_next      = NULL;
+
+   p_stream = s;
+
+   i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
+
+   if( i_result )
+   {
+      mp4_box_t *p_moov;
+      mp4_box_t *p_cmov;
+
+      /* check if there is a cmov, if so replace
+      compressed moov by  uncompressed one */
+      if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
+         ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
+      {
+         /* rename the compressed moov as a box to skip */
+         p_moov->i_type = ATOM_skip;
+
+         /* get uncompressed p_moov */
+         p_moov = p_cmov->data.p_cmov->moov;
+         p_cmov->data.p_cmov->moov = NULL;
+
+         /* make p_root father of this new moov */
+         p_moov->p_father = p_root;
+
+         /* insert this new moov box as first child of p_root */
+         p_moov->p_next = p_root->p_first;
+         p_root->p_first = p_moov;
+      }
+   }
+
+   return p_root;
+}
+
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
+{
+	//mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+	mp4_box_t *cur = p_head;
+
+    while (cur != NULL)
+    {
+		if (cur->i_type==ATOM_moov||cur->i_type==ATOM_trak||cur->i_type==ATOM_mdia||cur->i_type==ATOM_moof \
+			||cur->i_type==ATOM_minf||cur->i_type==ATOM_stbl||cur->i_type==ATOM_dinf||cur->i_type==ATOM_edts \
+			||cur->i_type==ATOM_udta||cur->i_type==ATOM_nmhd||cur->i_type==ATOM_hnti||cur->i_type==ATOM_rmra \
+			||cur->i_type==ATOM_rmda||cur->i_type==ATOM_tref||cur->i_type==ATOM_gmhd||cur->i_type==ATOM_wave \
+			||cur->i_type==ATOM_ilst||cur->i_type==ATOM_mvex||cur->i_type==ATOM_stsd||cur->i_type==ATOM_tref \
+			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root\
+			||cur->i_type==ATOM_meta||cur->i_type==ATOM_iinf)
+        {
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type==i_type)
+				return cur;
+        	 // find predecessor
+			else {
+				cur = cur->p_first;
+				return MP4_BoxSearchBox(cur, i_type);
+			}
+        }
+        else
+        {
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type == i_type)
+				{
+					return(cur); /*Find the box*/
+				}
+            else 
+				if(cur->p_next)
+					cur = cur->p_next;
+				else if(cur->p_father->p_next)
+					cur = cur->p_father->p_next;
+                else if (cur->p_father->p_father) {
+	                mp4_box_t* parent = cur->p_father->p_father;
+                    cur = NULL;
+                    do {
+                        if (parent->p_next) {
+                            cur = parent->p_next;
+                            break;
+                        }
+                        parent = parent->p_father;
+                    }while(parent);
+
+				    if(!cur) {
+					    printf("Format not supported!\n");
+					    return NULL;
+				    }
+                }else {
+					printf("Format not supported!\n");
+					return NULL;
+				}
+
+        }
+    }
+    return(NULL);
+}
+/*****************************************************************************
+* MP4_ReadBox : parse the actual box and the children
+*  XXX : Do not go to the next box
+*****************************************************************************/
+mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
+{
+   mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+   unsigned int i_index;
+
+   if( p_box == NULL )
+      return NULL;
+
+   if( !MP4_ReadBoxCommon( p_stream, p_box ) )
+   {
+      printf( "cannot read one box" );
+      free( p_box );
+      return NULL;
+   }
+   if( !p_box->i_size )
+   {
+       printf( "found an empty box (null size)" );
+      free( p_box );
+      return NULL;
+   }
+   p_box->p_father = p_father;
+
+   /* Now search function to call */
+   for( i_index = 0; ; i_index++ )
+   {
+      if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+         ( MP4_Box_Function[i_index].i_type == 0 ) )
+      {
+         break;
+      }
+   }
+
+   if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
+   {
+      MP4_BoxFree( p_stream, p_box );
+      return NULL;
+   }
+
+   return p_box;
+}
+
+void MP4_BoxFree( stream_t *s, mp4_box_t *p_box )
+{
+   unsigned int i_index;
+   mp4_box_t    *p_child;
+
+   if( !p_box )
+      return; /* hehe */
+
+   for( p_child = p_box->p_first; p_child != NULL; )
+   {
+      mp4_box_t *p_next;
+
+      p_next = p_child->p_next;
+      MP4_BoxFree( s, p_child );
+      p_child = p_next;
+   }
+
+   /* Now search function to call */
+   if( p_box->data.p_data )
+   {
+      for( i_index = 0; ; i_index++ )
+      {
+         if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+            ( MP4_Box_Function[i_index].i_type == 0 ) )
+         {
+            break;
+         }
+      }
+      if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
+      {
+         /* Should not happen */
+         if MP4_BOX_TYPE_ASCII()
+		printf(
+            "cannot free box %4.4s, type unknown",
+            (char*)&p_box->i_type );
+         else
+        	 printf(
+            "cannot free box c%3.3s, type unknown",
+            (char*)&p_box->i_type+1 );
+      }
+      else
+      {
+         MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
+      }
+      free( p_box->data.p_data );
+   }
+   free( p_box );
+}
+
+/*****************************************************************************
+*****************************************************************************
+**
+**  High level methods to acces an MP4 file
+**
+*****************************************************************************
+*****************************************************************************/
+static void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )
+{
+   size_t i_len ;
+   if( !*ppsz_path[0] )
+   {
+      *ppsz_token = NULL;
+      *pi_number = 0;
+      return;
+   }
+   i_len = strcspn( *ppsz_path, "/[" );
+   if( !i_len && **ppsz_path == '/' )
+   {
+      i_len = 1;
+   }
+   *ppsz_token = malloc( i_len + 1 );
+
+   memcpy( *ppsz_token, *ppsz_path, i_len );
+
+   (*ppsz_token)[i_len] = '\0';
+
+   *ppsz_path += i_len;
+
+   if( **ppsz_path == '[' )
+   {
+      (*ppsz_path)++;
+      *pi_number = strtol( *ppsz_path, NULL, 10 );
+      while( **ppsz_path && **ppsz_path != ']' )
+      {
+         (*ppsz_path)++;
+      }
+      if( **ppsz_path == ']' )
+      {
+         (*ppsz_path)++;
+      }
+   }
+   else
+   {
+      *pi_number = 0;
+   }
+   while( **ppsz_path == '/' )
+   {
+      (*ppsz_path)++;
+   }
+}
+
+static void MP4_BoxGet_Internal(mp4_box_t **pp_result,
+   mp4_box_t *p_box, const char *psz_fmt, va_list args)
+{
+   char *psz_dup;
+   char *psz_path = malloc(4096);
+   char *psz_token;
+
+   if( !p_box )
+   {
+      *pp_result = NULL;
+      return;
+   }
+
+   if( vsprintf( psz_path, psz_fmt, args ) == -1 )
+      psz_path = NULL;
+
+   if( !psz_path || !psz_path[0] )
+   {
+      free( psz_path );
+      *pp_result = NULL;
+      return;
+   }
+
+   //    fprintf( stderr, "path:'%s'\n", psz_path );
+   psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
+   for( ; ; )
+   {
+      int i_number;
+
+      get_token( &psz_path, &psz_token, &i_number );
+      //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
+      //                 psz_path,psz_token,i_number );
+      if( !psz_token )
+      {
+         free( psz_dup );
+         *pp_result = p_box;
+         return;
+      }
+      else
+         if( !strcmp( psz_token, "/" ) )
+         {
+            /* Find root box */
+            while( p_box && p_box->i_type != ATOM_root )
+            {
+               p_box = p_box->p_father;
+            }
+            if( !p_box )
+            {
+               goto error_box;
+            }
+         }
+         else
+            if( !strcmp( psz_token, "." ) )
+            {
+               /* Do nothing */
+            }
+            else
+               if( !strcmp( psz_token, ".." ) )
+               {
+                  p_box = p_box->p_father;
+                  if( !p_box )
+                  {
+                     goto error_box;
+                  }
+               }
+               else
+                  if( strlen( psz_token ) == 4 )
+                  {
+                     uint32_t i_fourcc;
+                     i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
+                        psz_token[2], psz_token[3] );
+                     p_box = p_box->p_first;
+                     for( ; ; )
+                     {
+                        if( !p_box )
+                        {
+                           goto error_box;
+                        }
+                        if( p_box->i_type == i_fourcc )
+                        {
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
+                        }
+                        p_box = p_box->p_next;
+                     }
+                  }
+                  else
+                     if( *psz_token == '\0' )
+                     {
+                        p_box = p_box->p_first;
+                        for( ; ; )
+                        {
+                           if( !p_box )
+                           {
+                              goto error_box;
+                           }
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
+                           p_box = p_box->p_next;
+                        }
+                     }
+                     else
+                     {
+                        //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
+                        goto error_box;
+                     }
+
+                     FREENULL( psz_token );
+   }
+
+   return;
+
+error_box:
+   free( psz_token );
+   free( psz_dup );
+   *pp_result = NULL;
+   return;
+}
+
+mp4_box_t * MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...)
+{
+   va_list args;
+   mp4_box_t *p_result;
+
+   va_start( args, psz_fmt );
+   MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
+   va_end( args );
+
+   return( p_result );
+}
+
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
new file mode 100644
index 0000000..0f4624b
--- /dev/null
+++ b/net/mmt/mpu/mp4.h
@@ -0,0 +1,1278 @@
+#ifndef NET_MMT_MPU_MP4_H_
+#define NET_MMT_MPU_MP4_H_
+
+#include "stream.h"
+
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_tfdt MP4_FOURCC( 't', 'f', 'd', 't' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_foov MP4_FOURCC( 'f', 'o', 'o', 'v' )
+#define ATOM_cmov MP4_FOURCC( 'c', 'm', 'o', 'v' )
+#define ATOM_dcom MP4_FOURCC( 'd', 'c', 'o', 'm' )
+#define ATOM_cmvd MP4_FOURCC( 'c', 'm', 'v', 'd' )
+
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+#define ATOM_skip MP4_FOURCC( 's', 'k', 'i', 'p' )
+#define ATOM_free MP4_FOURCC( 'f', 'r', 'e', 'e' )
+#define ATOM_udta MP4_FOURCC( 'u', 'd', 't', 'a' )
+#define ATOM_wide MP4_FOURCC( 'w', 'i', 'd', 'e' )
+
+#define ATOM_data MP4_FOURCC( 'd', 'a', 't', 'a' )
+
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mvhd MP4_FOURCC( 'm', 'v', 'h', 'd' )
+#define ATOM_tkhd MP4_FOURCC( 't', 'k', 'h', 'd' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_tref MP4_FOURCC( 't', 'r', 'e', 'f' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_mdhd MP4_FOURCC( 'm', 'd', 'h', 'd' )
+#define ATOM_hdlr MP4_FOURCC( 'h', 'd', 'l', 'r' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_vmhd MP4_FOURCC( 'v', 'm', 'h', 'd' )
+#define ATOM_smhd MP4_FOURCC( 's', 'm', 'h', 'd' )
+#define ATOM_hmhd MP4_FOURCC( 'h', 'm', 'h', 'd' )
+#define ATOM_dinf MP4_FOURCC( 'd', 'i', 'n', 'f' )
+#define ATOM_url  MP4_FOURCC( 'u', 'r', 'l', ' ' )
+#define ATOM_urn  MP4_FOURCC( 'u', 'r', 'n', ' ' )
+#define ATOM_dref MP4_FOURCC( 'd', 'r', 'e', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stts MP4_FOURCC( 's', 't', 't', 's' )
+#define ATOM_ctts MP4_FOURCC( 'c', 't', 't', 's' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_stsz MP4_FOURCC( 's', 't', 's', 'z' )
+#define ATOM_stz2 MP4_FOURCC( 's', 't', 'z', '2' )
+#define ATOM_stsc MP4_FOURCC( 's', 't', 's', 'c' )
+#define ATOM_stco MP4_FOURCC( 's', 't', 'c', 'o' )
+#define ATOM_co64 MP4_FOURCC( 'c', 'o', '6', '4' )
+#define ATOM_stss MP4_FOURCC( 's', 't', 's', 's' )
+#define ATOM_stsh MP4_FOURCC( 's', 't', 's', 'h' )
+#define ATOM_stdp MP4_FOURCC( 's', 't', 'd', 'p' )
+#define ATOM_padb MP4_FOURCC( 'p', 'a', 'd', 'b' )
+#define ATOM_edts MP4_FOURCC( 'e', 'd', 't', 's' )
+#define ATOM_elst MP4_FOURCC( 'e', 'l', 's', 't' )
+#define ATOM_mvex MP4_FOURCC( 'm', 'v', 'e', 'x' )
+#define ATOM_sdtp MP4_FOURCC( 's', 'd', 't', 'p' )
+#define ATOM_trex MP4_FOURCC( 't', 'r', 'e', 'x' )
+#define ATOM_mehd MP4_FOURCC( 'm', 'e', 'h', 'd' )
+#define ATOM_mfhd MP4_FOURCC( 'm', 'f', 'h', 'd' )
+#define ATOM_traf MP4_FOURCC( 't', 'r', 'a', 'f' )
+#define ATOM_tfhd MP4_FOURCC( 't', 'f', 'h', 'd' )
+#define ATOM_trun MP4_FOURCC( 't', 'r', 'u', 'n' )
+#define ATOM_cprt MP4_FOURCC( 'c', 'p', 'r', 't' )
+#define ATOM_iods MP4_FOURCC( 'i', 'o', 'd', 's' )
+#define ATOM_pasp MP4_FOURCC( 'p', 'a', 's', 'p' )
+#define ATOM_mfra MP4_FOURCC( 'm', 'f', 'r', 'a' )
+#define ATOM_mfro MP4_FOURCC( 'm', 'f', 'r', 'o' )
+#define ATOM_tfra MP4_FOURCC( 't', 'f', 'r', 'a' )
+
+#define ATOM_nmhd MP4_FOURCC( 'n', 'm', 'h', 'd' )
+#define ATOM_mp2v MP4_FOURCC( 'm', 'p', '2', 'v' )
+#define ATOM_mp4v MP4_FOURCC( 'm', 'p', '4', 'v' )
+#define ATOM_mp4a MP4_FOURCC( 'm', 'p', '4', 'a' )
+#define ATOM_mp4s MP4_FOURCC( 'm', 'p', '4', 's' )
+#define ATOM_vide MP4_FOURCC( 'v', 'i', 'd', 'e' )
+#define ATOM_soun MP4_FOURCC( 's', 'o', 'u', 'n' )
+#define ATOM_mmth MP4_FOURCC( 'm', 'm', 't', 'h' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_hdv2 MP4_FOURCC( 'h', 'd', 'v', '2' )
+
+#define ATOM_dpnd MP4_FOURCC( 'd', 'p', 'n', 'd' )
+#define ATOM_ipir MP4_FOURCC( 'i', 'p', 'i', 'r' )
+#define ATOM_mpod MP4_FOURCC( 'm', 'p', 'o', 'd' )
+#define ATOM_hnti MP4_FOURCC( 'h', 'n', 't', 'i' )
+#define ATOM_rtp  MP4_FOURCC( 'r', 't', 'p', ' ' )
+
+#define ATOM_isom MP4_FOURCC( 'i', 's', 'o', 'm' )
+#define ATOM_3gp4 MP4_FOURCC( '3', 'g', 'p', '4' )
+#define ATOM_esds MP4_FOURCC( 'e', 's', 'd', 's' )
+
+#define ATOM__mp3 MP4_FOURCC( '.', 'm', 'p', '3' )
+#define ATOM_ms02 MP4_FOURCC( 'm', 's', 0x0, 0x02 )
+#define ATOM_ms11 MP4_FOURCC( 'm', 's', 0x0, 0x11 )
+#define ATOM_ms55 MP4_FOURCC( 'm', 's', 0x0, 0x55 )
+#define ATOM_twos MP4_FOURCC( 't', 'w', 'o', 's' )
+#define ATOM_sowt MP4_FOURCC( 's', 'o', 'w', 't' )
+#define ATOM_QDMC MP4_FOURCC( 'Q', 'D', 'M', 'C' )
+#define ATOM_QDM2 MP4_FOURCC( 'Q', 'D', 'M', '2' )
+#define ATOM_ima4 MP4_FOURCC( 'i', 'm', 'a', '4' )
+#define ATOM_IMA4 MP4_FOURCC( 'I', 'M', 'A', '4' )
+#define ATOM_dvi  MP4_FOURCC( 'd', 'v', 'i', ' ' )
+#define ATOM_MAC3 MP4_FOURCC( 'M', 'A', 'C', '3' )
+#define ATOM_MAC6 MP4_FOURCC( 'M', 'A', 'C', '6' )
+#define ATOM_alaw MP4_FOURCC( 'a', 'l', 'a', 'w' )
+#define ATOM_ulaw MP4_FOURCC( 'u', 'l', 'a', 'w' )
+#define ATOM_Qclp MP4_FOURCC( 'Q', 'c', 'l', 'p' )
+#define ATOM_samr MP4_FOURCC( 's', 'a', 'm', 'r' )
+#define ATOM_sawb MP4_FOURCC( 's', 'a', 'w', 'b' )
+#define ATOM_OggS MP4_FOURCC( 'O', 'g', 'g', 'S' )
+#define ATOM_alac MP4_FOURCC( 'a', 'l', 'a', 'c' )
+#define ATOM_dac3 MP4_FOURCC( 'd', 'a', 'c', '3' )
+#define ATOM_dec3 MP4_FOURCC( 'd', 'e', 'c', '3' )
+#define ATOM_enda MP4_FOURCC( 'e', 'n', 'd', 'a' )
+#define ATOM_gnre MP4_FOURCC( 'g', 'n', 'r', 'e' )
+#define ATOM_trkn MP4_FOURCC( 't', 'r', 'k', 'n' )
+
+#define ATOM_zlib MP4_FOURCC( 'z', 'l', 'i', 'b' )
+#define ATOM_SVQ1 MP4_FOURCC( 'S', 'V', 'Q', '1' )
+#define ATOM_SVQ3 MP4_FOURCC( 'S', 'V', 'Q', '3' )
+#define ATOM_ZyGo MP4_FOURCC( 'Z', 'y', 'G', 'o' )
+#define ATOM_3IV1 MP4_FOURCC( '3', 'I', 'V', '1' )
+#define ATOM_3iv1 MP4_FOURCC( '3', 'i', 'v', '1' )
+#define ATOM_3IV2 MP4_FOURCC( '3', 'I', 'V', '2' )
+#define ATOM_3iv2 MP4_FOURCC( '3', 'i', 'v', '2' )
+#define ATOM_3IVD MP4_FOURCC( '3', 'I', 'V', 'D' )
+#define ATOM_3ivd MP4_FOURCC( '3', 'i', 'v', 'd' )
+#define ATOM_3VID MP4_FOURCC( '3', 'V', 'I', 'D' )
+#define ATOM_3vid MP4_FOURCC( '3', 'v', 'i', 'd' )
+#define ATOM_h263 MP4_FOURCC( 'h', '2', '6', '3' )
+#define ATOM_s263 MP4_FOURCC( 's', '2', '6', '3' )
+#define ATOM_DIVX MP4_FOURCC( 'D', 'I', 'V', 'X' )
+#define ATOM_XVID MP4_FOURCC( 'X', 'V', 'I', 'D' )
+#define ATOM_cvid MP4_FOURCC( 'c', 'v', 'i', 'd' )
+#define ATOM_mjpa MP4_FOURCC( 'm', 'j', 'p', 'a' )
+#define ATOM_mjpb MP4_FOURCC( 'm', 'j', 'q', 't' )
+#define ATOM_mjqt MP4_FOURCC( 'm', 'j', 'h', 't' )
+#define ATOM_mjht MP4_FOURCC( 'm', 'j', 'p', 'b' )
+#define ATOM_VP31 MP4_FOURCC( 'V', 'P', '3', '1' )
+#define ATOM_vp31 MP4_FOURCC( 'v', 'p', '3', '1' )
+#define ATOM_h264 MP4_FOURCC( 'h', '2', '6', '4' )
+#define ATOM_qdrw MP4_FOURCC( 'q', 'd', 'r', 'w' )
+
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+#define ATOM_m4ds MP4_FOURCC( 'm', '4', 'd', 's' )
+
+#define ATOM_dvc  MP4_FOURCC( 'd', 'v', 'c', ' ' )
+#define ATOM_dvp  MP4_FOURCC( 'd', 'v', 'p', ' ' )
+#define ATOM_dv5n MP4_FOURCC( 'd', 'v', '5', 'n' )
+#define ATOM_dv5p MP4_FOURCC( 'd', 'v', '5', 'p' )
+#define ATOM_raw  MP4_FOURCC( 'r', 'a', 'w', ' ' )
+
+#define ATOM_jpeg MP4_FOURCC( 'j', 'p', 'e', 'g' )
+
+#define ATOM_yv12 MP4_FOURCC( 'y', 'v', '1', '2' )
+#define ATOM_yuv2 MP4_FOURCC( 'y', 'u', 'v', '2' )
+
+#define ATOM_rmra MP4_FOURCC( 'r', 'm', 'r', 'a' )
+#define ATOM_rmda MP4_FOURCC( 'r', 'm', 'd', 'a' )
+#define ATOM_rdrf MP4_FOURCC( 'r', 'd', 'r', 'f' )
+#define ATOM_rmdr MP4_FOURCC( 'r', 'm', 'd', 'r' )
+#define ATOM_rmvc MP4_FOURCC( 'r', 'm', 'v', 'c' )
+#define ATOM_rmcd MP4_FOURCC( 'r', 'm', 'c', 'd' )
+#define ATOM_rmqu MP4_FOURCC( 'r', 'm', 'q', 'u' )
+#define ATOM_alis MP4_FOURCC( 'a', 'l', 'i', 's' )
+
+#define ATOM_gmhd MP4_FOURCC( 'g', 'm', 'h', 'd' )
+#define ATOM_wave MP4_FOURCC( 'w', 'a', 'v', 'e' )
+
+#define ATOM_drms MP4_FOURCC( 'd', 'r', 'm', 's' )
+#define ATOM_sinf MP4_FOURCC( 's', 'i', 'n', 'f' )
+#define ATOM_schi MP4_FOURCC( 's', 'c', 'h', 'i' )
+#define ATOM_user MP4_FOURCC( 'u', 's', 'e', 'r' )
+#define ATOM_key  MP4_FOURCC( 'k', 'e', 'y', ' ' )
+#define ATOM_iviv MP4_FOURCC( 'i', 'v', 'i', 'v' )
+#define ATOM_name MP4_FOURCC( 'n', 'a', 'm', 'e' )
+#define ATOM_priv MP4_FOURCC( 'p', 'r', 'i', 'v' )
+#define ATOM_drmi MP4_FOURCC( 'd', 'r', 'm', 'i' )
+#define ATOM_frma MP4_FOURCC( 'f', 'r', 'm', 'a' )
+#define ATOM_skcr MP4_FOURCC( 's', 'k', 'c', 'r' )
+
+#define ATOM_text MP4_FOURCC( 't', 'e', 'x', 't' )
+#define ATOM_tx3g MP4_FOURCC( 't', 'x', '3', 'g' )
+#define ATOM_subp MP4_FOURCC( 's', 'u', 'b', 'p' )
+#define ATOM_sbtl MP4_FOURCC( 's', 'b', 't', 'l' )
+
+#define ATOM_0xa9nam MP4_FOURCC( 0xa9, 'n', 'a', 'm' )
+#define ATOM_0xa9aut MP4_FOURCC( 0xa9, 'a', 'u', 't' )
+#define ATOM_0xa9cpy MP4_FOURCC( 0xa9, 'c', 'p', 'y' )
+#define ATOM_0xa9inf MP4_FOURCC( 0xa9, 'i', 'n', 'f' )
+#define ATOM_0xa9ART MP4_FOURCC( 0xa9, 'A', 'R', 'T' )
+#define ATOM_0xa9des MP4_FOURCC( 0xa9, 'd', 'e', 's' )
+#define ATOM_0xa9dir MP4_FOURCC( 0xa9, 'd', 'i', 'r' )
+#define ATOM_0xa9cmt MP4_FOURCC( 0xa9, 'c', 'm', 't' )
+#define ATOM_0xa9req MP4_FOURCC( 0xa9, 'r', 'e', 'q' )
+#define ATOM_0xa9day MP4_FOURCC( 0xa9, 'd', 'a', 'y' )
+#define ATOM_0xa9fmt MP4_FOURCC( 0xa9, 'f', 'm', 't' )
+#define ATOM_0xa9prd MP4_FOURCC( 0xa9, 'p', 'r', 'd' )
+#define ATOM_0xa9prf MP4_FOURCC( 0xa9, 'p', 'r', 'f' )
+#define ATOM_0xa9src MP4_FOURCC( 0xa9, 's', 'r', 'c' )
+#define ATOM_0xa9alb MP4_FOURCC( 0xa9, 'a', 'l', 'b' )
+#define ATOM_0xa9dis MP4_FOURCC( 0xa9, 'd', 'i', 's' )
+#define ATOM_0xa9enc MP4_FOURCC( 0xa9, 'e', 'n', 'c' )
+#define ATOM_0xa9trk MP4_FOURCC( 0xa9, 't', 'r', 'k' )
+#define ATOM_0xa9url MP4_FOURCC( 0xa9, 'u', 'r', 'l' )
+#define ATOM_0xa9dsa MP4_FOURCC( 0xa9, 'd', 's', 'a' )
+#define ATOM_0xa9hst MP4_FOURCC( 0xa9, 'h', 's', 't' )
+#define ATOM_0xa9ope MP4_FOURCC( 0xa9, 'o', 'p', 'e' )
+#define ATOM_0xa9wrt MP4_FOURCC( 0xa9, 'w', 'r', 't' )
+#define ATOM_0xa9com MP4_FOURCC( 0xa9, 'c', 'o', 'm' )
+#define ATOM_0xa9gen MP4_FOURCC( 0xa9, 'g', 'e', 'n' )
+#define ATOM_0xa9too MP4_FOURCC( 0xa9, 't', 'o', 'o' )
+#define ATOM_0xa9wrn MP4_FOURCC( 0xa9, 'w', 'r', 'n' )
+#define ATOM_0xa9swr MP4_FOURCC( 0xa9, 's', 'w', 'r' )
+#define ATOM_0xa9mak MP4_FOURCC( 0xa9, 'm', 'a', 'k' )
+#define ATOM_0xa9mod MP4_FOURCC( 0xa9, 'm', 'o', 'd' )
+#define ATOM_0xa9PRD MP4_FOURCC( 0xa9, 'P', 'R', 'D' )
+#define ATOM_0xa9grp MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_0xa9lyr MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_chpl MP4_FOURCC( 'c', 'h', 'p', 'l' )
+#define ATOM_WLOC MP4_FOURCC( 'W', 'L', 'O', 'C' )
+
+#define ATOM_meta MP4_FOURCC( 'm', 'e', 't', 'a' )
+#define ATOM_ilst MP4_FOURCC( 'i', 'l', 's', 't' )
+
+#define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
+
+#define ATOM_muli MP4_FOURCC( 'm', 'u', 'l', 'i' )
+#define ATOM_pitm MP4_FOURCC( 'p', 'i', 't', 'm' )
+#define ATOM_iloc MP4_FOURCC( 'i', 'l', 'o', 'c' )
+#define ATOM_iinf MP4_FOURCC( 'i', 'i', 'n', 'f' )
+#define ATOM_infe MP4_FOURCC( 'i', 'n', 'f', 'e' )
+#define ATOM_idat MP4_FOURCC( 'i', 'd', 'a', 't' )
+
+
+typedef struct uuid_s
+{
+   uint8_t b[16];
+} uuid_t;
+
+/* specific structure for all boxes */
+typedef struct mp4_box_data_ftyp_s
+{
+   uint32_t major_brand;
+   uint32_t minor_version;
+
+   uint32_t compatible_brands_count;
+   uint32_t *compatible_brands;
+
+} mp4_box_data_ftyp_t;
+
+typedef struct mp4_box_data_mmpu_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint8_t  is_complete;
+	uint8_t  reserved;
+   uint32_t mpu_sequence_number;
+   uint32_t asset_id_scheme;
+   uint32_t asset_id_length;
+   char *asset_id_value;
+
+} mp4_box_data_mmpu_t;
+typedef struct mp4_box_data_infe_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint16_t item_ID;
+	uint16_t item_protection_index;
+    char     *item_name;
+    char     *content_type;
+	char     *content_encoding;
+
+} mp4_box_data_infe_t;
+
+typedef struct mp4_box_data_iinf_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_iinf_t;
+
+typedef struct mp4_box_data_iloc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+	uint8_t  offset_size;
+	uint8_t  length_size;
+	uint8_t  base_offset_size;
+	uint8_t  index_size_or_reserved;
+    uint16_t item_count;
+
+    uint16_t *item_ID; /* theses are arrays */
+	uint16_t *data_reference_index;
+    uint32_t *base_offset;
+	uint16_t *extent_count;
+    uint32_t *extent_offset;
+	uint32_t *extent_length;
+
+} mp4_box_data_iloc_t;
+
+typedef struct mp4_box_data_pitm_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t item_ID;
+
+} mp4_box_data_pitm_t;
+
+typedef struct mp4_box_data_idat_s
+{
+    uint8_t  *data;
+
+} mp4_box_data_idat_t;
+
+typedef struct mp4_box_data_tfdt_s
+{
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+
+} mp4_box_data_tfdt_t;
+
+typedef struct mp4_box_data_mvhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+
+} mp4_box_data_mvhd_t;
+
+#define MP4_TRACK_ENABLED    0x000001
+#define MP4_TRACK_IN_MOVIE   0x000002
+#define MP4_TRACK_IN_PREVIEW 0x000004
+
+typedef struct mp4_box_data_tkhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t track_id;
+   uint32_t reserved;
+   uint64_t duration;
+
+   uint32_t reserved2[2];
+   int16_t  layer;
+   int16_t  predefined;
+
+   int16_t  volume;
+   uint16_t reserved3;
+   int32_t  matrix[9];
+   int32_t  width;
+   int32_t  height;
+
+} mp4_box_data_tkhd_t;
+
+typedef struct mp4_box_data_hint_s
+{
+
+	uint32_t track_IDs;
+
+} mp4_box_data_hint_t;
+
+typedef struct mp4_box_data_mdhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   /* one bit for pad */
+   uint16_t language_code;
+   /* unsigned int(5)[3] language difference with 0x60*/
+   unsigned char language[3];
+   uint16_t predefined;
+
+} mp4_box_data_mdhd_t;
+
+typedef struct mp4_box_data_hdlr_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t predefined;
+    uint32_t handler_type; /* "vide" "soun" "hint" "odsm" "crsm" "sdsm" "m7sm" "ocsm" "ipsm" "mjsm" */
+
+    unsigned char *psz_name; /* in UTF-8 */
+
+} mp4_box_data_hdlr_t;
+
+typedef struct mp4_box_data_vmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  graphics_mode;
+   int16_t  opcolor[3];
+
+} mp4_box_data_vmhd_t;
+
+typedef struct mp4_box_data_smhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  balance;
+   int16_t  reserved;
+
+} mp4_box_data_smhd_t;
+
+typedef struct mp4_box_data_hmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t max_PDU_size;
+   uint16_t avg_PDU_size;
+   uint32_t max_bitrate;
+   uint32_t avg_bitrate;
+   uint32_t reserved;
+
+} mp4_box_data_hmhd_t;
+
+typedef struct mp4_box_data_url_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   char *psz_location;
+
+} mp4_box_data_url_t;
+
+typedef struct mp4_box_data_urn_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    char *psz_name;
+    char *psz_location;
+
+} mp4_box_data_urn_t;
+
+typedef struct mp4_box_data_dref_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_dref_t;
+
+typedef struct mp4_box_data_stts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_delta;
+
+} mp4_box_data_stts_t;
+
+typedef struct mp4_box_data_ctts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_offset;
+
+} mp4_box_data_ctts_t;
+
+
+typedef struct mp4_box_data_sample_soun_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    //uint32_t reserved2[2];
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint16_t channelcount;
+    uint16_t samplesize;
+    uint16_t predefined;
+    uint16_t reserved3;
+    uint16_t sampleratehi; /* timescale of track */
+    uint16_t sampleratelo;
+
+    /* for version 1 (reserved1[0] == 1) */
+    uint32_t sample_per_packet;
+    uint32_t bytes_per_packet;
+    uint32_t bytes_per_frame;
+    uint32_t bytes_per_sample;
+
+    /* XXX hack */
+    int     qt_description;
+    uint8_t *p_qt_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_soun_t;
+
+typedef struct mp4_box_data_sample_vide_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint32_t qt_temporal_quality;
+    uint32_t qt_spatial_quality;
+
+    int16_t  width;
+    int16_t  height;
+
+    uint32_t horizresolution;
+    uint32_t vertresolution;
+
+    uint32_t qt_data_size;
+    uint16_t qt_frame_count;
+
+    uint8_t  compressorname[32];
+    int16_t  depth;
+
+    int16_t  qt_color_table;
+
+    /* XXX hack ImageDescription */
+    int     qt_image_description;
+    uint8_t *p_qt_image_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_vide_t;
+
+typedef struct mp4_box_data_sample_mmth_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t hinttrackversion;
+    uint16_t highestcompatibleversion;
+    uint16_t packet_id;
+    uint8_t has_mfus_flag;
+    uint8_t is_timed;
+    uint8_t reserved;
+    /*uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;*/
+
+} mp4_box_data_sample_mmth_t;
+
+typedef struct mp4_box_data_mmthsample_s
+{
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t moviefragmentsequencenumber;
+	uint32_t samplenumber;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+	uint16_t item_ID;
+
+} mp4_box_data_mmthsample_t;
+
+typedef struct mp4_box_data_muli_s
+{
+	uint8_t multilayer_flag:1;
+	uint8_t reserved0:7;
+	uint8_t dependency_id:3;
+	uint8_t depth_flag:1;
+	uint8_t reserved1:4;
+	uint8_t temporal_id:3;
+	uint8_t reserved2:1;
+	uint8_t quality_id:4;
+	uint8_t priority_id:6;
+	uint16_t view_id:10;
+
+	uint8_t layer_id:6;
+	//uint8_t temporal_id:3;
+	uint8_t reserved3:7;
+
+} mp4_box_data_muli_t;
+
+
+
+#define MP4_TEXT_DISPLAY_FLAG_DONT_DISPLAY       (1<<0)
+#define MP4_TEXT_DISPLAY_FLAG_AUTO_SCALE         (1<<1)
+#define MP4_TEXT_DISPLAY_FLAG_CLIP_TO_TEXT_BOX   (1<<2)
+#define MP4_TEXT_DISPLAY_FLAG_USE_MOVIE_BG_COLOR (1<<3)
+#define MP4_TEXT_DISPLAY_FLAG_SHRINK_TEXT_BOX_TO_FIT (1<<4)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_IN          (1<<5)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_OUT         (1<<6)
+#define MP4_TEXT_DISPLAY_FLAG_HORIZONTAL_SCROLL  (1<<7)
+#define MP4_TEXT_DISPLAY_FLAG_REVERSE_SCROLL     (1<<8)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_SCROLL  (1<<9)
+#define MP4_TEXT_DISPLAY_FLAG_FLOW_HORIZONTAL    (1<<10)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_KARAOKE (1<<11)
+#define MP4_TEXT_DISPLAY_FLAG_DROP_SHADOW        (1<<12)
+#define MP4_TEXT_DISPLAY_FLAG_ANTI_ALIAS         (1<<13)
+#define MP4_TEXT_DISPLAY_FLAG_KEYED_TEXT         (1<<14)
+#define MP4_TEXT_DISPLAY_FLAG_INVERSE_HILITE     (1<<15)
+#define MP4_TEXT_DISPLAY_FLAG_COLOR_HILITE       (1<<16)
+#define MP4_TEXT_DISPLAY_FLAG_WRITE_VERTICALLY   (1<<17)
+
+typedef struct
+{
+    uint32_t reserved1;
+    uint16_t reserved2;
+
+    uint16_t data_reference_index;
+
+    uint32_t display_flags;   // TextDescription and Tx3gDescription
+
+    int8_t justification_horizontal; // left(0), centered(1), right(-1)
+    int8_t justification_vertical;   // top(0), centered(1), bottom(-1)
+
+    uint16_t background_color[4];
+
+    uint16_t text_box_top;
+    uint16_t text_box_left;
+    uint16_t text_box_bottom;
+    uint16_t text_box_right;
+
+    // TODO to complete
+} mp4_box_data_sample_text_t;
+
+typedef struct mp4_box_data_sample_hint_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint8_t *data;
+
+} mp4_box_data_sample_hint_t;
+
+typedef struct mp4_box_data_moviehintinformation_rtp_s
+{
+    uint32_t description_format;
+    unsigned char *psz_text;
+
+} mp4_box_data_moviehintinformation_rtp_t;
+
+
+
+typedef struct mp4_box_data_stsd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    /* it contains SampleEntry handled as if it was Box */
+
+} mp4_box_data_stsd_t;
+
+
+typedef struct mp4_box_data_stsz_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array , empty if sample_size != 0 */
+
+} mp4_box_data_stsz_t;
+
+typedef struct mp4_box_data_stz2_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size; /* 24 bits */
+    uint8_t  field_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array: unsigned int(field_size) entry_size */
+
+} mp4_box_data_stz2_t;
+
+typedef struct mp4_box_data_stsc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *first_chunk; /* theses are arrays */
+    uint32_t *samples_per_chunk;
+    uint32_t *sample_description_index;
+
+} mp4_box_data_stsc_t;
+
+
+typedef struct mp4_box_data_co64_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *chunk_offset;
+
+} mp4_box_data_co64_t;
+
+
+typedef struct mp4_box_data_stss_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_number;
+
+} mp4_box_data_stss_t;
+
+typedef struct mp4_box_data_stsh_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *shadowed_sample_number;
+    uint32_t *sync_sample_number;
+
+} mp4_box_data_stsh_t;
+
+typedef struct mp4_box_data_stdp_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint16_t *priority;
+
+} mp4_box_data_stdp_t;
+
+typedef struct mp4_box_data_padb_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_count;
+
+    uint16_t *reserved1;   /* 1bit  */
+    uint16_t *pad2;        /* 3bits */
+    uint16_t *reserved2;   /* 1bit  */
+    uint16_t *pad1;        /* 3bits */
+
+
+} mp4_box_data_padb_t;
+
+
+typedef struct mp4_box_data_elst_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *segment_duration;
+    int64_t  *media_time;
+    uint16_t *media_rate_integer;
+    uint16_t *media_rate_fraction;
+
+
+} mp4_box_data_elst_t;
+
+typedef struct mp4_box_data_cprt_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    /* 1 pad bit */
+    unsigned char language[3];
+
+    char *psz_notice;
+} mp4_box_data_cprt_t;
+
+
+/* DecoderConfigDescriptor */
+typedef struct mp4_descriptor_decoder_config_s
+{
+    uint8_t objectTypeIndication;
+    uint8_t streamType;
+    int     b_upStream;
+    int     buffer_sizeDB;
+    int     max_bitrate;
+    int     avg_bitrate;
+
+    int     decoder_specific_info_len;
+    uint8_t *decoder_specific_info;
+    /* some other stuff */
+
+} mp4_descriptor_decoder_config_t;
+
+typedef struct mp4_descriptor_SL_config_s
+{
+
+    int dummy; /* ANSI C forbids empty structures */
+
+} mp4_descriptor_SL_config_t;
+
+
+typedef struct mp4_descriptor_ES_s
+{
+    uint16_t ES_ID;
+    int      b_stream_dependence;
+    int      b_url;
+    int      b_OCRstream;
+    int      stream_priority;
+
+    int      depend_on_ES_ID; /* if b_stream_dependence set */
+
+    unsigned char *psz_URL;
+
+    uint16_t OCR_ES_ID;       /* if b_OCRstream */
+    mp4_descriptor_decoder_config_t *decConfigDescr;
+
+    mp4_descriptor_SL_config_t *slConfigDescr;
+
+    /* some other stuff ... */
+
+} mp4_descriptor_ES_t;
+
+/* ES descriptor */
+typedef struct mp4_box_data_esds_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    mp4_descriptor_ES_t es_descriptor;
+
+} mp4_box_data_esds_t;
+
+
+typedef struct mp4_box_data_dcom_s
+{
+    uint32_t algorithm; /* fourcc */
+
+} mp4_box_data_dcom_t;
+
+typedef struct mp4_box_data_cmvd_s
+{
+    uint32_t uncompressed_size;
+    uint32_t compressed_size;
+
+    int     b_compressed; /* Set to 1 if compressed data, 0 if uncompressed */
+    uint8_t *data;
+
+} mp4_box_data_cmvd_t;
+
+typedef struct mp4_box_data_cmov_s
+{
+    struct mp4_box_s *moov; /* uncompressed moov */
+
+} mp4_box_data_cmov_t;
+
+typedef struct
+{
+    uint32_t type;
+} mp4_box_data_frma_t;
+
+typedef struct
+{
+    uint32_t init;
+    uint32_t encr;
+    uint32_t decr;
+} mp4_box_data_skcr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t ref_type;
+    char     *psz_ref;
+
+} mp4_box_data_rdrf_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t rate;
+
+} mp4_box_data_rmdr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t gestaltType;
+    uint32_t val1;
+    uint32_t val2;
+    uint16_t checkType;   /* 0: val1 is version min
+                               1: gestalt value & val2 == val1 */
+
+} mp4_box_data_rmvc_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+
+} mp4_box_data_rmcd_t;
+
+typedef struct
+{
+    uint32_t quality;
+
+} mp4_box_data_rmqu_t;
+
+typedef struct mp4_box_data_mfhd_s
+{
+    uint32_t sequence_number;
+
+    uint8_t *vendor_extension;
+
+} mp4_box_data_mfhd_t;
+
+#define MP4_TFHD_BASE_DATA_OFFSET     (1LL<<0)
+#define MP4_TFHD_SAMPLE_DESC_INDEX    (1LL<<1)
+#define MP4_TFHD_DFLT_SAMPLE_DURATION (1LL<<3)
+#define MP4_TFHD_DFLT_SAMPLE_SIZE     (1LL<<4)
+#define MP4_TFHD_DFLT_SAMPLE_FLAGS    (1LL<<5)
+typedef struct mp4_box_data_tfhd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t track_ID;
+
+    /* optional fields */
+    uint64_t base_data_offset;
+    uint32_t sample_description_index;
+    uint32_t default_sample_duration;
+    uint32_t default_sample_size;
+    uint32_t default_sample_flags;
+
+} mp4_box_data_tfhd_t;
+
+#define MP4_TRUN_DATA_OFFSET         (1<<0)
+#define MP4_TRUN_FIRST_FLAGS         (1<<2)
+#define MP4_TRUN_SAMPLE_DURATION     (1<<8)
+#define MP4_TRUN_SAMPLE_SIZE         (1<<9)
+#define MP4_TRUN_SAMPLE_FLAGS        (1<<10)
+#define MP4_TRUN_SAMPLE_TIME_OFFSET  (1<<11)
+typedef struct mp4_descriptor_trun_sample_t
+{
+    uint32_t duration;
+    uint32_t size;
+    uint32_t flags;
+    uint32_t composition_time_offset;
+} mp4_descriptor_trun_sample_t;
+
+typedef struct mp4_box_data_trun_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t sample_count;
+
+    /* optional fields */
+    uint32_t data_offset;
+    uint32_t first_sample_flags;
+
+    mp4_descriptor_trun_sample_t *samples;
+
+} mp4_box_data_trun_t;
+
+
+
+typedef struct mp4_box_data_0xa9xxx_s
+{
+   char *psz_text;
+
+} mp4_box_data_0xa9xxx_t;
+
+typedef struct mp4_box_data_name_s
+{
+   char *psz_text;
+
+} mp4_box_data_name_t;
+
+typedef struct mp4_box_data_tref_generic_s
+{
+   uint32_t entry_count;
+   uint32_t *track_ID;
+
+} mp4_box_data_tref_generic_t;
+
+typedef struct mp4_box_data_chpl_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t chapter;
+   struct
+   {
+      char    *psz_name;
+      int64_t  start;
+   } p_chapter[256];
+} mp4_box_data_chpl_t;
+
+typedef struct mp4_box_data_avcC_s
+{
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+
+} mp4_box_data_avcC_t;
+
+typedef struct mp4_box_data_dac3_s
+{
+   uint8_t fscod;
+   uint8_t bsid;
+   uint8_t bsmod;
+   uint8_t acmod;
+   uint8_t lfeon;
+   uint8_t bitrate_code;
+
+} mp4_box_data_dac3_t;
+
+typedef struct mp4_box_data_enda_s
+{
+   uint16_t little_endian;
+
+} mp4_box_data_enda_t;
+
+typedef struct mp4_box_data_gnre_s
+{
+   uint16_t genre;
+
+} mp4_box_data_gnre_t;
+
+typedef struct mp4_box_data_trkn_s
+{
+   uint32_t track_number;
+   uint32_t track_total;
+
+} mp4_box_data_trkn_t;
+
+typedef struct mp4_box_data_iods_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t object_descriptor;
+   uint8_t OD_profile_level;
+   uint8_t scene_profile_level;
+   uint8_t audio_profile_level;
+   uint8_t visual_profile_level;
+   uint8_t graphics_profile_level;
+
+} mp4_box_data_iods_t;
+
+typedef struct mp4_box_data_pasp_s
+{
+   uint32_t horizontal_spacing;
+   uint32_t vertical_spacing;
+} mp4_box_data_pasp_t;
+
+typedef struct mp4_box_data_mehd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t fragment_duration;
+} mp4_box_data_mehd_t;
+
+typedef struct mp4_box_data_trex_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t default_sample_description_index;
+   uint32_t default_sample_duration;
+   uint32_t default_sample_size;
+   uint32_t default_sample_flags;
+} mp4_box_data_trex_t;
+
+typedef struct mp4_box_data_sdtp_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t *sample_table;
+} mp4_box_data_sdtp_t;
+
+typedef struct mp4_box_data_mfro_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t size;
+} mp4_box_data_mfro_t;
+
+typedef struct mp4_box_data_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} mp4_box_data_tfra_t;
+
+typedef union mp4_box_data_s
+{
+   mp4_box_data_ftyp_t *p_ftyp;
+   mp4_box_data_mmpu_t *p_mmpu;
+   mp4_box_data_tfdt_t *p_tfdt;
+   mp4_box_data_mvhd_t *p_mvhd;
+   mp4_box_data_mfhd_t *p_mfhd;
+   mp4_box_data_tfhd_t *p_tfhd;
+   mp4_box_data_trun_t *p_trun;
+   mp4_box_data_tkhd_t *p_tkhd;
+   mp4_box_data_hint_t *p_hint;
+   mp4_box_data_mdhd_t *p_mdhd;
+   mp4_box_data_hdlr_t *p_hdlr;
+   mp4_box_data_vmhd_t *p_vmhd;
+   mp4_box_data_smhd_t *p_smhd;
+   mp4_box_data_hmhd_t *p_hmhd;
+   mp4_box_data_url_t  *p_url;
+   mp4_box_data_urn_t  *p_urn;
+   mp4_box_data_dref_t *p_dref;
+   mp4_box_data_stts_t *p_stts;
+   mp4_box_data_ctts_t *p_ctts;
+   mp4_box_data_stsd_t *p_stsd;
+   mp4_box_data_sample_vide_t *p_sample_vide;
+   mp4_box_data_sample_soun_t *p_sample_soun;
+   mp4_box_data_sample_text_t *p_sample_text;
+   mp4_box_data_sample_hint_t *p_sample_hint;
+   mp4_box_data_sample_mmth_t *p_sample_mmth;
+
+   mp4_box_data_esds_t *p_esds;
+   mp4_box_data_avcC_t *p_avcC;
+   mp4_box_data_dac3_t *p_dac3;
+   mp4_box_data_enda_t *p_enda;
+   mp4_box_data_gnre_t *p_gnre;
+   mp4_box_data_trkn_t *p_trkn;
+   mp4_box_data_iods_t *p_iods;
+   mp4_box_data_pasp_t *p_pasp;
+   mp4_box_data_trex_t *p_trex;
+   mp4_box_data_mehd_t *p_mehd;
+   mp4_box_data_sdtp_t *p_sdtp;
+
+   mp4_box_data_tfra_t *p_tfra;
+   mp4_box_data_mfro_t *p_mfro;
+
+   mp4_box_data_stsz_t *p_stsz;
+   mp4_box_data_stz2_t *p_stz2;
+   mp4_box_data_stsc_t *p_stsc;
+   mp4_box_data_co64_t *p_co64;
+   mp4_box_data_stss_t *p_stss;
+   mp4_box_data_stsh_t *p_stsh;
+   mp4_box_data_stdp_t *p_stdp;
+   mp4_box_data_padb_t *p_padb;
+   mp4_box_data_elst_t *p_elst;
+   mp4_box_data_cprt_t *p_cprt;
+
+   mp4_box_data_dcom_t *p_dcom;
+   mp4_box_data_cmvd_t *p_cmvd;
+   mp4_box_data_cmov_t *p_cmov;
+
+   mp4_box_data_moviehintinformation_rtp_t p_moviehintinformation_rtp;
+
+   mp4_box_data_frma_t *p_frma;
+   mp4_box_data_skcr_t *p_skcr;
+
+   mp4_box_data_rdrf_t *p_rdrf;
+   mp4_box_data_rmdr_t *p_rmdr;
+   mp4_box_data_rmqu_t *p_rmqu;
+   mp4_box_data_rmvc_t *p_rmvc;
+
+   mp4_box_data_0xa9xxx_t *p_0xa9xxx;
+   mp4_box_data_chpl_t *p_chpl;
+   mp4_box_data_tref_generic_t *p_tref_generic;
+   mp4_box_data_name_t *p_name;
+   mp4_box_data_infe_t *p_infe;
+   mp4_box_data_iinf_t *p_iinf;
+   mp4_box_data_iloc_t *p_iloc;
+   mp4_box_data_pitm_t *p_pitm;
+   mp4_box_data_idat_t *p_idat;
+   void *p_data;
+} mp4_box_data_t;
+
+typedef struct mp4_box_s
+{
+   int64_t i_pos;
+   uint32_t i_type;
+   uint32_t i_shortsize;
+   uuid_t i_uuid;
+   uint64_t i_size;
+   mp4_box_data_t data;
+   struct mp4_box_s* p_father;
+   struct mp4_box_s* p_first;
+   struct mp4_box_s* p_last;
+   struct mp4_box_s* p_next;
+} mp4_box_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+mp4_box_t *MP4_BoxGetRoot(stream_t * s);
+void MP4_BoxFree(stream_t * s, mp4_box_t *box);
+mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
+mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif // NET_MMT_MPU_MP4_H_
diff --git a/net/mmt/mpu/mp4atom.h b/net/mmt/mpu/mp4atom.h
new file mode 100644
index 0000000..52e68ce
--- /dev/null
+++ b/net/mmt/mpu/mp4atom.h
@@ -0,0 +1,154 @@
+#ifndef NET_MMT_MPU_MP4ATOM_H_
+#define NET_MMT_MPU_MP4ATOM_H_
+
+#include <stdint.h>
+
+typedef struct uuid_s{
+    uint8_t b[16];
+} uuid_t;
+
+#define MP4_FOURCC( a, b, c, d ) \
+    (((uint32_t)a) | (((uint32_t)b)<<8) | (((uint32_t)c)<<16) | (((uint32_t)d)<<24))
+
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+
+// pps/sps: moov -> trak -> mdia -> minf -> stbl -> stsd -> avcl -> avcC
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+
+// moof
+
+
+typedef struct atom_ftyp_s {
+    uint32_t major_brand;
+    uint32_t minor_version;
+    uint32_t compatible_brands_count;
+    uint32_t *compatible_brands;
+} atom_ftyp_t;
+
+typedef struct atom_mmpu_s {
+    uint8_t  version;
+    uint32_t flags;
+    uint8_t  is_complete;
+    uint8_t  reserved;
+    uint32_t mpu_sequence_number;
+    uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;
+} atom_mmpu_t;
+
+typedef struct atom_tfdt_s {
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+} atom_tfdt_t;
+
+typedef struct atom_mvhd_s {
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+} atom_mvhd_t;
+
+typedef struct atom_mfhd_s {
+    uint32_t sequence_number;
+    uint8_t *vendor_extension;
+} atom_mfhd_t;
+
+typedef struct atom_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} atom_tfra_t;
+
+typedef struct atom_avcC_s {
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+} atom_avcC_t;
+
+
+// common atoms
+//  a) ftyp
+//  b) avcC in moov/trak/mdia/minf/stbl/stsd/avcl
+//  c) mdat
+// common containers: 
+//  a) moov/trak/mdia/minf/stbl/stsd/avcl
+//  b) moof/
+
+// for some atom containers
+typedef unsigned char* data_t;
+typedef struct atom_info_s {
+    int     pos;
+    int     type;
+    uuid_t  uuid;
+    char    name[5]; // box name: 4chars + '\0'
+    int     size;
+    data_t  data;
+}atom_info_t;
+
+typedef struct mp4_root_s {
+    atom_info_t ftyp; // required
+    atom_info_t mmpu; // required
+    atom_info_t moov; // required
+    atom_info_t moof; // the first moof
+    atom_info_t mdat;
+    int     size;
+    data_t  data;
+}mp4_root_t;
+
+#endif // NET_MMT_MPU_MP4ATOM_H_
diff --git a/net/mmt/mpu/mpu.gyp b/net/mmt/mpu/mpu.gyp
new file mode 100644
index 0000000..597fb94
--- /dev/null
+++ b/net/mmt/mpu/mpu.gyp
@@ -0,0 +1,87 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmpu',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mpu',
+      'sources': [
+        'stream.c',
+        'mp4.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
new file mode 100644
index 0000000..8be0258
--- /dev/null
+++ b/net/mmt/mpu/stream.c
@@ -0,0 +1,390 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc.h>
+#include <memory.h>
+#include <assert.h>
+#include "stream.h"
+
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+void* file_open(stream_t *stream_s, const char* filename, int mode)
+{
+   FILE* file = NULL;
+   const char* mode_fopen = NULL;
+   if ((mode & MODE_READWRITEFILTER) == MODE_READ)
+      mode_fopen = "rb";
+   else
+      if (mode & MODE_EXISTING)
+         mode_fopen = "r+b";
+      else
+         if (mode & MODE_CREATE)
+            mode_fopen = "wb";
+   if ((filename != NULL) && (mode_fopen != NULL))
+      file = fopen(filename, mode_fopen);
+   stream_s->opaque = (void*)file;
+
+   return file;
+}
+
+int file_read(stream_t *stream_s, void* buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fread(buf, 1, size, file);
+}
+
+int file_write(stream_t *stream_s, void *buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fwrite(buf, 1, size, file);
+}
+
+int file_peek(stream_t *stream_s, void* buf, int size)
+{
+   uint32_t offset = file_tell(stream_s);
+   int ret = file_read(stream_s, buf, size);
+   file_seek(stream_s, offset, SEEK_SET);
+   return ret;
+}
+
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fseek(file, offset, whence);
+}
+
+uint64_t file_tell(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return ftell(file);
+}
+
+int file_close(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fclose(file);
+}
+
+stream_t* create_file_stream()
+{
+   stream_t* s = malloc(sizeof(stream_t));
+   s->open = file_open;
+   s->read = file_read;
+   s->write = file_write;
+   s->peek = file_peek;
+   s->seek = file_seek;
+   s->tell = file_tell;
+   s->close = file_close;
+   return s;
+}
+
+void destory_file_stream(stream_t* stream_s)
+{
+   free(stream_s);
+}
+
+stream_t* create_buf_file_stream()
+{
+   buf_stream_t* s = malloc(sizeof(buf_stream_t));
+   stream_t* file_s = create_file_stream();
+   s->s = *file_s;
+   destory_file_stream(file_s);
+   s->s.read = buf_file_read;
+   s->s.write = buf_file_write;
+   s->s.peek = buf_file_peek;
+   s->s.seek = buf_file_seek;
+   s->s.close = buf_file_close;
+   s->read_buf_s.buf = malloc(READ_BUFFER_SIZE);
+   s->read_buf_s.bufsize = -1;
+   s->read_buf_s.offset = 0;
+   s->write_buf_s.buf = malloc(WRITE_BUFFER_SIZE);
+   s->write_buf_s.bufsize = 0;
+   s->write_buf_s.offset = 0;
+   s->offset = 0;
+   return (stream_t*)s;
+}
+
+void destory_buf_file_stream(stream_t* stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   free(s->read_buf_s.buf);
+   free(s->write_buf_s.buf);
+   free(stream_s);
+}
+
+int buf_file_read(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int length = 0, remainder = 0, position = 0;
+
+   while (size > 0)
+   {
+      int read_bytes = 0;
+      if (s->read_buf_s.offset > s->offset || 
+         s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset ||
+         s->read_buf_s.bufsize == -1)
+      {
+         int read_bytes, ret;
+         // offset, .
+         ret = file_seek(stream_s, s->offset, SEEK_SET);
+         if (ret != 0)
+         {
+            assert(0);
+            return ret;       // ERROR!!!
+         }
+         read_bytes = file_read(stream_s, s->read_buf_s.buf, READ_BUFFER_SIZE);
+         if (read_bytes < 0)
+            return read_bytes; // ERROR!!!
+         if (read_bytes == 0)
+            return length;
+         if (s->read_buf_s.bufsize == -1)
+            s->read_buf_s.offset = s->offset;
+         else
+            s->read_buf_s.offset += s->read_buf_s.bufsize;
+         s->read_buf_s.bufsize = read_bytes;
+      }
+
+      position = s->offset - s->read_buf_s.offset;
+      remainder = s->read_buf_s.bufsize - position;
+      read_bytes = min(size, remainder);
+
+      memcpy((char*)buf + length, 
+         (char*)s->read_buf_s.buf + position, read_bytes);
+
+      length += read_bytes;
+      position += read_bytes;
+      size -= read_bytes;
+      remainder -= read_bytes;
+      s->offset += read_bytes;
+   }
+
+   return length;
+}
+
+int buf_file_write(stream_t *stream_s, void *buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.offset + s->write_buf_s.bufsize == s->offset &&
+      s->write_buf_s.bufsize + size < WRITE_BUFFER_SIZE)
+   {
+      memcpy((char*)s->write_buf_s.buf + s->write_buf_s.bufsize, buf, size);
+      s->write_buf_s.bufsize += size;
+      s->offset += size;
+      return size;
+   }
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   if (size > WRITE_BUFFER_SIZE)
+   {
+      int ret = file_seek(stream_s, s->offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != size)
+      {
+         int n = file_write(stream_s, (char*)buf + write_bytes, size - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->offset += size;
+      return write_bytes;
+   }
+   else
+   {
+      memcpy(s->write_buf_s.buf, buf, size);
+      s->write_buf_s.offset = s->offset;
+      s->offset += size;
+      s->write_buf_s.bufsize = size;
+      return size;
+   }
+}
+
+int buf_file_peek(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int ret = 0;
+   int len = 0;
+
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   len = file_read(stream_s, buf, size);
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   return len;
+}
+
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   uint64_t ret = 0;
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+   ret = file_seek(stream_s, offset, whence);
+   if (ret != 0)
+      return ret;
+   s->offset = file_tell(stream_s);
+   if (s->read_buf_s.offset > s->offset || 
+      s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset)
+      s->read_buf_s.bufsize = -1;
+   else
+      s->read_buf_s.offset = s->offset;
+   return ret;
+}
+
+int buf_file_close(stream_t *stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   return file_close(stream_s);
+}
+
+
+
+uint16_t Swap16(uint16_t x)
+{
+   return ((x<<8)|(x>>8));
+}
+
+uint32_t Swap32(uint32_t x)
+{
+   return((x<<24)|((x<<8)&0x00FF0000)|((x>>8)&0x0000FF00)|(x>>24));
+}
+
+uint64_t Swap64(uint64_t x)
+{
+   uint32_t hi, lo;
+
+   /* Separate into high and low 32-bit values and swap them */
+   lo = (uint32_t)(x & 0xFFFFFFFF);
+   x >>= 32;
+   hi = (uint32_t)(x & 0xFFFFFFFF);
+   x = Swap32(lo);
+   x <<= 32;
+   x |= Swap32(hi);
+   return(x);
+}
+
+uint16_t read_le16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE16(value));
+}
+
+uint16_t read_be16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE16(value));
+}
+
+uint32_t read_le32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE32(value));
+}
+
+uint32_t read_be32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE32(value));
+}
+
+uint64_t read_le64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE64(value));
+}
+
+uint64_t read_be64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE64(value));
+}
+
+int write_le16(stream_t *dst, uint16_t value)
+{
+   value = SwapLE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be16(stream_t *dst, uint16_t value)
+{
+   value = SwapBE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le32(stream_t *dst, uint32_t value)
+{
+   value = SwapLE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be32(stream_t *dst, uint32_t value)
+{
+   value = SwapBE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le64(stream_t *dst, uint64_t value)
+{
+   value = SwapLE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be64(stream_t *dst, uint64_t value)
+{
+   value = SwapBE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
new file mode 100644
index 0000000..6cdbeec
--- /dev/null
+++ b/net/mmt/mpu/stream.h
@@ -0,0 +1,152 @@
+#ifndef NET_MMT_MPU_STREAM_H_
+#define NET_MMT_MPU_STREAM_H_
+
+// .
+#ifndef _STDINT_H
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned int uint32_t;
+//typedef long long int64_t;
+typedef unsigned long long uint64_t;
+//typedef unsigned long size_t;
+#endif
+
+// .
+#define MODE_READ             (1)
+#define MODE_WRITE            (2)
+#define MODE_READWRITEFILTER  (3)
+#define MODE_EXISTING         (4)
+#define MODE_CREATE           (8)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// .
+typedef struct stream {
+   void* (*open)(struct stream *stream_s, const char* filename, int mode);
+   int (*read)(struct stream *stream_s, void* buf, int size);
+   int (*write)(struct stream *stream_s, void *buf, int size);
+   int (*peek)(struct stream *stream_s, void* buf, int size);
+   uint64_t (*seek)(struct stream *stream_s, int64_t offset, int whence);
+   uint64_t (*tell)(struct stream *stream_s);
+   int (*close)(struct stream *stream_s);
+   void* opaque;
+} stream_t;
+
+// .
+#define stream_open(s, filename, mode) ((stream_t*)s)->open(((stream_t*)s), filename, mode)
+#define stream_read(s, buf, size) ((stream_t*)s)->read(((stream_t*)s), buf, size)
+#define stream_write(s, buf, size) ((stream_t*)s)->write(((stream_t*)s), buf, size)
+#define stream_peek(s, buf, size) ((stream_t*)s)->peek(((stream_t*)s), buf, size)
+#define stream_seek(s, offset, whence) ((stream_t*)s)->seek(((stream_t*)s), offset, whence)
+#define stream_tell(s) ((stream_t*)s)->tell(((stream_t*)s))
+#define stream_close(s) ((stream_t*)s)->close(((stream_t*)s))
+
+// .
+void* file_open(stream_t *stream_s, const char* filename, int mode);
+int file_read(stream_t *stream_s, void* buf, int size);
+int file_write(stream_t *stream_s, void *buf, int size);
+int file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence);
+uint64_t file_tell(stream_t *stream_s);
+int file_close(stream_t *stream_s);
+
+// .
+stream_t* create_file_stream();
+void destory_file_stream(stream_t* stream_s);
+
+
+// stream.
+#define READ_BUFFER_SIZE   10485760
+#define WRITE_BUFFER_SIZE  10485760
+
+typedef struct buf_stream {
+   stream_t s;
+
+   struct read_buf {
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
+   } read_buf_s;
+
+   struct write_buf {
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
+   } write_buf_s;
+
+   uint64_t offset;     // offset.
+
+} buf_stream_t;
+
+// .
+int buf_file_read(stream_t *stream_s, void* buf, int size);
+int buf_file_write(stream_t *stream_s, void *buf, int size);
+int buf_file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence);
+int buf_file_close(stream_t *stream_s);
+
+// .
+stream_t* create_buf_file_stream();
+void destory_buf_file_stream(stream_t* stream_s);
+
+// .
+#define LIL_ENDIAN__	1234
+#define BIG_ENDIAN__	4321
+/* #define BYTEORDER    1234 ? . */
+
+#ifndef BYTEORDER
+#if defined(__hppa__) || \
+   defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \
+   (defined(__MIPS__) && defined(__MISPEB__)) || \
+   defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
+   defined(__sparc__)
+#define BYTEORDER	BIG_ENDIAN__
+#else
+#define BYTEORDER	LIL_ENDIAN__
+#endif
+#endif /* !BYTEORDER */
+
+uint16_t Swap16(uint16_t x);
+uint32_t Swap32(uint32_t x);
+uint64_t Swap64(uint64_t x);
+
+#if BYTEORDER == LIL_ENDIAN__
+#define SwapLE16(X)	(X)
+#define SwapLE32(X)	(X)
+#define SwapLE64(X)	(X)
+#define SwapBE16(X)	Swap16(X)
+#define SwapBE32(X)	Swap32(X)
+#define SwapBE64(X)	Swap64(X)
+#else
+#define SwapLE16(X)	Swap16(X)
+#define SwapLE32(X)	Swap32(X)
+#define SwapLE64(X)	Swap64(X)
+#define SwapBE16(X)	(X)
+#define SwapBE32(X)	(X)
+#define SwapBE64(X)	(X)
+#endif
+
+uint16_t read_le16(stream_t *src);
+uint16_t read_be16(stream_t *src);
+uint32_t read_le32(stream_t *src);
+uint32_t read_be32(stream_t *src);
+uint64_t read_le64(stream_t *src);
+uint64_t read_be64(stream_t *src);
+
+int write_le16(stream_t *dst, uint16_t value);
+int write_be16(stream_t *dst, uint16_t value);
+int write_le32(stream_t *dst, uint32_t value);
+int write_be32(stream_t *dst, uint32_t value);
+int write_le64(stream_t *dst, uint64_t value);
+int write_be64(stream_t *dst, uint64_t value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NET_MMT_MPU_STREAM_H_
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
new file mode 100644
index 0000000..db65e88
--- /dev/null
+++ b/net/mmt/mpu/test_parser.cc
@@ -0,0 +1,113 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "stream.h"
+#include "mp4.h"
+
+void update_mdat(stream_t* s, long pos, uint64_t size) {
+    if (!s) return;
+    uint64_t pre = stream_tell(s);
+    stream_seek(s, 0, SEEK_END);
+    long fsize = stream_tell(s);
+    if (pos + (long)size != fsize) {
+        uint32_t real = fsize - pos;
+        printf("invalid mdat size: pos=%ld, size=%llu, fsize=%ld, real=%u\n", pos, size, fsize, real);
+        stream_seek(s, pos, SEEK_SET);
+        stream_read(s, &real, 4);
+        real = Swap32(real);
+        printf("read size=%u\n", real);
+
+        real = Swap32((uint32_t)(fsize - pos));
+        stream_seek(s, pos, SEEK_SET);
+        stream_write(s, &real, 4);
+        printf("update read size=%ld\n", fsize - pos);
+    }
+}
+
+mp4_box_t* print_traf(mp4_box_t* box) {
+    printf("\n");
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_traf);
+        if (!box) break;
+        printf("traf: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+
+        box = MP4_BoxSearchBox(box, ATOM_tfhd);
+        if (!box) break;
+        else {
+            printf("tfhd: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+            printf("tfhd: version:%d, flags:%d, trackid=%d base offset=%llu smaple idx=%u sample size=%u flags=%u\n", 
+                box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
+                box->data.p_tfhd->base_data_offset, 
+                box->data.p_tfhd->sample_description_index,
+                box->data.p_tfhd->default_sample_size,
+                box->data.p_tfhd->default_sample_flags);
+        }
+
+        box = MP4_BoxSearchBox(box, ATOM_trun);
+        if (!box) break;
+        else {
+            printf("trun: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+            if (box->data.p_trun->flags & MP4_TRUN_DATA_OFFSET)
+            printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
+                box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
+                box->data.p_trun->data_offset);
+
+        }
+    }while(0);
+    printf("\n");
+    return box;
+}
+
+int main(int argc, char* argv[])
+{
+    if (argc != 2) {
+        printf("usage: %s mp4file\n", argv[0]);
+        exit(1);
+    }
+
+    mp4_box_t *root = NULL;
+    stream_t* s = NULL;
+
+    s = create_file_stream();
+    if (stream_open(s, argv[1], MODE_EXISTING) == 0)
+        return -1;
+
+    root = MP4_BoxGetRoot(s);
+    if (!root) return -1;
+    printf("root: %p itype=%u ftyp=%u moof=%u\n", root, root->i_type,
+        ATOM_ftyp, ATOM_moof);
+
+    mp4_box_t* box = NULL;
+    box = MP4_BoxSearchBox(root, ATOM_ftyp);
+    if (box) {
+        printf("ftyp: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+    }else {
+        box = root;
+    }
+
+    mp4_box_t* idat = MP4_BoxSearchBox(box, ATOM_idat); 
+    if (idat) {
+        printf("idat: %p pos: %ld size: %llu\n", idat, idat->i_pos, idat->i_size);
+    }
+
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_moof);
+        if (!box) break;
+        printf("moof: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+
+        box = print_traf(box);
+        box = print_traf(box);
+
+        box = MP4_BoxSearchBox(box, ATOM_mdat);
+        if (!box) break;
+        printf("mdat: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+        //update_mdat(s, box->i_pos, box->i_size);
+    }while(1);
+
+    MP4_BoxFree(s, root);
+    stream_close(s);
+    destory_file_stream(s);
+
+    return 0;
+}
+
diff --git a/net/mmt/neon/CMakeLists.txt b/net/mmt/neon/CMakeLists.txt
new file mode 100644
index 0000000..0471fda
--- /dev/null
+++ b/net/mmt/neon/CMakeLists.txt
@@ -0,0 +1,65 @@
+#cmake_minimum_required(VERSION 2.8)
+#project(neon)
+
+# CMAKE_C_FLAGS CMAKE_CXX_FLAGS
+add_definitions(-O2 -Wall)
+#add_definitions(-no-cpp-precomp)
+add_definitions(-DHAVE_CONFIG_H -DNE_PRIVATE=extern)
+
+include_directories(
+    .
+)
+
+link_directories(
+)
+
+# for uuid
+set(neon_LIB_SRCS
+    #src/ne_basic.c     
+    #src/ne_props.c     
+    #src/ne_locks.c   
+    #src/ne_xml.c
+    #src/ne_xmlreq.c
+    #src/ne_207.c       
+    #src/ne_oldacl.c    
+    #src/ne_acl3744.c   
+    #ne_gnutls.c  
+    #ne_openssl.c   
+    src/ne_dates.c   
+    src/ne_session.c
+    src/ne_uri.c
+    src/ne_socket.c
+    src/ne_utils.c
+    src/ne_alloc.c     
+    src/ne_i18n.c    
+    src/ne_pkcs11.c    
+    src/ne_socks.c
+    src/ne_auth.c      
+    src/ne_sspi.c
+    src/ne_md5.c     
+    src/ne_redirect.c  
+    src/ne_string.c
+    src/ne_compress.c  
+    src/ne_ntlm.c    
+    src/ne_request.c   
+    src/ne_stubssl.c
+)
+
+# add extra header/function/type check
+include(cmake_check.cmake)
+
+set(so_NAME neon)
+#add_library(${so_NAME} SHARED ${neon_LIB_SRCS})
+#set_target_properties(${so_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1) 
+#set_target_properties(${so_NAME} PROPERTIES VERSION 1.0 SOVERSION 1)
+
+set(a_NAME neon_static)
+add_library(${a_NAME} STATIC ${neon_LIB_SRCS})
+set_target_properties(${a_NAME} PROPERTIES OUTPUT_NAME ${so_NAME})
+set_target_properties(${a_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1) 
+
+set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib/) 
+
+#install(TARGETS ${so_NAME} LIBRARY DESTINATION lib)
+install(TARGETS ${a_NAME}  ARCHIVE DESTINATION lib)
+
diff --git a/net/mmt/neon/cmake_check.cmake b/net/mmt/neon/cmake_check.cmake
new file mode 100644
index 0000000..a423e7b
--- /dev/null
+++ b/net/mmt/neon/cmake_check.cmake
@@ -0,0 +1,157 @@
+#CheckFunctionExists
+#CheckIncludeFile
+#CheckIncludeFileCXX
+#CheckIncludeFiles
+#CheckLibraryExists
+#CheckStructHasMember
+#CheckSymbolExists
+#CheckTypeSize
+#CheckVariableExists
+
+
+include(CheckVariableExists)
+check_variable_exists(timezone HAVE_TIMEZONE)
+
+include(CheckSymbolExists)
+check_symbol_exists(AI_ADDRCONFIG netdb.h USE_GAI_ADDRCONFIG)
+
+# Check C types
+include(CheckTypeSize)
+check_type_size(int         SIZEOF_INT)
+check_type_size(long        SIZEOF_LONG)
+check_type_size("long long" SIZEOF_LONG_LONG)
+check_type_size(off64_t     SIZEOF_OFF64_T)
+check_type_size(off_t       SIZEOF_OFF_T)
+check_type_size(size_t      SIZEOF_SIZE_T)
+check_type_size(ssize_t     SIZEOF_SSIZE_T)
+check_type_size(time_t      SIZEOF_TIME_T)
+check_type_size(XML_Size    SIZEOF_XML_SIZE)
+
+include(CheckIncludeFiles)
+check_include_files("arpa/inet.h" HAVE_ARPA_INET_H)
+check_include_files("dlfcn.h" HAVE_DLFCN_H)
+check_include_files("errno.h" HAVE_ERRNO_H)
+check_include_files("fcntl.h" HAVE_FCNTL_H)
+check_include_files("iconv.h" HAVE_ICONV_H)
+check_include_files("inttypes.h" HAVE_INTTYPES_H)
+check_include_files("libintl.h" HAVE_LIBINTL_H)
+check_include_files("limits.h" HAVE_LIMITS_H)
+check_include_files("locale.h" HAVE_LOCALE_H)
+check_include_files("memory.h" HAVE_MEMORY_H)
+check_include_files("netdb.h" HAVE_NETDB_H)
+check_include_files("netinet/in.h" HAVE_NETINET_IN_H)
+check_include_files("netinet/tcp.h" HAVE_NETINET_TCP_H)
+check_include_files("signal.h" HAVE_SIGNAL_H)
+check_include_files("stdarg.h" HAVE_STDARG_H)
+check_include_files("stdint.h" HAVE_STDINT_H)
+check_include_files("stdlib.h" HAVE_STDLIB_H)
+check_include_files("strings.h" HAVE_STRINGS_H)
+check_include_files("string.h" HAVE_STRING_H)
+check_include_files("sys/limits.h" HAVE_SYS_LIMITS_H)
+check_include_files("sys/poll.h" HAVE_SYS_POLL_H)
+check_include_files("sys/select.h" HAVE_SYS_SELECT_H)
+check_include_files("sys/socket.h" HAVE_SYS_SOCKET_H)
+check_include_files("sys/stat.h" HAVE_SYS_STAT_H)
+check_include_files("sys/time.h" HAVE_SYS_TIME_H)
+check_include_files("sys/types.h" HAVE_SYS_TYPES_H)
+check_include_files("sys/uio.h" HAVE_SYS_UIO_H)
+check_include_files("trio.h" HAVE_TRIO_H)
+check_include_files("unistd.h" HAVE_UNISTD_H)
+check_include_files("time.h" HAVE_TIME_H)
+
+include(CheckFunctionExists)
+check_function_exists(stpcpy HAVE_DECL_STPCPY)
+check_function_exists(strerror_r HAVE_DECL_STRERROR_R)
+check_function_exists(fcntl HAVE_FCNTL)
+check_function_exists(fstat64 HAVE_FSTAT64)
+check_function_exists(gai_strerror HAVE_GAI_STRERROR)
+check_function_exists(gethostname HAVE_GETHOSTNAME)
+check_function_exists(getnameinfo HAVE_GETNAMEINFO)
+check_function_exists(hstrerror HAVE_HSTRERROR)
+check_function_exists(getsockopt HAVE_GETSOCKOPT)
+check_function_exists(inet_ntop HAVE_INET_NTOP)
+check_function_exists(inet_pton HAVE_INET_PTON)
+check_function_exists(isatty HAVE_ISATTY)
+check_function_exists(lseek64 HAVE_LSEEK64)
+check_function_exists(pipe HAVE_PIPE)
+check_function_exists(poll HAVE_POLL)
+check_function_exists(pthread_mutex_init HAVE_PTHREAD_MUTEX_INIT)
+check_function_exists(pthread_mutex_lock HAVE_PTHREAD_MUTEX_LOCK)
+check_function_exists(setlocale HAVE_SETLOCALE)
+check_function_exists(setsockopt HAVE_SETSOCKOPT)
+check_function_exists(setvbuf HAVE_SETVBUF)
+check_function_exists(shutdown HAVE_SHUTDOWN)
+check_function_exists(signal HAVE_SIGNAL)
+check_function_exists(snprintf HAVE_SNPRINTF)
+check_function_exists(stpcpy HAVE_STPCPY)
+check_function_exists(strcasecmp HAVE_STRCASECMP)
+check_function_exists(strerror_r HAVE_STRERROR_R)
+check_function_exists(strtoll HAVE_STRTOLL)
+check_function_exists(strtoq HAVE_STRTOQ)
+check_function_exists(usleep HAVE_USLEEP)
+check_function_exists(vsnprintf HAVE_VSNPRINTF)
+
+include(CheckStructHasMember)
+check_struct_has_member("struct tm" tm_gmtoff time.h HAVE_STRUCT_TM_TM_GMTOFF)
+check_struct_has_member("struct tm" __tm_gmtoff time.h HAVE_STRUCT_TM___TM_GMTOFF)
+
+# set the size of off_t/size_t/ssize_t/time_t
+set(NE_FMT_NE_OFF_T NE_FMT_OFF_T)
+if (${SIZEOF_OFF_T} EQUAL 4)
+    set(NE_FMT_OFF_T \"ld\")
+else()
+    set(NE_FMT_OFF_T \"lld\")
+endif()
+if (${SIZEOF_SIZE_T} EQUAL 4)
+    set(NE_FMT_SIZE_T \"u\")
+else()
+    set(NE_FMT_SIZE_T \"lu\")
+endif()
+if (${SIZEOF_SSIZE_T} EQUAL 4)
+    set(NE_FMT_SSIZE_T \"d\")
+else()
+    set(NE_FMT_SSIZE_T \"ld\")
+endif()
+if (${SIZEOF_TIME_T} EQUAL 4)
+    set(NE_FMT_TIME_T \"d\")
+else()
+    set(NE_FMT_TIME_T \"ld\")
+endif()
+
+if(${USE_GAI_ADDRCONFIG})
+    set(USE_GETADDRINFO 1)
+endif()
+
+if (${HAVE_SYS_SOCKET_H})
+    set(HAVE_SOCKLEN_T 1)
+endif()
+
+if (HAVE_SYS_TIME_H AND HAVE_TIME_H)
+    set(TIME_WITH_SYS_TIME 1)
+endif()
+
+set(STDC_HEADERS 1)
+#set(_ALL_SOURCE 1)
+#set(_GNU_SOURCE 1)
+#set(_POSIX_PTHREAD_SEMANTICS 1)
+#set(_TANDEM_SOURCE 1)
+#set(__EXTENSIONS__ 1)
+
+set(NEON_IS_LIBRARY 1)
+#set(NE_DEBUGGING 1)
+#set(NE_HAVE_DAV 1)
+
+set(NEON_VERSION \"0.30.0\")
+set(NE_VERSION_MAJOR "\(0\)")
+set(NE_VERSION_MINOR "\(30\)")
+set(NE_VERSION_PATCH "\(0\)")
+set(PACKAGE_BUGREPORT \"neon@lists.manyfish.co.uk\")
+set(PACKAGE_NAME \"neon\")
+set(PACKAGE_STRING \"neon\ 0.30.0\")
+set(PACKAGE_TARNAME \"neon\")
+set(PACKAGE_URL \"\")
+set(PACKAGE_VERSION \"0.30.0\")
+
+
+configure_file(config.h.cmake.in config.h)
+include_directories(${PROJECT_BINARY_DIR}/misc/libneon)
diff --git a/net/mmt/neon/config.h b/net/mmt/neon/config.h
new file mode 100644
index 0000000..82fa77f
--- /dev/null
+++ b/net/mmt/neon/config.h
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to specific EGD socket path */
+/* #undef EGD_PATH */
+
+/* Define if EGD should be supported */
+/* #undef ENABLE_EGD */
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+/* #undef GSS_C_NT_HOSTBASED_SERVICE */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+/* #undef HAVE_BIND_TEXTDOMAIN_CODESET */
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+/* #undef HAVE_CRYPTO_SET_IDPTR_CALLBACK */
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_H_ERRNO */
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#define HAVE_DECL_STPCPY 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if you have expat */
+/* #undef HAVE_EXPAT */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fstat64' function. */
+#define HAVE_FSTAT64 1
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#define HAVE_GAI_STRERROR 1
+
+/* Define to 1 if you have the `gethostname' function. */
+#define HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `getsockopt' function. */
+#define HAVE_GETSOCKOPT 1
+
+/* Define if GnuTLS support is enabled */
+/* #undef HAVE_GNUTLS */
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+/* #undef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER */
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+/* #undef HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS */
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+/* #undef HAVE_GNUTLS_SESSION_GET_DATA2 */
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+/* #undef HAVE_GNUTLS_SIGN_CALLBACK_SET */
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+/* #undef HAVE_GNUTLS_X509_CRT_SIGN2 */
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+/* #undef HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+/* Define if GSSAPI support is enabled */
+/* #undef HAVE_GSSAPI */
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_GENERIC_H */
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_H */
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_H */
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+/* #undef HAVE_GSS_INIT_SEC_CONTEXT */
+
+/* Define to 1 if you have the `hstrerror' function. */
+#define HAVE_HSTRERROR 1
+
+/* Define to 1 if you have the `iconv' function. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#define HAVE_ICONV_H 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+#define HAVE_INET_PTON 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define if libproxy is supported */
+/* #undef HAVE_LIBPROXY */
+
+/* Define if you have libxml */
+/* #undef HAVE_LIBXML */
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+/* #undef HAVE_LIBXML_PARSER_H */
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+/* #undef HAVE_LIBXML_XMLVERSION_H */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `lseek64' function. */
+#define HAVE_LSEEK64 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#define HAVE_NETINET_TCP_H 1
+
+/* Define if NTLM is supported */
+/* #undef HAVE_NTLM */
+
+/* Define if OpenSSL support is enabled */
+/* #undef HAVE_OPENSSL */
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+/* #undef HAVE_OPENSSL_OPENSSLV_H */
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef HAVE_OPENSSL_SSL_H */
+
+/* Define if pakchois library supported */
+/* #undef HAVE_PAKCHOIS */
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#define HAVE_PTHREAD_MUTEX_INIT 1
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#define HAVE_PTHREAD_MUTEX_LOCK 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the `setsockopt' function. */
+#define HAVE_SETSOCKOPT 1
+
+/* Define to 1 if you have the `setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+/* Define to 1 if you have the `shutdown' function. */
+#define HAVE_SHUTDOWN 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#define HAVE_SOCKLEN_T 1
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+/* #undef HAVE_SSL_SESSION_CMP */
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtoq' function. */
+#define HAVE_STRTOQ 1
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+/* #undef HAVE_STRUCT_TM___TM_GMTOFF */
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+/* #undef HAVE_SYS_LIMITS_H */
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#define HAVE_SYS_POLL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define if the timezone global is available */
+#define HAVE_TIMEZONE 1
+
+/* Use trio printf replacement library */
+/* #undef HAVE_TRIO */
+
+/* Define to 1 if you have the <trio.h> header file. */
+/* #undef HAVE_TRIO_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to be location of localedir */
+/* #undef LOCALEDIR */
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+/* #undef LT_OBJDIR */
+
+/* Defined when neon is built as a library */
+#define NEON_IS_LIBRARY 1
+
+/* Define to be the neon version string */
+#define NEON_VERSION "0.30.0"
+
+/* Define to enable debugging */
+/* #undef NE_DEBUGGING */
+
+/* Define to be printf format string for ne_off_t */
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+/* Define to be printf format string for off64_t */
+/* #undef NE_FMT_OFF64_T */
+
+/* Define to be printf format string for off_t */
+#define NE_FMT_OFF_T "lld"
+
+/* Define to be printf format string for size_t */
+#define NE_FMT_SIZE_T "lu"
+
+/* Define to be printf format string for ssize_t */
+#define NE_FMT_SSIZE_T "ld"
+
+/* Define to be printf format string for time_t */
+#define NE_FMT_TIME_T "ld"
+
+/* Define to be printf format string for XML_Size */
+/* #undef NE_FMT_XML_SIZE */
+
+/* Defined if DAV is supported */
+/* #undef NE_HAVE_DAV */
+
+/* Defined if I18N is supported */
+/* #undef NE_HAVE_I18N */
+
+/* Defined if IPV6 is supported */
+/* #undef NE_HAVE_IPV6 */
+
+/* Defined if LFS is supported */
+/* #undef NE_HAVE_LFS */
+
+/* Defined if LIBPXY is supported */
+/* #undef NE_HAVE_LIBPXY */
+
+/* Defined if SSL is supported */
+/* #undef NE_HAVE_SSL */
+
+/* Defined if TS_SSL is supported */
+/* #undef NE_HAVE_TS_SSL */
+
+/* Defined if ZLIB is supported */
+/* #undef NE_HAVE_ZLIB */
+
+/* Define to be filename of an SSL CA root bundle */
+/* #undef NE_SSL_CA_BUNDLE */
+
+/* Define if poll() should be used */
+/* #undef NE_USE_POLL */
+
+/* Define to be neon library major version */
+#define NE_VERSION_MAJOR (0)
+
+/* Define to be neon library minor version */
+#define NE_VERSION_MINOR (30)
+
+/* Define to be neon library patch version */
+#define NE_VERSION_PATCH (0)
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "neon@lists.manyfish.co.uk"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "neon"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "neon 0.30.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "neon"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.30.0"
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `off64_t', as computed by sizeof. */
+/* #undef SIZEOF_OFF64_T */
+
+/* The size of `off_t', as computed by sizeof. */
+#define SIZEOF_OFF_T 8
+
+/* The size of `size_t', as computed by sizeof. */
+#define SIZEOF_SIZE_T 8
+
+/* The size of `ssize_t', as computed by sizeof. */
+#define SIZEOF_SSIZE_T 8
+
+/* The size of `time_t', as computed by sizeof. */
+#define SIZEOF_TIME_T 8
+
+/* The size of `XML_Size', as computed by sizeof. */
+/* #undef SIZEOF_XML_SIZE */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#define USE_GAI_ADDRCONFIG 1
+
+/* Define if getaddrinfo() should be used */
+#define USE_GETADDRINFO 1
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+/* #undef _GNU_SOURCE */
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+/* #undef _POSIX_PTHREAD_SEMANTICS */
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+/* #undef _TANDEM_SOURCE */
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+/* #undef __EXTENSIONS__ */
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+/* #undef _GNU_SOURCE */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define if in_addr_t is not available */
+/* #undef in_addr_t */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define if socklen_t is not available */
+/* #undef socklen_t */
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.h.cmake.in b/net/mmt/neon/config.h.cmake.in
new file mode 100644
index 0000000..a106041
--- /dev/null
+++ b/net/mmt/neon/config.h.cmake.in
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#cmakedefine AC_APPLE_UNIVERSAL_BUILD @AC_APPLE_UNIVERSAL_BUILD@
+
+/* Define to specific EGD socket path */
+#cmakedefine EGD_PATH @EGD_PATH@
+
+/* Define if EGD should be supported */
+#cmakedefine ENABLE_EGD @ENABLE_EGD@
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+#cmakedefine GSS_C_NT_HOSTBASED_SERVICE @GSS_C_NT_HOSTBASED_SERVICE@
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#cmakedefine HAVE_ARPA_INET_H @HAVE_ARPA_INET_H@
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#cmakedefine HAVE_BIND_TEXTDOMAIN_CODESET @HAVE_BIND_TEXTDOMAIN_CODESET@
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+#cmakedefine HAVE_CRYPTO_SET_IDPTR_CALLBACK @HAVE_CRYPTO_SET_IDPTR_CALLBACK@
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_H_ERRNO @HAVE_DECL_H_ERRNO@
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_STPCPY @HAVE_DECL_STPCPY@
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_STRERROR_R @HAVE_DECL_STRERROR_R@
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H @HAVE_DLFCN_H@
+
+/* Define to 1 if you have the <errno.h> header file. */
+#cmakedefine HAVE_ERRNO_H @HAVE_ERRNO_H@
+
+/* Define if you have expat */
+#cmakedefine HAVE_EXPAT @HAVE_EXPAT@
+
+/* Define to 1 if you have the `fcntl' function. */
+#cmakedefine HAVE_FCNTL @HAVE_FCNTL@
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H @HAVE_FCNTL_H@
+
+/* Define to 1 if you have the `fstat64' function. */
+#cmakedefine HAVE_FSTAT64 @HAVE_FSTAT64@
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#cmakedefine HAVE_GAI_STRERROR @HAVE_GAI_STRERROR@
+
+/* Define to 1 if you have the `gethostname' function. */
+#cmakedefine HAVE_GETHOSTNAME @HAVE_GETHOSTNAME@
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#cmakedefine HAVE_GETNAMEINFO @HAVE_GETNAMEINFO@
+
+/* Define to 1 if you have the `getsockopt' function. */
+#cmakedefine HAVE_GETSOCKOPT @HAVE_GETSOCKOPT@
+
+/* Define if GnuTLS support is enabled */
+#cmakedefine HAVE_GNUTLS @HAVE_GNUTLS@
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+#cmakedefine HAVE_GNUTLS_CERTIFICATE_GET_ISSUER @HAVE_GNUTLS_CERTIFICATE_GET_ISSUER@
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+#cmakedefine HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS @HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS@
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+#cmakedefine HAVE_GNUTLS_SESSION_GET_DATA2 @HAVE_GNUTLS_SESSION_GET_DATA2@
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+#cmakedefine HAVE_GNUTLS_SIGN_CALLBACK_SET @HAVE_GNUTLS_SIGN_CALLBACK_SET@
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+#cmakedefine HAVE_GNUTLS_X509_CRT_SIGN2 @HAVE_GNUTLS_X509_CRT_SIGN2@
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+#cmakedefine HAVE_GNUTLS_X509_DN_GET_RDN_AVA @HAVE_GNUTLS_X509_DN_GET_RDN_AVA@
+
+/* Define if GSSAPI support is enabled */
+#cmakedefine HAVE_GSSAPI @HAVE_GSSAPI@
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+#cmakedefine HAVE_GSSAPI_GSSAPI_GENERIC_H @HAVE_GSSAPI_GSSAPI_GENERIC_H@
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+#cmakedefine HAVE_GSSAPI_GSSAPI_H @HAVE_GSSAPI_GSSAPI_H@
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+#cmakedefine HAVE_GSSAPI_H @HAVE_GSSAPI_H@
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+#cmakedefine HAVE_GSS_INIT_SEC_CONTEXT @HAVE_GSS_INIT_SEC_CONTEXT@
+
+/* Define to 1 if you have the `hstrerror' function. */
+#cmakedefine HAVE_HSTRERROR @HAVE_HSTRERROR@
+
+/* Define to 1 if you have the `iconv' function. */
+#cmakedefine HAVE_ICONV @HAVE_ICONV@
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#cmakedefine HAVE_ICONV_H @HAVE_ICONV_H@
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#cmakedefine HAVE_INET_NTOP @HAVE_INET_NTOP@
+
+/* Define to 1 if you have the `inet_pton' function. */
+#cmakedefine HAVE_INET_PTON @HAVE_INET_PTON@
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H @HAVE_INTTYPES_H@
+
+/* Define to 1 if you have the `isatty' function. */
+#cmakedefine HAVE_ISATTY @HAVE_ISATTY@
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#cmakedefine HAVE_LIBINTL_H @HAVE_LIBINTL_H@
+
+/* Define if libproxy is supported */
+#cmakedefine HAVE_LIBPROXY @HAVE_LIBPROXY@
+
+/* Define if you have libxml */
+#cmakedefine HAVE_LIBXML @HAVE_LIBXML@
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+#cmakedefine HAVE_LIBXML_PARSER_H @HAVE_LIBXML_PARSER_H@
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+#cmakedefine HAVE_LIBXML_XMLVERSION_H @HAVE_LIBXML_XMLVERSION_H@
+
+/* Define to 1 if you have the <limits.h> header file. */
+#cmakedefine HAVE_LIMITS_H @HAVE_LIMITS_H@
+
+/* Define to 1 if you have the <locale.h> header file. */
+#cmakedefine HAVE_LOCALE_H @HAVE_LOCALE_H@
+
+/* Define to 1 if you have the `lseek64' function. */
+#cmakedefine HAVE_LSEEK64 @HAVE_LSEEK64@
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H @HAVE_MEMORY_H@
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#cmakedefine HAVE_NETDB_H @HAVE_NETDB_H@
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#cmakedefine HAVE_NETINET_IN_H @HAVE_NETINET_IN_H@
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#cmakedefine HAVE_NETINET_TCP_H @HAVE_NETINET_TCP_H@
+
+/* Define if NTLM is supported */
+#cmakedefine HAVE_NTLM @HAVE_NTLM@
+
+/* Define if OpenSSL support is enabled */
+#cmakedefine HAVE_OPENSSL @HAVE_OPENSSL@
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+#cmakedefine HAVE_OPENSSL_OPENSSLV_H @HAVE_OPENSSL_OPENSSLV_H@
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#cmakedefine HAVE_OPENSSL_SSL_H @HAVE_OPENSSL_SSL_H@
+
+/* Define if pakchois library supported */
+#cmakedefine HAVE_PAKCHOIS @HAVE_PAKCHOIS@
+
+/* Define to 1 if you have the `pipe' function. */
+#cmakedefine HAVE_PIPE @HAVE_PIPE@
+
+/* Define to 1 if you have the `poll' function. */
+#cmakedefine HAVE_POLL @HAVE_POLL@
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#cmakedefine HAVE_PTHREAD_MUTEX_INIT @HAVE_PTHREAD_MUTEX_INIT@
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#cmakedefine HAVE_PTHREAD_MUTEX_LOCK @HAVE_PTHREAD_MUTEX_LOCK@
+
+/* Define to 1 if you have the `setlocale' function. */
+#cmakedefine HAVE_SETLOCALE @HAVE_SETLOCALE@
+
+/* Define to 1 if you have the `setsockopt' function. */
+#cmakedefine HAVE_SETSOCKOPT @HAVE_SETSOCKOPT@
+
+/* Define to 1 if you have the `setvbuf' function. */
+#cmakedefine HAVE_SETVBUF @HAVE_SETVBUF@
+
+/* Define to 1 if you have the `shutdown' function. */
+#cmakedefine HAVE_SHUTDOWN @HAVE_SHUTDOWN@
+
+/* Define to 1 if you have the `signal' function. */
+#cmakedefine HAVE_SIGNAL @HAVE_SIGNAL@
+
+/* Define to 1 if you have the <signal.h> header file. */
+#cmakedefine HAVE_SIGNAL_H @HAVE_SIGNAL_H@
+
+/* Define to 1 if you have the `snprintf' function. */
+#cmakedefine HAVE_SNPRINTF @HAVE_SNPRINTF@
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#cmakedefine HAVE_SOCKLEN_T @HAVE_SOCKLEN_T@
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+#cmakedefine HAVE_SSL_SESSION_CMP @HAVE_SSL_SESSION_CMP@
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#cmakedefine HAVE_STDARG_H @HAVE_STDARG_H@
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H @HAVE_STDINT_H@
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H @HAVE_STDLIB_H@
+
+/* Define to 1 if you have the `stpcpy' function. */
+#cmakedefine HAVE_STPCPY @HAVE_STPCPY@
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#cmakedefine HAVE_STRCASECMP @HAVE_STRCASECMP@
+
+/* Define to 1 if you have the `strerror_r' function. */
+#cmakedefine HAVE_STRERROR_R @HAVE_STRERROR_R@
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H @HAVE_STRINGS_H@
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H @HAVE_STRING_H@
+
+/* Define to 1 if you have the `strtoll' function. */
+#cmakedefine HAVE_STRTOLL @HAVE_STRTOLL@
+
+/* Define to 1 if you have the `strtoq' function. */
+#cmakedefine HAVE_STRTOQ @HAVE_STRTOQ@
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#cmakedefine HAVE_STRUCT_TM_TM_GMTOFF @HAVE_STRUCT_TM_TM_GMTOFF@
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+#cmakedefine HAVE_STRUCT_TM___TM_GMTOFF @HAVE_STRUCT_TM___TM_GMTOFF@
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+#cmakedefine HAVE_SYS_LIMITS_H @HAVE_SYS_LIMITS_H@
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#cmakedefine HAVE_SYS_POLL_H @HAVE_SYS_POLL_H@
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#cmakedefine HAVE_SYS_SELECT_H @HAVE_SYS_SELECT_H@
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#cmakedefine HAVE_SYS_SOCKET_H @HAVE_SYS_SOCKET_H@
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H @HAVE_SYS_STAT_H@
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H @HAVE_SYS_TIME_H@
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H @HAVE_SYS_TYPES_H@
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#cmakedefine HAVE_SYS_UIO_H @HAVE_SYS_UIO_H@
+
+/* Define if the timezone global is available */
+#cmakedefine HAVE_TIMEZONE @HAVE_TIMEZONE@
+
+/* Use trio printf replacement library */
+#cmakedefine HAVE_TRIO @HAVE_TRIO@
+
+/* Define to 1 if you have the <trio.h> header file. */
+#cmakedefine HAVE_TRIO_H @HAVE_TRIO_H@
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H @HAVE_UNISTD_H@
+
+/* Define to 1 if you have the `usleep' function. */
+#cmakedefine HAVE_USLEEP @HAVE_USLEEP@
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#cmakedefine HAVE_VSNPRINTF @HAVE_VSNPRINTF@
+
+/* Define to be location of localedir */
+#cmakedefine LOCALEDIR @LOCALEDIR@
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#cmakedefine LT_OBJDIR @LT_OBJDIR@
+
+/* Defined when neon is built as a library */
+#cmakedefine NEON_IS_LIBRARY @NEON_IS_LIBRARY@
+
+/* Define to be the neon version string */
+#cmakedefine NEON_VERSION @NEON_VERSION@
+
+/* Define to enable debugging */
+#cmakedefine NE_DEBUGGING @NE_DEBUGGING@
+
+/* Define to be printf format string for ne_off_t */
+#cmakedefine NE_FMT_NE_OFF_T @NE_FMT_NE_OFF_T@
+
+/* Define to be printf format string for off64_t */
+#cmakedefine NE_FMT_OFF64_T @NE_FMT_OFF64_T@
+
+/* Define to be printf format string for off_t */
+#cmakedefine NE_FMT_OFF_T @NE_FMT_OFF_T@
+
+/* Define to be printf format string for size_t */
+#cmakedefine NE_FMT_SIZE_T @NE_FMT_SIZE_T@
+
+/* Define to be printf format string for ssize_t */
+#cmakedefine NE_FMT_SSIZE_T @NE_FMT_SSIZE_T@
+
+/* Define to be printf format string for time_t */
+#cmakedefine NE_FMT_TIME_T @NE_FMT_TIME_T@
+
+/* Define to be printf format string for XML_Size */
+#cmakedefine NE_FMT_XML_SIZE @NE_FMT_XML_SIZE@
+
+/* Defined if DAV is supported */
+#cmakedefine NE_HAVE_DAV @NE_HAVE_DAV@
+
+/* Defined if I18N is supported */
+#cmakedefine NE_HAVE_I18N @NE_HAVE_I18N@
+
+/* Defined if IPV6 is supported */
+#cmakedefine NE_HAVE_IPV6 @NE_HAVE_IPV6@
+
+/* Defined if LFS is supported */
+#cmakedefine NE_HAVE_LFS @NE_HAVE_LFS@
+
+/* Defined if LIBPXY is supported */
+#cmakedefine NE_HAVE_LIBPXY @NE_HAVE_LIBPXY@
+
+/* Defined if SSL is supported */
+#cmakedefine NE_HAVE_SSL @NE_HAVE_SSL@
+
+/* Defined if TS_SSL is supported */
+#cmakedefine NE_HAVE_TS_SSL @NE_HAVE_TS_SSL@
+
+/* Defined if ZLIB is supported */
+#cmakedefine NE_HAVE_ZLIB @NE_HAVE_ZLIB@
+
+/* Define to be filename of an SSL CA root bundle */
+#cmakedefine NE_SSL_CA_BUNDLE @NE_SSL_CA_BUNDLE@
+
+/* Define if poll() should be used */
+#cmakedefine NE_USE_POLL @NE_USE_POLL@
+
+/* Define to be neon library major version */
+#define NE_VERSION_MAJOR @NE_VERSION_MAJOR@
+
+/* Define to be neon library minor version */
+#define NE_VERSION_MINOR @NE_VERSION_MINOR@
+
+/* Define to be neon library patch version */
+#define NE_VERSION_PATCH @NE_VERSION_PATCH@
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT @PACKAGE_BUGREPORT@
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME @PACKAGE_NAME@
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING @PACKAGE_STRING@
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME @PACKAGE_TARNAME@
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL @PACKAGE_URL@
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION @PACKAGE_VERSION@
+
+/* The size of `int', as computed by sizeof. */
+#cmakedefine SIZEOF_INT @SIZEOF_INT@
+
+/* The size of `long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+
+/* The size of `long long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG_LONG @SIZEOF_LONG_LONG@
+
+/* The size of `off64_t', as computed by sizeof. */
+#cmakedefine SIZEOF_OFF64_T @SIZEOF_OFF64_T@
+
+/* The size of `off_t', as computed by sizeof. */
+#cmakedefine SIZEOF_OFF_T @SIZEOF_OFF_T@
+
+/* The size of `size_t', as computed by sizeof. */
+#cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+
+/* The size of `ssize_t', as computed by sizeof. */
+#cmakedefine SIZEOF_SSIZE_T @SIZEOF_SSIZE_T@
+
+/* The size of `time_t', as computed by sizeof. */
+#cmakedefine SIZEOF_TIME_T @SIZEOF_TIME_T@
+
+/* The size of `XML_Size', as computed by sizeof. */
+#cmakedefine SIZEOF_XML_SIZE @SIZEOF_XML_SIZE@
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS @STDC_HEADERS@
+
+/* Define to 1 if strerror_r returns char *. */
+#cmakedefine STRERROR_R_CHAR_P @STRERROR_R_CHAR_P@
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#cmakedefine TIME_WITH_SYS_TIME @TIME_WITH_SYS_TIME@
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#cmakedefine USE_GAI_ADDRCONFIG @USE_GAI_ADDRCONFIG@
+
+/* Define if getaddrinfo() should be used */
+#cmakedefine USE_GETADDRINFO @USE_GETADDRINFO@
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+#cmakedefine _ALL_SOURCE @_ALL_SOURCE@
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+#cmakedefine _GNU_SOURCE @_GNU_SOURCE@
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+#cmakedefine _POSIX_PTHREAD_SEMANTICS @_POSIX_PTHREAD_SEMANTICS@
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+#cmakedefine _TANDEM_SOURCE @_TANDEM_SOURCE@
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+#cmakedefine __EXTENSIONS__ @__EXTENSIONS__@
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#cmakedefine WORDS_BIGENDIAN @WORDS_BIGENDIAN@
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+#cmakedefine _GNU_SOURCE @_GNU_SOURCE@
+
+/* Define to 1 if on MINIX. */
+#cmakedefine _MINIX @_MINIX@
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#cmakedefine _POSIX_1_SOURCE @_POSIX_1_SOURCE@
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#cmakedefine _POSIX_SOURCE @_POSIX_SOURCE@
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#cmakedefine const @const@
+
+/* Define if in_addr_t is not available */
+#cmakedefine in_addr_t @in_addr_t@
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#cmakedefine inline @inline@
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#cmakedefine off_t @off_t@
+
+/* Define to `int' if <sys/types.h> does not define. */
+#cmakedefine pid_t @pid_t@
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#cmakedefine size_t @size_t@
+
+/* Define if socklen_t is not available */
+#cmakedefine socklen_t @socklen_t@
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.h.in b/net/mmt/neon/config.h.in
new file mode 100644
index 0000000..c28a268
--- /dev/null
+++ b/net/mmt/neon/config.h.in
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
+/* Define to specific EGD socket path */
+#undef EGD_PATH
+
+/* Define if EGD should be supported */
+#undef ENABLE_EGD
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+#undef GSS_C_NT_HOSTBASED_SERVICE
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#undef HAVE_ARPA_INET_H
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#undef HAVE_BIND_TEXTDOMAIN_CODESET
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+#undef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+#undef HAVE_DECL_H_ERRNO
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#undef HAVE_DECL_STPCPY
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#undef HAVE_DECL_STRERROR_R
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define if you have expat */
+#undef HAVE_EXPAT
+
+/* Define to 1 if you have the `fcntl' function. */
+#undef HAVE_FCNTL
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the `fstat64' function. */
+#undef HAVE_FSTAT64
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#undef HAVE_GAI_STRERROR
+
+/* Define to 1 if you have the `gethostname' function. */
+#undef HAVE_GETHOSTNAME
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#undef HAVE_GETNAMEINFO
+
+/* Define to 1 if you have the `getsockopt' function. */
+#undef HAVE_GETSOCKOPT
+
+/* Define if GnuTLS support is enabled */
+#undef HAVE_GNUTLS
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+#undef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+#undef HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+#undef HAVE_GNUTLS_SESSION_GET_DATA2
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+#undef HAVE_GNUTLS_SIGN_CALLBACK_SET
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+#undef HAVE_GNUTLS_X509_CRT_SIGN2
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+#undef HAVE_GNUTLS_X509_DN_GET_RDN_AVA
+
+/* Define if GSSAPI support is enabled */
+#undef HAVE_GSSAPI
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+#undef HAVE_GSSAPI_GSSAPI_GENERIC_H
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+#undef HAVE_GSSAPI_GSSAPI_H
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+#undef HAVE_GSSAPI_H
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+#undef HAVE_GSS_INIT_SEC_CONTEXT
+
+/* Define to 1 if you have the `hstrerror' function. */
+#undef HAVE_HSTRERROR
+
+/* Define to 1 if you have the `iconv' function. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#undef HAVE_ICONV_H
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#undef HAVE_INET_NTOP
+
+/* Define to 1 if you have the `inet_pton' function. */
+#undef HAVE_INET_PTON
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `isatty' function. */
+#undef HAVE_ISATTY
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#undef HAVE_LIBINTL_H
+
+/* Define if libproxy is supported */
+#undef HAVE_LIBPROXY
+
+/* Define if you have libxml */
+#undef HAVE_LIBXML
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+#undef HAVE_LIBXML_PARSER_H
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+#undef HAVE_LIBXML_XMLVERSION_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the `lseek64' function. */
+#undef HAVE_LSEEK64
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#undef HAVE_NETDB_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#undef HAVE_NETINET_IN_H
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#undef HAVE_NETINET_TCP_H
+
+/* Define if NTLM is supported */
+#undef HAVE_NTLM
+
+/* Define if OpenSSL support is enabled */
+#undef HAVE_OPENSSL
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+#undef HAVE_OPENSSL_OPENSSLV_H
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#undef HAVE_OPENSSL_SSL_H
+
+/* Define if pakchois library supported */
+#undef HAVE_PAKCHOIS
+
+/* Define to 1 if you have the `pipe' function. */
+#undef HAVE_PIPE
+
+/* Define to 1 if you have the `poll' function. */
+#undef HAVE_POLL
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#undef HAVE_PTHREAD_MUTEX_INIT
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#undef HAVE_PTHREAD_MUTEX_LOCK
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if you have the `setsockopt' function. */
+#undef HAVE_SETSOCKOPT
+
+/* Define to 1 if you have the `setvbuf' function. */
+#undef HAVE_SETVBUF
+
+/* Define to 1 if you have the `shutdown' function. */
+#undef HAVE_SHUTDOWN
+
+/* Define to 1 if you have the `signal' function. */
+#undef HAVE_SIGNAL
+
+/* Define to 1 if you have the <signal.h> header file. */
+#undef HAVE_SIGNAL_H
+
+/* Define to 1 if you have the `snprintf' function. */
+#undef HAVE_SNPRINTF
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#undef HAVE_SOCKLEN_T
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+#undef HAVE_SSL_SESSION_CMP
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#undef HAVE_STDARG_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `stpcpy' function. */
+#undef HAVE_STPCPY
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strerror_r' function. */
+#undef HAVE_STRERROR_R
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strtoll' function. */
+#undef HAVE_STRTOLL
+
+/* Define to 1 if you have the `strtoq' function. */
+#undef HAVE_STRTOQ
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#undef HAVE_STRUCT_TM_TM_GMTOFF
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+#undef HAVE_STRUCT_TM___TM_GMTOFF
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+#undef HAVE_SYS_LIMITS_H
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#undef HAVE_SYS_POLL_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#undef HAVE_SYS_UIO_H
+
+/* Define if the timezone global is available */
+#undef HAVE_TIMEZONE
+
+/* Use trio printf replacement library */
+#undef HAVE_TRIO
+
+/* Define to 1 if you have the <trio.h> header file. */
+#undef HAVE_TRIO_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `usleep' function. */
+#undef HAVE_USLEEP
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#undef HAVE_VSNPRINTF
+
+/* Define to be location of localedir */
+#undef LOCALEDIR
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Defined when neon is built as a library */
+#undef NEON_IS_LIBRARY
+
+/* Define to be the neon version string */
+#undef NEON_VERSION
+
+/* Define to enable debugging */
+#undef NE_DEBUGGING
+
+/* Define to be printf format string for ne_off_t */
+#undef NE_FMT_NE_OFF_T
+
+/* Define to be printf format string for off64_t */
+#undef NE_FMT_OFF64_T
+
+/* Define to be printf format string for off_t */
+#undef NE_FMT_OFF_T
+
+/* Define to be printf format string for size_t */
+#undef NE_FMT_SIZE_T
+
+/* Define to be printf format string for ssize_t */
+#undef NE_FMT_SSIZE_T
+
+/* Define to be printf format string for time_t */
+#undef NE_FMT_TIME_T
+
+/* Define to be printf format string for XML_Size */
+#undef NE_FMT_XML_SIZE
+
+/* Defined if DAV is supported */
+#undef NE_HAVE_DAV
+
+/* Defined if I18N is supported */
+#undef NE_HAVE_I18N
+
+/* Defined if IPV6 is supported */
+#undef NE_HAVE_IPV6
+
+/* Defined if LFS is supported */
+#undef NE_HAVE_LFS
+
+/* Defined if LIBPXY is supported */
+#undef NE_HAVE_LIBPXY
+
+/* Defined if SSL is supported */
+#undef NE_HAVE_SSL
+
+/* Defined if TS_SSL is supported */
+#undef NE_HAVE_TS_SSL
+
+/* Defined if ZLIB is supported */
+#undef NE_HAVE_ZLIB
+
+/* Define to be filename of an SSL CA root bundle */
+#undef NE_SSL_CA_BUNDLE
+
+/* Define if poll() should be used */
+#undef NE_USE_POLL
+
+/* Define to be neon library major version */
+#undef NE_VERSION_MAJOR
+
+/* Define to be neon library minor version */
+#undef NE_VERSION_MINOR
+
+/* Define to be neon library patch version */
+#undef NE_VERSION_PATCH
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* The size of `off64_t', as computed by sizeof. */
+#undef SIZEOF_OFF64_T
+
+/* The size of `off_t', as computed by sizeof. */
+#undef SIZEOF_OFF_T
+
+/* The size of `size_t', as computed by sizeof. */
+#undef SIZEOF_SIZE_T
+
+/* The size of `ssize_t', as computed by sizeof. */
+#undef SIZEOF_SSIZE_T
+
+/* The size of `time_t', as computed by sizeof. */
+#undef SIZEOF_TIME_T
+
+/* The size of `XML_Size', as computed by sizeof. */
+#undef SIZEOF_XML_SIZE
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define to 1 if strerror_r returns char *. */
+#undef STRERROR_R_CHAR_P
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#undef TIME_WITH_SYS_TIME
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#undef USE_GAI_ADDRCONFIG
+
+/* Define if getaddrinfo() should be used */
+#undef USE_GETADDRINFO
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+#undef _GNU_SOURCE
+
+/* Define to 1 if on MINIX. */
+#undef _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#undef _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#undef _POSIX_SOURCE
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define if in_addr_t is not available */
+#undef in_addr_t
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef pid_t
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define if socklen_t is not available */
+#undef socklen_t
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.hw b/net/mmt/neon/config.hw
new file mode 100644
index 0000000..77a0358
--- /dev/null
+++ b/net/mmt/neon/config.hw
@@ -0,0 +1,98 @@
+/*                                                      -*- c -*-
+   Win32 config.h
+   Copyright (C) 1999-2000, Peter Boos <pedib@colorfullife.com>
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#if defined(_WIN32) && !defined(WIN32)
+#define WIN32
+#endif
+
+#ifdef WIN32
+
+#define NEON_VERSION "0.30.0"
+#define NE_VERSION_MAJOR (0)
+#define NE_VERSION_MINOR (30)
+
+#define HAVE_ERRNO_H
+#define HAVE_LIMITS_H
+#define HAVE_STDLIB_H
+#define HAVE_STRING_H
+
+#define HAVE_MEMCPY
+#define HAVE_SETSOCKOPT
+
+#define HAVE_SSPI
+
+#define NE_HAVE_TS_SSL 1
+
+/* Define to enable debugging */
+#define NE_DEBUGGING 1
+
+#define NE_FMT_SIZE_T "u"
+#define NE_FMT_SSIZE_T "d"
+#define NE_FMT_OFF_T "ld"
+#define NE_FMT_OFF64_T "I64d"
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+#ifndef NE_FMT_XML_SIZE
+#define NE_FMT_XML_SIZE "d"
+#endif
+
+/* needs adjusting for Win64... */
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+
+/* Win32 uses a underscore, so we use a macro to eliminate that. */
+#define snprintf			_snprintf
+/* VS2008 has this already defined */
+#if (_MSC_VER < 1500)
+#define vsnprintf			_vsnprintf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define strcasecmp			_strcmpi
+#define strncasecmp			_strnicmp
+#else
+#define strcasecmp			strcmpi
+#define strncasecmp			strnicmp
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1300
+#define HAVE_STRTOLL
+#define strtoll				_strtoi64
+#endif
+#define ssize_t				int
+#define inline                          __inline
+#if defined(NE_LFS)
+#define lseek64				_lseeki64
+#define fstat64				_fstat64
+#define stat64				__stat64
+#else
+#define off_t                           _off_t
+#endif
+
+#ifndef USE_GETADDRINFO
+#define in_addr_t                       unsigned int
+#endif
+
+typedef int socklen_t;
+
+#include <io.h>
+#define read _read
+
+#endif
diff --git a/net/mmt/neon/config.hw.in b/net/mmt/neon/config.hw.in
new file mode 100644
index 0000000..5bee759
--- /dev/null
+++ b/net/mmt/neon/config.hw.in
@@ -0,0 +1,98 @@
+/*                                                      -*- c -*-
+   Win32 config.h
+   Copyright (C) 1999-2000, Peter Boos <pedib@colorfullife.com>
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#if defined(_WIN32) && !defined(WIN32)
+#define WIN32
+#endif
+
+#ifdef WIN32
+
+#define NEON_VERSION "@VERSION@"
+#define NE_VERSION_MAJOR (@MAJOR@)
+#define NE_VERSION_MINOR (@MINOR@)
+
+#define HAVE_ERRNO_H
+#define HAVE_LIMITS_H
+#define HAVE_STDLIB_H
+#define HAVE_STRING_H
+
+#define HAVE_MEMCPY
+#define HAVE_SETSOCKOPT
+
+#define HAVE_SSPI
+
+#define NE_HAVE_TS_SSL 1
+
+/* Define to enable debugging */
+#define NE_DEBUGGING 1
+
+#define NE_FMT_SIZE_T "u"
+#define NE_FMT_SSIZE_T "d"
+#define NE_FMT_OFF_T "ld"
+#define NE_FMT_OFF64_T "I64d"
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+#ifndef NE_FMT_XML_SIZE
+#define NE_FMT_XML_SIZE "d"
+#endif
+
+/* needs adjusting for Win64... */
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+
+/* Win32 uses a underscore, so we use a macro to eliminate that. */
+#define snprintf			_snprintf
+/* VS2008 has this already defined */
+#if (_MSC_VER < 1500)
+#define vsnprintf			_vsnprintf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define strcasecmp			_strcmpi
+#define strncasecmp			_strnicmp
+#else
+#define strcasecmp			strcmpi
+#define strncasecmp			strnicmp
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1300
+#define HAVE_STRTOLL
+#define strtoll				_strtoi64
+#endif
+#define ssize_t				int
+#define inline                          __inline
+#if defined(NE_LFS)
+#define lseek64				_lseeki64
+#define fstat64				_fstat64
+#define stat64				__stat64
+#else
+#define off_t                           _off_t
+#endif
+
+#ifndef USE_GETADDRINFO
+#define in_addr_t                       unsigned int
+#endif
+
+typedef int socklen_t;
+
+#include <io.h>
+#define read _read
+
+#endif
diff --git a/net/mmt/neon/neon.gyp b/net/mmt/neon/neon.gyp
new file mode 100644
index 0000000..150fa8f
--- /dev/null
+++ b/net/mmt/neon/neon.gyp
@@ -0,0 +1,103 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libneon',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'neon',
+      'sources': [
+          'src/ne_dates.c',
+          'src/ne_session.c',
+          'src/ne_uri.c',
+          'src/ne_socket.c',
+          'src/ne_utils.c',
+          'src/ne_alloc.c',   
+          'src/ne_i18n.c',   
+          'src/ne_pkcs11.c',   
+          'src/ne_socks.c',
+          'src/ne_auth.c',   
+          'src/ne_sspi.c',
+          'src/ne_md5.c',  
+          'src/ne_redirect.c',  
+          'src/ne_string.c',
+          'src/ne_compress.c',  
+          'src/ne_ntlm.c',
+          'src/ne_request.c',
+          'src/ne_stubssl.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/neon/src/memleak.h b/net/mmt/neon/src/memleak.h
new file mode 100644
index 0000000..8d77dcb
--- /dev/null
+++ b/net/mmt/neon/src/memleak.h
@@ -0,0 +1,55 @@
+/* 
+   Memory leak wrappers
+   Copyright (C) 2003, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* WARNING: THIS IS AN INTERNAL NEON INTERFACE AND MUST NOT BE USED
+ * from NEON APPLICATIONS. */
+
+/* This file contains an alternate interface to the memory allocation
+ * wrappers in ne_alloc.c, which perform simple leak detection.  It
+ * MUST NOT BE INSTALLED, or used from neon applications. */
+
+#ifndef MEMLEAK_H
+#define MEMLEAK_H
+
+#include <stdio.h>
+
+#define ne_malloc(s) ne_malloc_ml(s, __FILE__, __LINE__)
+#define ne_calloc(s) ne_calloc_ml(s, __FILE__, __LINE__)
+#define ne_realloc(p, s) ne_realloc_ml(p, s, __FILE__, __LINE__)
+#define ne_strdup(s) ne_strdup_ml(s, __FILE__, __LINE__)
+#define ne_strndup(s, n) ne_strndup_ml(s, n, __FILE__, __LINE__)
+#define ne_free ne_free_ml
+
+/* Prototypes of allocation functions: */
+void *ne_malloc_ml(size_t size, const char *file, int line);
+void *ne_calloc_ml(size_t size, const char *file, int line);
+void *ne_realloc_ml(void *ptr, size_t s, const char *file, int line);
+char *ne_strdup_ml(const char *s, const char *file, int line);
+char *ne_strndup_ml(const char *s, size_t n, const char *file, int line);
+void ne_free_ml(void *ptr);
+
+/* Dump the list of currently allocated blocks to 'f'. */
+void ne_alloc_dump(FILE *f);
+
+/* Current number of bytes in allocated but not free'd. */
+extern size_t ne_alloc_used;
+
+#endif /* MEMLEAK_H */
diff --git a/net/mmt/neon/src/ne_207.c b/net/mmt/neon/src/ne_207.c
new file mode 100644
index 0000000..b9cc9e8
--- /dev/null
+++ b/net/mmt/neon/src/ne_207.c
@@ -0,0 +1,371 @@
+/* 
+   WebDAV 207 multi-status response handling
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Generic handling for WebDAV 207 Multi-Status responses. */
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_xml.h"
+#include "ne_207.h"
+#include "ne_uri.h"
+#include "ne_basic.h"
+
+#include "ne_internal.h"
+
+struct ne_207_parser_s {
+    ne_207_start_response *start_response;
+    ne_207_end_response *end_response;
+    ne_207_start_propstat *start_propstat;
+    ne_207_end_propstat *end_propstat;
+    ne_xml_parser *parser;
+    void *userdata;
+
+    ne_uri base;
+
+    ne_buffer *cdata;
+
+    /* remember whether we are in a response: the validation
+     * doesn't encapsulate this since we only count as being 
+     * "in a response" when we've seen the href element. */
+    int in_response;
+
+    /* current position */
+    void *response, *propstat;
+    /* caching */
+    ne_status status;
+    char *description, *href;
+};
+
+#define ELM_multistatus 1
+#define ELM_response 2
+#define ELM_responsedescription 3
+#define ELM_href 4
+#define ELM_prop (NE_207_STATE_PROP)
+#define ELM_status 6
+#define ELM_propstat 7
+
+static const struct ne_xml_idmap map207[] = {
+    { "DAV:", "multistatus", ELM_multistatus },
+    { "DAV:", "response", ELM_response },
+    { "DAV:", "responsedescription", ELM_responsedescription },
+    { "DAV:", "href", ELM_href },
+    { "DAV:", "propstat", ELM_propstat },
+    { "DAV:", "prop",  ELM_prop },
+    { "DAV:", "status", ELM_status }
+};
+
+/* Set the callbacks for the parser */
+void ne_207_set_response_handlers(ne_207_parser *p,
+                                  ne_207_start_response *start,
+                                  ne_207_end_response *end)
+{
+    p->start_response = start;
+    p->end_response = end;
+}
+
+void ne_207_set_propstat_handlers(ne_207_parser *p,
+				   ne_207_start_propstat *start,
+				   ne_207_end_propstat *end)
+{
+    p->start_propstat = start;
+    p->end_propstat = end;
+}
+
+void *ne_207_get_current_response(ne_207_parser *p)
+{
+    return p->response;
+}
+
+void *ne_207_get_current_propstat(ne_207_parser *p)
+{
+    return p->propstat;
+}
+
+/* return non-zero if (child, parent) is an interesting element */
+static int can_handle(int parent, int child) 
+{
+    return (parent == 0 && child == ELM_multistatus) ||
+        (parent == ELM_multistatus && child == ELM_response) ||
+        (parent == ELM_response && 
+         (child == ELM_href || child == ELM_status || 
+          child == ELM_propstat || child == ELM_responsedescription)) ||
+        (parent == ELM_propstat &&
+         (child == ELM_prop || child == ELM_status ||
+          child == ELM_responsedescription));
+}
+
+static int cdata_207(void *userdata, int state, const char *buf, size_t len)
+{
+    ne_207_parser *p = userdata;
+
+    if ((state == ELM_href || state == ELM_responsedescription ||
+         state == ELM_status) && p->cdata->used + len < 2048)
+        ne_buffer_append(p->cdata, buf, len);
+
+    return 0;
+}
+
+static int start_element(void *userdata, int parent, 
+                         const char *nspace, const char *name, 
+                         const char **atts) 
+{
+    ne_207_parser *p = userdata;
+    int state = ne_xml_mapid(map207, NE_XML_MAPLEN(map207), nspace, name);
+
+    if (!can_handle(parent, state))
+        return NE_XML_DECLINE;
+
+    /* if not in a response, ignore everything. */
+    if (!p->in_response && state != ELM_response && state != ELM_multistatus &&
+        state != ELM_href)
+        return NE_XML_DECLINE;
+
+    if (state == ELM_propstat && p->start_propstat) {
+        p->propstat = p->start_propstat(p->userdata, p->response);
+        if (p->propstat == NULL) {
+            return NE_XML_ABORT;
+        }
+    }
+
+    ne_buffer_clear(p->cdata);
+
+    return state;
+}
+
+#define GIVE_STATUS(p) ((p)->status.reason_phrase?&(p)->status:NULL)
+
+#define HAVE_CDATA(p) ((p)->cdata->used > 1)
+
+static int 
+end_element(void *userdata, int state, const char *nspace, const char *name)
+{
+    ne_207_parser *p = userdata;
+    const char *cdata = ne_shave(p->cdata->data, "\r\n\t ");
+
+    switch (state) {
+    case ELM_responsedescription:
+	if (HAVE_CDATA(p)) {
+            if (p->description) ne_free(p->description);
+	    p->description = ne_strdup(cdata);
+	}
+	break;
+    case ELM_href:
+	/* Now we have the href, begin the response */
+	if (p->start_response && HAVE_CDATA(p)) {
+            ne_uri ref, resolved;
+
+            if (ne_uri_parse(cdata, &ref) == 0) {
+                ne_uri_resolve(&p->base, &ref, &resolved);
+
+                p->response = p->start_response(p->userdata, &resolved);
+                p->in_response = 1;
+                ne_uri_free(&resolved);
+            }
+            ne_uri_free(&ref);
+	}
+	break;
+    case ELM_status:
+	if (HAVE_CDATA(p)) {
+            if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+	    if (ne_parse_statusline(cdata, &p->status)) {
+		char buf[500];
+		NE_DEBUG(NE_DBG_HTTP, "Status line: %s\n", cdata);
+		ne_snprintf(buf, 500, 
+			    _("Invalid HTTP status line in status element "
+                              "at line %d of response:\nStatus line was: %s"),
+			    ne_xml_currentline(p->parser), cdata);
+		ne_xml_set_error(p->parser, buf);
+		return -1;
+	    } else {
+		NE_DEBUG(NE_DBG_XML, "Decoded status line: %s\n", cdata);
+	    }
+	}
+	break;
+    case ELM_propstat:
+	if (p->end_propstat)
+	    p->end_propstat(p->userdata, p->propstat, GIVE_STATUS(p),
+			    p->description);
+	p->propstat = NULL;
+        if (p->description) ne_free(p->description);
+        if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+        p->description = p->status.reason_phrase = NULL;
+	break;
+    case ELM_response:
+        if (!p->in_response) break;
+	if (p->end_response)
+	    p->end_response(p->userdata, p->response, GIVE_STATUS(p),
+			    p->description);
+	p->response = NULL;
+	p->in_response = 0;
+        if (p->description) ne_free(p->description);
+        if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+        p->description = p->status.reason_phrase = NULL;
+	break;
+    }
+    return 0;
+}
+
+ne_207_parser *ne_207_create(ne_xml_parser *parser, const ne_uri *base, 
+                             void *userdata)
+{
+    ne_207_parser *p = ne_calloc(sizeof *p);
+
+    p->parser = parser;
+    p->userdata = userdata;
+    p->cdata = ne_buffer_create();
+
+    ne_uri_copy(&p->base, base);
+
+    /* Add handler for the standard 207 elements */
+    ne_xml_push_handler(parser, start_element, cdata_207, end_element, p);
+    
+    return p;
+}
+
+void ne_207_destroy(ne_207_parser *p) 
+{
+    if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+    ne_buffer_destroy(p->cdata);
+    ne_uri_free(&p->base);
+    ne_free(p);
+}
+
+int ne_accept_207(void *userdata, ne_request *req, const ne_status *status)
+{
+    return (status->code == 207);
+}
+
+/* Handling of 207 errors: we keep a string buffer, and append
+ * messages to it as they come down.
+ *
+ * Note, 424 means it would have worked but something else went wrong.
+ * We will have had the error for "something else", so we display
+ * that, and skip 424 errors. */
+
+/* This is passed as userdata to the 207 code. */
+struct context {
+    char *href;
+    ne_buffer *buf;
+    unsigned int is_error;
+};
+
+static void *start_response(void *userdata, const ne_uri *uri)
+{
+    struct context *ctx = userdata;
+    if (ctx->href) ne_free(ctx->href);
+    ctx->href = ne_uri_unparse(uri);
+    return NULL;
+}
+
+static void handle_error(struct context *ctx, const ne_status *status,
+			 const char *description)
+{
+    if (status && status->klass != 2 && status->code != 424) {
+	char buf[50];
+	ctx->is_error = 1;
+	sprintf(buf, "%d", status->code);
+	ne_buffer_concat(ctx->buf, ctx->href, ": ", 
+			 buf, " ", status->reason_phrase, "\n", NULL);
+	if (description != NULL) {
+	    /* TODO: these can be multi-line. Would be good to
+	     * word-wrap this at col 80. */
+	    ne_buffer_concat(ctx->buf, " -> ", description, "\n", NULL);
+	}
+    }
+
+}
+
+static void end_response(void *userdata, void *response,
+			 const ne_status *status, const char *description)
+{
+    struct context *ctx = userdata;
+    handle_error(ctx, status, description);
+}
+
+static void 
+end_propstat(void *userdata, void *propstat,
+	     const ne_status *status, const char *description)
+{
+    struct context *ctx = userdata;
+    handle_error(ctx, status, description);
+}
+
+/* Dispatch a DAV request and handle a 207 error response appropriately */
+/* TODO: hook up Content-Type parsing; passing charset to XML parser */
+int ne_simple_request(ne_session *sess, ne_request *req)
+{
+    int ret;
+    struct context ctx = {0};
+    ne_207_parser *p207;
+    ne_xml_parser *p = ne_xml_create();
+    ne_uri base = {0};
+
+    /* Mock up a base URI; it should really be retrieved from the
+     * request object. */
+    ne_fill_server_uri(sess, &base);
+    base.path = ne_strdup("/");
+    p207 = ne_207_create(p, &base, &ctx);
+    ne_uri_free(&base);    
+
+    /* The error string is progressively written into the
+     * ne_buffer by the element callbacks */
+    ctx.buf = ne_buffer_create();
+
+    ne_207_set_response_handlers(p207, start_response, end_response);
+    ne_207_set_propstat_handlers(p207, NULL, end_propstat);
+    
+    ne_add_response_body_reader(req, ne_accept_207, ne_xml_parse_v, p);
+
+    ret = ne_request_dispatch(req);
+
+    if (ret == NE_OK) {
+	if (ne_get_status(req)->code == 207) {
+	    if (ne_xml_failed(p)) { 
+		/* The parse was invalid */
+		ne_set_error(sess, "%s", ne_xml_get_error(p));
+		ret = NE_ERROR;
+	    } else if (ctx.is_error) {
+		/* If we've actually got any error information
+		 * from the 207, then set that as the error */
+		ne_set_error(sess, "%s", ctx.buf->data);
+		ret = NE_ERROR;
+	    }
+	} else if (ne_get_status(req)->klass != 2) {
+	    ret = NE_ERROR;
+	}
+    }
+
+    ne_207_destroy(p207);
+    ne_xml_destroy(p);
+    ne_buffer_destroy(ctx.buf);
+    if (ctx.href) ne_free(ctx.href);
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+    
diff --git a/net/mmt/neon/src/ne_207.h b/net/mmt/neon/src/ne_207.h
new file mode 100644
index 0000000..2779e56
--- /dev/null
+++ b/net/mmt/neon/src/ne_207.h
@@ -0,0 +1,103 @@
+/* 
+   WebDAV 207 multi-status response handling
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_207_H
+#define NE_207_H
+
+#include "ne_xml.h"
+#include "ne_request.h" /* for ne_request */
+#include "ne_uri.h" /* for ne_uri */
+
+NE_BEGIN_DECLS
+
+/* The defined state integer for the '{DAV:}prop' element. */
+#define NE_207_STATE_PROP (50)
+/* This interface reserves the state integers 'x' where 0 < x < 100 */
+#define NE_207_STATE_TOP (100)
+
+/* Handling of 207 multistatus XML documents.  A "multistatus"
+ * document is made up of a set of responses, each concerned with a
+ * particular resource.  Each response may have an associated result
+ * status and failure description.  A response is made up of a set of
+ * propstats, each of which again may have an associated result status
+ * and failure description. */
+
+/* Start and end response callbacks trigger at the start and end of
+ * each "response" within the multistatus body. 'uri' gives the URI
+ * of the resource which is subject of this response.  The return
+ * value of a 'start_response' callback is passed as the 'response'
+ * parameter to the corresponding 'end_response' parameter. */
+typedef void *ne_207_start_response(void *userdata, const ne_uri *uri);
+typedef void ne_207_end_response(void *userdata, void *response,
+                                 const ne_status *status,
+                                 const char *description);
+
+/* Similarly, start and end callbacks for each propstat within the
+ * response.  The return value of the 'start_response' callback for
+ * the response in which this propstat is contains is passed as the
+ * 'response' parameter.  The return value of each 'start_propstat' is
+ * passed as the 'propstat' parameter' to the corresponding
+ * 'end_propstat' callback.  If the start_propstat callback returns
+ * NULL, parsing is aborted (the XML parser error must be set by the
+ * callback). */
+typedef void *ne_207_start_propstat(void *userdata, void *response);
+typedef void ne_207_end_propstat(void *userdata, void *propstat,
+                                 const ne_status *status,
+                                 const char *description);
+
+typedef struct ne_207_parser_s ne_207_parser;
+
+/* Create 207 parser an add the handlers the the given parser's
+ * handler stack.  URI references in the 207 response will be resolved
+ * relative to the base URI 'base'. */
+ne_207_parser *ne_207_create(ne_xml_parser *parser, const ne_uri *base, 
+                             void *userdata);
+
+/* Register response handling callbacks. */
+void ne_207_set_response_handlers(ne_207_parser *p,
+                                  ne_207_start_response *start,
+                                  ne_207_end_response *end);
+
+/* Register propstat handling callbacks. */
+void ne_207_set_propstat_handlers(ne_207_parser *p, 
+                                  ne_207_start_propstat *start,
+                                  ne_207_end_propstat *end);
+
+/* Destroy the parser */
+void ne_207_destroy(ne_207_parser *p);
+
+/* An acceptance function which only accepts 207 responses */
+int ne_accept_207(void *userdata, ne_request *req, const ne_status *status);
+
+void *ne_207_get_current_propstat(ne_207_parser *p);
+void *ne_207_get_current_response(ne_207_parser *p);
+
+/* Dispatch request 'req', returning:
+ *  NE_ERROR: for a dispatch error, or a non-2xx response, or a
+ *            207 response which contained a non-2xx propstat
+ *  NE_OK: for a 2xx response or a 207 response which contained
+ *            only 2xx-class propstats.
+ * The request object is destroyed in both cases. */
+int ne_simple_request(ne_session *sess, ne_request *req);
+
+NE_END_DECLS
+
+#endif /* NE_207_H */
diff --git a/net/mmt/neon/src/ne_acl.h b/net/mmt/neon/src/ne_acl.h
new file mode 100644
index 0000000..a473981
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl.h
@@ -0,0 +1,60 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/*
+ * DEPRECATED ACL Interface.  See ne_acl3744.h for replacement API.
+ */
+
+#ifndef NE_ACL_H
+#define NE_ACL_H
+
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+typedef struct
+{
+    enum {
+	ne_acl_href,
+	ne_acl_property,
+	ne_acl_all
+    } apply;
+    
+    enum {
+	ne_acl_grant,
+	ne_acl_deny
+    } type;
+
+    char *principal;
+    int read;
+    int read_acl;
+    int write;
+    int write_acl;
+    int read_cuprivset;
+} ne_acl_entry;
+
+/* Set the ACL for the given resource to the list of ACL entries. */
+int ne_acl_set(ne_session *sess, const char *uri,
+	       const ne_acl_entry entries[], int numentries);
+
+NE_END_DECLS
+
+#endif /* NE_ACL_H */
diff --git a/net/mmt/neon/src/ne_acl3744.c b/net/mmt/neon/src/ne_acl3744.c
new file mode 100644
index 0000000..3ad7e1d
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl3744.c
@@ -0,0 +1,179 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, 2008, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2001, Arun Garg <arung@pspl.co.in>
+   Copyright (C) 2007 Henrik Holst <henrik.holst2@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Contributed by Arun Garg <arung@pspl.co.in> */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_locks.h"
+#include "ne_alloc.h"
+#include "ne_string.h"
+#include "ne_acl3744.h"
+#include "ne_uri.h"
+#include "ne_xml.h" /* for NE_XML_MEDIA_TYPE */
+
+#define EOL "\r\n"
+
+static ne_buffer *acl_body(const ne_acl_entry *right, int count)
+{
+    ne_buffer *body = ne_buffer_create();
+    int m;
+
+    ne_buffer_zappend(body,
+		      "<?xml version=\"1.0\" encoding=\"utf-8\"?>" EOL
+		      "<acl xmlns='DAV:'>" EOL);
+
+    for (m = 0; m < count; m++) {
+	const char *type;
+
+	type = (right[m].type == ne_acl_grant ? "grant" : "deny");
+
+	ne_buffer_concat(body, "<ace>" EOL "<principal>", NULL);
+
+	switch (right[m].target) {
+	case ne_acl_all:
+	    ne_buffer_czappend(body, "<all/>" EOL);
+	    break;
+	case ne_acl_authenticated:
+	    ne_buffer_czappend(body, "<authenticated/>" EOL);
+	    break;
+	case ne_acl_unauthenticated:
+	    ne_buffer_czappend(body, "<unauthenticated/>" EOL);
+	    break;
+	case ne_acl_self:
+	    ne_buffer_czappend(body, "<self/>" EOL);
+	    break;
+	case ne_acl_property:
+	    ne_buffer_concat(body, "<property><", right[m].tname,
+			     "/></property>" EOL, NULL);
+	    break;
+	case ne_acl_href:
+	    ne_buffer_concat(body, "<href>", right[m].tname,
+			     "</href>" EOL, NULL);
+	    break;
+	}
+
+	ne_buffer_concat(body, "</principal>" EOL 
+                         "<", type, ">" EOL, NULL);
+
+	if ((right[m].privileges & NE_ACL_READ) == NE_ACL_READ)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE) == NE_ACL_WRITE)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_PROPERTIES) == NE_ACL_WRITE_PROPERTIES)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-properties/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_CONTENT) == NE_ACL_WRITE_CONTENT)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-content/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_UNLOCK) == NE_ACL_UNLOCK)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<unlock/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_READ_ACL) == NE_ACL_READ_ACL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-acl/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_READ_CUPRIVSET) == NE_ACL_READ_CUPRIVSET)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-current-user-privileges-set/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_ACL) == NE_ACL_WRITE_ACL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-acl/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_BIND) == NE_ACL_BIND)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<bind/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_UNBIND) == NE_ACL_UNBIND)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<unbind/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_ALL) == NE_ACL_ALL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<all/>" "</privilege>" EOL,
+			     NULL);
+
+	ne_buffer_concat(body, "</", type, ">" EOL, NULL);
+	ne_buffer_czappend(body, "</ace>" EOL);
+    }
+
+    ne_buffer_czappend(body, "</acl>" EOL);
+
+    return body;
+}
+
+int ne_acl3744_set(ne_session *sess, const char *uri,
+                   const ne_acl_entry *entries, int numentries)
+{
+    int ret;
+    ne_request *req = ne_request_create(sess, "ACL", uri);
+    ne_buffer *body = acl_body(entries, numentries);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+#endif
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ret = ne_request_dispatch(req);
+
+    ne_buffer_destroy(body);
+
+    if (ret == NE_OK && ne_get_status(req)->code == 207) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_acl3744.h b/net/mmt/neon/src/ne_acl3744.h
new file mode 100644
index 0000000..dc8835c
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl3744.h
@@ -0,0 +1,85 @@
+/*
+   Access control
+   Copyright (C) 2001-2007, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2001, Arun Garg <arung@pspl.co.in>
+   Copyright (C) 2007 Henrik Holst <henrik.holst2@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_ACL3744_H
+#define NE_ACL3744_H
+
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+#define NE_ACL_READ             (0x0001)
+#define NE_ACL_WRITE            (0x0002)
+#define NE_ACL_WRITE_PROPERTIES (0x0004)
+#define NE_ACL_WRITE_CONTENT    (0x0008)
+#define NE_ACL_UNLOCK           (0x0010)
+#define NE_ACL_READ_ACL         (0x0020)
+#define NE_ACL_READ_CUPRIVSET   (0x0040)
+#define NE_ACL_WRITE_ACL        (0x0080)
+#define NE_ACL_BIND             (0x0100)
+#define NE_ACL_UNBIND           (0x0200)
+#define NE_ACL_ALL              (0x0400)
+
+enum ne_acl_target {
+    ne_acl_href,
+    ne_acl_property,
+    ne_acl_all,
+    ne_acl_authenticated,
+    ne_acl_unauthenticated,
+    ne_acl_self
+};
+
+enum ne_acl_optype {
+    ne_acl_grant,
+    ne_acl_deny
+};
+
+/* A simplified representation of an Access Control Element (ACE): */
+typedef struct {
+    /* Identify the principal(s) to which this ACE applies: */
+    enum ne_acl_target target;
+
+    /* Whether to grant or deny access: */
+    enum ne_acl_optype type;
+
+    /* If target == ne_acl_href, tname must be non-NULL and give the
+     * principal URL.  If target == ne_acl_property, tname must be
+     * non-NULL and be a property name, including an XML namespace
+     * definition, if appropriate (the default namespace being
+     * "DAV:").  This restricts access as described at:
+     * http://tools.ietf.org/html/rfc3744#section-5.5.1 */
+    char *tname;
+
+    /* The set of privileges to be restricted; a bit mask of one or
+     * more of the NE_ACL_* constants defined above: */
+    unsigned int privileges;
+
+} ne_acl_entry;
+
+/* Set the ACL for the given resource to the list of ACL entries. */
+int ne_acl3744_set(ne_session *sess, const char *path,
+                   const ne_acl_entry entries[], int numentries);
+
+NE_END_DECLS
+
+#endif /* NE_ACL3744_H */
diff --git a/net/mmt/neon/src/ne_alloc.c b/net/mmt/neon/src/ne_alloc.c
new file mode 100644
index 0000000..7d98bf2
--- /dev/null
+++ b/net/mmt/neon/src/ne_alloc.c
@@ -0,0 +1,223 @@
+/* 
+   Replacement memory allocation handling etc.
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <stdio.h>
+
+#include "ne_alloc.h"
+
+static ne_oom_callback_fn oom;
+
+void ne_oom_callback(ne_oom_callback_fn callback)
+{
+    oom = callback;
+}
+
+#ifndef NEON_MEMLEAK
+
+#define DO_MALLOC(ptr, len) do {		\
+    ptr = malloc((len));			\
+    if (!ptr) {					\
+	if (oom != NULL)			\
+	    oom();				\
+	abort();				\
+    }						\
+} while(0);
+
+void *ne_malloc(size_t len) 
+{
+    void *ptr;
+    DO_MALLOC(ptr, len);
+    return ptr;
+}
+
+void *ne_calloc(size_t len) 
+{
+    void *ptr;
+    DO_MALLOC(ptr, len);
+    return memset(ptr, 0, len);
+}
+
+void *ne_realloc(void *ptr, size_t len)
+{
+    void *ret = realloc(ptr, len);
+    if (!ret) {
+	if (oom)
+	    oom();
+	abort();
+    }
+    return ret;
+}
+
+#ifdef WIN32
+/* Implemented only to ensure free is bound to the correct DLL. */
+void ne_free(void *ptr)
+{
+    free(ptr);
+}
+#endif
+
+char *ne_strdup(const char *s) 
+{
+    char *ret;
+    DO_MALLOC(ret, strlen(s) + 1);
+    return strcpy(ret, s);
+}
+
+char *ne_strndup(const char *s, size_t n)
+{
+    char *new;
+    DO_MALLOC(new, n+1);
+    new[n] = '\0';
+    memcpy(new, s, n);
+    return new;
+}
+
+#else /* NEON_MEMLEAK */
+
+#include <assert.h>
+
+/* Memory-leak detection implementation: ne_malloc and friends are
+ * #defined to ne_malloc_ml etc by memleak.h, which is conditionally
+ * included by config.h. */
+
+/* memory allocated be ne_*alloc, but not freed. */
+size_t ne_alloc_used = 0;
+
+static struct block {
+    void *ptr;
+    size_t len;
+    const char *file;
+    int line;
+    struct block *next;
+} *blocks = NULL;
+
+void ne_alloc_dump(FILE *f)
+{
+    struct block *b;
+
+    for (b = blocks; b != NULL; b = b->next)
+        fprintf(f, "%" NE_FMT_SIZE_T "b@%s:%d%s", b->len, b->file, b->line,
+                b->next?", ":"");
+}
+
+static void *tracking_malloc(size_t len, const char *file, int line)
+{
+    void *ptr = malloc((len));
+    struct block *block;
+
+    if (!ptr) {
+	if (oom) oom();
+	abort();
+    }
+    
+    block = malloc(sizeof *block);
+    if (block != NULL) {
+        block->ptr = ptr;
+        block->len = len;
+        block->file = file;
+        block->line = line;
+        block->next = blocks;
+        blocks = block;
+        ne_alloc_used += len;
+    }
+
+    return ptr;
+}
+
+void *ne_malloc_ml(size_t size, const char *file, int line)
+{
+    return tracking_malloc(size, file, line);
+}
+
+void *ne_calloc_ml(size_t size, const char *file, int line)
+{
+    return memset(tracking_malloc(size, file, line), 0, size);
+}
+
+void *ne_realloc_ml(void *ptr, size_t s, const char *file, int line)
+{
+    void *ret;
+    struct block *b;
+
+    if (ptr == NULL)
+        return tracking_malloc(s, file, line);
+
+    ret = realloc(ptr, s);
+    if (!ret) {
+        if (oom) oom();
+        abort();
+    }
+    
+    for (b = blocks; b != NULL; b = b->next) {
+        if (b->ptr == ptr) {
+            ne_alloc_used += s - b->len;
+            b->ptr = ret;
+            b->len = s;
+            break;
+        }
+    }
+    assert(b != NULL);
+
+    return ret;
+}
+
+char *ne_strdup_ml(const char *s, const char *file, int line)
+{
+    return strcpy(tracking_malloc(strlen(s) + 1, file, line), s);
+}
+
+char *ne_strndup_ml(const char *s, size_t n, const char *file, int line)
+{
+    char *ret = tracking_malloc(n + 1, file, line);
+    ret[n] = '\0';
+    return memcpy(ret, s, n);
+}
+
+void ne_free_ml(void *ptr)
+{
+    struct block *b, *last = NULL;
+
+    for (b = blocks; b != NULL; last = b, b = b->next) {
+        if (b->ptr == ptr) {
+            ne_alloc_used -= b->len;
+            if (last) 
+                last->next = b->next;
+            else
+                blocks = b->next;
+            free(b);
+            break;
+        }
+    }
+
+    free(ptr);
+}
+
+#endif /* NEON_MEMLEAK */
diff --git a/net/mmt/neon/src/ne_alloc.h b/net/mmt/neon/src/ne_alloc.h
new file mode 100644
index 0000000..0322fa7
--- /dev/null
+++ b/net/mmt/neon/src/ne_alloc.h
@@ -0,0 +1,60 @@
+/* 
+   Replacement memory allocation handling etc.
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_ALLOC_H
+#define NE_ALLOC_H
+
+#include <stdlib.h>
+
+#ifndef WIN32
+#include <sys/types.h>
+#endif
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+typedef void (*ne_oom_callback_fn)(void);
+
+/* Set callback which is called if malloc() returns NULL. */
+void ne_oom_callback(ne_oom_callback_fn callback);
+
+#ifndef NEON_MEMLEAK
+/* Replacements for standard C library memory allocation functions,
+ * which never return NULL. If the C library malloc() returns NULL,
+ * neon will abort(); calling an OOM callback beforehand if one is
+ * registered.  The C library will only ever return NULL if the
+ * operating system does not use optimistic memory allocation. */
+void *ne_malloc(size_t size) ne_attribute_malloc;
+void *ne_calloc(size_t size) ne_attribute_malloc;
+void *ne_realloc(void *ptr, size_t s);
+char *ne_strdup(const char *s) ne_attribute_malloc;
+char *ne_strndup(const char *s, size_t n) ne_attribute_malloc;
+#ifdef WIN32
+void ne_free(void *ptr);
+#else
+#define ne_free free
+#endif
+#endif
+
+NE_END_DECLS
+
+#endif /* NE_ALLOC_H */
diff --git a/net/mmt/neon/src/ne_auth.c b/net/mmt/neon/src/ne_auth.c
new file mode 100644
index 0000000..48a0cb5
--- /dev/null
+++ b/net/mmt/neon/src/ne_auth.c
@@ -0,0 +1,1719 @@
+/* 
+   HTTP Authentication routines
+   Copyright (C) 1999-2011, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h> /* for getpid() */
+#endif
+
+#ifdef WIN32
+#include <windows.h> /* for GetCurrentThreadId() etc */
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/rand.h>
+#elif defined(HAVE_GNUTLS)
+#include <gnutls/gnutls.h>
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b00
+#include <gcrypt.h>
+#else
+#include <gnutls/crypto.h>
+#endif
+#endif
+
+#include <errno.h>
+#include <time.h>
+
+#include "ne_md5.h"
+#include "ne_dates.h"
+#include "ne_request.h"
+#include "ne_auth.h"
+#include "ne_string.h"
+#include "ne_utils.h"
+#include "ne_alloc.h"
+#include "ne_uri.h"
+#include "ne_internal.h"
+
+#ifdef HAVE_GSSAPI
+#ifdef HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
+#include <gssapi/gssapi_generic.h>
+#endif
+#else
+#include <gssapi.h>
+#endif
+#endif
+
+#ifdef HAVE_SSPI
+#include "ne_sspi.h"
+#endif
+
+#ifdef HAVE_NTLM
+#include "ne_ntlm.h"
+#endif
+ 
+#define HOOK_SERVER_ID "http://webdav.org/neon/hooks/server-auth"
+#define HOOK_PROXY_ID "http://webdav.org/neon/hooks/proxy-auth"
+
+typedef enum { 
+    auth_alg_md5,
+    auth_alg_md5_sess,
+    auth_alg_unknown
+} auth_algorithm;
+
+/* Selected method of qop which the client is using */
+typedef enum {
+    auth_qop_none,
+    auth_qop_auth
+} auth_qop;
+
+/* A callback/userdata pair registered by the application for
+ * a particular set of protocols. */
+struct auth_handler {
+    unsigned protomask; 
+
+    ne_auth_creds creds;
+    void *userdata;
+    int attempt; /* number of invocations of this callback for
+                  * current request. */
+    
+    struct auth_handler *next;
+};
+
+/* A challenge */
+struct auth_challenge {
+    const struct auth_protocol *protocol;
+    struct auth_handler *handler;
+    const char *realm, *nonce, *opaque, *domain;
+    unsigned int stale; /* if stale=true */
+    unsigned int got_qop; /* we were given a qop directive */
+    unsigned int qop_auth; /* "auth" token in qop attrib */
+    auth_algorithm alg;
+    struct auth_challenge *next;
+};
+
+static const struct auth_class {
+    const char *id, *req_hdr, *resp_hdr, *resp_info_hdr;
+    int status_code; /* Response status-code to trap. */
+    int fail_code;   /* NE_* request to fail with. */
+    const char *error_noauth; /* Error message template use when
+                               * giving up authentication attempts. */
+} ah_server_class = {
+    HOOK_SERVER_ID,
+    "Authorization", "WWW-Authenticate", "Authentication-Info",
+    401, NE_AUTH,
+    N_("Could not authenticate to server: %s")
+}, ah_proxy_class = {
+    HOOK_PROXY_ID,
+    "Proxy-Authorization", "Proxy-Authenticate", "Proxy-Authentication-Info",
+    407, NE_PROXYAUTH,
+    N_("Could not authenticate to proxy server: %s")
+};
+
+/* Authentication session state. */
+typedef struct {
+    ne_session *sess;
+
+    /* Which context will auth challenges be accepted? */
+    enum {
+        AUTH_ANY, /* ignore nothing. */
+        AUTH_CONNECT, /* only in response to a CONNECT request. */
+        AUTH_NOTCONNECT /* only in non-CONNECT responsees */
+    } context;
+    
+    /* Protocol type for server/proxy auth. */
+    const struct auth_class *spec;
+    
+    /* The protocol used for this authentication session */
+    const struct auth_protocol *protocol;
+
+    struct auth_handler *handlers;
+
+    /*** Session details ***/
+
+    /* The username and password we are using to authenticate with */
+    char username[NE_ABUFSIZ];
+
+    /* This used for Basic auth */
+    char *basic; 
+#ifdef HAVE_GSSAPI
+    /* for the GSSAPI/Negotiate scheme: */
+    char *gssapi_token;
+    gss_ctx_id_t gssctx;
+    gss_name_t gssname;
+    gss_OID gssmech;
+#endif
+#ifdef HAVE_SSPI
+    /* This is used for SSPI (Negotiate/NTLM) auth */
+    char *sspi_token;
+    void *sspi_context;
+    char *sspi_host;
+#endif
+#ifdef HAVE_NTLM
+     /* This is used for NTLM auth */
+     ne_ntlm_context *ntlm_context;
+#endif
+    /* These all used for Digest auth */
+    char *realm;
+    char *nonce;
+    char *cnonce;
+    char *opaque;
+    char **domains; /* list of paths given as domain. */
+    size_t ndomains; /* size of domains array */
+    auth_qop qop;
+    auth_algorithm alg;
+    unsigned int nonce_count;
+    /* The ASCII representation of the session's H(A1) value */
+    char h_a1[33];
+
+    /* Temporary store for half of the Request-Digest
+     * (an optimisation - used in the response-digest calculation) */
+    struct ne_md5_ctx *stored_rdig;
+} auth_session;
+
+struct auth_request {
+    /*** Per-request details. ***/
+    ne_request *request; /* the request object. */
+
+    /* The method and URI we are using for the current request */
+    const char *uri;
+    const char *method;
+    
+    int attempt; /* number of times this request has been retries due
+                  * to auth challenges. */
+};
+
+/* Used if this protocol takes an unquoted non-name/value-pair
+ * parameter in the challenge. */
+#define AUTH_FLAG_OPAQUE_PARAM (0x0001)
+/* Used if this Authentication-Info may be sent for non-40[17]
+ * response for this protocol. */
+#define AUTH_FLAG_VERIFY_NON40x (0x0002)
+/* Used for broken the connection-based auth schemes. */
+#define AUTH_FLAG_CONN_AUTH (0x0004)
+
+struct auth_protocol {
+    unsigned id; /* public NE_AUTH_* id. */
+
+    int strength; /* protocol strength for sort order. */
+
+    const char *name; /* protocol name. */
+    
+    /* Parse the authentication challenge; returns zero on success, or
+     * non-zero if this challenge be handled.  'attempt' is the number
+     * of times the request has been resent due to auth challenges.
+     * On failure, challenge_error() should be used to append an error
+     * message to the error buffer 'errmsg'. */
+    int (*challenge)(auth_session *sess, int attempt,
+                     struct auth_challenge *chall, ne_buffer **errmsg);
+
+    /* Return the string to send in the -Authenticate request header:
+     * (ne_malloc-allocated, NUL-terminated string) */
+    char *(*response)(auth_session *sess, struct auth_request *req);
+    
+    /* Parse a Authentication-Info response; returns NE_* error code
+     * on failure; on failure, the session error string must be
+     * set. */
+    int (*verify)(struct auth_request *req, auth_session *sess,
+                  const char *value);
+    
+    int flags; /* AUTH_FLAG_* flags */
+};
+
+/* Helper function to append an error to the buffer during challenge
+ * handling.  Pass printf-style string.  *errmsg may be NULL and is
+ * allocated if necessary.  errmsg must be non-NULL. */
+static void challenge_error(ne_buffer **errmsg, const char *fmt, ...)
+    ne_attribute((format(printf, 2, 3)));
+
+/* Free the domains array, precondition sess->ndomains > 0. */
+static void free_domains(auth_session *sess)
+{
+    do {
+        ne_free(sess->domains[sess->ndomains - 1]);
+    } while (--sess->ndomains);
+    ne_free(sess->domains);
+    sess->domains = NULL;
+}
+
+static void clean_session(auth_session *sess) 
+{
+    if (sess->basic) ne_free(sess->basic);
+    if (sess->nonce) ne_free(sess->nonce);
+    if (sess->cnonce) ne_free(sess->cnonce);
+    if (sess->opaque) ne_free(sess->opaque);
+    if (sess->realm) ne_free(sess->realm);
+    sess->realm = sess->basic = sess->cnonce = sess->nonce =
+        sess->opaque = NULL;
+    if (sess->stored_rdig) {
+        ne_md5_destroy_ctx(sess->stored_rdig);
+        sess->stored_rdig = NULL;
+    }
+    if (sess->ndomains) free_domains(sess);
+#ifdef HAVE_GSSAPI
+    {
+        unsigned int major;
+
+        if (sess->gssctx != GSS_C_NO_CONTEXT)
+            gss_delete_sec_context(&major, &sess->gssctx, GSS_C_NO_BUFFER);
+        
+    }
+    if (sess->gssapi_token) ne_free(sess->gssapi_token);
+    sess->gssapi_token = NULL;
+#endif
+#ifdef HAVE_SSPI
+    if (sess->sspi_token) ne_free(sess->sspi_token);
+    sess->sspi_token = NULL;
+    ne_sspi_destroy_context(sess->sspi_context);
+    sess->sspi_context = NULL;
+    if (sess->sspi_host) ne_free(sess->sspi_host);
+    sess->sspi_host = NULL;
+#endif
+#ifdef HAVE_NTLM
+    if (sess->ntlm_context) {
+        ne__ntlm_destroy_context(sess->ntlm_context);
+        sess->ntlm_context = NULL;
+    }
+#endif
+
+    sess->protocol = NULL;
+}
+
+/* Returns client nonce string. */
+static char *get_cnonce(void) 
+{
+    char ret[33];
+    unsigned char data[256];
+    struct ne_md5_ctx *hash;
+
+    hash = ne_md5_create_ctx();
+
+#ifdef HAVE_GNUTLS
+    if (1) {
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b00
+        gcry_create_nonce(data, sizeof data);
+#else
+        gnutls_rnd(GNUTLS_RND_NONCE, data, sizeof data);
+#endif
+        ne_md5_process_bytes(data, sizeof data, hash);
+    }
+    else
+#elif defined(HAVE_OPENSSL)
+    if (RAND_status() == 1 && RAND_pseudo_bytes(data, sizeof data) >= 0) {
+	ne_md5_process_bytes(data, sizeof data, hash);
+    } 
+    else 
+#endif /* HAVE_OPENSSL */
+    {
+        /* Fallback sources of random data: all bad, but no good sources
+         * are available. */
+        
+        /* Uninitialized stack data; yes, happy valgrinders, this is
+         * supposed to be here. */
+        ne_md5_process_bytes(data, sizeof data, hash);
+        
+        {
+#ifdef HAVE_GETTIMEOFDAY
+            struct timeval tv;
+            if (gettimeofday(&tv, NULL) == 0)
+                ne_md5_process_bytes(&tv, sizeof tv, hash);
+#else /* HAVE_GETTIMEOFDAY */
+            time_t t = time(NULL);
+            ne_md5_process_bytes(&t, sizeof t, hash);
+#endif
+        }
+        {
+#ifdef WIN32
+            DWORD pid = GetCurrentThreadId();
+#else
+            pid_t pid = getpid();
+#endif
+            ne_md5_process_bytes(&pid, sizeof pid, hash);
+        }
+    }
+
+    ne_md5_finish_ascii(hash, ret);
+    ne_md5_destroy_ctx(hash);
+
+    return ne_strdup(ret);
+}
+
+/* Callback to retrieve user credentials for given session on given
+ * attempt (pre request) for given challenge.  Password is written to
+ * pwbuf (of size NE_ABUFSIZ.  On error, challenge_error() is used
+ * with errmsg. */
+static int get_credentials(auth_session *sess, ne_buffer **errmsg, int attempt,
+                           struct auth_challenge *chall, char *pwbuf) 
+{
+    if (chall->handler->creds(chall->handler->userdata, sess->realm, 
+                              chall->handler->attempt++, sess->username, pwbuf) == 0) {
+        return 0;
+    } else {
+        challenge_error(errmsg, _("rejected %s challenge"), 
+                        chall->protocol->name);
+        return -1;
+    }
+}
+
+/* Examine a Basic auth challenge.
+ * Returns 0 if an valid challenge, else non-zero. */
+static int basic_challenge(auth_session *sess, int attempt,
+                           struct auth_challenge *parms,
+                           ne_buffer **errmsg) 
+{
+    char *tmp, password[NE_ABUFSIZ];
+
+    /* Verify challenge... must have a realm */
+    if (parms->realm == NULL) {
+        challenge_error(errmsg, _("missing realm in Basic challenge"));
+	return -1;
+    }
+
+    clean_session(sess);
+    
+    sess->realm = ne_strdup(parms->realm);
+
+    if (get_credentials(sess, errmsg, attempt, parms, password)) {
+	/* Failed to get credentials */
+	return -1;
+    }
+
+    tmp = ne_concat(sess->username, ":", password, NULL);
+    sess->basic = ne_base64((unsigned char *)tmp, strlen(tmp));
+    ne_free(tmp);
+
+    /* Paranoia. */
+    memset(password, 0, sizeof password);
+
+    return 0;
+}
+
+/* Add Basic authentication credentials to a request */
+static char *request_basic(auth_session *sess, struct auth_request *req) 
+{
+    return ne_concat("Basic ", sess->basic, "\r\n", NULL);
+}
+
+#ifdef HAVE_GSSAPI
+/* Add GSSAPI authentication credentials to a request */
+static char *request_negotiate(auth_session *sess, struct auth_request *req)
+{
+    if (sess->gssapi_token) 
+        return ne_concat("Negotiate ", sess->gssapi_token, "\r\n", NULL);
+    else
+        return NULL;
+}
+
+/* Create an GSSAPI name for server HOSTNAME; returns non-zero on
+ * error. */
+static void get_gss_name(gss_name_t *server, const char *hostname)
+{
+    unsigned int major, minor;
+    gss_buffer_desc token;
+
+    token.value = ne_concat("HTTP@", hostname, NULL);
+    token.length = strlen(token.value);
+
+    major = gss_import_name(&minor, &token, GSS_C_NT_HOSTBASED_SERVICE,
+                            server);
+    ne_free(token.value);
+    
+    if (GSS_ERROR(major)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: gss_import_name failed.\n");
+        *server = GSS_C_NO_NAME;
+    }
+}
+
+/* Append GSSAPI error(s) for STATUS of type TYPE to BUF; prepending
+ * ": " to each error if *FLAG is non-zero, setting *FLAG after an
+ * error has been appended. */
+static void make_gss_error(ne_buffer *buf, int *flag,
+                           unsigned int status, int type)
+{
+    unsigned int major, minor;
+    unsigned int context = 0;
+    
+    do {
+        gss_buffer_desc msg;
+        major = gss_display_status(&minor, status, type,
+                                   GSS_C_NO_OID, &context, &msg);
+        if (major == GSS_S_COMPLETE && msg.length) {
+            if ((*flag)++) ne_buffer_append(buf, ": ", 2);
+            ne_buffer_append(buf, msg.value, msg.length);
+        }
+        if (msg.length) gss_release_buffer(&minor, &msg);
+    } while (context);
+}
+
+/* Continue a GSS-API Negotiate exchange, using input TOKEN if
+ * non-NULL.  Returns non-zero on error, in which case *errmsg is
+ * guaranteed to be non-NULL (i.e. an error message is set). */
+static int continue_negotiate(auth_session *sess, const char *token,
+                              ne_buffer **errmsg)
+{
+    unsigned int major, minor;
+    gss_buffer_desc input = GSS_C_EMPTY_BUFFER;
+    gss_buffer_desc output = GSS_C_EMPTY_BUFFER;
+    unsigned char *bintoken = NULL;
+    int ret;
+
+    if (token) {
+        input.length = ne_unbase64(token, &bintoken);
+        if (input.length == 0) {
+            challenge_error(errmsg, _("invalid Negotiate token"));
+            return -1;
+        }
+        input.value = bintoken;
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Continuation token [%s]\n", token);
+    }
+    else if (sess->gssctx != GSS_C_NO_CONTEXT) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Reset incomplete context.\n");
+        gss_delete_sec_context(&minor, &sess->gssctx, GSS_C_NO_BUFFER);
+    }
+
+    major = gss_init_sec_context(&minor, GSS_C_NO_CREDENTIAL, &sess->gssctx,
+                                 sess->gssname, sess->gssmech, 
+                                 GSS_C_MUTUAL_FLAG, GSS_C_INDEFINITE, 
+                                 GSS_C_NO_CHANNEL_BINDINGS,
+                                 &input, &sess->gssmech, &output, NULL, NULL);
+
+    /* done with the input token. */
+    if (bintoken) ne_free(bintoken);
+
+    if (GSS_ERROR(major)) {
+        int flag = 0;
+
+        challenge_error(errmsg, _("GSSAPI authentication error: "));
+        make_gss_error(*errmsg, &flag, major, GSS_C_GSS_CODE);
+        make_gss_error(*errmsg, &flag, minor, GSS_C_MECH_CODE);
+
+        return -1;
+    }
+
+    if (major == GSS_S_CONTINUE_NEEDED || major == GSS_S_COMPLETE) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: init_sec_context OK. (major=%d)\n",
+                 major);
+        ret = 0;
+    } 
+    else {
+        challenge_error(errmsg, _("GSSAPI failure (code %u)"), major);
+        ret = -1;
+    }
+
+    if (major != GSS_S_CONTINUE_NEEDED) {
+        /* context no longer needed: destroy it */
+        gss_delete_sec_context(&minor, &sess->gssctx, GSS_C_NO_BUFFER);
+    }
+
+    if (output.length) {
+        sess->gssapi_token = ne_base64(output.value, output.length);
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Output token: [%s]\n", 
+                 sess->gssapi_token);
+        gss_release_buffer(&minor, &output);
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: No output token.\n");
+    }
+
+    return ret;
+}
+
+/* Process a Negotiate challange CHALL in session SESS; returns zero
+ * if challenge is accepted. */
+static int negotiate_challenge(auth_session *sess, int attempt,
+                               struct auth_challenge *chall,
+                               ne_buffer **errmsg) 
+{
+    const char *token = chall->opaque;
+
+    /* Respect an initial challenge - which must have no input token,
+     * or a continuation - which must have an input token. */
+    if (attempt == 0 || token) {
+        return continue_negotiate(sess, token, errmsg);
+    }
+    else {
+        challenge_error(errmsg, _("ignoring empty Negotiate continuation"));
+        return -1;
+    }
+}
+
+/* Verify the header HDR in a Negotiate response. */
+static int verify_negotiate_response(struct auth_request *req, auth_session *sess,
+                                     const char *hdr)
+{
+    char *duphdr = ne_strdup(hdr);
+    char *sep, *ptr = strchr(duphdr, ' ');
+    int ret;
+    ne_buffer *errmsg = NULL;
+
+    if (!ptr || strncmp(hdr, "Negotiate", ptr - duphdr) != 0) {
+        ne_set_error(sess->sess, _("Negotiate response verification failed: "
+                                   "invalid response header token"));
+        ne_free(duphdr);
+        return NE_ERROR;
+    }
+    
+    ptr++;
+
+    if (strlen(ptr) == 0) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: No token in Negotiate response!\n");
+        ne_free(duphdr);
+        return NE_OK;
+    }
+
+    if ((sep = strchr(ptr, ',')) != NULL)
+        *sep = '\0';
+    if ((sep = strchr(ptr, ' ')) != NULL)
+        *sep = '\0';
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Negotiate response token [%s]\n", ptr);
+    ret = continue_negotiate(sess, ptr, &errmsg);
+    if (ret) {
+        ne_set_error(sess->sess, _("Negotiate response verification failure: %s"),
+                     errmsg->data);
+    }
+
+    if (errmsg) ne_buffer_destroy(errmsg);
+    ne_free(duphdr);
+
+    return ret ? NE_ERROR : NE_OK;
+}
+#endif
+
+#ifdef HAVE_SSPI
+static char *request_sspi(auth_session *sess, struct auth_request *request) 
+{
+    if (sess->sspi_token)
+        return ne_concat(sess->protocol->name, " ", sess->sspi_token, "\r\n", NULL);
+    else
+        return NULL;
+}
+
+static int continue_sspi(auth_session *sess, int ntlm, const char *hdr)
+{
+    int status;
+    char *response = NULL;
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: SSPI challenge.\n");
+    
+    if (!sess->sspi_context) {
+        status = ne_sspi_create_context(&sess->sspi_context, sess->sspi_host, ntlm);
+        if (status) {
+            return status;
+        }
+    }
+    
+    status = ne_sspi_authenticate(sess->sspi_context, hdr, &response);
+    if (status) {
+        return status;
+    }
+
+    if (response && *response) {
+        sess->sspi_token = response;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: SSPI challenge [%s]\n", sess->sspi_token);
+    }
+
+    return 0;
+}
+
+static int sspi_challenge(auth_session *sess, int attempt,
+                          struct auth_challenge *parms,
+                          ne_buffer **errmsg) 
+{
+    int ntlm = ne_strcasecmp(parms->protocol->name, "NTLM") == 0;
+
+    return continue_sspi(sess, ntlm, parms->opaque);
+}
+
+static int verify_sspi(struct auth_request *req, auth_session *sess,
+                       const char *hdr)
+{
+    int ntlm = ne_strncasecmp(hdr, "NTLM ", 5) == 0;
+    char *ptr = strchr(hdr, ' ');
+
+    if (!ptr) {
+        ne_set_error(sess->sess, _("SSPI response verification failed: "
+                                   "invalid response header token"));
+        return NE_ERROR;
+    }
+
+    while(*ptr == ' ')
+        ptr++;
+
+    if (*ptr == '\0') {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: No token in SSPI response!\n");
+        return NE_OK;
+    }
+
+    return continue_sspi(sess, ntlm, ptr);
+}
+
+#endif
+
+/* Parse the "domain" challenge parameter and set the domains array up
+ * in the session appropriately. */
+static int parse_domain(auth_session *sess, const char *domain)
+{
+    char *cp = ne_strdup(domain), *p = cp;
+    ne_uri base;
+    int invalid = 0;
+
+    memset(&base, 0, sizeof base);
+    ne_fill_server_uri(sess->sess, &base);
+
+    do {
+        char *token = ne_token(&p, ' ');
+        ne_uri rel, absolute;
+        
+        if (ne_uri_parse(token, &rel) == 0) {
+            /* Resolve relative to the Request-URI. */
+            base.path = "/";
+            ne_uri_resolve(&base, &rel, &absolute);
+
+            /* Compare against the resolved path to check this URI has
+             * the same (scheme, host, port) components; ignore it
+             * otherwise: */
+            base.path = absolute.path;
+            if (absolute.path && ne_uri_cmp(&absolute, &base) == 0) {
+                sess->domains = ne_realloc(sess->domains, 
+                                           ++sess->ndomains *
+                                           sizeof(*sess->domains));
+                sess->domains[sess->ndomains - 1] = absolute.path;
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Using domain %s from %s\n",
+                         absolute.path, token);
+                absolute.path = NULL;
+            }
+            else {
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Ignoring domain %s\n",
+                         token);
+            }
+
+            ne_uri_free(&absolute);
+        }
+        else {
+            invalid = 1;
+        }
+        
+        ne_uri_free(&rel);
+        
+    } while (p && !invalid);
+
+    if (invalid && sess->ndomains) {
+        free_domains(sess);
+    }
+
+    ne_free(cp);
+    base.path = NULL;
+    ne_uri_free(&base);
+
+    return invalid;
+}
+
+#ifdef HAVE_NTLM
+
+static char *request_ntlm(auth_session *sess, struct auth_request *request) 
+{
+    char *token = ne__ntlm_getRequestToken(sess->ntlm_context);
+    if (token) {
+        char *req = ne_concat(sess->protocol->name, " ", token, "\r\n", NULL);
+        ne_free(token);
+        return req;
+    } else {
+        return NULL;
+    }
+}
+
+static int ntlm_challenge(auth_session *sess, int attempt,
+                          struct auth_challenge *parms,
+                          ne_buffer **errmsg) 
+{
+    int status;
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: NTLM challenge.\n");
+    
+    if (!parms->opaque && (!sess->ntlm_context || (attempt > 1))) {
+        char password[NE_ABUFSIZ];
+
+        if (get_credentials(sess, errmsg, attempt, parms, password)) {
+            /* Failed to get credentials */
+            return -1;
+        }
+
+        if (sess->ntlm_context) {
+            ne__ntlm_destroy_context(sess->ntlm_context);
+            sess->ntlm_context = NULL;
+        }
+
+        sess->ntlm_context = ne__ntlm_create_context(sess->username, password);
+    }
+
+    status = ne__ntlm_authenticate(sess->ntlm_context, parms->opaque);
+    if (status) {
+        return status;
+    }
+
+    return 0;
+}
+#endif /* HAVE_NTLM */
+  
+/* Examine a digest challenge: return 0 if it is a valid Digest challenge,
+ * else non-zero. */
+static int digest_challenge(auth_session *sess, int attempt,
+                            struct auth_challenge *parms,
+                            ne_buffer **errmsg) 
+{
+    char password[NE_ABUFSIZ];
+
+    if (parms->alg == auth_alg_unknown) {
+        challenge_error(errmsg, _("unknown algorithm in Digest challenge"));
+        return -1;
+    }
+    else if (parms->alg == auth_alg_md5_sess && !parms->qop_auth) {
+        challenge_error(errmsg, _("incompatible algorithm in Digest challenge"));
+        return -1;
+    }
+    else if (parms->realm == NULL || parms->nonce == NULL) {
+        challenge_error(errmsg, _("missing parameter in Digest challenge"));
+	return -1;
+    }
+    else if (parms->stale && sess->realm == NULL) {
+        challenge_error(errmsg, _("initial Digest challenge was stale"));
+        return -1;
+    }
+    else if (parms->stale && (sess->alg != parms->alg
+                              || strcmp(sess->realm, parms->realm))) {
+        /* With stale=true the realm and algorithm cannot change since these
+         * require re-hashing H(A1) which defeats the point. */
+        challenge_error(errmsg, _("stale Digest challenge with new algorithm or realm"));
+        return -1;
+    }
+
+    if (!parms->stale) {
+        /* Non-stale challenge: clear session and request credentials. */
+        clean_session(sess);
+
+        /* The domain paramater must be parsed after the session is
+         * cleaned; ignore domain for proxy auth. */
+        if (parms->domain && sess->spec == &ah_server_class
+            && parse_domain(sess, parms->domain)) {
+            challenge_error(errmsg, _("could not parse domain in Digest challenge"));
+            return -1;
+        }
+
+        sess->realm = ne_strdup(parms->realm);
+        sess->alg = parms->alg;
+        sess->cnonce = get_cnonce();
+
+        if (get_credentials(sess, errmsg, attempt, parms, password)) {
+            /* Failed to get credentials */
+            return -1;
+        }
+    }
+    else {
+        /* Stale challenge: accept a new nonce or opaque. */
+        if (sess->nonce) ne_free(sess->nonce);
+        if (sess->opaque && parms->opaque) ne_free(sess->opaque);
+    }
+    
+    sess->nonce = ne_strdup(parms->nonce);
+    if (parms->opaque) {
+	sess->opaque = ne_strdup(parms->opaque);
+    }
+    
+    if (parms->got_qop) {
+	/* What type of qop are we to apply to the message? */
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got qop, using 2617-style.\n");
+	sess->nonce_count = 0;
+        sess->qop = auth_qop_auth;
+    } else {
+	/* No qop at all/ */
+	sess->qop = auth_qop_none;
+    }
+    
+    if (!parms->stale) {
+        struct ne_md5_ctx *tmp;
+
+	/* Calculate H(A1).
+	 * tmp = H(unq(username-value) ":" unq(realm-value) ":" passwd)
+	 */
+	tmp = ne_md5_create_ctx();
+	ne_md5_process_bytes(sess->username, strlen(sess->username), tmp);
+	ne_md5_process_bytes(":", 1, tmp);
+	ne_md5_process_bytes(sess->realm, strlen(sess->realm), tmp);
+	ne_md5_process_bytes(":", 1, tmp);
+	ne_md5_process_bytes(password, strlen(password), tmp);
+	memset(password, 0, sizeof password); /* done with that. */
+	if (sess->alg == auth_alg_md5_sess) {
+	    struct ne_md5_ctx *a1;
+	    char tmp_md5_ascii[33];
+
+	    /* Now we calculate the SESSION H(A1)
+	     *    A1 = H(...above...) ":" unq(nonce-value) ":" unq(cnonce-value) 
+	     */
+	    ne_md5_finish_ascii(tmp, tmp_md5_ascii);
+	    a1 = ne_md5_create_ctx();
+	    ne_md5_process_bytes(tmp_md5_ascii, 32, a1);
+	    ne_md5_process_bytes(":", 1, a1);
+	    ne_md5_process_bytes(sess->nonce, strlen(sess->nonce), a1);
+	    ne_md5_process_bytes(":", 1, a1);
+	    ne_md5_process_bytes(sess->cnonce, strlen(sess->cnonce), a1);
+	    ne_md5_finish_ascii(a1, sess->h_a1);
+            ne_md5_destroy_ctx(a1);
+	    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Session H(A1) is [%s]\n", sess->h_a1);
+	} else {
+	    ne_md5_finish_ascii(tmp, sess->h_a1);
+	    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: H(A1) is [%s]\n", sess->h_a1);
+	}
+        ne_md5_destroy_ctx(tmp);
+	
+    }
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Accepting digest challenge.\n");
+
+    return 0;
+}
+
+/* Returns non-zero if given Request-URI is inside the authentication
+ * domain defined for the session. */
+static int inside_domain(auth_session *sess, const char *req_uri)
+{
+    int inside = 0;
+    size_t n;
+    ne_uri uri;
+    
+    /* Parse the Request-URI; it will be an absoluteURI if using a
+     * proxy, and possibly '*'. */
+    if (strcmp(req_uri, "*") == 0 || ne_uri_parse(req_uri, &uri) != 0) {
+        /* Presume outside the authentication domain. */
+        return 0;
+    }
+
+    for (n = 0; n < sess->ndomains && !inside; n++) {
+        const char *d = sess->domains[n];
+        
+        inside = strncmp(uri.path, d, strlen(d)) == 0;
+    }
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: '%s' is inside auth domain: %d.\n", 
+             uri.path, inside);
+    ne_uri_free(&uri);
+    
+    return inside;
+}            
+
+/* Return Digest authentication credentials header value for the given
+ * session. */
+static char *request_digest(auth_session *sess, struct auth_request *req) 
+{
+    struct ne_md5_ctx *a2, *rdig;
+    char a2_md5_ascii[33], rdig_md5_ascii[33];
+    char nc_value[9] = {0};
+    const char *qop_value = "auth"; /* qop-value */
+    ne_buffer *ret;
+
+    /* Do not submit credentials if an auth domain is defined and this
+     * request-uri fails outside it. */
+    if (sess->ndomains && !inside_domain(sess, req->uri)) {
+        return NULL;
+    }
+
+    /* Increase the nonce-count */
+    if (sess->qop != auth_qop_none) {
+	sess->nonce_count++;
+	ne_snprintf(nc_value, 9, "%08x", sess->nonce_count);
+    }
+
+    /* Calculate H(A2). */
+    a2 = ne_md5_create_ctx();
+    ne_md5_process_bytes(req->method, strlen(req->method), a2);
+    ne_md5_process_bytes(":", 1, a2);
+    ne_md5_process_bytes(req->uri, strlen(req->uri), a2);
+    ne_md5_finish_ascii(a2, a2_md5_ascii);
+    ne_md5_destroy_ctx(a2);
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: H(A2): %s\n", a2_md5_ascii);
+
+    /* Now, calculation of the Request-Digest.
+     * The first section is the regardless of qop value
+     *     H(A1) ":" unq(nonce-value) ":" */
+    rdig = ne_md5_create_ctx();
+
+    /* Use the calculated H(A1) */
+    ne_md5_process_bytes(sess->h_a1, 32, rdig);
+
+    ne_md5_process_bytes(":", 1, rdig);
+    ne_md5_process_bytes(sess->nonce, strlen(sess->nonce), rdig);
+    ne_md5_process_bytes(":", 1, rdig);
+    if (sess->qop != auth_qop_none) {
+	/* Add on:
+	 *    nc-value ":" unq(cnonce-value) ":" unq(qop-value) ":"
+	 */
+	ne_md5_process_bytes(nc_value, 8, rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+	ne_md5_process_bytes(sess->cnonce, strlen(sess->cnonce), rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+	/* Store a copy of this structure (see note below) */
+        if (sess->stored_rdig) ne_md5_destroy_ctx(sess->stored_rdig);
+	sess->stored_rdig = ne_md5_dup_ctx(rdig);
+	ne_md5_process_bytes(qop_value, strlen(qop_value), rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+    }
+
+    /* And finally, H(A2) */
+    ne_md5_process_bytes(a2_md5_ascii, 32, rdig);
+    ne_md5_finish_ascii(rdig, rdig_md5_ascii);
+    ne_md5_destroy_ctx(rdig);
+
+    ret = ne_buffer_create();
+
+    ne_buffer_concat(ret, 
+		     "Digest username=\"", sess->username, "\", "
+		     "realm=\"", sess->realm, "\", "
+		     "nonce=\"", sess->nonce, "\", "
+		     "uri=\"", req->uri, "\", "
+		     "response=\"", rdig_md5_ascii, "\", "
+		     "algorithm=\"", sess->alg == auth_alg_md5 ? "MD5" : "MD5-sess", "\"", 
+		     NULL);
+    
+    if (sess->opaque != NULL) {
+	ne_buffer_concat(ret, ", opaque=\"", sess->opaque, "\"", NULL);
+    }
+
+    if (sess->qop != auth_qop_none) {
+	/* Add in cnonce and nc-value fields */
+	ne_buffer_concat(ret, ", cnonce=\"", sess->cnonce, "\", "
+			 "nc=", nc_value, ", "
+			 "qop=\"", qop_value, "\"", NULL);
+    }
+
+    ne_buffer_zappend(ret, "\r\n");
+
+    return ne_buffer_finish(ret);
+}
+
+/* Parse line of comma-separated key-value pairs.  If 'ischall' == 1,
+ * then also return a leading space-separated token, as *value ==
+ * NULL.  Otherwise, if return value is 0, *key and *value will be
+ * non-NULL.  If return value is non-zero, parsing has ended.  If
+ * 'sep' is non-NULL and ischall is 1, the separator character is
+ * written to *sep when a challenge is parsed. */
+static int tokenize(char **hdr, char **key, char **value, char *sep,
+                    int ischall)
+{
+    char *pnt = *hdr;
+    enum { BEFORE_EQ, AFTER_EQ, AFTER_EQ_QUOTED } state = BEFORE_EQ;
+    
+    if (**hdr == '\0')
+	return 1;
+
+    *key = NULL;
+
+    do {
+	switch (state) {
+	case BEFORE_EQ:
+	    if (*pnt == '=') {
+		if (*key == NULL)
+		    return -1;
+		*pnt = '\0';
+		*value = pnt + 1;
+		state = AFTER_EQ;
+	    } else if ((*pnt == ' ' || *pnt == ',') 
+                       && ischall && *key != NULL) {
+		*value = NULL;
+                if (sep) *sep = *pnt;
+		*pnt = '\0';
+		*hdr = pnt + 1;
+		return 0;
+	    } else if (*key == NULL && strchr(" \r\n\t", *pnt) == NULL) {
+		*key = pnt;
+	    }
+	    break;
+	case AFTER_EQ:
+	    if (*pnt == ',') {
+		*pnt = '\0';
+		*hdr = pnt + 1;
+		return 0;
+	    } else if (*pnt == '\"') {
+		state = AFTER_EQ_QUOTED;
+	    }
+	    break;
+	case AFTER_EQ_QUOTED:
+	    if (*pnt == '\"') {
+		state = AFTER_EQ;
+                *pnt = '\0';
+	    }
+	    break;
+	}
+    } while (*++pnt != '\0');
+    
+    if (state == BEFORE_EQ && ischall && *key != NULL) {
+	*value = NULL;
+        if (sep) *sep = '\0';
+    }
+
+    *hdr = pnt;
+
+    /* End of string: */
+    return 0;
+}
+
+/* Pass this the value of the 'Authentication-Info:' header field, if
+ * one is received.
+ * Returns:
+ *    0 if it gives a valid authentication for the server 
+ *    non-zero otherwise (don't believe the response in this case!).
+ */
+static int verify_digest_response(struct auth_request *req, auth_session *sess,
+                                  const char *value) 
+{
+    char *hdr, *pnt, *key, *val;
+    auth_qop qop = auth_qop_none;
+    char *nextnonce, *rspauth, *cnonce, *nc, *qop_value;
+    unsigned int nonce_count;
+    int ret = NE_OK;
+
+    nextnonce = rspauth = cnonce = nc = qop_value = NULL;
+
+    pnt = hdr = ne_strdup(value);
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got Auth-Info header: %s\n", value);
+
+    while (tokenize(&pnt, &key, &val, NULL, 0) == 0) {
+	val = ne_shave(val, "\"");
+
+	if (ne_strcasecmp(key, "qop") == 0) {
+            qop_value = val;
+            if (ne_strcasecmp(val, "auth") == 0) {
+		qop = auth_qop_auth;
+	    } else {
+		qop = auth_qop_none;
+	    }
+	} else if (ne_strcasecmp(key, "nextnonce") == 0) {
+	    nextnonce = val;
+	} else if (ne_strcasecmp(key, "rspauth") == 0) {
+	    rspauth = val;
+	} else if (ne_strcasecmp(key, "cnonce") == 0) {
+	    cnonce = val;
+	} else if (ne_strcasecmp(key, "nc") == 0) { 
+	    nc = val;
+        }
+    }
+
+    if (qop == auth_qop_none) {
+        /* The 2069-style A-I header only has the entity and nextnonce
+         * parameters. */
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: 2069-style A-I header.\n");
+    }
+    else if (!rspauth || !cnonce || !nc) {
+        ret = NE_ERROR;
+        ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                   "missing parameters"));
+    }
+    else if (strcmp(cnonce, sess->cnonce) != 0) {
+        ret = NE_ERROR;
+        ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                   "client nonce mismatch"));
+    }
+    else if (nc) {
+        char *ptr;
+        
+        errno = 0;
+        nonce_count = strtoul(nc, &ptr, 16);
+        if (*ptr != '\0' || errno) {
+            ret = NE_ERROR;
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "could not parse nonce count"));
+        }
+        else if (nonce_count != sess->nonce_count) {
+            ret = NE_ERROR;
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "nonce count mismatch (%u not %u)"),
+                         nonce_count, sess->nonce_count);
+        }
+    }
+
+    /* Finally, for qop=auth cases, if everything else is OK, verify
+     * the response-digest field. */    
+    if (qop == auth_qop_auth && ret == NE_OK) {
+        struct ne_md5_ctx *a2;
+        char a2_md5_ascii[33], rdig_md5_ascii[33];
+
+        /* Modified H(A2): */
+        a2 = ne_md5_create_ctx();
+        ne_md5_process_bytes(":", 1, a2);
+        ne_md5_process_bytes(req->uri, strlen(req->uri), a2);
+        ne_md5_finish_ascii(a2, a2_md5_ascii);
+        ne_md5_destroy_ctx(a2);
+
+        /* sess->stored_rdig contains digest-so-far of:
+         *   H(A1) ":" unq(nonce-value) 
+         */
+        
+        /* Add in qop-value */
+        ne_md5_process_bytes(qop_value, strlen(qop_value), 
+                             sess->stored_rdig);
+        ne_md5_process_bytes(":", 1, sess->stored_rdig);
+
+        /* Digest ":" H(A2) */
+        ne_md5_process_bytes(a2_md5_ascii, 32, sess->stored_rdig);
+        /* All done */
+        ne_md5_finish_ascii(sess->stored_rdig, rdig_md5_ascii);
+        ne_md5_destroy_ctx(sess->stored_rdig);
+        sess->stored_rdig = NULL;
+
+        /* And... do they match? */
+        ret = ne_strcasecmp(rdig_md5_ascii, rspauth) == 0 ? NE_OK : NE_ERROR;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: response-digest match: %s "
+                 "(expected [%s] vs actual [%s])\n", 
+                 ret == NE_OK ? "yes" : "no", rdig_md5_ascii, rspauth);
+
+        if (ret) {
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "request-digest mismatch"));
+        }
+    }
+
+    /* Check for a nextnonce */
+    if (nextnonce != NULL) {
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Found nextnonce of [%s].\n", nextnonce);
+        ne_free(sess->nonce);
+	sess->nonce = ne_strdup(nextnonce);
+        sess->nonce_count = 0;
+    }
+
+    ne_free(hdr);
+
+    return ret;
+}
+
+static const struct auth_protocol protocols[] = {
+    { NE_AUTH_BASIC, 10, "Basic",
+      basic_challenge, request_basic, NULL,
+      0 },
+    { NE_AUTH_DIGEST, 20, "Digest",
+      digest_challenge, request_digest, verify_digest_response,
+      0 },
+#ifdef HAVE_GSSAPI
+    { NE_AUTH_GSSAPI_ONLY, 30, "Negotiate",
+      negotiate_challenge, request_negotiate, verify_negotiate_response,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+#ifdef HAVE_SSPI
+    { NE_AUTH_NTLM, 30, "NTLM",
+      sspi_challenge, request_sspi, NULL,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+    { NE_AUTH_SSPI, 30, "Negotiate",
+      sspi_challenge, request_sspi, verify_sspi,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+#ifdef HAVE_NTLM
+    { NE_AUTH_NTLM, 30, "NTLM",
+      ntlm_challenge, request_ntlm, NULL,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+    { 0 }
+};
+
+/* Insert a new auth challenge for protocol 'proto' in list of
+ * challenges 'list'.  The challenge list is kept in sorted order of
+ * strength, with highest strength first. */
+static struct auth_challenge *insert_challenge(struct auth_challenge **list,
+                                               const struct auth_protocol *proto)
+{
+    struct auth_challenge *ret = ne_calloc(sizeof *ret);
+    struct auth_challenge *chall, *prev;
+
+    for (chall = *list, prev = NULL; chall != NULL; 
+         prev = chall, chall = chall->next) {
+        if (proto->strength > chall->protocol->strength) {
+            break;
+        }
+    }
+
+    if (prev) {
+        ret->next = prev->next;
+        prev->next = ret;
+    } else {
+        ret->next = *list;
+        *list = ret;
+    }
+
+    ret->protocol = proto;
+
+    return ret;
+}
+
+static void challenge_error(ne_buffer **errbuf, const char *fmt, ...)
+{
+    char err[128];
+    va_list ap;
+    size_t len;
+    
+    va_start(ap, fmt);
+    len = ne_vsnprintf(err, sizeof err, fmt, ap);
+    va_end(ap);
+    
+    if (*errbuf == NULL) {
+        *errbuf = ne_buffer_create();
+        ne_buffer_append(*errbuf, err, len);
+    }
+    else {
+        ne_buffer_concat(*errbuf, ", ", err, NULL);
+    }
+}
+
+/* Passed the value of a "(Proxy,WWW)-Authenticate: " header field.
+ * Returns 0 if valid challenge was accepted; non-zero if no valid
+ * challenge was found. */
+static int auth_challenge(auth_session *sess, int attempt,
+                          const char *value) 
+{
+    char *pnt, *key, *val, *hdr, sep;
+    struct auth_challenge *chall = NULL, *challenges = NULL;
+    ne_buffer *errmsg = NULL;
+
+    pnt = hdr = ne_strdup(value); 
+
+    /* The header value may be made up of one or more challenges.  We
+     * split it down into attribute-value pairs, then search for
+     * schemes in the pair keys. */
+
+    while (!tokenize(&pnt, &key, &val, &sep, 1)) {
+
+	if (val == NULL) {
+            const struct auth_protocol *proto = NULL;
+            struct auth_handler *hdl;
+            size_t n;
+
+            for (hdl = sess->handlers; hdl; hdl = hdl->next) {
+                for (n = 0; protocols[n].id; n++) {
+                    if (protocols[n].id & hdl->protomask
+                        && ne_strcasecmp(key, protocols[n].name) == 0) {
+                        proto = &protocols[n];
+                        break;
+                    }
+                }
+                if (proto) break;
+            }
+
+            if (proto == NULL) {
+                /* Ignore this challenge. */
+                chall = NULL;
+                challenge_error(&errmsg, _("ignored %s challenge"), key);
+                continue;
+	    }
+            
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got '%s' challenge.\n", proto->name);
+            chall = insert_challenge(&challenges, proto);
+            chall->handler = hdl;
+
+            if ((proto->flags & AUTH_FLAG_OPAQUE_PARAM) && sep == ' ') {
+                /* Cope with the fact that the unquoted base64
+                 * paramater token doesn't match the 2617 auth-param
+                 * grammar: */
+                chall->opaque = ne_shave(ne_token(&pnt, ','), " \t");
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: %s opaque parameter '%s'\n",
+                         proto->name, chall->opaque);
+                if (!pnt) break; /* stop parsing at end-of-string. */
+            }
+	    continue;
+	} else if (chall == NULL) {
+	    /* Ignore pairs for an unknown challenge. */
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Ignored parameter: %s = %s\n", key, val);
+	    continue;
+	}
+
+	/* Strip quotes off value. */
+	val = ne_shave(val, "\"'");
+
+	if (ne_strcasecmp(key, "realm") == 0) {
+	    chall->realm = val;
+	} else if (ne_strcasecmp(key, "nonce") == 0) {
+	    chall->nonce = val;
+	} else if (ne_strcasecmp(key, "opaque") == 0) {
+	    chall->opaque = val;
+	} else if (ne_strcasecmp(key, "stale") == 0) {
+	    /* Truth value */
+	    chall->stale = (ne_strcasecmp(val, "true") == 0);
+	} else if (ne_strcasecmp(key, "algorithm") == 0) {
+	    if (ne_strcasecmp(val, "md5") == 0) {
+		chall->alg = auth_alg_md5;
+	    } else if (ne_strcasecmp(val, "md5-sess") == 0) {
+		chall->alg = auth_alg_md5_sess;
+	    } else {
+		chall->alg = auth_alg_unknown;
+	    }
+	} else if (ne_strcasecmp(key, "qop") == 0) {
+            /* iterate over each token in the value */
+            do {
+                const char *tok = ne_shave(ne_token(&val, ','), " \t");
+                
+                if (ne_strcasecmp(tok, "auth") == 0) {
+                    chall->qop_auth = 1;
+                }
+            } while (val);
+            
+            chall->got_qop = chall->qop_auth;
+	}
+        else if (ne_strcasecmp(key, "domain") == 0) {
+            chall->domain = val;
+        }
+    }
+    
+    sess->protocol = NULL;
+
+    /* Iterate through the challenge list (which is sorted from
+     * strongest to weakest) attempting to accept each one. */
+    for (chall = challenges; chall != NULL; chall = chall->next) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Trying %s challenge...\n",
+                 chall->protocol->name);
+        if (chall->protocol->challenge(sess, attempt, chall, &errmsg) == 0) {
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Accepted %s challenge.\n", 
+                     chall->protocol->name);
+            sess->protocol = chall->protocol;
+            break;
+        }
+    }
+
+    if (!sess->protocol) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: No challenges accepted.\n");
+        ne_set_error(sess->sess, _(sess->spec->error_noauth),
+                     errmsg ? errmsg->data : _("could not parse challenge"));
+    }
+
+    while (challenges != NULL) {
+	chall = challenges->next;
+	ne_free(challenges);
+	challenges = chall;
+    }
+
+    ne_free(hdr);
+    if (errmsg) ne_buffer_destroy(errmsg);
+
+    return !(sess->protocol != NULL);
+}
+
+static void ah_create(ne_request *req, void *session, const char *method,
+		      const char *uri)
+{
+    auth_session *sess = session;
+    int is_connect = strcmp(method, "CONNECT") == 0;
+
+    if (sess->context == AUTH_ANY ||
+        (is_connect && sess->context == AUTH_CONNECT) ||
+        (!is_connect && sess->context == AUTH_NOTCONNECT)) {
+        struct auth_request *areq = ne_calloc(sizeof *areq);
+        struct auth_handler *hdl;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "ah_create, for %s\n", sess->spec->resp_hdr);
+        
+        areq->method = method;
+        areq->uri = uri;
+        areq->request = req;
+        
+        ne_set_request_private(req, sess->spec->id, areq);
+
+        /* For each new request, reset the attempt counter in every
+         * registered handler. */
+        for (hdl = sess->handlers; hdl; hdl = hdl->next) {
+            hdl->attempt = 0;
+        }
+    }
+}
+
+
+static void ah_pre_send(ne_request *r, void *cookie, ne_buffer *request)
+{
+    auth_session *sess = cookie;
+    struct auth_request *req = ne_get_request_private(r, sess->spec->id);
+
+    if (sess->protocol && req) {
+	char *value;
+
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Sending '%s' response.\n",
+                 sess->protocol->name);
+
+        value = sess->protocol->response(sess, req);
+
+	if (value != NULL) {
+	    ne_buffer_concat(request, sess->spec->req_hdr, ": ", value, NULL);
+	    ne_free(value);
+	}
+    }
+
+}
+
+static int ah_post_send(ne_request *req, void *cookie, const ne_status *status)
+{
+    auth_session *sess = cookie;
+    struct auth_request *areq = ne_get_request_private(req, sess->spec->id);
+    const char *auth_hdr, *auth_info_hdr;
+    int ret = NE_OK;
+
+    if (!areq) return NE_OK;
+
+    auth_hdr = ne_get_response_header(req, sess->spec->resp_hdr);
+    auth_info_hdr = ne_get_response_header(req, sess->spec->resp_info_hdr);
+
+    if (sess->context == AUTH_CONNECT && status->code == 401 && !auth_hdr) {
+        /* Some broken proxies issue a 401 as a proxy auth challenge
+         * to a CONNECT request; handle this here. */
+        auth_hdr = ne_get_response_header(req, "WWW-Authenticate");
+        auth_info_hdr = NULL;
+    }
+
+#ifdef HAVE_GSSAPI
+    /* whatever happens: forget the GSSAPI token cached thus far */
+    if (sess->gssapi_token) {
+        ne_free(sess->gssapi_token);
+        sess->gssapi_token = NULL;
+    }
+#endif
+
+#ifdef HAVE_SSPI
+    /* whatever happens: forget the SSPI token cached thus far */
+    if (sess->sspi_token) {
+        ne_free(sess->sspi_token);
+        sess->sspi_token = NULL;
+    }
+#endif
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, 
+	     "ah_post_send (#%d), code is %d (want %d), %s is %s\n",
+	     areq->attempt, status->code, sess->spec->status_code, 
+	     sess->spec->resp_hdr, auth_hdr ? auth_hdr : "(none)");
+    if (auth_info_hdr && sess->protocol && sess->protocol->verify 
+        && (sess->protocol->flags & AUTH_FLAG_VERIFY_NON40x) == 0) {
+        ret = sess->protocol->verify(areq, sess, auth_info_hdr);
+    }
+    else if (sess->protocol && sess->protocol->verify
+             && (sess->protocol->flags & AUTH_FLAG_VERIFY_NON40x) 
+             && (status->klass == 2 || status->klass == 3)
+             && auth_hdr) {
+        ret = sess->protocol->verify(areq, sess, auth_hdr);
+    }
+    else if ((status->code == sess->spec->status_code ||
+              (status->code == 401 && sess->context == AUTH_CONNECT)) &&
+	       auth_hdr) {
+        /* note above: allow a 401 in response to a CONNECT request
+         * from a proxy since some buggy proxies send that. */
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got challenge (code %d).\n", status->code);
+	if (!auth_challenge(sess, areq->attempt++, auth_hdr)) {
+	    ret = NE_RETRY;
+	} else {
+	    clean_session(sess);
+	    ret = sess->spec->fail_code;
+	}
+        
+        /* Set or clear the conn-auth flag according to whether this
+         * was an accepted challenge for a borked protocol. */
+        ne_set_session_flag(sess->sess, NE_SESSFLAG_CONNAUTH,
+                            sess->protocol 
+                            && (sess->protocol->flags & AUTH_FLAG_CONN_AUTH));
+    }
+
+#ifdef HAVE_SSPI
+    /* Clear the SSPI context after successful authentication. */
+    if (status->code != sess->spec->status_code && sess->sspi_context) {
+        ne_sspi_clear_context(sess->sspi_context);
+    }
+#endif
+
+    return ret;
+}
+
+static void ah_destroy(ne_request *req, void *session)
+{
+    auth_session *sess = session;
+    struct auth_request *areq = ne_get_request_private(req, sess->spec->id);
+
+    if (areq) {
+        ne_free(areq);
+    }
+}
+
+static void free_auth(void *cookie)
+{
+    auth_session *sess = cookie;
+    struct auth_handler *hdl, *next;
+
+#ifdef HAVE_GSSAPI
+    if (sess->gssname != GSS_C_NO_NAME) {
+        unsigned int major;
+        gss_release_name(&major, &sess->gssname);
+    }
+#endif
+
+    for (hdl = sess->handlers; hdl; hdl = next) {
+        next = hdl->next;
+        ne_free(hdl);
+    }
+
+    clean_session(sess);
+    ne_free(sess);
+}
+
+static void auth_register(ne_session *sess, int isproxy, unsigned protomask,
+			  const struct auth_class *ahc, const char *id, 
+			  ne_auth_creds creds, void *userdata) 
+{
+    auth_session *ahs;
+    struct auth_handler **hdl;
+
+    /* Handle the _ALL and _DEFAULT protocol masks: */
+    if (protomask == NE_AUTH_ALL) {
+        protomask |= NE_AUTH_BASIC | NE_AUTH_DIGEST | NE_AUTH_NEGOTIATE;
+    }
+    else if (protomask == NE_AUTH_DEFAULT) {
+        protomask |= NE_AUTH_BASIC | NE_AUTH_DIGEST;
+        
+        if (strcmp(ne_get_scheme(sess), "https") == 0 || isproxy) {
+            protomask |= NE_AUTH_NEGOTIATE;
+        }
+    }
+
+    if ((protomask & NE_AUTH_NEGOTIATE) == NE_AUTH_NEGOTIATE) {
+        /* Map NEGOTIATE to NTLM | GSSAPI. */
+        protomask |= NE_AUTH_GSSAPI | NE_AUTH_NTLM;
+    }
+    
+    if ((protomask & NE_AUTH_GSSAPI) == NE_AUTH_GSSAPI) {
+        /* Map GSSAPI to GSSAPI_ONLY | SSPI. */
+        protomask |= NE_AUTH_GSSAPI_ONLY | NE_AUTH_SSPI;
+    }
+
+    ahs = ne_get_session_private(sess, id);
+    if (ahs == NULL) {
+        ahs = ne_calloc(sizeof *ahs);
+        
+        ahs->sess = sess;
+        ahs->spec = ahc;
+        
+        if (strcmp(ne_get_scheme(sess), "https") == 0) {
+            ahs->context = isproxy ? AUTH_CONNECT : AUTH_NOTCONNECT;
+        } else {
+            ahs->context = AUTH_ANY;
+        }
+        
+        /* Register hooks */
+        ne_hook_create_request(sess, ah_create, ahs);
+        ne_hook_pre_send(sess, ah_pre_send, ahs);
+        ne_hook_post_send(sess, ah_post_send, ahs);
+        ne_hook_destroy_request(sess, ah_destroy, ahs);
+        ne_hook_destroy_session(sess, free_auth, ahs);
+        
+        ne_set_session_private(sess, id, ahs);
+    }
+
+#ifdef HAVE_GSSAPI
+    if ((protomask & NE_AUTH_GSSAPI_ONLY) && ahs->gssname == GSS_C_NO_NAME) {
+        ne_uri uri = {0};
+        
+        if (isproxy)
+            ne_fill_proxy_uri(sess, &uri);
+        else
+            ne_fill_server_uri(sess, &uri);
+
+        get_gss_name(&ahs->gssname, uri.host);
+
+        ne_uri_free(&uri);
+    }
+#endif
+#ifdef HAVE_SSPI
+    if ((protomask & (NE_AUTH_NTLM|NE_AUTH_SSPI)) && !ahs->sspi_host) {
+        ne_uri uri = {0};
+        
+        if (isproxy)
+            ne_fill_proxy_uri(sess, &uri);
+        else
+            ne_fill_server_uri(sess, &uri);
+
+        ahs->sspi_host = uri.host;
+        uri.host = NULL;
+
+        ne_uri_free(&uri);
+    }
+#endif        
+
+    /* Find the end of the handler list, and add a new one. */
+    hdl = &ahs->handlers;
+    while (*hdl)
+        hdl = &(*hdl)->next;
+        
+    *hdl = ne_malloc(sizeof **hdl);
+    (*hdl)->protomask = protomask;
+    (*hdl)->creds = creds;
+    (*hdl)->userdata = userdata;
+    (*hdl)->next = NULL;
+    (*hdl)->attempt = 0;
+}
+
+void ne_set_server_auth(ne_session *sess, ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 0, NE_AUTH_DEFAULT, &ah_server_class, HOOK_SERVER_ID,
+                  creds, userdata);
+}
+
+void ne_set_proxy_auth(ne_session *sess, ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 1, NE_AUTH_DEFAULT, &ah_proxy_class, HOOK_PROXY_ID,
+                  creds, userdata);
+}
+
+void ne_add_server_auth(ne_session *sess, unsigned protocol, 
+                        ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 0, protocol, &ah_server_class, HOOK_SERVER_ID,
+                  creds, userdata);
+}
+
+void ne_add_proxy_auth(ne_session *sess, unsigned protocol, 
+                       ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 1, protocol, &ah_proxy_class, HOOK_PROXY_ID,
+                  creds, userdata);
+}
+
+void ne_forget_auth(ne_session *sess)
+{
+    auth_session *as;
+    if ((as = ne_get_session_private(sess, HOOK_SERVER_ID)) != NULL)
+	clean_session(as);
+    if ((as = ne_get_session_private(sess, HOOK_PROXY_ID)) != NULL)
+	clean_session(as);
+}
+
diff --git a/net/mmt/neon/src/ne_auth.h b/net/mmt/neon/src/ne_auth.h
new file mode 100644
index 0000000..98e7e18
--- /dev/null
+++ b/net/mmt/neon/src/ne_auth.h
@@ -0,0 +1,143 @@
+/* 
+   HTTP authentication routines
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_AUTH_H
+#define NE_AUTH_H
+
+#include "ne_session.h" /* for ne_session */
+
+NE_BEGIN_DECLS
+
+/* Size of username/password buffers passed to ne_auth_creds
+ * callback. */
+#define NE_ABUFSIZ (256)
+
+/* The callback used to request the username and password in the given
+ * realm. The username and password must be copied into the buffers
+ * which are both of size NE_ABUFSIZ.  The 'attempt' parameter is zero
+ * on the first call to the callback, and increases by one each time
+ * an attempt to authenticate fails.
+ *
+ * The callback must return zero to indicate that authentication
+ * should be attempted with the username/password, or non-zero to
+ * cancel the request. (if non-zero, username and password are
+ * ignored.)
+ *
+ * IMPORTANT NOTE: The callback will be invoked repeatedly until
+ * either it returns non-zero, or authentication is successful.
+ *
+ * Hint: if you just wish to attempt authentication just once (even if
+ * the user gets the username/password wrong), have the callback
+ * function use 'attempt' value as the function return value. */
+typedef int (*ne_auth_creds)(void *userdata, const char *realm, int attempt,
+			     char *username, char *password);
+
+/* Set callbacks to provide credentials for server and proxy
+ * authentication, using the default set of authentication protocols.
+ * userdata is passed as the first argument to the callback. */
+void ne_set_server_auth(ne_session *sess, ne_auth_creds creds, void *userdata);
+void ne_set_proxy_auth(ne_session *sess, ne_auth_creds creds, void *userdata);
+
+/* As an alternative to using ne_set_server_auth and
+ * ne_set_proxy_auth, the following interfaces may be used; these
+ * allow control over which authentication protocol is used. */
+
+/* NE_AUTH_BASIC: Basic authentication transmits the username and
+ * password unprotected over the channel; this allows a passive attack
+ * to steal the credentials if using an unsecured channel
+ * (i.e. non-SSL). */
+#define NE_AUTH_BASIC (0x0001)
+
+/* NE_AUTH_DIGEST: Digest authentication uses a hash of the username,
+ * password, and certain aspects of the request, so prevents passive
+ * attackers from obtaining the credentials; active attackers can
+ * still modify most of the request/response if using an unsecured
+ * channel. */ 
+#define NE_AUTH_DIGEST (0x0002)
+
+/* NE_AUTH_NEGOTIATE: Negotiate uses GSSAPI/SSPI, or NTLM, to
+ * authenticate the user; an active attacker can modify any of the
+ * request/response at will, so this must not be used over an
+ * unsecured channel.  NE_AUTH_NEGOTIATE is currently equivalent to
+ * use of (NE_AUTH_GSSAPI | NE_AUTH_NTLM). */
+#define NE_AUTH_NEGOTIATE (0x0004)
+
+/* NE_AUTH_GSSAPI: Use GSSAPI or SSPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. NE_AUTH_GSSAPI
+ * is currently equivalent to (NE_AUTH_GSSAPI_ONLY | NE_AUTH_SSPI). */
+#define NE_AUTH_GSSAPI (0x0008)
+
+/* NE_AUTH_NTLM: Use NTLM to authenticate the user; an active attacker
+ * can modify any of the request/response at will, so this must not be
+ * used over an unsecured channel. */
+#define NE_AUTH_NTLM (0x0010)
+
+/* NE_AUTH_SSPI: Use SSPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. */
+#define NE_AUTH_SSPI (0x0020)
+
+/* NE_AUTH_GSSAPI_ONLY: Use GSSAPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. */
+#define NE_AUTH_GSSAPI_ONLY (0x0040)
+
+/* The default set of supported protocols, as deemed appropriate for
+ * the given session scheme. */
+#define NE_AUTH_DEFAULT (0x1000)
+
+/* All protocols supported by the library. */
+#define NE_AUTH_ALL (0x2000)
+
+/* Add a callback to provide credentials for server and proxy
+ * authentication using a particular auth protocol or set of
+ * protocols.  The protocol is supplied as a bitmask of NE_AUTH_*
+ * values.  For NE_AUTH_NEGOTIATE, the creds and userdata arguments
+ * are ignored and may be NULL.
+ *
+ * These functions may be called multiple times per session to
+ * register callbacks for different protocols.  If the server presents
+ * more than one protocol in an auth challenge, the following
+ * algorithm will be used to determine which callback is used:
+ *
+ * - iterate over the registered callbacks in the order registered
+ * - for each each callback, iterate over the known set of protocols
+ *   in order of algorithm strength (strongest first).
+ * - if the protocol mask for that callback matches the protocol,
+ *   attempt authentication using this protocol.
+ *
+ * Therefore, if multiple calls to ne_add_server_auth or
+ * ne_add_proxy_auth are used for a given session, the caller must
+ * ensure that the order in which those calls are made reflects the
+ * precedence of protocols to be used. */
+void ne_add_server_auth(ne_session *sess, unsigned protocol, 
+                        ne_auth_creds creds, void *userdata);
+void ne_add_proxy_auth(ne_session *sess, unsigned protocol, 
+                       ne_auth_creds creds, void *userdata);
+
+/* Clear any cached authentication credentials for the given
+ * session. */
+void ne_forget_auth(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_AUTH_H */
diff --git a/net/mmt/neon/src/ne_basic.c b/net/mmt/neon/src/ne_basic.c
new file mode 100644
index 0000000..7b7190e
--- /dev/null
+++ b/net/mmt/neon/src/ne_basic.c
@@ -0,0 +1,501 @@
+/* 
+   Basic HTTP and WebDAV methods
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/stat.h> /* for struct stat */
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <errno.h>
+
+#include "ne_request.h"
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_basic.h"
+#include "ne_207.h"
+
+#ifdef NE_HAVE_DAV
+#include "ne_uri.h"
+#include "ne_locks.h"
+#endif
+
+#include "ne_dates.h"
+#include "ne_internal.h"
+
+int ne_getmodtime(ne_session *sess, const char *uri, time_t *modtime) 
+{
+    ne_request *req = ne_request_create(sess, "HEAD", uri);
+    const char *value;
+    int ret;
+
+    ret = ne_request_dispatch(req);
+
+    value = ne_get_response_header(req, "Last-Modified"); 
+
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	*modtime = -1;
+	ret = NE_ERROR;
+    } 
+    else if (value) {
+        *modtime = ne_httpdate_parse(value);
+    }
+    else {
+        *modtime = -1;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+#ifdef NE_LFS
+#define ne_fstat fstat64
+typedef struct stat64 struct_stat;
+#else
+#define ne_fstat fstat
+typedef struct stat struct_stat;
+#endif
+
+/* PUT's from fd to URI */
+int ne_put(ne_session *sess, const char *uri, int fd) 
+{
+    ne_request *req;
+    struct_stat st;
+    int ret;
+
+    if (ne_fstat(fd, &st)) {
+        int errnum = errno;
+        char buf[200];
+
+        ne_set_error(sess, _("Could not determine file size: %s"),
+                     ne_strerror(errnum, buf, sizeof buf));
+        return NE_ERROR;
+    }
+    
+    req = ne_request_create(sess, "PUT", uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+    ne_lock_using_parent(req, uri);
+#endif
+
+    ne_set_request_body_fd(req, fd, 0, st.st_size);
+	
+    ret = ne_request_dispatch(req);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2)
+	ret = NE_ERROR;
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+/* Dispatch a GET request REQ, writing the response body to FD fd.  If
+ * RANGE is non-NULL, then it is the value of the Range request
+ * header, e.g. "bytes=1-5".  Returns an NE_* error code. */
+static int dispatch_to_fd(ne_request *req, int fd, const char *range)
+{
+    ne_session *const sess = ne_get_session(req);
+    const ne_status *const st = ne_get_status(req);
+    int ret;
+    size_t rlen;
+
+    /* length of bytespec after "bytes=" */
+    rlen = range ? strlen(range + 6) : 0;
+
+    do {
+        const char *value;
+        
+        ret = ne_begin_request(req);
+        if (ret != NE_OK) break;
+
+        value = ne_get_response_header(req, "Content-Range");
+
+        /* For a 206 response, check that a Content-Range header is
+         * given which matches the Range request header. */
+        if (range && st->code == 206 
+            && (value == NULL || strncmp(value, "bytes ", 6) != 0
+                || strncmp(range + 6, value + 6, rlen)
+                || (range[5 + rlen] != '-' && value[6 + rlen] != '/'))) {
+            ne_set_error(sess, _("Response did not include requested range"));
+            return NE_ERROR;
+        }
+
+        if ((range && st->code == 206) || (!range && st->klass == 2)) {
+            ret = ne_read_response_to_fd(req, fd);
+        } else {
+            ret = ne_discard_response(req);
+        }
+
+        if (ret == NE_OK) ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    return ret;
+}
+
+static int get_range_common(ne_session *sess, const char *uri, 
+                            const char *brange, int fd)
+
+{
+    ne_request *req = ne_request_create(sess, "GET", uri);
+    const ne_status *status;
+    int ret;
+
+    ne_add_request_header(req, "Range", brange);
+    ne_add_request_header(req, "Accept-Ranges", "bytes");
+
+    ret = dispatch_to_fd(req, fd, brange);
+
+    status = ne_get_status(req);
+
+    if (ret == NE_OK && status->code == 416) {
+	/* connection is terminated too early with Apache/1.3, so we check
+	 * this even if ret == NE_ERROR... */
+	ne_set_error(sess, _("Range is not satisfiable"));
+	ret = NE_ERROR;
+    }
+    else if (ret == NE_OK) {
+	if (status->klass == 2 && status->code != 206) {
+	    ne_set_error(sess, _("Resource does not support ranged GET requests"));
+	    ret = NE_ERROR;
+	}
+	else if (status->klass != 2) {
+	    ret = NE_ERROR;
+	}
+    } 
+    
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_get_range(ne_session *sess, const char *uri, 
+		 ne_content_range *range, int fd)
+{
+    char brange[64];
+
+    if (range->end == -1) {
+        ne_snprintf(brange, sizeof brange, "bytes=%" FMT_NE_OFF_T "-", 
+                    range->start);
+    }
+    else {
+	ne_snprintf(brange, sizeof brange,
+                    "bytes=%" FMT_NE_OFF_T "-%" FMT_NE_OFF_T,
+                    range->start, range->end);
+    }
+
+    return get_range_common(sess, uri, brange, fd);
+}
+
+/* Get to given fd */
+int ne_get(ne_session *sess, const char *uri, int fd)
+{
+    ne_request *req = ne_request_create(sess, "GET", uri);
+    int ret;
+
+    ret = dispatch_to_fd(req, fd, NULL);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+
+/* Get to given fd */
+int ne_post(ne_session *sess, const char *uri, int fd, const char *buffer)
+{
+    ne_request *req = ne_request_create(sess, "POST", uri);
+    int ret;
+
+    ne_set_request_flag(req, NE_REQFLAG_IDEMPOTENT, 0);
+
+    ne_set_request_body_buffer(req, buffer, strlen(buffer));
+
+    ret = dispatch_to_fd(req, fd, NULL);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_get_content_type(ne_request *req, ne_content_type *ct)
+{
+    const char *value;
+    char *sep, *stype;
+
+    value = ne_get_response_header(req, "Content-Type");
+    if (value == NULL || strchr(value, '/') == NULL) {
+        return -1;
+    }
+
+    ct->value = ne_strdup(value);
+    
+    stype = strchr(ct->value, '/');
+
+    *stype++ = '\0';
+    ct->type = ct->value;
+    ct->charset = NULL;
+    
+    sep = strchr(stype, ';');
+
+    if (sep) {
+	char *tok;
+	/* look for the charset parameter. TODO; probably better to
+	 * hand-carve a parser than use ne_token/strstr/shave here. */
+	*sep++ = '\0';
+	do {
+	    tok = ne_qtoken(&sep, ';', "\"\'");
+	    if (tok) {
+		tok = strstr(tok, "charset=");
+		if (tok)
+		    ct->charset = ne_shave(tok+8, "\"\'");
+	    } else {
+		break;
+	    }
+	} while (sep != NULL);
+    }
+
+    /* set subtype, losing any trailing whitespace */
+    ct->subtype = ne_shave(stype, " \t");
+    
+    if (ct->charset == NULL && ne_strcasecmp(ct->type, "text") == 0) {
+        /* 32803.1: text/xml without charset implies us-ascii. */
+        if (ne_strcasecmp(ct->subtype, "xml") == 0)
+            ct->charset = "us-ascii";
+        /* 26163.7.1: subtypes of text/ default to charset ISO-8859-1. */
+        else
+            ct->charset = "ISO-8859-1";
+    }
+    
+    return 0;
+}
+
+static const struct options_map {
+    const char *name;
+    unsigned int cap;
+} options_map[] = {
+    { "1", NE_CAP_DAV_CLASS1 },
+    { "2", NE_CAP_DAV_CLASS2 },
+    { "3", NE_CAP_DAV_CLASS3 },
+    { "<http://apache.org/dav/propset/fs/1>", NE_CAP_MODDAV_EXEC },
+    { "access-control", NE_CAP_DAV_ACL },
+    { "version-control", NE_CAP_VER_CONTROL },
+    { "checkout-in-place", NE_CAP_CO_IN_PLACE },
+    { "version-history", NE_CAP_VER_HISTORY },
+    { "workspace", NE_CAP_WORKSPACE },
+    { "update", NE_CAP_UPDATE },
+    { "label", NE_CAP_LABEL },
+    { "working-resource", NE_CAP_WORK_RESOURCE },
+    { "merge", NE_CAP_MERGE },
+    { "baseline", NE_CAP_BASELINE },
+    { "version-controlled-collection", NE_CAP_VC_COLLECTION },
+    { "extended-mkcol", NE_CAP_EXT_MKCOL }
+};
+
+static void parse_dav_header(const char *value, unsigned int *caps)
+{
+    char *tokens = ne_strdup(value), *pnt = tokens;
+    
+    *caps = 0;
+
+    do {
+        char *tok = ne_qtoken(&pnt, ',',  "\"'");
+        unsigned n;
+
+        if (!tok) break;
+        
+        tok = ne_shave(tok, " \r\t\n");
+
+        for (n = 0; n < sizeof(options_map)/sizeof(options_map[0]); n++) {
+            if (strcmp(tok, options_map[n].name) == 0) {
+                *caps |= options_map[n].cap;
+            }
+        }
+    } while (pnt != NULL);
+    
+    ne_free(tokens);
+}
+
+int ne_options2(ne_session *sess, const char *uri, unsigned int *caps)
+{
+    ne_request *req = ne_request_create(sess, "OPTIONS", uri);
+    int ret = ne_request_dispatch(req);
+    const char *header = ne_get_response_header(req, "DAV");
+    
+    if (header) parse_dav_header(header, caps);
+ 
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+    
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_options(ne_session *sess, const char *path,
+               ne_server_capabilities *caps)
+{
+    int ret;
+    unsigned int capmask = 0;
+    
+    memset(caps, 0, sizeof *caps);
+
+    ret = ne_options2(sess, path, &capmask);
+
+    caps->dav_class1 = capmask & NE_CAP_DAV_CLASS1 ? 1 : 0;
+    caps->dav_class2 = capmask & NE_CAP_DAV_CLASS2 ? 1 : 0;
+    caps->dav_executable = capmask & NE_CAP_MODDAV_EXEC ? 1 : 0;
+    
+    return ret;
+}
+
+#ifdef NE_HAVE_DAV
+
+void ne_add_depth_header(ne_request *req, int depth)
+{
+    const char *value;
+    switch(depth) {
+    case NE_DEPTH_ZERO:
+	value = "0";
+	break;
+    case NE_DEPTH_ONE:
+	value = "1";
+	break;
+    default:
+	value = "infinity";
+	break;
+    }
+    ne_add_request_header(req, "Depth", value);
+}
+
+static int copy_or_move(ne_session *sess, int is_move, int overwrite,
+			int depth, const char *src, const char *dest) 
+{
+    ne_request *req = ne_request_create( sess, is_move?"MOVE":"COPY", src );
+
+    /* 2518 S8.9.2 says only use Depth: infinity with MOVE. */
+    if (!is_move) {
+	ne_add_depth_header(req, depth);
+    }
+
+#ifdef NE_HAVE_DAV
+    if (is_move) {
+	ne_lock_using_resource(req, src, NE_DEPTH_INFINITE);
+    }
+    ne_lock_using_resource(req, dest, NE_DEPTH_INFINITE);
+    /* And we need to be able to add members to the destination's parent */
+    ne_lock_using_parent(req, dest);
+#endif
+
+    if (ne_get_session_flag(sess, NE_SESSFLAG_RFC4918)) {
+        ne_add_request_header(req, "Destination", dest);
+    }
+    else {
+        ne_print_request_header(req, "Destination", "%s://%s%s", 
+                                ne_get_scheme(sess), 
+                                ne_get_server_hostport(sess), dest);
+    }
+    
+    ne_add_request_header(req, "Overwrite", overwrite?"T":"F");
+
+    return ne_simple_request(sess, req);
+}
+
+int ne_copy(ne_session *sess, int overwrite, int depth,
+	     const char *src, const char *dest) 
+{
+    return copy_or_move(sess, 0, overwrite, depth, src, dest);
+}
+
+int ne_move(ne_session *sess, int overwrite,
+	     const char *src, const char *dest) 
+{
+    return copy_or_move(sess, 1, overwrite, 0, src, dest);
+}
+
+/* Deletes the specified resource. (and in only two lines of code!) */
+int ne_delete(ne_session *sess, const char *uri) 
+{
+    ne_request *req = ne_request_create(sess, "DELETE", uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, NE_DEPTH_INFINITE);
+    ne_lock_using_parent(req, uri);
+#endif
+    
+    /* joe: I asked on the DAV WG list about whether we might get a
+     * 207 error back from a DELETE... conclusion, you shouldn't if
+     * you don't send the Depth header, since we might be an HTTP/1.1
+     * client and a 2xx response indicates success to them.  But
+     * it's all a bit unclear. In any case, DAV servers today do
+     * return 207 to DELETE even if we don't send the Depth header.
+     * So we handle 207 errors appropriately. */
+
+    return ne_simple_request(sess, req);
+}
+
+int ne_mkcol(ne_session *sess, const char *uri) 
+{
+    ne_request *req;
+    char *real_uri;
+    int ret;
+
+    if (ne_path_has_trailing_slash(uri)) {
+	real_uri = ne_strdup(uri);
+    } else {
+	real_uri = ne_concat(uri, "/", NULL);
+    }
+
+    req = ne_request_create(sess, "MKCOL", real_uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, real_uri, 0);
+    ne_lock_using_parent(req, real_uri);
+#endif
+    
+    ret = ne_simple_request(sess, req);
+
+    ne_free(real_uri);
+
+    return ret;
+}
+
+#endif /* NE_HAVE_DAV */
diff --git a/net/mmt/neon/src/ne_basic.h b/net/mmt/neon/src/ne_basic.h
new file mode 100644
index 0000000..257f033
--- /dev/null
+++ b/net/mmt/neon/src/ne_basic.h
@@ -0,0 +1,156 @@
+/* 
+   HTTP/1.1 methods
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_BASIC_H
+#define NE_BASIC_H
+
+#include <sys/types.h> /* for time_t */
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+/* Perform a GET request on resource at 'path', writing the entity
+ * body which is returned to 'fd'. */
+int ne_get(ne_session *sess, const char *path, int fd);
+
+/* Perform a PUT request on resource at 'path', reading the entity
+ * body to submit from 'fd'. */
+int ne_put(ne_session *sess, const char *path, int fd);
+
+#define NE_DEPTH_ZERO (0)
+#define NE_DEPTH_ONE (1)
+#define NE_DEPTH_INFINITE (2)
+
+/* For ne_copy and ne_move:
+ * 
+ * If a resource exists at "dest" and overwrite is zero, the operation
+ * will fail; if overwrite is non-zero, any existing resource will
+ * be over-written.
+ */
+
+/* Copy resource from 'src to 'dest' paths. If 'src' identifies a
+ * collection resource, depth may be NE_DEPTH_ZERO to request that the
+ * collection and its properties are to be copied, or
+ * NE_DEPTH_INFINITE to request that the collection and its contents
+ * are to be copied.  Returns NE_* error code. */
+int ne_copy(ne_session *sess, int overwrite, int depth,
+	    const char *src, const char *dest);
+
+/* Move resource from 'src' to 'dest' path.  Returns NE_* error
+ * code. */
+int ne_move(ne_session *sess, int overwrite,
+	    const char *src, const char *dest);
+
+/* Delete resource at 'path'.  Returns NE_* error code. */
+int ne_delete(ne_session *sess, const char *path);
+
+/* Create a collection at 'path', which is required to have a trailing
+ * slash.  Returns NE_* error code. */
+int ne_mkcol(ne_session *sess, const char *path);
+
+/* Adds a Depth: header to a request. */
+void ne_add_depth_header(ne_request *req, int depth);
+
+/* Retrieve modification time of resource at location 'path', using
+ * the HEAD method, placing parsed time in *modtime.  *modtime is set
+ * to -1 if no Last-Modified response header was given, or the date
+ * given could not be parsed.  Returns NE_* error code.  */
+int ne_getmodtime(ne_session *sess, const char *path, time_t *modtime);
+
+typedef struct {
+    const char *type, *subtype;
+    const char *charset;
+    char *value;
+} ne_content_type;
+
+/* Retrieve the content-type of the response; returns zero if response
+ * had valid content-type, in which case all fields in *ctype are set
+ * (and never NULL); the caller must free(ctype->value) after use.
+ * Returns non-zero on error, in which case *ctype is not altered. */
+int ne_get_content_type(ne_request *req, ne_content_type *ctype);
+
+/* DEPRECATED: Server capabilities. */
+typedef struct {
+    unsigned int dav_class1; /* True if Class 1 WebDAV server */
+    unsigned int dav_class2; /* True if Class 2 WebDAV server */
+    unsigned int dav_executable; /* True if supports the 'executable'
+				  * property a. la. mod_dav */
+} ne_server_capabilities;
+
+/* DEPRECATED: Determines server capabilities (using OPTIONS).  Use
+ * ne_options2() instead. */
+int ne_options(ne_session *sess, const char *path,
+               ne_server_capabilities *caps);
+
+#define NE_CAP_DAV_CLASS1    (0x0001) /* Class 1 WebDAV (RFC 2518) */
+#define NE_CAP_DAV_CLASS2    (0x0002) /* Class 2 WebDAV (RFC 2518) */
+#define NE_CAP_DAV_CLASS3    (0x0004) /* Class 3 WebDAV (RFC 4918) */
+#define NE_CAP_MODDAV_EXEC   (0x0008) /* mod_dav "executable" property */
+#define NE_CAP_DAV_ACL       (0x0010) /* WebDAV ACL (RFC 3744) */
+#define NE_CAP_VER_CONTROL   (0x0020) /* DeltaV version-control */
+#define NE_CAP_CO_IN_PLACE   (0x0040) /* DeltaV checkout-in-place */
+#define NE_CAP_VER_HISTORY   (0x0080) /* DeltaV version-history */
+#define NE_CAP_WORKSPACE     (0x0100) /* DeltaV workspace */
+#define NE_CAP_UPDATE        (0x0200) /* DeltaV update */
+#define NE_CAP_LABEL         (0x0400) /* DeltaV label */
+#define NE_CAP_WORK_RESOURCE (0x0800) /* DeltaV working-resouce */
+#define NE_CAP_MERGE         (0x1000) /* DeltaV merge */
+#define NE_CAP_BASELINE      (0x2000) /* DeltaV baseline */
+#define NE_CAP_ACTIVITY      (0x4000) /* DeltaV activity */
+#define NE_CAP_VC_COLLECTION (0x8000) /* DeltaV version-controlled-collection */
+#define NE_CAP_EXT_MKCOL    (0x10000) /* extended-mkcol (RFC 5689) */
+
+/* Determines resource capailities, using an OPTIONS request.  On
+ * return, *caps is set to a bit-mask of the above NE_CAP_* constants
+ * describing the advertised resource capabilities. */
+int ne_options2(ne_session *sess, const char *path, unsigned int *caps);
+
+/* Defines a range of bytes, starting at 'start' and ending
+ * at 'end'.  'total' is the number of bytes in the range.
+ */
+typedef struct {
+    ne_off_t start, end, total;
+} ne_content_range;
+
+/* Partial GET. range->start must be >= 0. range->total is ignored.
+ *
+ * If range->end is -1, then the rest of the resource from start is
+ * requested, and range->total and end are filled in on success.
+ *
+ * Otherwise, bytes from range->start to range->end are requested.
+ *
+ * This will write to the CURRENT position of f; so if you want
+ * to do a resume download, use:
+ *      struct ne_content_range range;
+ *      range.start = resume_from; 
+ *      range.end = range.start + 999;  (= 1000 bytes)
+ *      fseek(myfile, resume_from, SEEK_SET);
+ *      ne_get_range(sess, path, &range, myfile); */
+int ne_get_range(ne_session *sess, const char *path, 
+		 ne_content_range *range, int fd);
+
+/* Post using buffer as request-body: stream response into f */
+int ne_post(ne_session *sess, const char *path, int fd, const char *buffer);
+
+NE_END_DECLS
+
+#endif /* NE_BASIC_H */
diff --git a/net/mmt/neon/src/ne_compress.c b/net/mmt/neon/src/ne_compress.c
new file mode 100644
index 0000000..f122bf5
--- /dev/null
+++ b/net/mmt/neon/src/ne_compress.c
@@ -0,0 +1,449 @@
+/* 
+   Handling of compressed HTTP responses
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_compress.h"
+#include "ne_utils.h"
+#include "ne_internal.h"
+
+#ifdef NE_HAVE_ZLIB
+
+#include <zlib.h>
+
+/* Adds support for the 'gzip' Content-Encoding in HTTP.  gzip is a
+ * file format which wraps the DEFLATE compression algorithm.  zlib
+ * implements DEFLATE: we have to unwrap the gzip format (specified in
+ * RFC1952) as it comes off the wire, and hand off chunks of data to
+ * be inflated. */
+
+struct ne_decompress_s {
+    ne_request *request; /* associated request. */
+    ne_session *session; /* associated session. */
+    /* temporary buffer for holding inflated data. */
+    char outbuf[NE_BUFSIZ];
+    z_stream zstr;
+    int zstrinit; /* non-zero if zstr has been initialized */
+
+    /* pass blocks back to this. */
+    ne_block_reader reader;
+    ne_accept_response acceptor;
+    void *userdata;
+
+    /* buffer for gzip header bytes. */
+    unsigned char header[10];
+    size_t hdrcount;    /* bytes in header */
+
+    unsigned char footer[8];
+    size_t footcount; /* bytes in footer. */
+
+    /* CRC32 checksum: odd that zlib uses uLong for this since it is a
+     * 64-bit integer on LP64 platforms. */
+    uLong checksum;
+
+    /* current state. */
+    enum state {
+	NE_Z_BEFORE_DATA, /* not received any response blocks yet. */
+	NE_Z_PASSTHROUGH, /* response not compressed: passing through. */
+	NE_Z_IN_HEADER, /* received a few bytes of response data, but not
+			 * got past the gzip header yet. */
+	NE_Z_POST_HEADER, /* waiting for the end of the NUL-terminated bits. */
+	NE_Z_INFLATING, /* inflating response bytes. */
+	NE_Z_AFTER_DATA, /* after data; reading CRC32 & ISIZE */
+	NE_Z_FINISHED /* stream is finished. */
+    } state;
+};
+
+/* Convert 'buf' to unsigned int; 'buf' must be 'unsigned char *' */
+#define BUF2UINT(buf) (((buf)[3]<<24) + ((buf)[2]<<16) + ((buf)[1]<<8) + (buf)[0])
+
+#define ID1 0x1f
+#define ID2 0x8b
+
+#define HDR_DONE 0
+#define HDR_EXTENDED 1
+#define HDR_ERROR 2
+
+#define HDR_ID1(ctx) ((ctx)->header[0])
+#define HDR_ID2(ctx) ((ctx)->header[1])
+#define HDR_CMETH(ctx) ((ctx)->header[2])
+#define HDR_FLAGS(ctx) ((ctx)->header[3])
+#define HDR_MTIME(ctx) (BUF2UINT(&(ctx)->header[4]))
+#define HDR_XFLAGS(ctx) ((ctx)->header[8])
+#define HDR_OS(ctx) ((ctx)->header[9])
+
+/* parse_header parses the gzip header, sets the next state and returns
+ *   HDR_DONE: all done, bytes following are raw DEFLATE data.
+ *   HDR_EXTENDED: all done, expect a NUL-termianted string
+ *                 before the DEFLATE data
+ *   HDR_ERROR: invalid header, give up (session error is set).
+ */
+static int parse_header(ne_decompress *ctx)
+{
+    NE_DEBUG(NE_DBG_HTTP, "ID1: %d  ID2: %d, cmeth %d, flags %d\n", 
+             HDR_ID1(ctx), HDR_ID2(ctx), HDR_CMETH(ctx), HDR_FLAGS(ctx));
+    
+    if (HDR_ID1(ctx) != ID1 || HDR_ID2(ctx) != ID2 || HDR_CMETH(ctx) != 8) {
+	ne_set_error(ctx->session, "Compressed stream invalid");
+	return HDR_ERROR;
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "mtime: %d, xflags: %d, os: %d\n",
+	     HDR_MTIME(ctx), HDR_XFLAGS(ctx), HDR_OS(ctx));
+    
+    /* TODO: we can only handle one NUL-terminated extensions field
+     * currently.  Really, we should count the number of bits set, and
+     * skip as many fields as bits set (bailing if any reserved bits
+     * are set. */
+    if (HDR_FLAGS(ctx) == 8) {
+	ctx->state = NE_Z_POST_HEADER;
+	return HDR_EXTENDED;
+    } else if (HDR_FLAGS(ctx) != 0) {
+	ne_set_error(ctx->session, "Compressed stream not supported");
+	return HDR_ERROR;
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "compress: Good stream.\n");
+    
+    ctx->state = NE_Z_INFLATING;
+    return HDR_DONE;
+}
+
+/* Process extra 'len' bytes of 'buf' which were received after the
+ * DEFLATE data. */
+static int process_footer(ne_decompress *ctx, 
+			   const unsigned char *buf, size_t len)
+{
+    if (len + ctx->footcount > 8) {
+        ne_set_error(ctx->session, 
+                     "Too many bytes (%" NE_FMT_SIZE_T ") in gzip footer",
+                     len);
+        return -1;
+    } else {
+	memcpy(ctx->footer + ctx->footcount, buf, len);
+	ctx->footcount += len;
+	if (ctx->footcount == 8) {
+	    uLong crc = BUF2UINT(ctx->footer) & 0xFFFFFFFF;
+	    if (crc == ctx->checksum) {
+		ctx->state = NE_Z_FINISHED;
+		NE_DEBUG(NE_DBG_HTTP, "compress: End of response; checksum match.\n");
+	    } else {
+		NE_DEBUG(NE_DBG_HTTP, "compress: End of response; checksum mismatch: "
+			 "given %lu vs computed %lu\n", crc, ctx->checksum);
+		ne_set_error(ctx->session, 
+			     "Checksum invalid for compressed stream");
+                return -1;
+	    }
+	}
+    }
+    return 0;
+}
+
+/* A zlib function failed with 'code'; set the session error string
+ * appropriately. */
+static void set_zlib_error(ne_decompress *ctx, const char *msg, int code)
+{
+    if (ctx->zstr.msg)
+        ne_set_error(ctx->session, "%s: %s", msg, ctx->zstr.msg);
+    else {
+        const char *err;
+        switch (code) {
+        case Z_STREAM_ERROR: err = "stream error"; break;
+        case Z_DATA_ERROR: err = "data corrupt"; break;
+        case Z_MEM_ERROR: err = "out of memory"; break;
+        case Z_BUF_ERROR: err = "buffer error"; break;
+        case Z_VERSION_ERROR: err = "library version mismatch"; break;
+        default: err = "unknown error"; break;
+        }
+        ne_set_error(ctx->session, _("%s: %s (code %d)"), msg, err, code);
+    }
+}
+
+/* Inflate response buffer 'buf' of length 'len'. */
+static int do_inflate(ne_decompress *ctx, const char *buf, size_t len)
+{
+    int ret;
+
+    ctx->zstr.avail_in = len;
+    ctx->zstr.next_in = (unsigned char *)buf;
+    ctx->zstr.total_in = 0;
+    
+    do {
+	ctx->zstr.avail_out = sizeof ctx->outbuf;
+	ctx->zstr.next_out = (unsigned char *)ctx->outbuf;
+	ctx->zstr.total_out = 0;
+	
+	ret = inflate(&ctx->zstr, Z_NO_FLUSH);
+	
+	NE_DEBUG(NE_DBG_HTTP, 
+		 "compress: inflate %d, %ld bytes out, %d remaining\n",
+		 ret, ctx->zstr.total_out, ctx->zstr.avail_in);
+#if 0
+	NE_DEBUG(NE_DBG_HTTPBODY,
+		 "Inflated body block (%ld):\n[%.*s]\n", 
+		 ctx->zstr.total_out, (int)ctx->zstr.total_out, 
+		 ctx->outbuf);
+#endif
+	/* update checksum. */
+	ctx->checksum = crc32(ctx->checksum, (unsigned char *)ctx->outbuf, 
+			      ctx->zstr.total_out);
+
+	/* pass on the inflated data, if any */
+        if (ctx->zstr.total_out > 0) {
+            int rret = ctx->reader(ctx->userdata, ctx->outbuf,
+                                   ctx->zstr.total_out);
+            if (rret) return rret;
+        }	
+    } while (ret == Z_OK && ctx->zstr.avail_in > 0);
+    
+    if (ret == Z_STREAM_END) {
+	NE_DEBUG(NE_DBG_HTTP, "compress: end of data stream, %d bytes remain.\n",
+		 ctx->zstr.avail_in);
+	/* process the footer. */
+	ctx->state = NE_Z_AFTER_DATA;
+	return process_footer(ctx, ctx->zstr.next_in, ctx->zstr.avail_in);
+    } else if (ret != Z_OK) {
+        set_zlib_error(ctx, _("Could not inflate data"), ret);
+        return NE_ERROR;
+    }
+    return 0;
+}
+
+/* Callback which is passed blocks of the response body. */
+static int gz_reader(void *ud, const char *buf, size_t len)
+{
+    ne_decompress *ctx = ud;
+    const char *zbuf;
+    size_t count;
+    const char *hdr;
+
+    if (len == 0) {
+        /* End of response: */
+        switch (ctx->state) {
+        case NE_Z_BEFORE_DATA:
+            hdr = ne_get_response_header(ctx->request, "Content-Encoding");
+            if (hdr && ne_strcasecmp(hdr, "gzip") == 0) {
+                /* response was truncated: return error. */
+                break;
+            }
+            /* else, fall through */
+        case NE_Z_FINISHED: /* complete gzip response */
+        case NE_Z_PASSTHROUGH: /* complete uncompressed response */
+            return ctx->reader(ctx->userdata, buf, 0);
+        default:
+            /* invalid state: truncated response. */
+            break;
+        }
+	/* else: truncated response, fail. */
+	ne_set_error(ctx->session, "Compressed response was truncated");
+	return NE_ERROR;
+    }        
+
+    switch (ctx->state) {
+    case NE_Z_PASSTHROUGH:
+	/* move along there. */
+	return ctx->reader(ctx->userdata, buf, len);
+
+    case NE_Z_FINISHED:
+	/* Could argue for tolerance, and ignoring trailing content;
+	 * but it could mean something more serious. */
+	if (len > 0) {
+	    ne_set_error(ctx->session,
+			 "Unexpected content received after compressed stream");
+            return NE_ERROR;
+	}
+        break;
+
+    case NE_Z_BEFORE_DATA:
+	/* work out whether this is a compressed response or not. */
+        hdr = ne_get_response_header(ctx->request, "Content-Encoding");
+        if (hdr && ne_strcasecmp(hdr, "gzip") == 0) {
+            int ret;
+	    NE_DEBUG(NE_DBG_HTTP, "compress: got gzipped stream.\n");
+
+            /* inflateInit2() works here where inflateInit() doesn't. */
+            ret = inflateInit2(&ctx->zstr, -MAX_WBITS);
+            if (ret != Z_OK) {
+                set_zlib_error(ctx, _("Could not initialize zlib"), ret);
+                return -1;
+            }
+	    ctx->zstrinit = 1;
+
+	} else {
+	    /* No Content-Encoding header: pass it on.  TODO: we could
+	     * hack it and register the real callback now. But that
+	     * would require add_resp_body_rdr to have defined
+	     * ordering semantics etc etc */
+	    ctx->state = NE_Z_PASSTHROUGH;
+	    return ctx->reader(ctx->userdata, buf, len);
+	}
+
+	ctx->state = NE_Z_IN_HEADER;
+	/* FALLTHROUGH */
+
+    case NE_Z_IN_HEADER:
+	/* copy as many bytes as possible into the buffer. */
+	if (len + ctx->hdrcount > 10) {
+	    count = 10 - ctx->hdrcount;
+	} else {
+	    count = len;
+	}
+	memcpy(ctx->header + ctx->hdrcount, buf, count);
+	ctx->hdrcount += count;
+	/* have we got the full header yet? */
+	if (ctx->hdrcount != 10) {
+	    return 0;
+	}
+
+	buf += count;
+	len -= count;
+
+	switch (parse_header(ctx)) {
+	case HDR_EXTENDED:
+	    if (len == 0)
+		return 0;
+	    break;
+        case HDR_ERROR:
+            return NE_ERROR;
+	case HDR_DONE:
+	    if (len > 0) {
+		return do_inflate(ctx, buf, len);
+	    }
+            break;
+	}
+
+	/* FALLTHROUGH */
+
+    case NE_Z_POST_HEADER:
+	/* eating the filename string. */
+	zbuf = memchr(buf, '\0', len);
+	if (zbuf == NULL) {
+	    /* not found it yet. */
+	    return 0;
+	}
+
+	NE_DEBUG(NE_DBG_HTTP,
+		 "compresss: skipped %" NE_FMT_SIZE_T " header bytes.\n", 
+		 zbuf - buf);
+	/* found end of string. */
+	len -= (1 + zbuf - buf);
+	buf = zbuf + 1;
+	ctx->state = NE_Z_INFLATING;
+	if (len == 0) {
+	    /* end of string was at end of buffer. */
+	    return 0;
+	}
+
+	/* FALLTHROUGH */
+
+    case NE_Z_INFLATING:
+	return do_inflate(ctx, buf, len);
+
+    case NE_Z_AFTER_DATA:
+	return process_footer(ctx, (unsigned char *)buf, len);
+    }
+
+    return 0;
+}
+
+/* Prepare for a compressed response; may be called many times per
+ * request, for auth retries etc. */
+static void gz_pre_send(ne_request *r, void *ud, ne_buffer *req)
+{
+    ne_decompress *ctx = ud;
+
+    if (ctx->request == r) {
+        NE_DEBUG(NE_DBG_HTTP, "compress: Initialization.\n");
+        
+        /* (Re-)Initialize the context */
+        ctx->state = NE_Z_BEFORE_DATA;
+        if (ctx->zstrinit) inflateEnd(&ctx->zstr);
+        ctx->zstrinit = 0;
+        ctx->hdrcount = ctx->footcount = 0;
+        ctx->checksum = crc32(0L, Z_NULL, 0);
+    }
+}
+
+/* Wrapper for user-passed acceptor function. */
+static int gz_acceptor(void *userdata, ne_request *req, const ne_status *st)
+{
+    ne_decompress *ctx = userdata;
+    return ctx->acceptor(ctx->userdata, req, st);
+}
+
+/* A slightly ugly hack: the pre_send hook is scoped per-session, so
+ * must check that the invoking request is this one, before doing
+ * anything, and must be unregistered when the context is
+ * destroyed. */
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response acpt,
+				    ne_block_reader rdr, void *userdata)
+{
+    ne_decompress *ctx = ne_calloc(sizeof *ctx);
+
+    ne_add_request_header(req, "Accept-Encoding", "gzip");
+
+    ne_add_response_body_reader(req, gz_acceptor, gz_reader, ctx);
+
+    ctx->reader = rdr;
+    ctx->userdata = userdata;
+    ctx->session = ne_get_session(req);
+    ctx->request = req;
+    ctx->acceptor = acpt;
+
+    ne_hook_pre_send(ne_get_session(req), gz_pre_send, ctx);
+
+    return ctx;    
+}
+
+void ne_decompress_destroy(ne_decompress *ctx)
+{
+    if (ctx->zstrinit) inflateEnd(&ctx->zstr);
+
+    ne_unhook_pre_send(ctx->session, gz_pre_send, ctx);
+
+    ne_free(ctx);
+}
+
+#else /* !NE_HAVE_ZLIB */
+
+/* Pass-through interface present to provide ABI compatibility. */
+
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response acpt,
+				    ne_block_reader rdr, void *userdata)
+{
+    ne_add_response_body_reader(req, acpt, rdr, userdata);
+    /* an arbitrary return value: don't confuse them by returning NULL. */
+    return (ne_decompress *)req;
+}
+
+void ne_decompress_destroy(ne_decompress *dc)
+{
+}
+
+#endif /* NE_HAVE_ZLIB */
diff --git a/net/mmt/neon/src/ne_compress.h b/net/mmt/neon/src/ne_compress.h
new file mode 100644
index 0000000..039cebd
--- /dev/null
+++ b/net/mmt/neon/src/ne_compress.h
@@ -0,0 +1,48 @@
+/* 
+   Compressed HTTP response handling
+   Copyright (C) 2001-2004, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_COMPRESS_H
+#define NE_COMPRESS_H
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_decompress_s ne_decompress;
+
+/* Call this to register a 'reader' callback which will be passed
+ * blocks of response body (if the 'acceptance' callback is
+ * successful).  If the response body is returned compressed by the
+ * server, this reader will receive UNCOMPRESSED blocks.
+ *
+ * Returns pointer to context object which must be passed to
+ * ne_decompress_destroy after the request has been dispatched, to
+ * free any internal state.  If an error occurs during decompression,
+ * the request will be aborted and session error string set. */
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response accpt,
+				    ne_block_reader rdr, void *userdata);
+
+/* Destroys decompression state. */
+void ne_decompress_destroy(ne_decompress *ctx);
+
+NE_END_DECLS
+
+#endif /* NE_COMPRESS_H */
diff --git a/net/mmt/neon/src/ne_dates.c b/net/mmt/neon/src/ne_dates.c
new file mode 100644
index 0000000..b621e7a
--- /dev/null
+++ b/net/mmt/neon/src/ne_dates.c
@@ -0,0 +1,262 @@
+/* 
+   Date manipulation routines
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004 Jiang Lei <tristone@deluxe.ocn.ne.jp>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <time.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#include <stdio.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef WIN32
+#include <windows.h> /* for TIME_ZONE_INFORMATION */
+#endif
+
+#include "ne_alloc.h"
+#include "ne_dates.h"
+#include "ne_string.h"
+
+/* Generic date manipulation routines. */
+
+/* ISO8601: 2001-01-01T12:30:00Z */
+#define ISO8601_FORMAT_Z "%04d-%02d-%02dT%02d:%02d:%lfZ"
+#define ISO8601_FORMAT_M "%04d-%02d-%02dT%02d:%02d:%lf-%02d:%02d"
+#define ISO8601_FORMAT_P "%04d-%02d-%02dT%02d:%02d:%lf+%02d:%02d"
+
+/* RFC1123: Sun, 06 Nov 1994 08:49:37 GMT */
+#define RFC1123_FORMAT "%3s, %02d %3s %4d %02d:%02d:%02d GMT"
+/* RFC850:  Sunday, 06-Nov-94 08:49:37 GMT */
+#define RFC1036_FORMAT "%10s %2d-%3s-%2d %2d:%2d:%2d GMT"
+/* asctime: Wed Jun 30 21:49:08 1993 */
+#define ASCTIME_FORMAT "%3s %3s %2d %2d:%2d:%2d %4d"
+
+static const char rfc1123_weekdays[7][4] = { 
+    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" 
+};
+static const char short_months[12][4] = { 
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
+
+#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
+#define GMTOFF(t) ((t).tm_gmtoff)
+#elif defined(HAVE_STRUCT_TM___TM_GMTOFF)
+#define GMTOFF(t) ((t).__tm_gmtoff)
+#elif defined(WIN32)
+#define GMTOFF(t) (gmt_to_local_win32())
+#elif defined(HAVE_TIMEZONE)
+/* FIXME: the following assumes fixed dst offset of 1 hour */
+#define GMTOFF(t) (-timezone + ((t).tm_isdst > 0 ? 3600 : 0))
+#else
+/* FIXME: work out the offset anyway. */
+#define GMTOFF(t) (0)
+#endif
+
+#ifdef WIN32
+time_t gmt_to_local_win32(void)
+{
+    TIME_ZONE_INFORMATION tzinfo;
+    DWORD dwStandardDaylight;
+    long bias;
+
+    dwStandardDaylight = GetTimeZoneInformation(&tzinfo);
+    bias = tzinfo.Bias;
+
+    if (dwStandardDaylight == TIME_ZONE_ID_STANDARD)
+        bias += tzinfo.StandardBias;
+    
+    if (dwStandardDaylight == TIME_ZONE_ID_DAYLIGHT)
+        bias += tzinfo.DaylightBias;
+    
+    return (- bias * 60);
+}
+#endif
+
+/* Returns the time/date GMT, in RFC1123-type format: eg
+ *  Sun, 06 Nov 1994 08:49:37 GMT. */
+char *ne_rfc1123_date(time_t anytime) {
+    struct tm *gmt;
+    char *ret;
+    gmt = gmtime(&anytime);
+    if (gmt == NULL)
+	return NULL;
+    ret = ne_malloc(29 + 1); /* dates are 29 chars long */
+/*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
+    ne_snprintf(ret, 30, RFC1123_FORMAT,
+		rfc1123_weekdays[gmt->tm_wday], gmt->tm_mday, 
+		short_months[gmt->tm_mon], 1900 + gmt->tm_year, 
+		gmt->tm_hour, gmt->tm_min, gmt->tm_sec);
+    
+    return ret;
+}
+
+/* Takes an ISO-8601-formatted date string and returns the time_t.
+ * Returns (time_t)-1 if the parse fails. */
+time_t ne_iso8601_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int off_hour, off_min;
+    double sec;
+    off_t fix;
+    int n;
+    time_t result;
+
+    /*  it goes: ISO8601: 2001-01-01T12:30:00+03:30 */
+    if ((n = sscanf(date, ISO8601_FORMAT_P,
+		    &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+		    &gmt.tm_hour, &gmt.tm_min, &sec,
+		    &off_hour, &off_min)) == 8) {
+      gmt.tm_sec = (int)sec;
+      fix = - off_hour * 3600 - off_min * 60;
+    }
+    /*  it goes: ISO8601: 2001-01-01T12:30:00-03:30 */
+    else if ((n = sscanf(date, ISO8601_FORMAT_M,
+			 &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+			 &gmt.tm_hour, &gmt.tm_min, &sec,
+			 &off_hour, &off_min)) == 8) {
+      gmt.tm_sec = (int)sec;
+      fix = off_hour * 3600 + off_min * 60;
+    }
+    /*  it goes: ISO8601: 2001-01-01T12:30:00Z */
+    else if ((n = sscanf(date, ISO8601_FORMAT_Z,
+			 &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+			 &gmt.tm_hour, &gmt.tm_min, &sec)) == 6) {
+      gmt.tm_sec = (int)sec;
+      fix = 0;
+    }
+    else {
+      return (time_t)-1;
+    }
+
+    gmt.tm_year -= 1900;
+    gmt.tm_isdst = -1;
+    gmt.tm_mon--;
+
+    result = mktime(&gmt) + fix;
+    return result + GMTOFF(gmt);
+}
+
+/* Takes an RFC1123-formatted date string and returns the time_t.
+ * Returns (time_t)-1 if the parse fails. */
+time_t ne_rfc1123_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    char wkday[4], mon[4];
+    int n;
+    time_t result;
+    
+/*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
+    n = sscanf(date, RFC1123_FORMAT,
+	    wkday, &gmt.tm_mday, mon, &gmt.tm_year, &gmt.tm_hour,
+	    &gmt.tm_min, &gmt.tm_sec);
+    /* Is it portable to check n==7 here? */
+    gmt.tm_year -= 1900;
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+/* Takes a string containing a RFC1036-style date and returns the time_t */
+time_t ne_rfc1036_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int n;
+    char wkday[11], mon[4];
+    time_t result;
+
+    /* RFC850/1036 style dates: Sunday, 06-Nov-94 08:49:37 GMT */
+    n = sscanf(date, RFC1036_FORMAT,
+		wkday, &gmt.tm_mday, mon, &gmt.tm_year,
+		&gmt.tm_hour, &gmt.tm_min, &gmt.tm_sec);
+    if (n != 7) {
+	return (time_t)-1;
+    }
+
+    /* portable to check n here? */
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+
+    /* Defeat Y2K bug. */
+    if (gmt.tm_year < 50)
+	gmt.tm_year += 100;
+
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+
+/* (as)ctime dates are like:
+ *    Wed Jun 30 21:49:08 1993
+ */
+time_t ne_asctime_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int n;
+    char wkday[4], mon[4];
+    time_t result;
+
+    n = sscanf(date, ASCTIME_FORMAT,
+		wkday, mon, &gmt.tm_mday, 
+		&gmt.tm_hour, &gmt.tm_min, &gmt.tm_sec,
+		&gmt.tm_year);
+    /* portable to check n here? */
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+/* HTTP-date parser */
+time_t ne_httpdate_parse(const char *date)
+{
+    time_t tmp;
+    tmp = ne_rfc1123_parse(date);
+    if (tmp == -1) {
+        tmp = ne_rfc1036_parse(date);
+	if (tmp == -1)
+	    tmp = ne_asctime_parse(date);
+    }
+    return tmp;
+}
diff --git a/net/mmt/neon/src/ne_dates.h b/net/mmt/neon/src/ne_dates.h
new file mode 100644
index 0000000..7be69b1
--- /dev/null
+++ b/net/mmt/neon/src/ne_dates.h
@@ -0,0 +1,54 @@
+/* 
+   Date manipulation routines
+   Copyright (C) 1999-2002, 2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_DATES_H
+#define NE_DATES_H
+
+#include <sys/types.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Date manipulation routines as per RFC1123 and RFC1036 */
+
+/* Return current date/time in RFC1123 format */
+char *ne_rfc1123_date(time_t anytime);
+
+/* Returns time from date/time using the subset of the ISO8601 format
+ * referenced in RFC2518 (e.g as used in the creationdate property in
+ * the DAV: namespace). */
+time_t ne_iso8601_parse(const char *date);
+
+/* Returns time from date/time in RFC1123 format */
+time_t ne_rfc1123_parse(const char *date);
+
+time_t ne_rfc1036_parse(const char *date);
+
+/* Parses asctime date string */
+time_t ne_asctime_parse(const char *date);
+
+/* Parse an HTTP-date as per RFC2616 */
+time_t ne_httpdate_parse(const char *date);
+
+NE_END_DECLS
+
+#endif /* NE_DATES_H */
diff --git a/net/mmt/neon/src/ne_defs.h b/net/mmt/neon/src/ne_defs.h
new file mode 100644
index 0000000..4283454
--- /dev/null
+++ b/net/mmt/neon/src/ne_defs.h
@@ -0,0 +1,84 @@
+/* 
+   Standard definitions for neon headers
+   Copyright (C) 2003-2008, 2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#undef NE_BEGIN_DECLS
+#undef NE_END_DECLS
+#ifdef __cplusplus
+# define NE_BEGIN_DECLS extern "C" {
+# define NE_END_DECLS }
+#else
+# define NE_BEGIN_DECLS /* empty */
+# define NE_END_DECLS /* empty */
+#endif
+
+#ifndef NE_DEFS_H
+#define NE_DEFS_H
+
+#include <sys/types.h>
+
+#ifdef NE_LFS
+# ifdef _MSC_VER
+typedef __int64 off64_t;
+# endif
+typedef off64_t ne_off_t;
+#else
+typedef off_t ne_off_t;
+#endif
+
+/* define ssize_t for Win32 */
+#if defined(WIN32) && !defined(ssize_t)
+#define ssize_t int
+#endif
+
+#ifdef __NETWARE__
+#include <time.h> /* for time_t */
+#endif
+
+#ifdef __GNUC__
+#if __GNUC__ >= 3
+#ifndef NE_PRIVATE
+#define NE_PRIVATE __attribute__((visibility ("hidden")))
+#endif
+#define ne_attribute_malloc __attribute__((malloc))
+#else
+#define ne_attribute_malloc
+#endif
+#if __GNUC__ > 3
+#define ne_attribute_sentinel __attribute__((sentinel))
+#else
+#define ne_attribute_sentinel 
+#endif
+#define ne_attribute(x) __attribute__(x)
+#else
+#define ne_attribute(x)
+#define ne_attribute_malloc
+#define ne_attribute_sentinel
+#endif
+
+#ifndef NE_PRIVATE
+#define NE_PRIVATE
+#endif
+
+#ifndef NE_BUFSIZ
+#define NE_BUFSIZ 8192
+#endif
+
+#endif /* NE_DEFS_H */
diff --git a/net/mmt/neon/src/ne_gnutls.c b/net/mmt/neon/src/ne_gnutls.c
new file mode 100644
index 0000000..08d78cc
--- /dev/null
+++ b/net/mmt/neon/src/ne_gnutls.c
@@ -0,0 +1,1435 @@
+/*
+   neon SSL/TLS support using GNU TLS
+   Copyright (C) 2002-2011, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004, Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <gnutls/gnutls.h>
+#include <gnutls/pkcs12.h>
+
+#ifdef NE_HAVE_TS_SSL
+#include <errno.h>
+#include <pthread.h>
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#include <gcrypt.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+#endif
+#else
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#include <gcrypt.h>
+#endif
+#endif
+
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
+
+#include "ne_ssl.h"
+#include "ne_string.h"
+#include "ne_session.h"
+#include "ne_internal.h"
+
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020302
+/* The GnuTLS DN functions in 2.3.2 and later allow a simpler DN
+ * abstraction to be used. */
+#define HAVE_NEW_DN_API
+#endif
+
+struct ne_ssl_dname_s {
+#ifdef HAVE_NEW_DN_API
+    gnutls_x509_dn_t dn;
+#else
+    int subject; /* non-zero if this is the subject DN object */
+    gnutls_x509_crt_t cert;
+#endif
+};
+
+struct ne_ssl_certificate_s {
+    ne_ssl_dname subj_dn, issuer_dn;
+    gnutls_x509_crt_t subject;
+    ne_ssl_certificate *issuer;
+    char *identity;
+};
+
+struct ne_ssl_client_cert_s {
+    gnutls_pkcs12_t p12;
+    int decrypted; /* non-zero if successfully decrypted. */
+    int keyless;
+    ne_ssl_certificate cert;
+    gnutls_x509_privkey_t pkey;
+    char *friendly_name;
+};
+
+/* Returns the highest used index in subject (or issuer) DN of
+ * certificate CERT for OID, or -1 if no RDNs are present in the DN
+ * using that OID. */
+static int oid_find_highest_index(gnutls_x509_crt_t cert, int subject, const char *oid)
+{
+    int ret, idx = -1;
+
+    do {
+        size_t len = 0;
+
+        if (subject)
+            ret = gnutls_x509_crt_get_dn_by_oid(cert, oid, ++idx, 0, 
+                                                NULL, &len);
+        else
+            ret = gnutls_x509_crt_get_issuer_dn_by_oid(cert, oid, ++idx, 0, 
+                                                       NULL, &len);
+    } while (ret == GNUTLS_E_SHORT_MEMORY_BUFFER);
+    
+    return idx - 1;
+}
+
+#ifdef HAVE_GNUTLS_X509_DN_GET_RDN_AVA
+/* New-style RDN handling introduced in GnuTLS 1.7.x. */
+
+#ifdef HAVE_ICONV
+static void convert_dirstring(ne_buffer *buf, const char *charset, 
+                              gnutls_datum_t *data)
+{
+    iconv_t id = iconv_open("UTF-8", charset);
+    size_t inlen = data->size, outlen = buf->length - buf->used;
+    char *inbuf = (char *)data->data;
+    char *outbuf = buf->data + buf->used - 1;
+    
+    if (id == (iconv_t)-1) {
+        char err[128], err2[128];
+
+        ne_snprintf(err, sizeof err, "[unprintable in %s: %s]",
+                    charset, ne_strerror(errno, err2, sizeof err2));
+        ne_buffer_zappend(buf, err);
+        return;
+    }
+    
+    ne_buffer_grow(buf, buf->used + 64);
+    
+    while (inlen && outlen 
+           && iconv(id, &inbuf, &inlen, &outbuf, &outlen) == 0)
+        ;
+    
+    iconv_close(id);
+    buf->used += buf->length - buf->used - outlen;
+    buf->data[buf->used - 1] = '\0';
+}
+#endif
+
+/* From section 11.13 of the Dubuisson ASN.1 bible: */
+#define TAG_UTF8 (12)
+#define TAG_PRINTABLE (19)
+#define TAG_T61 (20)
+#define TAG_IA5 (22)
+#define TAG_VISIBLE (26)
+#define TAG_UNIVERSAL (28)
+#define TAG_BMP (30)
+
+static void append_dirstring(ne_buffer *buf, gnutls_datum_t *data, unsigned long tag)
+{
+    switch (tag) {
+    case TAG_UTF8:
+    case TAG_IA5:
+    case TAG_PRINTABLE:
+    case TAG_VISIBLE:
+        ne_buffer_append(buf, (char *)data->data, data->size);
+        break;
+#ifdef HAVE_ICONV
+    case TAG_T61:
+        convert_dirstring(buf, "ISO-8859-1", data);
+        break;
+    case TAG_BMP:
+        convert_dirstring(buf, "UCS-2BE", data);
+        break;
+#endif
+    default: {
+        char tmp[128];
+        ne_snprintf(tmp, sizeof tmp, _("[unprintable:#%lu]"), tag);
+        ne_buffer_zappend(buf, tmp);
+    } break;
+    }
+}
+
+/* OIDs to not include in readable DNs by default: */
+#define OID_emailAddress "1.2.840.113549.1.9.1"
+#define OID_commonName "2.5.4.3"
+
+#define CMPOID(a,o) ((a)->oid.size == sizeof(o)                        \
+                     && memcmp((a)->oid.data, o, strlen(o)) == 0)
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    gnutls_x509_dn_t dn;
+    int ret, rdn = 0, flag = 0;
+    ne_buffer *buf;
+    gnutls_x509_ava_st val;
+
+#ifdef HAVE_NEW_DN_API
+    dn = name->dn;
+#else
+    if (name->subject)
+        ret = gnutls_x509_crt_get_subject(name->cert, &dn);
+    else
+        ret = gnutls_x509_crt_get_issuer(name->cert, &dn);
+    
+    if (ret)
+        return ne_strdup(_("[unprintable]"));
+#endif /* HAVE_NEW_DN_API */
+
+    buf = ne_buffer_create();
+    
+    /* Find the highest rdn... */
+    while (gnutls_x509_dn_get_rdn_ava(dn, rdn++, 0, &val) == 0)
+        ;        
+
+    /* ..then iterate back to the first: */
+    while (--rdn >= 0) {
+        int ava = 0;
+
+        /* Iterate through all AVAs for multivalued AVAs; better than
+         * ne_openssl can do! */
+        do {
+            ret = gnutls_x509_dn_get_rdn_ava(dn, rdn, ava, &val);
+
+            /* If the *only* attribute to append is the common name or
+             * email address, use it; otherwise skip those
+             * attributes. */
+            if (ret == 0 && val.value.size > 0
+                && ((!CMPOID(&val, OID_emailAddress)
+                     && !CMPOID(&val, OID_commonName))
+                    || (buf->used == 1 && rdn == 0))) {
+                flag = 1;
+                if (buf->used > 1) ne_buffer_append(buf, ", ", 2);
+
+                append_dirstring(buf, &val.value, val.value_tag);
+            }
+            
+            ava++;
+        } while (ret == 0);
+    }
+
+    return ne_buffer_finish(buf);
+}
+
+#else /* !HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+/* Appends the value of RDN with given oid from certitifcate x5
+ * subject (if subject is non-zero), or issuer DN to buffer 'buf': */
+static void append_rdn(ne_buffer *buf, gnutls_x509_crt_t x5, int subject, const char *oid)
+{
+    int idx, top, ret;
+    char rdn[50];
+
+    top = oid_find_highest_index(x5, subject, oid);
+    
+    for (idx = top; idx >= 0; idx--) {
+        size_t rdnlen = sizeof rdn;
+
+        if (subject)
+            ret = gnutls_x509_crt_get_dn_by_oid(x5, oid, idx, 0, rdn, &rdnlen);
+        else
+            ret = gnutls_x509_crt_get_issuer_dn_by_oid(x5, oid, idx, 0, rdn, &rdnlen);
+        
+        if (ret < 0)
+            return;
+
+        if (buf->used > 1) {
+            ne_buffer_append(buf, ", ", 2);
+        }
+        
+        ne_buffer_append(buf, rdn, rdnlen);
+    }
+}
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    ne_buffer *buf = ne_buffer_create();
+    int ret, idx = 0;
+
+    do {
+        char oid[32] = {0};
+        size_t oidlen = sizeof oid;
+        
+        ret = name->subject 
+            ? gnutls_x509_crt_get_dn_oid(name->cert, idx, oid, &oidlen)
+            : gnutls_x509_crt_get_issuer_dn_oid(name->cert, idx, oid, &oidlen);
+        
+        if (ret == 0) {
+            append_rdn(buf, name->cert, name->subject, oid);
+            idx++;
+        }
+    } while (ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);
+
+    return ne_buffer_finish(buf);
+}
+#endif /* HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    char c1[1024], c2[1024];
+    size_t s1 = sizeof c1, s2 = sizeof c2;
+
+#ifdef HAVE_NEW_DN_API
+    if (gnutls_x509_dn_export(dn1->dn, GNUTLS_X509_FMT_DER, c1, &s1))
+        return 1;
+        
+    if (gnutls_x509_dn_export(dn2->dn, GNUTLS_X509_FMT_DER, c2, &s2))
+        return -1;
+#else
+    int ret;
+
+    if (dn1->subject)
+        ret = gnutls_x509_crt_get_dn(dn1->cert, c1, &s1);
+    else
+        ret = gnutls_x509_crt_get_issuer_dn(dn1->cert, c1, &s1);
+    if (ret)
+        return 1;
+
+    if (dn2->subject)
+        ret = gnutls_x509_crt_get_dn(dn2->cert, c2, &s2);
+    else
+        ret = gnutls_x509_crt_get_issuer_dn(dn2->cert, c2, &s2);
+    if (ret)
+        return -1;
+#endif /* HAVE_NEW_DN_API */
+    
+    if (s1 != s2)
+        return s2 - s1;
+
+    return memcmp(c1, c2, s1);
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *cc)
+{
+    if (cc->p12)
+        gnutls_pkcs12_deinit(cc->p12);
+    if (cc->decrypted) {
+        if (cc->cert.identity) ne_free(cc->cert.identity);
+        if (cc->pkey) gnutls_x509_privkey_deinit(cc->pkey);
+        if (cc->cert.subject) gnutls_x509_crt_deinit(cc->cert.subject);
+    }
+    if (cc->friendly_name) ne_free(cc->friendly_name);
+    ne_free(cc);
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until)
+{
+    if (from) {
+        *from = gnutls_x509_crt_get_activation_time(cert->subject);
+    }
+    if (until) {
+        *until = gnutls_x509_crt_get_expiration_time(cert->subject);
+    }
+}
+
+/* Check certificate identity.  Returns zero if identity matches; 1 if
+ * identity does not match, or <0 if the certificate had no identity.
+ * If 'identity' is non-NULL, store the malloc-allocated identity in
+ * *identity.  If 'server' is non-NULL, it must be the network address
+ * of the server in use, and identity must be NULL. */
+static int check_identity(const ne_uri *server, gnutls_x509_crt_t cert,
+                          char **identity)
+{
+    char name[255];
+    unsigned int critical;
+    int ret, seq = 0;
+    int match = 0, found = 0;
+    size_t len;
+    const char *hostname;
+    
+    hostname = server ? server->host : "";
+
+    do {
+        len = sizeof name - 1;
+        ret = gnutls_x509_crt_get_subject_alt_name(cert, seq, name, &len,
+                                                   &critical);
+        switch (ret) {
+        case GNUTLS_SAN_DNSNAME:
+            name[len] = '\0';
+            if (identity && !found) *identity = ne_strdup(name);
+            match = ne__ssl_match_hostname(name, len, hostname);
+            found = 1;
+            break;
+        case GNUTLS_SAN_IPADDRESS: {
+            ne_inet_addr *ia;
+            if (len == 4)
+                ia = ne_iaddr_make(ne_iaddr_ipv4, (unsigned char *)name);
+            else if (len == 16)
+                ia = ne_iaddr_make(ne_iaddr_ipv6, (unsigned char *)name);
+            else 
+                ia = NULL;
+            if (ia) {
+                char buf[128];
+                
+                match = strcmp(hostname, 
+                               ne_iaddr_print(ia, buf, sizeof buf)) == 0;
+                if (identity) *identity = ne_strdup(buf);
+                found = 1;
+                ne_iaddr_free(ia);
+            } else {
+                NE_DEBUG(NE_DBG_SSL, "iPAddress name with unsupported "
+                         "address type (length %" NE_FMT_SIZE_T "), skipped.\n",
+                         len);
+            }
+        } break;
+        case GNUTLS_SAN_URI: {
+            ne_uri uri;
+            
+            name[len] = '\0';
+            
+            if (ne_uri_parse(name, &uri) == 0 && uri.host && uri.scheme) {
+                ne_uri tmp;
+                
+                if (identity && !found) *identity = ne_strdup(name);
+                found = 1;
+                
+                if (server) {
+                    /* For comparison purposes, all that matters is
+                     * host, scheme and port; ignore the rest. */
+                    memset(&tmp, 0, sizeof tmp);
+                    tmp.host = uri.host;
+                    tmp.scheme = uri.scheme;
+                    tmp.port = uri.port;
+                    
+                    match = ne_uri_cmp(server, &tmp) == 0;
+                }
+            }
+            
+            ne_uri_free(&uri);
+        } break;
+
+        default:
+            break;
+        }
+        seq++;
+    } while (!match && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);
+
+    /* Check against the commonName if no DNS alt. names were found,
+     * as per RFC3280. */
+    if (!found) {
+        seq = oid_find_highest_index(cert, 1, GNUTLS_OID_X520_COMMON_NAME);
+
+        if (seq >= 0) {
+            len = sizeof name;
+            name[0] = '\0';
+            ret = gnutls_x509_crt_get_dn_by_oid(cert, GNUTLS_OID_X520_COMMON_NAME,
+                                                seq, 0, name, &len);
+            if (ret == 0) {
+                if (identity) *identity = ne_strdup(name);
+                match = ne__ssl_match_hostname(name, len, hostname);
+            }
+        } else {
+            return -1;
+        }
+    }
+
+    if (*hostname)
+        NE_DEBUG(NE_DBG_SSL, "ssl: Identity match for '%s': %s\n", hostname, 
+                 match ? "good" : "bad");
+
+    return match ? 0 : 1;
+}
+
+/* Populate an ne_ssl_certificate structure from an X509 object.  Note
+ * that x5 is owned by returned cert object and must not be otherwise
+ * freed by the caller.  */
+static ne_ssl_certificate *populate_cert(ne_ssl_certificate *cert,
+                                         gnutls_x509_crt_t x5)
+{
+#ifdef HAVE_NEW_DN_API
+    gnutls_x509_crt_get_subject(x5, &cert->subj_dn.dn);
+    gnutls_x509_crt_get_issuer(x5, &cert->issuer_dn.dn);
+#else
+    cert->subj_dn.cert = x5;
+    cert->subj_dn.subject = 1;
+    cert->issuer_dn.cert = x5;
+    cert->issuer_dn.subject = 0;
+#endif
+    cert->issuer = NULL;
+    cert->subject = x5;
+    cert->identity = NULL;
+    check_identity(NULL, x5, &cert->identity);
+    return cert;
+}
+
+/* Returns a copy certificate of certificate SRC. */
+static gnutls_x509_crt_t x509_crt_copy(gnutls_x509_crt_t src)
+{
+    int ret;
+    size_t size = 0;
+    gnutls_datum_t tmp;
+    gnutls_x509_crt_t dest;
+    
+    if (gnutls_x509_crt_init(&dest) != 0) {
+        return NULL;
+    }
+
+    if (gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, NULL, &size) 
+        != GNUTLS_E_SHORT_MEMORY_BUFFER) {
+        gnutls_x509_crt_deinit(dest);
+        return NULL;
+    }
+
+    tmp.data = ne_malloc(size);
+    ret = gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, tmp.data, &size);
+    if (ret == 0) {
+        tmp.size = size;
+        ret = gnutls_x509_crt_import(dest, &tmp, GNUTLS_X509_FMT_DER);
+    }
+
+    if (ret) {
+        gnutls_x509_crt_deinit(dest);
+        dest = NULL;
+    }
+
+    ne_free(tmp.data);
+    return dest;
+}
+
+/* Duplicate a client certificate, which must be in the decrypted state. */
+static ne_ssl_client_cert *dup_client_cert(const ne_ssl_client_cert *cc)
+{
+    int ret;
+    ne_ssl_client_cert *newcc = ne_calloc(sizeof *newcc);
+
+    newcc->decrypted = 1;
+    
+    if (cc->keyless) {
+        newcc->keyless = 1;
+    }
+    else {
+        ret = gnutls_x509_privkey_init(&newcc->pkey);
+        if (ret != 0) goto dup_error;
+        
+        ret = gnutls_x509_privkey_cpy(newcc->pkey, cc->pkey);
+        if (ret != 0) goto dup_error;
+    }    
+
+    newcc->cert.subject = x509_crt_copy(cc->cert.subject);
+    if (!newcc->cert.subject) goto dup_error;
+
+    if (cc->friendly_name) newcc->friendly_name = ne_strdup(cc->friendly_name);
+
+    populate_cert(&newcc->cert, newcc->cert.subject);
+    return newcc;
+
+dup_error:
+    if (newcc->pkey) gnutls_x509_privkey_deinit(newcc->pkey);
+    if (newcc->cert.subject) gnutls_x509_crt_deinit(newcc->cert.subject);
+    ne_free(newcc);
+    return NULL;
+}    
+
+/* Callback invoked when the SSL server requests a client certificate.  */
+static int provide_client_cert(gnutls_session_t session,
+                               const gnutls_datum_t *req_ca_rdn, int nreqs,
+                               const gnutls_pk_algorithm_t *sign_algos,
+                               int sign_algos_length, gnutls_retr_st *st)
+{
+    ne_session *sess = gnutls_session_get_ptr(session);
+    
+    if (!sess) {
+        return GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Client cert provider callback; %d CA names.\n",
+             nreqs);
+
+    if (!sess->client_cert && sess->ssl_provide_fn) {
+#ifdef HAVE_NEW_DN_API
+        const ne_ssl_dname **dns;
+        ne_ssl_dname *dnarray;
+        unsigned dncount = 0;
+        int n;
+
+        dns = ne_malloc(nreqs * sizeof(ne_ssl_dname *));
+        dnarray = ne_calloc(nreqs * sizeof(ne_ssl_dname));
+
+        for (n = 0; n < nreqs; n++) {
+            gnutls_x509_dn_t dn;
+
+            if (gnutls_x509_dn_init(&dn) == 0) {
+                dnarray[n].dn = dn;
+                if (gnutls_x509_dn_import(dn, &req_ca_rdn[n]) == 0) {
+                    dns[dncount++] = &dnarray[n];
+                }
+                else {
+                    gnutls_x509_dn_deinit(dn);
+                }            
+            }
+        }
+       
+        NE_DEBUG(NE_DBG_SSL, "ssl: Mapped %d CA names to %u DN objects.\n",
+                 nreqs, dncount);
+
+        sess->ssl_provide_fn(sess->ssl_provide_ud, sess, dns, dncount);
+        
+        for (n = 0; n < nreqs; n++) {
+            if (dnarray[n].dn) {
+                gnutls_x509_dn_deinit(dnarray[n].dn);
+            }
+        }
+
+        ne_free(dns);
+        ne_free(dnarray);
+#else /* HAVE_NEW_DN_API */
+        /* Nothing to do here other than pretend no CA names were
+         * given, and hope the caller can cope. */
+        sess->ssl_provide_fn(sess->ssl_provide_ud, sess, NULL, 0);
+#endif
+    }
+
+    if (sess->client_cert) {
+        gnutls_certificate_type_t type = gnutls_certificate_type_get(session);
+        if (type == GNUTLS_CRT_X509
+#if LIBGNUTLS_VERSION_NUMBER > 0x030000
+            /* Ugly hack; prevent segfaults w/GnuTLS 3.0. */
+            && sess->client_cert->pkey != NULL
+#endif
+            ) {
+            NE_DEBUG(NE_DBG_SSL, "Supplying client certificate.\n");
+
+            st->type = type;
+            st->ncerts = 1;
+            st->cert.x509 = &sess->client_cert->cert.subject;
+            st->key.x509 = sess->client_cert->pkey;
+            
+            /* tell GNU TLS not to deallocate the certs. */
+            st->deinit_all = 0;
+        } else {
+            return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;
+        }
+    } 
+    else {
+        NE_DEBUG(NE_DBG_SSL, "No client certificate supplied.\n");
+        st->ncerts = 0;
+        sess->ssl_cc_requested = 1;
+        return 0;
+    }
+
+    return 0;
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc)
+{
+    sess->client_cert = dup_client_cert(cc);
+}
+
+ne_ssl_context *ne_ssl_context_create(int flags)
+{
+    ne_ssl_context *ctx = ne_calloc(sizeof *ctx);
+    gnutls_certificate_allocate_credentials(&ctx->cred);
+    if (flags == NE_SSL_CTX_CLIENT) {
+        gnutls_certificate_client_set_retrieve_function(ctx->cred,
+                                                        provide_client_cert);
+    }
+    gnutls_certificate_set_verify_flags(ctx->cred, 
+                                        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
+    return ctx;
+}
+
+int ne_ssl_context_keypair(ne_ssl_context *ctx, 
+                           const char *cert, const char *key)
+{
+    gnutls_certificate_set_x509_key_file(ctx->cred, cert, key,
+                                         GNUTLS_X509_FMT_PEM);
+    return 0;
+}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, int required,
+                              const char *ca_names, const char *verify_cas)
+{
+    ctx->verify = required;
+    if (verify_cas) {
+        gnutls_certificate_set_x509_trust_file(ctx->cred, verify_cas,
+                                               GNUTLS_X509_FMT_PEM);
+    }
+    /* gnutls_certificate_send_x509_rdn_sequence in gnutls >= 1.2 can
+     * be used to *suppress* sending the CA names, but not control it,
+     * it seems. */
+    return 0;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value)
+{
+    /* SSLv2 not supported. */
+}
+
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag)
+{
+    return 0;
+}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx)
+{
+    gnutls_certificate_free_credentials(ctx->cred);
+    if (ctx->cache.client.data) {
+        ne_free(ctx->cache.client.data);
+    } else if (ctx->cache.server.key.data) {
+        gnutls_free(ctx->cache.server.key.data);
+        gnutls_free(ctx->cache.server.data.data);
+    }    
+    ne_free(ctx);
+}
+
+#if !defined(HAVE_GNUTLS_CERTIFICATE_GET_ISSUER) && defined(HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS)
+/* Return the issuer of the given certificate, or NULL if none can be
+ * found. */
+static gnutls_x509_crt_t find_issuer(gnutls_x509_crt_t *ca_list,
+                                   unsigned int num_cas,
+                                   gnutls_x509_crt_t cert)
+{
+    unsigned int n;
+
+    for (n = 0; n < num_cas; n++) {
+        if (gnutls_x509_crt_check_issuer(cert, ca_list[n]) == 1)
+            return ca_list[n];
+    }
+
+    return NULL;
+}
+#endif
+
+/* Return the certificate chain sent by the peer, or NULL on error. */
+static ne_ssl_certificate *make_peers_chain(gnutls_session_t sock,
+                                            gnutls_certificate_credentials_t crd)
+{
+    ne_ssl_certificate *current = NULL, *top = NULL;
+    const gnutls_datum_t *certs;
+    unsigned int n, count;
+    ne_ssl_certificate *cert;
+
+    certs = gnutls_certificate_get_peers(sock, &count);
+    if (!certs) {
+        return NULL;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Got %u certs in peer chain.\n", count);
+    
+    for (n = 0; n < count; n++) {
+        gnutls_x509_crt_t x5;
+
+        if (gnutls_x509_crt_init(&x5) ||
+            gnutls_x509_crt_import(x5, &certs[n], GNUTLS_X509_FMT_DER)) {
+            if (top) {
+                ne_ssl_cert_free(top);
+            }
+            return NULL;
+        }
+
+        cert = populate_cert(ne_calloc(sizeof *cert), x5);
+        
+        if (top == NULL) {
+            current = top = cert;
+        } else {
+            current->issuer = cert;
+            current = cert;
+        }
+    }
+
+#if defined(HAVE_GNUTLS_CERTIFICATE_GET_ISSUER) || defined(HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS)
+    /* GnuTLS only returns the peers which were *sent* by the server
+     * in the Certificate list during the handshake.  Fill in the
+     * complete chain manually against the certs we trust: */
+    if (current->issuer == NULL) {
+        gnutls_x509_crt_t issuer;
+
+#ifndef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+        gnutls_x509_crt_t *ca_list;
+        unsigned int num_cas;
+        
+        gnutls_certificate_get_x509_cas(crd, &ca_list, &num_cas);
+#endif
+
+        do { 
+            /* Look up the issuer. */
+#ifndef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+            issuer = find_issuer(ca_list, num_cas, current->subject);
+#else
+            if (gnutls_certificate_get_issuer(crd, current->subject, &issuer, 0))
+                issuer = NULL;
+#endif
+
+            if (issuer) {
+                issuer = x509_crt_copy(issuer);
+                if (issuer == NULL)
+                    break;
+
+                cert = populate_cert(ne_calloc(sizeof *cert), issuer);
+                /* Check that the issuer does not match the current
+                 * cert. */
+                if (ne_ssl_cert_cmp(current, cert)) {
+                    current = current->issuer = cert;
+                }
+                else {
+                    ne_ssl_cert_free(cert);
+                    issuer = NULL;
+                }
+            }
+        } while (issuer);
+    }
+#endif
+    
+    return top;
+}
+
+/* Map from GnuTLS verify failure mask *status to NE_SSL_* failure
+ * bitmask, which is returned.  *status is modified, removing all
+ * mapped bits. */
+static int map_verify_failures(unsigned int *status)
+{
+    static const struct {
+        gnutls_certificate_status_t from;
+        int to;
+    } map[] = {
+        { GNUTLS_CERT_REVOKED, NE_SSL_REVOKED },
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020800
+        { GNUTLS_CERT_NOT_ACTIVATED, NE_SSL_NOTYETVALID },
+        { GNUTLS_CERT_EXPIRED, NE_SSL_EXPIRED },
+#endif
+        { GNUTLS_CERT_INVALID|GNUTLS_CERT_SIGNER_NOT_FOUND, NE_SSL_UNTRUSTED },
+        { GNUTLS_CERT_INVALID|GNUTLS_CERT_SIGNER_NOT_CA, NE_SSL_UNTRUSTED }
+    };
+    size_t n;
+    int ret = 0;
+
+    for (n = 0; n < sizeof(map)/sizeof(map[0]); n++) {
+        if ((*status & map[n].from) == map[n].from) {
+            *status &= ~map[n].from;
+            ret |= map[n].to;
+        }
+    }
+
+    return ret;
+}
+
+/* Return a malloc-allocated human-readable error string describing
+ * GnuTLS verification error bitmask 'status'; return value must be
+ * freed by the caller. */
+static char *verify_error_string(unsigned int status)
+{
+    ne_buffer *buf = ne_buffer_create();
+
+    /* sorry, i18n-ers */
+    if (status & GNUTLS_CERT_INSECURE_ALGORITHM) {
+        ne_buffer_zappend(buf, _("signed using insecure algorithm"));
+    }
+    else {
+        ne_buffer_snprintf(buf, 64, _("unrecognized errors (%u)"),
+                           status);
+    }
+    
+    return ne_buffer_finish(buf);
+}
+
+/* Return NE_SSL_* failure bits after checking chain expiry. */
+static int check_chain_expiry(ne_ssl_certificate *chain)
+{
+    time_t before, after, now = time(NULL);
+    ne_ssl_certificate *cert;
+    int failures = 0;
+    
+    /* Check that all certs within the chain are inside their defined
+     * validity period.  Note that the errors flagged for the server
+     * cert are different from the generic error for issues higher up
+     * the chain. */
+    for (cert = chain; cert; cert = cert->issuer) {
+        before = gnutls_x509_crt_get_activation_time(cert->subject);
+        after = gnutls_x509_crt_get_expiration_time(cert->subject);
+        
+        if (now < before)
+            failures |= (cert == chain) ? NE_SSL_NOTYETVALID : NE_SSL_BADCHAIN;
+        else if (now > after)
+            failures |= (cert == chain) ? NE_SSL_EXPIRED : NE_SSL_BADCHAIN;
+    }
+
+    return failures;
+}
+
+/* Verifies an SSL server certificate. */
+static int check_certificate(ne_session *sess, gnutls_session_t sock,
+                             ne_ssl_certificate *chain)
+{
+    int ret, failures = 0;
+    ne_uri server;
+    unsigned int status;
+
+    memset(&server, 0, sizeof server);
+    ne_fill_server_uri(sess, &server);
+    ret = check_identity(&server, chain->subject, NULL);
+    ne_uri_free(&server);
+
+    if (ret < 0) {
+        ne_set_error(sess, _("Server certificate was missing commonName "
+                             "attribute in subject name"));
+        return NE_ERROR;
+    } 
+    else if (ret > 0) {
+        failures |= NE_SSL_IDMISMATCH;
+    }
+    
+    failures |= check_chain_expiry(chain);
+
+    ret = gnutls_certificate_verify_peers2(sock, &status);
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify peers returned %d, status=%u\n", 
+             ret, status);
+    if (ret != GNUTLS_E_SUCCESS) {
+        ne_set_error(sess, _("Could not verify server certificate: %s"),
+                     gnutls_strerror(ret));
+        return NE_ERROR;
+    }
+
+    failures |= map_verify_failures(&status);
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verification failures = %d (status = %u).\n", 
+             failures, status);
+    
+    if (status && status != GNUTLS_CERT_INVALID) {
+        char *errstr = verify_error_string(status);
+        ne_set_error(sess, _("Certificate verification error: %s"), errstr);
+        ne_free(errstr);       
+        return NE_ERROR;
+    }
+
+    if (failures == 0) {
+        ret = NE_OK;
+    } else {
+        ne__ssl_set_verify_err(sess, failures);
+        ret = NE_ERROR;
+        if (sess->ssl_verify_fn
+            && sess->ssl_verify_fn(sess->ssl_verify_ud, failures, chain) == 0)
+            ret = NE_OK;
+    }
+
+    return ret;
+}
+
+/* Negotiate an SSL connection. */
+int ne__negotiate_ssl(ne_session *sess)
+{
+    ne_ssl_context *const ctx = sess->ssl_context;
+    ne_ssl_certificate *chain;
+    gnutls_session_t sock;
+
+    NE_DEBUG(NE_DBG_SSL, "Negotiating SSL connection.\n");
+
+    /* Pass through the hostname if SNI is enabled. */
+    ctx->hostname = 
+        sess->flags[NE_SESSFLAG_TLS_SNI] ? sess->server.hostname : NULL;
+
+    if (ne_sock_connect_ssl(sess->socket, ctx, sess)) {
+        if (sess->ssl_cc_requested) {
+            ne_set_error(sess, _("SSL handshake failed, "
+                                 "client certificate was requested: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        else {
+            ne_set_error(sess, _("SSL handshake failed: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        return NE_ERROR;
+    }
+
+    sock = ne__sock_sslsock(sess->socket);
+
+    chain = make_peers_chain(sock, ctx->cred);
+    if (chain == NULL) {
+        ne_set_error(sess, _("Server did not send certificate chain"));
+        return NE_ERROR;
+    }
+
+    if (sess->server_cert && ne_ssl_cert_cmp(sess->server_cert, chain) == 0) {
+        /* Same cert as last time; presume OK.  This is not optimal as
+         * make_peers_chain() has already gone through and done the
+         * expensive DER parsing stuff for the whole chain by now. */
+        ne_ssl_cert_free(chain);
+        return NE_OK;
+    }
+
+    if (check_certificate(sess, sock, chain)) {
+        ne_ssl_cert_free(chain);
+        return NE_ERROR;
+    }
+
+    sess->server_cert = chain;
+
+    return NE_OK;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return &cert->issuer_dn;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return &cert->subj_dn;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{
+    return cert->issuer;
+}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return cert->identity;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{
+    gnutls_x509_crt_t certs = cert->subject;
+    gnutls_certificate_set_x509_trust(ctx->cred, &certs, 1);
+}
+
+void ne_ssl_trust_default_ca(ne_session *sess)
+{
+#ifdef NE_SSL_CA_BUNDLE
+    gnutls_certificate_set_x509_trust_file(sess->ssl_context->cred,
+                                           NE_SSL_CA_BUNDLE,
+                                           GNUTLS_X509_FMT_PEM);
+#endif
+}
+
+/* Read the contents of file FILENAME into *DATUM. */
+static int read_to_datum(const char *filename, gnutls_datum_t *datum)
+{
+    FILE *f = fopen(filename, "r");
+    ne_buffer *buf;
+    char tmp[4192];
+    size_t len;
+
+    if (!f) {
+        return -1;
+    }
+
+    buf = ne_buffer_ncreate(8192);
+    while ((len = fread(tmp, 1, sizeof tmp, f)) > 0) {
+        ne_buffer_append(buf, tmp, len);
+    }
+
+    if (!feof(f)) {
+        fclose(f);
+        ne_buffer_destroy(buf);
+        return -1;
+    }
+    
+    fclose(f);
+
+    datum->size = ne_buffer_size(buf);
+    datum->data = (unsigned char *)ne_buffer_finish(buf);
+    return 0;
+}
+
+/* Parses a PKCS#12 structure and loads the certificate, private key
+ * and friendly name if possible.  Returns zero on success, non-zero
+ * on error. */
+static int pkcs12_parse(gnutls_pkcs12_t p12, gnutls_x509_privkey_t *pkey,
+                        gnutls_x509_crt_t *x5, char **friendly_name,
+                        const char *password)
+{
+    gnutls_pkcs12_bag_t bag = NULL;
+    int i, j, ret = 0;
+
+    for (i = 0; ret == 0; ++i) {
+        if (bag) gnutls_pkcs12_bag_deinit(bag);
+
+        ret = gnutls_pkcs12_bag_init(&bag);
+        if (ret < 0) continue;
+
+        ret = gnutls_pkcs12_get_bag(p12, i, bag);
+        if (ret < 0) continue;
+
+        gnutls_pkcs12_bag_decrypt(bag, password);
+
+        for (j = 0; ret == 0 && j < gnutls_pkcs12_bag_get_count(bag); ++j) {
+            gnutls_pkcs12_bag_type_t type;
+            gnutls_datum_t data;
+
+            if (friendly_name && *friendly_name == NULL) {
+                char *name = NULL;
+                gnutls_pkcs12_bag_get_friendly_name(bag, j, &name);
+                if (name) {
+                    if (name[0] == '.') name++; /* weird GnuTLS bug? */
+                    *friendly_name = ne_strdup(name);
+                }
+            }
+
+            type = gnutls_pkcs12_bag_get_type(bag, j);
+            switch (type) {
+            case GNUTLS_BAG_PKCS8_KEY:
+            case GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:
+                /* Ignore any but the first key encountered; really
+                 * need to match up keyids. */
+                if (*pkey) break;
+
+                gnutls_x509_privkey_init(pkey);
+
+                ret = gnutls_pkcs12_bag_get_data(bag, j, &data);
+                if (ret < 0) continue;
+
+                ret = gnutls_x509_privkey_import_pkcs8(*pkey, &data,
+                                                       GNUTLS_X509_FMT_DER,
+                                                       password,
+                                                       0);
+                if (ret < 0) continue;
+                break;
+            case GNUTLS_BAG_CERTIFICATE:
+                /* Ignore any but the first cert encountered; again,
+                 * really need to match up keyids. */
+                if (*x5) break;
+
+                ret = gnutls_x509_crt_init(x5);
+                if (ret < 0) continue;
+
+                ret = gnutls_pkcs12_bag_get_data(bag, j, &data);
+                if (ret < 0) continue;
+
+                ret = gnutls_x509_crt_import(*x5, &data, GNUTLS_X509_FMT_DER);
+                if (ret < 0) continue;
+
+                break;
+            default:
+                break;
+            }
+        }
+    }
+
+    /* Make sure last bag is freed */
+    if (bag) gnutls_pkcs12_bag_deinit(bag);
+
+    /* Free in case of error */
+    if (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {
+        if (*x5) gnutls_x509_crt_deinit(*x5);
+        if (*pkey) gnutls_x509_privkey_deinit(*pkey);
+        if (friendly_name && *friendly_name) ne_free(*friendly_name);
+    }
+
+    if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) ret = 0;
+    return ret;
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    gnutls_datum_t datum;
+    ne_ssl_client_cert *cc;
+
+    if (read_to_datum(filename, &datum))
+        return NULL;
+
+    cc = ne_ssl_clicert_import(datum.data, datum.size);
+
+    ne_free(datum.data);
+
+    return cc;
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, size_t buflen)
+{
+    int ret;
+    gnutls_datum_t data;
+    gnutls_pkcs12_t p12;
+    ne_ssl_client_cert *cc;
+    char *friendly_name = NULL;
+    gnutls_x509_crt_t cert = NULL;
+    gnutls_x509_privkey_t pkey = NULL;
+
+    data.data = buffer;
+    data.size = buflen;
+
+    if (gnutls_pkcs12_init(&p12) != 0) {
+        return NULL;
+    }
+
+    ret = gnutls_pkcs12_import(p12, &data, GNUTLS_X509_FMT_DER, 0);
+    if (ret < 0) {
+        gnutls_pkcs12_deinit(p12);
+        return NULL;
+    }
+
+    if (gnutls_pkcs12_verify_mac(p12, "") == 0) {
+        if (pkcs12_parse(p12, &pkey, &cert, &friendly_name, "") != 0
+            || !cert || !pkey) {
+            gnutls_pkcs12_deinit(p12);
+            return NULL;
+        }
+
+        cc = ne_calloc(sizeof *cc);
+        cc->pkey = pkey;
+        cc->decrypted = 1;
+        cc->friendly_name = friendly_name;
+        populate_cert(&cc->cert, cert);
+        gnutls_pkcs12_deinit(p12);
+        cc->p12 = NULL;
+        return cc;
+    } else {
+        /* TODO: calling pkcs12_parse() here to find the friendly_name
+         * seems to break horribly.  */
+        cc = ne_calloc(sizeof *cc);
+        cc->p12 = p12;
+        return cc;
+    }
+}
+
+ne_ssl_client_cert *ne__ssl_clicert_exkey_import(const unsigned char *der,
+                                                 size_t der_len)
+{
+    ne_ssl_client_cert *cc;
+    gnutls_x509_crt_t x5;
+    gnutls_datum_t datum;
+
+    datum.data = (unsigned char *)der;
+    datum.size = der_len;    
+
+    if (gnutls_x509_crt_init(&x5) 
+        || gnutls_x509_crt_import(x5, &datum, GNUTLS_X509_FMT_DER)) {
+        NE_DEBUG(NE_DBG_SSL, "ssl: crt_import failed.\n");
+        return NULL;
+    }
+    
+    cc = ne_calloc(sizeof *cc);
+    cc->keyless = 1;
+    cc->decrypted = 1;
+    populate_cert(&cc->cert, x5);
+
+    return cc;    
+}
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *cc)
+{
+    return !cc->decrypted;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *cc, const char *password)
+{
+    int ret;
+    gnutls_x509_crt_t cert = NULL;
+    gnutls_x509_privkey_t pkey = NULL;
+
+    if (gnutls_pkcs12_verify_mac(cc->p12, password) != 0) {
+        return -1;
+    }        
+
+    ret = pkcs12_parse(cc->p12, &pkey, &cert, NULL, password);
+    if (ret < 0)
+        return ret;
+    
+    if (!cert || (!pkey && !cc->keyless)) {
+        if (cert) gnutls_x509_crt_deinit(cert);
+        if (pkey) gnutls_x509_privkey_deinit(pkey);
+        return -1;
+    }
+
+    gnutls_pkcs12_deinit(cc->p12);
+    populate_cert(&cc->cert, cert);
+    cc->pkey = pkey;
+    cc->decrypted = 1;
+    cc->p12 = NULL;
+    return 0;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *cc)
+{
+    return &cc->cert;
+}
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return ccert->friendly_name;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    int ret;
+    gnutls_datum_t data;
+    gnutls_x509_crt_t x5;
+
+    if (read_to_datum(filename, &data))
+        return NULL;
+
+    if (gnutls_x509_crt_init(&x5) != 0)
+        return NULL;
+
+    ret = gnutls_x509_crt_import(x5, &data, GNUTLS_X509_FMT_PEM);
+    ne_free(data.data);
+    if (ret < 0) {
+        gnutls_x509_crt_deinit(x5);
+        return NULL;
+    }
+    
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    unsigned char buffer[10*1024];
+    size_t len = sizeof buffer;
+
+    FILE *fp = fopen(filename, "w");
+
+    if (fp == NULL) return -1;
+
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_PEM, buffer,
+                               &len) < 0) {
+        fclose(fp);
+        return -1;
+    }
+
+    if (fwrite(buffer, len, 1, fp) != 1) {
+        fclose(fp);
+        return -1;
+    }
+
+    if (fclose(fp) != 0)
+        return -1;
+
+    return 0;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert)
+{
+    gnutls_x509_crt_deinit(cert->subject);
+    if (cert->identity) ne_free(cert->identity);
+    if (cert->issuer) ne_ssl_cert_free(cert->issuer);
+    ne_free(cert);
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    char digest1[NE_SSL_DIGESTLEN], digest2[NE_SSL_DIGESTLEN];
+
+    if (ne_ssl_cert_digest(c1, digest1) || ne_ssl_cert_digest(c2, digest2)) {
+        return -1;
+    }
+
+    return strcmp(digest1, digest2);
+}
+
+/* The certificate import/export format is the base64 encoding of the
+ * raw DER; PEM without the newlines and wrapping. */
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    int ret;
+    size_t len;
+    unsigned char *der;
+    gnutls_datum_t buffer = { NULL, 0 };
+    gnutls_x509_crt_t x5;
+
+    if (gnutls_x509_crt_init(&x5) != 0)
+        return NULL;
+
+    /* decode the base64 to get the raw DER representation */
+    len = ne_unbase64(data, &der);
+    if (len == 0) return NULL;
+
+    buffer.data = der;
+    buffer.size = len;
+
+    ret = gnutls_x509_crt_import(x5, &buffer, GNUTLS_X509_FMT_DER);
+    ne_free(der);
+
+    if (ret < 0) {
+        gnutls_x509_crt_deinit(x5);
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    unsigned char *der;
+    size_t len = 0;
+    char *ret;
+
+    /* find the length of the DER encoding. */
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_DER, NULL, &len) != 
+        GNUTLS_E_SHORT_MEMORY_BUFFER) {
+        return NULL;
+    }
+    
+    der = ne_malloc(len);
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_DER, der, &len)) {
+        ne_free(der);
+        return NULL;
+    }
+    
+    ret = ne_base64(der, len);
+    ne_free(der);
+    return ret;
+}
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest)
+{
+    char sha1[20], *p;
+    int j;
+    size_t len = sizeof sha1;
+
+    if (gnutls_x509_crt_get_fingerprint(cert->subject, GNUTLS_DIG_SHA,
+                                        sha1, &len) < 0)
+        return -1;
+
+    for (j = 0, p = digest; j < 20; j++) {
+        *p++ = NE_HEX2ASC((sha1[j] >> 4) & 0x0f);
+        *p++ = NE_HEX2ASC(sha1[j] & 0x0f);
+        *p++ = ':';
+    }
+
+    *--p = '\0';
+    return 0;
+}
+
+int ne__ssl_init(void)
+{
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#ifdef NE_HAVE_TS_SSL
+    gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+#endif
+    gcry_control(GCRYCTL_ENABLE_QUICK_RANDOM, 0);
+#endif
+    return gnutls_global_init();
+}
+
+void ne__ssl_exit(void)
+{
+    /* No way to unregister the thread callbacks.  Doomed. */
+#if LIBGNUTLS_VERSION_MAJOR > 1 || LIBGNUTLS_VERSION_MINOR > 3 \
+    || (LIBGNUTLS_VERSION_MINOR == 3 && LIBGNUTLS_VERSION_PATCH >= 3)
+    /* It's safe to call gnutls_global_deinit() here only with
+     * gnutls >= 1.3., since older versions don't refcount and
+     * doing so would prevent any other use of gnutls within
+     * the process. */
+    gnutls_global_deinit();
+#endif
+}
diff --git a/net/mmt/neon/src/ne_i18n.c b/net/mmt/neon/src/ne_i18n.c
new file mode 100644
index 0000000..0fb4a3b
--- /dev/null
+++ b/net/mmt/neon/src/ne_i18n.c
@@ -0,0 +1,47 @@
+/* 
+   Internationalization of neon
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include "ne_i18n.h"
+
+#ifdef HAVE_LIBINTL_H
+#include <libintl.h>
+#endif
+
+void ne_i18n_init(const char *encoding)
+{
+#if defined(NE_HAVE_I18N) && defined(NEON_IS_LIBRARY)
+    /* The bindtextdomain call is only enabled if neon is built as a
+     * library rather than as a bundled source; it would be possible
+     * in the future to allow it for bundled builds too, if the neon
+     * message catalogs could be installed alongside the app's own
+     * message catalogs. */
+    bindtextdomain("neon", LOCALEDIR);
+
+#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
+    if (encoding) {
+        bind_textdomain_codeset("neon", encoding);
+    }
+#endif /* HAVE_BIND_TEXTDOMAIN_CODESET */
+
+#endif
+}
diff --git a/net/mmt/neon/src/ne_i18n.h b/net/mmt/neon/src/ne_i18n.h
new file mode 100644
index 0000000..b6dd219
--- /dev/null
+++ b/net/mmt/neon/src/ne_i18n.h
@@ -0,0 +1,55 @@
+/* 
+   Internationalization of neon
+   Copyright (C) 2005-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_I18N_H
+#define NE_I18N_H
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Initialize translated error messages within neon.  If 'encoding' is
+ * non-NULL, it specifies the character encoding for the generated
+ * translated strings.  If it is NULL, the appropriate character
+ * encoding for the locale will be used.
+ *
+ * This call is only strictly necessary if either:
+ *
+ * a) neon has been installed into a different prefix than the
+ * gettext() implementation on which it depends for i18n purposes, or
+ *
+ * b) the caller requires that translated messages are in a particular
+ * character encoding.
+ *
+ * If ne_i18n_init() is never called, the message catalogs will not be
+ * found if case (a) applies (and so English error messages will be
+ * used), and will use the default character encoding specified by the
+ * process locale.  The library will otherwise operate correctly.
+ *
+ * Note that the encoding used is a process-global setting and so
+ * results may be unexpected if other users of neon within the process
+ * call ne_i18n_init() with a different encoding parameter.
+ */
+void ne_i18n_init(const char *encoding);
+
+NE_END_DECLS
+
+#endif /* NE_I18N_H */
diff --git a/net/mmt/neon/src/ne_internal.h b/net/mmt/neon/src/ne_internal.h
new file mode 100644
index 0000000..c9c6eff
--- /dev/null
+++ b/net/mmt/neon/src/ne_internal.h
@@ -0,0 +1,86 @@
+/* 
+   Global interfaces private to neon.
+   Copyright (C) 2005-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* NOTE WELL: The interfaces defined in this file are internal to neon
+ * and MUST NOT be used by neon-based applications. */
+
+#ifndef NE_INTERNAL_H
+#define NE_INTERNAL_H 1
+
+#include "config.h"
+
+#ifdef HAVE_SYS_LIMITS_H
+#include <sys/limits.h>
+#endif
+#ifdef HAVE_LIMITS_H
+#include <limits.h> /* for UINT_MAX etc */
+#endif
+
+#include "ne_defs.h"
+
+#undef _
+#ifdef NE_HAVE_I18N
+#include <libintl.h>
+#define _(str) dgettext(PACKAGE_NAME, str)
+#else
+#define _(str) (str)
+#endif /* NE_ENABLE_NLS */
+#define N_(str) (str)
+
+#if !defined(LONG_LONG_MAX) && defined(LLONG_MAX)
+#define LONG_LONG_MAX LLONG_MAX
+#elif !defined(LONG_LONG_MAX) && defined(LONGLONG_MAX)
+#define LONG_LONG_MAX LONGLONG_MAX
+#endif
+
+#if defined(NE_LFS)
+
+#define ne_lseek lseek64
+#define FMT_NE_OFF_T NE_FMT_OFF64_T
+#define NE_OFFT_MAX LONG_LONG_MAX
+#ifdef HAVE_STRTOLL
+#define ne_strtoff strtoll
+#else
+#define ne_strtoff strtoq
+#endif
+
+#else /* !NE_LFS */
+
+#define ne_lseek lseek
+#define FMT_NE_OFF_T NE_FMT_OFF_T
+
+#if defined(SIZEOF_LONG_LONG) && defined(LONG_LONG_MAX) \
+    && SIZEOF_OFF_T == SIZEOF_LONG_LONG
+#define NE_OFFT_MAX LONG_LONG_MAX
+#else
+#define NE_OFFT_MAX LONG_MAX
+#endif
+
+#if SIZEOF_OFF_T > SIZEOF_LONG && defined(HAVE_STRTOLL)
+#define ne_strtoff strtoll
+#elif SIZEOF_OFF_T > SIZEOF_LONG && defined(HAVE_STRTOQ)
+#define ne_strtoff strtoq
+#else
+#define ne_strtoff strtol
+#endif
+#endif /* NE_LFS */
+
+#endif /* NE_INTERNAL_H */
diff --git a/net/mmt/neon/src/ne_locks.c b/net/mmt/neon/src/ne_locks.c
new file mode 100644
index 0000000..fbe390c
--- /dev/null
+++ b/net/mmt/neon/src/ne_locks.c
@@ -0,0 +1,816 @@
+/* 
+   WebDAV Class 2 locking operations
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#endif
+
+#include <ctype.h> /* for isdigit() */
+
+#include "ne_alloc.h"
+
+#include "ne_request.h"
+#include "ne_xml.h"
+#include "ne_locks.h"
+#include "ne_uri.h"
+#include "ne_basic.h"
+#include "ne_props.h"
+#include "ne_207.h"
+#include "ne_internal.h"
+#include "ne_xmlreq.h"
+
+#define HOOK_ID "http://webdav.org/neon/hooks/webdav-locking"
+
+/* A list of lock objects. */
+struct lock_list {
+    struct ne_lock *lock;
+    struct lock_list *next, *prev;
+};
+
+struct ne_lock_store_s {
+    struct lock_list *locks;
+    struct lock_list *cursor; /* current position in 'locks' */
+};
+
+struct lh_req_cookie {
+    const ne_lock_store *store;
+    struct lock_list *submit;
+};
+
+/* Context for PROPFIND/lockdiscovery callbacks */
+struct discover_ctx {
+    ne_propfind_handler *phandler;
+    ne_lock_result results;
+    void *userdata;
+    ne_buffer *cdata;
+};
+
+/* Context for handling LOCK response */
+struct lock_ctx {
+    struct ne_lock active; /* activelock */
+    ne_request *req; /* the request in question */
+    ne_xml_parser *parser;
+    char *token; /* the token we're after. */
+    int found;
+    ne_buffer *cdata;
+};
+
+/* use the "application" state space. */
+#define ELM_LOCK_FIRST (NE_PROPS_STATE_TOP + 66)
+
+#define ELM_lockdiscovery (ELM_LOCK_FIRST)
+#define ELM_activelock (ELM_LOCK_FIRST + 1)
+#define ELM_lockscope (ELM_LOCK_FIRST + 2)
+#define ELM_locktype (ELM_LOCK_FIRST + 3)
+#define ELM_depth (ELM_LOCK_FIRST + 4)
+#define ELM_owner (ELM_LOCK_FIRST + 5)
+#define ELM_timeout (ELM_LOCK_FIRST + 6)
+#define ELM_locktoken (ELM_LOCK_FIRST + 7)
+#define ELM_lockinfo (ELM_LOCK_FIRST + 8)
+#define ELM_write (ELM_LOCK_FIRST + 9)
+#define ELM_exclusive (ELM_LOCK_FIRST + 10)
+#define ELM_shared (ELM_LOCK_FIRST + 11)
+#define ELM_href (ELM_LOCK_FIRST + 12)
+#define ELM_prop (NE_207_STATE_PROP)
+
+static const struct ne_xml_idmap element_map[] = {
+#define ELM(x) { "DAV:", #x, ELM_ ## x }
+    ELM(lockdiscovery), ELM(activelock), ELM(prop), ELM(lockscope),
+    ELM(locktype), ELM(depth), ELM(owner), ELM(timeout), ELM(locktoken),
+    ELM(lockinfo), ELM(lockscope), ELM(locktype), ELM(write), ELM(exclusive),
+    ELM(shared), ELM(href)
+    /* no "lockentry" */
+#undef ELM
+};
+
+static const ne_propname lock_props[] = {
+    { "DAV:", "lockdiscovery" },
+    { NULL }
+};
+
+/* this simply registers the accessor for the function. */
+static void lk_create(ne_request *req, void *session, 
+		       const char *method, const char *uri)
+{
+    struct lh_req_cookie *lrc = ne_malloc(sizeof *lrc);
+    lrc->store = session;
+    lrc->submit = NULL;
+    ne_set_request_private(req, HOOK_ID, lrc);
+}
+
+static void lk_pre_send(ne_request *r, void *userdata, ne_buffer *req)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(r, HOOK_ID);
+
+    if (lrc->submit != NULL) {
+	struct lock_list *item;
+
+	/* Add in the If header */
+	ne_buffer_czappend(req, "If:");
+	for (item = lrc->submit; item != NULL; item = item->next) {
+	    char *uri = ne_uri_unparse(&item->lock->uri);
+	    ne_buffer_concat(req, " <", uri, "> (<",
+			     item->lock->token, ">)", NULL);
+	    ne_free(uri);
+	}
+	ne_buffer_czappend(req, "\r\n");
+    }
+}
+
+/* Insert 'lock' into lock list *list. */
+static void insert_lock(struct lock_list **list, struct ne_lock *lock)
+{
+    struct lock_list *item = ne_malloc(sizeof *item);
+    if (*list != NULL) {
+	(*list)->prev = item;
+    }
+    item->prev = NULL;
+    item->next = *list;
+    item->lock = lock;
+    *list = item;
+}
+
+static void free_list(struct lock_list *list, int destroy)
+{
+    struct lock_list *next;
+
+    while (list != NULL) {
+	next = list->next;
+	if (destroy)
+	    ne_lock_destroy(list->lock);
+	ne_free(list);
+	list = next;
+    }
+}
+
+static void lk_destroy(ne_request *req, void *userdata)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    free_list(lrc->submit, 0);
+    ne_free(lrc);
+}
+
+void ne_lockstore_destroy(ne_lock_store *store)
+{
+    free_list(store->locks, 1);
+    ne_free(store);
+}
+
+ne_lock_store *ne_lockstore_create(void)
+{
+    return ne_calloc(sizeof(ne_lock_store));
+}
+
+#define CURSOR_RET(s) ((s)->cursor?(s)->cursor->lock:NULL)
+
+struct ne_lock *ne_lockstore_first(ne_lock_store *store)
+{
+    store->cursor = store->locks;
+    return CURSOR_RET(store);
+}
+
+struct ne_lock *ne_lockstore_next(ne_lock_store *store)
+{
+    store->cursor = store->cursor->next;
+    return CURSOR_RET(store);
+}
+
+void ne_lockstore_register(ne_lock_store *store, ne_session *sess)
+{
+    /* Register the hooks */
+    ne_hook_create_request(sess, lk_create, store);
+    ne_hook_pre_send(sess, lk_pre_send, store);
+    ne_hook_destroy_request(sess, lk_destroy, store);
+}
+
+/* Submit the given lock for the given URI */
+static void submit_lock(struct lh_req_cookie *lrc, struct ne_lock *lock)
+{
+    struct lock_list *item;
+
+    /* Check for dups */
+    for (item = lrc->submit; item != NULL; item = item->next) {
+	if (ne_strcasecmp(item->lock->token, lock->token) == 0)
+	    return;
+    }
+
+    insert_lock(&lrc->submit, lock);
+}
+
+struct ne_lock *ne_lockstore_findbyuri(ne_lock_store *store,
+				       const ne_uri *uri)
+{
+    struct lock_list *cur;
+
+    for (cur = store->locks; cur != NULL; cur = cur->next) {
+	if (ne_uri_cmp(&cur->lock->uri, uri) == 0) {
+	    return cur->lock;
+	}
+    }
+
+    return NULL;
+}
+
+void ne_lock_using_parent(ne_request *req, const char *path)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    ne_uri u = {0};
+    struct lock_list *item;
+    char *parent;
+
+    if (lrc == NULL)
+	return;
+    
+    parent = ne_path_parent(path);
+    if (parent == NULL)
+	return;
+    
+    ne_fill_server_uri(ne_get_session(req), &u);
+
+    for (item = lrc->store->locks; item != NULL; item = item->next) {
+
+	/* Only care about locks which are on this server. */
+	u.path = item->lock->uri.path;
+	if (ne_uri_cmp(&u, &item->lock->uri))
+	    continue;
+	
+	/* This lock is needed if it is an infinite depth lock which
+	 * covers the parent, or a lock on the parent itself. */
+	if ((item->lock->depth == NE_DEPTH_INFINITE && 
+	     ne_path_childof(item->lock->uri.path, parent)) ||
+	    ne_path_compare(item->lock->uri.path, parent) == 0) {
+	    NE_DEBUG(NE_DBG_LOCKS, "Locked parent, %s on %s\n",
+		     item->lock->token, item->lock->uri.path);
+	    submit_lock(lrc, item->lock);
+	}
+    }
+
+    u.path = parent; /* handy: makes u.path valid and ne_free(parent). */
+    ne_uri_free(&u);
+}
+
+void ne_lock_using_resource(ne_request *req, const char *uri, int depth)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    struct lock_list *item;
+    int match;
+
+    if (lrc == NULL)
+	return;	
+
+    /* Iterate over the list of stored locks to see if any of them
+     * apply to this resource */
+    for (item = lrc->store->locks; item != NULL; item = item->next) {
+	
+	match = 0;
+	
+	if (depth == NE_DEPTH_INFINITE &&
+	    ne_path_childof(uri, item->lock->uri.path)) {
+	    /* Case 1: this is a depth-infinity request which will 
+	     * modify a lock somewhere inside the collection. */
+	    NE_DEBUG(NE_DBG_LOCKS, "Has child: %s\n", item->lock->token);
+	    match = 1;
+	} 
+	else if (ne_path_compare(uri, item->lock->uri.path) == 0) {
+	    /* Case 2: this request is directly on a locked resource */
+	    NE_DEBUG(NE_DBG_LOCKS, "Has direct lock: %s\n", item->lock->token);
+	    match = 1;
+	}
+	else if (item->lock->depth == NE_DEPTH_INFINITE && 
+		 ne_path_childof(item->lock->uri.path, uri)) {
+	    /* Case 3: there is a higher-up infinite-depth lock which
+	     * covers the resource that this request will modify. */
+	    NE_DEBUG(NE_DBG_LOCKS, "Is child of: %s\n", item->lock->token);
+	    match = 1;
+	}
+	
+	if (match) {
+	    submit_lock(lrc, item->lock);
+	}
+    }
+
+}
+
+void ne_lockstore_add(ne_lock_store *store, struct ne_lock *lock)
+{
+    insert_lock(&store->locks, lock);
+}
+
+void ne_lockstore_remove(ne_lock_store *store, struct ne_lock *lock)
+{
+    struct lock_list *item;
+
+    /* Find the lock */
+    for (item = store->locks; item != NULL; item = item->next)
+	if (item->lock == lock)
+	    break;
+    
+    if (item->prev != NULL) {
+	item->prev->next = item->next;
+    } else {
+	store->locks = item->next;
+    }
+    if (item->next != NULL) {
+	item->next->prev = item->prev;
+    }
+    ne_free(item);
+}
+
+struct ne_lock *ne_lock_copy(const struct ne_lock *lock)
+{
+    struct ne_lock *ret = ne_calloc(sizeof *ret);
+
+    ne_uri_copy(&ret->uri, &lock->uri);
+    ret->token = ne_strdup(lock->token);
+    ret->depth = lock->depth;
+    ret->type = lock->type;
+    ret->scope = lock->scope;
+    if (lock->owner) ret->owner = ne_strdup(lock->owner);
+    ret->timeout = lock->timeout;
+
+    return ret;
+}
+
+struct ne_lock *ne_lock_create(void)
+{
+    struct ne_lock *lock = ne_calloc(sizeof *lock);
+    lock->depth = NE_DEPTH_ZERO;
+    lock->type = ne_locktype_write;
+    lock->scope = ne_lockscope_exclusive;
+    lock->timeout = NE_TIMEOUT_INVALID;
+    return lock;
+}
+
+void ne_lock_free(struct ne_lock *lock)
+{
+    ne_uri_free(&lock->uri);
+    if (lock->owner) {
+        ne_free(lock->owner);
+        lock->owner = NULL;
+    }
+    if (lock->token) {
+        ne_free(lock->token);
+        lock->token = NULL;
+    }
+}
+
+void ne_lock_destroy(struct ne_lock *lock)
+{
+    ne_lock_free(lock);
+    ne_free(lock);
+}
+
+int ne_unlock(ne_session *sess, const struct ne_lock *lock)
+{
+    ne_request *req = ne_request_create(sess, "UNLOCK", lock->uri.path);
+    int ret;
+    
+    ne_print_request_header(req, "Lock-Token", "<%s>", lock->token);
+    
+    /* UNLOCK of a lock-null resource removes the resource from the
+     * parent collection; so an UNLOCK may modify the parent
+     * collection. (somewhat counter-intuitive, and not easily derived
+     * from 2518.) */
+    ne_lock_using_parent(req, lock->uri.path);
+
+    ret = ne_request_dispatch(req);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    
+    return ret;
+}
+
+static int parse_depth(const char *depth)
+{
+    if (ne_strcasecmp(depth, "infinity") == 0) {
+	return NE_DEPTH_INFINITE;
+    } else if (isdigit(depth[0])) {
+	return atoi(depth);
+    } else {
+	return -1;
+    }
+}
+
+static long parse_timeout(const char *timeout)
+{
+    if (ne_strcasecmp(timeout, "infinite") == 0) {
+	return NE_TIMEOUT_INFINITE;
+    } else if (strncasecmp(timeout, "Second-", 7) == 0) {
+	long to = strtol(timeout+7, NULL, 10);
+	if (to == LONG_MIN || to == LONG_MAX)
+	    return NE_TIMEOUT_INVALID;
+	return to;
+    } else {
+	return NE_TIMEOUT_INVALID;
+    }
+}
+
+static void discover_results(void *userdata, const ne_uri *uri,
+			     const ne_prop_result_set *set)
+{
+    struct discover_ctx *ctx = userdata;
+    struct ne_lock *lock = ne_propset_private(set);
+    const ne_status *status = ne_propset_status(set, &lock_props[0]);
+
+    /* Require at least that the lock has a token. */
+    if (lock->token) {
+	if (status && status->klass != 2) {
+	    ctx->results(ctx->userdata, NULL, uri, status);
+	} else {
+	    ctx->results(ctx->userdata, lock, uri, NULL);
+	}
+    }
+    else if (status) {
+	ctx->results(ctx->userdata, NULL, uri, status);
+    }
+
+    NE_DEBUG(NE_DBG_LOCKS, "End of response for %s\n", uri->path);
+}
+
+static int 
+end_element_common(struct ne_lock *l, int state, const char *cdata)
+{
+    switch (state) { 
+    case ELM_write:
+	l->type = ne_locktype_write;
+	break;
+    case ELM_exclusive:
+	l->scope = ne_lockscope_exclusive;
+	break;
+    case ELM_shared:
+	l->scope = ne_lockscope_shared;
+	break;
+    case ELM_depth:
+	NE_DEBUG(NE_DBG_LOCKS, "Got depth: %s\n", cdata);
+	l->depth = parse_depth(cdata);
+	if (l->depth == -1) {
+	    return -1;
+	}
+	break;
+    case ELM_timeout:
+	NE_DEBUG(NE_DBG_LOCKS, "Got timeout: %s\n", cdata);
+	l->timeout = parse_timeout(cdata);
+	if (l->timeout == NE_TIMEOUT_INVALID) {
+	    return -1;
+	}
+	break;
+    case ELM_owner:
+	l->owner = strdup(cdata);
+	break;
+    case ELM_href:
+	l->token = strdup(cdata);
+	break;
+    }
+    return 0;
+}
+
+/* End-element handler for lock discovery PROPFIND response */
+static int end_element_ldisc(void *userdata, int state, 
+                             const char *nspace, const char *name)
+{
+    struct discover_ctx *ctx = userdata;
+    struct ne_lock *lock = ne_propfind_current_private(ctx->phandler);
+
+    return end_element_common(lock, state, ctx->cdata->data);
+}
+
+static inline int can_accept(int parent, int id)
+{
+    return (parent == NE_XML_STATEROOT && id == ELM_prop) ||
+        (parent == ELM_prop && id == ELM_lockdiscovery) ||
+        (parent == ELM_lockdiscovery && id == ELM_activelock) ||
+        (parent == ELM_activelock && 
+         (id == ELM_lockscope || id == ELM_locktype ||
+          id == ELM_depth || id == ELM_owner ||
+          id == ELM_timeout || id == ELM_locktoken)) ||
+        (parent == ELM_lockscope &&
+         (id == ELM_exclusive || id == ELM_shared)) ||
+        (parent == ELM_locktype && id == ELM_write) ||
+        (parent == ELM_locktoken && id == ELM_href);
+}
+
+static int ld_startelm(void *userdata, int parent,
+                       const char *nspace, const char *name,
+		       const char **atts)
+{
+    struct discover_ctx *ctx = userdata;
+    int id = ne_xml_mapid(element_map, NE_XML_MAPLEN(element_map),
+                          nspace, name);
+    
+    ne_buffer_clear(ctx->cdata);
+    
+    if (can_accept(parent, id))
+        return id;
+    else
+        return NE_XML_DECLINE;
+}    
+
+#define MAX_CDATA (256)
+
+static int lk_cdata(void *userdata, int state,
+                    const char *cdata, size_t len)
+{
+    struct lock_ctx *ctx = userdata;
+
+    if (ctx->cdata->used + len < MAX_CDATA)
+        ne_buffer_append(ctx->cdata, cdata, len);
+    
+    return 0;
+}
+
+static int ld_cdata(void *userdata, int state,
+                    const char *cdata, size_t len)
+{
+    struct discover_ctx *ctx = userdata;
+
+    if (ctx->cdata->used + len < MAX_CDATA)
+        ne_buffer_append(ctx->cdata, cdata, len);
+    
+    return 0;
+}
+
+static int lk_startelm(void *userdata, int parent,
+                       const char *nspace, const char *name,
+		       const char **atts)
+{
+    struct lock_ctx *ctx = userdata;
+    int id;
+
+    id = ne_xml_mapid(element_map, NE_XML_MAPLEN(element_map), nspace, name);
+
+    NE_DEBUG(NE_DBG_LOCKS, "lk_startelm: %s => %d\n", name, id);
+    
+    if (id == 0)
+        return NE_XML_DECLINE;    
+
+    if (parent == 0 && ctx->token == NULL) {
+        const char *token = ne_get_response_header(ctx->req, "Lock-Token");
+        /* at the root element; retrieve the Lock-Token header,
+         * and bail if it wasn't given. */
+        if (token == NULL) {
+            ne_xml_set_error(ctx->parser, 
+                             _("LOCK response missing Lock-Token header"));
+            return NE_XML_ABORT;
+        }
+
+        if (token[0] == '<') token++;
+        ctx->token = ne_strdup(token);
+        ne_shave(ctx->token, ">");
+        NE_DEBUG(NE_DBG_LOCKS, "lk_startelm: Finding token %s\n",
+                 ctx->token);
+    }
+
+    /* TODO: only accept 'prop' as root for LOCK response */
+    if (!can_accept(parent, id))
+        return NE_XML_DECLINE;
+
+    if (id == ELM_activelock && !ctx->found) {
+	/* a new activelock */
+	ne_lock_free(&ctx->active);
+	memset(&ctx->active, 0, sizeof ctx->active);
+        ctx->active.timeout = NE_TIMEOUT_INVALID;
+    }
+
+    ne_buffer_clear(ctx->cdata);
+
+    return id;
+}
+
+/* End-element handler for LOCK response */
+static int lk_endelm(void *userdata, int state,
+                     const char *nspace, const char *name)
+{
+    struct lock_ctx *ctx = userdata;
+
+    if (ctx->found)
+	return 0;
+
+    if (end_element_common(&ctx->active, state, ctx->cdata->data))
+	return -1;
+
+    if (state == ELM_activelock) {
+	if (ctx->active.token && strcmp(ctx->active.token, ctx->token) == 0) {
+	    ctx->found = 1;
+	}
+    }
+
+    return 0;
+}
+
+/* Creator callback for private structure. */
+static void *ld_create(void *userdata, const ne_uri *uri)
+{
+    struct ne_lock *lk = ne_lock_create();
+
+    ne_uri_copy(&lk->uri, uri);
+
+    return lk;
+}
+
+/* Destructor callback for private structure. */
+static void ld_destroy(void *userdata, void *private)
+{
+    struct ne_lock *lk = private;
+
+    ne_lock_destroy(lk);
+}
+
+/* Discover all locks on URI */
+int ne_lock_discover(ne_session *sess, const char *uri, 
+		     ne_lock_result callback, void *userdata)
+{
+    ne_propfind_handler *handler;
+    struct discover_ctx ctx = {0};
+    int ret;
+    
+    ctx.results = callback;
+    ctx.userdata = userdata;
+    ctx.cdata = ne_buffer_create();
+    ctx.phandler = handler = ne_propfind_create(sess, uri, NE_DEPTH_ZERO);
+
+    ne_propfind_set_private(handler, ld_create, ld_destroy, &ctx);
+    
+    ne_xml_push_handler(ne_propfind_get_parser(handler), 
+                        ld_startelm, ld_cdata, end_element_ldisc, &ctx);
+    
+    ret = ne_propfind_named(handler, lock_props, discover_results, &ctx);
+    
+    ne_buffer_destroy(ctx.cdata);
+    ne_propfind_destroy(handler);
+
+    return ret;
+}
+
+static void add_timeout_header(ne_request *req, long timeout)
+{
+    if (timeout == NE_TIMEOUT_INFINITE) {
+	ne_add_request_header(req, "Timeout", "Infinite");
+    } 
+    else if (timeout != NE_TIMEOUT_INVALID && timeout > 0) {
+	ne_print_request_header(req, "Timeout", "Second-%ld", timeout);
+    }
+    /* just ignore it if timeout == 0 or invalid. */
+}
+
+int ne_lock(ne_session *sess, struct ne_lock *lock) 
+{
+    ne_request *req = ne_request_create(sess, "LOCK", lock->uri.path);
+    ne_buffer *body = ne_buffer_create();
+    ne_xml_parser *parser = ne_xml_create();
+    int ret;
+    struct lock_ctx ctx;
+
+    memset(&ctx, 0, sizeof ctx);
+    ctx.cdata = ne_buffer_create();    
+    ctx.req = req;
+    ctx.parser = parser;
+
+    /* LOCK is not idempotent. */
+    ne_set_request_flag(req, NE_REQFLAG_IDEMPOTENT, 0);
+
+    ne_xml_push_handler(parser, lk_startelm, lk_cdata, lk_endelm, &ctx);
+    
+    /* Create the body */
+    ne_buffer_concat(body, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+		    "<lockinfo xmlns='DAV:'>\n" " <lockscope>",
+		    lock->scope==ne_lockscope_exclusive?
+		    "<exclusive/>":"<shared/>",
+		    "</lockscope>\n"
+		    "<locktype><write/></locktype>", NULL);
+
+    if (lock->owner) {
+	ne_buffer_concat(body, "<owner>", lock->owner, "</owner>\n", NULL);
+    }
+    ne_buffer_czappend(body, "</lockinfo>\n");
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ne_add_depth_header(req, lock->depth);
+    add_timeout_header(req, lock->timeout);
+    
+    /* TODO: 
+     * By 2518, we need this only if we are creating a lock-null resource.
+     * Since we don't KNOW whether the lock we're given is a lock-null
+     * or not, we cover our bases.
+     */
+    ne_lock_using_parent(req, lock->uri.path);
+    /* This one is clearer from 2518 sec 8.10.4. */
+    ne_lock_using_resource(req, lock->uri.path, lock->depth);
+
+    ret = ne_xml_dispatch_request(req, parser);
+
+    ne_buffer_destroy(body);
+    ne_buffer_destroy(ctx.cdata);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass == 2) {
+        if (ne_get_status(req)->code == 207) {
+            ret = NE_ERROR;
+            /* TODO: set the error string appropriately */
+        } else if (ctx.found) {
+	    /* it worked: copy over real lock details if given. */
+            if (lock->token) ne_free(lock->token);
+	    lock->token = ctx.token;
+            ctx.token = NULL;
+	    if (ctx.active.timeout != NE_TIMEOUT_INVALID)
+		lock->timeout = ctx.active.timeout;
+	    lock->scope = ctx.active.scope;
+	    lock->type = ctx.active.type;
+	    if (ctx.active.depth >= 0)
+		lock->depth = ctx.active.depth;
+	    if (ctx.active.owner) {
+		if (lock->owner) ne_free(lock->owner);
+		lock->owner = ctx.active.owner;
+		ctx.active.owner = NULL;
+	    }
+	} else {
+	    ret = NE_ERROR;
+	    ne_set_error(sess, _("Response missing activelock for %s"), 
+			 ctx.token);
+	}
+    } else if (ret == NE_OK /* && status != 2xx */) {
+	ret = NE_ERROR;
+    }
+
+    ne_lock_free(&ctx.active);
+    if (ctx.token) ne_free(ctx.token);
+    ne_request_destroy(req);
+    ne_xml_destroy(parser);
+
+    return ret;
+}
+
+int ne_lock_refresh(ne_session *sess, struct ne_lock *lock)
+{
+    ne_request *req = ne_request_create(sess, "LOCK", lock->uri.path);
+    ne_xml_parser *parser = ne_xml_create();
+    int ret;
+    struct lock_ctx ctx;
+
+    memset(&ctx, 0, sizeof ctx);
+    ctx.cdata = ne_buffer_create();
+    ctx.req = req;
+    ctx.token = lock->token;
+    ctx.parser = parser;
+
+    /* Handle the response and update *lock appropriately. */
+    ne_xml_push_handler(parser, lk_startelm, lk_cdata, lk_endelm, &ctx);
+    
+    /* For a lock refresh, submitting only this lock token must be
+     * sufficient. */
+    ne_print_request_header(req, "If", "(<%s>)", lock->token);
+    add_timeout_header(req, lock->timeout);
+
+    ret = ne_xml_dispatch_request(req, parser);
+
+    if (ret == NE_OK) {
+        if (ne_get_status(req)->klass != 2) {
+            ret = NE_ERROR; /* and use default session error */
+	} else if (!ctx.found) {
+            ne_set_error(sess, _("No activelock for <%s> returned in "
+                                 "LOCK refresh response"), lock->token);
+            ret = NE_ERROR;
+        } else /* success! */ {
+            /* update timeout for passed-in lock structure. */
+            lock->timeout = ctx.active.timeout;
+        }
+    }
+
+    ne_lock_free(&ctx.active);
+    ne_buffer_destroy(ctx.cdata);
+    ne_request_destroy(req);
+    ne_xml_destroy(parser);
+
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_locks.h b/net/mmt/neon/src/ne_locks.h
new file mode 100644
index 0000000..db98f11
--- /dev/null
+++ b/net/mmt/neon/src/ne_locks.h
@@ -0,0 +1,165 @@
+/* 
+   WebDAV Class 2 locking operations
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_LOCKS_H
+#define NE_LOCKS_H
+
+#include "ne_request.h" /* for ne_session + ne_request */
+#include "ne_uri.h" /* for ne_uri */
+
+NE_BEGIN_DECLS
+
+/* The scope of a lock */
+enum ne_lock_scope {
+    ne_lockscope_exclusive,
+    ne_lockscope_shared
+};
+
+/* Lock type. Only write locks are defined in RFC2518. */
+enum ne_lock_type {
+    ne_locktype_write
+};
+
+/* A lock object. */
+struct ne_lock {
+    ne_uri uri;
+    int depth; /* the depth of the lock (NE_DEPTH_*). */
+    enum ne_lock_type type;
+    enum ne_lock_scope scope;
+    char *token; /* the lock token: uniquely identifies this lock. */
+    char *owner; /* string describing the owner of the lock. */
+    long timeout; /* timeout in seconds. (or NE_TIMEOUT_*) */
+};
+/* NB: struct ne_lock Would be typedef'ed to ne_lock except lock is
+ * a verb and a noun, so we already have ne_lock the function. Damn
+ * the English language. */
+
+#define NE_TIMEOUT_INFINITE -1
+#define NE_TIMEOUT_INVALID -2
+
+/* Create a depth zero, exclusive write lock, with default timeout
+ * (allowing a server to pick a default).  token, owner and uri are
+ * unset. */
+struct ne_lock *ne_lock_create(void);
+
+/* HINT: to initialize uri host/port/scheme for the lock's URI, use
+ * ne_fill_server_uri from ne_session.h. */
+
+/* Deep-copy a lock structure: strdup's any of path, token, owner,
+ * hostport which are set. */
+struct ne_lock *ne_lock_copy(const struct ne_lock *lock);
+
+/* Free a lock structure; free's any of any of the URI, token and
+ * owner which are set, but not the lock object itself. */
+void ne_lock_free(struct ne_lock *lock);
+
+/* Like ne_lock_free; but free's the lock object itself too. */
+void ne_lock_destroy(struct ne_lock *lock);
+
+/* ne_lock_store: an opaque type which is used to store a set of lock
+ * objects. */
+typedef struct ne_lock_store_s ne_lock_store;
+
+/* Create a lock store. */
+ne_lock_store *ne_lockstore_create(void);
+
+/* Register the lock store 'store' with the HTTP session 'sess': any
+ * operations made using 'sess' which operate on a locked resource,
+ * can use the locks from 'store' if needed. */
+void ne_lockstore_register(ne_lock_store *store, ne_session *sess);
+
+/* Destroy a lock store, free'ing any locks remaining inside. */
+void ne_lockstore_destroy(ne_lock_store *store);
+
+/* Add a lock to the store: the store then "owns" the lock object, and
+ * you must not free it. The lock MUST have all of:
+ *  - a completed URI structure: scheme, host, port, and path all set
+ *  - a valid lock token
+ *  - a valid depth
+ */
+void ne_lockstore_add(ne_lock_store *store, struct ne_lock *lock);
+
+/* Remove given lock object from store: 'lock' MUST point to a lock
+ * object which is known to be in the store. */
+void ne_lockstore_remove(ne_lock_store *store, struct ne_lock *lock);
+
+/* Returns the first lock in the lock store, or NULL if the store is
+ * empty. */
+struct ne_lock *ne_lockstore_first(ne_lock_store *store);
+
+/* After ne_lockstore_first has been called; returns the next lock in
+ * the lock store, or NULL if there are no more locks stored.
+ * Behaviour is undefined if ne_lockstore_first has not been called on
+ * 'store' since the store was created, or the last time this function
+ * returned NULL for the store.. */
+struct ne_lock *ne_lockstore_next(ne_lock_store *store);
+
+/* Find a lock in the store for the given server, and with the given
+ * path. */
+struct ne_lock *ne_lockstore_findbyuri(ne_lock_store *store, 
+				       const ne_uri *uri);
+
+/* Issue a LOCK request for the given lock.  Requires that the uri,
+ * depth, type, scope, and timeout members of 'lock' are filled in.
+ * owner and token must be malloc-allocated if not NULL; and may be
+ * free()d by this function.  On successful return, lock->token will
+ * contain the lock token. */
+int ne_lock(ne_session *sess, struct ne_lock *lock);
+
+/* Issue an UNLOCK request for the given lock */
+int ne_unlock(ne_session *sess, const struct ne_lock *lock);
+
+/* Refresh a lock. Updates lock->timeout appropriately. */
+int ne_lock_refresh(ne_session *sess, struct ne_lock *lock);
+
+/* Callback for lock discovery.  If 'lock' is NULL, something went
+ * wrong performing lockdiscovery for the resource, look at 'status'
+ * for the details.
+ * 
+ * If lock is non-NULL, at least lock->uri and lock->token will be
+ * filled in; and status will be NULL. */
+typedef void (*ne_lock_result)(void *userdata, const struct ne_lock *lock, 
+			       const ne_uri *uri, const ne_status *status);
+
+/* Perform lock discovery on the given path.  'result' is called with
+ * the results (possibly >1 times).  */
+int ne_lock_discover(ne_session *sess, const char *path,
+		     ne_lock_result result, void *userdata);
+
+/* The ne_lock_using_* functions should be used before dispatching a
+ * request which modify resources.  If a lock store has been
+ * registered with the session associated with the request, and locks
+ * are present in the lock store which cover the resources which are
+ * being modified by the request, then the appropriate lock tokens are
+ * submitted in the request headers. */
+
+/* Indicate that request 'req' will modify the resource at 'path', and
+ * is an operation of given 'depth'. */
+void ne_lock_using_resource(ne_request *req, const char *path, int depth);
+
+/* Indicate that request 'req' will modify the parent collection of
+ * the resource found at 'path' (for instance when removing the
+ * resource from the collection). */
+void ne_lock_using_parent(ne_request *req, const char *path);
+
+NE_END_DECLS
+
+#endif /* NE_LOCKS_H */
diff --git a/net/mmt/neon/src/ne_md5.c b/net/mmt/neon/src/ne_md5.c
new file mode 100644
index 0000000..35d7109
--- /dev/null
+++ b/net/mmt/neon/src/ne_md5.c
@@ -0,0 +1,464 @@
+/* md5.c - Functions to compute MD5 message digest of files or memory blocks
+   according to the definition of MD5 in RFC 1321 from April 1992.
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <stdlib.h>
+#include <string.h>
+#ifdef HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+#include "ne_md5.h"
+#include "ne_string.h" /* for NE_ASC2HEX */
+
+#define md5_process_block ne_md5_process_block
+#define md5_process_bytes ne_md5_process_bytes
+#define md5_finish_ctx ne_md5_finish_ctx
+#define md5_read_ctx ne_md5_read_ctx
+#define md5_stream ne_md5_stream
+#define md5_ctx ne_md5_ctx
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n)							\
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#else
+# define SWAP(n) (n)
+#endif
+
+#if SIZEOF_INT == 4
+typedef unsigned int md5_uint32;
+#elif SIZEOF_LONG == 4
+typedef unsigned long md5_uint32;
+#else
+# error "Cannot determine unsigned 32-bit data type."
+#endif
+
+/* Structure to save state of computation between the single steps.  */
+struct md5_ctx
+{
+  md5_uint32 A;
+  md5_uint32 B;
+  md5_uint32 C;
+  md5_uint32 D;
+
+  md5_uint32 total[2];
+  md5_uint32 buflen;
+  char buffer[128];
+};
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+static void 
+md5_init_ctx (struct md5_ctx *ctx)
+{
+  ctx->A = 0x67452301;
+  ctx->B = 0xefcdab89;
+  ctx->C = 0x98badcfe;
+  ctx->D = 0x10325476;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+struct ne_md5_ctx *
+ne_md5_create_ctx(void)
+{
+  struct md5_ctx *ctx = ne_malloc(sizeof *ctx);
+  md5_init_ctx(ctx);
+  return ctx;
+}
+
+extern void 
+ne_md5_reset_ctx(struct ne_md5_ctx *ctx)
+{
+  md5_init_ctx(ctx);
+}
+
+struct ne_md5_ctx *
+ne_md5_dup_ctx(struct ne_md5_ctx *ctx)
+{
+  return memcpy(ne_malloc(sizeof *ctx), ctx, sizeof *ctx);
+}
+
+void
+ne_md5_destroy_ctx(struct ne_md5_ctx *ctx)
+{
+  ne_free(ctx);
+}
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)
+{
+  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);
+  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);
+  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);
+  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)
+{
+  /* Take yet unprocessed bytes into account.  */
+  md5_uint32 bytes = ctx->buflen;
+  md5_uint32 swap_bytes;
+  size_t pad;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.
+     Use memcpy to avoid aliasing problems.  On most systems, this
+     will be optimized away to the same code.  */
+  swap_bytes = SWAP (ctx->total[0] << 3);
+  memcpy (&ctx->buffer[bytes + pad], &swap_bytes, sizeof (swap_bytes));
+  swap_bytes = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));
+  memcpy (&ctx->buffer[bytes + pad + 4], &swap_bytes, sizeof (swap_bytes));
+
+  /* Process last bytes.  */
+  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);
+
+  return md5_read_ctx (ctx, resbuf);
+}
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+int
+md5_stream (FILE *stream, void *resblock)
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+  struct md5_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      do
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+	}
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+	break;
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+      md5_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+    md5_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  md5_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+void
+md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (left_over + add > 64)
+	{
+	  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+		  (left_over + add) & 63);
+	  ctx->buflen = (left_over + add) & 63;
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len > 64)
+    {
+      md5_process_block (buffer, len & ~63, ctx);
+      buffer = (const char *) buffer + (len & ~63);
+      len &= 63;
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      memcpy (ctx->buffer, buffer, len);
+      ctx->buflen = len;
+    }
+}
+
+
+/* These are the four functions used in the four steps of the MD5 algorithm
+   and defined in the RFC 1321.  The first function is a little bit optimized
+   (as found in Colin Plumbs public domain implementation).  */
+/* #define FF(b, c, d) ((b & c) | (~b & d)) */
+#define FF(b, c, d) (d ^ (b & (c ^ d)))
+#define FG(b, c, d) FF (d, b, c)
+#define FH(b, c, d) (b ^ c ^ d)
+#define FI(b, c, d) (c ^ (b | ~d))
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.  */
+
+void
+md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  md5_uint32 correct_words[16];
+  const unsigned char *words = buffer;
+  const unsigned char *endp = words + len;
+  md5_uint32 A = ctx->A;
+  md5_uint32 B = ctx->B;
+  md5_uint32 C = ctx->C;
+  md5_uint32 D = ctx->D;
+
+  /* First increment the byte count.  RFC 1321 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+  /* Process all bytes in the buffer with 64 bytes in each round of
+     the loop.  */
+  while (words < endp)
+    {
+      md5_uint32 *cwp = correct_words;
+      md5_uint32 A_save = A;
+      md5_uint32 B_save = B;
+      md5_uint32 C_save = C;
+      md5_uint32 D_save = D;
+
+      /* First round: using the given function, the context and a constant
+	 the next context is computed.  Because the algorithms processing
+	 unit is a 32-bit word and it is determined to work on words in
+	 little endian byte order we perhaps have to change the byte order
+	 before the computation.  To reduce the work for the next steps
+	 we store the swapped words in the array CORRECT_WORDS.  */
+
+#define OP(a, b, c, d, s, T)						\
+      do								\
+        {								\
+	  md5_uint32 WORD_ = (md5_uint32)words[0] | ((md5_uint32)words[1] << 8) \
+	       | ((md5_uint32)words[2] << 16) | ((md5_uint32)words[3] << 24); \
+	  a += FF (b, c, d) + (*cwp++ = WORD_) + T;		\
+	  words += 4;							\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+        }								\
+      while (0)
+
+      /* It is unfortunate that C does not provide an operator for
+	 cyclic rotation.  Hope the C compiler is smart enough.  */
+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
+
+      /* Before we start, one word to the strange constants.
+	 They are defined in RFC 1321 as
+
+	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
+       */
+
+      /* Round 1.  */
+      OP (A, B, C, D,  7, 0xd76aa478);
+      OP (D, A, B, C, 12, 0xe8c7b756);
+      OP (C, D, A, B, 17, 0x242070db);
+      OP (B, C, D, A, 22, 0xc1bdceee);
+      OP (A, B, C, D,  7, 0xf57c0faf);
+      OP (D, A, B, C, 12, 0x4787c62a);
+      OP (C, D, A, B, 17, 0xa8304613);
+      OP (B, C, D, A, 22, 0xfd469501);
+      OP (A, B, C, D,  7, 0x698098d8);
+      OP (D, A, B, C, 12, 0x8b44f7af);
+      OP (C, D, A, B, 17, 0xffff5bb1);
+      OP (B, C, D, A, 22, 0x895cd7be);
+      OP (A, B, C, D,  7, 0x6b901122);
+      OP (D, A, B, C, 12, 0xfd987193);
+      OP (C, D, A, B, 17, 0xa679438e);
+      OP (B, C, D, A, 22, 0x49b40821);
+
+      /* For the second to fourth round we have the possibly swapped words
+	 in CORRECT_WORDS.  Redefine the macro to take an additional first
+	 argument specifying the function to use.  */
+#undef OP
+#define OP(f, a, b, c, d, k, s, T)					\
+      do 								\
+	{								\
+	  a += f (b, c, d) + correct_words[k] + T;			\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+	}								\
+      while (0)
+
+      /* Round 2.  */
+      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
+      OP (FG, D, A, B, C,  6,  9, 0xc040b340);
+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
+      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
+      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
+      OP (FG, D, A, B, C, 10,  9, 0x02441453);
+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
+      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
+      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
+      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
+      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
+      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
+      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
+      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
+      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
+
+      /* Round 3.  */
+      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
+      OP (FH, D, A, B, C,  8, 11, 0x8771f681);
+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
+      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
+      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
+      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
+      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
+      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
+      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
+      OP (FH, B, C, D, A,  6, 23, 0x04881d05);
+      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
+      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);
+
+      /* Round 4.  */
+      OP (FI, A, B, C, D,  0,  6, 0xf4292244);
+      OP (FI, D, A, B, C,  7, 10, 0x432aff97);
+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
+      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
+      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
+      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
+      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
+      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
+      OP (FI, C, D, A, B,  6, 15, 0xa3014314);
+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
+      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
+      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
+      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);
+
+      /* Add the starting values of the context.  */
+      A += A_save;
+      B += B_save;
+      C += C_save;
+      D += D_save;
+    }
+
+  /* Put checksum in context given as argument.  */
+  ctx->A = A;
+  ctx->B = B;
+  ctx->C = C;
+  ctx->D = D;
+}
+
+/* Writes the ASCII representation of the MD5 digest into the
+ * given buffer, which must be at least 33 characters long. */
+void ne_md5_to_ascii(const unsigned char md5_buf[16], char *buffer) 
+{
+    int count;
+    for (count = 0; count<16; count++) {
+	buffer[count*2] = NE_HEX2ASC(md5_buf[count] >> 4);
+	buffer[count*2+1] = NE_HEX2ASC(md5_buf[count] & 0x0f);
+    }
+    buffer[32] = '\0';
+}
+
+/* Reads the ASCII representation of an MD5 digest. The buffer must
+ * be at least 32 characters long. */
+void ne_ascii_to_md5(const char *buffer, unsigned char md5_buf[16]) 
+{
+    int count;
+    for (count = 0; count<16; count++) {
+	md5_buf[count] = ((NE_ASC2HEX(buffer[count*2])) << 4) |
+	    NE_ASC2HEX(buffer[count*2+1]);
+    }
+}
+
+char *ne_md5_finish_ascii(struct ne_md5_ctx *ctx, char buffer[33])
+{
+    md5_uint32 result[4];
+
+    ne_md5_finish_ctx(ctx, (void *)result);
+    ne_md5_to_ascii((void *)result, buffer);
+
+    return buffer;
+}
+
diff --git a/net/mmt/neon/src/ne_md5.h b/net/mmt/neon/src/ne_md5.h
new file mode 100644
index 0000000..9a625bc
--- /dev/null
+++ b/net/mmt/neon/src/ne_md5.h
@@ -0,0 +1,98 @@
+/* Declaration of functions and data types used for MD5 sum computing
+   library functions.
+   Copyright (C) 2006, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef NE_MD5_H
+#define NE_MD5_H 1
+
+#include <stdio.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/*
+ * The following three functions are build up the low level used in
+ * the functions `md5_stream' and `md5_buffer'.
+ */
+struct ne_md5_ctx;
+
+/* Create structure containing state of computation. */
+extern struct ne_md5_ctx *ne_md5_create_ctx(void);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 64!!! */
+extern void ne_md5_process_block(const void *buffer, size_t len,
+                                 struct ne_md5_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 64.  */
+extern void ne_md5_process_bytes(const void *buffer, size_t len,
+                                 struct ne_md5_ctx *ctx);
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 16 bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *ne_md5_finish_ctx(struct ne_md5_ctx *ctx, void *resbuf);
+
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *ne_md5_read_ctx(const struct ne_md5_ctx *ctx, void *resbuf);
+
+/* Take a copy of the state structure. */
+extern struct ne_md5_ctx *ne_md5_dup_ctx(struct ne_md5_ctx *ctx);
+
+/* Re-initialize the context structure. */
+extern void ne_md5_reset_ctx(struct ne_md5_ctx *ctx);
+
+/* Destroy the context structure. */
+extern void ne_md5_destroy_ctx(struct ne_md5_ctx *ctx);
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+extern int ne_md5_stream(FILE *stream, void *resblock);
+
+/* Process the remaining bytes in the buffer and put ASCII
+   representation of the resulting message digest from CTX in the
+   first 33 bytes of BUFFER, including a trailing NUL terminator
+   byte.  Returns pointer to buffer. */
+char *ne_md5_finish_ascii(struct ne_md5_ctx *ctx, char buffer[33]);
+
+/* MD5 ascii->binary conversion */
+void ne_md5_to_ascii(const unsigned char md5_buf[16], char *buffer);
+void ne_ascii_to_md5(const char *buffer, unsigned char md5_buf[16]);
+
+NE_END_DECLS
+
+#endif /* NE_MD5_H */
diff --git a/net/mmt/neon/src/ne_ntlm.c b/net/mmt/neon/src/ne_ntlm.c
new file mode 100644
index 0000000..3c00e79
--- /dev/null
+++ b/net/mmt/neon/src/ne_ntlm.c
@@ -0,0 +1,688 @@
+/* 
+   Handling of NTLM Authentication
+   Copyright (C) 2003, Daniel Stenberg <daniel@haxx.se>
+   Copyright (C) 2009, Kai Sommerfeld <kso@openoffice.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* NTLM details:
+   
+   http://davenport.sourceforge.net/ntlm.html
+   http://www.innovation.ch/java/ntlm.html
+
+*/
+
+#include "ne_ntlm.h"
+
+#ifdef HAVE_NTLM
+
+#include "ne_string.h"
+
+typedef enum {
+  NTLMSTATE_NONE,
+  NTLMSTATE_TYPE1,
+  NTLMSTATE_TYPE2,
+  NTLMSTATE_TYPE3,
+  NTLMSTATE_LAST
+} NTLMState;
+
+struct ne_ntlm_context_s {
+  NTLMState state;
+  unsigned char nonce[8];
+  char *user;
+  char *passwd;
+  char *requestToken;
+};
+
+typedef enum {
+  NTLM_NONE, /* not a ntlm */
+  NTLM_BAD,  /* an ntlm, but one we don't like */
+  NTLM_FIRST, /* the first 401-reply we got with NTLM */
+  NTLM_FINE, /* an ntlm we act on */
+
+  NTLM_LAST  /* last entry in this enum, don't use */
+} ntlm;
+
+/* Flag bits definitions based on http://davenport.sourceforge.net/ntlm.html */
+
+#define NTLMFLAG_NEGOTIATE_UNICODE               (1<<0)
+/* Indicates that Unicode strings are supported for use in security buffer
+   data. */
+
+#define NTLMFLAG_NEGOTIATE_OEM                   (1<<1)
+/* Indicates that OEM strings are supported for use in security buffer data. */
+
+#define NTLMFLAG_REQUEST_TARGET                  (1<<2)
+/* Requests that the server's authentication realm be included in the Type 2
+   message. */
+
+/* unknown (1<<3) */
+#define NTLMFLAG_NEGOTIATE_SIGN                  (1<<4)
+/* Specifies that authenticated communication between the client and server
+   should carry a digital signature (message integrity). */
+
+#define NTLMFLAG_NEGOTIATE_SEAL                  (1<<5)
+/* Specifies that authenticated communication between the client and server
+   should be encrypted (message confidentiality). */
+
+#define NTLMFLAG_NEGOTIATE_DATAGRAM_STYLE        (1<<6)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_LM_KEY                (1<<7)
+/* Indicates that the LAN Manager session key should be used for signing and
+   sealing authenticated communications. */
+
+#define NTLMFLAG_NEGOTIATE_NETWARE               (1<<8)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_NTLM_KEY              (1<<9)
+/* Indicates that NTLM authentication is being used. */
+
+/* unknown (1<<10) */
+/* unknown (1<<11) */
+
+#define NTLMFLAG_NEGOTIATE_DOMAIN_SUPPLIED       (1<<12)
+/* Sent by the client in the Type 1 message to indicate that a desired
+   authentication realm is included in the message. */
+
+#define NTLMFLAG_NEGOTIATE_WORKSTATION_SUPPLIED  (1<<13)
+/* Sent by the client in the Type 1 message to indicate that the client
+   workstation's name is included in the message. */
+
+#define NTLMFLAG_NEGOTIATE_LOCAL_CALL            (1<<14)
+/* Sent by the server to indicate that the server and client are on the same
+   machine. Implies that the client may use a pre-established local security
+   context rather than responding to the challenge. */
+
+#define NTLMFLAG_NEGOTIATE_ALWAYS_SIGN           (1<<15)
+/* Indicates that authenticated communication between the client and server
+   should be signed with a "dummy" signature. */
+
+#define NTLMFLAG_TARGET_TYPE_DOMAIN              (1<<16)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a domain. */
+
+#define NTLMFLAG_TARGET_TYPE_SERVER              (1<<17)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a server. */
+
+#define NTLMFLAG_TARGET_TYPE_SHARE               (1<<18)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a share. Presumably, this is for share-level
+   authentication. Usage is unclear. */
+
+#define NTLMFLAG_NEGOTIATE_NTLM2_KEY             (1<<19)
+/* Indicates that the NTLM2 signing and sealing scheme should be used for
+   protecting authenticated communications. */
+
+#define NTLMFLAG_REQUEST_INIT_RESPONSE           (1<<20)
+/* unknown purpose */
+
+#define NTLMFLAG_REQUEST_ACCEPT_RESPONSE         (1<<21)
+/* unknown purpose */
+
+#define NTLMFLAG_REQUEST_NONNT_SESSION_KEY       (1<<22)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_TARGET_INFO           (1<<23)
+/* Sent by the server in the Type 2 message to indicate that it is including a
+   Target Information block in the message. */
+
+/* unknown (1<24) */
+/* unknown (1<25) */
+/* unknown (1<26) */
+/* unknown (1<27) */
+/* unknown (1<28) */
+
+#define NTLMFLAG_NEGOTIATE_128                   (1<<29)
+/* Indicates that 128-bit encryption is supported. */
+
+#define NTLMFLAG_NEGOTIATE_KEY_EXCHANGE          (1<<30)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_56                    (1<<31)
+/* Indicates that 56-bit encryption is supported. */
+
+#ifdef HAVE_OPENSSL
+/* We need OpenSSL for the crypto lib to provide us with MD4 and DES */
+
+/* -- WIN32 approved -- */
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#include <openssl/des.h>
+#include <openssl/md4.h>
+#include <openssl/ssl.h>
+
+#if OPENSSL_VERSION_NUMBER < 0x00907001L
+#define DES_key_schedule des_key_schedule
+#define DES_cblock des_cblock
+#define DES_set_odd_parity des_set_odd_parity
+#define DES_set_key des_set_key
+#define DES_ecb_encrypt des_ecb_encrypt
+
+/* This is how things were done in the old days */
+#define DESKEY(x) x
+#define DESKEYARG(x) x
+#else
+/* Modern version */
+#define DESKEYARG(x) *x
+#define DESKEY(x) &x
+#endif
+
+/* Define this to make the type-3 message include the NT response message */
+#define USE_NTRESPONSES 1
+
+/*
+  (*) = A "security buffer" is a triplet consisting of two shorts and one
+  long:
+
+  1. a 'short' containing the length of the buffer in bytes
+  2. a 'short' containing the allocated space for the buffer in bytes
+  3. a 'long' containing the offset to the start of the buffer from the
+     beginning of the NTLM message, in bytes.
+*/
+
+static ntlm ne_input_ntlm(ne_ntlm_context *ctx,
+			  const char *responseToken)
+{
+  if(responseToken) {
+    /* We got a type-2 message here:
+
+       Index   Description         Content
+       0       NTLMSSP Signature   Null-terminated ASCII "NTLMSSP"
+                                   (0x4e544c4d53535000)
+       8       NTLM Message Type   long (0x02000000)
+       12      Target Name         security buffer(*)
+       20      Flags               long
+       24      Challenge           8 bytes
+       (32)    Context (optional)  8 bytes (two consecutive longs)
+       (40)    Target Information  (optional) security buffer(*)
+       32 (48) start of data block
+    */
+    unsigned char * buffer = NULL;
+
+    int size = ne_unbase64(responseToken, &buffer);
+
+    ctx->state = NTLMSTATE_TYPE2; /* we got a type-2 */
+
+    if(size >= 48)
+      /* the nonce of interest is index [24 .. 31], 8 bytes */
+      memcpy(ctx->nonce, &buffer[24], 8);
+
+    /* at index decimal 20, there's a 32bit NTLM flag field */
+      
+    if (buffer) ne_free(buffer); 
+  }
+  else {
+    if(ctx->state >= NTLMSTATE_TYPE1)
+      return NTLM_BAD;
+
+    ctx->state = NTLMSTATE_TYPE1; /* we should sent away a type-1 */
+  }
+  return NTLM_FINE;
+}
+
+/*
+ * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The
+ * key schedule ks is also set.
+ */
+static void setup_des_key(unsigned char *key_56,
+                          DES_key_schedule DESKEYARG(ks))
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = ((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1);
+  key[2] = ((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2);
+  key[3] = ((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3);
+  key[4] = ((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4);
+  key[5] = ((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5);
+  key[6] = ((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6);
+  key[7] =  (key_56[6] << 1) & 0xFF;
+
+  DES_set_odd_parity(&key);
+  DES_set_key(&key, ks);
+}
+
+ /*
+  * takes a 21 byte array and treats it as 3 56-bit DES keys. The
+  * 8 byte plaintext is encrypted with each key and the resulting 24
+  * bytes are stored in the results array.
+  */
+static void calc_resp(unsigned char *keys,
+                      unsigned char *plaintext,
+                      unsigned char *results)
+{
+  DES_key_schedule ks;
+
+  setup_des_key(keys, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) results,
+                  DESKEY(ks), DES_ENCRYPT);
+
+  setup_des_key(keys+7, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results+8),
+                  DESKEY(ks), DES_ENCRYPT);
+
+  setup_des_key(keys+14, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results+16),
+                  DESKEY(ks), DES_ENCRYPT);
+}
+
+/*
+ * Set up lanmanager and nt hashed passwords
+ */
+static void mkhash(char *password,
+                   unsigned char *nonce,  /* 8 bytes */
+                   unsigned char *lmresp  /* must fit 0x18 bytes */
+#ifdef USE_NTRESPONSES
+                   , unsigned char *ntresp  /* must fit 0x18 bytes */
+#endif
+  )
+{
+  unsigned char lmbuffer[21];
+#ifdef USE_NTRESPONSES
+  unsigned char ntbuffer[21];
+#endif
+  unsigned char *pw;
+  static const unsigned char magic[] = {
+    0x4B, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25
+  };
+  int i;
+  int len = strlen(password);
+
+  /* make it fit at least 14 bytes */
+  pw = ne_malloc(len<7?14:len*2);
+  if(!pw)
+    return; /* this will lead to a badly generated package */
+
+  if (len > 14)
+    len = 14;
+  
+  for (i=0; i<len; i++)
+    pw[i] = toupper(password[i]);
+
+  for (; i<14; i++)
+    pw[i] = 0;
+
+  {
+    /* create LanManager hashed password */
+    DES_key_schedule ks;
+
+    setup_des_key(pw, DESKEY(ks));
+    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)lmbuffer,
+                    DESKEY(ks), DES_ENCRYPT);
+  
+    setup_des_key(pw+7, DESKEY(ks));
+    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)(lmbuffer+8),
+                    DESKEY(ks), DES_ENCRYPT);
+
+    memset(lmbuffer+16, 0, 5);
+  }
+  /* create LM responses */
+  calc_resp(lmbuffer, nonce, lmresp);
+
+#ifdef USE_NTRESPONSES
+  {
+    /* create NT hashed password */
+    MD4_CTX md4;
+
+    len = strlen(password);
+
+    for (i=0; i<len; i++) {
+      pw[2*i]   = password[i];
+      pw[2*i+1] = 0;
+    }
+
+    MD4_Init(&md4);
+    MD4_Update(&md4, pw, 2*len);
+    MD4_Final(ntbuffer, &md4);
+
+    memset(ntbuffer+16, 0, 5);
+  }
+
+  calc_resp(ntbuffer, nonce, ntresp);
+#endif
+
+  ne_free(pw);
+}
+
+#define SHORTPAIR(x) ((x) & 0xff), ((x) >> 8)
+#define LONGQUARTET(x) ((x) & 0xff), (((x) >> 8)&0xff), \
+  (((x) >>16)&0xff), ((x)>>24)
+
+/* this is for creating ntlm header output */
+static int ne_output_ntlm(ne_ntlm_context *ctx)
+{
+  const char *domain=""; /* empty */
+  const char *host=""; /* empty */
+  int domlen=strlen(domain);
+  int hostlen = strlen(host);
+  int hostoff; /* host name offset */
+  int domoff;  /* domain name offset */
+  int size;
+  unsigned char ntlmbuf[256]; /* enough, unless the host/domain is very long */
+
+  if(!ctx->user || !ctx->passwd)
+    /* no user, no auth */
+    return 0; /* OK */
+  
+  switch(ctx->state) {
+  case NTLMSTATE_TYPE1:
+  default: /* for the weird cases we (re)start here */
+    hostoff = 32;
+    domoff = hostoff + hostlen;
+    
+    /* Create and send a type-1 message:
+
+    Index Description          Content
+    0     NTLMSSP Signature    Null-terminated ASCII "NTLMSSP"
+                               (0x4e544c4d53535000)
+    8     NTLM Message Type    long (0x01000000)
+    12    Flags                long
+    16    Supplied Domain      security buffer(*)
+    24    Supplied Workstation security buffer(*)
+    32    start of data block
+
+    */
+
+    ne_snprintf((char *)ntlmbuf, sizeof(ntlmbuf), "NTLMSSP%c"
+             "\x01%c%c%c" /* 32-bit type = 1 */
+             "%c%c%c%c"   /* 32-bit NTLM flag field */
+             "%c%c"  /* domain length */
+             "%c%c"  /* domain allocated space */
+             "%c%c"  /* domain name offset */
+             "%c%c"  /* 2 zeroes */
+             "%c%c"  /* host length */
+             "%c%c"  /* host allocated space */
+             "%c%c"  /* host name offset */
+             "%c%c"  /* 2 zeroes */
+             "%s"   /* host name */
+             "%s",  /* domain string */
+             0,     /* trailing zero */
+             0,0,0, /* part of type-1 long */
+
+             LONGQUARTET(
+               NTLMFLAG_NEGOTIATE_OEM|      /*   2 */
+               NTLMFLAG_NEGOTIATE_NTLM_KEY  /* 200 */
+               /* equals 0x0202 */
+               ),
+             SHORTPAIR(domlen),
+             SHORTPAIR(domlen),
+             SHORTPAIR(domoff),
+             0,0,
+             SHORTPAIR(hostlen),
+             SHORTPAIR(hostlen),
+             SHORTPAIR(hostoff),
+             0,0,
+             host, domain);
+
+    /* initial packet length */
+    size = 32 + hostlen + domlen;
+
+    /* now keeper of the base64 encoded package size */
+    if (ctx->requestToken) ne_free(ctx->requestToken);
+    ctx->requestToken = ne_base64(ntlmbuf, size);
+
+    break;
+    
+  case NTLMSTATE_TYPE2:
+    /* We received the type-2 already, create a type-3 message:
+
+    Index   Description            Content
+    0       NTLMSSP Signature      Null-terminated ASCII "NTLMSSP"
+                                   (0x4e544c4d53535000)
+    8       NTLM Message Type      long (0x03000000)
+    12      LM/LMv2 Response       security buffer(*)
+    20      NTLM/NTLMv2 Response   security buffer(*)
+    28      Domain Name            security buffer(*)
+    36      User Name              security buffer(*)
+    44      Workstation Name       security buffer(*)
+    (52)    Session Key (optional) security buffer(*)
+    (60)    Flags (optional)       long
+    52 (64) start of data block
+
+    */
+  
+  {
+    int lmrespoff;
+    int ntrespoff;
+    int useroff;
+    unsigned char lmresp[0x18]; /* fixed-size */
+#ifdef USE_NTRESPONSES
+    unsigned char ntresp[0x18]; /* fixed-size */
+#endif
+    const char *user;
+    int userlen;
+
+    user = strchr(ctx->user, '\\');
+    if(!user)
+      user = strchr(ctx->user, '/');
+
+    if (user) {
+      domain = ctx->user;
+      domlen = user - domain;
+      user++;
+    }
+    else
+      user = ctx->user;
+    userlen = strlen(user);
+
+    mkhash(ctx->passwd, &ctx->nonce[0], lmresp
+#ifdef USE_NTRESPONSES
+           , ntresp
+#endif
+      );
+
+    domoff = 64; /* always */
+    useroff = domoff + domlen;
+    hostoff = useroff + userlen;
+    lmrespoff = hostoff + hostlen;
+    ntrespoff = lmrespoff + 0x18;
+
+    /* Create the big type-3 message binary blob */
+    size = ne_snprintf((char *)ntlmbuf, sizeof(ntlmbuf),
+                    "NTLMSSP%c"
+                    "\x03%c%c%c" /* type-3, 32 bits */
+
+                    "%c%c%c%c" /* LanManager length + allocated space */
+                    "%c%c" /* LanManager offset */
+                    "%c%c" /* 2 zeroes */
+
+                    "%c%c" /* NT-response length */
+                    "%c%c" /* NT-response allocated space */
+                    "%c%c" /* NT-response offset */
+                    "%c%c" /* 2 zeroes */
+                    
+                    "%c%c"  /* domain length */
+                    "%c%c"  /* domain allocated space */
+                    "%c%c"  /* domain name offset */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "%c%c"  /* user length */
+                    "%c%c"  /* user allocated space */
+                    "%c%c"  /* user offset */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "%c%c"  /* host length */
+                    "%c%c"  /* host allocated space */
+                    "%c%c"  /* host offset */
+                    "%c%c%c%c%c%c"  /* 6 zeroes */
+                    
+                    "\xff\xff"  /* message length */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "\x01\x82" /* flags */
+                    "%c%c"  /* 2 zeroes */
+
+                    /* domain string */
+                    /* user string */
+                    /* host string */
+                    /* LanManager response */
+                    /* NT response */
+                    ,
+                    0, /* zero termination */
+                    0,0,0, /* type-3 long, the 24 upper bits */
+
+                    SHORTPAIR(0x18),  /* LanManager response length, twice */
+                    SHORTPAIR(0x18),
+                    SHORTPAIR(lmrespoff),
+                    0x0, 0x0,
+                    
+#ifdef USE_NTRESPONSES
+                    SHORTPAIR(0x18),  /* NT-response length, twice */
+                    SHORTPAIR(0x18),
+#else
+                    0x0, 0x0,
+                    0x0, 0x0,
+#endif
+                    SHORTPAIR(ntrespoff),
+                    0x0, 0x0,
+
+                    SHORTPAIR(domlen),
+                    SHORTPAIR(domlen),
+                    SHORTPAIR(domoff),
+                    0x0, 0x0,
+
+                    SHORTPAIR(userlen),
+                    SHORTPAIR(userlen),
+                    SHORTPAIR(useroff),
+                    0x0, 0x0,
+                    
+                    SHORTPAIR(hostlen),
+                    SHORTPAIR(hostlen),
+                    SHORTPAIR(hostoff),
+                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+             
+                    0x0, 0x0,
+
+                    0x0, 0x0);
+
+    /* size is now 64 */
+    size=64;
+    ntlmbuf[62]=ntlmbuf[63]=0;
+
+    /* Make sure that the user and domain strings fit in the target buffer
+       before we copy them there. */
+    if((size_t)size + userlen + domlen >= sizeof(ntlmbuf)) {
+      return -1;
+    }
+
+    memcpy(&ntlmbuf[size], domain, domlen);
+    size += domlen;
+
+    memcpy(&ntlmbuf[size], user, userlen);
+    size += userlen;
+
+    /* we append the binary hashes to the end of the blob */
+    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
+      memcpy(&ntlmbuf[size], lmresp, 0x18);
+      size += 0x18;
+    }
+
+#ifdef USE_NTRESPONSES
+    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {      
+      memcpy(&ntlmbuf[size], ntresp, 0x18);
+      size += 0x18;
+    }
+#endif
+
+    ntlmbuf[56] = size & 0xff;
+    ntlmbuf[57] = size >> 8;
+
+    /* convert the binary blob into base64 */
+    ctx->requestToken = ne_base64(ntlmbuf, size);
+
+    ctx->state = NTLMSTATE_TYPE3; /* we sent a type-3 */
+  }
+  break;
+
+  case NTLMSTATE_TYPE3:
+    /* connection is already authenticated,
+     * don't send a header in future requests */
+    if (ctx->requestToken) ne_free(ctx->requestToken);
+    ctx->requestToken = NULL;
+    break;
+  }
+
+  return 0; /* OK */
+}
+
+ne_ntlm_context *ne__ntlm_create_context(const char *userName, const char *password)
+{
+    ne_ntlm_context *ctx = ne_calloc(sizeof(ne_ntlm_context));
+
+    ctx->state = NTLMSTATE_NONE;
+    ctx->user = ne_strdup(userName);
+    ctx->passwd = ne_strdup(password);
+    
+    return ctx;
+}
+
+void ne__ntlm_destroy_context(ne_ntlm_context *context)
+{
+    if (context->user)
+        ne_free(context->user);
+    
+    if (context->passwd)
+        ne_free(context->passwd);
+    
+    if (context->requestToken)
+        ne_free(context->requestToken);
+    
+    ne_free(context);
+}
+
+int ne__ntlm_authenticate(ne_ntlm_context *context, const char *responseToken)
+{
+    if (context == NULL) {
+	return -1;
+    } else {
+        if (!responseToken && (context->state == NTLMSTATE_TYPE3))
+            context->state = NTLMSTATE_NONE;
+
+        if (context->state <= NTLMSTATE_TYPE3) {
+	  ntlm ntlmstatus = ne_input_ntlm(context, responseToken);
+
+	  if (ntlmstatus != NTLM_FINE) { 
+	    return -1;
+	  }
+	}
+    }
+    return ne_output_ntlm(context);
+}
+
+char *ne__ntlm_getRequestToken(ne_ntlm_context *context)
+{
+    char *ret;
+
+    if (context == NULL || !context->requestToken) {
+	return NULL;
+    }
+
+    ret = ne_strdup(context->requestToken);
+    ne_free(context->requestToken);
+    context->requestToken = NULL;
+    return ret;
+}
+
+#endif /* HAVE_OPENSSL */
+#endif /* HAVE_NTLM */
diff --git a/net/mmt/neon/src/ne_ntlm.h b/net/mmt/neon/src/ne_ntlm.h
new file mode 100644
index 0000000..f903bcb
--- /dev/null
+++ b/net/mmt/neon/src/ne_ntlm.h
@@ -0,0 +1,46 @@
+/* 
+   Handling of NTLM Authentication
+   Copyright (C) 2009, Kai Sommerfeld <kso@openoffice.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#ifndef NE_NTLM_H
+#define NE_NTLM_H
+
+#include "config.h"
+
+/* PRIVATE TO NEON -- NOT PART OF THE EXTERNAL API. */
+
+#ifdef HAVE_NTLM
+
+#include "ne_defs.h"
+
+typedef struct ne_ntlm_context_s ne_ntlm_context;
+
+NE_PRIVATE ne_ntlm_context *ne__ntlm_create_context(const char *userName, const char *password);
+
+NE_PRIVATE int ne__ntlm_clear_context(ne_ntlm_context *context);
+
+NE_PRIVATE void ne__ntlm_destroy_context(ne_ntlm_context *context);
+
+NE_PRIVATE int ne__ntlm_authenticate(ne_ntlm_context *context, const char *responseToken);
+
+NE_PRIVATE char *ne__ntlm_getRequestToken(ne_ntlm_context *context);
+
+#endif /* HAVE_NTLM */
+
+#endif /* NE_NTLM_H */
diff --git a/net/mmt/neon/src/ne_oldacl.c b/net/mmt/neon/src/ne_oldacl.c
new file mode 100644
index 0000000..80a6838
--- /dev/null
+++ b/net/mmt/neon/src/ne_oldacl.c
@@ -0,0 +1,132 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Contributed by Arun Garg <arung@pspl.co.in> */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_locks.h"
+#include "ne_alloc.h"
+#include "ne_string.h"
+#include "ne_acl.h"
+#include "ne_uri.h"
+#include "ne_xml.h" /* for NE_XML_MEDIA_TYPE */
+
+#define EOL "\r\n"
+
+static ne_buffer *acl_body(const ne_acl_entry *right, int count)
+{
+    ne_buffer *body = ne_buffer_create();
+    int m;
+
+    ne_buffer_zappend(body,
+		      "<?xml version=\"1.0\" encoding=\"utf-8\"?>" EOL
+		      "<acl xmlns='DAV:'>" EOL);
+
+    for (m = 0; m < count; m++) {
+	const char *type;
+
+	type = (right[m].type == ne_acl_grant ? "grant" : "deny");
+
+	ne_buffer_concat(body, "<ace>" EOL "<principal>", NULL);
+
+	switch (right[m].apply) {
+	case ne_acl_all:
+	    ne_buffer_zappend(body, "<all/>" EOL);
+	    break;
+	case ne_acl_property:
+	    ne_buffer_concat(body, "<property><", right[m].principal,
+			     "/></property>" EOL, NULL);
+	    break;
+	case ne_acl_href:
+	    ne_buffer_concat(body, "<href>", right[m].principal,
+			     "</href>" EOL, NULL);
+	    break;
+	}
+
+	ne_buffer_concat(body, "</principal>" EOL "<", type, ">" EOL, NULL);
+	
+	if (right[m].read == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].read_acl == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-acl/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].write == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].write_acl == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-acl/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].read_cuprivset == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>"
+			     "<read-current-user-privilege-set/>"
+			     "</privilege>" EOL, NULL);
+	ne_buffer_concat(body, "</", type, ">" EOL, NULL);
+	ne_buffer_zappend(body, "</ace>" EOL);
+    }
+    ne_buffer_zappend(body, "</acl>" EOL);
+
+    return body;
+}
+
+int ne_acl_set(ne_session *sess, const char *uri,
+	       const ne_acl_entry *entries, int numentries)
+{
+    int ret;
+    ne_request *req = ne_request_create(sess, "ACL", uri);
+    ne_buffer *body = acl_body(entries, numentries);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+#endif
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ret = ne_request_dispatch(req);
+
+    ne_buffer_destroy(body);
+
+    if (ret == NE_OK && ne_get_status(req)->code == 207) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_openssl.c b/net/mmt/neon/src/ne_openssl.c
new file mode 100644
index 0000000..f8350fa
--- /dev/null
+++ b/net/mmt/neon/src/ne_openssl.c
@@ -0,0 +1,1272 @@
+/* 
+   neon SSL/TLS support using OpenSSL
+   Copyright (C) 2002-2011, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/pkcs12.h>
+#include <openssl/x509v3.h>
+#include <openssl/rand.h>
+#include <openssl/opensslv.h>
+
+#ifdef NE_HAVE_TS_SSL
+#include <stdlib.h> /* for abort() */
+#ifndef _WIN32
+#include <pthread.h>
+#endif
+#endif
+
+#include "ne_ssl.h"
+#include "ne_string.h"
+#include "ne_session.h"
+#include "ne_internal.h"
+
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+/* OpenSSL 0.9.6 compatibility */
+#if OPENSSL_VERSION_NUMBER < 0x0090700fL
+#define PKCS12_unpack_authsafes M_PKCS12_unpack_authsafes
+#define PKCS12_unpack_p7data M_PKCS12_unpack_p7data
+/* cast away lack of const-ness */
+#define OBJ_cmp(a,b) OBJ_cmp((ASN1_OBJECT *)(a), (ASN1_OBJECT *)(b))
+#endif
+
+/* Second argument for d2i_X509() changed type in 0.9.8. */
+#if OPENSSL_VERSION_NUMBER < 0x0090800fL
+typedef unsigned char ne_d2i_uchar;
+#else
+typedef const unsigned char ne_d2i_uchar;
+#endif
+
+struct ne_ssl_dname_s {
+    X509_NAME *dn;
+};
+
+struct ne_ssl_certificate_s {
+    ne_ssl_dname subj_dn, issuer_dn;
+    X509 *subject;
+    ne_ssl_certificate *issuer;
+    char *identity;
+};
+
+struct ne_ssl_client_cert_s {
+    PKCS12 *p12;
+    int decrypted; /* non-zero if successfully decrypted. */
+    ne_ssl_certificate cert;
+    EVP_PKEY *pkey;
+    char *friendly_name;
+};
+
+#define NE_SSL_UNHANDLED (0x20) /* failure bit for unhandled case. */
+
+/* Append an ASN.1 DirectoryString STR to buffer BUF as UTF-8.
+ * Returns zero on success or non-zero on error. */
+static int append_dirstring(ne_buffer *buf, ASN1_STRING *str)
+{
+    unsigned char *tmp = (unsigned char *)""; /* initialize to workaround 0.9.6 bug */
+    int len;
+
+    switch (str->type) {
+    case V_ASN1_IA5STRING: /* definitely ASCII */
+    case V_ASN1_VISIBLESTRING: /* probably ASCII */
+    case V_ASN1_PRINTABLESTRING: /* subset of ASCII */
+        ne_buffer_qappend(buf, str->data, str->length);
+        break;
+    case V_ASN1_UTF8STRING:
+        /* Fail for embedded NUL bytes. */
+        if (strlen((char *)str->data) != (size_t)str->length) {
+            return -1;
+        }
+        ne_buffer_append(buf, (char *)str->data, str->length);
+        break;
+    case V_ASN1_UNIVERSALSTRING:
+    case V_ASN1_T61STRING: /* let OpenSSL convert it as ISO-8859-1 */
+    case V_ASN1_BMPSTRING: 
+        len = ASN1_STRING_to_UTF8(&tmp, str);
+        if (len > 0) {
+            /* Fail if there were embedded NUL bytes. */
+            if (strlen((char *)tmp) != (size_t)len) {
+                OPENSSL_free(tmp);
+                return -1;
+            } 
+            else {
+                ne_buffer_append(buf, (char *)tmp, len);
+                OPENSSL_free(tmp);
+            }
+            break;
+        } else {
+            ERR_clear_error();
+            return -1;
+        }
+        break;
+    default:
+        NE_DEBUG(NE_DBG_SSL, "Could not convert DirectoryString type %d\n",
+                 str->type);
+        return -1;
+    }
+    return 0;
+}
+
+/* Returns a malloc-allocated version of IA5 string AS, escaped for
+ * safety. */
+static char *dup_ia5string(const ASN1_IA5STRING *as)
+{
+    return ne_strnqdup(as->data, as->length);
+}
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    int n, flag = 0;
+    ne_buffer *dump = ne_buffer_create();
+    const ASN1_OBJECT * const cname = OBJ_nid2obj(NID_commonName),
+	* const email = OBJ_nid2obj(NID_pkcs9_emailAddress);
+
+    for (n = X509_NAME_entry_count(name->dn); n > 0; n--) {
+	X509_NAME_ENTRY *ent = X509_NAME_get_entry(name->dn, n-1);
+	
+        /* Skip commonName or emailAddress except if there is no other
+         * attribute in dname. */
+	if ((OBJ_cmp(ent->object, cname) && OBJ_cmp(ent->object, email)) ||
+            (!flag && n == 1)) {
+ 	    if (flag++)
+		ne_buffer_append(dump, ", ", 2);
+
+            if (append_dirstring(dump, ent->value))
+                ne_buffer_czappend(dump, "???");
+	}
+    }
+
+    return ne_buffer_finish(dump);
+}
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    return X509_NAME_cmp(dn1->dn, dn2->dn);
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *cc)
+{
+    if (cc->p12)
+        PKCS12_free(cc->p12);
+    if (cc->decrypted) {
+        if (cc->cert.identity) ne_free(cc->cert.identity);
+        EVP_PKEY_free(cc->pkey);
+        X509_free(cc->cert.subject);
+    }
+    if (cc->friendly_name) ne_free(cc->friendly_name);
+    ne_free(cc);
+}
+
+/* Format an ASN1 time to a string. 'buf' must be at least of size
+ * 'NE_SSL_VDATELEN'. */
+static time_t asn1time_to_timet(const ASN1_TIME *atm)
+{
+    struct tm tm = {0};
+    int i = atm->length;
+    
+    if (i < 10)
+        return (time_t )-1;
+
+    tm.tm_year = (atm->data[0]-'0') * 10 + (atm->data[1]-'0');
+
+    /* Deal with Year 2000 */
+    if (tm.tm_year < 70)
+        tm.tm_year += 100;
+
+    tm.tm_mon = (atm->data[2]-'0') * 10 + (atm->data[3]-'0') - 1;
+    tm.tm_mday = (atm->data[4]-'0') * 10 + (atm->data[5]-'0');
+    tm.tm_hour = (atm->data[6]-'0') * 10 + (atm->data[7]-'0');
+    tm.tm_min = (atm->data[8]-'0') * 10 + (atm->data[9]-'0');
+    tm.tm_sec = (atm->data[10]-'0') * 10 + (atm->data[11]-'0');
+
+#ifdef HAVE_TIMEZONE
+    /* ANSI C time handling is... interesting. */
+    return mktime(&tm) - timezone;
+#else
+    return mktime(&tm);
+#endif
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until)
+{
+    if (from) {
+        *from = asn1time_to_timet(X509_get_notBefore(cert->subject));
+    }
+    if (until) {
+        *until = asn1time_to_timet(X509_get_notAfter(cert->subject));
+    }
+}
+
+/* Check certificate identity.  Returns zero if identity matches; 1 if
+ * identity does not match, or <0 if the certificate had no identity.
+ * If 'identity' is non-NULL, store the malloc-allocated identity in
+ * *identity.  Logic specified by RFC 2818 and RFC 3280. */
+static int check_identity(const ne_uri *server, X509 *cert, char **identity)
+{
+    STACK_OF(GENERAL_NAME) *names;
+    int match = 0, found = 0;
+    const char *hostname;
+    
+    hostname = server ? server->host : "";
+
+    names = X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
+    if (names) {
+	int n;
+
+        /* subjectAltName contains a sequence of GeneralNames */
+	for (n = 0; n < sk_GENERAL_NAME_num(names) && !match; n++) {
+	    GENERAL_NAME *nm = sk_GENERAL_NAME_value(names, n);
+	    
+            /* handle dNSName and iPAddress name extensions only. */
+	    if (nm->type == GEN_DNS) {
+		char *name = dup_ia5string(nm->d.ia5);
+                if (identity && !found) *identity = ne_strdup(name);
+		match = ne__ssl_match_hostname(name, strlen(name), hostname);
+		ne_free(name);
+		found = 1;
+            } 
+            else if (nm->type == GEN_IPADD) {
+                /* compare IP address with server IP address. */
+                ne_inet_addr *ia;
+                if (nm->d.ip->length == 4)
+                    ia = ne_iaddr_make(ne_iaddr_ipv4, nm->d.ip->data);
+                else if (nm->d.ip->length == 16)
+                    ia = ne_iaddr_make(ne_iaddr_ipv6, nm->d.ip->data);
+                else
+                    ia = NULL;
+                /* ne_iaddr_make returns NULL if address type is unsupported */
+                if (ia != NULL) { /* address type was supported. */
+                    char buf[128];
+
+                    match = strcmp(hostname, 
+                                   ne_iaddr_print(ia, buf, sizeof buf)) == 0;
+                    found = 1;
+                    ne_iaddr_free(ia);
+                } else {
+                    NE_DEBUG(NE_DBG_SSL, "iPAddress name with unsupported "
+                             "address type (length %d), skipped.\n",
+                             nm->d.ip->length);
+                }
+            } 
+            else if (nm->type == GEN_URI) {
+                char *name = dup_ia5string(nm->d.ia5);
+                ne_uri uri;
+
+                if (ne_uri_parse(name, &uri) == 0 && uri.host && uri.scheme) {
+                    ne_uri tmp;
+
+                    if (identity && !found) *identity = ne_strdup(name);
+                    found = 1;
+
+                    if (server) {
+                        /* For comparison purposes, all that matters is
+                         * host, scheme and port; ignore the rest. */
+                        memset(&tmp, 0, sizeof tmp);
+                        tmp.host = uri.host;
+                        tmp.scheme = uri.scheme;
+                        tmp.port = uri.port;
+                        
+                        match = ne_uri_cmp(server, &tmp) == 0;
+                    }
+                }
+
+                ne_uri_free(&uri);
+                ne_free(name);
+            }
+	}
+        /* free the whole stack. */
+        sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
+    }
+    
+    /* Check against the commonName if no DNS alt. names were found,
+     * as per RFC3280. */
+    if (!found) {
+	X509_NAME *subj = X509_get_subject_name(cert);
+	X509_NAME_ENTRY *entry;
+	ne_buffer *cname = ne_buffer_ncreate(30);
+	int idx = -1, lastidx;
+
+	/* find the most specific commonName attribute. */
+	do {
+	    lastidx = idx;
+	    idx = X509_NAME_get_index_by_NID(subj, NID_commonName, lastidx);
+	} while (idx >= 0);
+	
+	if (lastidx < 0) {
+            /* no commonName attributes at all. */
+            ne_buffer_destroy(cname);
+	    return -1;
+        }
+
+	/* extract the string from the entry */
+        entry = X509_NAME_get_entry(subj, lastidx);
+        if (append_dirstring(cname, X509_NAME_ENTRY_get_data(entry))) {
+            ne_buffer_destroy(cname);
+            return -1;
+        }
+        if (identity) *identity = ne_strdup(cname->data);
+        match = ne__ssl_match_hostname(cname->data, cname->used - 1, hostname);
+        ne_buffer_destroy(cname);
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "Identity match for '%s': %s\n", hostname, 
+             match ? "good" : "bad");
+    return match ? 0 : 1;
+}
+
+/* Populate an ne_ssl_certificate structure from an X509 object. */
+static ne_ssl_certificate *populate_cert(ne_ssl_certificate *cert, X509 *x5)
+{
+    cert->subj_dn.dn = X509_get_subject_name(x5);
+    cert->issuer_dn.dn = X509_get_issuer_name(x5);
+    cert->issuer = NULL;
+    cert->subject = x5;
+    /* Retrieve the cert identity; pass a dummy hostname to match. */
+    cert->identity = NULL;
+    check_identity(NULL, x5, &cert->identity);
+    return cert;
+}
+
+/* OpenSSL cert verification callback.  This is invoked for *each*
+ * error which is encoutered whilst verifying the cert chain; multiple
+ * invocations for any particular cert in the chain are possible. */
+static int verify_callback(int ok, X509_STORE_CTX *ctx)
+{
+    /* OpenSSL, living in its own little happy world of global state,
+     * where userdata was just a twinkle in the eye of an API designer
+     * yet to be born.  Or... "Seriously, wtf?"  */
+    SSL *ssl = X509_STORE_CTX_get_ex_data(ctx, 
+                                          SSL_get_ex_data_X509_STORE_CTX_idx());
+    ne_session *sess = SSL_get_app_data(ssl);
+    int depth = X509_STORE_CTX_get_error_depth(ctx);
+    int err = X509_STORE_CTX_get_error(ctx);
+    int failures = 0;
+
+    /* If there's no error, nothing to do here. */
+    if (ok) return ok;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify callback @ %d => %d\n", depth, err);
+
+    /* Map the error code onto any of the exported cert validation
+     * errors, if possible. */
+    switch (err) {
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
+    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
+    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+    case X509_V_ERR_CERT_UNTRUSTED:
+    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
+        failures |= NE_SSL_UNTRUSTED;
+        break;
+    case X509_V_ERR_CERT_NOT_YET_VALID:
+        failures |= depth > 0 ? NE_SSL_BADCHAIN : NE_SSL_NOTYETVALID;
+        break;
+    case X509_V_ERR_CERT_HAS_EXPIRED:
+        failures |= depth > 0 ? NE_SSL_BADCHAIN : NE_SSL_EXPIRED;
+        break;
+    case X509_V_OK:
+        break;
+    default:
+        /* Clear the failures bitmask so check_certificate knows this
+         * is a bailout. */
+        sess->ssl_context->failures |= NE_SSL_UNHANDLED;
+        NE_DEBUG(NE_DBG_SSL, "ssl: Unhandled verification error %d -> %s\n", 
+                 err, X509_verify_cert_error_string(err));
+        return 0;
+    }
+
+    sess->ssl_context->failures |= failures;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify failures |= %d => %d\n", failures,
+             sess->ssl_context->failures);
+    
+    return 1;
+}
+
+/* Return a linked list of certificate objects from an OpenSSL chain. */
+static ne_ssl_certificate *make_chain(STACK_OF(X509) *chain)
+{
+    int n, count = sk_X509_num(chain);
+    ne_ssl_certificate *top = NULL, *current = NULL;
+    
+    NE_DEBUG(NE_DBG_SSL, "Chain depth: %d\n", count);
+
+    for (n = 0; n < count; n++) {
+        ne_ssl_certificate *cert = ne_malloc(sizeof *cert);
+        populate_cert(cert, X509_dup(sk_X509_value(chain, n)));
+#ifdef NE_DEBUGGING
+        if (ne_debug_mask & NE_DBG_SSL) {
+            fprintf(ne_debug_stream, "Cert #%d:\n", n);
+            X509_print_fp(ne_debug_stream, cert->subject);
+        }
+#endif
+        if (top == NULL) {
+            current = top = cert;
+        } else {
+            current->issuer = cert;
+            current = cert;
+        }
+    }
+
+    return top;
+}
+
+/* Verifies an SSL server certificate. */
+static int check_certificate(ne_session *sess, SSL *ssl, ne_ssl_certificate *chain)
+{
+    X509 *cert = chain->subject;
+    int ret, failures = sess->ssl_context->failures;
+    ne_uri server;
+
+    /* If the verification callback hit a case which can't be mapped
+     * to one of the exported error bits, it's treated as a hard
+     * failure rather than invoking the callback, which can't present
+     * a useful error to the user.  "Um, something is wrong.  OK?" */
+    if (failures & NE_SSL_UNHANDLED) {
+        long result = SSL_get_verify_result(ssl);
+
+        ne_set_error(sess, _("Certificate verification error: %s"),
+                    X509_verify_cert_error_string(result));
+
+        return NE_ERROR;
+    }
+
+    /* Check certificate was issued to this server; pass URI of
+     * server. */
+    memset(&server, 0, sizeof server);
+    ne_fill_server_uri(sess, &server);
+    ret = check_identity(&server, cert, NULL);
+    ne_uri_free(&server);
+    if (ret < 0) {
+        ne_set_error(sess, _("Server certificate was missing commonName "
+                             "attribute in subject name"));
+        return NE_ERROR;
+    } else if (ret > 0) failures |= NE_SSL_IDMISMATCH;
+
+    if (failures == 0) {
+        /* verified OK! */
+        ret = NE_OK;
+    } else {
+        /* Set up the error string. */
+        ne__ssl_set_verify_err(sess, failures);
+        ret = NE_ERROR;
+        /* Allow manual override */
+        if (sess->ssl_verify_fn && 
+            sess->ssl_verify_fn(sess->ssl_verify_ud, failures, chain) == 0)
+            ret = NE_OK;
+    }
+
+    return ret;
+}
+
+/* Duplicate a client certificate, which must be in the decrypted state. */
+static ne_ssl_client_cert *dup_client_cert(const ne_ssl_client_cert *cc)
+{
+    ne_ssl_client_cert *newcc = ne_calloc(sizeof *newcc);
+    
+    newcc->decrypted = 1;
+    newcc->pkey = cc->pkey;
+    if (cc->friendly_name)
+        newcc->friendly_name = ne_strdup(cc->friendly_name);
+
+    populate_cert(&newcc->cert, cc->cert.subject);
+
+    cc->cert.subject->references++;
+    cc->pkey->references++;
+    return newcc;
+}
+
+/* Callback invoked when the SSL server requests a client certificate.  */
+static int provide_client_cert(SSL *ssl, X509 **cert, EVP_PKEY **pkey)
+{
+    ne_session *const sess = SSL_get_app_data(ssl);
+
+    if (!sess->client_cert && sess->ssl_provide_fn) {
+	ne_ssl_dname **dnames = NULL, *dnarray = NULL;
+        int n, count = 0;
+	STACK_OF(X509_NAME) *ca_list = SSL_get_client_CA_list(ssl);
+
+        count = ca_list ? sk_X509_NAME_num(ca_list) : 0;
+
+        if (count > 0) {
+            dnames = ne_malloc(count * sizeof(ne_ssl_dname *));
+            dnarray = ne_malloc(count * sizeof(ne_ssl_dname));
+            
+            for (n = 0; n < count; n++) {
+                dnames[n] = &dnarray[n];
+                dnames[n]->dn = sk_X509_NAME_value(ca_list, n);
+            }
+        }
+
+	NE_DEBUG(NE_DBG_SSL, "Calling client certificate provider...\n");
+	sess->ssl_provide_fn(sess->ssl_provide_ud, sess, 
+                             (const ne_ssl_dname *const *)dnames, count);
+        if (count) {
+            ne_free(dnarray);
+            ne_free(dnames);
+        }
+    }
+
+    if (sess->client_cert) {
+        ne_ssl_client_cert *const cc = sess->client_cert;
+	NE_DEBUG(NE_DBG_SSL, "Supplying client certificate.\n");
+	cc->pkey->references++;
+	cc->cert.subject->references++;
+	*cert = cc->cert.subject;
+	*pkey = cc->pkey;
+	return 1;
+    } else {
+        sess->ssl_cc_requested = 1;
+	NE_DEBUG(NE_DBG_SSL, "No client certificate supplied.\n");
+	return 0;
+    }
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc)
+{
+    sess->client_cert = dup_client_cert(cc);
+}
+
+ne_ssl_context *ne_ssl_context_create(int mode)
+{
+    ne_ssl_context *ctx = ne_calloc(sizeof *ctx);
+    if (mode == NE_SSL_CTX_CLIENT) {
+        ctx->ctx = SSL_CTX_new(SSLv23_client_method());
+        ctx->sess = NULL;
+        /* set client cert callback. */
+        SSL_CTX_set_client_cert_cb(ctx->ctx, provide_client_cert);
+        /* enable workarounds for buggy SSL server implementations */
+        SSL_CTX_set_options(ctx->ctx, SSL_OP_ALL);
+        SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_PEER, verify_callback);
+    } else if (mode == NE_SSL_CTX_SERVER) {
+        ctx->ctx = SSL_CTX_new(SSLv23_server_method());
+        SSL_CTX_set_session_cache_mode(ctx->ctx, SSL_SESS_CACHE_CLIENT);
+#ifdef SSL_OP_NO_TICKET
+        /* disable ticket support since it inhibits testing of session
+         * caching. */
+        SSL_CTX_set_options(ctx->ctx, SSL_OP_NO_TICKET);
+#endif
+    } else {
+#ifdef OPENSSL_NO_SSL2
+        ne_free(ctx);
+        return NULL;
+#else
+        ctx->ctx = SSL_CTX_new(SSLv2_server_method());
+        SSL_CTX_set_session_cache_mode(ctx->ctx, SSL_SESS_CACHE_CLIENT);
+#endif
+    }
+    return ctx;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value)
+{
+    long opts = SSL_CTX_get_options(ctx->ctx);
+
+    switch (flag) {
+    case NE_SSL_CTX_SSLv2:
+        if (value) { 
+            /* Enable SSLv2 support; clear the "no SSLv2" flag. */
+            opts &= ~SSL_OP_NO_SSLv2;
+        } else {
+            /* Disable it: set the flag. */
+            opts |= SSL_OP_NO_SSLv2;
+        }
+        break;
+    }
+
+    SSL_CTX_set_options(ctx->ctx, opts);
+}
+
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag)
+{
+    switch (flag) {
+    case NE_SSL_CTX_SSLv2:
+#ifdef OPENSSL_NO_SSL2
+        return 0;
+#else
+        return ! (SSL_CTX_get_options(ctx->ctx) & SSL_OP_NO_SSLv2);
+#endif
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+int ne_ssl_context_keypair(ne_ssl_context *ctx, const char *cert,
+                           const char *key)
+{
+    int ret;
+
+    ret = SSL_CTX_use_PrivateKey_file(ctx->ctx, key, SSL_FILETYPE_PEM);
+    if (ret == 1) {
+        ret = SSL_CTX_use_certificate_chain_file(ctx->ctx, cert);
+    }
+
+    return ret == 1 ? 0 : -1;
+}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, 
+                              int required,
+                              const char *ca_names,
+                              const char *verify_cas)
+{
+    if (required) {
+        SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_PEER | 
+                           SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
+    }
+    if (ca_names) {
+        SSL_CTX_set_client_CA_list(ctx->ctx, 
+                                   SSL_load_client_CA_file(ca_names));
+    }
+    if (verify_cas) {
+        SSL_CTX_load_verify_locations(ctx->ctx, verify_cas, NULL);
+    }
+    return 0;
+}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx)
+{
+    SSL_CTX_free(ctx->ctx);
+    if (ctx->sess)
+        SSL_SESSION_free(ctx->sess);
+    ne_free(ctx);
+}
+
+#if !defined(HAVE_SSL_SESSION_CMP) && !defined(SSL_SESSION_cmp) \
+    && defined(OPENSSL_VERSION_NUMBER) \
+    && OPENSSL_VERSION_NUMBER > 0x10000000L
+/* OpenSSL 1.0 removed SSL_SESSION_cmp for no apparent reason - hoping
+ * it is reasonable to assume that comparing the session IDs is
+ * sufficient. */
+static int SSL_SESSION_cmp(SSL_SESSION *a, SSL_SESSION *b)
+{
+    return a->session_id_length == b->session_id_length
+        && memcmp(a->session_id, b->session_id, a->session_id_length) == 0;
+}
+#endif
+
+/* For internal use only. */
+int ne__negotiate_ssl(ne_session *sess)
+{
+    ne_ssl_context *ctx = sess->ssl_context;
+    SSL *ssl;
+    STACK_OF(X509) *chain;
+    int freechain = 0; /* non-zero if chain should be free'd. */
+
+    NE_DEBUG(NE_DBG_SSL, "Doing SSL negotiation.\n");
+    
+    /* Pass through the hostname if SNI is enabled. */
+    ctx->hostname = 
+        sess->flags[NE_SESSFLAG_TLS_SNI] ? sess->server.hostname : NULL;
+
+    sess->ssl_cc_requested = 0;
+    ctx->failures = 0;
+
+    if (ne_sock_connect_ssl(sess->socket, ctx, sess)) {
+	if (ctx->sess) {
+	    /* remove cached session. */
+	    SSL_SESSION_free(ctx->sess);
+	    ctx->sess = NULL;
+	}
+        if (sess->ssl_cc_requested) {
+            ne_set_error(sess, _("SSL handshake failed, "
+                                 "client certificate was requested: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        else {
+            ne_set_error(sess, _("SSL handshake failed: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        return NE_ERROR;
+    }	
+    
+    ssl = ne__sock_sslsock(sess->socket);
+
+    chain = SSL_get_peer_cert_chain(ssl);
+    /* For an SSLv2 connection, the cert chain will always be NULL. */
+    if (chain == NULL) {
+        X509 *cert = SSL_get_peer_certificate(ssl);
+        if (cert) {
+            chain = sk_X509_new_null();
+            sk_X509_push(chain, cert);
+            freechain = 1;
+        }
+    }
+
+    if (chain == NULL || sk_X509_num(chain) == 0) {
+	ne_set_error(sess, _("SSL server did not present certificate"));
+	return NE_ERROR;
+    }
+
+    if (sess->server_cert) {
+        int diff = X509_cmp(sk_X509_value(chain, 0), sess->server_cert->subject);
+        if (freechain) sk_X509_free(chain); /* no longer need the chain */
+	if (diff) {
+	    /* This could be a MITM attack: fail the request. */
+	    ne_set_error(sess, _("Server certificate changed: "
+				 "connection intercepted?"));
+	    return NE_ERROR;
+	} 
+	/* certificate has already passed verification: no need to
+	 * verify it again. */
+    } else {
+	/* new connection: create the chain. */
+        ne_ssl_certificate *cert = make_chain(chain);
+
+        if (freechain) sk_X509_free(chain); /* no longer need the chain */
+
+	if (check_certificate(sess, ssl, cert)) {
+	    NE_DEBUG(NE_DBG_SSL, "SSL certificate checks failed: %s\n",
+		     sess->error);
+	    ne_ssl_cert_free(cert);
+	    return NE_ERROR;
+	}
+	/* remember the chain. */
+        sess->server_cert = cert;
+    }
+    
+    if (ctx->sess) {
+        SSL_SESSION *newsess = SSL_get0_session(ssl);
+        /* Replace the session if it has changed. */ 
+        if (newsess != ctx->sess || SSL_SESSION_cmp(ctx->sess, newsess)) {
+            SSL_SESSION_free(ctx->sess);
+            ctx->sess = SSL_get1_session(ssl); /* bumping the refcount */
+        }
+    } else {
+	/* Store the session. */
+	ctx->sess = SSL_get1_session(ssl);
+    }
+
+    return NE_OK;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return &cert->issuer_dn;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return &cert->subj_dn;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{
+    return cert->issuer;
+}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return cert->identity;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{
+    X509_STORE *store = SSL_CTX_get_cert_store(ctx->ctx);
+    
+    X509_STORE_add_cert(store, cert->subject);
+}
+
+void ne_ssl_trust_default_ca(ne_session *sess)
+{
+    X509_STORE *store = SSL_CTX_get_cert_store(sess->ssl_context->ctx);
+    
+#ifdef NE_SSL_CA_BUNDLE
+    X509_STORE_load_locations(store, NE_SSL_CA_BUNDLE, NULL);
+#else
+    X509_STORE_set_default_paths(store);
+#endif
+}
+
+/* Find a friendly name in a PKCS12 structure the hard way, without
+ * decrypting the parts which are encrypted.. */
+static char *find_friendly_name(PKCS12 *p12)
+{
+    STACK_OF(PKCS7) *safes = PKCS12_unpack_authsafes(p12);
+    int n, m;
+    char *name = NULL;
+
+    if (safes == NULL) return NULL;
+    
+    /* Iterate over the unpacked authsafes: */
+    for (n = 0; n < sk_PKCS7_num(safes) && !name; n++) {
+        PKCS7 *safe = sk_PKCS7_value(safes, n);
+        STACK_OF(PKCS12_SAFEBAG) *bags;
+    
+        /* Only looking for unencrypted authsafes. */
+        if (OBJ_obj2nid(safe->type) != NID_pkcs7_data) continue;
+
+        bags = PKCS12_unpack_p7data(safe);
+        if (!bags) continue;
+
+        /* Iterate through the bags, picking out a friendly name */
+        for (m = 0; m < sk_PKCS12_SAFEBAG_num(bags) && !name; m++) {
+            PKCS12_SAFEBAG *bag = sk_PKCS12_SAFEBAG_value(bags, m);
+            name = PKCS12_get_friendlyname(bag);
+        }
+    
+        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
+    }
+
+    sk_PKCS7_pop_free(safes, PKCS7_free);
+    return name;
+}
+
+static ne_ssl_client_cert *parse_client_cert(PKCS12 *p12)
+{
+    X509 *cert;
+    EVP_PKEY *pkey;
+    ne_ssl_client_cert *cc;
+
+    if (p12 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+
+    /* Try parsing with no password. */
+    if (PKCS12_parse(p12, NULL, &pkey, &cert, NULL) == 1) {
+        /* Success - no password needed for decryption. */
+        int len = 0;
+        unsigned char *name;
+
+        if (!cert || !pkey) {
+            PKCS12_free(p12);
+            return NULL;
+        }
+
+        name = X509_alias_get0(cert, &len);
+        
+        cc = ne_calloc(sizeof *cc);
+        cc->pkey = pkey;
+        cc->decrypted = 1;
+        if (name && len > 0)
+            cc->friendly_name = ne_strndup((char *)name, len);
+        populate_cert(&cc->cert, cert);
+        PKCS12_free(p12);
+        return cc;
+    } else {
+        /* Failed to parse the file */
+        int err = ERR_get_error();
+        ERR_clear_error();
+        if (ERR_GET_LIB(err) == ERR_LIB_PKCS12 &&
+            ERR_GET_REASON(err) == PKCS12_R_MAC_VERIFY_FAILURE) {
+            /* Decryption error due to bad password. */
+            cc = ne_calloc(sizeof *cc);
+            cc->friendly_name = find_friendly_name(p12);
+            cc->p12 = p12;
+            return cc;
+        } else {
+            /* Some parse error, give up. */
+            PKCS12_free(p12);
+            return NULL;
+        }
+    }
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, 
+                                          size_t buflen)
+{
+    ne_d2i_uchar *p;
+    PKCS12 *p12;
+
+    p = buffer;
+    p12 = d2i_PKCS12(NULL, &p, buflen);
+    
+    return parse_client_cert(p12);
+}
+    
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    PKCS12 *p12;
+    FILE *fp;
+
+    fp = fopen(filename, "rb");
+    if (fp == NULL)
+        return NULL;
+
+    p12 = d2i_PKCS12_fp(fp, NULL);
+
+    fclose(fp);
+
+    return parse_client_cert(p12);
+}
+
+#ifdef HAVE_PAKCHOIS
+ne_ssl_client_cert *ne__ssl_clicert_exkey_import(const unsigned char *der,
+                                                 size_t der_len,
+                                                 const RSA_METHOD *method)
+{
+    ne_ssl_client_cert *cc;
+    ne_d2i_uchar *p;
+    X509 *x5;
+    RSA *pk;    
+    EVP_PKEY *epk, *tpk;
+
+    p = der;
+    x5 = d2i_X509(NULL, &p, der_len); /* p is incremented */
+    if (x5 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+    
+    pk = RSA_new();
+    RSA_set_method(pk, method);
+    epk = EVP_PKEY_new();
+    EVP_PKEY_assign_RSA(epk, pk);
+    
+    /* It is necessary to initialize pk->n otherwise OpenSSL will barf
+     * later calling RSA_size() on this RSA structure.
+     * X509_get_pubkey() forces the relevant RSA parameters to be
+     * extracted from the certificate. */
+    tpk = X509_get_pubkey(x5);
+    pk->n = BN_dup(tpk->pkey.rsa->n);
+    EVP_PKEY_free(tpk);
+
+    cc = ne_calloc(sizeof *cc);
+    
+    cc->decrypted = 1;
+    cc->pkey = epk;
+
+    populate_cert(&cc->cert, x5);
+
+    return cc;    
+}
+#endif
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *cc)
+{
+    return !cc->decrypted;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *cc, const char *password)
+{
+    X509 *cert;
+    EVP_PKEY *pkey;
+
+    if (PKCS12_parse(cc->p12, password, &pkey, &cert, NULL) != 1) {
+        ERR_clear_error();
+        return -1;
+    }
+    
+    if (X509_check_private_key(cert, pkey) != 1) {
+        ERR_clear_error();
+        X509_free(cert);
+        EVP_PKEY_free(pkey);
+        NE_DEBUG(NE_DBG_SSL, "Decrypted private key/cert are not matched.");
+        return -1;
+    }
+
+    PKCS12_free(cc->p12);
+    populate_cert(&cc->cert, cert);
+    cc->pkey = pkey;
+    cc->decrypted = 1;
+    cc->p12 = NULL;
+    return 0;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *cc)
+{
+    return &cc->cert;
+}
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return ccert->friendly_name;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    FILE *fp = fopen(filename, "r");
+    X509 *cert;
+
+    if (fp == NULL)
+        return NULL;
+
+    cert = PEM_read_X509(fp, NULL, NULL, NULL);
+    fclose(fp);
+
+    if (cert == NULL) {
+        NE_DEBUG(NE_DBG_SSL, "d2i_X509_fp failed: %s\n", 
+                 ERR_reason_error_string(ERR_get_error()));
+        ERR_clear_error();
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), cert);
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    FILE *fp = fopen(filename, "w");
+
+    if (fp == NULL) return -1;
+
+    if (PEM_write_X509(fp, cert->subject) != 1) {
+        ERR_clear_error();
+        fclose(fp);
+        return -1;
+    }
+    
+    if (fclose(fp) != 0)
+        return -1;
+
+    return 0;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert)
+{
+    X509_free(cert->subject);
+    if (cert->issuer)
+        ne_ssl_cert_free(cert->issuer);
+    if (cert->identity)
+        ne_free(cert->identity);
+    ne_free(cert);
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    return X509_cmp(c1->subject, c2->subject);
+}
+
+/* The certificate import/export format is the base64 encoding of the
+ * raw DER; PEM without the newlines and wrapping. */
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    unsigned char *der;
+    ne_d2i_uchar *p;
+    size_t len;
+    X509 *x5;
+    
+    /* decode the base64 to get the raw DER representation */
+    len = ne_unbase64(data, &der);
+    if (len == 0) return NULL;
+
+    p = der;
+    x5 = d2i_X509(NULL, &p, len); /* p is incremented */
+    ne_free(der);
+    if (x5 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    int len;
+    unsigned char *der, *p;
+    char *ret;
+    
+    /* find the length of the DER encoding. */
+    len = i2d_X509(cert->subject, NULL);
+
+    p = der = ne_malloc(len);
+    i2d_X509(cert->subject, &p); /* p is incremented */
+
+    ret = ne_base64(der, len);
+    ne_free(der);
+    return ret;
+}
+
+#if SHA_DIGEST_LENGTH != 20
+# error SHA digest length is not 20 bytes
+#endif
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest)
+{
+    unsigned char sha1[EVP_MAX_MD_SIZE];
+    unsigned int len, j;
+    char *p;
+
+    if (!X509_digest(cert->subject, EVP_sha1(), sha1, &len) || len != 20) {
+        ERR_clear_error();
+        return -1;
+    }
+    
+    for (j = 0, p = digest; j < 20; j++) {
+        *p++ = NE_HEX2ASC((sha1[j] >> 4) & 0x0f);
+        *p++ = NE_HEX2ASC(sha1[j] & 0x0f);
+        *p++ = ':';
+    }
+
+    p[-1] = '\0';
+    return 0;
+}
+
+#ifdef NE_HAVE_TS_SSL
+/* Implementation of locking callbacks to make OpenSSL thread-safe.
+ * If the OpenSSL API was better designed, this wouldn't be necessary.
+ * In OpenSSL releases without CRYPTO_set_idptr_callback, it's not
+ * possible to implement the locking in a POSIX-compliant way, since
+ * it's necessary to cast from a pthread_t to an unsigned long at some
+ * point.  */
+
+#ifndef _WIN32
+static pthread_mutex_t *locks;
+#else
+static HANDLE *locks;
+#endif
+static size_t num_locks;
+
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+/* Named to be obvious when it shows up in a backtrace. */
+static unsigned long thread_id_neon(void)
+{
+#ifndef _WIN32
+    /* This will break if pthread_t is a structure; upgrading OpenSSL
+     * >= 0.9.9 (which does not require this callback) is the only
+     * solution.  */
+    return (unsigned long) pthread_self();
+#else
+    return (unsigned long) GetCurrentThreadId();
+#endif
+}
+#endif
+
+/* Another great API design win for OpenSSL: no return value!  So if
+ * the lock/unlock fails, all that can be done is to abort. */
+static void thread_lock_neon(int mode, int n, const char *file, int line)
+{
+    if (mode & CRYPTO_LOCK) {
+#ifndef _WIN32
+        if (pthread_mutex_lock(&locks[n])) {
+#else
+        if (WaitForSingleObject(locks[n], INFINITE)) {
+#endif
+            abort();
+        }
+    }
+    else {
+#ifndef _WIN32
+        if (pthread_mutex_unlock(&locks[n])) {
+#else
+        if (!ReleaseMutex(locks[n])) {
+#endif
+            abort();
+        }
+    }
+}
+
+#endif
+
+/* ID_CALLBACK_IS_{NEON,OTHER} evaluate as true if the currently
+ * registered OpenSSL ID callback is the neon function (_NEON), or has
+ * been overwritten by some other app (_OTHER). */
+#ifdef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+#define ID_CALLBACK_IS_OTHER (0)
+#define ID_CALLBACK_IS_NEON (1)
+#else
+#define ID_CALLBACK_IS_OTHER (CRYPTO_get_id_callback() != NULL)
+#define ID_CALLBACK_IS_NEON (CRYPTO_get_id_callback() == thread_id_neon)
+#endif
+
+int ne__ssl_init(void)
+{
+    CRYPTO_malloc_init();
+    SSL_load_error_strings();
+    SSL_library_init();
+    OpenSSL_add_all_algorithms();
+
+#ifdef NE_HAVE_TS_SSL
+    /* If some other library has already come along and set up the
+     * thread-safety callbacks, then it must be presumed that the
+     * other library will have a longer lifetime in the process than
+     * neon.  If the library which has installed the callbacks is
+     * unloaded, then all bets are off. */
+    if (ID_CALLBACK_IS_OTHER || CRYPTO_get_locking_callback() != NULL) {
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: OpenSSL thread-safety callbacks already installed.\n");
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: neon will not replace existing callbacks.\n");
+    } else {
+        size_t n;
+
+        num_locks = CRYPTO_num_locks();
+
+        /* For releases where CRYPTO_set_idptr_callback is present,
+         * the default ID callback should be sufficient. */
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+        CRYPTO_set_id_callback(thread_id_neon);
+#endif
+        CRYPTO_set_locking_callback(thread_lock_neon);
+
+        locks = malloc(num_locks * sizeof *locks);
+        for (n = 0; n < num_locks; n++) {
+#ifndef _WIN32
+            if (pthread_mutex_init(&locks[n], NULL)) {
+#else
+            if ((locks[n] = CreateMutex(NULL, FALSE, NULL)) == NULL) {
+#endif
+                NE_DEBUG(NE_DBG_SOCKET, "ssl: Failed to initialize pthread mutex.\n");
+                return -1;
+            }
+        }
+        
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: Initialized OpenSSL thread-safety callbacks "
+                 "for %" NE_FMT_SIZE_T " locks.\n", num_locks);
+    }
+#endif
+
+    return 0;
+}
+
+void ne__ssl_exit(void)
+{
+    /* Cannot call ERR_free_strings() etc here in case any other code
+     * in the process using OpenSSL. */
+
+#ifdef NE_HAVE_TS_SSL
+    /* Only unregister the callbacks if some *other* library has not
+     * come along in the mean-time and trampled over the callbacks
+     * installed by neon. */
+    if (CRYPTO_get_locking_callback() == thread_lock_neon
+        && ID_CALLBACK_IS_NEON) {
+        size_t n;
+
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+        CRYPTO_set_id_callback(NULL);
+#endif
+        CRYPTO_set_locking_callback(NULL);
+
+        for (n = 0; n < num_locks; n++) {
+#ifndef _WIN32
+            pthread_mutex_destroy(&locks[n]);
+#else
+            CloseHandle(locks[n]);
+#endif
+        }
+
+        free(locks);
+    }
+#endif
+}
diff --git a/net/mmt/neon/src/ne_pkcs11.c b/net/mmt/neon/src/ne_pkcs11.c
new file mode 100644
index 0000000..69875b6
--- /dev/null
+++ b/net/mmt/neon/src/ne_pkcs11.c
@@ -0,0 +1,625 @@
+/*
+   neon PKCS#11 support
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include "ne_pkcs11.h"
+
+#ifdef HAVE_PAKCHOIS
+#include <string.h>
+
+#include <pakchois.h>
+
+#include "ne_internal.h"
+#include "ne_alloc.h"
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+struct ne_ssl_pkcs11_provider_s {
+    pakchois_module_t *module;
+    ne_ssl_pkcs11_pin_fn pin_fn;
+    void *pin_data;
+    pakchois_session_t *session;
+    ne_ssl_client_cert *clicert;
+    ck_object_handle_t privkey;
+    ck_key_type_t keytype;
+};
+
+/* To do list for PKCS#11 support:
+
+   - propagate error strings back to ne_session; use new 
+   pakchois_error() for pakchois API 0.2
+   - add API to specify a particular slot number to use for clicert
+   - add API to specify a particular cert ID for clicert
+   - find a certificate which has an issuer matching the 
+     CA dnames given by GnuTLS
+   - make sure subject name matches between pubkey and privkey
+   - check error handling & fail gracefully if the token is 
+   ejected mid-session
+   - add API to enumerate/search provided certs and allow 
+     direct choice? (or just punt)
+   - the session<->provider interface requires that 
+   one clicert is used for all sessions.  remove this limitation
+   - add API to import all CA certs as trusted
+   (CKA_CERTIFICATE_CATEGORY seems to be unused unfortunately; 
+    just add all X509 certs with CKA_TRUSTED set to true))
+   - make DSA work
+
+*/
+
+#ifdef HAVE_OPENSSL
+
+#include <openssl/rsa.h>
+#include <openssl/err.h>
+
+#define PK11_RSA_ERR (RSA_F_RSA_EAY_PRIVATE_ENCRYPT)
+
+/* RSA_METHOD ->rsa_sign calback. */
+static int pk11_rsa_sign(int type,
+                         const unsigned char *m, unsigned int mlen,
+                         unsigned char *sigret, unsigned int *siglen, 
+                         const RSA *r)
+{
+    ne_ssl_pkcs11_provider *prov = (ne_ssl_pkcs11_provider *)r->meth->app_data;
+    ck_rv_t rv;
+    struct ck_mechanism mech;
+    unsigned long len;
+
+    if (!prov->session || prov->privkey == CK_INVALID_HANDLE) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Cannot sign, no session/key.\n");
+        RSAerr(PK11_RSA_ERR,ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    mech.mechanism = CKM_RSA_PKCS;
+    mech.parameter = NULL;
+    mech.parameter_len = 0;
+
+    /* Initialize signing operation; using the private key discovered
+     * earlier. */
+    rv = pakchois_sign_init(prov->session, &mech, prov->privkey);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: SignInit failed: %lx.\n", rv);
+        RSAerr(PK11_RSA_ERR, ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    len = *siglen = RSA_size(r);
+    rv = pakchois_sign(prov->session, (unsigned char *)m, mlen, sigret, &len);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign failed.\n");
+        RSAerr(PK11_RSA_ERR, ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Signed successfully.\n");
+    return 1;
+}
+
+/* RSA_METHOD ->rsa_init implementation; called during RSA_new(rsa). */
+static int pk11_rsa_init(RSA *rsa)
+{
+    /* Ensures that RSA_sign() uses meth->rsa_sign: */
+    rsa->flags |= RSA_FLAG_SIGN_VER;
+    return 1;
+}
+
+/* RSA_METHOD ->rsa_finish implementation; called during
+ * RSA_free(rsa). */
+static int pk11_rsa_finish(RSA *rsa)
+{
+    RSA_METHOD *meth = (RSA_METHOD *)rsa->meth;
+
+    /* Freeing the dynamically allocated method here works as well as
+     * doing anything else: */
+    ne_free(meth);
+    /* Does not appear that rsa->meth will be used after this, but in
+     * case it is, ensure a NULL pointer dereference rather than a
+     * random pointer dereference. */
+    rsa->meth = NULL;
+
+    return 0;
+}
+
+/* Return an RSA_METHOD which will use the PKCS#11 provider to
+ * implement the signing operation. */
+static RSA_METHOD *pk11_rsa_method(ne_ssl_pkcs11_provider *prov)
+{
+    RSA_METHOD *m = ne_calloc(sizeof *m);
+
+    m->name = "neon PKCS#11";
+    m->rsa_sign = pk11_rsa_sign;
+    
+    m->init = pk11_rsa_init;
+    m->finish = pk11_rsa_finish;
+    
+    /* This is hopefully under complete control of the RSA_METHOD,
+     * otherwise there is nowhere to put this. */
+    m->app_data = (char *)prov;
+
+    m->flags = RSA_METHOD_FLAG_NO_CHECK;
+    
+    return m;    
+}
+#endif
+
+static int pk11_find_x509(ne_ssl_pkcs11_provider *prov,
+                          pakchois_session_t *pks, 
+                          unsigned char *certid, unsigned long *cid_len)
+{
+    struct ck_attribute a[3];
+    ck_object_class_t class;
+    ck_certificate_type_t type;
+    ck_rv_t rv;
+    ck_object_handle_t obj;
+    unsigned long count;
+    int found = 0;
+
+    /* Find objects with cert class and X.509 cert type. */
+    class = CKO_CERTIFICATE;
+    type = CKC_X_509;
+
+    a[0].type = CKA_CLASS;
+    a[0].value = &class;
+    a[0].value_len = sizeof class;
+    a[1].type = CKA_CERTIFICATE_TYPE;
+    a[1].value = &type;
+    a[1].value_len = sizeof type;
+
+    rv = pakchois_find_objects_init(pks, a, 2);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: FindObjectsInit failed.\n");
+        return 0;
+    }
+
+    while (pakchois_find_objects(pks, &obj, 1, &count) == CKR_OK
+           && count == 1) {
+        unsigned char value[8192], subject[8192];
+
+        a[0].type = CKA_VALUE;
+        a[0].value = value;
+        a[0].value_len = sizeof value;
+        a[1].type = CKA_ID;
+        a[1].value = certid;
+        a[1].value_len = *cid_len;
+        a[2].type = CKA_SUBJECT;
+        a[2].value = subject;
+        a[2].value_len = sizeof subject;
+
+        if (pakchois_get_attribute_value(pks, obj, a, 3) == CKR_OK) {
+            ne_ssl_client_cert *cc;
+            
+#ifdef HAVE_GNUTLS
+            cc = ne__ssl_clicert_exkey_import(value, a[0].value_len);
+#else
+            cc = ne__ssl_clicert_exkey_import(value, a[0].value_len, pk11_rsa_method(prov));
+#endif
+            if (cc) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: Imported X.509 cert.\n");
+                prov->clicert = cc;
+                found = 1;
+                *cid_len = a[1].value_len;
+                break;
+            }
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Skipped cert, missing attrs.\n");
+        }
+    }
+
+    pakchois_find_objects_final(pks);
+    return found;    
+}
+
+#ifdef HAVE_OPENSSL
+/* No DSA support for OpenSSL (yet, anyway). */
+#define KEYTYPE_IS_DSA(kt) (0)
+#else
+#define KEYTYPE_IS_DSA(kt) (kt == CKK_DSA)
+#endif
+
+static int pk11_find_pkey(ne_ssl_pkcs11_provider *prov, 
+                          pakchois_session_t *pks,
+                          unsigned char *certid, unsigned long cid_len)
+{
+    struct ck_attribute a[3];
+    ck_object_class_t class;
+    ck_rv_t rv;
+    ck_object_handle_t obj;
+    unsigned long count;
+    int found = 0;
+
+    class = CKO_PRIVATE_KEY;
+
+    /* Find an object with private key class and a certificate ID
+     * which matches the certificate. */
+    /* FIXME: also match the cert subject. */
+    a[0].type = CKA_CLASS;
+    a[0].value = &class;
+    a[0].value_len = sizeof class;
+    a[1].type = CKA_ID;
+    a[1].value = certid;
+    a[1].value_len = cid_len;
+
+    rv = pakchois_find_objects_init(pks, a, 2);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: FindObjectsInit failed.\n");
+        /* TODO: error propagation */
+        return 0;
+    }
+
+    rv = pakchois_find_objects(pks, &obj, 1, &count);
+    if (rv == CKR_OK && count == 1) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Found private key.\n");
+
+        a[0].type = CKA_KEY_TYPE;
+        a[0].value = &prov->keytype;
+        a[0].value_len = sizeof prov->keytype;
+
+        if (pakchois_get_attribute_value(pks, obj, a, 1) == CKR_OK
+            && (prov->keytype == CKK_RSA || KEYTYPE_IS_DSA(prov->keytype))) {
+            found = 1;
+            prov->privkey = obj;
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Could not determine key type.\n");
+        }
+    }
+
+    pakchois_find_objects_final(pks);
+
+    return found;
+}
+
+static int find_client_cert(ne_ssl_pkcs11_provider *prov,
+                            pakchois_session_t *pks)
+{
+    unsigned char certid[8192];
+    unsigned long cid_len = sizeof certid;
+
+    /* TODO: match cert subject too. */
+    return pk11_find_x509(prov, pks, certid, &cid_len) 
+        && pk11_find_pkey(prov, pks, certid, cid_len);
+}
+
+#ifdef HAVE_GNUTLS
+/* Callback invoked by GnuTLS to provide the signature.  The signature
+ * operation is handled here by the PKCS#11 provider.  */
+static int pk11_sign_callback(gnutls_session_t session,
+                              void *userdata,
+                              gnutls_certificate_type_t cert_type,
+                              const gnutls_datum_t *cert,
+                              const gnutls_datum_t *hash,
+                              gnutls_datum_t *signature)
+{
+    ne_ssl_pkcs11_provider *prov = userdata;
+    ck_rv_t rv;
+    struct ck_mechanism mech;
+    unsigned long siglen;
+
+    if (!prov->session || prov->privkey == CK_INVALID_HANDLE) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Cannot sign, no session/key.\n");
+        return GNUTLS_E_NO_CERTIFICATE_FOUND;
+    }
+
+    mech.mechanism = prov->keytype == CKK_DSA ? CKM_DSA : CKM_RSA_PKCS;
+    mech.parameter = NULL;
+    mech.parameter_len = 0;
+
+    /* Initialize signing operation; using the private key discovered
+     * earlier. */
+    rv = pakchois_sign_init(prov->session, &mech, prov->privkey);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: SignInit failed: %lx.\n", rv);
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    /* Work out how long the signature must be: */
+    rv = pakchois_sign(prov->session, hash->data, hash->size, NULL, &siglen);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign1 failed.\n");
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    signature->data = gnutls_malloc(siglen);
+    signature->size = siglen;
+
+    rv = pakchois_sign(prov->session, hash->data, hash->size, 
+                       signature->data, &siglen);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign2 failed.\n");
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Signed successfully.\n");
+
+    return 0;
+}
+#endif
+
+static void terminate_string(unsigned char *str, size_t len)
+{
+    unsigned char *ptr = str + len - 1;
+
+    while ((*ptr == ' ' || *ptr == '\t' || *ptr == '\0') && ptr >= str)
+        ptr--;
+    
+    if (ptr == str - 1)
+        str[0] = '\0';
+    else if (ptr == str + len - 1)
+        str[len-1] = '\0';
+    else
+        ptr[1] = '\0';
+}
+
+static int pk11_login(ne_ssl_pkcs11_provider *prov, ck_slot_id_t slot_id,
+                      pakchois_session_t *pks, struct ck_slot_info *sinfo)
+{
+    struct ck_token_info tinfo;
+    int attempt = 0;
+    ck_rv_t rv;
+
+    if (pakchois_get_token_info(prov->module, slot_id, &tinfo) != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: GetTokenInfo failed\n");
+        /* TODO: propagate error. */
+        return -1;
+    }
+
+    if ((tinfo.flags & CKF_LOGIN_REQUIRED) == 0) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No login required.\n");
+        return 0;
+    }
+
+    /* For a token with a "protected" (out-of-band) authentication
+     * path, calling login with a NULL username is all that is
+     * required. */
+    if (tinfo.flags & CKF_PROTECTED_AUTHENTICATION_PATH) {
+        if (pakchois_login(pks, CKU_USER, NULL, 0) == CKR_OK) {
+            return 0;
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Protected login failed.\n");
+            /* TODO: error propagation. */
+            return -1;
+        }
+    }
+
+    /* Otherwise, PIN entry is necessary for login, so fail if there's
+     * no callback. */
+    if (!prov->pin_fn) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No pin callback but login required.\n");
+        /* TODO: propagate error. */
+        return -1;
+    }
+
+    terminate_string(sinfo->slot_description, sizeof sinfo->slot_description);
+
+    do {
+        char pin[NE_SSL_P11PINLEN];
+        unsigned int flags = 0;
+
+        /* If login has been attempted once already, check the token
+         * status again, the flags might change. */
+        if (attempt) {
+            if (pakchois_get_token_info(prov->module, slot_id, 
+                                        &tinfo) != CKR_OK) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: GetTokenInfo failed\n");
+                /* TODO: propagate error. */
+                return -1;
+            }
+        }
+
+        if (tinfo.flags & CKF_USER_PIN_COUNT_LOW)
+            flags |= NE_SSL_P11PIN_COUNT_LOW;
+        if (tinfo.flags & CKF_USER_PIN_FINAL_TRY)
+            flags |= NE_SSL_P11PIN_FINAL_TRY;
+        
+        terminate_string(tinfo.label, sizeof tinfo.label);
+
+        if (prov->pin_fn(prov->pin_data, attempt++,
+                         (char *)sinfo->slot_description,
+                         (char *)tinfo.label, flags, pin)) {
+            return -1;
+        }
+
+        rv = pakchois_login(pks, CKU_USER, (unsigned char *)pin, strlen(pin));
+        
+        /* Try to scrub the pin off the stack.  Clever compilers will
+         * probably optimize this away, oh well. */
+        memset(pin, 0, sizeof pin);
+    } while (rv == CKR_PIN_INCORRECT);
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Login result = %lu\n", rv);
+
+    return (rv == CKR_OK || rv == CKR_USER_ALREADY_LOGGED_IN) ? 0 : -1;
+}
+
+static void pk11_provide(void *userdata, ne_session *sess,
+                         const ne_ssl_dname *const *dnames,
+                         int dncount)
+{
+    ne_ssl_pkcs11_provider *prov = userdata;
+    ck_slot_id_t *slots;
+    unsigned long scount, n;
+
+    if (prov->clicert) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Using existing clicert.\n");
+        ne_ssl_set_clicert(sess, prov->clicert);
+        return;
+    }
+
+    if (pakchois_get_slot_list(prov->module, 1, NULL, &scount) != CKR_OK
+        || scount == 0) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No slots.\n");
+        /* TODO: propagate error. */
+        return;
+    }
+
+    slots = ne_malloc(scount * sizeof *slots);
+    if (pakchois_get_slot_list(prov->module, 1, slots, &scount) != CKR_OK)  {
+        ne_free(slots);
+        NE_DEBUG(NE_DBG_SSL, "pk11: Really, no slots?\n");
+        /* TODO: propagate error. */
+        return;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Found %ld slots.\n", scount);
+
+    for (n = 0; n < scount; n++) {
+        pakchois_session_t *pks;
+        ck_rv_t rv;
+        struct ck_slot_info sinfo;
+
+        if (pakchois_get_slot_info(prov->module, slots[n], &sinfo) != CKR_OK) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: GetSlotInfo failed\n");
+            continue;
+        }
+
+        if ((sinfo.flags & CKF_TOKEN_PRESENT) == 0) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: slot empty, ignoring\n");
+            continue;
+        }
+        
+        rv = pakchois_open_session(prov->module, slots[n], 
+                                   CKF_SERIAL_SESSION,
+                                   NULL, NULL, &pks);
+        if (rv != CKR_OK) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: could not open slot, %ld (%ld: %ld)\n", 
+                     rv, n, slots[n]);
+            continue;
+        }
+
+        if (pk11_login(prov, slots[n], pks, &sinfo) == 0) {
+            if (find_client_cert(prov, pks)) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: Setup complete.\n");
+                prov->session = pks;
+                ne_ssl_set_clicert(sess, prov->clicert);
+                ne_free(slots);
+                return;
+            }
+        }
+
+        pakchois_close_session(pks);
+    }
+
+    ne_free(slots);
+}
+
+static int pk11_init(ne_ssl_pkcs11_provider **provider,
+                     pakchois_module_t *module)
+{
+    ne_ssl_pkcs11_provider *prov;
+
+    prov = *provider = ne_calloc(sizeof *prov);
+    prov->module = module;
+    prov->privkey = CK_INVALID_HANDLE;
+
+    return NE_PK11_OK;
+}
+
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name)
+{
+    pakchois_module_t *pm;
+    
+    if (pakchois_module_load(&pm, name) == CKR_OK) {
+        return pk11_init(provider, pm);
+    }
+    else {
+        return NE_PK11_FAILED;
+    }
+}
+
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db)
+{
+    pakchois_module_t *pm;
+    
+    if (pakchois_module_nssload(&pm, name, directory, cert_prefix,
+                                key_prefix, secmod_db) == CKR_OK) {
+        return pk11_init(provider, pm);
+    }
+    else {
+        return NE_PK11_FAILED;
+    }
+}
+
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata)
+{
+    provider->pin_fn = fn;
+    provider->pin_data = userdata;
+}
+
+void ne_ssl_set_pkcs11_provider(ne_session *sess, 
+                                ne_ssl_pkcs11_provider *provider)
+{
+#ifdef HAVE_GNUTLS
+    sess->ssl_context->sign_func = pk11_sign_callback;
+    sess->ssl_context->sign_data = provider;
+#endif
+
+    ne_ssl_provide_clicert(sess, pk11_provide, provider);
+}
+
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *prov)
+{
+    if (prov->session) {
+        pakchois_close_session(prov->session);
+    }
+    if (prov->clicert) {
+        ne_ssl_clicert_free(prov->clicert);
+    }
+    pakchois_module_destroy(prov->module);
+    ne_free(prov);
+}
+
+#else /* !HAVE_PAKCHOIS */
+
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name)
+{
+    return NE_PK11_NOTIMPL;
+}
+
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db)
+{
+    return NE_PK11_NOTIMPL;
+}
+
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *provider) { }
+
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata) { }
+
+void ne_ssl_set_pkcs11_provider(ne_session *sess,
+                                ne_ssl_pkcs11_provider *provider) { }
+
+#endif /* HAVE_PAKCHOIS */
+
diff --git a/net/mmt/neon/src/ne_pkcs11.h b/net/mmt/neon/src/ne_pkcs11.h
new file mode 100644
index 0000000..4cefeb0
--- /dev/null
+++ b/net/mmt/neon/src/ne_pkcs11.h
@@ -0,0 +1,110 @@
+/* 
+   PKCS#11 support for neon
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_PKCS11_H
+#define NE_PKCS11_H 1
+
+#include "ne_defs.h"
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_ssl_pkcs11_provider_s ne_ssl_pkcs11_provider;
+
+#define NE_PK11_OK (0)
+#define NE_PK11_NOTIMPL (-1)
+#define NE_PK11_FAILED (-2)
+
+/* Initialize a PKCS#11 provider of given name.  Returns NE_OK on
+ * success, NE_PK11_FAILED if the provider could not be
+ * loaded/initialized, and NE_PK11_NOTIMPL if PKCS#11 is not
+ * supported.  On success, *provider is set to non-NULL.  */
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name);
+
+/* Initialize a NSS softoken pseudo-PKCS#11 provider of given name
+ * (e.g. "softokn3") to supply a client certificate if requested,
+ * using database in given directory name; the other parameters may be
+ * NULL.  Returns NE_OK on success, NE_PK11_FAILED if the provider
+ * could not be loaded/initialized, and NE_PK11_NOTIMPL if PKCS#11 is
+ * not supported.  On success, *provider is set to non-NULL. */
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db);
+
+/* Destroy a PKCS#11 provider object. */
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *provider);
+
+
+/* Flags passed to PIN entry callback: */
+#define NE_SSL_P11PIN_COUNT_LOW (0x01) /* an incorrect PIN has been
+                                        * entered. */
+#define NE_SSL_P11PIN_FINAL_TRY (0x02) /* token will become locked if
+                                        * entered PIN is incorrect */
+
+/* Size of buffer passed to PIN entry callback: */
+#define NE_SSL_P11PINLEN (256)
+
+/* Callback for PKCS#11 PIN entry.  The callback provides the PIN code
+ * to unlock the token with label 'token_label' in the slot described
+ * by 'slot_descr'.
+ *
+ * The PIN code, as a NUL-terminated ASCII string, should be copied
+ * into the 'pin' buffer (of fixed length NE_SSL_P11PINLEN), and
+ * return 0 to indicate success. Alternatively, the callback may
+ * return -1 to indicate failure and cancel PIN entry (in which case,
+ * the contents of the 'pin' parameter are ignored).
+ *
+ * When a PIN is required, the callback will be invoked repeatedly
+ * (and indefinitely) until either the returned PIN code is correct,
+ * the callback returns failure, or the token refuses login (e.g. when
+ * the token is locked due to too many incorrect PINs!).  For the
+ * first such invocation, the 'attempt' counter will have value zero;
+ * it will increase by one for each subsequent attempt.
+ *
+ * The NE_SSL_P11PIN_COUNT_LOW and/or NE_SSL_P11PIN_FINAL_TRY hints
+ * may be set in the 'flags' argument, if these hints are made
+ * available by the token; not all tokens expose these hints. */
+typedef int (*ne_ssl_pkcs11_pin_fn)(void *userdata, int attempt,
+                                    const char *slot_descr,
+                                    const char *token_label,
+                                    unsigned int flags,
+                                    char *pin);
+
+/* Set the PIN entry callback for the given provider.  This is
+ * necessary for some (but not all) types of token.  For tokens which
+ * implement an out-of-band ("protected") authentication path, the PIN
+ * entry callback will not be invoked. */
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata);
+
+/* Set up a given PKCS#11 provider to supply an appropriate client
+ * certificate if requested by the server.  A provider may be
+ * configured for use in multiple sessions. */
+void ne_ssl_set_pkcs11_provider(ne_session *sess,
+                                ne_ssl_pkcs11_provider *provider);
+
+NE_END_DECLS
+
+#endif /* NE_PKCS11_H */
diff --git a/net/mmt/neon/src/ne_private.h b/net/mmt/neon/src/ne_private.h
new file mode 100644
index 0000000..a2c5fcf
--- /dev/null
+++ b/net/mmt/neon/src/ne_private.h
@@ -0,0 +1,154 @@
+/* 
+   HTTP Request Handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* THIS IS NOT A PUBLIC INTERFACE. You CANNOT include this header file
+ * from an application.  */
+ 
+#ifndef NE_PRIVATE_H
+#define NE_PRIVATE_H
+
+#include "ne_request.h"
+#include "ne_socket.h"
+#include "ne_ssl.h"
+
+struct host_info {
+    /* Type of host represented: */
+    enum proxy_type {
+        PROXY_NONE = 0,
+        PROXY_HTTP, /* an HTTP proxy */
+        PROXY_SOCKS /* a SOCKS proxy */
+    } proxy;
+    unsigned int port;
+    /* If hostname is non-NULL, host is identified by this hostname. */
+    char *hostname, *hostport;
+    /* If address is non-NULL, the result of resolving ->hostname. */
+    ne_sock_addr *address;
+    /* If current non-NULL, current network address used in ->address. */
+    const ne_inet_addr *current;
+    /* If override is non-NULL, the host is identified by this network
+     * address. */
+    const ne_inet_addr *network;
+    struct host_info *next;
+};
+
+/* Store every registered callback in a generic container, and cast
+ * the function pointer when calling it.  */
+struct hook {
+    void (*fn)(void);
+    void *userdata;
+    const char *id; /* non-NULL for accessors. */
+    struct hook *next;
+};
+
+#define HAVE_HOOK(st,func) (st->hook->hooks->func != NULL)
+#define HOOK_FUNC(st, func) (*st->hook->hooks->func)
+
+/* Session support. */
+struct ne_session_s {
+    /* Connection information */
+    ne_socket *socket;
+
+    /* non-zero if connection has been established. */
+    int connected;
+    
+    /* non-zero if connection has persisted beyond one request. */
+    int persisted;
+
+    int is_http11; /* >0 if connected server is known to be
+		    * HTTP/1.1 compliant. */
+
+    char *scheme;
+
+    /* Server host details. */
+    struct host_info server;
+    /* Proxy host details, or NULL if not using a proxy. */
+    struct host_info *proxies;
+    /* Most recently used proxy server. */
+    struct host_info *prev_proxy;
+
+    /* Pointer to the active .server or .proxies as appropriate: */
+    struct host_info *nexthop;
+
+    /* Local address to which sockets should be bound. */
+    const ne_inet_addr *local_addr;
+
+    /* Settings */
+    int use_ssl; /* whether a secure connection is required */
+    int in_connect; /* doing a proxy CONNECT */
+    int any_proxy_http; /* whether any configured proxy is an HTTP proxy */
+    
+    enum ne_sock_sversion socks_ver;
+    char *socks_user, *socks_password;
+
+    int flags[NE_SESSFLAG_LAST];
+
+    ne_progress progress_cb;
+    void *progress_ud;
+
+    ne_notify_status notify_cb;
+    void *notify_ud;
+
+    int rdtimeout, cotimeout; /* read, connect timeouts. */
+
+    struct hook *create_req_hooks, *pre_send_hooks, *post_send_hooks,
+        *post_headers_hooks, *destroy_req_hooks, *destroy_sess_hooks, 
+        *close_conn_hooks, *private;
+
+    char *user_agent; /* full User-Agent: header field */
+
+#ifdef NE_HAVE_SSL
+    ne_ssl_client_cert *client_cert;
+    ne_ssl_certificate *server_cert;
+    ne_ssl_context *ssl_context;
+    int ssl_cc_requested; /* set to non-zero if a client cert was
+                           * requested during initial handshake, but
+                           * none could be provided. */
+#endif
+
+    /* Server cert verification callback: */
+    ne_ssl_verify_fn ssl_verify_fn;
+    void *ssl_verify_ud;
+    /* Client cert provider callback: */
+    ne_ssl_provide_fn ssl_provide_fn;
+    void *ssl_provide_ud;
+
+    ne_session_status_info status;
+
+    /* Error string */
+    char error[512];
+};
+
+/* Pushes block of 'count' bytes at 'buf'. Returns non-zero on
+ * error. */
+typedef int (*ne_push_fn)(void *userdata, const char *buf, size_t count);
+
+/* Do the SSL negotiation. */
+NE_PRIVATE int ne__negotiate_ssl(ne_session *sess);
+
+/* Set the session error appropriate for SSL verification failures. */
+NE_PRIVATE void ne__ssl_set_verify_err(ne_session *sess, int failures);
+
+/* Return non-zero if hostname from certificate (cn) matches hostname
+ * used for session (hostname); follows RFC2818 logic. */
+NE_PRIVATE int ne__ssl_match_hostname(const char *cn, size_t cnlen, 
+                                      const char *hostname);
+
+#endif /* HTTP_PRIVATE_H */
diff --git a/net/mmt/neon/src/ne_privssl.h b/net/mmt/neon/src/ne_privssl.h
new file mode 100644
index 0000000..57d53c8
--- /dev/null
+++ b/net/mmt/neon/src/ne_privssl.h
@@ -0,0 +1,106 @@
+/* 
+   SSL interface definitions internal to neon.
+   Copyright (C) 2003-2005, 2008, 2009, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004, Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* THIS IS NOT A PUBLIC INTERFACE. You CANNOT include this header file
+ * from an application.  */
+ 
+#ifndef NE_PRIVSSL_H
+#define NE_PRIVSSL_H
+
+/* This is the private interface between ne_socket, ne_gnutls and
+ * ne_openssl. */
+
+#include "ne_ssl.h"
+#include "ne_socket.h"
+
+#ifdef HAVE_OPENSSL
+
+#include <openssl/ssl.h>
+
+struct ne_ssl_context_s {
+    SSL_CTX *ctx;
+    SSL_SESSION *sess;
+    const char *hostname; /* for SNI */
+    int failures; /* bitmask of exposed failure bits. */
+};
+
+typedef SSL *ne_ssl_socket;
+
+/* Create a clicert object from cert DER {der, der_len}, using given
+ * RSA_METHOD for the RSA object. */
+NE_PRIVATE ne_ssl_client_cert *
+ne__ssl_clicert_exkey_import(const unsigned char *der,
+                             size_t der_len,
+                             const RSA_METHOD *method);
+
+#endif /* HAVE_OPENSSL */
+
+#ifdef HAVE_GNUTLS
+
+#include <gnutls/gnutls.h>
+
+struct ne_ssl_context_s {
+    gnutls_certificate_credentials_t cred;
+    int verify; /* non-zero if client cert verification required */
+
+    const char *hostname; /* for SNI */
+
+    /* Session cache. */
+    union ne_ssl_scache {
+        struct {
+            gnutls_datum_t key, data;
+        } server;
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_datum_t client;
+#else
+        struct {
+            char *data;
+            size_t len;
+        } client;
+#endif
+    } cache;
+
+#ifdef HAVE_GNUTLS_SIGN_CALLBACK_SET
+    gnutls_sign_func sign_func;
+    void *sign_data;
+#endif
+};
+
+typedef gnutls_session_t ne_ssl_socket;
+
+NE_PRIVATE ne_ssl_client_cert *
+ne__ssl_clicert_exkey_import(const unsigned char *der, size_t der_len);
+
+#endif /* HAVE_GNUTLS */
+
+#ifdef NE_HAVE_SSL
+NE_PRIVATE ne_ssl_socket ne__sock_sslsock(ne_socket *sock);
+
+/* Process-global initialization of the SSL library; returns non-zero
+ * on error. */
+NE_PRIVATE int ne__ssl_init(void);
+
+/* Process-global de-initialization of the SSL library. */
+NE_PRIVATE void ne__ssl_exit(void);
+#endif
+
+#endif /* NE_PRIVSSL_H */
diff --git a/net/mmt/neon/src/ne_props.c b/net/mmt/neon/src/ne_props.c
new file mode 100644
index 0000000..8131709
--- /dev/null
+++ b/net/mmt/neon/src/ne_props.c
@@ -0,0 +1,675 @@
+/* 
+   WebDAV property manipulation
+   Copyright (C) 2000-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include "ne_alloc.h"
+#include "ne_xml.h"
+#include "ne_props.h"
+#include "ne_basic.h"
+#include "ne_locks.h"
+#include "ne_internal.h"
+
+/* don't store flat props with a value > 10K */
+#define MAX_FLATPROP_LEN (102400)
+
+struct ne_propfind_handler_s {
+    ne_session *sess;
+    ne_request *request;
+
+    int has_props; /* whether we've already written some
+		    * props to the body. */
+    ne_buffer *body;
+    
+    ne_207_parser *parser207;
+    ne_xml_parser *parser;
+
+    /* Creator/destructor callbacks. */
+    ne_props_create_complex creator;
+    ne_props_destroy_complex destructor;
+    void *cd_userdata;
+    
+    /* Current propset, or NULL if none being processed. */
+    ne_prop_result_set *current;
+
+    ne_buffer *value; /* current flat property value */
+    int depth; /* nesting depth within a flat property */
+
+    ne_props_result callback;
+    void *userdata;
+};
+
+#define ELM_flatprop (NE_207_STATE_TOP - 1)
+
+/* We build up the results of one 'response' element in memory. */
+struct prop {
+    char *name, *nspace, *value, *lang;
+    /* Store a ne_propname here too, for convienience.  pname.name =
+     * name, pname.nspace = nspace, but they are const'ed in pname. */
+    ne_propname pname;
+};
+
+#define NSPACE(x) ((x) ? (x) : "")
+
+struct propstat {
+    struct prop *props;
+    int numprops;
+    ne_status status;
+};
+
+/* Results set. */
+struct ne_prop_result_set_s {
+    struct propstat *pstats;
+    int numpstats, counter;
+    void *private;
+    ne_uri uri;
+};
+
+#define MAX_PROP_COUNTER (1024)
+
+static int 
+startelm(void *userdata, int state, const char *name, const char *nspace,
+	 const char **atts);
+static int 
+endelm(void *userdata, int state, const char *name, const char *nspace);
+
+/* Handle character data; flat property value. */
+static int chardata(void *userdata, int state, const char *data, size_t len)
+{
+    ne_propfind_handler *hdl = userdata;
+
+    if (state == ELM_flatprop && hdl->value->length < MAX_FLATPROP_LEN)
+        ne_buffer_append(hdl->value, data, len);
+
+    return 0;
+}
+
+ne_xml_parser *ne_propfind_get_parser(ne_propfind_handler *handler)
+{
+    return handler->parser;
+}
+
+ne_request *ne_propfind_get_request(ne_propfind_handler *handler)
+{
+    return handler->request;
+}
+
+static int propfind(ne_propfind_handler *handler, 
+		    ne_props_result results, void *userdata)
+{
+    int ret;
+    ne_request *req = handler->request;
+
+    /* Register the flat property handler to catch any properties 
+     * which the user isn't handling as 'complex'. */
+    ne_xml_push_handler(handler->parser, startelm, chardata, endelm, handler);
+
+    handler->callback = results;
+    handler->userdata = userdata;
+
+    ne_set_request_body_buffer(req, handler->body->data,
+			       ne_buffer_size(handler->body));
+
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    
+    ne_add_response_body_reader(req, ne_accept_207, ne_xml_parse_v, 
+				  handler->parser);
+
+    ret = ne_request_dispatch(req);
+
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    } else if (ne_xml_failed(handler->parser)) {
+	ne_set_error(handler->sess, "%s", ne_xml_get_error(handler->parser));
+	ret = NE_ERROR;
+    }
+
+    return ret;
+}
+
+static void set_body(ne_propfind_handler *hdl, const ne_propname *names)
+{
+    ne_buffer *body = hdl->body;
+    int n;
+    
+    if (!hdl->has_props) {
+	ne_buffer_czappend(body, "<prop>\n");
+	hdl->has_props = 1;
+    }
+
+    for (n = 0; names[n].name != NULL; n++) {
+	ne_buffer_concat(body, "<", names[n].name, " xmlns=\"", 
+			 NSPACE(names[n].nspace), "\"/>\n", NULL);
+    }
+
+}
+
+int ne_propfind_allprop(ne_propfind_handler *handler, 
+			 ne_props_result results, void *userdata)
+{
+    ne_buffer_czappend(handler->body, "<allprop/></propfind>\n");
+    return propfind(handler, results, userdata);
+}
+
+int ne_propfind_named(ne_propfind_handler *handler, const ne_propname *props,
+		       ne_props_result results, void *userdata)
+{
+    set_body(handler, props);
+    ne_buffer_czappend(handler->body, "</prop></propfind>\n");
+    return propfind(handler, results, userdata);
+}
+
+
+/* The easy one... PROPPATCH */
+int ne_proppatch(ne_session *sess, const char *uri, 
+		 const ne_proppatch_operation *items)
+{
+    ne_request *req = ne_request_create(sess, "PROPPATCH", uri);
+    ne_buffer *body = ne_buffer_create();
+    int n, ret;
+    
+    /* Create the request body */
+    ne_buffer_czappend(body, "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n"
+                       "<D:propertyupdate xmlns:D=\"DAV:\">");
+
+    for (n = 0; items[n].name != NULL; n++) {
+	const char *elm = (items[n].type == ne_propset) ? "set" : "remove";
+
+	/* <set><prop><prop-name>value</prop-name></prop></set> */
+	ne_buffer_concat(body, "<D:", elm, "><D:prop>"
+			 "<", items[n].name->name, NULL);
+	
+	if (items[n].name->nspace) {
+	    ne_buffer_concat(body, " xmlns=\"", items[n].name->nspace, "\"", NULL);
+	}
+
+	if (items[n].type == ne_propset) {
+	    ne_buffer_concat(body, ">", items[n].value, NULL);
+	} else {
+	    ne_buffer_append(body, ">", 1);
+	}
+
+	ne_buffer_concat(body, "</", items[n].name->name, "></D:prop></D:", elm, 
+                         ">\n", NULL);
+    }	
+
+    ne_buffer_czappend(body, "</D:propertyupdate>\n");
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, NE_DEPTH_ZERO);
+#endif
+
+    ret = ne_simple_request(sess, req);
+    
+    ne_buffer_destroy(body);
+
+    return ret;
+}
+
+/* Compare two property names. */
+static int pnamecmp(const ne_propname *pn1, const ne_propname *pn2)
+{
+    if (pn1->nspace == NULL && pn2->nspace != NULL) {
+	return 1;
+    } else if (pn1->nspace != NULL && pn2->nspace == NULL) {
+	return -1;
+    } else if (pn1->nspace == NULL) {
+	return strcmp(pn1->name, pn2->name);
+    } else {
+	return (strcmp(pn1->nspace, pn2->nspace) ||
+		strcmp(pn1->name, pn2->name));
+    }
+}
+
+/* Find property in 'set' with name 'pname'.  If found, set pstat_ret
+ * to the containing propstat, likewise prop_ret, and returns zero.
+ * If not found, returns non-zero.  */
+static int findprop(const ne_prop_result_set *set, const ne_propname *pname,
+		    struct propstat **pstat_ret, struct prop **prop_ret)
+{
+    
+    int ps, p;
+
+    for (ps = 0; ps < set->numpstats; ps++) {
+	for (p = 0; p < set->pstats[ps].numprops; p++) {
+	    struct prop *prop = &set->pstats[ps].props[p];
+
+	    if (pnamecmp(&prop->pname, pname) == 0) {
+		if (pstat_ret != NULL)
+		    *pstat_ret = &set->pstats[ps];
+		if (prop_ret != NULL)
+		    *prop_ret = prop;
+		return 0;
+	    }
+	}
+    }
+
+    return -1;
+}
+
+const char *ne_propset_value(const ne_prop_result_set *set,
+			      const ne_propname *pname)
+{
+    struct prop *prop;
+    
+    if (findprop(set, pname, NULL, &prop)) {
+	return NULL;
+    } else {
+	return prop->value;
+    }
+}
+
+const char *ne_propset_lang(const ne_prop_result_set *set,
+			     const ne_propname *pname)
+{
+    struct prop *prop;
+
+    if (findprop(set, pname, NULL, &prop)) {
+	return NULL;
+    } else {
+	return prop->lang;
+    }
+}
+
+void *ne_propfind_current_private(ne_propfind_handler *handler)
+{
+    return handler->current ? handler->current->private : NULL;
+}
+
+void *ne_propset_private(const ne_prop_result_set *set)
+{
+    return set->private;
+}
+
+int ne_propset_iterate(const ne_prop_result_set *set,
+			ne_propset_iterator iterator, void *userdata)
+{
+    int ps, p;
+
+    for (ps = 0; ps < set->numpstats; ps++) {
+	for (p = 0; p < set->pstats[ps].numprops; p++) {
+	    struct prop *prop = &set->pstats[ps].props[p];
+	    int ret = iterator(userdata, &prop->pname, prop->value, 
+			       &set->pstats[ps].status);
+	    if (ret)
+		return ret;
+
+	}
+    }
+
+    return 0;
+}
+
+const ne_status *ne_propset_status(const ne_prop_result_set *set,
+				      const ne_propname *pname)
+{
+    struct propstat *pstat;
+    
+    if (findprop(set, pname, &pstat, NULL)) {
+	/* TODO: it is tempting to return a dummy status object here
+	 * rather than NULL, which says "Property result was not given
+	 * by server."  but I'm not sure if this is best left to the
+	 * client.  */
+	return NULL;
+    } else {
+	return &pstat->status;
+    }
+}
+
+static void *start_response(void *userdata, const ne_uri *uri)
+{
+    ne_prop_result_set *set = ne_calloc(sizeof(*set));
+    ne_propfind_handler *hdl = userdata;
+
+    ne_uri_copy(&set->uri, uri);
+
+    if (hdl->creator) {
+	set->private = hdl->creator(hdl->cd_userdata, &set->uri);
+    }
+
+    hdl->current = set;
+
+    return set;
+}
+
+static void *start_propstat(void *userdata, void *response)
+{
+    ne_prop_result_set *set = response;
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat;
+    int n;
+
+    if (++hdl->current->counter == MAX_PROP_COUNTER) {
+        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
+        return NULL;
+    }
+    
+    n = set->numpstats;
+    set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));
+    set->numpstats = n+1;
+
+    pstat = &set->pstats[n];
+    memset(pstat, 0, sizeof(*pstat));
+    
+    /* And return this as the new pstat. */
+    return &set->pstats[n];
+}
+
+static int startelm(void *userdata, int parent,
+                    const char *nspace, const char *name, const char **atts)
+{
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
+    struct prop *prop;
+    int n;
+    const char *lang;
+
+    /* Just handle all children of propstat and their descendants. */
+    if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop) 
+        || pstat == NULL)
+        return NE_XML_DECLINE;
+
+    if (parent == ELM_flatprop) {
+        /* collecting the flatprop value. */
+        hdl->depth++;
+        if (hdl->value->used < MAX_FLATPROP_LEN) {
+            const char **a = atts;
+
+            ne_buffer_concat(hdl->value, "<", nspace, name, NULL);
+            
+            while (a[0] && hdl->value->used < MAX_FLATPROP_LEN) {
+                const char *nsep = strchr(a[0], ':'), *pfx;
+
+                /* Resolve the attribute namespace prefix, if any.
+                 * Ignore a failure to resolve the namespace prefix. */
+                pfx = nsep ? ne_xml_resolve_nspace(hdl->parser,
+                                                   a[0], nsep - a[0]) : NULL;
+                
+                if (pfx) {
+                    ne_buffer_concat(hdl->value, " ", pfx, nsep + 1, "='", 
+                                     a[1], "'", NULL);
+                }
+                else {
+                    ne_buffer_concat(hdl->value, " ", a[0], "='", a[1], "'", NULL);
+                }
+                a += 2;
+            }
+
+            ne_buffer_czappend(hdl->value, ">");
+        }
+
+        return ELM_flatprop;
+    }        
+
+    /* Enforce maximum number of properties per resource to prevent a
+     * memory exhaustion attack by a hostile server. */
+    if (++hdl->current->counter == MAX_PROP_COUNTER) {
+        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
+        return NE_XML_ABORT;
+    }
+
+    /* Add a property to this propstat */
+    n = pstat->numprops;
+
+    pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));
+    pstat->numprops = n+1;
+
+    /* Fill in the new property. */
+    prop = &pstat->props[n];
+
+    prop->pname.name = prop->name = ne_strdup(name);
+    if (nspace[0] == '\0') {
+	prop->pname.nspace = prop->nspace = NULL;
+    } else {
+	prop->pname.nspace = prop->nspace = ne_strdup(nspace);
+    }
+    prop->value = NULL;
+
+    NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 
+	     NSPACE(prop->nspace), prop->name);
+
+    /* This is under discussion at time of writing (April '01), and it
+     * looks like we need to retrieve the xml:lang property from any
+     * element here or above.
+     *
+     * Also, I think we might need attribute namespace handling here.  */
+    lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");
+    if (lang != NULL) {
+	prop->lang = ne_strdup(lang);
+	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);
+    } else {
+	prop->lang = NULL;
+    }
+
+    hdl->depth = 0;
+
+    return ELM_flatprop;
+}
+
+static int endelm(void *userdata, int state,
+                  const char *nspace, const char *name)
+{
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
+    int n;
+
+    if (hdl->depth > 0) {
+        /* nested. */
+        if (hdl->value->used < MAX_FLATPROP_LEN)
+            ne_buffer_concat(hdl->value, "</", nspace, name, ">", NULL);
+        hdl->depth--;
+    } else {
+        /* end of the current property value */
+        n = pstat->numprops - 1;
+        pstat->props[n].value = ne_buffer_finish(hdl->value);
+        hdl->value = ne_buffer_create();
+    }
+    return 0;
+}
+
+static void end_propstat(void *userdata, void *pstat_v, 
+			 const ne_status *status,
+			 const char *description)
+{
+    struct propstat *pstat = pstat_v;
+
+    /* Nothing to do if no status was given. */
+    if (!status) return;
+
+    /* If we get a non-2xx response back here, we wipe the value for
+     * each of the properties in this propstat, so the caller knows to
+     * look at the status instead. It's annoying, since for each prop
+     * we will have done an unnecessary strdup("") above, but there is
+     * no easy way round that given the fact that we don't know
+     * whether we've got an error or not till after we get the
+     * property element.
+     *
+     * Interestingly IIS breaks the 2518 DTD and puts the status
+     * element first in the propstat. This is useful since then we
+     * *do* know whether each subsequent empty prop element means, but
+     * we can't rely on that here. */
+    if (status->klass != 2) {
+	int n;
+	
+	for (n = 0; n < pstat->numprops; n++) {
+	    ne_free(pstat->props[n].value);
+	    pstat->props[n].value = NULL;
+	}
+    }
+
+    /* copy the status structure, and dup the reason phrase. */
+    pstat->status = *status;
+    pstat->status.reason_phrase = ne_strdup(status->reason_phrase);
+}
+
+/* Frees up a results set */
+static void free_propset(ne_propfind_handler *handler,
+                         ne_prop_result_set *set)
+{
+    int n;
+    
+    if (handler->destructor && set->private) {
+        handler->destructor(handler->cd_userdata, set->private);
+    }
+
+    for (n = 0; n < set->numpstats; n++) {
+	int m;
+	struct propstat *p = &set->pstats[n];
+
+	for (m = 0; m < p->numprops; m++) {
+            if (p->props[m].nspace) ne_free(p->props[m].nspace);
+            ne_free(p->props[m].name);
+            if (p->props[m].lang) ne_free(p->props[m].lang);
+            if (p->props[m].value) ne_free(p->props[m].value);
+            p->props[m].nspace = p->props[m].lang = 
+                p->props[m].value = NULL;
+	}
+
+	if (p->status.reason_phrase)
+	    ne_free(p->status.reason_phrase);
+	if (p->props)
+	    ne_free(p->props);
+    }
+
+    if (set->pstats)
+	ne_free(set->pstats);
+    ne_uri_free(&set->uri);
+    ne_free(set);
+}
+
+static void end_response(void *userdata, void *resource,
+			 const ne_status *status,
+			 const char *description)
+{
+    ne_propfind_handler *handler = userdata;
+    ne_prop_result_set *set = resource;
+
+    /* Pass back the results for this resource. */
+    if (handler->callback && set->numpstats > 0)
+	handler->callback(handler->userdata, &set->uri, set);
+
+    /* Clean up the propset tree we've just built. */
+    free_propset(handler, set);
+    handler->current = NULL;
+}
+
+ne_propfind_handler *
+ne_propfind_create(ne_session *sess, const char *uri, int depth)
+{
+    ne_propfind_handler *ret = ne_calloc(sizeof(ne_propfind_handler));
+    ne_uri base = {0};
+
+    ne_fill_server_uri(sess, &base);
+    base.path = ne_strdup(uri);
+
+    ret->parser = ne_xml_create();
+    ret->parser207 = ne_207_create(ret->parser, &base, ret);
+    ret->sess = sess;
+    ret->body = ne_buffer_create();
+    ret->request = ne_request_create(sess, "PROPFIND", uri);
+    ret->value = ne_buffer_create();
+
+    ne_add_depth_header(ret->request, depth);
+
+    ne_207_set_response_handlers(ret->parser207, 
+				  start_response, end_response);
+
+    ne_207_set_propstat_handlers(ret->parser207, start_propstat,
+				  end_propstat);
+
+    /* The start of the request body is fixed: */
+    ne_buffer_czappend(ret->body, 
+                       "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" 
+                       "<propfind xmlns=\"DAV:\">");
+
+    ne_uri_free(&base);
+
+    return ret;
+}
+
+/* Destroy a propfind handler */
+void ne_propfind_destroy(ne_propfind_handler *handler)
+{
+    ne_buffer_destroy(handler->value);
+    if (handler->current)
+        free_propset(handler, handler->current);
+    ne_207_destroy(handler->parser207);
+    ne_xml_destroy(handler->parser);
+    ne_buffer_destroy(handler->body);
+    ne_request_destroy(handler->request);
+    ne_free(handler);    
+}
+
+int ne_simple_propfind(ne_session *sess, const char *href, int depth,
+			const ne_propname *props,
+			ne_props_result results, void *userdata)
+{
+    ne_propfind_handler *hdl;
+    int ret;
+
+    hdl = ne_propfind_create(sess, href, depth);
+    if (props != NULL) {
+	ret = ne_propfind_named(hdl, props, results, userdata);
+    } else {
+	ret = ne_propfind_allprop(hdl, results, userdata);
+    }
+	
+    ne_propfind_destroy(hdl);
+    
+    return ret;
+}
+
+int ne_propnames(ne_session *sess, const char *href, int depth,
+		  ne_props_result results, void *userdata)
+{
+    ne_propfind_handler *hdl;
+    int ret;
+
+    hdl = ne_propfind_create(sess, href, depth);
+
+    ne_buffer_czappend(hdl->body, "<propname/></propfind>");
+
+    ret = propfind(hdl, results, userdata);
+
+    ne_propfind_destroy(hdl);
+
+    return ret;
+}
+
+void ne_propfind_set_private(ne_propfind_handler *hdl,
+                             ne_props_create_complex creator,
+                             ne_props_destroy_complex destructor,
+                             void *userdata)
+{
+    hdl->creator = creator;
+    hdl->destructor = destructor;
+    hdl->cd_userdata = userdata;
+}
diff --git a/net/mmt/neon/src/ne_props.h b/net/mmt/neon/src/ne_props.h
new file mode 100644
index 0000000..fdeb8ff
--- /dev/null
+++ b/net/mmt/neon/src/ne_props.h
@@ -0,0 +1,249 @@
+/* 
+   WebDAV Properties manipulation
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_PROPS_H
+#define NE_PROPS_H
+
+#include "ne_request.h"
+#include "ne_207.h"
+
+NE_BEGIN_DECLS
+
+/* There are two interfaces for fetching properties. The first is
+ * 'ne_simple_propfind', which is relatively simple, and easy to use,
+ * but only lets you fetch FLAT properties, i.e. properties which are
+ * just a string of bytes.  The complex interface is 'ne_propfind_*',
+ * which is complicated, and hard to use, but lets you parse
+ * structured properties, i.e.  properties which have XML content.  */
+
+/* The 'ne_simple_propfind' interface. ***
+ *
+ * ne_simple_propfind allows you to fetch a set of properties for a
+ * single resource, or a tree of resources.  You set the operation
+ * going by passing these arguments:
+ *
+ *  - the session which should be used.
+ *  - the URI and the depth of the operation (0, 1, infinite)
+ *  - the names of the properties which you want to fetch
+ *  - a results callback, and the userdata for the callback.
+ *
+ * For each resource found, the results callback is called, passing
+ * you two things along with the userdata you passed in originally:
+ *
+ *   - the URI of the resource (const ne_uri *uri)
+ *   - the properties results set (const ne_prop_result_set *results)
+ * */
+
+/* The name of a WebDAV property. 'nspace' may be NULL. */
+typedef struct {
+    const char *nspace, *name;
+} ne_propname;
+
+typedef struct ne_prop_result_set_s ne_prop_result_set;
+
+/* Get the value of a given property. Will return NULL if there was an
+ * error fetching this property on this resource.  Call
+ * ne_propset_result to get the response-status if so.  */
+const char *ne_propset_value(const ne_prop_result_set *set,
+			      const ne_propname *propname);
+
+/* Returns the status structure for fetching the given property on
+ * this resource. This function will return NULL if the server did not
+ * return the property (which is a server error). */
+const ne_status *ne_propset_status(const ne_prop_result_set *set,
+				      const ne_propname *propname);
+
+/* Returns the private pointer for the given propset. */
+void *ne_propset_private(const ne_prop_result_set *set);
+
+/* Return language string of property (may be NULL). */
+const char *ne_propset_lang(const ne_prop_result_set *set,
+			     const ne_propname *pname);
+
+/* ne_propset_iterate iterates over a properties result set,
+ * calling the callback for each property in the set. userdata is
+ * passed as the first argument to the callback. value may be NULL,
+ * indicating an error occurred fetching this property: look at 
+ * status for the error in that case.
+ *
+ * If the iterator returns non-zero, ne_propset_iterate will return
+ * immediately with that value.
+ */
+typedef int (*ne_propset_iterator)(void *userdata,
+				    const ne_propname *pname,
+				    const char *value,
+				    const ne_status *status);
+
+/* Iterate over all the properties in 'set', calling 'iterator'
+ * for each, passing 'userdata' as the first argument to callback.
+ * 
+ * Returns:
+ *   whatever value iterator returns.
+ */
+int ne_propset_iterate(const ne_prop_result_set *set,
+			ne_propset_iterator iterator, void *userdata);
+
+/* Callback for handling the results of fetching properties for a
+ * single resource (identified by URI 'uri').  The results are stored
+ * in the result set 'results': use ne_propset_* to examine this
+ * object.  */
+typedef void (*ne_props_result)(void *userdata, const ne_uri *uri,
+                                const ne_prop_result_set *results);
+
+/* Fetch properties for a resource (if depth == NE_DEPTH_ZERO),
+ * or a tree of resources (if depth == NE_DEPTH_ONE or _INFINITE).
+ *
+ * Names of the properties required must be given in 'props',
+ * or if props is NULL, *all* properties are fetched.
+ *
+ * 'results' is called for each resource in the response, userdata is
+ * passed as the first argument to the callback. It is important to
+ * note that the callback is called as the response is read off the
+ * socket, so don't do anything silly in it (e.g. sleep(100), or call
+ * any functions which use this session).
+ *
+ * Note that if 'depth' is NE_DEPTH_INFINITY, some servers may refuse
+ * the request.
+ *
+ * Returns NE_*.  */
+int ne_simple_propfind(ne_session *sess, const char *path, int depth,
+			const ne_propname *props,
+			ne_props_result results, void *userdata);
+
+/* The properties of a resource can be manipulated using ne_proppatch.
+ * A single proppatch request may include any number of individual
+ * "set" and "remove" operations, and is defined to have
+ * "all-or-nothing" semantics, so either all the operations succeed,
+ * or none do. */
+
+/* A proppatch operation may either set a property to have a new
+ * value, in which case 'type' must be ne_propset, and 'value' must be
+ * non-NULL; or it can remove a property; in which case 'type' must be
+ * ne_propremove, and 'value' is ignored.  In both cases, 'name' must
+ * be set to the name of the property to alter. */
+enum ne_proppatch_optype {
+    ne_propset,
+    ne_propremove
+};
+typedef struct {
+    const ne_propname *name;
+    enum ne_proppatch_optype type;
+    const char *value;
+} ne_proppatch_operation;
+
+/* Execute a set of property operations 'ops' on 'path'. 'ops' is an
+ * array terminated by an operation with a NULL 'name' field. Returns
+ * NE_*. */
+int ne_proppatch(ne_session *sess, const char *path,
+		 const ne_proppatch_operation *ops);
+
+/* Retrieve property names for the resources at 'path'.  'results'
+ * callback is called for each resource.  Use 'ne_propset_iterate' on
+ * the passed results object to retrieve the list of property names.
+ * */
+int ne_propnames(ne_session *sess, const char *path, int depth,
+		 ne_props_result results, void *userdata);
+
+/* The complex, you-do-all-the-work, property fetch interface:
+ */
+
+struct ne_propfind_handler_s;
+typedef struct ne_propfind_handler_s ne_propfind_handler;
+
+/* Retrieve the 'private' pointer for the current propset for the
+ * given handler, as returned by the ne_props_create_complex callback
+ * installed using 'ne_propfind_set_private'.  If this callback was
+ * not registered, this function will return NULL.  */
+void *ne_propfind_current_private(ne_propfind_handler *handler);
+
+/* Create a PROPFIND handler, for the given resource or set of 
+ * resources.
+ *
+ * Depth must be one of NE_DEPTH_*. */
+ne_propfind_handler *
+ne_propfind_create(ne_session *sess, const char *path, int depth);
+
+/* Return the XML parser for the given handler (only need if you want
+ * to handle complex properties). */
+ne_xml_parser *ne_propfind_get_parser(ne_propfind_handler *handler);
+
+/* This interface reserves the state integer range 'x' where 0 < x
+ * and x < NE_PROPS_STATE_TOP. */
+#define NE_PROPS_STATE_TOP (NE_207_STATE_TOP + 100)
+
+/* Return the request object for the given handler.  You MUST NOT use
+ * ne_set_request_body_* on this request object.  (this call is only
+ * needed if for instance, you want to add extra headers to the
+ * PROPFIND request).  The result of using the request pointer after
+ * ne_propfind_destroy(handler) has been called is undefined. */
+ne_request *ne_propfind_get_request(ne_propfind_handler *handler);
+
+/* A "complex property" has a value which is structured XML. To handle
+ * complex properties, you must set up and register an XML handler
+ * which will understand the elements which make up such properties.
+ * The handler must be registered with the parser returned by
+ * 'ne_propfind_get_parser'.
+ *
+ * To store the parsed value of the property, a 'private' structure is
+ * allocated in each propset (i.e. one per resource). When parsing the
+ * property value elements, for each new resource encountered in the
+ * response, the 'creator' callback is called to retrieve a 'private'
+ * structure for this resource.  When the private structure is no longer
+ * needed, the 'destructor' callback is called to deallocate any 
+ * memory, if necessary.
+ *
+ * Whilst in XML element callbacks you will have registered to handle
+ * complex properties, you can use the 'ne_propfind_current_private'
+ * call to retrieve the pointer to this private structure.
+ *
+ * To retrieve this 'private' structure from the propset in the
+ * results callback, simply call 'ne_propset_private'.
+ * */
+typedef void *(*ne_props_create_complex)(void *userdata, const ne_uri *uri);
+typedef void (*ne_props_destroy_complex)(void *userdata, void *complex);
+
+void ne_propfind_set_private(ne_propfind_handler *handler,
+			     ne_props_create_complex creator,
+			     ne_props_destroy_complex destructor,
+			     void *userdata);
+
+/* Fetch all properties.
+ *
+ * Returns NE_*. */
+int ne_propfind_allprop(ne_propfind_handler *handler, 
+			ne_props_result result, void *userdata);
+
+/* Fetch all properties with names listed in array 'names', which is
+ * terminated by a property with a NULL name field.  For each resource
+ * encountered, the result callback will be invoked, passing in
+ * 'userdata' as the first argument.
+ *
+ * Returns NE_*. */
+int ne_propfind_named(ne_propfind_handler *handler, 
+		      const ne_propname *names,
+		      ne_props_result result, void *userdata);
+
+/* Destroy a propfind handler after use. */
+void ne_propfind_destroy(ne_propfind_handler *handler);
+
+NE_END_DECLS
+
+#endif /* NE_PROPS_H */
diff --git a/net/mmt/neon/src/ne_redirect.c b/net/mmt/neon/src/ne_redirect.c
new file mode 100644
index 0000000..171795b
--- /dev/null
+++ b/net/mmt/neon/src/ne_redirect.c
@@ -0,0 +1,141 @@
+/* 
+   HTTP-redirect support
+   Copyright (C) 1999-2007, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include "ne_session.h"
+#include "ne_request.h"
+#include "ne_alloc.h"
+#include "ne_uri.h"
+#include "ne_redirect.h"
+#include "ne_internal.h"
+#include "ne_string.h"
+
+#define REDIRECT_ID "http://www.webdav.org/neon/hooks/http-redirect"
+
+struct redirect {
+    char *requri;
+    int valid; /* non-zero if .uri contains a redirect */
+    ne_uri uri;
+    ne_session *sess;
+};
+
+static void
+create(ne_request *req, void *session, const char *method, const char *uri)
+{
+    struct redirect *red = session;
+    if (red->requri) ne_free(red->requri);
+    red->requri = ne_strdup(uri);
+}
+
+#define REDIR(n) ((n) == 301 || (n) == 302 || (n) == 303 || \
+		  (n) == 307)
+
+static int post_send(ne_request *req, void *private, const ne_status *status)
+{
+    struct redirect *red = private;
+    const char *location = ne_get_response_header(req, "Location");
+    ne_buffer *path = NULL;
+    int ret;
+
+    /* Don't do anything for non-redirect status or no Location header. */
+    if (!REDIR(status->code) || location == NULL)
+	return NE_OK;
+
+    if (strstr(location, "://") == NULL && location[0] != '/') {
+	char *pnt;
+
+	path = ne_buffer_create();
+	ne_buffer_zappend(path, red->requri);
+	pnt = strrchr(path->data, '/');
+
+	if (pnt && pnt[1] != '\0') {
+	    /* Chop off last path segment. */
+	    pnt[1] = '\0';
+	    ne_buffer_altered(path);
+	}
+	ne_buffer_zappend(path, location);
+	location = path->data;
+    }
+
+    /* free last uri. */
+    ne_uri_free(&red->uri);
+    
+    /* Parse the Location header */
+    if (ne_uri_parse(location, &red->uri) || red->uri.path == NULL) {
+        red->valid = 0;
+	ne_set_error(red->sess, _("Could not parse redirect destination URL"));
+        ret = NE_ERROR;
+    } else {
+        /* got a valid redirect. */
+        red->valid = 1;
+        ret = NE_REDIRECT;
+
+        if (!red->uri.host) {
+            /* Not an absoluteURI: breaks 2616 but everybody does it. */
+            ne_fill_server_uri(red->sess, &red->uri);
+        }
+    }
+
+    if (path) ne_buffer_destroy(path);
+
+    return ret;
+}
+
+static void free_redirect(void *cookie)
+{
+    struct redirect *red = cookie;
+    ne_uri_free(&red->uri);
+    if (red->requri)
+        ne_free(red->requri);
+    ne_free(red);
+}
+
+void ne_redirect_register(ne_session *sess)
+{
+    struct redirect *red = ne_calloc(sizeof *red);
+    
+    red->sess = sess;
+
+    ne_hook_create_request(sess, create, red);
+    ne_hook_post_send(sess, post_send, red);
+    ne_hook_destroy_session(sess, free_redirect, red);
+
+    ne_set_session_private(sess, REDIRECT_ID, red);
+}
+
+const ne_uri *ne_redirect_location(ne_session *sess)
+{
+    struct redirect *red = ne_get_session_private(sess, REDIRECT_ID);
+
+    if (red && red->valid)
+        return &red->uri;
+    else
+        return NULL;
+}
+
diff --git a/net/mmt/neon/src/ne_redirect.h b/net/mmt/neon/src/ne_redirect.h
new file mode 100644
index 0000000..f9b437a
--- /dev/null
+++ b/net/mmt/neon/src/ne_redirect.h
@@ -0,0 +1,42 @@
+/* 
+   HTTP-redirect support
+   Copyright (C) 1999-2002, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_REDIRECT_H
+#define NE_REDIRECT_H
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+/* Register redirect handling for the session: if a valid redirect
+ * (30x) response is given for any request in this session, the
+ * request will fail with the NE_REDIRECT code, and the destination of
+ * the redirect can be retrieved using ne_redirect_location(). */
+void ne_redirect_register(ne_session *sess);
+
+/* Returns location of last redirect for the session.  Returns NULL if
+ * no redirect has been encountered for given session, or the last
+ * redirect encountered could not be parsed. */
+const ne_uri *ne_redirect_location(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_REDIRECT_H */
diff --git a/net/mmt/neon/src/ne_request.c b/net/mmt/neon/src/ne_request.c
new file mode 100644
index 0000000..e28fcd4
--- /dev/null
+++ b/net/mmt/neon/src/ne_request.c
@@ -0,0 +1,1714 @@
+/* 
+   HTTP request/response handling
+   Copyright (C) 1999-2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* This is the HTTP client request/response implementation.
+ * The goal of this code is to be modular and simple.
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif 
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include "ne_internal.h"
+
+#include "ne_alloc.h"
+#include "ne_request.h"
+#include "ne_string.h" /* for ne_buffer */
+#include "ne_utils.h"
+#include "ne_socket.h"
+#include "ne_uri.h"
+
+#include "ne_private.h"
+
+#define SOCK_ERR(req, op, msg) do { ssize_t sret = (op); \
+if (sret < 0) return aborted(req, msg, sret); } while (0)
+
+#define EOL "\r\n"
+
+struct body_reader {
+    ne_block_reader handler;
+    ne_accept_response accept_response;
+    unsigned int use;
+    void *userdata;
+    struct body_reader *next;
+};
+
+struct field {
+    char *name, *value;
+    size_t vlen;
+    struct field *next;
+};
+
+/* Maximum number of header fields per response: */
+#define MAX_HEADER_FIELDS (100)
+/* Size of hash table; 43 is the smallest prime for which the common
+ * header names hash uniquely using the *33 hash function. */
+#define HH_HASHSIZE (43)
+/* Hash iteration step: *33 known to be a good hash for ASCII, see RSE. */
+#define HH_ITERATE(hash, ch) (((hash)*33 + (unsigned char)(ch)) % HH_HASHSIZE)
+
+/* pre-calculated hash values for given header names: */
+#define HH_HV_CONNECTION        (0x14)
+#define HH_HV_PROXY_CONNECTION  (0x1A)
+#define HH_HV_CONTENT_LENGTH    (0x13)
+#define HH_HV_TRANSFER_ENCODING (0x07)
+
+struct ne_request_s {
+    char *method, *uri; /* method and Request-URI */
+
+    ne_buffer *headers; /* request headers */
+
+    /* Request body. */
+    ne_provide_body body_cb;
+    void *body_ud;
+
+    /* Request body source: file or buffer (if not callback). */
+    union {
+        struct {
+            int fd;
+            ne_off_t offset, length;
+            ne_off_t remain; /* remaining bytes to send. */
+        } file;
+	struct {
+            /* length bytes @ buffer = whole body.
+             * remain bytes @ pnt = remaining bytes to send */
+	    const char *buffer, *pnt;
+	    size_t length, remain;
+	} buf;
+    } body;
+	    
+    ne_off_t body_length; /* length of request body */
+
+    /* temporary store for response lines. */
+    char respbuf[NE_BUFSIZ];
+
+    /**** Response ***/
+
+    /* The transfer encoding types */
+    struct ne_response {
+	enum {
+	    R_TILLEOF = 0, /* read till eof */
+	    R_NO_BODY, /* implicitly no body (HEAD, 204, 304) */
+	    R_CHUNKED, /* using chunked transfer-encoding */
+	    R_CLENGTH  /* using given content-length */
+	} mode;
+        union {
+            /* clen: used if mode == R_CLENGTH; total and bytes
+             * remaining to be read of response body. */
+            struct {
+                ne_off_t total, remain;
+            } clen;
+            /* chunk: used if mode == R_CHUNKED; total and bytes
+             * remaining to be read of current chunk */
+            struct {
+                size_t total, remain;
+            } chunk;
+        } body;
+        ne_off_t progress; /* number of bytes read of response */
+    } resp;
+    
+    struct hook *private;
+
+    /* response header fields */
+    struct field *response_headers[HH_HASHSIZE];
+    
+    unsigned int current_index; /* response_headers cursor for iterator */
+
+    /* List of callbacks which are passed response body blocks */
+    struct body_reader *body_readers;
+
+    /*** Miscellaneous ***/
+    unsigned int method_is_head;
+    unsigned int can_persist;
+
+    int flags[NE_REQFLAG_LAST];
+
+    ne_session *session;
+    ne_status status;
+};
+
+static int open_connection(ne_session *sess);
+
+/* Returns hash value for header 'name', converting it to lower-case
+ * in-place. */
+static inline unsigned int hash_and_lower(char *name)
+{
+    char *pnt;
+    unsigned int hash = 0;
+
+    for (pnt = name; *pnt != '\0'; pnt++) {
+	*pnt = ne_tolower(*pnt);
+	hash = HH_ITERATE(hash,*pnt);
+    }
+
+    return hash;
+}
+
+/* Abort a request due to an non-recoverable HTTP protocol error,
+ * whilst doing 'doing'.  'code', if non-zero, is the socket error
+ * code, NE_SOCK_*, or if zero, is ignored. */
+static int aborted(ne_request *req, const char *doing, ssize_t code)
+{
+    ne_session *sess = req->session;
+    int ret = NE_ERROR;
+
+    NE_DEBUG(NE_DBG_HTTP, "Aborted request (%" NE_FMT_SSIZE_T "): %s\n",
+	     code, doing);
+
+    switch(code) {
+    case NE_SOCK_CLOSED:
+	if (sess->nexthop->proxy != PROXY_NONE) {
+	    ne_set_error(sess, _("%s: connection was closed by proxy server"),
+			 doing);
+	} else {
+	    ne_set_error(sess, _("%s: connection was closed by server"),
+			 doing);
+	}
+	break;
+    case NE_SOCK_TIMEOUT:
+	ne_set_error(sess, _("%s: connection timed out"), doing);
+	ret = NE_TIMEOUT;
+	break;
+    case NE_SOCK_ERROR:
+    case NE_SOCK_RESET:
+    case NE_SOCK_TRUNC:
+        ne_set_error(sess, "%s: %s", doing, ne_sock_error(sess->socket));
+        break;
+    case 0:
+	ne_set_error(sess, "%s", doing);
+	break;
+    }
+
+    ne_close_connection(sess);
+    return ret;
+}
+
+static void notify_status(ne_session *sess, ne_session_status status)
+{
+    if (sess->notify_cb) {
+	sess->notify_cb(sess->notify_ud, status, &sess->status);
+    }
+}
+
+static void *get_private(const struct hook *hk, const char *id)
+{
+    for (; hk != NULL; hk = hk->next)
+	if (strcmp(hk->id, id) == 0)
+	    return hk->userdata;
+    return NULL;
+}
+
+void *ne_get_request_private(ne_request *req, const char *id)
+{
+    return get_private(req->private, id);
+}
+
+void *ne_get_session_private(ne_session *sess, const char *id)
+{
+    return get_private(sess->private, id);
+}
+
+void ne_set_request_private(ne_request *req, const char *id, void *userdata)
+{
+    struct hook *hk = ne_malloc(sizeof (struct hook)), *pos;
+
+    if (req->private != NULL) {
+	for (pos = req->private; pos->next != NULL; pos = pos->next)
+	    /* nullop */;
+	pos->next = hk;
+    } else {
+	req->private = hk;
+    }
+
+    hk->id = id;
+    hk->fn = NULL;
+    hk->userdata = userdata;
+    hk->next = NULL;
+}
+
+static ssize_t body_string_send(void *userdata, char *buffer, size_t count)
+{
+    ne_request *req = userdata;
+    
+    if (count == 0) {
+	req->body.buf.remain = req->body.buf.length;
+	req->body.buf.pnt = req->body.buf.buffer;
+    } else {
+	/* if body_left == 0 we fall through and return 0. */
+	if (req->body.buf.remain < count)
+	    count = req->body.buf.remain;
+
+	memcpy(buffer, req->body.buf.pnt, count);
+	req->body.buf.pnt += count;
+	req->body.buf.remain -= count;
+    }
+
+    return count;
+}    
+
+static ssize_t body_fd_send(void *userdata, char *buffer, size_t count)
+{
+    ne_request *req = userdata;
+
+    if (count) {
+        ssize_t ret;
+
+        if (req->body.file.remain == 0)
+            return 0;
+
+        /* Casts here are necessary for LFS platforms for safe and
+         * warning-free assignment/comparison between 32-bit size_t
+         * and 64-bit off64_t: */
+        if ((ne_off_t)count > req->body.file.remain)
+            count = (size_t)req->body.file.remain;
+        
+        ret = read(req->body.file.fd, buffer, count);
+        if (ret > 0) {
+            req->body.file.remain -= ret;
+            return ret;
+        }
+        else if (ret == 0) {
+            ne_set_error(req->session, 
+                         _("Premature EOF in request body file"));
+        }
+        else if (ret < 0) {
+            char err[200];
+            int errnum = errno;
+
+            ne_set_error(req->session, 
+                         _("Failed reading request body file: %s"),
+                         ne_strerror(errnum, err, sizeof err));
+        }
+
+        return -1;
+    } else {
+        ne_off_t newoff;
+
+        /* rewind for next send. */
+        newoff = ne_lseek(req->body.file.fd, req->body.file.offset, SEEK_SET);
+        if (newoff == req->body.file.offset) {
+            req->body.file.remain = req->body.file.length;
+            return 0;
+        } else {
+            char err[200], offstr[20];
+
+            if (newoff == -1) {
+                /* errno was set */
+                ne_strerror(errno, err, sizeof err);
+            } else {
+                strcpy(err, _("offset invalid"));
+            }
+            ne_snprintf(offstr, sizeof offstr, "%" FMT_NE_OFF_T,
+                        req->body.file.offset);
+            ne_set_error(req->session, 
+                         _("Could not seek to offset %s"
+                           " of request body file: %s"), 
+                           offstr, err);
+            return -1;
+        }
+    }
+}
+
+/* For accurate persistent connection handling, for any write() or
+ * read() operation for a new request on an already-open connection,
+ * an EOF or RST error MUST be treated as a persistent connection
+ * timeout, and the request retried on a new connection.  Once a
+ * read() operation has succeeded, any subsequent error MUST be
+ * treated as fatal.  A 'retry' flag is used; retry=1 represents the
+ * first case, retry=0 the latter. */
+
+/* RETRY_RET() crafts a function return value given the 'retry' flag,
+ * the socket error 'code', and the return value 'acode' from the
+ * aborted() function. */
+#define RETRY_RET(retry, code, acode) \
+((((code) == NE_SOCK_CLOSED || (code) == NE_SOCK_RESET || \
+ (code) == NE_SOCK_TRUNC) && retry) ? NE_RETRY : (acode))
+
+/* For sending chunks, an 8-byte prefix is reserved at the beginning
+ * of the buffer.  This is large enough for a trailing \r\n for the
+ * previous chunk, the chunk size, and the \r\n following the
+ * chunk-size. */
+#define CHUNK_OFFSET (8)
+#define CHUNK_TERM "\r\n0\r\n\r\n"
+#define CHUNK_NULL_TERM "0\r\n\r\n"
+
+/* Sends the request body; returns 0 on success or an NE_* error code.
+ * If retry is non-zero; will return NE_RETRY on persistent connection
+ * timeout.  On error, the session error string is set and the
+ * connection is closed. */
+static int send_request_body(ne_request *req, int retry)
+{
+    ne_session *const sess = req->session;
+    char buffer[NE_BUFSIZ], *start;
+    ssize_t bytes;
+    size_t buflen;
+    int chunked = req->body_length < 0, chunknum = 0;
+    int ret;
+
+    NE_DEBUG(NE_DBG_HTTP, "Sending request body:\n");
+
+    /* Set up status union and (start, buflen) as the buffer to be
+     * passed the supplied callback. */
+    if (chunked) {
+        start = buffer + CHUNK_OFFSET;
+        buflen = sizeof(buffer) - CHUNK_OFFSET;
+        req->session->status.sr.total = -1;
+    }
+    else {
+        start = buffer;
+        buflen = sizeof buffer;
+        req->session->status.sr.total = req->body_length;
+    }
+
+    req->session->status.sr.progress = 0;
+    notify_status(sess, ne_status_sending);
+    
+    /* tell the source to start again from the beginning. */
+    if (req->body_cb(req->body_ud, NULL, 0) != 0) {
+        ne_close_connection(sess);
+        return NE_ERROR;
+    }
+    
+    while ((bytes = req->body_cb(req->body_ud, start, buflen)) > 0) {
+        req->session->status.sr.progress += bytes;
+        if (chunked) {
+            /* Overwrite the buffer prefix with the appropriate chunk
+             * size; since ne_snprintf always NUL-terminates, the \n
+             * is omitted and placed over the NUL afterwards. */
+            if (chunknum++ == 0)
+                ne_snprintf(buffer, CHUNK_OFFSET, 
+                            "%06x\r", (unsigned)bytes);
+            else
+                ne_snprintf(buffer, CHUNK_OFFSET, 
+                            "\r\n%04x\r", (unsigned)bytes);
+            buffer[CHUNK_OFFSET - 1] = '\n';
+            bytes += CHUNK_OFFSET;
+        }
+        ret = ne_sock_fullwrite(sess->socket, buffer, bytes);
+
+        if (ret < 0) {
+            int aret = aborted(req, _("Could not send request body"), ret);
+            return RETRY_RET(retry, ret, aret);
+        }
+
+	NE_DEBUG(NE_DBG_HTTPBODY, 
+		 "Body block (%" NE_FMT_SSIZE_T " bytes):\n[%.*s]\n",
+		 bytes, (int)bytes, buffer);
+
+        /* invoke progress callback */
+        notify_status(sess, ne_status_sending);
+    }
+
+    if (bytes) {
+        NE_DEBUG(NE_DBG_HTTP, "Request body provider failed with "
+                 "%" NE_FMT_SSIZE_T "\n", bytes);
+        ne_close_connection(sess);
+        return NE_ERROR;
+    }
+
+    if (chunked) {
+        if (chunknum == 0)
+            ret = ne_sock_fullwrite(sess->socket, CHUNK_NULL_TERM, 
+                                    sizeof(CHUNK_NULL_TERM) - 1);
+        else
+            ret = ne_sock_fullwrite(sess->socket, CHUNK_TERM, 
+                                    sizeof(CHUNK_TERM) - 1);
+        if (ret < 0) {
+            int aret = aborted(req, _("Could not send chunked "
+                                      "request terminator"), ret);
+            return RETRY_RET(retry, ret, aret);
+        }
+    }
+    
+    return NE_OK;
+}
+
+/* Lob the User-Agent, connection and host headers in to the request
+ * headers */
+static void add_fixed_headers(ne_request *req) 
+{
+    ne_session *const sess = req->session;
+
+    if (sess->user_agent) {
+        ne_buffer_zappend(req->headers, sess->user_agent);
+    }
+
+    /* If persistent connections are disabled, just send Connection:
+     * close; otherwise, send Connection: Keep-Alive to pre-1.1 origin
+     * servers to try harder to get a persistent connection, except if
+     * using a proxy as per 206819.7.1.  Always add TE: trailers. */
+    if (!sess->flags[NE_SESSFLAG_PERSIST]) {
+       ne_buffer_czappend(req->headers, "Connection: TE, close" EOL);
+    } 
+    else if (!sess->is_http11 && !sess->any_proxy_http) {
+        ne_buffer_czappend(req->headers, 
+                           "Keep-Alive: " EOL
+                          "Connection: TE, Keep-Alive" EOL);
+    } 
+    else if (!req->session->is_http11 && !sess->any_proxy_http) {
+        ne_buffer_czappend(req->headers, 
+                           "Keep-Alive: " EOL
+                           "Proxy-Connection: Keep-Alive" EOL
+                           "Connection: TE" EOL);
+    } 
+    else {
+        ne_buffer_czappend(req->headers, "Connection: TE" EOL);
+    }
+
+    ne_buffer_concat(req->headers, "TE: trailers" EOL "Host: ", 
+                     req->session->server.hostport, EOL, NULL);
+}
+
+int ne_accept_always(void *userdata, ne_request *req, const ne_status *st)
+{
+    return 1;
+}				   
+
+int ne_accept_2xx(void *userdata, ne_request *req, const ne_status *st)
+{
+    return (st->klass == 2);
+}
+
+ne_request *ne_request_create(ne_session *sess,
+			      const char *method, const char *path) 
+{
+    ne_request *req = ne_calloc(sizeof *req);
+
+    req->session = sess;
+    req->headers = ne_buffer_create();
+    
+    /* Presume the method is idempotent by default. */
+    req->flags[NE_REQFLAG_IDEMPOTENT] = 1;
+    /* Expect-100 default follows the corresponding session flag. */
+    req->flags[NE_REQFLAG_EXPECT100] = sess->flags[NE_SESSFLAG_EXPECT100];
+
+    /* Add in the fixed headers */
+    add_fixed_headers(req);
+
+    /* Set the standard stuff */
+    req->method = ne_strdup(method);
+    req->method_is_head = (strcmp(method, "HEAD") == 0);
+
+    /* Only use an absoluteURI here when we might be using an HTTP
+     * proxy, and SSL is in use: some servers can't parse them. */
+    if (sess->any_proxy_http && !req->session->use_ssl && path[0] == '/')
+	req->uri = ne_concat(req->session->scheme, "://", 
+                             req->session->server.hostport, path, NULL);
+    else
+	req->uri = ne_strdup(path);
+
+    {
+	struct hook *hk;
+
+	for (hk = sess->create_req_hooks; hk != NULL; hk = hk->next) {
+	    ne_create_request_fn fn = (ne_create_request_fn)hk->fn;
+	    fn(req, hk->userdata, req->method, req->uri);
+	}
+    }
+
+    return req;
+}
+
+/* Set the request body length to 'length' */
+static void set_body_length(ne_request *req, ne_off_t length)
+{
+    req->body_length = length;
+
+    if (length >= 0)
+        ne_print_request_header(req, "Content-Length", "%" FMT_NE_OFF_T, length);
+    else /* length < 0 => chunked body */
+        ne_add_request_header(req, "Transfer-Encoding", "chunked");
+
+}
+
+void ne_set_request_body_buffer(ne_request *req, const char *buffer,
+				size_t size)
+{
+    req->body.buf.buffer = buffer;
+    req->body.buf.length = size;
+    req->body_cb = body_string_send;
+    req->body_ud = req;
+    set_body_length(req, size);
+}
+
+void ne_set_request_body_provider(ne_request *req, ne_off_t bodysize,
+				  ne_provide_body provider, void *ud)
+{
+    req->body_cb = provider;
+    req->body_ud = ud;
+    set_body_length(req, bodysize);
+}
+
+void ne_set_request_body_fd(ne_request *req, int fd,
+                            ne_off_t offset, ne_off_t length)
+{
+    req->body.file.fd = fd;
+    req->body.file.offset = offset;
+    req->body.file.length = length;
+    req->body_cb = body_fd_send;
+    req->body_ud = req;
+    set_body_length(req, length);
+}
+
+void ne_set_request_flag(ne_request *req, ne_request_flag flag, int value)
+{
+    if (flag < (ne_request_flag)NE_SESSFLAG_LAST) {
+        req->flags[flag] = value;
+    }
+}
+
+int ne_get_request_flag(ne_request *req, ne_request_flag flag)
+{
+    if (flag < (ne_request_flag)NE_REQFLAG_LAST) {
+        return req->flags[flag];
+    }
+    return -1;
+}
+
+void ne_add_request_header(ne_request *req, const char *name, 
+			   const char *value)
+{
+    ne_buffer_concat(req->headers, name, ": ", value, EOL, NULL);
+}
+
+void ne_print_request_header(ne_request *req, const char *name,
+			     const char *format, ...)
+{
+    va_list params;
+    char buf[NE_BUFSIZ];
+    
+    va_start(params, format);
+    ne_vsnprintf(buf, sizeof buf, format, params);
+    va_end(params);
+    
+    ne_buffer_concat(req->headers, name, ": ", buf, EOL, NULL);
+}
+
+/* Returns the value of the response header 'name', for which the hash
+ * value is 'h', or NULL if the header is not found. */
+static inline char *get_response_header_hv(ne_request *req, unsigned int h,
+                                           const char *name)
+{
+    struct field *f;
+
+    for (f = req->response_headers[h]; f; f = f->next)
+        if (strcmp(f->name, name) == 0)
+            return f->value;
+
+    return NULL;
+}
+
+const char *ne_get_response_header(ne_request *req, const char *name)
+{
+    char *lcname = ne_strdup(name);
+    unsigned int hash = hash_and_lower(lcname);
+    char *value = get_response_header_hv(req, hash, lcname);
+    ne_free(lcname);
+    return value;
+}
+
+/* The return value of the iterator function is a pointer to the
+ * struct field of the previously returned header. */
+void *ne_response_header_iterate(ne_request *req, void *iterator,
+                                 const char **name, const char **value)
+{
+    struct field *f = iterator;
+    unsigned int n;
+
+    if (f == NULL) {
+        n = 0;
+    } else if ((f = f->next) == NULL) {
+        n = req->current_index + 1;
+    }
+
+    if (f == NULL) {
+        while (n < HH_HASHSIZE && req->response_headers[n] == NULL)
+            n++;
+        if (n == HH_HASHSIZE)
+            return NULL; /* no more headers */
+        f = req->response_headers[n];
+        req->current_index = n;
+    }
+    
+    *name = f->name;
+    *value = f->value;
+    return f;
+}
+
+/* Removes the response header 'name', which has hash value 'hash'. */
+static void remove_response_header(ne_request *req, const char *name, 
+                                   unsigned int hash)
+{
+    struct field **ptr = req->response_headers + hash;
+
+    while (*ptr) {
+        struct field *const f = *ptr;
+
+        if (strcmp(f->name, name) == 0) {
+            *ptr = f->next;
+            ne_free(f->name);
+            ne_free(f->value);
+            ne_free(f);
+            return;
+        }
+        
+        ptr = &f->next;
+    }
+}
+
+/* Free all stored response headers. */
+static void free_response_headers(ne_request *req)
+{
+    int n;
+
+    for (n = 0; n < HH_HASHSIZE; n++) {
+        struct field **ptr = req->response_headers + n;
+
+        while (*ptr) {
+            struct field *const f = *ptr;
+            *ptr = f->next;
+            ne_free(f->name);
+            ne_free(f->value);
+            ne_free(f);
+	}
+    }
+}
+
+void ne_add_response_body_reader(ne_request *req, ne_accept_response acpt,
+				 ne_block_reader rdr, void *userdata)
+{
+    struct body_reader *new = ne_malloc(sizeof *new);
+    new->accept_response = acpt;
+    new->handler = rdr;
+    new->userdata = userdata;
+    new->next = req->body_readers;
+    req->body_readers = new;
+}
+
+void ne_request_destroy(ne_request *req) 
+{
+    struct body_reader *rdr, *next_rdr;
+    struct hook *hk, *next_hk;
+
+    ne_free(req->uri);
+    ne_free(req->method);
+
+    for (rdr = req->body_readers; rdr != NULL; rdr = next_rdr) {
+	next_rdr = rdr->next;
+	ne_free(rdr);
+    }
+
+    free_response_headers(req);
+
+    ne_buffer_destroy(req->headers);
+
+    NE_DEBUG(NE_DBG_HTTP, "Running destroy hooks.\n");
+    for (hk = req->session->destroy_req_hooks; hk; hk = next_hk) {
+	ne_destroy_req_fn fn = (ne_destroy_req_fn)hk->fn;
+        next_hk = hk->next;
+	fn(req, hk->userdata);
+    }
+
+    for (hk = req->private; hk; hk = next_hk) {
+	next_hk = hk->next;
+	ne_free(hk);
+    }
+
+    if (req->status.reason_phrase)
+	ne_free(req->status.reason_phrase);
+
+    NE_DEBUG(NE_DBG_HTTP, "Request ends.\n");
+    ne_free(req);
+}
+
+
+/* Reads a block of the response into BUFFER, which is of size
+ * *BUFLEN.  Returns zero on success or non-zero on error.  On
+ * success, *BUFLEN is updated to be the number of bytes read into
+ * BUFFER (which will be 0 to indicate the end of the repsonse).  On
+ * error, the connection is closed and the session error string is
+ * set.  */
+static int read_response_block(ne_request *req, struct ne_response *resp, 
+			       char *buffer, size_t *buflen) 
+{
+    ne_socket *const sock = req->session->socket;
+    size_t willread;
+    ssize_t readlen;
+    
+    switch (resp->mode) {
+    case R_CHUNKED:
+        /* Chunked transfer-encoding: chunk syntax is "SIZE CRLF CHUNK
+         * CRLF SIZE CRLF CHUNK CRLF ..." followed by zero-length
+         * chunk: "CHUNK CRLF 0 CRLF".  resp.chunk.remain contains the
+         * number of bytes left to read in the current chunk. */
+	if (resp->body.chunk.remain == 0) {
+	    unsigned long chunk_len;
+	    char *ptr;
+
+            /* Read the chunk size line into a temporary buffer. */
+            SOCK_ERR(req,
+                     ne_sock_readline(sock, req->respbuf, sizeof req->respbuf),
+                     _("Could not read chunk size"));
+            NE_DEBUG(NE_DBG_HTTP, "[chunk] < %s", req->respbuf);
+            chunk_len = strtoul(req->respbuf, &ptr, 16);
+	    /* limit chunk size to <= UINT_MAX, so it will probably
+	     * fit in a size_t. */
+	    if (ptr == req->respbuf || 
+		chunk_len == ULONG_MAX || chunk_len > UINT_MAX) {
+		return aborted(req, _("Could not parse chunk size"), 0);
+	    }
+	    NE_DEBUG(NE_DBG_HTTP, "Got chunk size: %lu\n", chunk_len);
+	    resp->body.chunk.remain = chunk_len;
+	}
+	willread = resp->body.chunk.remain > *buflen
+            ? *buflen : resp->body.chunk.remain;
+	break;
+    case R_CLENGTH:
+	willread = resp->body.clen.remain > (off_t)*buflen 
+            ? *buflen : (size_t)resp->body.clen.remain;
+	break;
+    case R_TILLEOF:
+	willread = *buflen;
+	break;
+    case R_NO_BODY:
+    default:
+	willread = 0;
+	break;
+    }
+    if (willread == 0) {
+	*buflen = 0;
+	return 0;
+    }
+    NE_DEBUG(NE_DBG_HTTP,
+	     "Reading %" NE_FMT_SIZE_T " bytes of response body.\n", willread);
+    readlen = ne_sock_read(sock, buffer, willread);
+
+    /* EOF is only valid when response body is delimited by it.
+     * Strictly, an SSL truncation should not be treated as an EOF in
+     * any case, but SSL servers are just too buggy.  */
+    if (resp->mode == R_TILLEOF && 
+	(readlen == NE_SOCK_CLOSED || readlen == NE_SOCK_TRUNC)) {
+	NE_DEBUG(NE_DBG_HTTP, "Got EOF.\n");
+	req->can_persist = 0;
+	readlen = 0;
+    } else if (readlen < 0) {
+	return aborted(req, _("Could not read response body"), readlen);
+    } else {
+	NE_DEBUG(NE_DBG_HTTP, "Got %" NE_FMT_SSIZE_T " bytes.\n", readlen);
+    }
+    /* safe to cast: readlen guaranteed to be >= 0 above */
+    *buflen = (size_t)readlen;
+    NE_DEBUG(NE_DBG_HTTPBODY,
+	     "Read block (%" NE_FMT_SSIZE_T " bytes):\n[%.*s]\n",
+	     readlen, (int)readlen, buffer);
+    if (resp->mode == R_CHUNKED) {
+	resp->body.chunk.remain -= readlen;
+	if (resp->body.chunk.remain == 0) {
+	    char crlfbuf[2];
+	    /* If we've read a whole chunk, read a CRLF */
+	    readlen = ne_sock_fullread(sock, crlfbuf, 2);
+            if (readlen < 0)
+                return aborted(req, _("Could not read chunk delimiter"),
+                               readlen);
+            else if (crlfbuf[0] != '\r' || crlfbuf[1] != '\n')
+                return aborted(req, _("Chunk delimiter was invalid"), 0);
+	}
+    } else if (resp->mode == R_CLENGTH) {
+	resp->body.clen.remain -= readlen;
+    }
+    resp->progress += readlen;
+    return NE_OK;
+}
+
+ssize_t ne_read_response_block(ne_request *req, char *buffer, size_t buflen)
+{
+    struct body_reader *rdr;
+    size_t readlen = buflen;
+    struct ne_response *const resp = &req->resp;
+
+    if (read_response_block(req, resp, buffer, &readlen))
+	return -1;
+
+    if (readlen) {
+        req->session->status.sr.progress += readlen;
+        notify_status(req->session, ne_status_recving);
+    }
+
+    for (rdr = req->body_readers; rdr!=NULL; rdr=rdr->next) {
+	if (rdr->use && rdr->handler(rdr->userdata, buffer, readlen) != 0) {
+            ne_close_connection(req->session);
+            return -1;
+        }
+    }
+    
+    return readlen;
+}
+
+/* Build the request string, returning the buffer. */
+static ne_buffer *build_request(ne_request *req) 
+{
+    struct hook *hk;
+    ne_buffer *buf = ne_buffer_create();
+
+    /* Add Request-Line and headers: */
+    ne_buffer_concat(buf, req->method, " ", req->uri, " HTTP/1.1" EOL, NULL);
+
+    /* Add custom headers: */
+    ne_buffer_append(buf, req->headers->data, ne_buffer_size(req->headers));
+
+    if (req->body_length && req->flags[NE_REQFLAG_EXPECT100]) {
+        ne_buffer_czappend(buf, "Expect: 100-continue\r\n");
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "Running pre_send hooks\n");
+    for (hk = req->session->pre_send_hooks; hk!=NULL; hk = hk->next) {
+	ne_pre_send_fn fn = (ne_pre_send_fn)hk->fn;
+	fn(req, hk->userdata, buf);
+    }
+    
+    ne_buffer_czappend(buf, "\r\n");
+    return buf;
+}
+
+#ifdef NE_DEBUGGING
+#define DEBUG_DUMP_REQUEST(x) dump_request(x)
+
+static void dump_request(const char *request)
+{ 
+    if (ne_debug_mask & NE_DBG_HTTPPLAIN) { 
+	/* Display everything mode */
+	NE_DEBUG(NE_DBG_HTTP, "Sending request headers:\n%s", request);
+    } else if (ne_debug_mask & NE_DBG_HTTP) {
+	/* Blank out the Authorization paramaters */
+	char *reqdebug = ne_strdup(request), *pnt = reqdebug;
+	while ((pnt = strstr(pnt, "Authorization: ")) != NULL) {
+	    for (pnt += 15; *pnt != '\r' && *pnt != '\0'; pnt++) {
+		*pnt = 'x';
+	    }
+	}
+	NE_DEBUG(NE_DBG_HTTP, "Sending request headers:\n%s", reqdebug);
+	ne_free(reqdebug);
+    }
+}
+
+#else
+#define DEBUG_DUMP_REQUEST(x)
+#endif /* DEBUGGING */
+
+/* remove trailing EOL from 'buf', where strlen(buf) == *len.  *len is
+ * adjusted in accordance with any changes made to the string to
+ * remain equal to strlen(buf). */
+static inline void strip_eol(char *buf, ssize_t *len)
+{
+    char *pnt = buf + *len - 1;
+    while (pnt >= buf && (*pnt == '\r' || *pnt == '\n')) {
+	*pnt-- = '\0';
+	(*len)--;
+    }
+}
+
+/* Read and parse response status-line into 'status'.  'retry' is non-zero
+ * if an NE_RETRY should be returned if an EOF is received. */
+static int read_status_line(ne_request *req, ne_status *status, int retry)
+{
+    char *buffer = req->respbuf;
+    ssize_t ret;
+
+    ret = ne_sock_readline(req->session->socket, buffer, sizeof req->respbuf);
+    if (ret <= 0) {
+	int aret = aborted(req, _("Could not read status line"), ret);
+	return RETRY_RET(retry, ret, aret);
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "[status-line] < %s", buffer);
+    strip_eol(buffer, &ret);
+    
+    if (status->reason_phrase) ne_free(status->reason_phrase);
+    memset(status, 0, sizeof *status);
+
+    /* Hack to allow ShoutCast-style servers, if requested. */
+    if (req->session->flags[NE_SESSFLAG_ICYPROTO]
+        && strncmp(buffer, "ICY ", 4) == 0 && strlen(buffer) > 8
+        && buffer[7] == ' ') {
+        status->code = atoi(buffer + 4);
+        status->major_version = 1;
+        status->minor_version = 0;
+        status->reason_phrase = ne_strclean(ne_strdup(buffer + 8));
+        status->klass = buffer[4] - '0';
+        NE_DEBUG(NE_DBG_HTTP, "[status-line] ICY protocol; code %d\n", 
+                 status->code);
+    } else if (ne_parse_statusline(buffer, status)) {
+	return aborted(req, _("Could not parse response status line"), 0);
+    }
+
+    return 0;
+}
+
+/* Discard a set of message headers. */
+static int discard_headers(ne_request *req)
+{
+    do {
+	SOCK_ERR(req, ne_sock_readline(req->session->socket, req->respbuf, 
+				       sizeof req->respbuf),
+		 _("Could not read interim response headers"));
+	NE_DEBUG(NE_DBG_HTTP, "[discard] < %s", req->respbuf);
+    } while (strcmp(req->respbuf, EOL) != 0);
+    return NE_OK;
+}
+
+/* Send the request, and read the response Status-Line. Returns:
+ *   NE_RETRY   connection closed by server; persistent connection
+ *		timeout
+ *   NE_OK	success
+ *   NE_*	error
+ * On NE_RETRY and NE_* responses, the connection will have been 
+ * closed already.
+ */
+static int send_request(ne_request *req, const ne_buffer *request)
+{
+    ne_session *const sess = req->session;
+    ne_status *const status = &req->status;
+    int sentbody = 0; /* zero until body has been sent. */
+    int ret, retry; /* retry non-zero whilst the request should be retried */
+    ssize_t sret;
+
+    /* Send the Request-Line and headers */
+    NE_DEBUG(NE_DBG_HTTP, "Sending request-line and headers:\n");
+    /* Open the connection if necessary */
+    ret = open_connection(sess);
+    if (ret) return ret;
+
+    /* Allow retry if a persistent connection has been used. */
+    retry = sess->persisted;
+    
+    sret = ne_sock_fullwrite(req->session->socket, request->data, 
+                             ne_buffer_size(request));
+    if (sret < 0) {
+	int aret = aborted(req, _("Could not send request"), sret);
+	return RETRY_RET(retry, sret, aret);
+    }
+    
+    if (!req->flags[NE_REQFLAG_EXPECT100] && req->body_length) {
+	/* Send request body, if not using 100-continue. */
+	ret = send_request_body(req, retry);
+	if (ret) {
+            return ret;
+	}
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Request sent; retry is %d.\n", retry);
+
+    /* Loop eating interim 1xx responses (RFC2616 says these MAY be
+     * sent by the server, even if 100-continue is not used). */
+    while ((ret = read_status_line(req, status, retry)) == NE_OK 
+	   && status->klass == 1) {
+	NE_DEBUG(NE_DBG_HTTP, "Interim %d response.\n", status->code);
+	retry = 0; /* successful read() => never retry now. */
+	/* Discard headers with the interim response. */
+	if ((ret = discard_headers(req)) != NE_OK) break;
+
+	if (req->flags[NE_REQFLAG_EXPECT100] && (status->code == 100)
+            && req->body_length && !sentbody) {
+	    /* Send the body after receiving the first 100 Continue */
+	    if ((ret = send_request_body(req, 0)) != NE_OK) break;	    
+	    sentbody = 1;
+	}
+    }
+
+    return ret;
+}
+
+/* Read a message header from sock into buf, which has size 'buflen'.
+ *
+ * Returns:
+ *   NE_RETRY: Success, read a header into buf.
+ *   NE_OK: End of headers reached.
+ *   NE_ERROR: Error (session error is set, connection closed).
+ */
+static int read_message_header(ne_request *req, char *buf, size_t buflen)
+{
+    ssize_t n;
+    ne_socket *sock = req->session->socket;
+
+    n = ne_sock_readline(sock, buf, buflen);
+    if (n <= 0)
+	return aborted(req, _("Error reading response headers"), n);
+    NE_DEBUG(NE_DBG_HTTP, "[hdr] %s", buf);
+
+    strip_eol(buf, &n);
+
+    if (n == 0) {
+	NE_DEBUG(NE_DBG_HTTP, "End of headers.\n");
+	return NE_OK;
+    }
+
+    buf += n;
+    buflen -= n;
+
+    while (buflen > 0) {
+	char ch;
+
+	/* Collect any extra lines into buffer */
+	SOCK_ERR(req, ne_sock_peek(sock, &ch, 1),
+		 _("Error reading response headers"));
+
+	if (ch != ' ' && ch != '\t') {
+	    /* No continuation of this header: stop reading. */
+	    return NE_RETRY;
+	}
+
+	/* Otherwise, read the next line onto the end of 'buf'. */
+	n = ne_sock_readline(sock, buf, buflen);
+	if (n <= 0) {
+	    return aborted(req, _("Error reading response headers"), n);
+	}
+
+	NE_DEBUG(NE_DBG_HTTP, "[cont] %s", buf);
+
+	strip_eol(buf, &n);
+	
+	/* assert(buf[0] == ch), which implies len(buf) > 0.
+	 * Otherwise the TCP stack is lying, but we'll be paranoid.
+	 * This might be a \t, so replace it with a space to be
+	 * friendly to applications (2616 says we MAY do this). */
+	if (n) buf[0] = ' ';
+
+	/* ready for the next header. */
+	buf += n;
+	buflen -= n;
+    }
+
+    ne_set_error(req->session, _("Response header too long"));
+    return NE_ERROR;
+}
+
+#define MAX_HEADER_LEN (8192)
+
+/* Add a respnose header field for the given request, using
+ * precalculated hash value. */
+static void add_response_header(ne_request *req, unsigned int hash,
+                                char *name, char *value)
+{
+    struct field **nextf = &req->response_headers[hash];
+    size_t vlen = strlen(value);
+
+    while (*nextf) {
+        struct field *const f = *nextf;
+        if (strcmp(f->name, name) == 0) {
+            if (vlen + f->vlen < MAX_HEADER_LEN) {
+                /* merge the header field */
+                f->value = ne_realloc(f->value, f->vlen + vlen + 3);
+                memcpy(f->value + f->vlen, ", ", 2);
+                memcpy(f->value + f->vlen + 2, value, vlen + 1);
+                f->vlen += vlen + 2;
+            }
+            return;
+        }
+        nextf = &f->next;
+    }
+    
+    (*nextf) = ne_malloc(sizeof **nextf);
+    (*nextf)->name = ne_strdup(name);
+    (*nextf)->value = ne_strdup(value);
+    (*nextf)->vlen = vlen;
+    (*nextf)->next = NULL;
+}
+
+/* Read response headers.  Returns NE_* code, sets session error and
+ * closes connection on error. */
+static int read_response_headers(ne_request *req) 
+{
+    char hdr[MAX_HEADER_LEN];
+    int ret, count = 0;
+    
+    while ((ret = read_message_header(req, hdr, sizeof hdr)) == NE_RETRY 
+	   && ++count < MAX_HEADER_FIELDS) {
+	char *pnt;
+	unsigned int hash = 0;
+	
+	/* Strip any trailing whitespace */
+	pnt = hdr + strlen(hdr) - 1;
+	while (pnt > hdr && (*pnt == ' ' || *pnt == '\t'))
+	    *pnt-- = '\0';
+
+	/* Convert the header name to lower case and hash it. */
+	for (pnt = hdr; (*pnt != '\0' && *pnt != ':' && 
+			 *pnt != ' ' && *pnt != '\t'); pnt++) {
+	    *pnt = ne_tolower(*pnt);
+	    hash = HH_ITERATE(hash,*pnt);
+	}
+
+	/* Skip over any whitespace before the colon. */
+	while (*pnt == ' ' || *pnt == '\t')
+	    *pnt++ = '\0';
+
+	/* ignore header lines which lack a ':'. */
+	if (*pnt != ':')
+	    continue;
+	
+	/* NUL-terminate at the colon (when no whitespace before) */
+	*pnt++ = '\0';
+
+	/* Skip any whitespace after the colon... */
+	while (*pnt == ' ' || *pnt == '\t')
+	    pnt++;
+
+	/* pnt now points to the header value. */
+	NE_DEBUG(NE_DBG_HTTP, "Header Name: [%s], Value: [%s]\n", hdr, pnt);
+        add_response_header(req, hash, hdr, pnt);
+    }
+
+    if (count == MAX_HEADER_FIELDS)
+	ret = aborted(
+	    req, _("Response exceeded maximum number of header fields"), 0);
+
+    return ret;
+}
+
+/* Perform any necessary DNS lookup for the host given by *info;
+ * returns NE_ code with error string set on error. */
+static int lookup_host(ne_session *sess, struct host_info *info)
+{
+    NE_DEBUG(NE_DBG_HTTP, "Doing DNS lookup on %s...\n", info->hostname);
+    sess->status.lu.hostname = info->hostname;
+    notify_status(sess, ne_status_lookup);
+    info->address = ne_addr_resolve(info->hostname, 0);
+    if (ne_addr_result(info->address)) {
+	char buf[256];
+	ne_set_error(sess, _("Could not resolve hostname `%s': %s"), 
+		     info->hostname,
+		     ne_addr_error(info->address, buf, sizeof buf));
+	ne_addr_destroy(info->address);
+	info->address = NULL;
+	return NE_LOOKUP;
+    } else {
+	return NE_OK;
+    }
+}
+
+int ne_begin_request(ne_request *req)
+{
+    struct body_reader *rdr;
+    ne_buffer *data;
+    const ne_status *const st = &req->status;
+    const char *value;
+    struct hook *hk;
+    int ret, forced_closure = 0;
+
+    /* If a non-idempotent request is sent on a persisted connection,
+     * then it is impossible to distinguish between a server failure
+     * and a connection timeout if an EOF/RST is received.  So don't
+     * do that. */
+    if (!req->flags[NE_REQFLAG_IDEMPOTENT] && req->session->persisted
+        && !req->session->flags[NE_SESSFLAG_CONNAUTH]) {
+        NE_DEBUG(NE_DBG_HTTP, "req: Closing connection for non-idempotent "
+                 "request.\n");
+        ne_close_connection(req->session);
+    }
+
+    /* Build the request string, and send it */
+    data = build_request(req);
+    DEBUG_DUMP_REQUEST(data->data);
+    ret = send_request(req, data);
+    /* Retry this once after a persistent connection timeout. */
+    if (ret == NE_RETRY) {
+	NE_DEBUG(NE_DBG_HTTP, "Persistent connection timed out, retrying.\n");
+	ret = send_request(req, data);
+    }
+    ne_buffer_destroy(data);
+    if (ret != NE_OK) return ret == NE_RETRY ? NE_ERROR : ret;
+
+    /* Determine whether server claims HTTP/1.1 compliance. */
+    req->session->is_http11 = (st->major_version == 1 && 
+                               st->minor_version > 0) || st->major_version > 1;
+
+    /* Persistent connections supported implicitly in HTTP/1.1 */
+    if (req->session->is_http11) req->can_persist = 1;
+
+    ne_set_error(req->session, "%d %s", st->code, st->reason_phrase);
+    
+    /* Empty the response header hash, in case this request was
+     * retried: */
+    free_response_headers(req);
+
+    /* Read the headers */
+    ret = read_response_headers(req);
+    if (ret) return ret;
+
+    /* check the Connection header */
+    value = get_response_header_hv(req, HH_HV_CONNECTION, "connection");
+    if (value) {
+        char *vcopy = ne_strdup(value), *ptr = vcopy;
+
+        do {
+            char *token = ne_shave(ne_token(&ptr, ','), " \t");
+            unsigned int hash = hash_and_lower(token);
+
+            if (strcmp(token, "close") == 0) {
+                req->can_persist = 0;
+                forced_closure = 1;
+            } else if (strcmp(token, "keep-alive") == 0) {
+                req->can_persist = 1;
+            } else if (!req->session->is_http11
+                       && strcmp(token, "connection")) {
+                /* Strip the header per 261614.10, last para.  Avoid
+                 * danger from "Connection: connection". */
+                remove_response_header(req, token, hash);
+            }
+        } while (ptr);
+        
+        ne_free(vcopy);
+    }
+
+    /* Support "Proxy-Connection: keep-alive" for compatibility with
+     * some HTTP/1.0 proxies; it is risky to do this, because an
+     * intermediary proxy may not support this HTTP/1.0 extension, but
+     * will not strip the header either.  Persistent connection
+     * support is enabled based on the presence of this header if:
+     * a) it is *necessary* to do so due to the use of a connection-auth
+     * scheme, and
+     * b) connection closure was not forced via "Connection: close".  */
+    if (req->session->nexthop->proxy == PROXY_HTTP && !req->session->is_http11
+        && !forced_closure && req->session->flags[NE_SESSFLAG_CONNAUTH]) {
+        value = get_response_header_hv(req, HH_HV_PROXY_CONNECTION,
+                                       "proxy-connection");
+        if (value && ne_strcasecmp(value, "keep-alive") == 0) {
+            NE_DEBUG(NE_DBG_HTTP, "req: Using persistent connection "
+                     "for HTTP/1.0 proxy requiring conn-auth hack.\n");
+            req->can_persist = 1;
+        }
+    }
+
+    /* Decide which method determines the response message-length per
+     * 26164.4 (multipart/byteranges is not supported): */
+
+#ifdef NE_HAVE_SSL
+    /* Special case for CONNECT handling: the response has no body,
+     * and the connection can persist. */
+    if (req->session->in_connect && st->klass == 2) {
+	req->resp.mode = R_NO_BODY;
+	req->can_persist = 1;
+    } else
+#endif
+    /* HEAD requests and 204, 304 responses have no response body,
+     * regardless of what headers are present. */
+    if (req->method_is_head || st->code == 204 || st->code == 304) {
+    	req->resp.mode = R_NO_BODY;
+    }
+    /* Broken intermediaries exist which use "transfer-encoding: identity"
+     * to mean "no transfer-coding".  So that case must be ignored. */
+    else if ((value = get_response_header_hv(req, HH_HV_TRANSFER_ENCODING,
+                                             "transfer-encoding")) != NULL
+             && ne_strcasecmp(value, "identity") != 0) {
+        /* Otherwise, fail iff an unknown transfer-coding is used. */
+        if (ne_strcasecmp(value, "chunked") == 0) {
+            req->resp.mode = R_CHUNKED;
+            req->resp.body.chunk.remain = 0;
+        }
+        else {
+            return aborted(req, _("Unknown transfer-coding in response"), 0);
+        }
+    } 
+    else if ((value = get_response_header_hv(req, HH_HV_CONTENT_LENGTH,
+                                             "content-length")) != NULL) {
+        char *endptr = NULL;
+        ne_off_t len = ne_strtoff(value, &endptr, 10);
+
+        if (*value && len != NE_OFFT_MAX && len >= 0 && endptr && *endptr == '\0') {
+            req->resp.mode = R_CLENGTH;
+            req->resp.body.clen.total = req->resp.body.clen.remain = len;
+        } else {
+            /* fail for an invalid content-length header. */
+            return aborted(req, _("Invalid Content-Length in response"), 0);
+        }
+    } else {
+        req->resp.mode = R_TILLEOF; /* otherwise: read-till-eof mode */
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Running post_headers hooks\n");
+    for (hk = req->session->post_headers_hooks; hk != NULL; hk = hk->next) {
+        ne_post_headers_fn fn = (ne_post_headers_fn)hk->fn;
+        fn(req, hk->userdata, &req->status);
+    }
+    
+    /* Prepare for reading the response entity-body.  Call each of the
+     * body readers and ask them whether they want to accept this
+     * response or not. */
+    for (rdr = req->body_readers; rdr != NULL; rdr=rdr->next) {
+	rdr->use = rdr->accept_response(rdr->userdata, req, st);
+    }
+
+    req->session->status.sr.progress = 0;
+    req->session->status.sr.total = 
+        req->resp.mode == R_CLENGTH ? req->resp.body.clen.total : -1;
+    notify_status(req->session, ne_status_recving);
+    
+    return NE_OK;
+}
+
+int ne_end_request(ne_request *req)
+{
+    struct hook *hk;
+    int ret;
+
+    /* Read headers in chunked trailers */
+    if (req->resp.mode == R_CHUNKED) {
+	ret = read_response_headers(req);
+        if (ret) return ret;
+    } else {
+        ret = NE_OK;
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Running post_send hooks\n");
+    for (hk = req->session->post_send_hooks; 
+	 ret == NE_OK && hk != NULL; hk = hk->next) {
+	ne_post_send_fn fn = (ne_post_send_fn)hk->fn;
+	ret = fn(req, hk->userdata, &req->status);
+    }
+    
+    /* Close the connection if persistent connections are disabled or
+     * not supported by the server. */
+    if (!req->session->flags[NE_SESSFLAG_PERSIST] || !req->can_persist)
+	ne_close_connection(req->session);
+    else
+	req->session->persisted = 1;
+    
+    return ret;
+}
+
+int ne_read_response_to_fd(ne_request *req, int fd)
+{
+    ssize_t len;
+
+    while ((len = ne_read_response_block(req, req->respbuf, 
+                                         sizeof req->respbuf)) > 0) {
+        const char *block = req->respbuf;
+
+        do {
+            ssize_t ret = write(fd, block, len);
+            if (ret == -1 && errno == EINTR) {
+                continue;
+            } else if (ret < 0) {
+                char err[200];
+                ne_strerror(errno, err, sizeof err);
+                ne_set_error(ne_get_session(req), 
+                             _("Could not write to file: %s"), err);
+                return NE_ERROR;
+            } else {
+                len -= ret;
+                block += ret;
+            }
+        } while (len > 0);
+    }
+    
+    return len == 0 ? NE_OK : NE_ERROR;
+}
+
+int ne_discard_response(ne_request *req)
+{
+    ssize_t len;
+
+    do {
+        len = ne_read_response_block(req, req->respbuf, sizeof req->respbuf);
+    } while (len > 0);
+    
+    return len == 0 ? NE_OK : NE_ERROR;
+}
+
+int ne_request_dispatch(ne_request *req) 
+{
+    int ret;
+    
+    do {
+	ret = ne_begin_request(req);
+        if (ret == NE_OK) ret = ne_discard_response(req);
+        if (ret == NE_OK) ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    NE_DEBUG(NE_DBG_HTTP | NE_DBG_FLUSH, 
+             "Request ends, status %d class %dxx, error line:\n%s\n", 
+             req->status.code, req->status.klass, req->session->error);
+
+    return ret;
+}
+
+const ne_status *ne_get_status(const ne_request *req)
+{
+    return &req->status;
+}
+
+ne_session *ne_get_session(const ne_request *req)
+{
+    return req->session;
+}
+
+#ifdef NE_HAVE_SSL
+/* Create a CONNECT tunnel through the proxy server.
+ * Returns HTTP_* */
+static int proxy_tunnel(ne_session *sess)
+{
+    /* Hack up an HTTP CONNECT request... */
+    ne_request *req;
+    int ret = NE_OK;
+    char ruri[200];
+
+    /* Can't use server.hostport here; Request-URI must include `:port' */
+    ne_snprintf(ruri, sizeof ruri, "%s:%u", sess->server.hostname,  
+		sess->server.port);
+    req = ne_request_create(sess, "CONNECT", ruri);
+
+    sess->in_connect = 1;
+    ret = ne_request_dispatch(req);
+    sess->in_connect = 0;
+
+    sess->persisted = 0; /* don't treat this is a persistent connection. */
+
+    if (ret != NE_OK || !sess->connected || req->status.klass != 2) {
+        char *err = ne_strdup(sess->error);
+        ne_set_error(sess, _("Could not create SSL connection "
+                             "through proxy server: %s"), err);
+        ne_free(err);
+        if (ret == NE_OK) ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
+#endif
+
+/* Return the first resolved address for the given host. */
+static const ne_inet_addr *resolve_first(struct host_info *host)
+{
+    return host->network ? host->network : ne_addr_first(host->address);
+}
+
+/* Return the next resolved address for the given host or NULL if
+ * there are no more addresses. */
+static const ne_inet_addr *resolve_next(struct host_info *host)
+{
+    return host->network ? NULL : ne_addr_next(host->address);
+}
+
+/* Make new TCP connection to server at 'host' of type 'name'.  Note
+ * that once a connection to a particular network address has
+ * succeeded, that address will be used first for the next attempt to
+ * connect. */
+static int do_connect(ne_session *sess, struct host_info *host)
+{
+    int ret;
+
+    /* Resolve hostname if necessary. */
+    if (host->address == NULL && host->network == NULL) {
+        ret = lookup_host(sess, host);
+        if (ret) return ret;
+    }
+
+    if ((sess->socket = ne_sock_create()) == NULL) {
+        ne_set_error(sess, _("Could not create socket"));
+        return NE_ERROR;
+    }
+
+    if (sess->cotimeout)
+	ne_sock_connect_timeout(sess->socket, sess->cotimeout);
+
+    if (sess->local_addr)
+        ne_sock_prebind(sess->socket, sess->local_addr, 0);
+
+    if (host->current == NULL)
+	host->current = resolve_first(host);
+
+    sess->status.ci.hostname = host->hostname;
+
+    do {
+        sess->status.ci.address = host->current;
+	notify_status(sess, ne_status_connecting);
+#ifdef NE_DEBUGGING
+	if (ne_debug_mask & NE_DBG_HTTP) {
+	    char buf[150];
+	    NE_DEBUG(NE_DBG_HTTP, "req: Connecting to %s:%u\n",
+		     ne_iaddr_print(host->current, buf, sizeof buf),
+                     host->port);
+	}
+#endif
+	ret = ne_sock_connect(sess->socket, host->current, host->port);
+    } while (ret && /* try the next address... */
+	     (host->current = resolve_next(host)) != NULL);
+
+    if (ret) {
+        const char *msg;
+
+        if (host->proxy == PROXY_NONE)
+            msg = _("Could not connect to server");
+        else
+            msg = _("Could not connect to proxy server");
+
+        ne_set_error(sess, "%s: %s", msg, ne_sock_error(sess->socket));
+        ne_sock_close(sess->socket);
+	return ret == NE_SOCK_TIMEOUT ? NE_TIMEOUT : NE_CONNECT;
+    }
+
+    if (sess->rdtimeout)
+	ne_sock_read_timeout(sess->socket, sess->rdtimeout);
+
+    notify_status(sess, ne_status_connected);
+    sess->nexthop = host;
+
+    sess->connected = 1;
+    /* clear persistent connection flag. */
+    sess->persisted = 0;
+    return NE_OK;
+}
+
+/* For a SOCKSv4 proxy only, the IP address of the origin server (in
+ * addition to the proxy) must be known, and must be an IPv4 address.
+ * Returns NE_*; connection closed and error string set on error. */
+static int socks_origin_lookup(ne_session *sess)
+{
+    const ne_inet_addr *ia;
+    int ret;
+
+    ret = lookup_host(sess, &sess->server);
+    if (ret) {
+        /* lookup_host already set the error string. */
+        ne_close_connection(sess);
+        return ret;
+    }
+    
+    /* Find the first IPv4 address available for the server. */
+    for (ia = ne_addr_first(sess->server.address);
+         ia && ne_iaddr_typeof(ia) == ne_iaddr_ipv6;
+         ia = ne_addr_next(sess->server.address)) {
+        /* noop */
+    }
+
+    /* ... if any */
+    if (ia == NULL) {
+        ne_set_error(sess, _("Could not find IPv4 address of "
+                             "hostname %s for SOCKS v4 proxy"), 
+                     sess->server.hostname);
+        ne_close_connection(sess);
+        return NE_LOOKUP;
+    }
+
+    sess->server.current = ia;
+    
+    return ret;
+}
+
+static int open_connection(ne_session *sess) 
+{
+    int ret;
+    
+    if (sess->connected) return NE_OK;
+
+    if (!sess->proxies) {
+        ret = do_connect(sess, &sess->server);
+        if (ret) {
+            sess->nexthop = NULL;
+            return ret;
+        }
+    }
+    else {
+        struct host_info *hi;
+
+        /* Attempt to re-use proxy to avoid iterating through
+         * unnecessarily. */
+        if (sess->prev_proxy) 
+            ret = do_connect(sess, sess->prev_proxy);
+        else
+            ret = NE_ERROR;
+
+        /* Otherwise, try everything - but omitting prev_proxy if that
+         * has already been tried. */
+        for (hi = sess->proxies; hi && ret; hi = hi->next) {
+            if (hi != sess->prev_proxy)
+                ret = do_connect(sess, hi);
+        }
+
+        if (ret == NE_OK && sess->nexthop->proxy == PROXY_SOCKS) {
+            /* Special-case for SOCKS v4 proxies, which require the
+             * client to resolve the origin server IP address. */
+            if (sess->socks_ver == NE_SOCK_SOCKSV4) {
+                ret = socks_origin_lookup(sess);
+            }
+            
+            if (ret == NE_OK) {
+                /* Perform the SOCKS handshake, instructing the proxy
+                 * to set up the connection to the origin server. */
+                ret = ne_sock_proxy(sess->socket, sess->socks_ver, 
+                                    sess->server.current,
+                                    sess->server.hostname, sess->server.port,
+                                    sess->socks_user, sess->socks_password);
+                if (ret) {
+                    ne_set_error(sess, 
+                                 _("Could not establish connection from "
+                                   "SOCKS proxy (%s:%u): %s"),
+                                 sess->nexthop->hostname,
+                                 sess->nexthop->port,
+                                 ne_sock_error(sess->socket));
+                    ne_close_connection(sess);
+                    ret = NE_ERROR;
+                }
+            }
+        }
+
+        if (ret != NE_OK) {
+            sess->nexthop = NULL;
+            sess->prev_proxy = NULL;
+            return ret;
+        }
+        
+        /* Success - make this proxy stick. */
+        sess->prev_proxy = hi;
+    }
+
+#ifdef NE_HAVE_SSL
+    /* Negotiate SSL layer if required. */
+    if (sess->use_ssl && !sess->in_connect) {
+        /* Set up CONNECT tunnel if using an HTTP proxy. */
+        if (sess->nexthop->proxy == PROXY_HTTP)
+            ret = proxy_tunnel(sess);
+        
+        if (ret == NE_OK) {
+            ret = ne__negotiate_ssl(sess);
+            if (ret != NE_OK)
+                ne_close_connection(sess);
+        }
+    }
+#endif
+    
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_request.h b/net/mmt/neon/src/ne_request.h
new file mode 100644
index 0000000..be6f3a1
--- /dev/null
+++ b/net/mmt/neon/src/ne_request.h
@@ -0,0 +1,318 @@
+/* 
+   HTTP Request Handling
+   Copyright (C) 1999-2006, 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_REQUEST_H
+#define NE_REQUEST_H
+
+#include "ne_utils.h" /* For ne_status */
+#include "ne_string.h" /* For ne_buffer */
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+#define NE_OK (0) /* Success */
+#define NE_ERROR (1) /* Generic error; use ne_get_error(session) for message */
+#define NE_LOOKUP (2) /* Server or proxy hostname lookup failed */
+#define NE_AUTH (3) /* User authentication failed on server */
+#define NE_PROXYAUTH (4) /* User authentication failed on proxy */
+#define NE_CONNECT (5) /* Could not connect to server */
+#define NE_TIMEOUT (6) /* Connection timed out */
+#define NE_FAILED (7) /* The precondition failed */
+#define NE_RETRY (8) /* Retry request (ne_end_request ONLY) */
+#define NE_REDIRECT (9) /* See ne_redirect.h */
+
+/* Opaque object representing a single HTTP request. */
+typedef struct ne_request_s ne_request;
+
+/***** Request Handling *****/
+
+/* Create a request in session 'sess', with given method and path.
+ * 'path' must conform to the 'abs_path' grammar in RFC2396, with an
+ * optional "? query" part, and MUST be URI-escaped by the caller. */
+ne_request *ne_request_create(ne_session *sess,
+			      const char *method, const char *path);
+
+/* The request body will be taken from 'size' bytes of 'buffer'. */
+void ne_set_request_body_buffer(ne_request *req, const char *buffer,
+				size_t size);
+
+/* The request body will be taken from 'length' bytes read from the
+ * file descriptor 'fd', starting from file offset 'offset'. */
+void ne_set_request_body_fd(ne_request *req, int fd,
+                            ne_off_t offset, ne_off_t length);
+
+/* "Pull"-based request body provider: a callback which is invoked to
+ * provide blocks of request body on demand.
+ *
+ * Before each time the body is provided, the callback will be called
+ * once with buflen == 0.  The body may have to be provided >1 time
+ * per request (for authentication retries etc.).
+ *
+ * For a call with buflen == 0, the callback must return zero on success
+ * or non-zero on error; the session error string must be set on error.
+ * For a call with buflen > 0, the callback must return:
+ *        <0           : error, abort request; session error string must be set.
+ *         0           : ignore 'buffer' contents, end of body.
+ *     0 < x <= buflen : buffer contains x bytes of body data.  */
+typedef ssize_t (*ne_provide_body)(void *userdata, 
+				   char *buffer, size_t buflen);
+
+/* Install a callback which is invoked as needed to provide the
+ * request body, a block at a time.  The total size of the request
+ * body is 'length'; the callback must ensure that it returns no more
+ * than 'length' bytes in total.  If 'length' is set to -1, then the
+ * total size of the request is unknown by the caller and chunked 
+ * tranfer will be used. */
+void ne_set_request_body_provider(ne_request *req, ne_off_t length,
+                                  ne_provide_body provider, void *userdata);
+
+/* Handling response bodies; two callbacks must be provided:
+ *
+ * 1) 'acceptance' callback: determines whether you want to handle the
+ * response body given the response-status information, e.g., if you
+ * only want 2xx responses, say so here.
+ *
+ * 2) 'reader' callback: passed blocks of the response-body as they
+ * arrive, if the acceptance callback returned non-zero.  */
+
+/* 'acceptance' callback type. Return non-zero to accept the response,
+ * else zero to ignore it. */
+typedef int (*ne_accept_response)(void *userdata, ne_request *req, 
+                                  const ne_status *st);
+
+/* An 'acceptance' callback which only accepts 2xx-class responses.
+ * Ignores userdata. */
+int ne_accept_2xx(void *userdata, ne_request *req, const ne_status *st);
+
+/* An acceptance callback which accepts all responses.  Ignores
+ * userdata. */
+int ne_accept_always(void *userdata, ne_request *req, const ne_status *st);
+
+/* Callback for reading a block of data.  Returns zero on success, or
+ * non-zero on error.  If returning an error, the response will be
+ * aborted and the callback will not be invoked again.  The request
+ * dispatch (or ne_read_response_block call) will fail with NE_ERROR;
+ * the session error string should have been set by the callback. */
+typedef int (*ne_block_reader)(void *userdata, const char *buf, size_t len);
+
+/* Add a response reader for the given request, with the given
+ * acceptance function. userdata is passed as the first argument to
+ * the acceptance + reader callbacks. 
+ *
+ * The acceptance callback is called once each time the request is
+ * sent: it may be sent >1 time because of authentication retries etc.
+ * For each time the acceptance callback is called, if it returns
+ * non-zero, blocks of the response body will be passed to the reader
+ * callback as the response is read.  After all the response body has
+ * been read, the callback will be called with a 'len' argument of
+ * zero.  */
+void ne_add_response_body_reader(ne_request *req, ne_accept_response accpt,
+				 ne_block_reader reader, void *userdata);
+
+/* Retrieve the value of the response header field with given name;
+ * returns NULL if no response header with given name was found.  The
+ * return value is valid only until the next call to either
+ * ne_request_destroy or ne_begin_request for this request. */
+const char *ne_get_response_header(ne_request *req, const char *name);
+
+/* Iterator interface for response headers: if passed a NULL cursor,
+ * returns the first header; if passed a non-NULL cursor pointer,
+ * returns the next header.  The return value is a cursor pointer: if
+ * it is non-NULL, *name and *value are set to the name and value of
+ * the header field.  If the return value is NULL, no more headers are
+ * found, *name and *value are undefined.
+ *
+ * The order in which response headers is returned is undefined.  Both
+ * the cursor and name/value pointers are valid only until the next
+ * call to either ne_request_destroy or ne_begin_request for this
+ * request. */
+void *ne_response_header_iterate(ne_request *req, void *cursor,
+                                 const char **name, const char **value);
+
+/* Adds a header to the request with given name and value. */
+void ne_add_request_header(ne_request *req, const char *name, 
+			   const char *value);
+/* Adds a header to the request with given name, using printf-like
+ * format arguments for the value. */
+void ne_print_request_header(ne_request *req, const char *name,
+			     const char *format, ...) 
+    ne_attribute((format(printf, 3, 4)));
+
+/* ne_request_dispatch: Sends the given request, and reads the
+ * response.  Returns:
+ *  - NE_OK if the request was sent and response read successfully
+ *  - NE_AUTH, NE_PROXYAUTH for a server or proxy server authentication error
+ *  - NE_CONNECT if connection could not be established
+ *  - NE_TIMEOUT if an timeout occurred sending or reading from the server
+ *  - NE_ERROR for other fatal dispatch errors
+ * On any error, the session error string is set.  On success or
+ * authentication error, the actual response-status can be retrieved using
+ * ne_get_status(). */
+int ne_request_dispatch(ne_request *req);
+
+/* Returns a pointer to the response status information for the given
+ * request; pointer is valid until request object is destroyed. */
+const ne_status *ne_get_status(const ne_request *req) ne_attribute((const));
+
+/* Returns pointer to session associated with request. */
+ne_session *ne_get_session(const ne_request *req) ne_attribute((const));
+
+/* Destroy memory associated with request pointer */
+void ne_request_destroy(ne_request *req);
+
+/* "Caller-pulls" request interface.  This is an ALTERNATIVE interface
+ * to ne_request_dispatch: either use that, or do all this yourself:
+ *
+ * caller must call:
+ *  1. ne_begin_request (fail if returns non-NE_OK)
+ *  2. while(ne_read_response_block(...) > 0) ... loop ...;
+ *     (fail if ne_read_response_block returns <0)
+ *  3. ne_end_request
+ *
+ * ne_end_request and ne_begin_request both return an NE_* code; if
+ * ne_end_request returns NE_RETRY, you must restart the loop from (1)
+ * above. */
+int ne_begin_request(ne_request *req);
+int ne_end_request(ne_request *req);
+
+/* Read a block of the response into the passed buffer of size 'buflen'.
+ *
+ * Returns:
+ *  <0 - error, stop reading.
+ *   0 - end of response
+ *  >0 - number of bytes read into buffer.
+ */
+ssize_t ne_read_response_block(ne_request *req, char *buffer, size_t buflen);
+
+/* Read response blocks until end of response; exactly equivalent to
+ * calling ne_read_response_block() until it returns 0.  Returns
+ * non-zero on error. */
+int ne_discard_response(ne_request *req);
+
+/* Read response blocks until end of response, writing content to the
+ * given file descriptor.  Returns NE_ERROR on error. */
+int ne_read_response_to_fd(ne_request *req, int fd);
+
+/* Defined request flags: */
+typedef enum ne_request_flag_e {
+    NE_REQFLAG_EXPECT100 = 0, /* enable this flag to enable use of the
+                               * "Expect: 100-continue" for the
+                               * request. */
+
+    NE_REQFLAG_IDEMPOTENT, /* disable this flag if the request uses a
+                            * non-idempotent method such as POST. */
+
+    NE_REQFLAG_LAST /* enum sentinel value */
+} ne_request_flag;
+
+/* Set a new value for a particular request flag. */
+void ne_set_request_flag(ne_request *req, ne_request_flag flag, int value);
+
+/* Return 0 if the given flag is not set, >0 it is set, or -1 if the
+ * flag is not supported. */
+int ne_get_request_flag(ne_request *req, ne_request_flag flag);
+
+/**** Request hooks handling *****/
+
+typedef void (*ne_free_hooks)(void *cookie);
+
+/* Hook called when a request is created; passed the request method,
+ * and the string used as the Request-URI (note that this may be a
+ * absolute URI if a proxy is in use, an absolute path, a "*", etc).
+ * A create_request hook is called exactly once per request. */
+typedef void (*ne_create_request_fn)(ne_request *req, void *userdata,
+				     const char *method, const char *requri);
+void ne_hook_create_request(ne_session *sess, 
+			    ne_create_request_fn fn, void *userdata);
+
+/* Hook called before the request is sent.  'header' is the raw HTTP
+ * header before the trailing CRLF is added; more headers can be added
+ * here.  A pre_send hook may be called >1 time per request if the
+ * request is retried due to a post_send hook returning NE_RETRY. */
+typedef void (*ne_pre_send_fn)(ne_request *req, void *userdata, 
+			       ne_buffer *header);
+void ne_hook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata);
+
+/* Hook called directly after the response headers have been read, but
+ * before the resposnse body has been read.  'status' is the response
+ * status-code.  A post_header hook may be called >1 time per request
+ * if the request is retried due to a post_send hook returning
+ * NE_RETRY. */
+typedef void (*ne_post_headers_fn)(ne_request *req, void *userdata,
+                                   const ne_status *status);
+void ne_hook_post_headers(ne_session *sess, 
+                          ne_post_headers_fn fn, void *userdata);
+
+/* Hook called after the request is dispatched (request sent, and
+ * the entire response read).  If an error occurred reading the response,
+ * this hook will not run.  May return:
+ *  NE_OK     everything is okay
+ *  NE_RETRY  try sending the request again.
+ * anything else signifies an error, and the request is failed. The return
+ * code is passed back the _dispatch caller, so the session error must
+ * also be set appropriately (ne_set_error).
+ */
+typedef int (*ne_post_send_fn)(ne_request *req, void *userdata,
+			       const ne_status *status);
+void ne_hook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata);
+
+/* Hook called when the function is destroyed. */
+typedef void (*ne_destroy_req_fn)(ne_request *req, void *userdata);
+void ne_hook_destroy_request(ne_session *sess,
+			     ne_destroy_req_fn fn, void *userdata);
+
+typedef void (*ne_destroy_sess_fn)(void *userdata);
+/* Hook called when the session is about to be destroyed. */
+void ne_hook_destroy_session(ne_session *sess,
+			     ne_destroy_sess_fn fn, void *userdata);
+
+typedef void (*ne_close_conn_fn)(void *userdata);
+/* Hook called when the connection is closed; note that this hook
+ * may be called *AFTER* the destroy_session hook. */
+void ne_hook_close_conn(ne_session *sess, ne_close_conn_fn fn, void *userdata);
+
+/* The ne_unhook_* functions remove a hook registered with the given
+ * session.  If a hook is found which was registered with a given
+ * function 'fn', and userdata pointer 'userdata', then it will be
+ * removed from the hooks list.
+ *
+ * It is unsafe to use any of these functions from a hook function to
+ * unregister itself, except for ne_unhook_destroy_request. */
+void ne_unhook_create_request(ne_session *sess, 
+                              ne_create_request_fn fn, void *userdata);
+void ne_unhook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata);
+void ne_unhook_post_headers(ne_session *sess, ne_post_headers_fn fn, void *userdata);
+void ne_unhook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata);
+void ne_unhook_destroy_request(ne_session *sess,
+                               ne_destroy_req_fn fn, void *userdata);
+void ne_unhook_destroy_session(ne_session *sess,
+                               ne_destroy_sess_fn fn, void *userdata);
+void ne_unhook_close_conn(ne_session *sess, 
+                          ne_close_conn_fn fn, void *userdata);
+
+/* Store an opaque context for the request, 'priv' is returned by a
+ * call to ne_request_get_private with the same ID. */
+void ne_set_request_private(ne_request *req, const char *id, void *priv);
+void *ne_get_request_private(ne_request *req, const char *id);
+
+NE_END_DECLS
+
+#endif /* NE_REQUEST_H */
diff --git a/net/mmt/neon/src/ne_session.c b/net/mmt/neon/src/ne_session.c
new file mode 100644
index 0000000..6e1f395
--- /dev/null
+++ b/net/mmt/neon/src/ne_session.c
@@ -0,0 +1,745 @@
+/* 
+   HTTP session handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
+#ifdef HAVE_LIBPROXY
+#include <proxy.h>
+#endif
+
+#include "ne_session.h"
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_internal.h"
+#include "ne_string.h"
+#include "ne_dates.h"
+
+#include "ne_private.h"
+
+/* Destroy a a list of hooks. */
+static void destroy_hooks(struct hook *hooks)
+{
+    struct hook *nexthk;
+
+    while (hooks) {
+	nexthk = hooks->next;
+	ne_free(hooks);
+	hooks = nexthk;
+    }
+}
+
+static void free_hostinfo(struct host_info *hi)
+{
+    if (hi->hostname) ne_free(hi->hostname);
+    if (hi->hostport) ne_free(hi->hostport);
+    if (hi->address) ne_addr_destroy(hi->address);
+}
+
+/* Destroy the sess->proxies array. */
+static void free_proxies(ne_session *sess)
+{
+    struct host_info *hi, *nexthi;
+
+    for (hi = sess->proxies; hi; hi = nexthi) {
+        nexthi = hi->next;
+        free_hostinfo(hi);
+        ne_free(hi);
+    }
+
+    sess->proxies = NULL;
+    sess->any_proxy_http = 0;
+}
+
+void ne_session_destroy(ne_session *sess) 
+{
+    struct hook *hk;
+
+    NE_DEBUG(NE_DBG_HTTP, "sess: Destroying session.\n");
+
+    /* Run the destroy hooks. */
+    for (hk = sess->destroy_sess_hooks; hk != NULL; hk = hk->next) {
+	ne_destroy_sess_fn fn = (ne_destroy_sess_fn)hk->fn;
+	fn(hk->userdata);
+    }
+
+    /* Close the connection; note that the notifier callback could
+     * still be invoked here. */
+    if (sess->connected) {
+        ne_close_connection(sess);
+    }
+    
+    destroy_hooks(sess->create_req_hooks);
+    destroy_hooks(sess->pre_send_hooks);
+    destroy_hooks(sess->post_headers_hooks);
+    destroy_hooks(sess->post_send_hooks);
+    destroy_hooks(sess->destroy_req_hooks);
+    destroy_hooks(sess->destroy_sess_hooks);
+    destroy_hooks(sess->close_conn_hooks);
+    destroy_hooks(sess->private);
+
+    ne_free(sess->scheme);
+
+    free_hostinfo(&sess->server);
+    free_proxies(sess);
+
+    if (sess->user_agent) ne_free(sess->user_agent);
+    if (sess->socks_user) ne_free(sess->socks_user);
+    if (sess->socks_password) ne_free(sess->socks_password);
+
+#ifdef NE_HAVE_SSL
+    if (sess->ssl_context)
+        ne_ssl_context_destroy(sess->ssl_context);
+
+    if (sess->server_cert)
+        ne_ssl_cert_free(sess->server_cert);
+    
+    if (sess->client_cert)
+        ne_ssl_clicert_free(sess->client_cert);
+#endif
+
+    ne_free(sess);
+}
+
+int ne_version_pre_http11(ne_session *s)
+{
+    return !s->is_http11;
+}
+
+/* Stores the "hostname[:port]" segment */
+static void set_hostport(struct host_info *host, unsigned int defaultport)
+{
+    size_t len = strlen(host->hostname);
+    host->hostport = ne_malloc(len + 10);
+    strcpy(host->hostport, host->hostname);
+    if (host->port != defaultport)
+	ne_snprintf(host->hostport + len, 9, ":%u", host->port);
+}
+
+/* Stores the hostname/port in *info, setting up the "hostport"
+ * segment correctly. */
+static void set_hostinfo(struct host_info *hi, enum proxy_type type, 
+                         const char *hostname, unsigned int port)
+{
+    hi->hostname = ne_strdup(hostname);
+    hi->port = port;
+    hi->proxy = type;
+}
+
+ne_session *ne_session_create(const char *scheme,
+			      const char *hostname, unsigned int port)
+{
+    ne_session *sess = ne_calloc(sizeof *sess);
+
+    NE_DEBUG(NE_DBG_HTTP, "HTTP session to %s://%s:%d begins.\n",
+	     scheme, hostname, port);
+
+    strcpy(sess->error, "Unknown error.");
+
+    /* use SSL if scheme is https */
+    sess->use_ssl = !strcmp(scheme, "https");
+    
+    /* set the hostname/port */
+    set_hostinfo(&sess->server, PROXY_NONE, hostname, port);
+    set_hostport(&sess->server, sess->use_ssl?443:80);
+
+#ifdef NE_HAVE_SSL
+    if (sess->use_ssl) {
+        ne_inet_addr *ia;
+
+        sess->ssl_context = ne_ssl_context_create(0);
+        sess->flags[NE_SESSFLAG_SSLv2] = 1;
+        
+        /* If the hostname parses as an IP address, don't
+         * enable SNI by default. */
+        ia = ne_iaddr_parse(hostname, ne_iaddr_ipv4);
+        if (ia == NULL)
+            ia = ne_iaddr_parse(hostname, ne_iaddr_ipv6);
+
+        if (ia) {
+            ne_iaddr_free(ia);
+        } 
+        else {
+            sess->flags[NE_SESSFLAG_TLS_SNI] = 1;
+        }
+        NE_DEBUG(NE_DBG_SSL, "ssl: SNI %s by default.\n",
+                 sess->flags[NE_SESSFLAG_TLS_SNI] ?
+                 "enabled" : "disabled");
+    }
+#endif
+
+    sess->scheme = ne_strdup(scheme);
+
+    /* Set flags which default to on: */
+    sess->flags[NE_SESSFLAG_PERSIST] = 1;
+
+    return sess;
+}
+
+void ne_session_proxy(ne_session *sess, const char *hostname,
+		      unsigned int port)
+{
+    free_proxies(sess);
+
+    sess->proxies = ne_calloc(sizeof *sess->proxies);
+
+    sess->any_proxy_http = 1;
+    
+    set_hostinfo(sess->proxies, PROXY_HTTP, hostname, port);
+}
+
+void ne_session_socks_proxy(ne_session *sess, enum ne_sock_sversion vers, 
+                            const char *hostname, unsigned int port,
+                            const char *username, const char *password)
+{
+    free_proxies(sess);
+
+    sess->proxies = ne_calloc(sizeof *sess->proxies);
+
+    set_hostinfo(sess->proxies, PROXY_SOCKS, hostname, port);
+
+    sess->socks_ver = vers;
+
+    if (username) sess->socks_user = ne_strdup(username);
+    if (password) sess->socks_password = ne_strdup(password);
+}
+
+void ne_session_system_proxy(ne_session *sess, unsigned int flags)
+{
+#ifdef HAVE_LIBPROXY
+    pxProxyFactory *pxf = px_proxy_factory_new();
+    struct host_info *hi, **lasthi;
+    char *url, **proxies;
+    ne_uri uri;
+    unsigned n;
+
+    free_proxies(sess);
+
+    /* Create URI for session to pass off to libproxy */
+    memset(&uri, 0, sizeof uri);
+    ne_fill_server_uri(sess, &uri);
+
+    uri.path = "/"; /* make valid URI structure. */
+    url = ne_uri_unparse(&uri);
+    uri.path = NULL;
+
+    /* Get list of pseudo-URIs from libproxy: */
+    proxies = px_proxy_factory_get_proxies(pxf, url);
+    
+    for (n = 0, lasthi = &sess->proxies; proxies[n]; n++) {
+        enum proxy_type ptype;
+
+        ne_uri_free(&uri);
+
+        NE_DEBUG(NE_DBG_HTTP, "sess: libproxy #%u=%s\n", 
+                 n, proxies[n]);
+
+        if (ne_uri_parse(proxies[n], &uri))
+            continue;
+        
+        if (!uri.scheme) continue;
+
+        if (ne_strcasecmp(uri.scheme, "http") == 0)
+            ptype = PROXY_HTTP;
+        else if (ne_strcasecmp(uri.scheme, "socks") == 0)
+            ptype = PROXY_SOCKS;
+        else if (ne_strcasecmp(uri.scheme, "direct") == 0)
+            ptype = PROXY_NONE;
+        else
+            continue;
+
+        /* Hostname/port required for http/socks schemes. */
+        if (ptype != PROXY_NONE && !(uri.host && uri.port))
+            continue;
+        
+        /* Do nothing if libproxy returned only a single "direct://"
+         * entry -- a single "direct" (noop) proxy is equivalent to
+         * having none. */
+        if (n == 0 && proxies[1] == NULL && ptype == PROXY_NONE)
+            break;
+
+        NE_DEBUG(NE_DBG_HTTP, "sess: Got proxy %s://%s:%d\n",
+                 uri.scheme, uri.host ? uri.host : "(none)",
+                 uri.port);
+        
+        hi = *lasthi = ne_calloc(sizeof *hi);
+        
+        if (ptype == PROXY_NONE) {
+            /* A "direct" URI requires an attempt to connect directly to
+             * the origin server, so dup the server details. */
+            set_hostinfo(hi, ptype, sess->server.hostname,
+                         sess->server.port);
+        }
+        else {
+            /* SOCKS/HTTP proxy. */
+            set_hostinfo(hi, ptype, uri.host, uri.port);
+
+            if (ptype == PROXY_HTTP)
+                sess->any_proxy_http = 1;
+            else if (ptype == PROXY_SOCKS)
+                sess->socks_ver = NE_SOCK_SOCKSV5;
+        }
+
+        lasthi = &hi->next;
+    }
+
+    /* Free up the proxies array: */
+    for (n = 0; proxies[n]; n++)
+        free(proxies[n]);
+    free(proxies[n]);
+
+    ne_free(url);
+    ne_uri_free(&uri);
+    px_proxy_factory_free(pxf);
+#endif
+}
+
+void ne_set_addrlist2(ne_session *sess, unsigned int port,
+                      const ne_inet_addr **addrs, size_t n)
+{
+    struct host_info *hi, **lasthi;
+    size_t i;
+
+    free_proxies(sess);
+
+    lasthi = &sess->proxies;
+
+    for (i = 0; i < n; i++) {
+        *lasthi = hi = ne_calloc(sizeof *hi);
+        
+        hi->proxy = PROXY_NONE;
+        hi->network = addrs[i];
+        hi->port = port;
+
+        lasthi = &hi->next;
+    }
+}
+
+void ne_set_addrlist(ne_session *sess, const ne_inet_addr **addrs, size_t n)
+{
+    ne_set_addrlist2(sess, sess->server.port, addrs, n);
+}
+
+void ne_set_localaddr(ne_session *sess, const ne_inet_addr *addr)
+{
+    sess->local_addr = addr;    
+}
+
+void ne_set_error(ne_session *sess, const char *format, ...)
+{
+    va_list params;
+
+    va_start(params, format);
+    ne_vsnprintf(sess->error, sizeof sess->error, format, params);
+    va_end(params);
+}
+
+void ne_set_session_flag(ne_session *sess, ne_session_flag flag, int value)
+{
+    if (flag < NE_SESSFLAG_LAST) {
+        sess->flags[flag] = value;
+#ifdef NE_HAVE_SSL
+        if (flag == NE_SESSFLAG_SSLv2 && sess->ssl_context) {
+            ne_ssl_context_set_flag(sess->ssl_context, NE_SSL_CTX_SSLv2, value);
+            sess->flags[flag] = ne_ssl_context_get_flag(sess->ssl_context, NE_SSL_CTX_SSLv2);
+        }
+#endif
+    }
+}
+
+int ne_get_session_flag(ne_session *sess, ne_session_flag flag)
+{
+    if (flag < NE_SESSFLAG_LAST) {
+        return sess->flags[flag];
+    }
+    return -1;
+}
+
+static void progress_notifier(void *userdata, ne_session_status status,
+                              const ne_session_status_info *info)
+{
+    ne_session *sess = userdata;
+
+    if (status == ne_status_sending || status == ne_status_recving) {
+        sess->progress_cb(sess->progress_ud, info->sr.progress, info->sr.total);    
+    }
+}
+
+void ne_set_progress(ne_session *sess, ne_progress progress, void *userdata)
+{
+    if (progress) {
+        sess->progress_cb = progress;
+        sess->progress_ud = userdata;
+        ne_set_notifier(sess, progress_notifier, sess);
+    }
+    else {
+        ne_set_notifier(sess, NULL, NULL);
+    }
+}
+
+void ne_set_notifier(ne_session *sess,
+		     ne_notify_status status, void *userdata)
+{
+    sess->notify_cb = status;
+    sess->notify_ud = userdata;
+}
+
+void ne_set_read_timeout(ne_session *sess, int timeout)
+{
+    sess->rdtimeout = timeout;
+}
+
+void ne_set_connect_timeout(ne_session *sess, int timeout)
+{
+    sess->cotimeout = timeout;
+}
+
+#define UAHDR "User-Agent: "
+#define AGENT " neon/" NEON_VERSION "\r\n"
+
+void ne_set_useragent(ne_session *sess, const char *token)
+{
+    if (sess->user_agent) ne_free(sess->user_agent);
+    sess->user_agent = ne_malloc(strlen(UAHDR) + strlen(AGENT) + 
+                                 strlen(token) + 1);
+#ifdef HAVE_STPCPY
+    strcpy(stpcpy(stpcpy(sess->user_agent, UAHDR), token), AGENT);
+#else
+    strcat(strcat(strcpy(sess->user_agent, UAHDR), token), AGENT);
+#endif
+}
+
+const char *ne_get_server_hostport(ne_session *sess)
+{
+    return sess->server.hostport;
+}
+
+const char *ne_get_scheme(ne_session *sess)
+{
+    return sess->scheme;
+}
+
+void ne_fill_server_uri(ne_session *sess, ne_uri *uri)
+{
+    uri->host = ne_strdup(sess->server.hostname);
+    uri->port = sess->server.port;
+    uri->scheme = ne_strdup(sess->scheme);
+}
+
+void ne_fill_proxy_uri(ne_session *sess, ne_uri *uri)
+{
+    if (sess->proxies) {
+        struct host_info *hi = sess->nexthop ? sess->nexthop : sess->proxies;
+
+        if (hi->proxy == PROXY_HTTP) {
+            uri->host = ne_strdup(hi->hostname);
+            uri->port = hi->port;
+        }
+    }
+}
+
+const char *ne_get_error(ne_session *sess)
+{
+    return sess->error;
+}
+
+void ne_close_connection(ne_session *sess)
+{
+    if (sess->connected) {
+        struct hook *hk;
+
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Closing connection.\n");
+
+        if (sess->notify_cb) {
+            sess->status.cd.hostname = sess->nexthop->hostname;
+            sess->notify_cb(sess->notify_ud, ne_status_disconnected, 
+                            &sess->status);
+        }
+
+        /* Run the close_conn hooks. */
+        for (hk = sess->close_conn_hooks; hk != NULL; hk = hk->next) {
+            ne_close_conn_fn fn = (ne_close_conn_fn)hk->fn;
+            fn(hk->userdata);
+        }
+
+	ne_sock_close(sess->socket);
+	sess->socket = NULL;
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Connection closed.\n");
+    } else {
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Not closing closed connection.\n");
+    }
+    sess->connected = 0;
+}
+
+void ne_ssl_set_verify(ne_session *sess, ne_ssl_verify_fn fn, void *userdata)
+{
+    sess->ssl_verify_fn = fn;
+    sess->ssl_verify_ud = userdata;
+}
+
+void ne_ssl_provide_clicert(ne_session *sess, 
+			  ne_ssl_provide_fn fn, void *userdata)
+{
+    sess->ssl_provide_fn = fn;
+    sess->ssl_provide_ud = userdata;
+}
+
+void ne_ssl_trust_cert(ne_session *sess, const ne_ssl_certificate *cert)
+{
+#ifdef NE_HAVE_SSL
+    if (sess->ssl_context) {
+        ne_ssl_context_trustcert(sess->ssl_context, cert);
+    }
+#endif
+}
+
+void ne_ssl_cert_validity(const ne_ssl_certificate *cert, char *from, char *until)
+{
+#ifdef NE_HAVE_SSL
+    time_t tf, tu;
+    char *date;
+
+    ne_ssl_cert_validity_time(cert, &tf, &tu);
+    
+    if (from) {
+        if (tf != (time_t) -1) {
+            date = ne_rfc1123_date(tf);
+            ne_strnzcpy(from, date, NE_SSL_VDATELEN);
+            ne_free(date);
+        }
+        else {
+            ne_strnzcpy(from, _("[invalid date]"), NE_SSL_VDATELEN);
+        }
+    }
+        
+    if (until) {
+        if (tu != (time_t) -1) {
+            date = ne_rfc1123_date(tu);
+            ne_strnzcpy(until, date, NE_SSL_VDATELEN);
+            ne_free(date);
+        }
+        else {
+            ne_strnzcpy(until, _("[invalid date]"), NE_SSL_VDATELEN);
+        }
+    }
+#endif
+}
+
+#ifdef NE_HAVE_SSL
+void ne__ssl_set_verify_err(ne_session *sess, int failures)
+{
+    static const struct {
+	int bit;
+	const char *str;
+    } reasons[] = {
+	{ NE_SSL_NOTYETVALID, N_("certificate is not yet valid") },
+	{ NE_SSL_EXPIRED, N_("certificate has expired") },
+	{ NE_SSL_IDMISMATCH, N_("certificate issued for a different hostname") },
+	{ NE_SSL_UNTRUSTED, N_("issuer is not trusted") },
+        { NE_SSL_BADCHAIN, N_("bad certificate chain") },
+        { NE_SSL_REVOKED, N_("certificate has been revoked") },
+	{ 0, NULL }
+    };
+    int n, flag = 0;
+
+    strcpy(sess->error, _("Server certificate verification failed: "));
+
+    for (n = 0; reasons[n].bit; n++) {
+	if (failures & reasons[n].bit) {
+	    if (flag) strncat(sess->error, ", ", sizeof sess->error - 1);
+	    strncat(sess->error, _(reasons[n].str), sizeof sess->error - 1);
+	    flag = 1;
+	}
+    }
+}
+
+/* This doesn't actually implement complete RFC 2818 logic; omits
+ * "f*.example.com" support for simplicity. */
+int ne__ssl_match_hostname(const char *cn, size_t cnlen, const char *hostname)
+{
+    const char *dot;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Match common name '%s' against '%s'\n",
+             cn, hostname);
+
+    if (strncmp(cn, "*.", 2) == 0 && cnlen > 2
+        && (dot = strchr(hostname, '.')) != NULL) {
+        ne_inet_addr *ia;
+
+        /* Prevent wildcard CN matches against anything which can be
+         * parsed as an IP address (i.e. a CN of "*.1.1.1" should not
+         * be match 8.1.1.1).  draft-saintandre-tls-server-id-check
+         * will require some more significant changes to cert ID
+         * verification which will probably obviate this check, but
+         * this is a desirable policy tightening in the mean time. */
+        ia = ne_iaddr_parse(hostname, ne_iaddr_ipv4);
+        if (ia == NULL)
+            ia = ne_iaddr_parse(hostname, ne_iaddr_ipv6);
+        
+        if (ia) {
+            NE_DEBUG(NE_DBG_SSL, "ssl: Denying wildcard match for numeric "
+                     "IP address.\n");
+            ne_iaddr_free(ia);
+            return 0;
+        }
+
+	hostname = dot + 1;
+	cn += 2;
+        cnlen -= 2;
+    }
+
+    return cnlen == strlen(hostname) && !ne_strcasecmp(cn, hostname);
+}
+
+#endif /* NE_HAVE_SSL */
+
+typedef void (*void_fn)(void);
+
+#define ADD_HOOK(hooks, fn, ud) add_hook(&(hooks), NULL, (void_fn)(fn), (ud))
+
+static void add_hook(struct hook **hooks, const char *id, void_fn fn, void *ud)
+{
+    struct hook *hk = ne_malloc(sizeof (struct hook)), *pos;
+
+    if (*hooks != NULL) {
+	for (pos = *hooks; pos->next != NULL; pos = pos->next)
+	    /* nullop */;
+	pos->next = hk;
+    } else {
+	*hooks = hk;
+    }
+
+    hk->id = id;
+    hk->fn = fn;
+    hk->userdata = ud;
+    hk->next = NULL;
+}
+
+void ne_hook_create_request(ne_session *sess, 
+			    ne_create_request_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->create_req_hooks, fn, userdata);
+}
+
+void ne_hook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->pre_send_hooks, fn, userdata);
+}
+
+void ne_hook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->post_send_hooks, fn, userdata);
+}
+
+void ne_hook_post_headers(ne_session *sess, ne_post_headers_fn fn, 
+                          void *userdata)
+{
+    ADD_HOOK(sess->post_headers_hooks, fn, userdata);
+}
+
+void ne_hook_destroy_request(ne_session *sess,
+			     ne_destroy_req_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->destroy_req_hooks, fn, userdata);    
+}
+
+void ne_hook_destroy_session(ne_session *sess,
+			     ne_destroy_sess_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->destroy_sess_hooks, fn, userdata);
+}
+
+void ne_hook_close_conn(ne_session *sess,
+                        ne_close_conn_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->close_conn_hooks, fn, userdata);
+}
+
+void ne_set_session_private(ne_session *sess, const char *id, void *userdata)
+{
+    add_hook(&sess->private, id, NULL, userdata);
+}
+
+static void remove_hook(struct hook **hooks, void_fn fn, void *ud)
+{
+    struct hook **p = hooks;
+
+    while (*p) {
+        if ((*p)->fn == fn && (*p)->userdata == ud) {
+            struct hook *next = (*p)->next;
+            ne_free(*p);
+            (*p) = next;
+            break;
+        }
+        p = &(*p)->next;
+    }
+}
+
+#define REMOVE_HOOK(hooks, fn, ud) remove_hook(&hooks, (void_fn)fn, ud)
+
+void ne_unhook_create_request(ne_session *sess, 
+                              ne_create_request_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->create_req_hooks, fn, userdata);
+}
+
+void ne_unhook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->pre_send_hooks, fn, userdata);
+}
+
+void ne_unhook_post_headers(ne_session *sess, ne_post_headers_fn fn, 
+			    void *userdata)
+{
+    REMOVE_HOOK(sess->post_headers_hooks, fn, userdata);
+}
+
+void ne_unhook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->post_send_hooks, fn, userdata);
+}
+
+void ne_unhook_destroy_request(ne_session *sess,
+                               ne_destroy_req_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->destroy_req_hooks, fn, userdata);    
+}
+
+void ne_unhook_destroy_session(ne_session *sess,
+                               ne_destroy_sess_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->destroy_sess_hooks, fn, userdata);
+}
+
+void ne_unhook_close_conn(ne_session *sess,
+                          ne_close_conn_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->close_conn_hooks, fn, userdata);
+}
diff --git a/net/mmt/neon/src/ne_session.h b/net/mmt/neon/src/ne_session.h
new file mode 100644
index 0000000..58493bf
--- /dev/null
+++ b/net/mmt/neon/src/ne_session.h
@@ -0,0 +1,350 @@
+/* 
+   HTTP session handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SESSION_H
+#define NE_SESSION_H 1
+
+#include <sys/types.h>
+
+#include "ne_ssl.h"
+#include "ne_uri.h" /* for ne_uri */
+#include "ne_defs.h"
+#include "ne_socket.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_session_s ne_session;
+
+/* Create a session to the given server, using the given scheme.  If
+ * "https" is passed as the scheme, SSL will be used to connect to the
+ * server. */
+ne_session *ne_session_create(const char *scheme,
+			      const char *hostname, unsigned int port);
+
+/* Finish an HTTP session */
+void ne_session_destroy(ne_session *sess);
+
+/* Prematurely force the connection to be closed for the given
+ * session. */
+void ne_close_connection(ne_session *sess);
+
+/* Configure an HTTP proxy server for the session.  This function will
+ * override (remove) any proxy servers previously configured, and must
+ * be called before any requests are created using this session. */
+void ne_session_proxy(ne_session *sess,
+		      const char *hostname, unsigned int port);
+
+/* Configure a SOCKS proxy server which will be used for the session.
+ * The SOCKS protocol version 'vers' will be used to contact the
+ * proxy at given 'hostname' and 'port'.
+ *
+ * If SOCKSv4 or v4a are used, username must be non-NULL.  For v5,
+ * username may be NULL, in which case, password is ignored.  If
+ * username is non-NULL, password must also be non-NULL.
+ *
+ * This function will override (remove) any proxy servers previously
+ * configured, and must be called before any requests are created
+ * using this session. */
+void ne_session_socks_proxy(ne_session *sess, enum ne_sock_sversion vers,
+                            const char *hostname, unsigned int port,
+                            const char *username, const char *password);
+
+/* Configure use of proxy servers from any system-wide default sources
+ * which are configured at build time.  This function will override
+ * (remove) any proxy servers previously configured, and must be
+ * called before any requests are created using this session.  The
+ * 'flags' parameter must be zero.  */
+void ne_session_system_proxy(ne_session *sess, unsigned int flags);
+
+/* Defined session flags: */
+typedef enum ne_session_flag_e {
+    NE_SESSFLAG_PERSIST = 0, /* disable this flag to prevent use of
+                              * persistent connections. */
+
+    NE_SESSFLAG_ICYPROTO, /* enable this flag to enable support for
+                           * non-HTTP ShoutCast-style "ICY" responses. */
+
+    NE_SESSFLAG_SSLv2, /* disable this flag to disable support for
+                        * SSLv2, if supported by the SSL library. */
+
+    NE_SESSFLAG_RFC4918, /* enable this flag to enable support for
+                          * RFC4918-only WebDAV features; losing
+                          * backwards-compatibility with RFC2518
+                          * servers. */
+
+    NE_SESSFLAG_CONNAUTH, /* enable this flag if an awful, broken,
+                           * RFC-violating, connection-based HTTP
+                           * authentication scheme is in use. */
+
+    NE_SESSFLAG_TLS_SNI, /* disable this flag to disable use of the
+                          * TLS Server Name Indication extension. */
+
+    NE_SESSFLAG_EXPECT100, /* enable this flag to enable the flag
+                            * NE_REQFLAG_EXPECT100 for new requests. */
+
+    NE_SESSFLAG_LAST /* enum sentinel value */
+} ne_session_flag;
+
+/* Set a new value for a particular session flag. */
+void ne_set_session_flag(ne_session *sess, ne_session_flag flag, int value);
+
+/* Return 0 if the given flag is not set, >0 it is set, or -1 if the
+ * flag is not supported. */
+int ne_get_session_flag(ne_session *sess, ne_session_flag flag);
+
+/* Bypass the normal name resolution; force the use of specific set of
+ * addresses for this session, addrs[0]...addrs[n-1].  The 'addrs'
+ * array and pointed-to objects must remain valid until the session is
+ * destroyed.  This function will override (remove) any proxy servers
+ * previously configured, and must be called before any requests are
+ * created using this session.  */
+void ne_set_addrlist(ne_session *sess, const ne_inet_addr **addrs, size_t n);
+
+/* Bypass the normal name resolution; force the use of specific set of
+ * addresses for this session, addrs[0]...addrs[n-1].  The 'addrs'
+ * array and pointed-to objects must remain valid until the session is
+ * destroyed.  This function will override (remove) any proxy servers
+ * previously configured, and must be called before any requests are
+ * created using this session.  Port number 'port' will be used
+ * instead of the "real" session port, to connect to the proxy. */
+void ne_set_addrlist2(ne_session *sess, unsigned int port, 
+                      const ne_inet_addr **addrs, size_t n);
+
+/* Bind connections to the specified local address.  If the address
+ * determined for the remote host has a different family (type) to
+ * 'addr', 'addr' will be ignored.  The 'addr' object must remain
+ * valid until the session is destroyed. */
+void ne_set_localaddr(ne_session *sess, const ne_inet_addr *addr);
+
+/* DEPRECATED: Progress callback. */
+typedef void (*ne_progress)(void *userdata, ne_off_t progress, ne_off_t total);
+
+/* DEPRECATED API: Set a progress callback for the session; this is
+ * deprecated in favour of ne_set_notifier().  The progress callback
+ * is invoked for after each block of the request and response body to
+ * indicate request and response progress (there is no way to
+ * distinguish between the two using this interface alone).
+ * If progress is NULL, any existing callback is deregistered and will
+ * no longer be invoked.
+ *
+ * NOTE: Use of this interface is mutually exclusive with the use of
+ * ne_set_notifier().  A call to ne_set_progress() removes the
+ * notifier callback, and vice versa. */
+void ne_set_progress(ne_session *sess, ne_progress progress, void *userdata);
+
+/* Store an opaque context for the session, 'priv' is returned by a
+ * call to ne_session_get_private with the same ID. */
+void ne_set_session_private(ne_session *sess, const char *id, void *priv);
+void *ne_get_session_private(ne_session *sess, const char *id);
+
+/* Status event type.  NOTE: More event types may be added in
+ * subsequent releases, so callers must ignore unknown status types
+ * for forwards-compatibility.  */
+typedef enum {
+    ne_status_lookup = 0, /* looking up hostname */
+    ne_status_connecting, /* connecting to host */
+    ne_status_connected, /* connected to host */
+    ne_status_sending, /* sending a request body */
+    ne_status_recving, /* receiving a response body */
+    ne_status_disconnected /* disconnected from host */
+} ne_session_status;
+
+/* Status event information union; the relevant structure within
+ * corresponds to the event type.  WARNING: the size of this union is
+ * not limited by ABI constraint; it may be extended with additional
+ * members of different size, or existing members may be extended. */
+typedef union ne_session_status_info_u {
+    struct /* ne_status_lookup */ {
+        /* The hostname which is being resolved: */
+        const char *hostname;
+    } lu;
+    struct /* ne_status_connecting */ {
+        /* The hostname and network address to which a connection
+         * attempt is being made: */
+        const char *hostname;
+        const ne_inet_addr *address;
+    } ci;
+    struct /* ne_status_connected, ne_status_disconnected */ {
+        /* The hostname to which a connection has just been
+         * established or closed: */
+        const char *hostname;
+    } cd;
+    struct /* ne_status_sending and ne_status_recving */ {
+        /* Request/response body transfer progress; if total == -1,
+         * the total size is unknown; otherwise, total gives the total
+         * number of bytes which will be transferred.  progress gives
+         * the number of bytes transferred so far. */
+        ne_off_t progress, total;
+    } sr;
+} ne_session_status_info;
+
+/* Callback invoked to notify a new session status event, given by the
+ * 'status' argument.  On invocation, the contents of exactly one of
+ * the structures in the info union will be valid, as indicated
+ * above. */
+typedef void (*ne_notify_status)(void *userdata, ne_session_status status,
+                                 const ne_session_status_info *info);
+
+/* Set a status notification callback for the session, to report
+ * session status events.  Only one notification callback per session
+ * can be registered; the most recent of successive calls to this
+ * function takes effect.  If status is NULL, any existing callback
+ * is deregistered and will no longer be invoked.
+ *
+ * NOTE: Use of this interface is mutually exclusive with the use of
+ * ne_set_progress().  A call to ne_set_notifier() removes the
+ * progress callback, and vice versa. */
+void ne_set_notifier(ne_session *sess, ne_notify_status status, void *userdata);
+
+/* Certificate verification failures. */
+
+/* NE_SSL_NOTYETVALID: the certificate is not yet valid. */
+#define NE_SSL_NOTYETVALID (0x01)
+
+/* NE_SSL_EXPIRED: the certificate has expired. */
+#define NE_SSL_EXPIRED (0x02)
+
+/* NE_SSL_IDMISMATCH: the hostname for which the certificate was
+ * issued does not match the hostname of the server; this could mean
+ * that the connection is being intercepted. */
+#define NE_SSL_IDMISMATCH (0x04)
+
+/* NE_SSL_UNTRUSTED: the certificate authority which signed the server
+ * certificate is not trusted: there is no indicatation the server is
+ * who they claim to be: */
+#define NE_SSL_UNTRUSTED (0x08)
+
+/* NE_SSL_BADCHAIN: the certificate chain contained a certificate
+ * other than the server cert which failed verification for a reason
+ * other than lack of trust; for example, due to a CA cert being
+ * outside its validity period. */
+#define NE_SSL_BADCHAIN (0x10)
+
+/* N.B.: 0x20 is reserved. */
+
+/* NE_SSL_REVOKED: the server certificate has been revoked by the
+ * issuing authority. */
+#define NE_SSL_REVOKED (0x40)
+
+/* For purposes of forwards-compatibility, the bitmask of all
+ * currently exposed failure bits is given as NE_SSL_FAILMASK.  If the
+ * expression (failures & ~NE_SSL_FAILMASK) is non-zero a failure type
+ * is present which the application does not recognize but must treat
+ * as a verification failure nonetheless. */
+#define NE_SSL_FAILMASK (0x5f)
+
+/* A callback which is used when server certificate verification is
+ * needed.  The reasons for verification failure are given in the
+ * 'failures' parameter, which is a binary OR of one or more of the
+ * above NE_SSL_* values. failures is guaranteed to be non-zero.  The
+ * callback must return zero to accept the certificate: a non-zero
+ * return value will fail the SSL negotiation. */
+typedef int (*ne_ssl_verify_fn)(void *userdata, int failures,
+				const ne_ssl_certificate *cert);
+
+/* Install a callback to handle server certificate verification.  This
+ * is required when the CA certificate is not known for the server
+ * certificate, or the server cert has other verification problems. */
+void ne_ssl_set_verify(ne_session *sess, ne_ssl_verify_fn fn, void *userdata);
+
+/* Use the given client certificate for the session.  The client cert
+ * MUST be in the decrypted state, otherwise behaviour is undefined.
+ * The 'clicert' object is duplicated internally so can be destroyed
+ * by the caller.  */
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *clicert);
+
+/* Indicate that the certificate 'cert' is trusted; the 'cert' object
+ * is duplicated internally so can be destroyed by the caller.  This
+ * function has no effect for non-SSL sessions. */
+void ne_ssl_trust_cert(ne_session *sess, const ne_ssl_certificate *cert);
+
+/* If the SSL library provided a default set of CA certificates, trust
+ * this set of CAs. */
+void ne_ssl_trust_default_ca(ne_session *sess);
+
+/* Callback used to load a client certificate on demand.  If dncount
+ * is > 0, the 'dnames' array dnames[0] through dnames[dncount-1]
+ * gives the list of CA names which the server indicated were
+ * acceptable.  The callback should load an appropriate client
+ * certificate and then pass it to 'ne_ssl_set_clicert'. */
+typedef void (*ne_ssl_provide_fn)(void *userdata, ne_session *sess,
+				  const ne_ssl_dname *const *dnames,
+                                  int dncount);
+
+/* Register a function to be called when the server requests a client
+ * certificate. */
+void ne_ssl_provide_clicert(ne_session *sess, 
+                            ne_ssl_provide_fn fn, void *userdata);
+
+/* Set the timeout (in seconds) used when reading from a socket.  The
+ * timeout value must be greater than zero. */
+void ne_set_read_timeout(ne_session *sess, int timeout);
+
+/* Set the timeout (in seconds) used when making a connection.  The
+ * timeout value must be greater than zero. */
+void ne_set_connect_timeout(ne_session *sess, int timeout);
+
+/* Sets the user-agent string. neon/VERSION will be appended, to make
+ * the full header "User-Agent: product neon/VERSION".
+ * If this function is not called, the User-Agent header is not sent.
+ * The product string must follow the RFC2616 format, i.e.
+ *       product         = token ["/" product-version]
+ *       product-version = token
+ * where token is any alpha-numeric-y string [a-zA-Z0-9]* */
+void ne_set_useragent(ne_session *sess, const char *product);
+
+/* Returns non-zero if next-hop server does not claim compliance to
+ * HTTP/1.1 or later. */
+int ne_version_pre_http11(ne_session *sess);
+
+/* Returns the 'hostport' URI segment for the end-server, e.g.
+ * "my.server.com:8080". */
+const char *ne_get_server_hostport(ne_session *sess);
+
+/* Returns the URL scheme being used for the current session, omitting
+ * the trailing ':'; e.g. "http" or "https". */
+const char *ne_get_scheme(ne_session *sess);
+
+/* Sets the host, scheme, and port fields of the given URI structure
+ * to that of the configured server and scheme for the session; host
+ * and scheme are malloc-allocated.  No other fields in the URI
+ * structure are changed. */
+void ne_fill_server_uri(ne_session *sess, ne_uri *uri);
+
+/* If a proxy is configured, sets the host and port fields in the
+ * given URI structure to that of the proxy.  If multiple proxies are
+ * configured, the active is used if any, otherwise the first.  The
+ * hostname is malloc-allocated.  No other fields in the URI structure
+ * are changed; if no proxy is configured or a non-HTTP proxy is in
+ * use, no fields are changed. */
+void ne_fill_proxy_uri(ne_session *sess, ne_uri *uri);
+
+/* Set the error string for the session; takes printf-like format
+ * string. */
+void ne_set_error(ne_session *sess, const char *format, ...)
+    ne_attribute((format (printf, 2, 3)));
+
+/* Retrieve the error string for the session */
+const char *ne_get_error(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_SESSION_H */
diff --git a/net/mmt/neon/src/ne_socket.c b/net/mmt/neon/src/ne_socket.c
new file mode 100644
index 0000000..2dadac6
--- /dev/null
+++ b/net/mmt/neon/src/ne_socket.c
@@ -0,0 +1,1949 @@
+/* 
+   Socket handling routines
+   Copyright (C) 1998-2011, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004 Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+/*
+  portions were originally under GPL in Mutt, http://www.mutt.org/
+  Relicensed under LGPL for neon, http://www.webdav.org/neon/
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+#ifdef HAVE_SYS_UIO_h
+#include <sys/uio.h> /* writev(2) */
+#endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <sys/stat.h>
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#ifdef NE_USE_POLL
+#include <sys/poll.h>
+#elif defined(HAVE_SYS_SELECT_H)
+#include <sys/select.h>
+#endif
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_TCP_H
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_NETDB_H
+#include <netdb.h>
+#endif
+
+#ifdef WIN32
+#include <winsock2.h>
+#include <stddef.h>
+#ifdef USE_GETADDRINFO
+#include <ws2tcpip.h>
+#include <wspiapi.h>
+#endif
+#endif
+
+#if defined(HAVE_OPENSSL) && defined(HAVE_LIMITS_H)
+#include <limits.h> /* for INT_MAX */
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif 
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+
+#ifdef HAVE_SOCKS_H
+#include <socks.h>
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/pkcs12.h> /* for PKCS12_PBE_add */
+#include <openssl/rand.h>
+#include <openssl/opensslv.h> /* for OPENSSL_VERSION_NUMBER */
+#endif
+
+#ifdef HAVE_GNUTLS
+#include <gnutls/gnutls.h>
+#endif
+
+#define NE_INET_ADDR_DEFINED
+/* A slightly ugly hack: change the ne_inet_addr definition to be the
+ * real address type used.  The API only exposes ne_inet_addr as a
+ * pointer to an opaque object, so this should be well-defined
+ * behaviour.  It avoids the hassle of a real wrapper ne_inet_addr
+ * structure, or losing type-safety by using void *. */
+#ifdef USE_GETADDRINFO
+typedef struct addrinfo ne_inet_addr;
+#else
+typedef struct in_addr ne_inet_addr;
+#endif
+
+#include "ne_privssl.h" /* MUST come after ne_inet_addr is defined */
+
+/* To avoid doing AAAA queries unless absolutely necessary, either use
+ * AI_ADDRCONFIG where available, or a run-time check for working IPv6
+ * support; the latter is only known to work on Linux. */
+#if defined(USE_GETADDRINFO) && !defined(USE_GAI_ADDRCONFIG) && defined(__linux__)
+#define USE_CHECK_IPV6
+#endif
+
+/* "Be Conservative In What You Build". */
+#if defined(HAVE_FCNTL) && defined(O_NONBLOCK) && defined(F_SETFL) \
+    && defined(HAVE_GETSOCKOPT) && defined(SO_ERROR) \
+    && defined(HAVE_SOCKLEN_T) && defined(SOL_SOCKET) \
+    && defined(EINPROGRESS)
+#define USE_NONBLOCKING_CONNECT
+#endif
+
+#include "ne_internal.h"
+#include "ne_utils.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_alloc.h"
+#include "ne_sspi.h"
+
+#if defined(__BEOS__) && !defined(BONE_VERSION)
+/* pre-BONE */
+#define ne_close(s) closesocket(s)
+#define ne_errno errno
+#elif defined(WIN32)
+#define ne_close(s) closesocket(s)
+#define ne_errno WSAGetLastError()
+#else /* really Unix! */
+#define ne_close(s) close(s)
+#define ne_errno errno
+#endif
+
+#ifdef WIN32
+#define NE_ISRESET(e) ((e) == WSAECONNABORTED || (e) == WSAETIMEDOUT || \
+                       (e) == WSAECONNRESET || (e) == WSAENETRESET)
+#define NE_ISCLOSED(e) ((e) == WSAESHUTDOWN || (e) == WSAENOTCONN)
+#define NE_ISINTR(e) (0)
+#define NE_ISINPROGRESS(e) ((e) == WSAEWOULDBLOCK) /* says MSDN */
+#else /* Unix */
+/* Also treat ECONNABORTED and ENOTCONN as "connection reset" errors;
+ * both can be returned by Winsock-based sockets layers e.g. CygWin */
+#ifndef ECONNABORTED
+#define ECONNABORTED ECONNRESET
+#endif
+#ifndef ENOTCONN
+#define ENOTCONN ECONNRESET
+#endif
+#define NE_ISRESET(e) ((e) == ECONNRESET || (e) == ECONNABORTED || (e) == ENOTCONN)
+#define NE_ISCLOSED(e) ((e) == EPIPE)
+#define NE_ISINTR(e) ((e) == EINTR)
+#define NE_ISINPROGRESS(e) ((e) == EINPROGRESS)
+#endif
+
+/* Socket read timeout */
+#define SOCKET_READ_TIMEOUT 120
+
+/* Critical I/O functions on a socket: useful abstraction for easily
+ * handling SSL I/O alongside raw socket I/O. */
+struct iofns {
+    /* Read up to 'len' bytes into 'buf' from socket.  Return <0 on
+     * error or EOF, or >0; number of bytes read. */
+    ssize_t (*sread)(ne_socket *s, char *buf, size_t len);
+    /* Write up to 'len' bytes from 'buf' to socket.  Return number of
+     * bytes written on success, or <0 on error. */
+    ssize_t (*swrite)(ne_socket *s, const char *buf, size_t len);
+    /* Wait up to 'n' seconds for socket to become readable.  Returns
+     * 0 when readable, otherwise NE_SOCK_TIMEOUT or NE_SOCK_ERROR. */
+    int (*readable)(ne_socket *s, int n);
+    /* Write up to 'count' blocks described by 'vector' to socket.
+     * Return number of bytes written on success, or <0 on error. */
+    ssize_t (*swritev)(ne_socket *s, const struct ne_iovec *vector, 
+                       int count);
+};
+
+static const ne_inet_addr dummy_laddr;
+
+struct ne_socket_s {
+    int fd;
+    unsigned int lport;
+    const ne_inet_addr *laddr;
+
+    void *progress_ud;
+    int rdtimeout, cotimeout; /* timeouts */
+    const struct iofns *ops;
+#ifdef NE_HAVE_SSL
+    ne_ssl_socket ssl;
+#endif
+    /* The read buffer: ->buffer stores byte which have been read; as
+     * these are consumed and passed back to the caller, bufpos
+     * advances through ->buffer.  ->bufavail gives the number of
+     * bytes which remain to be consumed in ->buffer (from ->bufpos),
+     * and is hence always <= RDBUFSIZ. */
+    char *bufpos;
+    size_t bufavail;
+#define RDBUFSIZ 4096
+    char buffer[RDBUFSIZ];
+    /* Error string. */
+    char error[192];
+};
+
+/* ne_sock_addr represents an Internet address. */
+struct ne_sock_addr_s {
+#ifdef USE_GETADDRINFO
+    struct addrinfo *result, *cursor;
+#else
+    struct in_addr *addrs;
+    size_t cursor, count;
+    char *name;
+#endif
+    int errnum;
+};
+
+/* set_error: set socket error string to 'str'. */
+#define set_error(s, str) ne_strnzcpy((s)->error, (str), sizeof (s)->error)
+
+/* set_strerror: set socket error to system error string for 'errnum' */
+#ifdef WIN32
+/* Print system error message to given buffer. */
+static void print_error(int errnum, char *buffer, size_t buflen)
+{
+    if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
+                       | FORMAT_MESSAGE_IGNORE_INSERTS,
+                       NULL, (DWORD) errnum, 0, 
+                       buffer, buflen, NULL) == 0)
+        ne_snprintf(buffer, buflen, "Socket error %d", errnum);
+}
+#define set_strerror(s, e) print_error((e), (s)->error, sizeof (s)->error)
+#else /* not WIN32 */
+#define set_strerror(s, e) ne_strerror((e), (s)->error, sizeof (s)->error)
+#endif
+
+#ifdef HAVE_OPENSSL
+/* Seed the SSL PRNG, if necessary; returns non-zero on failure. */
+static int seed_ssl_prng(void)
+{
+    /* Check whether the PRNG has already been seeded. */
+    if (RAND_status() == 1)
+	return 0;
+
+#if defined(EGD_PATH)
+    NE_DEBUG(NE_DBG_SOCKET, "Seeding PRNG from " EGD_PATH "...\n");
+    if (RAND_egd(EGD_PATH) != -1)
+	return 0;
+#elif defined(ENABLE_EGD)
+    {
+	static const char *paths[] = { "/var/run/egd-pool", "/dev/egd-pool",
+				       "/etc/egd-pool", "/etc/entropy" };
+	size_t n;
+	for (n = 0; n < sizeof(paths) / sizeof(char *); n++) {
+	    NE_DEBUG(NE_DBG_SOCKET, "Seeding PRNG from %s...\n", paths[n]);
+	    if (RAND_egd(paths[n]) != -1)
+		return 0;
+	}
+    }
+#endif /* EGD_PATH */
+
+    NE_DEBUG(NE_DBG_SOCKET, "No entropy source found; could not seed PRNG.\n");
+    return -1;
+}
+#endif /* HAVE_OPENSSL */
+
+#ifdef USE_CHECK_IPV6
+static int ipv6_disabled = 0;
+
+/* On Linux kernels, IPv6 is typically built as a loadable module, and
+ * socket(AF_INET6, ...) will fail if this module is not loaded, so
+ * the slow AAAA lookups can be avoided for this common case. */
+static void init_ipv6(void)
+{
+    int fd = socket(AF_INET6, SOCK_STREAM, 0);
+    
+    if (fd < 0)
+        ipv6_disabled = 1;
+    else
+        close(fd);
+}
+#elif defined(AF_INET6)
+#define ipv6_disabled (0)
+#else
+#define ipv6_disabled (1)
+#endif
+
+/* If init_state is N where > 0, ne_sock_init has been called N times;
+ * if == 0, library is not initialized; if < 0, library initialization
+ * has failed. */
+static int init_state = 0;
+
+int ne_sock_init(void)
+{
+#ifdef WIN32
+    WORD wVersionRequested;
+    WSADATA wsaData;
+    int err;
+#endif
+
+    if (init_state > 0) {
+        init_state++;
+	return 0;
+    } 
+    else if (init_state < 0) {
+	return -1;
+    }
+
+#ifdef WIN32    
+    wVersionRequested = MAKEWORD(2, 2);
+    
+    err = WSAStartup(wVersionRequested, &wsaData);
+    if (err != 0) {
+	return init_state = -1;
+    }
+#ifdef HAVE_SSPI
+    if (ne_sspi_init() < 0) {
+        return init_state = -1;
+    }
+#endif
+#endif
+
+#ifdef NE_HAVE_SOCKS
+    SOCKSinit("neon");
+#endif
+
+#if defined(HAVE_SIGNAL) && defined(SIGPIPE)
+    (void) signal(SIGPIPE, SIG_IGN);
+#endif
+
+#ifdef USE_CHECK_IPV6
+    init_ipv6();
+#endif
+
+#ifdef NE_HAVE_SSL
+    if (ne__ssl_init()) {
+        return init_state = -1;
+    }
+#endif
+
+    init_state = 1;
+    return 0;
+}
+
+void ne_sock_exit(void)
+{
+    if (init_state > 0 && --init_state == 0) {
+#ifdef WIN32
+        WSACleanup();
+#endif
+#ifdef NE_HAVE_SSL
+        ne__ssl_exit();
+#endif
+        
+#ifdef HAVE_SSPI
+        ne_sspi_deinit();
+#endif
+    }
+}
+
+/* Await readability (rdwr = 0) or writability (rdwr != 0) for socket
+ * fd for secs seconds.  Returns <0 on error, zero on timeout, >0 if
+ * data is available. */
+static int raw_poll(int fdno, int rdwr, int secs)
+{
+    int ret;
+#ifdef NE_USE_POLL
+    struct pollfd fds;
+    int timeout = secs > 0 ? secs * 1000 : -1;
+
+    fds.fd = fdno;
+    fds.events = rdwr == 0 ? POLLIN : POLLOUT;
+    fds.revents = 0;
+
+    do {
+        ret = poll(&fds, 1, timeout);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+#else
+    fd_set rdfds, wrfds, exfds;
+    struct timeval timeout, *tvp = (secs >= 0 ? &timeout : NULL);
+
+    /* Init the fd set */
+    FD_ZERO(&rdfds);
+    FD_ZERO(&wrfds);
+    FD_ZERO(&exfds);
+
+    /* Note that (amazingly) the FD_SET macro does not expand
+     * correctly on Netware if not inside a compound statement
+     * block. */
+    if (rdwr == 0) {
+        FD_SET(fdno, &rdfds);
+    } else {
+        FD_SET(fdno, &wrfds);
+    }
+    FD_SET(fdno, &exfds);
+
+    if (tvp) {
+        tvp->tv_sec = secs;
+        tvp->tv_usec = 0;
+    }
+    do {
+	ret = select(fdno + 1, &rdfds, &wrfds, &exfds, tvp);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+#endif
+    return ret;
+}
+
+int ne_sock_block(ne_socket *sock, int n)
+{
+    if (sock->bufavail)
+	return 0;
+    return sock->ops->readable(sock, n);
+}
+
+/* Cast address object AD to type 'sockaddr_TY' */ 
+#define SACAST(ty, ad) ((struct sockaddr_##ty *)(ad))
+
+ssize_t ne_sock_read(ne_socket *sock, char *buffer, size_t buflen)
+{
+    ssize_t bytes;
+
+#if 0
+    NE_DEBUG(NE_DBG_SOCKET, "buf: at %d, %d avail [%s]\n", 
+	     sock->bufpos - sock->buffer, sock->bufavail, sock->bufpos);
+#endif
+
+    if (sock->bufavail > 0) {
+	/* Deliver buffered data. */
+	if (buflen > sock->bufavail)
+	    buflen = sock->bufavail;
+	memcpy(buffer, sock->bufpos, buflen);
+	sock->bufpos += buflen;
+	sock->bufavail -= buflen;
+	return buflen;
+    } else if (buflen >= sizeof sock->buffer) {
+	/* No need for read buffer. */
+	return sock->ops->sread(sock, buffer, buflen);
+    } else {
+	/* Fill read buffer. */
+	bytes = sock->ops->sread(sock, sock->buffer, sizeof sock->buffer);
+	if (bytes <= 0)
+	    return bytes;
+
+	if (buflen > (size_t)bytes)
+	    buflen = bytes;
+	memcpy(buffer, sock->buffer, buflen);
+	sock->bufpos = sock->buffer + buflen;
+	sock->bufavail = bytes - buflen;
+	return buflen; 
+    }
+}
+
+ssize_t ne_sock_peek(ne_socket *sock, char *buffer, size_t buflen)
+{
+    ssize_t bytes;
+    
+    if (sock->bufavail) {
+	/* just return buffered data. */
+	bytes = sock->bufavail;
+    } else {
+	/* fill the buffer. */
+	bytes = sock->ops->sread(sock, sock->buffer, sizeof sock->buffer);
+	if (bytes <= 0)
+	    return bytes;
+
+	sock->bufpos = sock->buffer;
+	sock->bufavail = bytes;
+    }
+
+    if (buflen > (size_t)bytes)
+	buflen = bytes;
+
+    memcpy(buffer, sock->bufpos, buflen);
+
+    return buflen;
+}
+
+/* Await data on raw fd in socket. */
+static int readable_raw(ne_socket *sock, int secs)
+{
+    int ret = raw_poll(sock->fd, 0, secs);
+
+    if (ret < 0) {
+	set_strerror(sock, ne_errno);
+	return NE_SOCK_ERROR;
+    }
+    return (ret == 0) ? NE_SOCK_TIMEOUT : 0;
+}
+
+static ssize_t read_raw(ne_socket *sock, char *buffer, size_t len)
+{
+    ssize_t ret;
+    
+    ret = readable_raw(sock, sock->rdtimeout);
+    if (ret) return ret;
+
+    do {
+	ret = recv(sock->fd, buffer, len, 0);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+
+    if (ret == 0) {
+	set_error(sock, _("Connection closed"));
+	ret = NE_SOCK_CLOSED;
+    } else if (ret < 0) {
+	int errnum = ne_errno;
+	ret = NE_ISRESET(errnum) ? NE_SOCK_RESET : NE_SOCK_ERROR;
+	set_strerror(sock, errnum);
+    }
+
+    return ret;
+}
+
+#define MAP_ERR(e) (NE_ISCLOSED(e) ? NE_SOCK_CLOSED : \
+                    (NE_ISRESET(e) ? NE_SOCK_RESET : NE_SOCK_ERROR))
+
+static ssize_t write_raw(ne_socket *sock, const char *data, size_t length) 
+{
+    ssize_t ret;
+    
+#ifdef __QNX__
+    /* Test failures seen on QNX over loopback, if passing large
+     * buffer lengths to send().  */
+    if (length > 8192) length = 8192;
+#endif
+
+    do {
+	ret = send(sock->fd, data, length, 0);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+
+    if (ret < 0) {
+	int errnum = ne_errno;
+	set_strerror(sock, errnum);
+	return MAP_ERR(errnum);
+    }
+    return ret;
+}
+
+static ssize_t writev_raw(ne_socket *sock, const struct ne_iovec *vector, int count) 
+{
+    ssize_t ret;
+#ifdef WIN32
+    LPWSABUF wasvector = (LPWSABUF)ne_malloc(count * sizeof(WSABUF));
+    DWORD total;
+    int i;
+
+    for (i = 0; i < count; i++){
+        wasvector[i].buf = vector[i].base;
+        wasvector[i].len = vector[i].len;
+    }
+        
+    ret = WSASend(sock->fd, wasvector, count, &total, 0, NULL, NULL);
+    if (ret == 0)
+        ret = total;
+    
+    ne_free(wasvector);
+#else
+    const struct iovec *vec = (const struct iovec *) vector;
+
+    do {
+	ret = writev(sock->fd, vec, count);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+#endif
+
+    if (ret < 0) {
+	int errnum = ne_errno;
+	set_strerror(sock, errnum);
+	return MAP_ERR(errnum);
+    }
+    
+    return ret;
+}
+
+#ifdef NE_HAVE_SSL
+static ssize_t writev_dummy(ne_socket *sock, const struct ne_iovec *vector, int count) 
+{
+    return sock->ops->swrite(sock, vector[0].base, vector[0].len);
+}
+#endif
+
+static const struct iofns iofns_raw = { read_raw, write_raw, readable_raw, writev_raw };
+
+#ifdef HAVE_OPENSSL
+/* OpenSSL I/O function implementations. */
+static int readable_ossl(ne_socket *sock, int secs)
+{
+    if (SSL_pending(sock->ssl))
+	return 0;
+    return readable_raw(sock, secs);
+}
+
+/* SSL error handling, according to SSL_get_error(3). */
+static int error_ossl(ne_socket *sock, int sret)
+{
+    int errnum = SSL_get_error(sock->ssl, sret);
+    unsigned long err;
+
+    if (errnum == SSL_ERROR_ZERO_RETURN) {
+	set_error(sock, _("Connection closed"));
+        return NE_SOCK_CLOSED;
+    }
+    
+    /* for all other errors, look at the OpenSSL error stack */
+    err = ERR_get_error();
+    if (err == 0) {
+        /* Empty error stack, presume this is a system call error: */
+        if (sret == 0) {
+            /* EOF without close_notify, possible truncation */
+            set_error(sock, _("Secure connection truncated"));
+            return NE_SOCK_TRUNC;
+        } else {
+            /* Other socket error. */
+            errnum = ne_errno;
+            set_strerror(sock, errnum);
+            return MAP_ERR(errnum);
+        }
+    }
+
+    if (ERR_reason_error_string(err)) {
+        ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL error: %s"), ERR_reason_error_string(err));
+    } else {
+	ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL error code %d/%d/%lu"), sret, errnum, err);
+    }
+    
+    /* make sure the error stack is now empty. */
+    ERR_clear_error();
+    return NE_SOCK_ERROR;
+}
+
+/* Work around OpenSSL's use of 'int' rather than 'size_t', to prevent
+ * accidentally passing a negative number, etc. */
+#define CAST2INT(n) (((n) > INT_MAX) ? INT_MAX : (n))
+
+static ssize_t read_ossl(ne_socket *sock, char *buffer, size_t len)
+{
+    int ret;
+
+    ret = readable_ossl(sock, sock->rdtimeout);
+    if (ret) return ret;
+    
+    ret = SSL_read(sock->ssl, buffer, CAST2INT(len));
+    if (ret <= 0)
+	ret = error_ossl(sock, ret);
+
+    return ret;
+}
+
+static ssize_t write_ossl(ne_socket *sock, const char *data, size_t len)
+{
+    int ret, ilen = CAST2INT(len);
+    ret = SSL_write(sock->ssl, data, ilen);
+    /* ssl.h says SSL_MODE_ENABLE_PARTIAL_WRITE must be enabled to
+     * have SSL_write return < length...  so, SSL_write should never
+     * return < length. */
+    if (ret != ilen)
+	return error_ossl(sock, ret);
+    return ret;
+}
+
+static const struct iofns iofns_ssl = {
+    read_ossl,
+    write_ossl,
+    readable_ossl,
+    writev_dummy
+};
+
+#elif defined(HAVE_GNUTLS)
+
+/* Return zero if an alert value can be ignored. */
+static int check_alert(ne_socket *sock, ssize_t ret)
+{
+    const char *alert;
+
+    if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED) {
+        alert = gnutls_alert_get_name(gnutls_alert_get(sock->ssl));
+        NE_DEBUG(NE_DBG_SOCKET, "TLS warning alert: %s\n", alert);
+        return 0;
+    } else if (ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {
+        alert = gnutls_alert_get_name(gnutls_alert_get(sock->ssl));
+        NE_DEBUG(NE_DBG_SOCKET, "TLS fatal alert: %s\n", alert);
+        return -1;
+    }
+    return ret;
+}
+
+static int readable_gnutls(ne_socket *sock, int secs)
+{
+    if (gnutls_record_check_pending(sock->ssl)) {
+        return 0;
+    }
+    return readable_raw(sock, secs);
+}
+
+static ssize_t error_gnutls(ne_socket *sock, ssize_t sret)
+{
+    ssize_t ret;
+
+    switch (sret) {
+    case 0:
+	ret = NE_SOCK_CLOSED;
+	set_error(sock, _("Connection closed"));
+	break;
+    case GNUTLS_E_FATAL_ALERT_RECEIVED:
+        ret = NE_SOCK_ERROR;
+        ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL alert received: %s"),
+                    gnutls_alert_get_name(gnutls_alert_get(sock->ssl)));
+        break;
+#if GNUTLS_VERSION_MAJOR > 2 || (GNUTLS_VERSION_MAJOR == 2 && GNUTLS_VERSION_MINOR >= 99)
+    case GNUTLS_E_PREMATURE_TERMINATION:
+#else
+    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:
+#endif
+        ret = NE_SOCK_TRUNC;
+        set_error(sock, _("Secure connection truncated"));
+        break;
+    case GNUTLS_E_PUSH_ERROR:
+        ret = NE_SOCK_RESET;
+        set_error(sock, ("SSL socket write failed"));
+        break;
+    case GNUTLS_E_PULL_ERROR:
+        ret = NE_SOCK_RESET;
+        set_error(sock, _("SSL socket read failed"));
+        break;
+    default:
+        ret = NE_SOCK_ERROR;
+        ne_snprintf(sock->error, sizeof sock->error, _("SSL error: %s"),
+                    gnutls_strerror(sret));
+    }
+    return ret;
+}
+
+#define RETRY_GNUTLS(sock, ret) ((ret < 0) \
+    && (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN \
+        || check_alert(sock, ret) == 0))
+
+static ssize_t read_gnutls(ne_socket *sock, char *buffer, size_t len)
+{
+    ssize_t ret;
+    unsigned reneg = 1; /* number of allowed rehandshakes */
+
+    ret = readable_gnutls(sock, sock->rdtimeout);
+    if (ret) return ret;
+    
+    do {
+        do {
+            ret = gnutls_record_recv(sock->ssl, buffer, len);
+        } while (RETRY_GNUTLS(sock, ret));
+        
+    } while (ret == GNUTLS_E_REHANDSHAKE && reneg--
+             && (ret = gnutls_handshake(sock->ssl)) == GNUTLS_E_SUCCESS);
+
+    if (ret <= 0)
+	ret = error_gnutls(sock, ret);
+
+    return ret;
+}
+
+static ssize_t write_gnutls(ne_socket *sock, const char *data, size_t len)
+{
+    ssize_t ret;
+
+    do {
+        ret = gnutls_record_send(sock->ssl, data, len);
+    } while (RETRY_GNUTLS(sock, ret));
+
+    if (ret < 0)
+	return error_gnutls(sock, ret);
+
+    return ret;
+}
+
+static const struct iofns iofns_ssl = {
+    read_gnutls,
+    write_gnutls,
+    readable_gnutls,
+    writev_dummy
+};
+
+#endif
+
+int ne_sock_fullwrite(ne_socket *sock, const char *data, size_t len)
+{
+    ssize_t ret;
+
+    do {
+        ret = sock->ops->swrite(sock, data, len);
+        if (ret > 0) {
+            data += ret;
+            len -= ret;
+        }
+    } while (ret > 0 && len > 0);
+
+    return ret < 0 ? ret : 0;
+}
+
+int ne_sock_fullwritev(ne_socket *sock, const struct ne_iovec *vector, int count)
+{
+    ssize_t ret;
+
+    do {
+        ret = sock->ops->swritev(sock, vector, count);
+        if (ret > 0) {
+            while (count && (size_t)ret >= vector[0].len) {
+                ret -= vector[0].len;
+                count--;
+                vector++;
+            }
+            
+            if (ret && count) {
+                /* Partial buffer sent; send the rest. */
+                ret = ne_sock_fullwrite(sock, (char *)vector[0].base + ret,
+                                        vector[0].len - ret);
+                count--;
+                vector++;
+            }
+        }
+    } while (count && ret >= 0);
+
+    return ret < 0 ? ret : 0;
+}
+
+ssize_t ne_sock_readline(ne_socket *sock, char *buf, size_t buflen)
+{
+    char *lf;
+    size_t len;
+    
+    if ((lf = memchr(sock->bufpos, '\n', sock->bufavail)) == NULL
+	&& sock->bufavail < RDBUFSIZ) {
+	/* The buffered data does not contain a complete line: move it
+	 * to the beginning of the buffer. */
+	if (sock->bufavail)
+	    memmove(sock->buffer, sock->bufpos, sock->bufavail);
+	sock->bufpos = sock->buffer;
+	
+	/* Loop filling the buffer whilst no newline is found in the data
+	 * buffered so far, and there is still buffer space available */ 
+	do {
+	    /* Read more data onto end of buffer. */
+	    ssize_t ret = sock->ops->sread(sock, sock->buffer + sock->bufavail,
+                                           RDBUFSIZ - sock->bufavail);
+	    if (ret < 0) return ret;
+	    sock->bufavail += ret;
+	} while ((lf = memchr(sock->buffer, '\n', sock->bufavail)) == NULL
+		 && sock->bufavail < RDBUFSIZ);
+    }
+
+    if (lf)
+	len = lf - sock->bufpos + 1;
+    else
+	len = buflen; /* fall into "line too long" error... */
+
+    if ((len + 1) > buflen) {
+	set_error(sock, _("Line too long"));
+	return NE_SOCK_ERROR;
+    }
+
+    memcpy(buf, sock->bufpos, len);
+    buf[len] = '\0';
+    /* consume the line from buffer: */
+    sock->bufavail -= len;
+    sock->bufpos += len;
+    return len;
+}
+
+ssize_t ne_sock_fullread(ne_socket *sock, char *buffer, size_t buflen) 
+{
+    ssize_t len;
+
+    while (buflen > 0) {
+	len = ne_sock_read(sock, buffer, buflen);
+	if (len < 0) return len;
+	buflen -= len;
+	buffer += len;
+    }
+
+    return 0;
+}
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((in_addr_t) -1)
+#endif
+
+#if !defined(USE_GETADDRINFO) && !defined(WIN32) && !HAVE_DECL_H_ERRNO
+/* Ancient versions of netdb.h don't export h_errno. */
+extern int h_errno;
+#endif
+
+/* This implemementation does not attempt to support IPv6 using
+ * gethostbyname2 et al.  */
+ne_sock_addr *ne_addr_resolve(const char *hostname, int flags)
+{
+    ne_sock_addr *addr = ne_calloc(sizeof *addr);
+#ifdef USE_GETADDRINFO
+    struct addrinfo hints = {0};
+    char *pnt;
+
+    hints.ai_socktype = SOCK_STREAM;
+
+    if (flags & NE_ADDR_CANON) {
+        hints.ai_flags = AI_CANONNAME;
+    }
+
+#ifdef AF_INET6
+    if (hostname[0] == '[' && ((pnt = strchr(hostname, ']')) != NULL)) {
+	char *hn = ne_strdup(hostname + 1);
+	hn[pnt - hostname - 1] = '\0';
+#ifdef AI_NUMERICHOST /* added in the RFC2553 API */
+	hints.ai_flags |= AI_NUMERICHOST;
+#endif
+        hints.ai_family = AF_INET6;
+	addr->errnum = getaddrinfo(hn, NULL, &hints, &addr->result);
+	ne_free(hn);
+    } else 
+#endif /* AF_INET6 */
+    {
+#ifdef USE_GAI_ADDRCONFIG /* added in the RFC3493 API */
+        hints.ai_flags |= AI_ADDRCONFIG;
+        hints.ai_family = AF_UNSPEC;
+        addr->errnum = getaddrinfo(hostname, NULL, &hints, &addr->result);
+#else
+        hints.ai_family = ipv6_disabled ? AF_INET : AF_UNSPEC;
+	addr->errnum = getaddrinfo(hostname, NULL, &hints, &addr->result);
+#endif
+    }
+#else /* Use gethostbyname() */
+    in_addr_t laddr;
+    struct hostent *hp;
+    
+    laddr = inet_addr(hostname);
+    if (laddr == INADDR_NONE) {
+	hp = gethostbyname(hostname);
+	if (hp == NULL) {
+#ifdef WIN32
+	    addr->errnum = WSAGetLastError();
+#else
+            addr->errnum = h_errno;
+#endif
+	} else if (hp->h_length != sizeof(struct in_addr)) {
+	    /* fail gracefully if somebody set RES_USE_INET6 */
+	    addr->errnum = NO_RECOVERY;
+	} else {
+	    size_t n;
+	    /* count addresses */
+	    for (n = 0; hp->h_addr_list[n] != NULL; n++)
+		/* noop */;
+
+	    addr->count = n;
+	    addr->addrs = ne_malloc(n * sizeof *addr->addrs);
+
+	    for (n = 0; n < addr->count; n++)
+		memcpy(&addr->addrs[n], hp->h_addr_list[n], hp->h_length);
+            
+            if (hp->h_name && hp->h_name[0]) 
+                addr->name = ne_strdup(hp->h_name);
+	}
+    } else {
+	addr->addrs = ne_malloc(sizeof *addr->addrs);
+	addr->count = 1;
+	memcpy(addr->addrs, &laddr, sizeof *addr->addrs);
+    }
+#endif
+    return addr;
+}
+
+int ne_addr_result(const ne_sock_addr *addr)
+{
+    return addr->errnum;
+}
+
+const char *ne_addr_canonical(const ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    return addr->result ? addr->result->ai_canonname : NULL;
+#else
+    return addr->name;
+#endif
+}
+
+const ne_inet_addr *ne_addr_first(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    addr->cursor = addr->result->ai_next;
+    return addr->result;
+#else
+    addr->cursor = 0;
+    return &addr->addrs[0];
+#endif
+}
+
+const ne_inet_addr *ne_addr_next(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    struct addrinfo *ret = addr->cursor;
+    if (addr->cursor) addr->cursor = addr->cursor->ai_next;
+#else
+    struct in_addr *ret;
+    if (++addr->cursor < addr->count)
+	ret = &addr->addrs[addr->cursor];
+    else
+	ret = NULL;
+#endif
+    return ret;
+}
+
+char *ne_addr_error(const ne_sock_addr *addr, char *buf, size_t bufsiz)
+{
+#ifdef WIN32
+    print_error(addr->errnum, buf, bufsiz);
+#else
+    const char *err;
+#ifdef USE_GETADDRINFO
+    /* override horrible generic "Name or service not known" error. */
+    if (addr->errnum == EAI_NONAME)
+	err = _("Host not found");
+    else
+	err = gai_strerror(addr->errnum);
+#elif defined(HAVE_HSTRERROR)
+    err = hstrerror(addr->errnum);
+#else
+    err = _("Host not found");
+#endif
+    ne_strnzcpy(buf, err, bufsiz);
+#endif /* WIN32 */
+    return buf;
+}
+
+char *ne_iaddr_print(const ne_inet_addr *ia, char *buf, size_t bufsiz)
+{
+#if defined(USE_GETADDRINFO) && defined(HAVE_INET_NTOP)
+    const char *ret;
+#ifdef AF_INET6
+    if (ia->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in6 = SACAST(in6, ia->ai_addr);
+	ret = inet_ntop(AF_INET6, &in6->sin6_addr, buf, bufsiz);
+    } else
+#endif
+    if (ia->ai_family == AF_INET) {
+	struct sockaddr_in *in = SACAST(in, ia->ai_addr);
+	ret = inet_ntop(AF_INET, &in->sin_addr, buf, bufsiz);
+    } else
+	ret = NULL;
+    if (ret == NULL)
+	ne_strnzcpy(buf, "[IP address]", bufsiz);
+#elif defined(USE_GETADDRINFO) && defined(NI_NUMERICHOST)
+    /* use getnameinfo instead for Win32, which lacks inet_ntop: */
+    if (getnameinfo(ia->ai_addr, ia->ai_addrlen, buf, bufsiz, NULL, 0,
+                    NI_NUMERICHOST))
+        ne_strnzcpy(buf, "[IP address]", bufsiz);
+#else /* USE_GETADDRINFO */
+    ne_strnzcpy(buf, inet_ntoa(*ia), bufsiz);
+#endif
+    return buf;
+}
+
+unsigned char *ne_iaddr_raw(const ne_inet_addr *ia, unsigned char *buf)
+{
+#ifdef USE_GETADDRINFO
+#ifdef AF_INET6
+    if (ia->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in6 = SACAST(in6, ia->ai_addr);
+        return memcpy(buf, in6->sin6_addr.s6_addr, sizeof in6->sin6_addr.s6_addr);
+    } else
+#endif /* AF_INET6 */
+    {
+	struct sockaddr_in *in = SACAST(in, ia->ai_addr);
+        return memcpy(buf, &in->sin_addr.s_addr, sizeof in->sin_addr.s_addr);
+    }
+#else /* !USE_GETADDRINFO */
+    return memcpy(buf, &ia->s_addr, sizeof ia->s_addr);
+#endif
+}
+
+ne_inet_addr *ne_iaddr_parse(const char *addr, ne_iaddr_type type)
+{
+#if defined(USE_GETADDRINFO) && defined(HAVE_INET_PTON)
+    char dst[sizeof(struct in6_addr)];
+    int af = type == ne_iaddr_ipv6 ? AF_INET6 : AF_INET;
+
+    if (inet_pton(af, addr, dst) != 1) {
+        return NULL;
+    }
+    
+    return ne_iaddr_make(type, (unsigned char *)dst);
+#elif defined(USE_GETADDRINFO) && !defined(HAVE_INET_PTON)
+    /* For Windows, which lacks inet_pton(). */
+    struct addrinfo *ai, *rv, hints;
+
+    memset(&hints, 0, sizeof hints);
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_flags = AI_NUMERICHOST;
+    hints.ai_family = type == ne_iaddr_ipv6 ? AF_INET6 : AF_INET;
+    
+    if (getaddrinfo(addr, NULL, &hints, &ai)) {
+        return NULL;
+    }
+    
+    /* Copy the returned addrinfo, since it needs to be ne_free()-able
+     * later; must only call freeaddrinfo() on ai. */
+    rv = ne_calloc(sizeof *rv);
+    memcpy(rv, ai, sizeof *rv);
+    rv->ai_next = NULL;
+    rv->ai_canonname = NULL;
+    rv->ai_addr = ne_calloc(ai->ai_addrlen);
+    memcpy(rv->ai_addr, ai->ai_addr, ai->ai_addrlen);
+    freeaddrinfo(ai);
+    
+    return rv;    
+#else /* !USE_GETADDRINFO */
+    struct in_addr a;
+    
+    if (type == ne_iaddr_ipv6) {
+        return NULL;
+    }
+
+#ifdef WIN32
+    /* inet_addr() is broken because INADDR_NONE is a valid
+     * broadcast address, so only use it on Windows. */
+    a.s_addr = inet_addr(addr);
+    if (a.s_addr == INADDR_NONE) {
+        return NULL;
+    }
+#else /* !WIN32 */
+    if (inet_aton(addr, &a) == 0) {
+        return NULL;
+    }
+#endif
+    
+    return ne_iaddr_make(ne_iaddr_ipv4, (unsigned char *)&a.s_addr);
+#endif /* !USE_GETADDRINFO */
+}
+
+int ne_iaddr_reverse(const ne_inet_addr *ia, char *buf, size_t bufsiz)
+{
+#ifdef USE_GETADDRINFO
+    return getnameinfo(ia->ai_addr, ia->ai_addrlen, buf, bufsiz,
+                       NULL, 0, 0);
+#else
+    struct hostent *hp;
+    
+    /* Cast to const void *; some old libc headers apparently expect
+     * const char * here. */
+    hp = gethostbyaddr((const void *)ia, sizeof *ia, AF_INET);
+    if (hp && hp->h_name) {
+        ne_strnzcpy(buf, hp->h_name, bufsiz);
+        return 0;
+    }
+    return -1;
+#endif
+}
+
+void ne_addr_destroy(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    if (addr->result)
+	freeaddrinfo(addr->result);
+#else
+    if (addr->addrs)
+	ne_free(addr->addrs);
+    if (addr->name)
+        ne_free(addr->name);
+#endif
+    ne_free(addr);
+}
+
+/* Perform a connect() for given fd, handling EINTR retries.  Returns
+ * zero on success or -1 on failure, in which case, ne_errno is set
+ * appropriately. */
+static int raw_connect(int fd, const struct sockaddr *sa, size_t salen)
+{
+    int ret;
+
+    do {
+        ret = connect(fd, sa, salen);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+
+    return ret;
+}
+
+/* Perform a connect() for fd to address sa of length salen, with a
+ * timeout if supported on this platform.  Returns zero on success or
+ * NE_SOCK_* on failure, with sock->error set appropriately. */
+static int timed_connect(ne_socket *sock, int fd,
+                         const struct sockaddr *sa, size_t salen)
+{
+    int ret;
+
+#ifdef USE_NONBLOCKING_CONNECT
+    if (sock->cotimeout) {
+        int errnum, flags;
+
+        /* Get flags and then set O_NONBLOCK. */
+        flags = fcntl(fd, F_GETFL);
+        if (flags & O_NONBLOCK) {
+            /* This socket was created using SOCK_NONBLOCK... flip the
+             * bit for restoring flags later. */
+            flags &= ~O_NONBLOCK;
+        }
+        else if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
+            set_strerror(sock, errno);
+            return NE_SOCK_ERROR;
+        }
+        
+        ret = raw_connect(fd, sa, salen);
+        if (ret == -1) {
+            errnum = ne_errno;
+            if (NE_ISINPROGRESS(errnum)) {
+                ret = raw_poll(fd, 1, sock->cotimeout);
+                if (ret > 0) { /* poll got data */
+                    socklen_t len = sizeof(errnum);
+                    
+                    /* Check whether there is a pending error for the
+                     * socket.  Per Stevens UNPv115.4, Solaris will
+                     * return a pending error via errno by failing the
+                     * getsockopt() call. */
+
+                    errnum = 0;
+                    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &errnum, &len))
+                        errnum = errno;
+                    
+                    if (errnum == 0) {
+                        ret = 0;
+                    } else {
+                        set_strerror(sock, errnum);
+                        ret = NE_SOCK_ERROR;
+                    }
+                } else if (ret == 0) { /* poll timed out */
+                    set_error(sock, _("Connection timed out"));
+                    ret = NE_SOCK_TIMEOUT;
+                } else /* poll failed */ {
+                    set_strerror(sock, errno);
+                    ret = NE_SOCK_ERROR;
+                }
+            } else /* non-EINPROGRESS error from connect() */ { 
+                set_strerror(sock, errnum);
+                ret = NE_SOCK_ERROR;
+            }
+        }
+        
+        /* Reset to old flags; fail on error if no previous error. */
+        if (fcntl(fd, F_SETFL, flags) == -1 && !ret) {
+            set_strerror(sock, errno);
+            ret = NE_SOCK_ERROR;
+        }
+    } else 
+#endif /* USE_NONBLOCKING_CONNECT */
+    {
+        ret = raw_connect(fd, sa, salen);
+        
+        if (ret < 0) {
+            set_strerror(sock, ne_errno);
+            ret = NE_SOCK_ERROR;
+        }
+    }
+
+    return ret;
+}
+
+/* Connect socket to address 'addr' on given 'port'.  Returns zero on
+ * success or NE_SOCK_* on failure with sock->error set
+ * appropriately. */
+static int connect_socket(ne_socket *sock, int fd,
+                          const ne_inet_addr *addr, unsigned int port)
+{
+#ifdef USE_GETADDRINFO
+#ifdef AF_INET6
+    /* fill in the _family field for AIX 4.3, which forgets to do so. */
+    if (addr->ai_family == AF_INET6) {
+	struct sockaddr_in6 in6;
+	memcpy(&in6, addr->ai_addr, sizeof in6);
+	in6.sin6_port = port;
+        in6.sin6_family = AF_INET6;
+        return timed_connect(sock, fd, (struct sockaddr *)&in6, sizeof in6);
+    } else
+#endif
+    if (addr->ai_family == AF_INET) {
+	struct sockaddr_in in;
+	memcpy(&in, addr->ai_addr, sizeof in);
+	in.sin_port = port;
+        in.sin_family = AF_INET;
+        return timed_connect(sock, fd, (struct sockaddr *)&in, sizeof in);
+    } else {
+        set_strerror(sock, EINVAL);
+        return NE_SOCK_ERROR;
+    }
+#else
+    struct sockaddr_in sa = {0};
+    sa.sin_family = AF_INET;
+    sa.sin_port = port;
+    sa.sin_addr = *addr;
+    return timed_connect(sock, fd, (struct sockaddr *)&sa, sizeof sa);
+#endif
+}
+
+ne_socket *ne_sock_create(void)
+{
+    ne_socket *sock = ne_calloc(sizeof *sock);
+    sock->rdtimeout = SOCKET_READ_TIMEOUT;
+    sock->cotimeout = 0;
+    sock->bufpos = sock->buffer;
+    sock->ops = &iofns_raw;
+    sock->fd = -1;
+    return sock;
+}
+
+
+#ifdef USE_GETADDRINFO
+#define ia_family(a) ((a)->ai_family)
+#define ia_proto(a)  ((a)->ai_protocol)
+#else
+#define ia_family(a) AF_INET
+#define ia_proto(a)  0
+#endif
+
+void ne_sock_prebind(ne_socket *sock, const ne_inet_addr *addr,
+                     unsigned int port)
+{
+    sock->lport = port;
+    sock->laddr = addr ? addr : &dummy_laddr;    
+}
+
+/* Bind socket 'fd' to address/port 'addr' and 'port', for subsequent
+ * connect() to address of family 'peer_family'. */
+static int do_bind(int fd, int peer_family, 
+                   const ne_inet_addr *addr, unsigned int port)
+{
+#if defined(HAVE_SETSOCKOPT) && defined(SO_REUSEADDR) && defined(SOL_SOCKET)
+    {
+        int flag = 1;
+
+        (void) setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof flag);
+        /* An error here is not fatal, so ignore it. */
+    }
+#endif        
+    
+
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    /* Use a sockaddr_in6 if an AF_INET6 local address is specifed, or
+     * if no address is specified and the peer address is AF_INET6: */
+    if ((addr != &dummy_laddr && addr->ai_family == AF_INET6)
+        || (addr == &dummy_laddr && peer_family == AF_INET6)) {
+        struct sockaddr_in6 in6;
+        
+        if (addr == &dummy_laddr)
+            memset(&in6, 0, sizeof in6);
+        else
+            memcpy(&in6, addr->ai_addr, sizeof in6);
+        in6.sin6_port = htons(port);
+        /* fill in the _family field for AIX 4.3, which forgets to do so. */
+        in6.sin6_family = AF_INET6;
+
+        return bind(fd, (struct sockaddr *)&in6, sizeof in6);
+    } else
+#endif
+    {
+	struct sockaddr_in in;
+
+        if (addr == &dummy_laddr)
+            memset(&in, 0, sizeof in);
+        else {
+#ifdef USE_GETADDRINFO
+            memcpy(&in, addr->ai_addr, sizeof in);
+#else
+            in.sin_addr = *addr;
+#endif
+        }
+        in.sin_port = htons(port);
+        in.sin_family = AF_INET;
+
+        return bind(fd, (struct sockaddr *)&in, sizeof in);
+    }
+}
+
+#ifdef SOCK_CLOEXEC
+/* sock_cloexec is initialized to SOCK_CLOEXEC and cleared to zero if
+ * a socket() call ever fails with EINVAL; not strictly thread-safe
+ * but in practice it will not matter if two threads race accessing
+ * the variable. */
+static int sock_cloexec = SOCK_CLOEXEC;
+#define RETRY_ON_EINVAL
+#else
+#define sock_cloexec 0
+#endif
+
+int ne_sock_connect(ne_socket *sock,
+                    const ne_inet_addr *addr, unsigned int port)
+{
+    int fd, ret;
+    int type = SOCK_STREAM | sock_cloexec;
+
+#if defined(RETRY_ON_EINVAL) && defined(SOCK_NONBLOCK) \
+    && defined(USE_NONBLOCKING_CONNECT)
+    /* If the SOCK_NONBLOCK flag is defined, and the retry-on-EINVAL
+     * logic is enabled, and the socket has a configured timeout, then
+     * also use the SOCK_NONBLOCK flag to save enabling O_NONBLOCK
+     * later. */
+    if (sock->cotimeout && sock_cloexec) {
+        type |= SOCK_NONBLOCK;
+    }
+#endif
+
+    /* use SOCK_STREAM rather than ai_socktype: some getaddrinfo
+     * implementations do not set ai_socktype, e.g. RHL6.2. */
+    fd = socket(ia_family(addr), type, ia_proto(addr));
+#ifdef RETRY_ON_EINVAL
+    /* Handle forwards compat for new glibc on an older kernels; clear
+     * the sock_cloexec flag and retry the call: */
+    if (fd < 0 && sock_cloexec && errno == EINVAL) {
+        sock_cloexec = 0;
+        fd = socket(ia_family(addr), SOCK_STREAM, ia_proto(addr));
+    }
+#endif
+    if (fd < 0) {
+        set_strerror(sock, ne_errno);
+	return -1;
+    }
+    
+#if !defined(NE_USE_POLL) && !defined(WIN32)
+    if (fd > FD_SETSIZE) {
+        ne_close(fd);
+        set_error(sock, _("Socket descriptor number exceeds FD_SETSIZE"));
+        return NE_SOCK_ERROR;
+    }
+#endif
+   
+#if defined(HAVE_FCNTL) && defined(F_GETFD) && defined(F_SETFD) \
+  && defined(FD_CLOEXEC)
+    /* Set the FD_CLOEXEC bit for the new fd, if the socket was not
+     * created with the CLOEXEC bit already set. */
+    if (!sock_cloexec && (ret = fcntl(fd, F_GETFD)) >= 0) {
+        fcntl(fd, F_SETFD, ret | FD_CLOEXEC);
+        /* ignore failure; not a critical error. */
+    }
+#endif
+
+    if (sock->laddr && (sock->laddr == &dummy_laddr || 
+                        ia_family(sock->laddr) == ia_family(addr))) {
+        ret = do_bind(fd, ia_family(addr), sock->laddr, sock->lport);
+        if (ret < 0) {
+            int errnum = ne_errno;
+            ne_close(fd);
+            set_strerror(sock, errnum);
+            return NE_SOCK_ERROR;
+        }
+    }
+
+#if defined(HAVE_SETSOCKOPT) && (defined(TCP_NODELAY) || defined(WIN32))
+    { /* Disable the Nagle algorithm. */
+        int flag = 1;
+        setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof flag);
+    }
+#endif
+    
+    ret = connect_socket(sock, fd, addr, htons(port));
+    if (ret == 0)
+        sock->fd = fd;
+    else
+        ne_close(fd);
+
+    return ret;
+}
+
+ne_inet_addr *ne_sock_peer(ne_socket *sock, unsigned int *port)
+{
+    union saun {
+        struct sockaddr sa;
+        struct sockaddr_in sin;
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+        struct sockaddr_in6 sin6;
+#endif
+    } saun;
+    socklen_t len = sizeof saun;
+    ne_inet_addr *ia;
+    struct sockaddr *sad = (struct sockaddr *)&saun;
+
+    if (getpeername(sock->fd, sad, &len) != 0) {
+        set_strerror(sock, errno);
+        return NULL;
+    }
+
+#if !defined(USE_GETADDRINFO) || !defined(AF_INET6)
+    if (sad->sa_family != AF_INET) {
+        set_error(sock, _("Socket family not supported"));
+        return NULL;
+    }
+#endif                  
+
+    ia = ne_calloc(sizeof *ia);
+#ifdef USE_GETADDRINFO
+    ia->ai_addr = ne_malloc(sizeof *ia);
+    ia->ai_addrlen = len;
+    memcpy(ia->ai_addr, sad, len);
+    ia->ai_family = saun.sa.sa_family;
+#else
+    memcpy(ia, &saun.sin.sin_addr.s_addr, sizeof *ia);
+#endif    
+
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    *port = ntohs(saun.sa.sa_family == AF_INET ? 
+                  saun.sin.sin_port : saun.sin6.sin6_port);
+#else
+    *port = ntohs(saun.sin.sin_port);
+#endif
+
+    return ia;
+}
+
+ne_inet_addr *ne_iaddr_make(ne_iaddr_type type, const unsigned char *raw)
+{
+    ne_inet_addr *ia;
+#if !defined(AF_INET6) || !defined(USE_GETADDRINFO)
+    /* fail if IPv6 address is given if IPv6 is not supported. */
+    if (type == ne_iaddr_ipv6)
+	return NULL;
+#endif
+    ia = ne_calloc(sizeof *ia);
+#ifdef USE_GETADDRINFO
+    /* ai_protocol and ai_socktype aren't used by connect_socket() so
+     * ignore them here. (for now) */
+    if (type == ne_iaddr_ipv4) {
+	struct sockaddr_in *in4 = ne_calloc(sizeof *in4);
+	ia->ai_family = AF_INET;
+	ia->ai_addr = (struct sockaddr *)in4;
+	ia->ai_addrlen = sizeof *in4;
+	in4->sin_family = AF_INET;
+	memcpy(&in4->sin_addr.s_addr, raw, sizeof in4->sin_addr.s_addr);
+    }
+#ifdef AF_INET6
+    else {
+	struct sockaddr_in6 *in6 = ne_calloc(sizeof *in6);
+	ia->ai_family = AF_INET6;
+	ia->ai_addr = (struct sockaddr *)in6;
+	ia->ai_addrlen = sizeof *in6;
+	in6->sin6_family = AF_INET6;
+	memcpy(&in6->sin6_addr, raw, sizeof in6->sin6_addr.s6_addr);
+    }
+#endif
+#else /* !USE_GETADDRINFO */
+    memcpy(&ia->s_addr, raw, sizeof ia->s_addr);
+#endif    
+    return ia;
+}
+
+ne_iaddr_type ne_iaddr_typeof(const ne_inet_addr *ia)
+{
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    return ia->ai_family == AF_INET6 ? ne_iaddr_ipv6 : ne_iaddr_ipv4;
+#else
+    return ne_iaddr_ipv4;
+#endif
+}
+
+int ne_iaddr_cmp(const ne_inet_addr *i1, const ne_inet_addr *i2)
+{
+#ifdef USE_GETADDRINFO
+    if (i1->ai_family != i2->ai_family)
+	return i2->ai_family - i1->ai_family;
+    if (i1->ai_family == AF_INET) {
+	struct sockaddr_in *in1 = SACAST(in, i1->ai_addr), 
+	    *in2 = SACAST(in, i2->ai_addr);
+	return memcmp(&in1->sin_addr.s_addr, &in2->sin_addr.s_addr, 
+		      sizeof in1->sin_addr.s_addr);
+    } 
+#ifdef AF_INET6
+    else if (i1->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in1 = SACAST(in6, i1->ai_addr), 
+	    *in2 = SACAST(in6, i2->ai_addr);
+	return memcmp(in1->sin6_addr.s6_addr, in2->sin6_addr.s6_addr,
+		      sizeof in1->sin6_addr.s6_addr);
+    } 
+#endif /* AF_INET6 */
+    else
+	return -1;
+#else
+    return memcmp(&i1->s_addr, &i2->s_addr, sizeof i1->s_addr);
+#endif /* USE_GETADDRINFO */
+}
+
+void ne_iaddr_free(ne_inet_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    ne_free(addr->ai_addr);
+#endif
+    ne_free(addr);
+}
+
+int ne_sock_accept(ne_socket *sock, int listener) 
+{
+    int fd = accept(listener, NULL, NULL);
+
+    if (fd < 0) {
+        set_strerror(sock, ne_errno);
+        return -1;
+    }
+
+    sock->fd = fd;
+    return 0;
+}
+
+int ne_sock_fd(const ne_socket *sock)
+{
+    return sock->fd;
+}
+
+void ne_sock_read_timeout(ne_socket *sock, int timeout)
+{
+    sock->rdtimeout = timeout;
+}
+
+void ne_sock_connect_timeout(ne_socket *sock, int timeout)
+{
+    sock->cotimeout = timeout;
+}
+
+#ifdef NE_HAVE_SSL
+
+#ifdef HAVE_GNUTLS
+/* Dumb server session cache implementation for GNUTLS; holds a single
+ * session. */
+
+/* Copy datum 'src' to 'dest'. */
+static void copy_datum(gnutls_datum_t *dest, gnutls_datum_t *src)
+{
+    dest->size = src->size;
+    dest->data = memcpy(gnutls_malloc(src->size), src->data, src->size);
+}
+
+/* Callback to store a session 'data' with id 'key'. */
+static int store_sess(void *userdata, gnutls_datum_t key, gnutls_datum_t data)
+{
+    ne_ssl_context *ctx = userdata;
+
+    if (ctx->cache.server.key.data) { 
+        gnutls_free(ctx->cache.server.key.data);
+        gnutls_free(ctx->cache.server.data.data);
+    }
+
+    copy_datum(&ctx->cache.server.key, &key);
+    copy_datum(&ctx->cache.server.data, &data);
+
+    return 0;
+}
+
+/* Returns non-zero if d1 and d2 are the same datum. */
+static int match_datum(gnutls_datum_t *d1, gnutls_datum_t *d2)
+{
+    return d1->size == d2->size
+        && memcmp(d1->data, d2->data, d1->size) == 0;
+}
+
+/* Callback to retrieve a session of id 'key'. */
+static gnutls_datum_t retrieve_sess(void *userdata, gnutls_datum_t key)
+{
+    ne_ssl_context *ctx = userdata;
+    gnutls_datum_t ret = { NULL, 0 };
+
+    if (match_datum(&ctx->cache.server.key, &key)) {
+        copy_datum(&ret, &ctx->cache.server.data);
+    }
+
+    return ret;
+}
+
+/* Callback to remove a session of id 'key'; stub needed but
+ * implementation seems unnecessary. */
+static int remove_sess(void *userdata, gnutls_datum_t key)
+{
+    return -1;
+}
+#endif
+
+int ne_sock_accept_ssl(ne_socket *sock, ne_ssl_context *ctx)
+{
+    int ret;
+    ne_ssl_socket ssl;
+
+#if defined(HAVE_OPENSSL)
+    ssl = SSL_new(ctx->ctx);
+    
+    SSL_set_fd(ssl, sock->fd);
+
+    sock->ssl = ssl;
+    ret = SSL_accept(ssl);
+    if (ret != 1) {
+        return error_ossl(sock, ret);
+    }
+
+    if (SSL_session_reused(ssl)) {
+        NE_DEBUG(NE_DBG_SSL, "ssl: Server reused session.\n");
+    }
+#elif defined(HAVE_GNUTLS)
+    unsigned int verify_status;
+
+    gnutls_init(&ssl, GNUTLS_SERVER);
+    gnutls_credentials_set(ssl, GNUTLS_CRD_CERTIFICATE, ctx->cred);
+    gnutls_set_default_priority(ssl);
+
+    /* Set up dummy session cache. */
+    gnutls_db_set_store_function(ssl, store_sess);
+    gnutls_db_set_retrieve_function(ssl, retrieve_sess);    
+    gnutls_db_set_remove_function(ssl, remove_sess);    
+    gnutls_db_set_ptr(ssl, ctx);
+
+    if (ctx->verify)
+        gnutls_certificate_server_set_request(ssl, GNUTLS_CERT_REQUIRE);
+
+    sock->ssl = ssl;
+    gnutls_transport_set_ptr(sock->ssl, (gnutls_transport_ptr_t)(long)sock->fd);
+    ret = gnutls_handshake(ssl);
+    if (ret < 0) {
+        return error_gnutls(sock, ret);
+    }
+    if (ctx->verify && (gnutls_certificate_verify_peers2(ssl, &verify_status) || verify_status)) {
+        set_error(sock, _("Client certificate verification failed"));
+        return NE_SOCK_ERROR;
+    }
+#endif
+    sock->ops = &iofns_ssl;
+    return 0;
+}
+
+int ne_sock_connect_ssl(ne_socket *sock, ne_ssl_context *ctx, void *userdata)
+{
+    int ret;
+
+#if defined(HAVE_OPENSSL)
+    SSL *ssl;
+
+    if (seed_ssl_prng()) {
+	set_error(sock, _("SSL disabled due to lack of entropy"));
+	return NE_SOCK_ERROR;
+    }
+
+    sock->ssl = ssl = SSL_new(ctx->ctx);
+    if (!ssl) {
+	set_error(sock, _("Could not create SSL structure"));
+	return NE_SOCK_ERROR;
+    }
+    
+    SSL_set_app_data(ssl, userdata);
+    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
+    SSL_set_fd(ssl, sock->fd);
+    sock->ops = &iofns_ssl;
+
+#ifdef SSL_set_tlsext_host_name
+    if (ctx->hostname) {
+        /* Try to enable SNI, but ignore failure (should only fail for
+         * >255 char hostnames, which are probably not legal
+         * anyway).  */
+        if (SSL_set_tlsext_host_name(ssl, ctx->hostname) != 1) {
+            ERR_clear_error();
+        }
+    }
+#endif
+    
+    if (ctx->sess)
+	SSL_set_session(ssl, ctx->sess);
+
+    ret = SSL_connect(ssl);
+    if (ret != 1) {
+	error_ossl(sock, ret);
+	SSL_free(ssl);
+	sock->ssl = NULL;
+	return NE_SOCK_ERROR;
+    }
+#elif defined(HAVE_GNUTLS)
+    /* DH and RSA params are set in ne_ssl_context_create */
+    gnutls_init(&sock->ssl, GNUTLS_CLIENT);
+    gnutls_set_default_priority(sock->ssl);
+    gnutls_session_set_ptr(sock->ssl, userdata);
+    gnutls_credentials_set(sock->ssl, GNUTLS_CRD_CERTIFICATE, ctx->cred);
+
+#ifdef HAVE_GNUTLS_SIGN_CALLBACK_SET
+    if (ctx->sign_func)
+        gnutls_sign_callback_set(sock->ssl, ctx->sign_func, ctx->sign_data);    
+#endif
+
+    if (ctx->hostname) {
+        gnutls_server_name_set(sock->ssl, GNUTLS_NAME_DNS, ctx->hostname,
+                               strlen(ctx->hostname));
+    }                               
+
+    gnutls_transport_set_ptr(sock->ssl, (gnutls_transport_ptr_t)(long)sock->fd);
+
+    if (ctx->cache.client.data) {
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_session_set_data(sock->ssl, 
+                                ctx->cache.client.data, 
+                                ctx->cache.client.size);
+#else
+        gnutls_session_set_data(sock->ssl, 
+                                ctx->cache.client.data, 
+                                ctx->cache.client.len);
+#endif
+    }
+    sock->ops = &iofns_ssl;
+
+    do {
+        ret = gnutls_handshake(sock->ssl);
+    } while (RETRY_GNUTLS(sock, ret));
+    if (ret < 0) {
+	error_gnutls(sock, ret);
+        return NE_SOCK_ERROR;
+    }
+
+    if (!gnutls_session_is_resumed(sock->ssl)) {
+        /* New session.  The old method of using the _get_data
+         * function seems to be broken with 1.3.0 and later*/
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_session_get_data2(sock->ssl, &ctx->cache.client);
+#else
+        ctx->cache.client.len = 0;
+        if (gnutls_session_get_data(sock->ssl, NULL, 
+                                    &ctx->cache.client.len) == 0) {
+            ctx->cache.client.data = ne_malloc(ctx->cache.client.len);
+            gnutls_session_get_data(sock->ssl, ctx->cache.client.data, 
+                                    &ctx->cache.client.len);
+        }
+#endif
+    }
+#endif
+    return 0;
+}
+
+ne_ssl_socket ne__sock_sslsock(ne_socket *sock)
+{
+    return sock->ssl;
+}
+
+#endif
+
+int ne_sock_sessid(ne_socket *sock, unsigned char *buf, size_t *buflen)
+{
+#ifdef NE_HAVE_SSL
+#ifdef HAVE_GNUTLS
+    if (sock->ssl) {
+        return gnutls_session_get_id(sock->ssl, buf, buflen);
+    } else {
+        return -1;
+    }
+#else
+    SSL_SESSION *sess;
+
+    if (!sock->ssl) {
+        return -1;
+    }
+
+    sess = SSL_get0_session(sock->ssl);
+
+    if (!buf) {
+        *buflen = sess->session_id_length;
+        return 0;
+    }
+
+    if (*buflen < sess->session_id_length) {
+        return -1;
+    }
+
+    *buflen = sess->session_id_length;
+    memcpy(buf, sess->session_id, *buflen);
+    return 0;
+#endif
+#else
+    return -1;
+#endif
+}
+
+char *ne_sock_cipher(ne_socket *sock)
+{
+#ifdef NE_HAVE_SSL
+    if (sock->ssl) {
+#ifdef HAVE_OPENSSL
+        const char *name = SSL_get_cipher(sock->ssl);
+        return ne_strdup(name);
+#elif defined(HAVE_GNUTLS)
+        const char *name = gnutls_cipher_get_name(gnutls_cipher_get(sock->ssl));
+        return ne_strdup(name);
+#endif
+    }
+    else 
+#endif /* NE_HAVE_SSL */
+    {
+        return NULL;
+    }    
+}
+
+const char *ne_sock_error(const ne_socket *sock)
+{
+    return sock->error;
+}
+
+void ne_sock_set_error(ne_socket *sock, const char *format, ...)
+{
+    va_list params;
+
+    va_start(params, format);
+    ne_vsnprintf(sock->error, sizeof sock->error, format, params);
+    va_end(params);
+}
+
+int ne_sock_close(ne_socket *sock)
+{
+    int ret;
+
+    /* Per API description - for an SSL connection, simply send the
+     * close_notify but do not wait for the peer's response. */
+#if defined(HAVE_OPENSSL)
+    if (sock->ssl) {
+        SSL_shutdown(sock->ssl);
+	SSL_free(sock->ssl);
+    }
+#elif defined(HAVE_GNUTLS)
+    if (sock->ssl) {
+        do {
+            ret = gnutls_bye(sock->ssl, GNUTLS_SHUT_WR);
+        } while (ret < 0
+                 && (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN));
+        gnutls_deinit(sock->ssl);
+    }
+#endif
+
+    if (sock->fd < 0)
+        ret = 0;
+    else
+        ret = ne_close(sock->fd);
+    ne_free(sock);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_socket.h b/net/mmt/neon/src/ne_socket.h
new file mode 100644
index 0000000..22b203d
--- /dev/null
+++ b/net/mmt/neon/src/ne_socket.h
@@ -0,0 +1,311 @@
+/* 
+   socket handling interface
+   Copyright (C) 1999-2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SOCKET_H
+#define NE_SOCKET_H
+
+#include <sys/types.h>
+
+#ifdef WIN32
+#include <stdlib.h> /* for size_t */
+#endif
+
+#include "ne_defs.h"
+#include "ne_ssl.h" /* for ne_ssl_context */
+
+NE_BEGIN_DECLS
+
+#define NE_SOCK_ERROR (-1)
+/* Read/Write timed out */
+#define NE_SOCK_TIMEOUT (-2)
+/* Socket was closed */
+#define NE_SOCK_CLOSED (-3)
+/* Connection was reset (e.g. server crashed) */
+#define NE_SOCK_RESET (-4)
+/* Secure connection was closed without proper SSL shutdown. */
+#define NE_SOCK_TRUNC (-5)
+
+/* ne_socket represents a TCP socket. */
+typedef struct ne_socket_s ne_socket;
+
+/* ne_sock_addr represents an address object. */
+typedef struct ne_sock_addr_s ne_sock_addr;
+
+#ifndef NE_INET_ADDR_DEFINED
+typedef struct ne_inet_addr_s ne_inet_addr;
+#endif
+
+/* Perform process-global initialization of any libraries in use.
+ * Returns non-zero on error. */
+int ne_sock_init(void);
+
+/* Perform process-global shutdown of any libraries in use.  This
+ * function only has effect when it has been called an equal number of
+ * times to ne_sock_init() for the process. */
+void ne_sock_exit(void);
+
+#define NE_ADDR_CANON (0x01)
+/* Resolve the given hostname. Hex string IPv6 addresses (e.g. `::1')
+ * may be enclosed in brackets (e.g. `[::1]').  'flags' should be
+ * zero, or if NE_ADDR_CANON is passed, the canonical name for the
+ * hostname will be determind. */
+ne_sock_addr *ne_addr_resolve(const char *hostname, int flags);
+
+/* Returns zero if name resolution was successful, non-zero on
+ * error. */
+int ne_addr_result(const ne_sock_addr *addr);
+
+/* Returns the first network address associated with the 'addr'
+ * object.  Undefined behaviour if ne_addr_result returns non-zero for
+ * 'addr'; otherwise, never returns NULL.  */
+const ne_inet_addr *ne_addr_first(ne_sock_addr *addr);
+
+/* Returns the next network address associated with the 'addr' object,
+ * or NULL if there are no more. */
+const ne_inet_addr *ne_addr_next(ne_sock_addr *addr);
+
+/* NB: the pointers returned by ne_addr_first and ne_addr_next are
+ * valid until ne_addr_destroy is called for the corresponding
+ * ne_sock_addr object.  They must not be passed to ne_iaddr_free. */
+
+/* If name resolution fails, copies the error string into 'buffer',
+ * which is of size 'bufsiz'.  'buffer' is returned. */
+char *ne_addr_error(const ne_sock_addr *addr, char *buffer, size_t bufsiz);
+
+/* Returns the canonical name of the host as a NUL-terminated string,
+ * if NE_ADDR_CANON was used, and name resolution was successful.
+ * Otherwise, returns NULL. */
+const char *ne_addr_canonical(const ne_sock_addr *addr);
+
+/* Destroys an address object created by ne_addr_resolve. */
+void ne_addr_destroy(ne_sock_addr *addr);
+
+/* Network address type; IPv4 or IPv6 */
+typedef enum {
+    ne_iaddr_ipv4 = 0,
+    ne_iaddr_ipv6
+} ne_iaddr_type;
+
+/* Create a network address object from raw byte representation (in
+ * network byte order) of given type.  'raw' must be four bytes for an
+ * IPv4 address, 16 bytes for an IPv6 address.  May return NULL if
+ * address type is not supported. */
+ne_inet_addr *ne_iaddr_make(ne_iaddr_type type, const unsigned char *raw);
+
+/* Compare two network address objects i1 and i2; returns zero if they
+ * are equivalent or non-zero otherwise.  */
+int ne_iaddr_cmp(const ne_inet_addr *i1, const ne_inet_addr *i2);
+
+/* Return the type of the given network address object. */
+ne_iaddr_type ne_iaddr_typeof(const ne_inet_addr *ia);
+
+/* Print the string representation of network address 'ia' into the
+ * buffer 'buffer', which is of length 'bufsiz'.  Returns 'buffer'. */
+char *ne_iaddr_print(const ne_inet_addr *ia, char *buffer, size_t bufsiz);
+
+/* Dump the raw byte representation (in network byte order) of address
+ * 'ia' into the buffer 'buffer', which must be of a suitable length
+ * (4 bytes for an IPv4 address, 16 bytes for an IPv6 address).
+ * Returns 'buffer'. */
+unsigned char *ne_iaddr_raw(const ne_inet_addr *ia, unsigned char *buffer);
+
+/* Perform the reverse name lookup on network address 'ia', placing
+ * the returned name in the 'buf' buffer (of length 'bufsiz') if
+ * successful.  Returns zero on success, or non-zero on error. */
+int ne_iaddr_reverse(const ne_inet_addr *ia, char *buf, size_t bufsiz);
+
+/* Convert network address string 'addr' (for example, "127.0.0.1")
+ * into a network address object.  Returns NULL on parse error.  If
+ * non-NULL, return value must be freed using ne_iaddr_free. */
+ne_inet_addr *ne_iaddr_parse(const char *addr, ne_iaddr_type type);
+
+/* Destroy a network address object created using ne_iaddr_make or
+ * ne_iaddr_parse. */
+void ne_iaddr_free(ne_inet_addr *addr);
+
+/* Create a socket object; returns NULL on error. */
+ne_socket *ne_sock_create(void);
+
+/* Specify an address to which the local end of the socket will be
+ * bound during a subsequent ne_sock_connect() call.  If the address
+ * passed to ne_sock_connect() is of a different type (family) to
+ * 'addr', 'addr' is ignored.  Either 'addr' may be NULL, to use the
+ * given port with unspecified address, or 'port' may be 0, to use the
+ * given address with an unspecified port.
+ *
+ * (Note: This function is not equivalent to a BSD socket bind(), it
+ * only takes effect during the _connect() call). */
+void ne_sock_prebind(ne_socket *sock, const ne_inet_addr *addr,
+                     unsigned int port);
+
+/* Connect the socket to server at address 'addr' on port 'port'.
+ * Returns zero on success, NE_SOCK_TIMEOUT if a timeout occurs when a
+ * non-zero connect timeout is configured (and is supported), or
+ * NE_SOCK_ERROR on failure.  */
+int ne_sock_connect(ne_socket *sock, const ne_inet_addr *addr, 
+                    unsigned int port);
+
+/* Read up to 'count' bytes from socket into 'buffer'.  Returns:
+ *   NE_SOCK_* on error,
+ *   >0 length of data read into buffer (may be less than 'count')
+ */
+ssize_t ne_sock_read(ne_socket *sock, char *buffer, size_t count);
+
+/* Read up to 'count' bytes into 'buffer', leaving the data available
+ * in the socket buffer to be returned by a subsequent call to
+ * ne_sock_read or ne_sock_peek. Returns:
+ *   NE_SOCK_* on error,
+ *   >0 length of data read into buffer.
+ */
+ssize_t ne_sock_peek(ne_socket *sock, char *buffer, size_t count);
+
+/* Block for up to 'n' seconds until data becomes available for reading
+ * from the socket. Returns:
+ *  NE_SOCK_* on error,
+ *  NE_SOCK_TIMEOUT if no data arrives in 'n' seconds,
+ *  0 if data arrived on the socket.
+ */
+int ne_sock_block(ne_socket *sock, int n);
+
+/* Write 'count' bytes of 'data' to the socket.  Guarantees to either
+ * write all the bytes or to fail.  Returns 0 on success, or NE_SOCK_*
+ * on error. */
+int ne_sock_fullwrite(ne_socket *sock, const char *data, size_t count); 
+
+/* I/O vector. */
+struct ne_iovec {
+    void *base;
+    size_t len;
+};
+
+/* Writes 'count' blocks described by 'vector' to the socket.
+ * Guarantees to either write all the bytes or to fail.  Count must be
+ * greater than zero and smaller than the system-defined maximum
+ * vector limit.  Returns 0 on success, or NE_SOCK_* on error. */
+int ne_sock_fullwritev(ne_socket *sock, const struct ne_iovec *vector,
+                       int count); 
+
+/* Read an LF-terminated line into 'buffer', and NUL-terminate it.
+ * At most 'len' bytes are read (including the NUL terminator).
+ * Returns:
+ * NE_SOCK_* on error,
+ * >0 number of bytes read (including NUL terminator)
+ */
+ssize_t ne_sock_readline(ne_socket *sock, char *buffer, size_t len);
+
+/* Read exactly 'len' bytes into buffer, or fail; returns 0 on
+ * success, NE_SOCK_* on error. */
+ssize_t ne_sock_fullread(ne_socket *sock, char *buffer, size_t len);
+
+/* Accepts a connection from listening socket 'fd' and places the
+ * socket in 'sock'.  Returns zero on success or -1 on failure. */
+int ne_sock_accept(ne_socket *sock, int fd);
+
+/* Returns the file descriptor used for socket 'sock'. */
+int ne_sock_fd(const ne_socket *sock);
+
+/* Return address of peer, or NULL on error.  The returned address
+ * must be destroyed by caller using ne_iaddr_free. */
+ne_inet_addr *ne_sock_peer(ne_socket *sock, unsigned int *port);
+
+/* Close the socket and destroy the socket object.  If SSL is in use
+ * for the socket, a closure alert is sent to initiate a clean
+ * shutdown, but this function does not wait for the peer's response.
+ * Returns zero on success, or non-zero on failure. */
+int ne_sock_close(ne_socket *sock);
+
+/* Return current error string for socket. */
+const char *ne_sock_error(const ne_socket *sock);
+
+/* Set the error string for the socket; takes printf-like format
+ * string. */
+void ne_sock_set_error(ne_socket *sock, const char *format, ...)
+    ne_attribute((format (printf, 2, 3)));
+
+/* Set read timeout for socket, in seconds; must be a non-zero
+ * positive integer. */
+void ne_sock_read_timeout(ne_socket *sock, int timeout);
+
+/* Set connect timeout for socket, in seconds; must be a positive
+ * integer.  If a timeout of 'zero' is used then then no explicit
+ * timeout handling will be used for ne_sock_connect(), and the
+ * connect call will only timeout as dictated by the TCP stack. */
+void ne_sock_connect_timeout(ne_socket *sock, int timeout);
+
+/* Negotiate an SSL connection on socket as an SSL server, using given
+ * SSL context. */
+int ne_sock_accept_ssl(ne_socket *sock, ne_ssl_context *ctx);
+
+/* Negotiate an SSL connection on socket as an SSL client, using given
+ * SSL context.  The 'userdata' parameter is associated with the
+ * underlying SSL library's socket structure for use in callbacks.
+ * Returns zero on success, or non-zero on error. */
+int ne_sock_connect_ssl(ne_socket *sock, ne_ssl_context *ctx,
+                        void *userdata);
+
+/* Retrieve the session ID of the current SSL session.  If 'buf' is
+ * non-NULL, on success, copies at most *buflen bytes to 'buf' and
+ * sets *buflen to the exact number of bytes copied.  If 'buf' is
+ * NULL, on success, sets *buflen to the length of the session ID.
+ * Returns zero on success, non-zero on error. */
+int ne_sock_sessid(ne_socket *sock, unsigned char *buf, size_t *buflen);
+
+/* Return human-readable name of SSL/TLS cipher used for connection,
+ * or NULL if none.  The format of this string is not intended to be
+ * fixed or parseable, but is informational only.  Return value is
+ * NUL-terminated malloc-allocated string if not NULL, which must be
+ * freed by the caller. */
+char *ne_sock_cipher(ne_socket *sock);
+
+/* SOCKS proxy protocol version: */
+enum ne_sock_sversion {
+    NE_SOCK_SOCKSV4 = 0,
+    NE_SOCK_SOCKSV4A,
+    NE_SOCK_SOCKSV5
+};
+
+/* Given a socket 'sock' which is connected to a SOCKS proxy, initiate
+ * a connection to a destination server using that proxy, specified
+ * either by network address or hostname, at given port 'port'.
+ *
+ * If 'vers' is NE_SOCKS_V4, addr must be an IPv4 address; hostname
+ * and password are ignored; username must be non-NULL.
+ *
+ * If 'vers' is NE_SOCKS_V4A, hostname must be non-NULL; addr is
+ * ignored; password is ignored; username must be non-NULL.
+ *
+ * If 'vers' is NE_SOCKS_V5, addr may be NULL, in which case hostname
+ * must be non-NULL.  addr if non-NULL may be an IPv4 or IPv6 address;
+ * username may be NULL, in which case password is ignored.  If
+ * username is non-NULL password must also be non-NULL.
+ *
+ * Returns 0 on success, or NE_SOCK_* on failure - in which case, the
+ * socket error string is set.  On failure, the socket must be closed
+ * by the caller.
+ */
+int ne_sock_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                  const ne_inet_addr *addr, const char *hostname, 
+                  unsigned int port,
+                  const char *username, const char *password);
+
+NE_END_DECLS
+
+#endif /* NE_SOCKET_H */
diff --git a/net/mmt/neon/src/ne_socks.c b/net/mmt/neon/src/ne_socks.c
new file mode 100644
index 0000000..73d9f04
--- /dev/null
+++ b/net/mmt/neon/src/ne_socks.c
@@ -0,0 +1,354 @@
+/*
+   SOCKS proxy support for neon
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include "ne_internal.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_utils.h"
+
+#include <string.h>
+
+/* SOCKS protocol reference:
+   v4:  http://www.ufasoft.com/doc/socks4_protocol.htm
+   v4a  http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol
+   v5:  http://tools.ietf.org/html/rfc1928
+   ...v5 auth: http://tools.ietf.org/html/rfc1929
+*/
+
+#define V5_REPLY_OK 0
+#define V5_REPLY_FAIL 1
+#define V5_REPLY_DISALLOW 2
+#define V5_REPLY_NET_UNREACH 3
+#define V5_REPLY_HOST_UNREACH 4
+#define V5_REPLY_CONN_REFUSED 5
+#define V5_REPLY_TTL_EXPIRED 6
+#define V5_REPLY_CMD_UNSUPPORTED 7
+#define V5_REPLY_TYPE_UNSUPPORTED 8
+
+#define V5_VERSION   0x05
+#define V5_ADDR_IPV4 0x01
+#define V5_ADDR_FQDN 0x03
+#define V5_ADDR_IPV6 0x04
+
+#define V5_CMD_CONNECT 0x01
+
+#define V5_AUTH_NONE   0x00
+#define V5_AUTH_USER   0x02
+#define V5_AUTH_NOMETH 0xFF
+
+/* Fail with given V5 error code in given context. */
+static int v5fail(ne_socket *sock, unsigned int code, const char *context)
+{
+    const char *err;
+
+    switch (code) {
+    case V5_REPLY_FAIL:
+        err = _("failure");
+        break;
+    case V5_REPLY_DISALLOW:
+        err = _("connection not permitted"); 
+        break;
+    case V5_REPLY_NET_UNREACH:
+        err = _("network unreachable");
+        break;
+    case V5_REPLY_HOST_UNREACH: 
+        err = _("host unreachable");
+        break;
+    case V5_REPLY_TTL_EXPIRED:
+        err = _("TTL expired");
+        break;
+    case V5_REPLY_CMD_UNSUPPORTED:
+        err = _("command not supported");
+        break;
+    case V5_REPLY_TYPE_UNSUPPORTED: 
+        err = _("address type not supported");
+        break;
+    default:
+        ne_sock_set_error(sock, _("%s: unrecognized error (%u)"), context, code);
+        return NE_SOCK_ERROR;
+    }
+    
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    return NE_SOCK_ERROR;
+}
+
+/* Fail with given error string. */
+static int fail(ne_socket *sock, const char *error)
+{
+    ne_sock_set_error(sock, "%s", error);
+    return NE_SOCK_ERROR;
+}
+
+/* Fail with given NE_SOCK_* error code and given context. */
+static int sofail(ne_socket *sock, ssize_t ret, const char *context)
+{
+    char *err = ne_strdup(ne_sock_error(sock));
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    ne_free(err);
+    return NE_SOCK_ERROR;
+}
+
+/* SOCKSv5 proxy. */
+static int v5_proxy(ne_socket *sock, const ne_inet_addr *addr,
+                    const char *hostname, unsigned int port,
+                    const char *username, const char *password)
+{
+    unsigned char msg[1024], *p;
+    unsigned int len;
+    int ret;
+    ssize_t n;
+
+    p = msg;
+    *p++ = V5_VERSION;
+    *p++ = 2; /* Two supported auth protocols; none and user. */
+    *p++ = V5_AUTH_NONE;
+    *p++ = V5_AUTH_USER;
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send message to proxy"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 2);
+    if (n) {
+        return sofail(sock, ret, _("Could not read initial response from proxy"));
+    }
+    else if (msg[0] != V5_VERSION) {
+        return fail(sock, _("Invalid version in proxy response"));
+    }
+    
+    /* Authenticate, if necessary. */
+    switch (msg[1]) {
+    case V5_AUTH_NONE:
+        break;
+    case V5_AUTH_USER:
+        p = msg;
+        *p++ = 0x01;
+        len = strlen(username) & 0xff;
+        *p++ = len;
+        memcpy(p, username, len);
+        p += len;
+        len = strlen(password) & 0xff;
+        *p++ = len;
+        memcpy(p, password, len);
+        p += len;
+
+        ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+        if (ret) {
+            return sofail(sock, ret, _("Could not send login message"));
+        }
+        
+        n = ne_sock_fullread(sock, (char *)msg, 2);
+        if (n) {
+            return sofail(sock, ret, _("Could not read login reply"));
+        }
+        else if (msg[0] != 1) {
+            return fail(sock, _("Invalid version in login reply"));
+        }
+        else if (msg[1] != 0) {
+            return fail(sock, _("Authentication failed"));
+        }
+        break;
+    case V5_AUTH_NOMETH:
+        return fail(sock, _("No acceptable authentication method"));
+    default:
+        return fail(sock, _("Unexpected authentication method chosen"));
+    }
+    
+    /* Send the CONNECT command. */
+    p = msg;
+    *p++ = V5_VERSION;
+    *p++ = V5_CMD_CONNECT;
+    *p++ = 0; /* reserved */
+    if (addr) {
+        unsigned char raw[16];
+
+        if (ne_iaddr_typeof(addr) == ne_iaddr_ipv4) {
+            len = 4;
+            *p++ = V5_ADDR_IPV4;
+        }
+        else {
+            len = 16;
+            *p++ = V5_ADDR_IPV6;
+        }
+        
+        memcpy(p, ne_iaddr_raw(addr, raw), len);
+        p += len;
+    }
+    else {
+        len = strlen(hostname) & 0xff;
+        *p++ = V5_ADDR_FQDN;
+        *p++ = len;
+        memcpy(p, hostname, len);
+        p += len;
+    }
+
+    *p++ = (port >> 8) & 0xff;
+    *p++ = port & 0xff;
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send connect request"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 4);
+    if (n) {
+        return sofail(sock, n, _("Could not read connect reply"));
+    }
+    if (msg[0] != V5_VERSION) {
+        return fail(sock, _("Invalid version in connect reply"));
+    }
+    if (msg[1] != V5_REPLY_OK) {
+        return v5fail(sock, msg[1], _("Could not connect"));
+    }
+    
+    switch (msg[3]) {
+    case V5_ADDR_IPV4:
+        len = 4;
+        break;
+    case V5_ADDR_IPV6:
+        len = 16;
+        break;
+    case V5_ADDR_FQDN:
+        n = ne_sock_read(sock, (char *)msg, 1);
+        if (n != 1) {
+            return sofail(sock, n, 
+                            _("Could not read FQDN length in connect reply"));
+        }
+        len = msg[0];
+        break;
+    default:
+        return fail(sock, _("Unknown address type in connect reply"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, len + 2);
+    if (n) {
+        return sofail(sock, n, _("Could not read address in connect reply"));
+    }
+
+    return 0;
+}
+
+#define V4_VERSION 0x04
+#define V4_CMD_STREAM 0x01
+
+#define V4_REP_OK      0x5a /* request granted */
+#define V4_REP_FAIL    0x5b /* request rejected or failed */
+#define V4_REP_NOIDENT 0x5c /* request failed, could connect to identd */
+#define V4_REP_IDFAIL  0x5d /* request failed, identd denial */
+
+/* Fail for given SOCKSv4 error code. */
+static int v4fail(ne_socket *sock, unsigned int code, const char *context)
+{
+    const char *err;
+
+    switch (code) {
+    case V4_REP_FAIL:
+        err = _("request rejected or failed");
+        break;
+    case V4_REP_NOIDENT:
+        err = _("could not establish connection to identd");
+        break;
+    case V4_REP_IDFAIL:
+        err = _("rejected due to identd user mismatch");
+        break;
+    default:
+        ne_sock_set_error(sock, _("%s: unrecognized failure (%u)"),
+                          context, code);
+        return NE_SOCK_ERROR;
+    }
+    
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    return NE_SOCK_ERROR;
+}
+
+/* SOCKS v4 or v4A proxy. */
+static int v4_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                    const ne_inet_addr *addr, const char *hostname, 
+                    unsigned int port, const char *username)
+{
+    unsigned char msg[1024], raw[16], *p;
+    ssize_t n;
+    int ret;
+
+    p = msg;
+    *p++ = V4_VERSION;
+    *p++ = V4_CMD_STREAM;
+    *p++ = (port >> 8) & 0xff;
+    *p++ = port & 0xff;
+
+    if (vers == NE_SOCK_SOCKSV4A) {
+        /* A bogus address is used to signify use of the hostname,
+         * 0.0.0.X where X != 0. */
+        memcpy(p, "\x00\x00\x00\xff", 4);
+    } 
+    else {
+        /* API precondition that addr is IPv4; if it's not this will
+         * just copy out the first four bytes of the v6 address;
+         * garbage in => garbage out. */
+        memcpy(p, ne_iaddr_raw(addr, raw), 4);
+    }
+    p += 4;
+
+    if (username) {
+        unsigned int len = strlen(username) & 0xff;
+        memcpy(p, username, len);
+        p += len;
+    }
+    *p++ = '\0';
+    
+    if (vers == NE_SOCK_SOCKSV4A) {
+        unsigned int len = strlen(hostname) & 0xff;
+        memcpy(p, hostname, len);
+        p += len;
+        *p++ = '\0';
+    }    
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send message to proxy"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 8);
+    if (n) {
+        return sofail(sock, ret, _("Could not read response from proxy"));
+    }
+    
+    if (msg[1] != V4_REP_OK) {
+        return v4fail(sock, ret, _("Could not connect"));
+    }
+
+    return 0;
+}
+
+int ne_sock_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                  const ne_inet_addr *addr, const char *hostname, 
+                  unsigned int port,
+                  const char *username, const char *password)
+{
+    if (vers == NE_SOCK_SOCKSV5) {
+        return v5_proxy(sock, addr, hostname, port, username, password);
+    }
+    else {
+        return v4_proxy(sock, vers, addr, hostname, port, username);
+    }
+}
diff --git a/net/mmt/neon/src/ne_ssl.h b/net/mmt/neon/src/ne_ssl.h
new file mode 100644
index 0000000..685b2c9
--- /dev/null
+++ b/net/mmt/neon/src/ne_ssl.h
@@ -0,0 +1,201 @@
+/* 
+   SSL/TLS abstraction layer for neon
+   Copyright (C) 2003-2006, 2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* ne_ssl.h defines an interface for loading and accessing the
+ * properties of SSL certificates. */
+
+#ifndef NE_SSL_H
+#define NE_SSL_H 1
+
+#include <sys/types.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* A "distinguished name"; a unique name for some entity. */
+typedef struct ne_ssl_dname_s ne_ssl_dname;
+
+/* Returns a single-line string representation of a distinguished
+ * name, intended to be human-readable (e.g. "Acme Ltd., Norfolk,
+ * GB").  Return value is a UTF-8-encoded malloc-allocated string and
+ * must be free'd by the caller. */
+char *ne_ssl_readable_dname(const ne_ssl_dname *dn);
+
+/* Returns zero if 'dn1' and 'dn2' refer to same name, or non-zero if
+ * they are different. */
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2);
+
+/* An SSL certificate. */
+typedef struct ne_ssl_certificate_s ne_ssl_certificate;
+
+/* Read a certificate from a file in PEM format; returns NULL if the
+ * certificate could not be parsed. */
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename);
+
+/* Write a certificate to a file in PEM format; returns non-zero if
+ * the certificate could not be written. */
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename);
+
+/* Export a certificate to a base64-encoded, NUL-terminated string.
+ * The returned string is malloc-allocated and must be free()d by the
+ * caller. */
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert);
+
+/* Import a certificate from a base64-encoded string as returned by
+ * ne_ssl_cert_export(). Returns a certificate object or NULL if
+ * 'data' was not valid. */
+ne_ssl_certificate *ne_ssl_cert_import(const char *data);
+
+/* Returns the identity of the certificate, or NULL if none is given.
+ * For a server certificate this will be the hostname of the server to
+ * which the cert was issued.  A NUL-terminated UTF-8-encoded string
+ * is returned, which is valid for the lifetime of the certificate
+ * object. */
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert);
+
+/* Return the certificate of the entity which signed certificate
+ * 'cert'.  Returns NULL if 'cert' is self-signed or the issuer
+ * certificate is not available; if non-NULL, the pointer is valid for
+ * the lifetime of the certificate object. */
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert);
+
+/* Returns the distinguished name of the certificate issuer. */
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert);
+
+/* Returns the distinguished name of the certificate subject. */
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert);
+
+#define NE_SSL_DIGESTLEN (60)
+
+/* Calculate the certificate digest ("fingerprint") and format it as a
+ * NUL-terminated hex string in 'digest', of the form "aa:bb:...:ff".
+ * Returns zero on success or non-zero if there was an internal error
+ * whilst calculating the digest.  'digest' must be at least 
+ * NE_SSL_DIGESTLEN bytes in length. */
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest);
+
+/* Copy the validity times for the certificate 'cert' into 'from' and
+ * 'until' (either may be NULL).  If the time cannot be represented by
+ * a time_t value, then (time_t)-1 will be written. */
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until);
+
+#define NE_SSL_VDATELEN (30)
+/* Copy the validity times into buffers 'from' and 'until' as
+ * NUL-terminated human-readable strings, using RFC 1123-style date
+ * formatting (and not localized, so always using English month/week
+ * names).  The buffers must be at least NE_SSL_VDATELEN bytes in
+ * length, and either may be NULL. */
+void ne_ssl_cert_validity(const ne_ssl_certificate *cert,
+                          char *from, char *until);
+
+/* Returns zero if 'c1' and 'c2' refer to the same certificate, or
+ * non-zero otherwise. */
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1,
+                    const ne_ssl_certificate *c2);
+
+/* Deallocate memory associated with certificate. */
+void ne_ssl_cert_free(ne_ssl_certificate *cert);
+
+/* A client certificate (and private key).  A client certificate
+ * object has state; the object is either in the "encrypted" or
+ * "decrypted" state.  */
+typedef struct ne_ssl_client_cert_s ne_ssl_client_cert;
+
+/* Read a client certificate (and private key) in PKCS#12 format from
+ * file 'filename'; returns NULL if the file could not be parsed, or
+ * otherwise returning a client certificate object.  The returned
+ * object may be in either the encrypted or decrypted state. */
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename);
+
+/* Read a client certificate (and private key) in PKCS#12 format from
+ * 'buffer', of length 'buflen', returning NULL if the certificate
+ * could not be parsed, or otherwise returning a client certificate
+ * object.  The returned object may be in either the encrypted or
+ * decrypted state. */
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, 
+                                          size_t buflen);
+
+/* Returns non-zero if client cert is in the encrypted state. */
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *ccert);
+
+/* Returns the "friendly name" given for the client cert, or NULL if
+ * none given.  Returns a NUL-terminated, UTF-8-encoded string.  This
+ * function may be used on a ccert object in either encrypted or
+ * decrypted state. */
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert);
+
+/* Decrypt the encrypted client cert using the given password.
+ * Returns non-zero on failure, in which case, the ccert object
+ * remains in the encrypted state and the function may be called again
+ * with a different password.  This function has undefined behaviour
+ * for a ccert object which is in the decrypted state. */
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *ccert, const char *password);
+
+/* Return the actual certificate part of the client certificate (never
+ * returns NULL).  This function has undefined behaviour for a ccert
+ * object which is in the encrypted state. */
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *ccert);
+
+/* Destroy a client certificate object.  This function may be used on
+ * a ccert object in either the encrypted or decrypted state. */
+void ne_ssl_clicert_free(ne_ssl_client_cert *ccert);
+
+
+/* SSL context object.  The interfaces to manipulate an SSL context
+ * are only needed when interfacing directly with ne_socket.h. */
+typedef struct ne_ssl_context_s ne_ssl_context;
+
+/* Context creation modes: */
+#define NE_SSL_CTX_CLIENT (0) /* client context */
+#define NE_SSL_CTX_SERVER (1) /* default server context */
+#define NE_SSL_CTX_SERVERv2 (2) /* SSLv2-specific server context */
+
+/* Create an SSL context. */
+ne_ssl_context *ne_ssl_context_create(int mode);
+
+/* Client mode: trust the given certificate 'cert' in context 'ctx'. */
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert);
+
+/* Server mode: use given cert and key (filenames to PEM certificates). */
+int ne_ssl_context_keypair(ne_ssl_context *ctx,
+                           const char *cert, const char *key);
+
+/* Server mode: set client cert verification options: required is non-zero if 
+ * a client cert is required, if ca_names is non-NULL it is a filename containing
+ * a set of PEM certs from which CA names are sent in the ccert request. */
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, int required,
+                              const char *ca_names, const char *verify_cas);
+
+#define NE_SSL_CTX_SSLv2 (0)
+/* Set a flag for the SSL context. */
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value);
+
+/* Return flag value. */
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag);
+
+/* Destroy an SSL context. */
+void ne_ssl_context_destroy(ne_ssl_context *ctx);
+
+NE_END_DECLS
+
+#endif
diff --git a/net/mmt/neon/src/ne_sspi.c b/net/mmt/neon/src/ne_sspi.c
new file mode 100644
index 0000000..9b40df7
--- /dev/null
+++ b/net/mmt/neon/src/ne_sspi.c
@@ -0,0 +1,606 @@
+/* 
+   Microsoft SSPI based authentication routines
+   Copyright (C) 2004-2005, Vladimir Berezniker @ http://public.xdi.org/=vmpn
+   Copyright (C) 2007, Yves Martin  <ymartin59@free.fr>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include "ne_utils.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_sspi.h"
+
+#ifdef HAVE_SSPI
+
+#define SEC_SUCCESS(Status) ((Status) >= 0)
+
+#ifndef SECURITY_ENTRYPOINT   /* Missing in MingW 3.7 */
+#define SECURITY_ENTRYPOINT "InitSecurityInterfaceA"
+#endif
+
+struct SSPIContextStruct {
+    CtxtHandle context;
+    char *serverName;
+    CredHandle credentials;
+    int continueNeeded;
+    int authfinished;
+    char *mechanism;
+    int ntlm;
+    ULONG maxTokenSize;
+};
+
+typedef struct SSPIContextStruct SSPIContext;
+
+static ULONG negotiateMaxTokenSize = 0;
+static ULONG ntlmMaxTokenSize = 0;
+static HINSTANCE hSecDll = NULL;
+static PSecurityFunctionTable pSFT = NULL;
+static int initialized = 0;
+
+/*
+ * Query specified package for it's maximum token size.
+ */
+static int getMaxTokenSize(char *package, ULONG * maxTokenSize)
+{
+    SECURITY_STATUS status;
+    SecPkgInfo *packageSecurityInfo = NULL;
+
+    status = pSFT->QuerySecurityPackageInfo(package, &packageSecurityInfo);
+    if (status == SEC_E_OK) {
+        *maxTokenSize = packageSecurityInfo->cbMaxToken;
+        if (pSFT->FreeContextBuffer(packageSecurityInfo) != SEC_E_OK) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unable to free security package info.");
+        }
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: QuerySecurityPackageInfo [failed] [%x].", status);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Initialize all the SSPI data
+ */
+static void initDll(HINSTANCE hSecDll)
+{
+    INIT_SECURITY_INTERFACE initSecurityInterface = NULL;
+
+    initSecurityInterface =
+        (INIT_SECURITY_INTERFACE) GetProcAddress(hSecDll,
+                                                 SECURITY_ENTRYPOINT);
+
+    if (initSecurityInterface == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Obtaining security interface [fail].\n");
+        initialized = -1;
+        return;
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Obtaining security interface [ok].\n");
+    }
+
+    pSFT = (initSecurityInterface) ();
+
+    if (pSFT == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Security Function Table [fail].\n");
+        initialized = -2;
+        return;
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Security Function Table [ok].\n");
+    }
+
+    if (getMaxTokenSize("Negotiate", &negotiateMaxTokenSize)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to get negotiate maximum packet size");
+        initialized = -3;
+    }
+
+    if (getMaxTokenSize("NTLM", &ntlmMaxTokenSize)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to get negotiate maximum packet size");
+        initialized = -3;
+    }
+}
+
+/*
+ * This function needs to be called at least once before using any other.
+ */
+int ne_sspi_init(void)
+{
+    if (initialized) {
+        return 0;
+    }
+
+    NE_DEBUG(NE_DBG_SOCKET, "sspiInit\n");
+    NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading security dll.\n");
+    hSecDll = LoadLibrary("security.dll");
+
+    if (hSecDll == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading of security dll [fail].\n");
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading of security dll [ok].\n");
+        initDll(hSecDll);
+        if (initialized == 0) {
+            initialized = 1;
+        }
+    }
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: sspiInit [%d].\n", initialized);
+    if (initialized < 0) {
+        return initialized;
+    } else {
+        return 0;
+    }
+}
+
+/*
+ * This function can be called to free resources used by SSPI.
+ */
+int ne_sspi_deinit(void)
+{
+    NE_DEBUG(NE_DBG_SOCKET, "sspi: DeInit\n");
+    if (initialized <= 0) {
+        return initialized;
+    }
+
+    pSFT = NULL;
+
+    if (hSecDll != NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Unloading security dll.\n");
+        if (FreeLibrary(hSecDll)) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unloading of security dll [ok].\n");
+        } else {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unloading of security dll [fail].\n");
+            return -1;
+        }
+        hSecDll = NULL;
+    }
+
+    initialized = 0;
+    return 0;
+}
+
+/*
+ * Simplification wrapper arround AcquireCredentialsHandle as most of
+ * the parameters do not change.
+ */
+static int acquireCredentialsHandle(CredHandle * credentials, char *package)
+{
+    SECURITY_STATUS status;
+    TimeStamp timestamp;
+
+    status =
+        pSFT->AcquireCredentialsHandle(NULL, package, SECPKG_CRED_OUTBOUND,
+                                       NULL, NULL, NULL, NULL, credentials,
+                                       &timestamp);
+
+    if (status != SEC_E_OK) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: AcquireCredentialsHandle [fail] [%x].\n", status);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Wrapper arround initializeSecurityContext.  Supplies several
+ * default parameters as well as logging in case of errors.
+ */
+static SECURITY_STATUS
+initializeSecurityContext(CredHandle * credentials, CtxtHandle * context,
+                          char *spn, ULONG contextReq,
+                          SecBufferDesc * inBuffer, CtxtHandle * newContext,
+                          SecBufferDesc * outBuffer)
+{
+    ULONG contextAttributes;
+    SECURITY_STATUS status;
+
+    status =
+        pSFT->InitializeSecurityContext(credentials, context, spn, contextReq,
+                                        0, SECURITY_NETWORK_DREP, inBuffer, 0,
+                                        newContext, outBuffer,
+                                        &contextAttributes, NULL);
+
+    if (!SEC_SUCCESS(status)) {
+        if (status == SEC_E_INVALID_TOKEN) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] SEC_E_INVALID_TOKEN.\n");
+        } else if (status == SEC_E_UNSUPPORTED_FUNCTION) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] SEC_E_UNSUPPORTED_FUNCTION.\n");
+        } else {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] [%x].\n", status);
+        }
+    }
+
+    return status;
+}
+
+/*
+ * Validates that the pointer is not NULL and converts it to its real type.
+ */
+static int getContext(void *context, SSPIContext **sspiContext)
+{
+    if (!context) {
+        return -1;
+    }
+
+    *sspiContext = context;
+    return 0;
+}
+
+/*
+ * Verifies that the buffer descriptor point only to one buffer and
+ * returns the pointer to it.
+ */
+static int getSingleBufferDescriptor(SecBufferDesc *secBufferDesc,
+                                     SecBuffer **secBuffer)
+{
+    if (secBufferDesc->cBuffers != 1) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: fillBufferDescriptor "
+                 "[fail] numbers of descriptor buffers. 1 != [%d].\n",
+                 secBufferDesc->cBuffers);
+        return -1;
+    }
+
+    *secBuffer = secBufferDesc->pBuffers;
+    return 0;
+}
+
+/*
+ * Decodes BASE64 string into SSPI SecBuffer
+ */
+static int base64ToBuffer(const char *token, SecBufferDesc * secBufferDesc)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    buffer->BufferType = SECBUFFER_TOKEN;
+    buffer->cbBuffer =
+        ne_unbase64(token, (unsigned char **) &buffer->pvBuffer);
+
+    if (buffer->cbBuffer == 0) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to decode BASE64 SSPI token.\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Creates a SecBuffer of a specified size.
+ */
+static int makeBuffer(SecBufferDesc * secBufferDesc, ULONG size)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    buffer->BufferType = SECBUFFER_TOKEN;
+    buffer->cbBuffer = size;
+    buffer->pvBuffer = ne_calloc(size);
+
+    return 0;
+}
+
+/*
+ * Frees data allocated in the buffer.
+ */
+static int freeBuffer(SecBufferDesc * secBufferDesc)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    if (buffer->cbBuffer > 0 && buffer->pvBuffer) {
+        ne_free(buffer->pvBuffer);
+        buffer->cbBuffer = 0;
+        buffer->pvBuffer = NULL;
+    }
+
+    return 0;
+}
+
+/*
+ * Canonicalize a server host name if possible.
+ * The returned pointer must be freed after usage.
+ */
+static char *canonical_hostname(const char *serverName)
+{
+    const char *hostname;
+    ne_sock_addr *addr;
+    
+    addr = ne_addr_resolve(serverName, NE_ADDR_CANON);
+    if (ne_addr_result(addr) || ne_addr_canonical(addr) == NULL) {
+        /* Lookup failed */
+        char buf[256];
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Could not resolve IP address for `%s': %s\n",
+                 serverName, ne_addr_error(addr, buf, sizeof buf));
+        hostname = ne_strdup(serverName);
+    }
+    else {
+        hostname = ne_strdup(ne_addr_canonical(addr));
+    }
+
+    ne_addr_destroy(addr);
+
+    return hostname;
+}
+
+/*
+ * Create a context to authenticate to specified server, using either
+ * ntlm or negotiate.
+ */
+int ne_sspi_create_context(void **context, char *serverName, int ntlm)
+{
+    SSPIContext *sspiContext;
+    char *canonicalName;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    sspiContext = ne_calloc(sizeof(SSPIContext));
+    sspiContext->continueNeeded = 0;
+
+    if (ntlm) {
+        sspiContext->mechanism = "NTLM";
+        sspiContext->serverName = ne_strdup(serverName);
+        sspiContext->maxTokenSize = ntlmMaxTokenSize;
+    } else {
+        sspiContext->mechanism = "Negotiate";
+        /* Canonicalize to conform to GSSAPI behavior */
+        canonicalName = canonical_hostname(serverName);
+        sspiContext->serverName = ne_concat("HTTP/", canonicalName, NULL);
+        ne_free(canonicalName);
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Created context with SPN '%s'\n",
+                 sspiContext->serverName);
+        sspiContext->maxTokenSize = negotiateMaxTokenSize;
+    }
+
+    sspiContext->ntlm = ntlm;
+    sspiContext->authfinished = 0;
+    *context = sspiContext;
+    return 0;
+}
+
+/*
+ * Resets the context
+ */
+static void resetContext(SSPIContext * sspiContext)
+{
+    pSFT->DeleteSecurityContext(&(sspiContext->context));
+#if defined(_MSC_VER) && _MSC_VER <= 1200
+    pSFT->FreeCredentialHandle(&(sspiContext->credentials));
+#else
+    pSFT->FreeCredentialsHandle(&(sspiContext->credentials));
+#endif
+    sspiContext->continueNeeded = 0;
+}
+
+/*
+ * Initializes supplied SecBufferDesc to point to supplied SecBuffer
+ * that is also initialized;
+ */
+static void
+initSingleEmptyBuffer(SecBufferDesc * bufferDesc, SecBuffer * buffer)
+{
+    buffer->BufferType = SECBUFFER_EMPTY;
+    buffer->cbBuffer = 0;
+    buffer->pvBuffer = NULL;
+
+    bufferDesc->cBuffers = 1;
+    bufferDesc->ulVersion = SECBUFFER_VERSION;
+    bufferDesc->pBuffers = buffer;
+
+}
+
+/*
+ * Destroyes the supplied context.
+ */
+int ne_sspi_destroy_context(void *context)
+{
+
+    int status;
+    SSPIContext *sspiContext;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+
+    resetContext(sspiContext);
+    if (sspiContext->serverName) {
+        ne_free(sspiContext->serverName);
+        sspiContext->serverName = NULL;
+    }
+
+    ne_free(sspiContext);
+    return 0;
+}
+int ne_sspi_clear_context(void *context)
+{
+    int status;
+    SSPIContext *sspiContext;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+    sspiContext->authfinished = 0;
+    sspiContext->continueNeeded = 0;
+    return 0;
+}
+/*
+ * Processes received authentication tokens as well as supplies the
+ * response token.
+ */
+int ne_sspi_authenticate(void *context, const char *base64Token, char **responseToken)
+{
+    SecBufferDesc outBufferDesc;
+    SecBuffer outBuffer;
+    int status;
+    SECURITY_STATUS securityStatus;
+    ULONG contextFlags;
+
+    SSPIContext *sspiContext;
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+
+    /* TODO: Not sure what flags should be set. joe: this needs to be
+     * driven by the ne_auth interface; the GSSAPI code needs similar
+     * flags. */
+    contextFlags = ISC_REQ_CONFIDENTIALITY | ISC_REQ_MUTUAL_AUTH;
+
+    initSingleEmptyBuffer(&outBufferDesc, &outBuffer);
+    status = makeBuffer(&outBufferDesc, sspiContext->maxTokenSize);
+    if (status) {
+        return status;
+    }
+
+    if (base64Token) {
+        SecBufferDesc inBufferDesc;
+        SecBuffer inBuffer;
+
+        if (!sspiContext->continueNeeded) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Got an unexpected token.\n");
+            return -1;
+        }
+
+        initSingleEmptyBuffer(&inBufferDesc, &inBuffer);
+
+        status = base64ToBuffer(base64Token, &inBufferDesc);
+        if (status) {
+            freeBuffer(&outBufferDesc);
+            return status;
+        }
+
+        securityStatus =
+            initializeSecurityContext(&sspiContext->credentials,
+                                      &(sspiContext->context),
+                                      sspiContext->serverName, contextFlags,
+                                      &inBufferDesc, &(sspiContext->context),
+                                      &outBufferDesc);
+        if (securityStatus == SEC_E_OK)
+        {
+            sspiContext->authfinished = 1;
+        }
+        freeBuffer(&inBufferDesc);
+    } else {
+        if (sspiContext->continueNeeded) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Expected a token from server.\n");
+            return -1;
+        }
+        if (sspiContext->authfinished && (sspiContext->credentials.dwLower || sspiContext->credentials.dwUpper)) {
+            if (sspiContext->authfinished)
+            {
+                freeBuffer(&outBufferDesc);
+                sspiContext->authfinished = 0;
+                NE_DEBUG(NE_DBG_HTTPAUTH,"sspi: failing because starting over from failed try.\n");
+                return -1;
+            }
+            sspiContext->authfinished = 0;
+        }
+
+        /* Reset any existing context since we are starting over */
+        resetContext(sspiContext);
+
+        if (acquireCredentialsHandle
+            (&sspiContext->credentials, sspiContext->mechanism) != SEC_E_OK) {
+                freeBuffer(&outBufferDesc);
+                NE_DEBUG(NE_DBG_HTTPAUTH,
+                    "sspi: acquireCredentialsHandle failed.\n");
+                return -1;
+        }
+
+        securityStatus =
+            initializeSecurityContext(&sspiContext->credentials, NULL,
+                                      sspiContext->serverName, contextFlags,
+                                      NULL, &(sspiContext->context),
+                                      &outBufferDesc);
+    }
+
+    if (securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+        || securityStatus == SEC_I_COMPLETE_NEEDED) {
+        SECURITY_STATUS compleStatus =
+            pSFT->CompleteAuthToken(&(sspiContext->context), &outBufferDesc);
+
+        if (compleStatus != SEC_E_OK) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: CompleteAuthToken failed.\n");
+            return -1;
+        }
+    }
+
+    if (securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+        || securityStatus == SEC_I_CONTINUE_NEEDED) {
+        sspiContext->continueNeeded = 1;
+    } else {
+        sspiContext->continueNeeded = 0;
+    }
+
+    if (!(securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+          || securityStatus == SEC_I_COMPLETE_NEEDED
+          || securityStatus == SEC_I_CONTINUE_NEEDED
+          || securityStatus == SEC_E_OK)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: initializeSecurityContext [failed] [%x].\n",
+                 securityStatus);
+        freeBuffer(&outBufferDesc);
+        return -1;
+    }
+
+    *responseToken = ne_base64(outBufferDesc.pBuffers->pvBuffer,
+                               outBufferDesc.pBuffers->cbBuffer);
+    freeBuffer(&outBufferDesc);
+
+    return 0;
+}
+#endif /* HAVE_SSPI */
diff --git a/net/mmt/neon/src/ne_sspi.h b/net/mmt/neon/src/ne_sspi.h
new file mode 100644
index 0000000..73f2b17
--- /dev/null
+++ b/net/mmt/neon/src/ne_sspi.h
@@ -0,0 +1,48 @@
+/* 
+   Microsoft SSPI based authentication routines
+   Copyright (C) 2004-2005, Vladimir Berezniker @ http://public.xdi.org/=vmpn
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SSPI_H
+#define NE_SSPI_H
+
+/* Win32 SSPI-based authentication interfaces.  PRIVATE TO NEON -- NOT
+ * PART OF THE EXTERNAL API. */
+
+#ifdef HAVE_SSPI
+
+#include <windows.h>
+#define SECURITY_WIN32
+#include <security.h>
+
+int ne_sspi_init(void);
+int ne_sspi_deinit(void);
+
+int ne_sspi_create_context(void **context, char * serverName, int ntlm);
+
+int ne_sspi_destroy_context(void *context);
+
+int ne_sspi_clear_context(void *context);
+
+int ne_sspi_authenticate(void *context, const char *base64Token,
+                         char **responseToken);
+
+#endif /* HAVE_SSPI */
+
+#endif /* NE_SSPI_H */
diff --git a/net/mmt/neon/src/ne_string.c b/net/mmt/neon/src/ne_string.c
new file mode 100644
index 0000000..2d222f4
--- /dev/null
+++ b/net/mmt/neon/src/ne_string.c
@@ -0,0 +1,616 @@
+/* 
+   String utility functions
+   Copyright (C) 1999-2007, 2009, Joe Orton <joe@manyfish.co.uk>
+   strcasecmp/strncasecmp implementations are:
+   Copyright (C) 1991, 1992, 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+#include "ne_alloc.h"
+#include "ne_string.h"
+
+char *ne_token(char **str, char separator)
+{
+    char *ret = *str, *pnt = strchr(*str, separator);
+
+    if (pnt) {
+	*pnt = '\0';
+	*str = pnt + 1;
+    } else {
+	/* no separator found: return end of string. */
+	*str = NULL;
+    }
+    
+    return ret;
+}
+
+char *ne_qtoken(char **str, char separator, const char *quotes)
+{
+    char *pnt, *ret = NULL;
+
+    for (pnt = *str; *pnt != '\0'; pnt++) {
+	char *quot = strchr(quotes, *pnt);
+	
+	if (quot) {
+	    char *qclose = strchr(pnt+1, *quot);
+	    
+	    if (!qclose) {
+		/* no closing quote: invalid string. */
+		return NULL;
+	    }
+	    
+	    pnt = qclose;
+	} else if (*pnt == separator) {
+	    /* found end of token. */
+	    *pnt = '\0';
+	    ret = *str;
+	    *str = pnt + 1;
+	    return ret;
+	}
+    }
+
+    /* no separator found: return end of string. */
+    ret = *str;
+    *str = NULL;
+    return ret;
+}
+
+char *ne_shave(char *str, const char *whitespace)
+{
+    char *pnt, *ret = str;
+
+    while (*ret != '\0' && strchr(whitespace, *ret) != NULL) {
+	ret++;
+    }
+
+    /* pnt points at the NUL terminator. */
+    pnt = &ret[strlen(ret)];
+    
+    while (pnt > ret && strchr(whitespace, *(pnt-1)) != NULL) {
+	pnt--;
+    }
+
+    *pnt = '\0';
+    return ret;
+}
+
+void ne_buffer_clear(ne_buffer *buf) 
+{
+    memset(buf->data, 0, buf->length);
+    buf->used = 1;
+}  
+
+/* Grows for given size, returns 0 on success, -1 on error. */
+void ne_buffer_grow(ne_buffer *buf, size_t newsize) 
+{
+#define NE_BUFFER_GROWTH 512
+    if (newsize > buf->length) {
+	/* If it's not big enough already... */
+	buf->length = ((newsize / NE_BUFFER_GROWTH) + 1) * NE_BUFFER_GROWTH;
+	
+	/* Reallocate bigger buffer */
+	buf->data = ne_realloc(buf->data, buf->length);
+    }
+}
+
+static size_t count_concat(va_list *ap)
+{
+    size_t total = 0;
+    char *next;
+
+    while ((next = va_arg(*ap, char *)) != NULL)
+	total += strlen(next);
+
+    return total;
+}
+
+static void do_concat(char *str, va_list *ap) 
+{
+    char *next;
+
+    while ((next = va_arg(*ap, char *)) != NULL) {
+#ifdef HAVE_STPCPY
+        str = stpcpy(str, next);
+#else
+	size_t len = strlen(next);
+	memcpy(str, next, len);
+	str += len;
+#endif
+    }
+}
+
+void ne_buffer_concat(ne_buffer *buf, ...)
+{
+    va_list ap;
+    ssize_t total;
+
+    va_start(ap, buf);
+    total = buf->used + count_concat(&ap);
+    va_end(ap);    
+
+    /* Grow the buffer */
+    ne_buffer_grow(buf, total);
+    
+    va_start(ap, buf);    
+    do_concat(buf->data + buf->used - 1, &ap);
+    va_end(ap);    
+
+    buf->used = total;
+    buf->data[total - 1] = '\0';
+}
+
+char *ne_concat(const char *str, ...)
+{
+    va_list ap;
+    size_t total, slen = strlen(str);
+    char *ret;
+
+    va_start(ap, str);
+    total = slen + count_concat(&ap);
+    va_end(ap);
+
+    ret = memcpy(ne_malloc(total + 1), str, slen);
+
+    va_start(ap, str);
+    do_concat(ret + slen, &ap);
+    va_end(ap);
+
+    ret[total] = '\0';
+    return ret;    
+}
+
+/* Append zero-terminated string... returns 0 on success or -1 on
+ * realloc failure. */
+void ne_buffer_zappend(ne_buffer *buf, const char *str) 
+{
+    ne_buffer_append(buf, str, strlen(str));
+}
+
+void ne_buffer_append(ne_buffer *buf, const char *data, size_t len) 
+{
+    ne_buffer_grow(buf, buf->used + len);
+    memcpy(buf->data + buf->used - 1, data, len);
+    buf->used += len;
+    buf->data[buf->used - 1] = '\0';
+}
+
+size_t ne_buffer_snprintf(ne_buffer *buf, size_t max, const char *fmt, ...)
+{
+    va_list ap;
+    size_t ret;
+
+    ne_buffer_grow(buf, buf->used + max);
+
+    va_start(ap, fmt);
+    ret = ne_vsnprintf(buf->data + buf->used - 1, max, fmt, ap);
+    va_end(ap);
+    buf->used += ret;
+
+    return ret;    
+}
+
+ne_buffer *ne_buffer_create(void) 
+{
+    return ne_buffer_ncreate(512);
+}
+
+ne_buffer *ne_buffer_ncreate(size_t s) 
+{
+    ne_buffer *buf = ne_malloc(sizeof(*buf));
+    buf->data = ne_malloc(s);
+    buf->data[0] = '\0';
+    buf->length = s;
+    buf->used = 1;
+    return buf;
+}
+
+void ne_buffer_destroy(ne_buffer *buf) 
+{
+    ne_free(buf->data);
+    ne_free(buf);
+}
+
+char *ne_buffer_finish(ne_buffer *buf)
+{
+    char *ret = buf->data;
+    ne_free(buf);
+    return ret;
+}
+
+void ne_buffer_altered(ne_buffer *buf)
+{
+    buf->used = strlen(buf->data) + 1;
+}
+
+
+/* ascii_quote[n] gives the number of bytes needed by
+ * ne_buffer_qappend() to append character 'n'. */
+static const unsigned char ascii_quote[256] = {
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
+};
+
+static const char hex_chars[16] = "0123456789ABCDEF";
+
+/* Return the expected number of bytes needed to append the string
+ * beginning at byte 's', where 'send' points to the last byte after
+ * 's'. */ 
+static size_t qappend_count(const unsigned char *s, const unsigned char *send)
+{
+    const unsigned char *p;
+    size_t ret;
+    
+    for (p = s, ret = 0; p < send; p++) {
+        ret += ascii_quote[*p];
+    }
+
+    return ret;
+}       
+
+/* Append the string 's', up to but not including 'send', to string
+ * 'dest', quoting along the way.  Returns pointer to NUL. */
+static char *quoted_append(char *dest, const unsigned char *s, 
+                           const unsigned char *send)
+{
+    const unsigned char *p;
+    char *q = dest;
+
+    for (p = s; p < send; p++) {
+        if (ascii_quote[*p] == 1) {
+            *q++ = *p;
+        }
+        else {
+            *q++ = '\\';
+            *q++ = 'x';
+            *q++ = hex_chars[(*p >> 4) & 0x0f];
+            *q++ = hex_chars[*p & 0x0f];
+        }
+    }
+
+    /* NUL terminate after the last character */
+    *q = '\0';
+    
+    return q;
+}
+
+void ne_buffer_qappend(ne_buffer *buf, const unsigned char *data, size_t len)
+{
+    const unsigned char *dend = data + len;
+    char *q, *qs;
+
+    ne_buffer_grow(buf, buf->used + qappend_count(data, dend));
+
+    /* buf->used >= 1, so this is safe. */
+    qs = buf->data + buf->used - 1;
+
+    q = quoted_append(qs, data, dend);
+    
+    /* used already accounts for a NUL, so increment by number of
+     * characters appended, *before* the NUL. */
+    buf->used += q - qs;
+}
+
+char *ne_strnqdup(const unsigned char *data, size_t len)
+{
+    const unsigned char *dend = data + len;
+    char *dest = malloc(qappend_count(data, dend) + 1);
+
+    quoted_append(dest, data, dend);
+
+    return dest;
+}
+
+static const char b64_alphabet[] =  
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+    "abcdefghijklmnopqrstuvwxyz"
+    "0123456789+/=";
+    
+char *ne_base64(const unsigned char *text, size_t inlen)
+{
+    /* The tricky thing about this is doing the padding at the end,
+     * doing the bit manipulation requires a bit of concentration only */
+    char *buffer, *point;
+    size_t outlen;
+    
+    /* Use 'buffer' to store the output. Work out how big it should be...
+     * This must be a multiple of 4 bytes */
+
+    outlen = (inlen*4)/3;
+    if ((inlen % 3) > 0) /* got to pad */
+	outlen += 4 - (inlen % 3);
+    
+    buffer = ne_malloc(outlen + 1); /* +1 for the \0 */
+    
+    /* now do the main stage of conversion, 3 bytes at a time,
+     * leave the trailing bytes (if there are any) for later */
+
+    for (point=buffer; inlen>=3; inlen-=3, text+=3) {
+	*(point++) = b64_alphabet[ (*text)>>2 ]; 
+	*(point++) = b64_alphabet[ ((*text)<<4 & 0x30) | (*(text+1))>>4 ]; 
+	*(point++) = b64_alphabet[ ((*(text+1))<<2 & 0x3c) | (*(text+2))>>6 ];
+	*(point++) = b64_alphabet[ (*(text+2)) & 0x3f ];
+    }
+
+    /* Now deal with the trailing bytes */
+    if (inlen > 0) {
+	/* We always have one trailing byte */
+	*(point++) = b64_alphabet[ (*text)>>2 ];
+	*(point++) = b64_alphabet[ (((*text)<<4 & 0x30) |
+				     (inlen==2?(*(text+1))>>4:0)) ]; 
+	*(point++) = (inlen==1?'=':b64_alphabet[ (*(text+1))<<2 & 0x3c ]);
+	*(point++) = '=';
+    }
+
+    /* Null-terminate */
+    *point = '\0';
+
+    return buffer;
+}
+
+/* VALID_B64: fail if 'ch' is not a valid base64 character */
+#define VALID_B64(ch) (((ch) >= 'A' && (ch) <= 'Z') || \
+                       ((ch) >= 'a' && (ch) <= 'z') || \
+                       ((ch) >= '0' && (ch) <= '9') || \
+                       (ch) == '/' || (ch) == '+' || (ch) == '=')
+
+/* DECODE_B64: decodes a valid base64 character. */
+#define DECODE_B64(ch) ((ch) >= 'a' ? ((ch) + 26 - 'a') : \
+                        ((ch) >= 'A' ? ((ch) - 'A') : \
+                         ((ch) >= '0' ? ((ch) + 52 - '0') : \
+                          ((ch) == '+' ? 62 : 63))))
+
+size_t ne_unbase64(const char *data, unsigned char **out)
+{
+    size_t inlen = strlen(data);
+    unsigned char *outp;
+    const unsigned char *in;
+
+    if (inlen == 0 || (inlen % 4) != 0) return 0;
+    
+    outp = *out = ne_malloc(inlen * 3 / 4);
+
+    for (in = (const unsigned char *)data; *in; in += 4) {
+        unsigned int tmp;
+        if (!VALID_B64(in[0]) || !VALID_B64(in[1]) || !VALID_B64(in[2]) ||
+            !VALID_B64(in[3]) || in[0] == '=' || in[1] == '=' ||
+            (in[2] == '=' && in[3] != '=')) {
+            ne_free(*out);
+            return 0;
+        }
+        tmp = (DECODE_B64(in[0]) & 0x3f) << 18 |
+            (DECODE_B64(in[1]) & 0x3f) << 12;
+        *outp++ = (tmp >> 16) & 0xff;
+        if (in[2] != '=') {
+            tmp |= (DECODE_B64(in[2]) & 0x3f) << 6;
+            *outp++ = (tmp >> 8) & 0xff;
+            if (in[3] != '=') {
+                tmp |= DECODE_B64(in[3]) & 0x3f;
+                *outp++ = tmp & 0xff;
+            }
+        }
+    }
+
+    return outp - *out;
+}
+
+/* Character map array; ascii_clean[n] = isprint(n) ? n : 0x20.  Used
+ * by ne_strclean as a locale-independent isprint(). */
+static const unsigned char ascii_clean[256] = {
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
+    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
+    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
+    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 
+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
+    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
+};
+
+char *ne_strclean(char *str)
+{
+    unsigned char *pnt;
+
+    for (pnt = (unsigned char *)str; *pnt; pnt++)
+        *pnt = (char)ascii_clean[*pnt];
+
+    return str;
+}
+
+char *ne_strerror(int errnum, char *buf, size_t buflen)
+{
+#ifdef HAVE_STRERROR_R
+#ifdef STRERROR_R_CHAR_P
+    /* glibc-style strerror_r which may-or-may-not use provided buffer. */
+    char *ret = strerror_r(errnum, buf, buflen);
+    if (ret != buf)
+	ne_strnzcpy(buf, ret, buflen);
+#else /* POSIX-style strerror_r: */
+    char tmp[256];
+
+    if (strerror_r(errnum, tmp, sizeof tmp) == 0)
+        ne_strnzcpy(buf, tmp, buflen);
+    else
+        ne_snprintf(buf, buflen, "Unknown error %d", errnum);
+#endif
+#else /* no strerror_r: */
+    ne_strnzcpy(buf, strerror(errnum), buflen);
+#endif
+    return buf;
+}
+
+
+/* Wrapper for ne_snprintf. */
+size_t ne_snprintf(char *str, size_t size, const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+#ifdef HAVE_TRIO
+    trio_vsnprintf(str, size, fmt, ap);
+#else
+    vsnprintf(str, size, fmt, ap);
+#endif
+    va_end(ap);
+    str[size-1] = '\0';
+    return strlen(str);
+}
+
+/* Wrapper for ne_vsnprintf. */
+size_t ne_vsnprintf(char *str, size_t size, const char *fmt, va_list ap)
+{
+#ifdef HAVE_TRIO
+    trio_vsnprintf(str, size, fmt, ap);
+#else
+    vsnprintf(str, size, fmt, ap);
+#endif
+    str[size-1] = '\0';
+    return strlen(str);
+}
+
+/* Locale-independent strcasecmp implementations. */
+static const unsigned char ascii_tolower[256] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
+0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
+0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
+0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
+0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
+0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
+};    
+
+#define TOLOWER(ch) ascii_tolower[ch]
+
+const unsigned char *ne_tolower_array(void)
+{
+    return ascii_tolower;
+}
+
+int ne_strcasecmp(const char *s1, const char *s2)
+{
+    const unsigned char *p1 = (const unsigned char *) s1;
+    const unsigned char *p2 = (const unsigned char *) s2;
+    unsigned char c1, c2;
+
+    if (p1 == p2)
+        return 0;
+    
+    do {
+        c1 = TOLOWER(*p1++);
+        c2 = TOLOWER(*p2++);
+        if (c1 == '\0')
+            break;
+    } while (c1 == c2);
+    
+    return c1 - c2;
+}
+
+int ne_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    const unsigned char *p1 = (const unsigned char *) s1;
+    const unsigned char *p2 = (const unsigned char *) s2;
+    unsigned char c1, c2;
+    
+    if (p1 == p2 || n == 0)
+        return 0;
+    
+    do {
+        c1 = TOLOWER(*p1++);
+        c2 = TOLOWER(*p2++);
+        if (c1 == '\0' || c1 != c2)
+            return c1 - c2;
+    } while (--n > 0);
+    
+    return c1 - c2;
+}
diff --git a/net/mmt/neon/src/ne_string.h b/net/mmt/neon/src/ne_string.h
new file mode 100644
index 0000000..b48cf3e
--- /dev/null
+++ b/net/mmt/neon/src/ne_string.h
@@ -0,0 +1,189 @@
+/* 
+   String utility functions
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_STRING_H
+#define NE_STRING_H
+
+#include "ne_defs.h"
+#include "ne_alloc.h"
+
+#include <stdarg.h>
+
+NE_BEGIN_DECLS
+
+/* ne_token and ne_qtoken return the next token in *str before either
+ * the next separator character 'sep' or the NUL terminator.
+ * ne_qtoken skips over any parts quoted using a pair of any one of
+ * the characters given in 'quotes'.  After returning, *str will point
+ * to the next character after the separator, or NULL if no separator
+ * character was found.
+ * 
+ * ne_qtoken will return NULL if unterminated quotes are found. */
+char *ne_token(char **str, char sep);
+char *ne_qtoken(char **str, char sep, const char *quotes);
+
+/* Return portion of 'str' with any characters in 'whitespace' shaved
+ * off the beginning and end.  Modifies str in-place. */
+char *ne_shave(char *str, const char *whitespace);
+
+/* Cleanse 'str' of non-printable (e.g. control) characters.  'str' is
+ * modified in-place, and returned. */
+char *ne_strclean(char *str);
+
+/* Encode 'len' bytes of 'text' to base64.  Returns malloc-allocated
+ * NUL-terminated buffer which the caller must free(). */
+char *ne_base64(const unsigned char *text, size_t len);
+
+/* Decode NUL-terminated base64-encoded string 'data', placing
+ * malloc-allocated raw decoder output in '*out'.  Returns length, or
+ * zero on decode error (in which case the content of *out is
+ * undefined). */
+size_t ne_unbase64(const char *data, unsigned char **out);
+
+/* Dynamically-allocated string buffer.  A string buffer which grows
+ * dynamically . (Strings are zero-terminated still).  A
+ * string buffer ne_buffer which grows dynamically with the string. */
+typedef struct {
+    char *data; /* contents: NUL-terminated string */
+    size_t used; /* strlen(data) + 1 */
+    size_t length; /* number of bytes allocated */
+} ne_buffer;
+
+/* Create a new string buffer object. */
+ne_buffer *ne_buffer_create(void);
+
+/* Create a new string buffer object with at least 'size' bytes of
+ * allocated space. */
+ne_buffer *ne_buffer_ncreate(size_t size);
+
+/* Returns size of data in buffer, equiv to strlen(ne_buffer_data(buf)) */
+#define ne_buffer_size(buf) ((buf)->used - 1)
+
+/* Concatenate all given strings onto the end of the buffer.  The
+ * strings must all be NUL-terminated, and MUST be followed by a NULL
+ * argument marking the end of the list.  */
+void ne_buffer_concat(ne_buffer *buf, ...)
+    ne_attribute_sentinel;
+
+/* Append a NUL-terminated string 'str' to buf. */
+void ne_buffer_zappend(ne_buffer *buf, const char *str);
+
+/* Append 'len' bytes of 'data' to buf, where 'data' does not contain
+ * a NUL terminator.  (A NUL terminator is appended to buf) */
+void ne_buffer_append(ne_buffer *buf, const char *data, size_t len);
+
+/* Append 'len' bytes of 'data' to buf.  All non-ASCII bytes, and
+ * ASCII control characters, are escaped.  (Note that this includes
+ * the NUL byte). */
+void ne_buffer_qappend(ne_buffer *buf, const unsigned char *data, size_t len);
+
+/* Print a string to the end of the buffer using printf-style format
+ * string 'format' and subsqeuent arguments.  At most 'max' characters
+ * are appended; the number of characters appended (excluding the NUL
+ * terminator) is returned.  Behaviour is undefined if 'max' is passed
+ * as zero. */
+size_t ne_buffer_snprintf(ne_buffer *buf, size_t max, 
+                          const char *format, ...)
+    ne_attribute((format(printf, 3, 4)));
+
+/* Append a literal, NUL-terminated constant string 'str' to buffer
+ * 'buf'. */
+#define ne_buffer_czappend(buf, str) \
+ne_buffer_append((buf), (str), sizeof((str)) - 1)
+
+/* Clear the string buffer 'buf', making it equivalent to the empty
+ * string. */
+void ne_buffer_clear(ne_buffer *buf);
+
+/* Grow the allocated size of string buffer 'buf' to at least 'size'
+ * bytes. */
+void ne_buffer_grow(ne_buffer *buf, size_t size);
+
+/* Re-establish the 'used' invariant if the string buffer data field is
+ * altered directly. */
+void ne_buffer_altered(ne_buffer *buf);
+
+/* Destroy the string buffer object 'buf' without deallocating the
+ * data string.  The data string must subsequently be freed using
+ * ne_free(). */
+char *ne_buffer_finish(ne_buffer *buf);
+
+/* Destroy a string buffer object. */
+void ne_buffer_destroy(ne_buffer *buf);
+
+/* Thread-safe strerror() wrapper; place system error for errno value
+ * 'errnum' in 'buffer', which is of length 'buflen'.  Returns
+ * 'buffer'. */
+char *ne_strerror(int errnum, char *buffer, size_t buflen);
+
+/* ne_strnzcpy copies at most 'n'-1 bytes of 'src' to 'dest', and
+ * ensures that 'dest' is subsequently NUL-terminated. */
+#define ne_strnzcpy(dest, src, n) do { size_t ne__nm1 = (n) - 1;      \
+strncpy(dest, src, ne__nm1); dest[ne__nm1] = '\0'; } while (0)
+
+/* Return a malloc-allocated copy of 'data', of length 'len', with all
+ * non-ASCII bytes, and ASCII control characters escaped.  (Note that
+ * the escaping includes the NUL byte). */
+char *ne_strnqdup(const unsigned char *data, size_t len);
+
+/* Return malloc-allocated concatenation of all NUL-terminated string
+ * arguments, up to a terminating NULL pointer. */
+char *ne_concat(const char *str, ...)
+    ne_attribute_sentinel;
+
+/* Wrapper for snprintf: always NUL-terminates returned buffer, and
+ * returns strlen(str). */
+size_t ne_snprintf(char *str, size_t size, const char *fmt, ...)
+    ne_attribute((format(printf, 3, 4)));
+
+/* Wrapper for vsnprintf. */
+size_t ne_vsnprintf(char *str, size_t size, const char *fmt, va_list ap)
+    ne_attribute((format(printf, 3, 0)));
+
+/* Implementations of strcasecmp and strncasecmp which behave as
+ * defined by the ANSI C strcasecmp() and strncasecmp() when in the
+ * POSIX locale; i.e. ignoring the process locale. */
+
+/* Compares 's1' and 's2', ignoring differences in case. */
+int ne_strcasecmp(const char *s1, const char *s2);
+/* Compares up to 'n' characters of 's1' and 's2', ignoring
+ * differences in case. */
+int ne_strncasecmp(const char *s1, const char *s2, size_t n);
+
+/* Return lowercase 'c' as in POSIX locale; note difference from ANSI
+ * C semantics as both the argument and return value are unsigned
+ * char. */
+#define ne_tolower(c) (ne_tolower_array()[(unsigned char)c])
+
+const unsigned char *ne_tolower_array(void);
+
+/* Convert an ASCII hexadecimal character in the ranges '0'..'9'
+ * 'a'..'f' 'A'..'F' to its numeric equivalent. */
+#define NE_ASC2HEX(x) (((x) <= '9') ? ((x) - '0') : \
+                       (ne_tolower((x)) + 10 - 'a'))
+
+/* Convert an integer in the range 0..15 to the equivalent (lowercase)
+ * ASCII hexadecimal equivalent character, in the range '0..9,'a..f' */
+#define NE_HEX2ASC(x) ((char) ((x) > 9 ? ((x) - 10 + 'a') : ((x) + '0')))
+
+NE_END_DECLS
+
+#endif /* NE_STRING_H */
diff --git a/net/mmt/neon/src/ne_stubssl.c b/net/mmt/neon/src/ne_stubssl.c
new file mode 100644
index 0000000..77f9055
--- /dev/null
+++ b/net/mmt/neon/src/ne_stubssl.c
@@ -0,0 +1,145 @@
+/* 
+   Stubs for SSL support when no SSL library has been configured
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <stdlib.h> /* for NULL */
+
+#include "ne_ssl.h"
+#include "ne_session.h"
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *dn)
+{
+    return NULL;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    return NULL;
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    return 1;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{ 
+    return NULL;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert) {}
+
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    return NULL;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *ccert)
+{
+    return NULL;
+}
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *ccert)
+{
+    return -1;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *ccert, const char *password)
+{
+    return -1;
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *ccert) {}
+
+void ne_ssl_trust_default_ca(ne_session *sess) {}
+
+ne_ssl_context *ne_ssl_context_create(int mode)
+{
+    return NULL;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, 
+                              int required,
+                              const char *ca_names,
+                              const char *verify_cas)
+{
+    return -1;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value) {}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx) {}
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char digest[60])
+{
+    return -1;
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until) {}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return NULL;
+}
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    return -1;
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    return -1;
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    return NULL;
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc) 
+{}
diff --git a/net/mmt/neon/src/ne_uri.c b/net/mmt/neon/src/ne_uri.c
new file mode 100644
index 0000000..4d0ab91
--- /dev/null
+++ b/net/mmt/neon/src/ne_uri.c
@@ -0,0 +1,617 @@
+/* 
+   URI manipulation routines.
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <stdio.h>
+
+#include <ctype.h>
+
+#include "ne_string.h" /* for ne_buffer */
+#include "ne_alloc.h"
+#include "ne_uri.h"
+
+/* URI ABNF from RFC 3986: */
+
+#define PS (0x0001) /* "+" */
+#define PC (0x0002) /* "%" */
+#define DS (0x0004) /* "-" */
+#define DT (0x0008) /* "." */
+#define US (0x0010) /* "_" */
+#define TD (0x0020) /* "~" */
+#define FS (0x0040) /* "/" */
+#define CL (0x0080) /* ":" */
+#define AT (0x0100) /* "@" */
+#define QU (0x0200) /* "?" */
+
+#define DG (0x0400) /* DIGIT */
+#define AL (0x0800) /* ALPHA */
+
+#define GD (0x1000) /* gen-delims    = "#" / "[" / "]" 
+                     * ... except ":", "/", "@", and "?" */
+
+#define SD (0x2000) /* sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+                     *               / "*" / "+" / "," / ";" / "=" 
+                     * ... except "+" which is PS */
+
+#define OT (0x4000) /* others */
+
+#define URI_ALPHA (AL)
+#define URI_DIGIT (DG)
+
+/* unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~" */
+#define URI_UNRESERVED (AL | DG | DS | DT | US | TD)
+/* scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
+#define URI_SCHEME (AL | DG | PS | DS | DT)
+/* real sub-delims definition, including "+" */
+#define URI_SUBDELIM (PS | SD)
+/* real gen-delims definition, including ":", "/", "@" and "?" */
+#define URI_GENDELIM (GD | CL | FS | AT | QU)
+/* userinfo = *( unreserved / pct-encoded / sub-delims / ":" ) */
+#define URI_USERINFO (URI_UNRESERVED | PC | URI_SUBDELIM | CL)
+/* pchar = unreserved / pct-encoded / sub-delims / ":" / "@" */
+#define URI_PCHAR (URI_UNRESERVED | PC | URI_SUBDELIM | CL | AT)
+/* invented: segchar = pchar / "/" */
+#define URI_SEGCHAR (URI_PCHAR | FS)
+/* query = *( pchar / "/" / "?" ) */
+#define URI_QUERY (URI_PCHAR | FS | QU)
+/* fragment == query */
+#define URI_FRAGMENT URI_QUERY
+
+/* any characters which should be path-escaped: */
+#define URI_ESCAPE ((URI_GENDELIM & ~(FS)) | URI_SUBDELIM | OT | PC)
+
+static const unsigned int uri_chars[256] = {
+/* 0xXX    x0      x2      x4      x6      x8      xA      xC      xE     */
+/*   0x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT,
+/*   1x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT,
+/*   2x */ OT, SD, OT, GD, SD, PC, SD, SD, SD, SD, SD, PS, SD, DS, DT, FS,
+/*   3x */ DG, DG, DG, DG, DG, DG, DG, DG, DG, DG, CL, SD, OT, SD, OT, QU,
+/*   4x */ AT, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+/*   5x */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, GD, OT, GD, OT, US,
+/*   6x */ OT, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+/*   7x */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, OT, OT, OT, TD, OT,
+/*   8x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   9x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Ax */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Bx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Cx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Dx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Ex */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Fx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT
+};
+
+#define uri_lookup(ch) (uri_chars[(unsigned char)ch])
+
+char *ne_path_parent(const char *uri) 
+{
+    size_t len = strlen(uri);
+    const char *pnt = uri + len - 1;
+    /* skip trailing slash (parent of "/foo/" is "/") */
+    if (pnt >= uri && *pnt == '/')
+	pnt--;
+    /* find previous slash */
+    while (pnt > uri && *pnt != '/')
+	pnt--;
+    if (pnt < uri || (pnt == uri && *pnt != '/'))
+	return NULL;
+    return ne_strndup(uri, pnt - uri + 1);
+}
+
+int ne_path_has_trailing_slash(const char *uri) 
+{
+    size_t len = strlen(uri);
+    return ((len > 0) &&
+	    (uri[len-1] == '/'));
+}
+
+unsigned int ne_uri_defaultport(const char *scheme)
+{
+    /* RFC2616/3.2.3 says use case-insensitive comparisons here. */
+    if (ne_strcasecmp(scheme, "http") == 0)
+	return 80;
+    else if (ne_strcasecmp(scheme, "https") == 0)
+	return 443;
+    else
+	return 0;
+}
+
+int ne_uri_parse(const char *uri, ne_uri *parsed)
+{
+    const char *p, *s;
+
+    memset(parsed, 0, sizeof *parsed);
+
+    p = s = uri;
+
+    /* => s = p = URI-reference */
+
+    if (uri_lookup(*p) & URI_ALPHA) {
+        while (uri_lookup(*p) & URI_SCHEME)
+            p++;
+        
+        if (*p == ':') {
+            parsed->scheme = ne_strndup(uri, p - s);
+            s = p + 1;
+        }
+    }
+
+    /* => s = heir-part, or s = relative-part */
+
+    if (s[0] == '/' && s[1] == '/') {
+        const char *pa;
+
+        /* => s = "//" authority path-abempty (from expansion of
+         * either heir-part of relative-part)  */
+        
+        /* authority = [ userinfo "@" ] host [ ":" port ] */
+
+        s = pa = s + 2; /* => s = authority */
+
+        while (*pa != '/' && *pa != '\0')
+            pa++;
+        /* => pa = path-abempty */
+        
+        p = s;
+        while (p < pa && uri_lookup(*p) & URI_USERINFO)
+            p++;
+
+        if (*p == '@') {
+            parsed->userinfo = ne_strndup(s, p - s);
+            s = p + 1;
+        }
+        /* => s = host */
+
+        if (s[0] == '[') {
+            p = s + 1;
+
+            while (*p != ']' && p < pa)
+                p++;
+
+            if (p == pa || (p + 1 != pa && p[1] != ':')) {
+                /* Ill-formed IP-literal. */
+                return -1;
+            }
+
+            p++; /* => p = colon */
+        } else {
+            /* Find the colon. */
+            p = pa;
+            while (*p != ':' && p > s)
+                p--;
+        }
+
+        if (p == s) {
+            p = pa;
+            /* No colon; => p = path-abempty */
+        } else if (p + 1 != pa) {
+            /* => p = colon */
+            parsed->port = atoi(p + 1);
+        }
+        parsed->host = ne_strndup(s, p - s);
+        
+        s = pa;        
+
+        if (*s == '\0') {
+            s = "/"; /* FIXME: scheme-specific. */
+        }
+    }
+
+    /* => s = path-abempty / path-absolute / path-rootless
+     *      / path-empty / path-noscheme */
+
+    p = s;
+
+    while (uri_lookup(*p) & URI_SEGCHAR)
+        p++;
+
+    /* => p = [ "?" query ] [ "#" fragment ] */
+
+    parsed->path = ne_strndup(s, p - s);
+
+    if (*p != '\0') {
+        s = p++;
+
+        while (uri_lookup(*p) & URI_QUERY)
+            p++;
+
+        /* => p = [ "#" fragment ] */
+        /* => s = [ "?" query ] [ "#" fragment ] */
+
+        if (*s == '?') {
+            parsed->query = ne_strndup(s + 1, p - s - 1);
+            
+            if (*p != '\0') {
+                s = p++;
+
+                while (uri_lookup(*p) & URI_FRAGMENT)
+                    p++;
+            }
+        }
+
+        /* => p now points to the next character after the
+         * URI-reference; which should be the NUL byte. */
+
+        if (*s == '#') {
+            parsed->fragment = ne_strndup(s + 1, p - s - 1);
+        }
+        else if (*p || *s != '?') {
+            return -1;
+        }
+    }
+    
+    return 0;
+}
+
+/* This function directly implements the "Merge Paths" algorithm
+ * described in RFC 3986 section 5.2.3. */
+static char *merge_paths(const ne_uri *base, const char *path)
+{
+    const char *p;
+
+    if (base->host && base->path[0] == '\0') {
+        return ne_concat("/", path, NULL);
+    }
+    
+    p = strrchr(base->path, '/');
+    if (p == NULL) {
+        return ne_strdup(path);
+    } else {
+        size_t len = p - base->path + 1;
+        char *ret = ne_malloc(strlen(path) + len + 1);
+
+        memcpy(ret, base->path, len);
+        memcpy(ret + len, path, strlen(path) + 1);
+        return ret;
+    }
+}
+
+/* This function directly implements the "Remove Dot Segments"
+ * algorithm described in RFC 3986 section 5.2.4. */
+static char *remove_dot_segments(const char *path)
+{
+    char *in, *inc, *out;
+
+    inc = in = ne_strdup(path);
+    out = ne_malloc(strlen(path) + 1);
+    out[0] = '\0';
+
+    while (in[0]) {
+        /* case 2.A: */
+        if (strncmp(in, "./", 2) == 0) {
+            in += 2;
+        } 
+        else if (strncmp(in, "../", 3) == 0) {
+            in += 3;
+        }
+
+        /* case 2.B: */
+        else if (strncmp(in, "/./", 3) == 0) {
+            in += 2;
+        }
+        else if (strcmp(in, "/.") == 0) {
+            in[1] = '\0';
+        }
+
+        /* case 2.C: */
+        else if (strncmp(in, "/../", 4) == 0 || strcmp(in, "/..") == 0) {
+            char *p;
+
+            /* Make the next character in the input buffer a "/": */
+            if (in[3] == '\0') {
+                /* terminating "/.." case */
+                in += 2;
+                in[0] = '/';
+            } else {
+                /* "/../" prefix case */
+                in += 3;
+            }
+
+            /* Trim the last component from the output buffer, or
+             * empty it. */
+            p = strrchr(out, '/');
+            if (p) {
+                *p = '\0';
+            } else {
+                out[0] = '\0';
+            }
+        }
+
+        /* case 2.D: */
+        else if (strcmp(in, ".") == 0 || strcmp(in, "..") == 0) {
+            in[0] = '\0';
+        }
+
+        /* case 2.E */
+        else {
+            char *p;
+
+            /* Search for the *second* "/" if the leading character is
+             * already "/": */
+            p = strchr(in + (in[0] == '/'), '/');
+            /* Otherwise, copy the whole string */
+            if (p == NULL) p = strchr(in, '\0');
+
+            strncat(out, in, p - in);
+            in = p;
+        }
+    }
+
+    ne_free(inc);
+
+    return out;
+}
+
+/* Copy authority components from 'src' to 'dest' if defined. */
+static void copy_authority(ne_uri *dest, const ne_uri *src)
+{
+    if (src->host) dest->host = ne_strdup(src->host);
+    dest->port = src->port;
+    if (src->userinfo) dest->userinfo = ne_strdup(src->userinfo);
+}
+
+/* This function directly implements the "Transform References"
+ * algorithm described in RFC 3986 section 5.2.2. */
+ne_uri *ne_uri_resolve(const ne_uri *base, const ne_uri *relative,
+                       ne_uri *target)
+{
+    memset(target, 0, sizeof *target);
+
+    if (relative->scheme) {
+        target->scheme = ne_strdup(relative->scheme);
+        copy_authority(target, relative);
+        target->path = remove_dot_segments(relative->path);
+        if (relative->query) target->query = ne_strdup(relative->query);
+    } else {
+        if (relative->host) {
+            copy_authority(target, relative);
+            target->path = remove_dot_segments(relative->path);
+            if (relative->query) target->query = ne_strdup(relative->query);
+        } else {
+            if (relative->path[0] == '\0') {
+                target->path = ne_strdup(base->path);
+                if (relative->query) {
+                    target->query = ne_strdup(relative->query);
+                } else if (base->query) {
+                    target->query = ne_strdup(base->query);
+                }
+            } else {
+                if (relative->path[0] == '/') {
+                    target->path = remove_dot_segments(relative->path);
+                } else {
+                    char *merged = merge_paths(base, relative->path);
+                    target->path = remove_dot_segments(merged);
+                    ne_free(merged);
+                }
+                if (relative->query) target->query = ne_strdup(relative->query);
+            }
+            copy_authority(target, base);
+        }
+        if (base->scheme) target->scheme = ne_strdup(base->scheme);
+    }
+    
+    if (relative->fragment) target->fragment = ne_strdup(relative->fragment);
+
+    return target;
+}
+
+ne_uri *ne_uri_copy(ne_uri *dest, const ne_uri *src)
+{
+    memset(dest, 0, sizeof *dest);
+
+    if (src->scheme) dest->scheme = ne_strdup(src->scheme);
+    copy_authority(dest, src);
+    if (src->path) dest->path = ne_strdup(src->path);
+    if (src->query) dest->query = ne_strdup(src->query);
+    if (src->fragment) dest->fragment = ne_strdup(src->fragment);
+
+    return dest;
+}
+
+void ne_uri_free(ne_uri *u)
+{
+    if (u->host) ne_free(u->host);
+    if (u->path) ne_free(u->path);
+    if (u->scheme) ne_free(u->scheme);
+    if (u->userinfo) ne_free(u->userinfo);
+    if (u->fragment) ne_free(u->fragment);
+    if (u->query) ne_free(u->query);
+    memset(u, 0, sizeof *u);
+}
+
+char *ne_path_unescape(const char *uri) 
+{
+    const char *pnt;
+    char *ret, *retpos, buf[5] = { "0x00" };
+    retpos = ret = ne_malloc(strlen(uri) + 1);
+    for (pnt = uri; *pnt != '\0'; pnt++) {
+	if (*pnt == '%') {
+	    if (!isxdigit((unsigned char) pnt[1]) || 
+		!isxdigit((unsigned char) pnt[2])) {
+		/* Invalid URI */
+                ne_free(ret);
+		return NULL;
+	    }
+	    buf[2] = *++pnt; buf[3] = *++pnt; /* bit faster than memcpy */
+	    *retpos++ = (char)strtol(buf, NULL, 16);
+	} else {
+	    *retpos++ = *pnt;
+	}
+    }
+    *retpos = '\0';
+    return ret;
+}
+
+/* CH must be an unsigned char; evaluates to 1 if CH should be
+ * percent-encoded (note !!x == x ? 1 : 0). */
+#define path_escape_ch(ch) (!!(uri_lookup(ch) & URI_ESCAPE))
+
+char *ne_path_escape(const char *path) 
+{
+    const unsigned char *pnt;
+    char *ret, *p;
+    size_t count = 0;
+
+    for (pnt = (const unsigned char *)path; *pnt != '\0'; pnt++) {
+        count += path_escape_ch(*pnt);
+    }
+
+    if (count == 0) {
+	return ne_strdup(path);
+    }
+
+    p = ret = ne_malloc(strlen(path) + 2 * count + 1);
+    for (pnt = (const unsigned char *)path; *pnt != '\0'; pnt++) {
+	if (path_escape_ch(*pnt)) {
+	    /* Escape it - %<hex><hex> */
+	    sprintf(p, "%%%02x", (unsigned char) *pnt);
+	    p += 3;
+	} else {
+	    *p++ = *pnt;
+	}
+    }
+    *p = '\0';
+    return ret;
+}
+
+#undef path_escape_ch
+
+#define CMPWITH(field, func)                    \
+    do {                                        \
+        if (u1->field) {                        \
+            if (!u2->field) return -1;          \
+            n = func(u1->field, u2->field);     \
+            if (n) return n;                    \
+        } else if (u2->field) {                 \
+            return 1;                           \
+        }                                       \
+    } while (0)
+
+#define CMP(field) CMPWITH(field, strcmp)
+#define CASECMP(field) CMPWITH(field, ne_strcasecmp)
+
+/* As specified by RFC 2616, section 3.2.3. */
+int ne_uri_cmp(const ne_uri *u1, const ne_uri *u2)
+{
+    int n;
+    
+    CMP(path);
+    CASECMP(host);
+    CASECMP(scheme);
+    CMP(query);
+    CMP(fragment);
+    CMP(userinfo);
+
+    return u2->port - u1->port;
+}
+
+#undef CMP
+#undef CASECMP
+#undef CMPWITH
+
+/* TODO: implement properly */
+int ne_path_compare(const char *a, const char *b) 
+{
+    int ret = ne_strcasecmp(a, b);
+    if (ret) {
+	/* This logic says: "If the lengths of the two URIs differ by
+	 * exactly one, and the LONGER of the two URIs has a trailing
+	 * slash and the SHORTER one DOESN'T, then..." */
+	int traila = ne_path_has_trailing_slash(a),
+	    trailb = ne_path_has_trailing_slash(b),
+	    lena = strlen(a), lenb = strlen(b);
+	if (traila != trailb && abs(lena - lenb) == 1 &&
+	    ((traila && lena > lenb) || (trailb && lenb > lena))) {
+	    /* Compare them, ignoring the trailing slash on the longer
+	     * URI */
+	    if (strncasecmp(a, b, lena < lenb ? lena : lenb) == 0)
+		ret = 0;
+	}
+    }
+    return ret;
+}
+
+char *ne_uri_unparse(const ne_uri *uri)
+{
+    ne_buffer *buf = ne_buffer_create();
+
+    if (uri->scheme) {
+        ne_buffer_concat(buf, uri->scheme, ":", NULL);
+    }
+
+    if (uri->host) {
+        ne_buffer_czappend(buf, "//");
+        if (uri->userinfo) {
+            ne_buffer_concat(buf, uri->userinfo, "@", NULL);
+        }
+        ne_buffer_zappend(buf, uri->host);
+        
+        if (uri->port > 0
+            && (!uri->scheme 
+                || ne_uri_defaultport(uri->scheme) != uri->port)) {
+            char str[20];
+            ne_snprintf(str, 20, ":%d", uri->port);
+            ne_buffer_zappend(buf, str);
+        }
+    }
+
+    ne_buffer_zappend(buf, uri->path);
+
+    if (uri->query) {
+        ne_buffer_concat(buf, "?", uri->query, NULL);
+    }
+    
+    if (uri->fragment) {
+        ne_buffer_concat(buf, "#", uri->fragment, NULL);
+    }
+
+    return ne_buffer_finish(buf);
+}
+
+/* Give it a path segment, it returns non-zero if child is 
+ * a child of parent. */
+int ne_path_childof(const char *parent, const char *child) 
+{
+    char *root = ne_strdup(child);
+    int ret;
+    if (strlen(parent) >= strlen(child)) {
+	ret = 0;
+    } else {
+	/* root is the first of child, equal to length of parent */
+	root[strlen(parent)] = '\0';
+	ret = (ne_path_compare(parent, root) == 0);
+    }
+    ne_free(root);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_uri.h b/net/mmt/neon/src/ne_uri.h
new file mode 100644
index 0000000..a51a3ee
--- /dev/null
+++ b/net/mmt/neon/src/ne_uri.h
@@ -0,0 +1,103 @@
+/* 
+   URI manipulation routines.
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_URI_H
+#define NE_URI_H
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Return a copy of a path string with anything other than
+ * "unreserved" and the forward-slash character percent-encoded
+ * according to the URI encoding rules.  Returns a malloc-allocated
+ * string and never NULL. */
+char *ne_path_escape(const char *path);
+
+/* Return a decoded copy of a percent-encoded path string. Returns
+ * malloc-allocated path on success, or NULL if the string contained
+ * any syntactically invalid percent-encoding sequences. */
+char *ne_path_unescape(const char *epath);
+
+/* Returns malloc-allocated parent of path, or NULL if path has no
+ * parent (such as "/"). */
+char *ne_path_parent(const char *path);
+
+/* Returns strcmp-like value giving comparison between p1 and p2,
+ * ignoring trailing-slashes. */
+int ne_path_compare(const char *p1, const char *p2);
+
+/* Returns non-zero if child is a child of parent */
+int ne_path_childof(const char *parent, const char *child);
+
+/* Returns non-zero if path has a trailing slash character */
+int ne_path_has_trailing_slash(const char *path);
+
+/* Return the default port for the given scheme, or 0 if none is
+ * known. */
+unsigned int ne_uri_defaultport(const char *scheme);
+
+typedef struct {
+    char *scheme;
+    char *host, *userinfo;
+    unsigned int port;
+    char *path, *query, *fragment;
+} ne_uri;
+
+/* Parse a URI-reference 'uri' and place parsed components in *parsed.
+ * Returns zero on success, non-zero on parse error.  On successful or
+ * error return, all the 'char *' fields of *parsed are either set to
+ * NULL, or point to malloc-allocated NUL-terminated strings;
+ * ne_uri_free can be used to free any set fields.  On success,
+ * parsed->path is guaranteed to be non-NULL. */
+int ne_uri_parse(const char *uri, ne_uri *parsed);
+
+/* Turns a URI structure back into a string.  The returned string is
+ * malloc-allocated, and must be freed by the caller. */
+char *ne_uri_unparse(const ne_uri *uri);
+
+/* Resolve a relative URI 'relative', with respect to base URI 'base',
+ * placing the resultant URI in '*result'.  At least both base->path
+ * and relative->path must be non-NULL.  On return, all the 'char *'
+ * fields of *result are either set to NULL or point to
+ * malloc-allocated NUL-terminated strings.  result->path is
+ * guaranteed to be non-NULL.  ne_uri_free can be used to free the
+ * result structure after use.  Returns 'result'. */
+ne_uri *ne_uri_resolve(const ne_uri *base, const ne_uri *relative,
+                       ne_uri *result);
+
+/* Compares URIs u1 and u2, returns non-zero if they are found to be
+ * non-equal.  The sign of the return value is <0 if 'u1' is less than
+ * 'u2', or >0 if 'u2' is greater than 'u1'. */
+int ne_uri_cmp(const ne_uri *u1, const ne_uri *u2);
+
+/* Copy components of URI 'src' to destination 'dest'.  Returns
+ * 'dest'. */
+ne_uri *ne_uri_copy(ne_uri *dest, const ne_uri *src);
+
+/* Frees any non-NULL fields of parsed URI structure *parsed.  All
+ * fields are then zero-initialized. */
+void ne_uri_free(ne_uri *parsed);
+
+NE_END_DECLS
+
+#endif /* NE_URI_H */
+
diff --git a/net/mmt/neon/src/ne_utils.c b/net/mmt/neon/src/ne_utils.c
new file mode 100644
index 0000000..5b120c8
--- /dev/null
+++ b/net/mmt/neon/src/ne_utils.c
@@ -0,0 +1,219 @@
+/* 
+   HTTP utility functions
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+#include <ctype.h> /* isdigit() for ne_parse_statusline */
+
+#ifdef NE_HAVE_ZLIB
+#include <zlib.h>
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_GNUTLS
+#include <gnutls/gnutls.h>
+#endif
+
+/* libxml2: pick up the version string. */
+#if defined(HAVE_LIBXML)
+#include <libxml/xmlversion.h>
+#elif defined(HAVE_EXPAT) && !defined(HAVE_XMLPARSE_H)
+#include <expat.h>
+#endif
+
+#include "ne_utils.h"
+#include "ne_string.h" /* for ne_strdup */
+#include "ne_dates.h"
+
+int ne_debug_mask = 0;
+FILE *ne_debug_stream = NULL;
+
+void ne_debug_init(FILE *stream, int mask)
+{
+    ne_debug_stream = stream;
+    ne_debug_mask = mask;
+#if defined(HAVE_SETVBUF) && defined(_IONBF)
+    /* If possible, turn off buffering on the debug log.  this is very
+     * helpful if debugging segfaults. */
+    if (stream) setvbuf(stream, NULL, _IONBF, 0);
+#endif        
+}
+
+void ne_debug(int ch, const char *template, ...) 
+{
+    va_list params;
+    if ((ch & ne_debug_mask) == 0) return;
+    fflush(stdout);
+    va_start(params, template);
+    vfprintf(ne_debug_stream, template, params);
+    va_end(params);
+    if ((ch & NE_DBG_FLUSH) == NE_DBG_FLUSH)
+	fflush(ne_debug_stream);
+}
+
+#define NE_STRINGIFY(x) # x
+#define NE_EXPAT_VER(x,y,z) NE_STRINGIFY(x) "." NE_STRINGIFY(y) "." NE_STRINGIFY(z)
+
+static const char version_string[] = "neon " NEON_VERSION ": " 
+#ifdef NEON_IS_LIBRARY
+  "Library build"
+#else
+  "Bundled build"
+#endif
+#ifdef NE_HAVE_IPV6
+   ", IPv6"
+#endif
+#ifdef HAVE_EXPAT
+  ", Expat"
+/* expat >=1.95.2 exported the version */
+#ifdef XML_MAJOR_VERSION
+" " NE_EXPAT_VER(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION)
+#endif
+#else /* !HAVE_EXPAT */
+#ifdef HAVE_LIBXML
+  ", libxml " LIBXML_DOTTED_VERSION
+#endif /* HAVE_LIBXML */
+#endif /* !HAVE_EXPAT */
+#if defined(NE_HAVE_ZLIB) && defined(ZLIB_VERSION)
+  ", zlib " ZLIB_VERSION
+#endif /* NE_HAVE_ZLIB && ... */
+#ifdef NE_HAVE_SOCKS
+   ", SOCKSv5"
+#endif
+#ifdef HAVE_OPENSSL
+#ifdef OPENSSL_VERSION_TEXT
+    ", " OPENSSL_VERSION_TEXT
+#else
+   "OpenSSL (unknown version)"
+#endif /* OPENSSL_VERSION_TEXT */
+#endif /* HAVE_OPENSSL */
+#ifdef HAVE_GNUTLS
+    ", GNU TLS " LIBGNUTLS_VERSION
+#endif /* HAVE_GNUTLS */
+#ifdef HAVE_SSPI
+    ", SSPI"
+#endif /* HAVE_SSPI */
+   "."
+;
+
+const char *ne_version_string(void)
+{
+    return version_string;
+}
+
+int ne_version_match(int major, int minor)
+{
+    return NE_VERSION_MAJOR != major || NE_VERSION_MINOR < minor
+        || (NE_VERSION_MAJOR == 0 && NE_VERSION_MINOR != minor);
+}
+
+int ne_has_support(int feature)
+{
+    switch (feature) {
+#if defined(NE_HAVE_SSL) || defined(NE_HAVE_ZLIB) || defined(NE_HAVE_IPV6) \
+    || defined(NE_HAVE_SOCKS) || defined(NE_HAVE_LFS) \
+    || defined(NE_HAVE_TS_SSL) || defined(NE_HAVE_I18N) || defined(HAVE_SSPI)
+#ifdef NE_HAVE_SSL
+    case NE_FEATURE_SSL:
+#endif
+#ifdef NE_HAVE_ZLIB
+    case NE_FEATURE_ZLIB:
+#endif
+#ifdef NE_HAVE_IPV6
+    case NE_FEATURE_IPV6:
+#endif
+#ifdef NE_HAVE_SOCKS
+    case NE_FEATURE_SOCKS:
+#endif
+#ifdef NE_HAVE_LFS
+    case NE_FEATURE_LFS:
+#endif
+#ifdef NE_HAVE_TS_SSL
+    case NE_FEATURE_TS_SSL:
+#endif
+#ifdef NE_HAVE_I18N
+    case NE_FEATURE_I18N:
+#endif
+#ifdef HAVE_SSPI
+    case NE_FEATURE_SSPI:
+#endif
+        return 1;
+#endif /* NE_HAVE_* */
+    default:
+        return 0;
+    }
+}
+
+int ne_parse_statusline(const char *status_line, ne_status *st)
+{
+    const char *part;
+    int major, minor, status_code, klass;
+
+    /* skip leading garbage if any. */
+    part = strstr(status_line, "HTTP/");
+    if (part == NULL) return -1;
+
+    minor = major = 0;
+
+    /* Parse version string, skipping leading zeroes. */
+    for (part += 5; *part != '\0' && isdigit(*part); part++)
+	major = major*10 + (*part-'0');
+
+    if (*part++ != '.') return -1;
+
+    for (;*part != '\0' && isdigit(*part); part++)
+	minor = minor*10 + (*part-'0');
+
+    if (*part != ' ') return -1;
+
+    /* Skip any spaces */
+    for (; *part == ' '; part++) /* noop */;
+
+    /* Parse the Status-Code; part now points at the first Y in
+     * "HTTP/x.x YYY". */
+    if (!isdigit(part[0]) || !isdigit(part[1]) || !isdigit(part[2]) ||
+	(part[3] != '\0' && part[3] != ' ')) return -1;
+    status_code = 100*(part[0]-'0') + 10*(part[1]-'0') + (part[2]-'0');
+    klass = part[0]-'0';
+
+    /* Skip whitespace between status-code and reason-phrase */
+    for (part+=3; *part == ' ' || *part == '\t'; part++) /* noop */;
+
+    /* part now may be pointing to \0 if reason phrase is blank */
+
+    /* Fill in the results */
+    st->major_version = major;
+    st->minor_version = minor;
+    st->reason_phrase = ne_strclean(ne_strdup(part));
+    st->code = status_code;
+    st->klass = klass;
+    return 0;
+}
diff --git a/net/mmt/neon/src/ne_utils.h b/net/mmt/neon/src/ne_utils.h
new file mode 100644
index 0000000..c298cf9
--- /dev/null
+++ b/net/mmt/neon/src/ne_utils.h
@@ -0,0 +1,118 @@
+/* 
+   HTTP utility functions
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_UTILS_H
+#define NE_UTILS_H
+
+#include <sys/types.h>
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#include "ne_defs.h"
+
+#ifdef NEON_TRIO
+#include <trio.h>
+#endif
+
+NE_BEGIN_DECLS
+
+/* Returns a human-readable library version string describing the
+ * version and build information; for example: 
+ *    "neon 0.2.0: Library build, OpenSSL support" */
+const char *ne_version_string(void);
+
+/* Returns non-zero if library version is not of major version
+ * 'major', or if minor version is not greater than or equal to
+ * 'minor'.  For neon versions with major == 0, all minor versions are
+ * presumed to be incompatible.  */
+int ne_version_match(int major, int minor);
+
+/* Feature codes: */
+#define NE_FEATURE_SSL (1) /* SSL/TLS support */
+#define NE_FEATURE_ZLIB (2) /* zlib compression in compress interface */
+#define NE_FEATURE_IPV6 (3) /* IPv6 is supported in resolver */
+#define NE_FEATURE_LFS (4) /* large file support */
+#define NE_FEATURE_SOCKS (5) /* SOCKSv5 support */
+#define NE_FEATURE_TS_SSL (6) /* Thread-safe SSL/TLS support */
+#define NE_FEATURE_I18N (7) /* i18n error message support */
+#define NE_FEATURE_SSPI (8) /* NTLM/Negotiate authentication protocol via SSPI */
+
+/* Returns non-zero if library is built with support for the given
+ * NE_FEATURE_* feature code 'code'. */
+int ne_has_support(int feature);
+
+/* Debugging macro to allow code to be optimized out if debugging is
+ * disabled at build time. */
+#ifndef NE_DEBUGGING
+#define NE_DEBUG if (0) ne_debug
+#else /* DEBUGGING */
+#define NE_DEBUG ne_debug
+#endif /* DEBUGGING */
+
+/* Debugging masks. */
+#define NE_DBG_SOCKET (1<<0) /* raw socket */
+#define NE_DBG_HTTP (1<<1) /* HTTP request/response handling */
+#define NE_DBG_XML (1<<2) /* XML parser */
+#define NE_DBG_HTTPAUTH (1<<3) /* HTTP authentication (hiding credentials) */
+#define NE_DBG_HTTPPLAIN (1<<4) /* plaintext HTTP authentication */
+#define NE_DBG_LOCKS (1<<5) /* WebDAV locking */
+#define NE_DBG_XMLPARSE (1<<6) /* low-level XML parser */
+#define NE_DBG_HTTPBODY (1<<7) /* HTTP response body blocks */
+#define NE_DBG_SSL (1<<8) /* SSL/TLS */
+#define NE_DBG_FLUSH (1<<30) /* always flush debugging */
+
+/* Send debugging output to 'stream', for all of the given debug
+ * channels.  To disable debugging, pass 'stream' as NULL and 'mask'
+ * as 0. */
+void ne_debug_init(FILE *stream, int mask);
+
+/* The current debug mask and stream set by the last call to
+ * ne_debug_init. */
+extern int ne_debug_mask;
+extern FILE *ne_debug_stream;
+
+/* Produce debug output if any of channels 'ch' is enabled for
+ * debugging. */
+void ne_debug(int ch, const char *, ...) ne_attribute((format(printf, 2, 3)));
+
+/* Storing an HTTP status result */
+typedef struct {
+    int major_version;
+    int minor_version;
+    int code; /* Status-Code value */
+    int klass; /* Class of Status-Code (1-5) */
+    char *reason_phrase;
+} ne_status;
+
+/* NB: couldn't use 'class' in ne_status because it would clash with
+ * the C++ reserved word. */
+
+/* Parse 'status_line' using the the RFC2616 Status-Line grammar.
+ * s->reason_phrase is malloc-allocated if non-NULL, and must be
+ * free'd by the caller.  Returns 0 on success, in which case all
+ * fields of '*s' will be set; or -1 on parse error, in which case
+ * '*s' is unmodified. */
+int ne_parse_statusline(const char *status_line, ne_status *s);
+
+NE_END_DECLS
+
+#endif /* NE_UTILS_H */
diff --git a/net/mmt/neon/src/ne_xml.c b/net/mmt/neon/src/ne_xml.c
new file mode 100644
index 0000000..3870701
--- /dev/null
+++ b/net/mmt/neon/src/ne_xml.c
@@ -0,0 +1,716 @@
+/* 
+   Wrapper interface to XML parser
+   Copyright (C) 1999-2007, 2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+
+#include "ne_internal.h"
+
+#include "ne_alloc.h"
+#include "ne_xml.h"
+#include "ne_utils.h"
+#include "ne_string.h"
+
+#if defined(HAVE_EXPAT)
+/* expat support: */
+#ifdef HAVE_XMLPARSE_H
+#include "xmlparse.h"
+#else
+#include <expat.h>
+#endif
+typedef XML_Char ne_xml_char;
+
+#if !defined(XML_MAJOR_VERSION)
+#define NEED_BOM_HANDLING
+#elif XML_MAJOR_VERSION < 2 && XML_MINOR_VERSION == 95 && XML_MICRO_VERSION < 2
+#define NEED_BOM_HANDLING
+#endif
+
+#elif defined(HAVE_LIBXML)
+/* libxml2 support: */
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+typedef xmlChar ne_xml_char;
+
+#if LIBXML_VERSION < 20619
+/* 2.6.19 and earlier have broken BOM handling */
+#define NEED_BOM_HANDLING
+#endif
+#else /* not HAVE_LIBXML */
+#  error need an XML parser
+#endif /* not HAVE_EXPAT */
+
+/* Approx. one screen of text: */
+#define ERR_SIZE (2048)
+
+struct handler {
+    ne_xml_startelm_cb *startelm_cb; /* start-element callback */
+    ne_xml_endelm_cb *endelm_cb; /* end-element callback */
+    ne_xml_cdata_cb *cdata_cb; /* character-data callback. */
+    void *userdata; /* userdata for the above. */
+    struct handler *next; /* next handler in stack. */
+};
+
+#ifdef HAVE_LIBXML
+static void sax_error(void *ctx, const char *msg, ...);
+#endif
+
+struct element {
+    const ne_xml_char *nspace;
+    ne_xml_char *name;
+
+    int state; /* opaque state integer */
+    
+    /* Namespaces declared in this element */
+    ne_xml_char *default_ns; /* A default namespace */
+    struct namespace *nspaces; /* List of other namespace scopes */
+
+    struct handler *handler; /* Handler for this element */
+
+    struct element *parent; /* parent element, or NULL */    
+};
+
+/* We pass around a ne_xml_parser as the userdata in the parsing
+ * library.  This maintains the current state of the parse and various
+ * other bits and bobs. Within the parse, we store the current branch
+ * of the tree, i.e., the current element and all its parents, up to
+ * the root, but nothing other than that.  */
+struct ne_xml_parser_s {
+    struct element *root; /* the root of the document */
+    struct element *current; /* current element in the branch */
+    struct handler *top_handlers; /* always points at the 
+					   * handler on top of the stack. */
+    int failure; /* zero whilst parse should continue */
+    int prune; /* if non-zero, depth within a dead branch */
+
+#ifdef NEED_BOM_HANDLING
+    int bom_pos;
+#endif
+
+#ifdef HAVE_EXPAT
+    XML_Parser parser;
+    char *encoding;
+#else
+    xmlParserCtxtPtr parser;
+#endif
+    char error[ERR_SIZE];
+};
+
+/* The callback handlers */
+static void start_element(void *userdata, const ne_xml_char *name, const ne_xml_char **atts);
+static void end_element(void *userdata, const ne_xml_char *name);
+static void char_data(void *userdata, const ne_xml_char *cdata, int len);
+static const char *resolve_nspace(const struct element *elm, 
+                                  const char *prefix, size_t pfxlen);
+
+/* Linked list of namespace scopes */
+struct namespace {
+    ne_xml_char *name;
+    ne_xml_char *uri;
+    struct namespace *next;
+};
+
+#ifdef HAVE_LIBXML
+
+/* Could be const as far as we care, but libxml doesn't want that */
+static xmlSAXHandler sax_handler = {
+    NULL, /* internalSubset */
+    NULL, /* isStandalone */
+    NULL, /* hasInternalSubset */
+    NULL, /* hasExternalSubset */
+    NULL, /* resolveEntity */
+    NULL, /* getEntity */
+    NULL, /* entityDecl */
+    NULL, /* notationDecl */
+    NULL, /* attributeDecl */
+    NULL, /* elementDecl */
+    NULL, /* unparsedEntityDecl */
+    NULL, /* setDocumentLocator */
+    NULL, /* startDocument */
+    NULL, /* endDocument */
+    start_element, /* startElement */
+    end_element, /* endElement */
+    NULL, /* reference */
+    char_data, /* characters */
+    NULL, /* ignorableWhitespace */
+    NULL, /* processingInstruction */
+    NULL, /* comment */
+    NULL, /* xmlParserWarning */
+    sax_error, /* xmlParserError */
+    sax_error, /* fatal error (never called by libxml2?) */
+    NULL, /* getParameterEntity */
+    char_data /* cdataBlock */
+};
+
+/* empty attributes array to mimic expat behaviour */
+static const char *const empty_atts[] = {NULL, NULL};
+
+/* macro for determining the attributes array to pass */
+#define PASS_ATTS(atts) (atts ? (const char **)(atts) : empty_atts)
+
+#else
+
+#define PASS_ATTS(atts) ((const char **)(atts))
+
+/* XML declaration callback for expat. */
+static void decl_handler(void *userdata,
+			 const XML_Char *version, const XML_Char *encoding, 
+			 int standalone)
+{
+    ne_xml_parser *p = userdata;
+    if (encoding) p->encoding = ne_strdup(encoding);    
+}
+
+#endif /* HAVE_LIBXML */
+
+int ne_xml_currentline(ne_xml_parser *p) 
+{
+#ifdef HAVE_EXPAT
+    return XML_GetCurrentLineNumber(p->parser);
+#else
+    return p->parser->input->line;
+#endif
+}
+
+const char *ne_xml_doc_encoding(const ne_xml_parser *p)
+{
+#ifdef HAVE_LIBXML
+    return p->parser->encoding;
+#else
+    return p->encoding;
+#endif
+}
+
+/* The first character of the REC-xml-names "NCName" rule excludes
+ * "Digit | '.' | '-' | '_' | CombiningChar | Extender"; the XML
+ * parser will not enforce this rule in a namespace declaration since
+ * it treats the entire attribute name as a REC-xml "Name" rule.  It's
+ * too hard to check for all of CombiningChar | Digit | Extender here,
+ * but the valid_ncname_ch1 macro catches some of the rest. */
+
+/* Return non-zero if 'ch' is an invalid start character for an NCName: */
+#define invalid_ncname_ch1(ch) ((ch) == '\0' || strchr("-.0123456789", (ch)) != NULL)
+
+/* Subversion repositories have been deployed which use property names
+ * marshalled as NCNames including a colon character; these should
+ * also be rejected but will be allowed for the time being. */
+#define invalid_ncname(xn) (invalid_ncname_ch1((xn)[0]))
+
+/* Extract the namespace prefix declarations from 'atts'. */
+static int declare_nspaces(ne_xml_parser *p, struct element *elm,
+                           const ne_xml_char **atts)
+{
+    int n;
+    
+    for (n = 0; atts && atts[n]; n += 2) {
+        if (strcmp(atts[n], "xmlns") == 0) {
+            /* New default namespace */
+            elm->default_ns = ne_strdup(atts[n+1]);
+        } else if (strncmp(atts[n], "xmlns:", 6) == 0) {
+            struct namespace *ns;
+            
+            /* Reject some invalid NCNames as namespace prefix, and an
+             * empty URI as the namespace URI */
+            if (invalid_ncname(atts[n] + 6) || atts[n+1][0] == '\0') {
+                ne_snprintf(p->error, ERR_SIZE, 
+                            ("XML parse error at line %d: invalid namespace "
+                             "declaration"), ne_xml_currentline(p));
+                return -1;
+            }
+
+            /* New namespace scope */
+            ns = ne_calloc(sizeof(*ns));
+            ns->next = elm->nspaces;
+            elm->nspaces = ns;
+            ns->name = ne_strdup(atts[n]+6); /* skip the xmlns= */
+            ns->uri = ne_strdup(atts[n+1]);
+        }
+    }
+    
+    return 0;
+}
+
+/* Expand an XML qualified name, which may include a namespace prefix
+ * as well as the local part. */
+static int expand_qname(ne_xml_parser *p, struct element *elm,
+                        const ne_xml_char *qname)
+{
+    const ne_xml_char *pfx;
+
+    pfx = strchr(qname, ':');
+    if (pfx == NULL) {
+        struct element *e = elm;
+
+        /* Find default namespace; guaranteed to terminate as the root
+         * element always has default_ns="". */
+        while (e->default_ns == NULL)
+            e = e->parent;
+        
+        elm->name = ne_strdup(qname);
+        elm->nspace = e->default_ns;
+    } else if (invalid_ncname(pfx + 1) || qname == pfx) {
+        ne_snprintf(p->error, ERR_SIZE, 
+                    _("XML parse error at line %d: invalid element name"), 
+                    ne_xml_currentline(p));
+        return -1;
+    } else {
+        const char *uri = resolve_nspace(elm, qname, pfx-qname);
+
+	if (uri) {
+	    elm->name = ne_strdup(pfx+1);
+            elm->nspace = uri;
+	} else {
+	    ne_snprintf(p->error, ERR_SIZE, 
+                        ("XML parse error at line %d: undeclared namespace prefix"),
+                        ne_xml_currentline(p));
+	    return -1;
+	}
+    }
+    return 0;
+}
+
+/* Called with the start of a new element. */
+static void start_element(void *userdata, const ne_xml_char *name,
+			  const ne_xml_char **atts) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm;
+    struct handler *hand;
+    int state = NE_XML_DECLINE;
+
+    if (p->failure) return;
+    
+    if (p->prune) {
+        p->prune++;
+        return;
+    }
+
+    /* Create a new element */
+    elm = ne_calloc(sizeof *elm);
+    elm->parent = p->current;
+    p->current = elm;
+
+    if (declare_nspaces(p, elm, atts) || expand_qname(p, elm, name)) {
+        p->failure = 1;
+        return;
+    }
+
+    /* Find a handler which will accept this element (or abort the parse) */
+    for (hand = elm->parent->handler; hand && state == NE_XML_DECLINE;
+         hand = hand->next) {
+        elm->handler = hand;
+        state = hand->startelm_cb(hand->userdata, elm->parent->state,
+                                  elm->nspace, elm->name, PASS_ATTS(atts));
+    }
+
+    NE_DEBUG(NE_DBG_XML, "XML: start-element (%d, {%s, %s}) => %d\n", 
+             elm->parent->state, elm->nspace, elm->name, state);             
+    
+    if (state > 0)
+        elm->state = state;
+    else if (state == NE_XML_DECLINE)
+        /* prune this branch. */
+        p->prune++;
+    else /* state < 0 => abort parse  */
+        p->failure = state;
+}
+
+/* Destroys an element structure. */
+static void destroy_element(struct element *elm) 
+{
+    struct namespace *this_ns, *next_ns;
+    ne_free(elm->name);
+    /* Free the namespaces */
+    this_ns = elm->nspaces;
+    while (this_ns != NULL) {
+	next_ns = this_ns->next;
+	ne_free(this_ns->name);
+	ne_free(this_ns->uri);
+	ne_free(this_ns);
+	this_ns = next_ns;
+    }
+    if (elm->default_ns)
+        ne_free(elm->default_ns);
+    ne_free(elm);
+}
+
+/* cdata SAX callback */
+static void char_data(void *userdata, const ne_xml_char *data, int len) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm = p->current;
+
+    if (p->failure || p->prune) return;
+    
+    if (elm->handler->cdata_cb) {
+        p->failure = elm->handler->cdata_cb(elm->handler->userdata, elm->state, data, len);
+        NE_DEBUG(NE_DBG_XML, "XML: char-data (%d) returns %d\n", 
+                 elm->state, p->failure);
+    }        
+}
+
+/* Called with the end of an element */
+static void end_element(void *userdata, const ne_xml_char *name) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm = p->current;
+
+    if (p->failure) return;
+	
+    if (p->prune) {
+        if (p->prune-- > 1) return;
+    } else if (elm->handler->endelm_cb) {
+        p->failure = elm->handler->endelm_cb(elm->handler->userdata, elm->state,
+                                             elm->nspace, elm->name);
+        if (p->failure) {
+            NE_DEBUG(NE_DBG_XML, "XML: end-element for %d failed with %d.\n", 
+                     elm->state, p->failure);
+        }
+    }
+    
+    NE_DEBUG(NE_DBG_XML, "XML: end-element (%d, {%s, %s})\n",
+             elm->state, elm->nspace, elm->name);
+
+    /* move back up the tree */
+    p->current = elm->parent;
+    p->prune = 0;
+
+    destroy_element(elm);
+}
+
+#if defined(HAVE_EXPAT) && XML_MAJOR_VERSION > 1
+/* Stop the parser if an entity declaration is hit. */
+static void entity_declaration(void *userData, const XML_Char *entityName,
+                              int is_parameter_entity, const XML_Char *value,
+                              int value_length, const XML_Char *base,
+                              const XML_Char *systemId, const XML_Char *publicId,
+                              const XML_Char *notationName)
+{
+    ne_xml_parser *parser = userData;
+    
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: entity declaration [%s]. Failing.\n",
+             entityName);
+
+    XML_StopParser(parser->parser, XML_FALSE);
+}
+#elif defined(HAVE_EXPAT)
+/* A noop default_handler. */
+static void default_handler(void *userData, const XML_Char *s, int len)
+{
+}
+#endif
+
+/* Find a namespace definition for 'prefix' in given element, where
+ * length of prefix is 'pfxlen'.  Returns the URI or NULL. */
+static const char *resolve_nspace(const struct element *elm, 
+                                  const char *prefix, size_t pfxlen)
+{
+    const struct element *s;
+
+    /* Search up the tree. */
+    for (s = elm; s != NULL; s = s->parent) {
+	const struct namespace *ns;
+	/* Iterate over defined spaces on this node. */
+	for (ns = s->nspaces; ns != NULL; ns = ns->next) {
+	    if (strlen(ns->name) == pfxlen && 
+		memcmp(ns->name, prefix, pfxlen) == 0)
+		return ns->uri;
+	}
+    }
+
+    return NULL;
+}
+
+const char *ne_xml_resolve_nspace(ne_xml_parser *parser, 
+                                  const char *prefix, size_t length)
+{
+    if (prefix) {
+        return resolve_nspace(parser->current, prefix, length);
+    }
+    else {
+        struct element *e = parser->current;
+
+        while (e->default_ns == NULL)
+            e = e->parent;
+
+        return e->default_ns;
+    }
+}
+
+ne_xml_parser *ne_xml_create(void) 
+{
+    ne_xml_parser *p = ne_calloc(sizeof *p);
+    /* Placeholder for the root element */
+    p->current = p->root = ne_calloc(sizeof *p->root);
+    p->root->default_ns = "";
+    p->root->state = 0;
+    strcpy(p->error, _("Unknown error"));
+#ifdef HAVE_EXPAT
+    p->parser = XML_ParserCreate(NULL);
+    if (p->parser == NULL) {
+	abort();
+    }
+    XML_SetElementHandler(p->parser, start_element, end_element);
+    XML_SetCharacterDataHandler(p->parser, char_data);
+    XML_SetUserData(p->parser, (void *) p);
+    XML_SetXmlDeclHandler(p->parser, decl_handler);
+
+    /* Prevent the "billion laughs" attack against expat by disabling
+     * internal entity expansion.  With 2.x, forcibly stop the parser
+     * if an entity is declared - this is safer and a more obvious
+     * failure mode.  With older versions, installing a noop
+     * DefaultHandler means that internal entities will be expanded as
+     * the empty string, which is also sufficient to prevent the
+     * attack. */
+#if XML_MAJOR_VERSION > 1
+    XML_SetEntityDeclHandler(p->parser, entity_declaration);
+#else
+    XML_SetDefaultHandler(p->parser, default_handler);
+#endif
+
+#else /* HAVE_LIBXML */
+    p->parser = xmlCreatePushParserCtxt(&sax_handler, 
+					(void *)p, NULL, 0, NULL);
+    if (p->parser == NULL) {
+	abort();
+    }
+#if LIBXML_VERSION < 20602
+    p->parser->replaceEntities = 1;
+#else
+    /* Enable expansion of entities, and disable network access. */
+    xmlCtxtUseOptions(p->parser, XML_PARSE_NOENT | XML_PARSE_NONET);
+#endif
+
+#endif /* HAVE_LIBXML || HAVE_EXPAT */
+    return p;
+}
+
+void ne_xml_push_handler(ne_xml_parser *p,
+			 ne_xml_startelm_cb *startelm_cb, 
+			 ne_xml_cdata_cb *cdata_cb, 
+			 ne_xml_endelm_cb *endelm_cb,
+			 void *userdata)
+{
+    struct handler *hand = ne_calloc(sizeof(struct handler));
+
+    hand->startelm_cb = startelm_cb;
+    hand->cdata_cb = cdata_cb;
+    hand->endelm_cb = endelm_cb;
+    hand->userdata = userdata;
+
+    /* If this is the first handler registered, update the
+     * base pointer too. */
+    if (p->top_handlers == NULL) {
+	p->root->handler = hand;
+	p->top_handlers = hand;
+    } else {
+	p->top_handlers->next = hand;
+	p->top_handlers = hand;
+    }
+}
+
+int ne_xml_parse_v(void *userdata, const char *block, size_t len) 
+{
+    ne_xml_parser *p = userdata;
+    return ne_xml_parse(p, (const ne_xml_char *)block, len);
+}
+
+#define BOM_UTF8 "\xEF\xBB\xBF" /* UTF-8 BOM */
+
+int ne_xml_parse(ne_xml_parser *p, const char *block, size_t len) 
+{
+    int ret, flag;
+    /* duck out if it's broken */
+    if (p->failure) {
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: Failed; ignoring %" NE_FMT_SIZE_T 
+                 " bytes.\n", len);
+	return p->failure;
+    }
+    if (len == 0) {
+	flag = -1;
+	block = "";
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: End of document.\n");
+    } else {	
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parsing %" NE_FMT_SIZE_T " bytes.\n", len);
+	flag = 0;
+    }
+
+#ifdef NEED_BOM_HANDLING
+    if (p->bom_pos < 3) {
+        NE_DEBUG(NE_DBG_XMLPARSE, "Checking for UTF-8 BOM.\n");
+        while (len > 0 && p->bom_pos < 3 && 
+               block[0] == BOM_UTF8[p->bom_pos]) {
+            block++;
+            len--;
+            p->bom_pos++;
+        }
+        if (len == 0)
+            return 0;
+        if (p->bom_pos == 0) {
+            p->bom_pos = 3; /* no BOM */
+        } else if (p->bom_pos > 0 && p->bom_pos < 3) {
+            strcpy(p->error, _("Invalid Byte Order Mark"));
+            return p->failure = 1;
+        }
+    }
+#endif
+
+    /* Note, don't write a parser error if p->failure, since an error
+     * will already have been written in that case. */
+#ifdef HAVE_EXPAT
+    ret = XML_Parse(p->parser, block, len, flag);
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: XML_Parse returned %d\n", ret);
+    if (ret == 0 && p->failure == 0) {
+	ne_snprintf(p->error, ERR_SIZE,
+		    "XML parse error at line %" NE_FMT_XML_SIZE ": %s", 
+		    XML_GetCurrentLineNumber(p->parser),
+		    XML_ErrorString(XML_GetErrorCode(p->parser)));
+	p->failure = 1;
+        NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parse error: %s\n", p->error);
+    }
+#else
+    ret = xmlParseChunk(p->parser, block, len, flag);
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: xmlParseChunk returned %d\n", ret);
+    /* Parse errors are normally caught by the sax_error() callback,
+     * which clears p->valid. */
+    if (p->parser->errNo && p->failure == 0) {
+	ne_snprintf(p->error, ERR_SIZE, "XML parse error at line %d", 
+		    ne_xml_currentline(p));
+	p->failure = 1;
+        NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parse error: %s\n", p->error);
+    }
+#endif
+    return p->failure;
+}
+
+int ne_xml_failed(ne_xml_parser *p)
+{
+    return p->failure;
+}
+
+void ne_xml_destroy(ne_xml_parser *p) 
+{
+    struct element *elm, *parent;
+    struct handler *hand, *next;
+
+    /* Free up the handlers on the stack: the root element has the
+     * pointer to the base of the handler stack. */
+    for (hand = p->root->handler; hand!=NULL; hand=next) {
+	next = hand->next;
+	ne_free(hand);
+    }
+
+    /* Clean up remaining elements */
+    for (elm = p->current; elm != p->root; elm = parent) {
+	parent = elm->parent;
+	destroy_element(elm);
+    }
+
+    /* free root element */
+    ne_free(p->root);
+
+#ifdef HAVE_EXPAT
+    XML_ParserFree(p->parser);
+    if (p->encoding) ne_free(p->encoding);
+#else
+    xmlFreeParserCtxt(p->parser);
+#endif
+
+    ne_free(p);
+}
+
+void ne_xml_set_error(ne_xml_parser *p, const char *msg)
+{
+    ne_snprintf(p->error, ERR_SIZE, "%s", msg);
+}
+
+#ifdef HAVE_LIBXML
+static void sax_error(void *ctx, const char *msg, ...)
+{
+    ne_xml_parser *p = ctx;
+    va_list ap;
+    char buf[1024];
+
+    va_start(ap, msg);
+    ne_vsnprintf(buf, 1024, msg, ap);
+    va_end(ap);
+
+    if (p->failure == 0) {
+        ne_snprintf(p->error, ERR_SIZE, 
+                    _("XML parse error at line %d: %s"),
+                    p->parser->input->line, buf);
+        p->failure = 1;
+    }
+}
+#endif
+
+const char *ne_xml_get_error(ne_xml_parser *p)
+{
+    return p->error;
+}
+
+const char *
+ne_xml_get_attr(ne_xml_parser *p, const char **attrs, 
+		const char *nspace, const char *name)
+{
+    int n;
+
+    for (n = 0; attrs[n] != NULL; n += 2) {
+	char *pnt = strchr(attrs[n], ':');
+
+	if (!nspace && !pnt && strcmp(attrs[n], name) == 0) {
+	    return attrs[n+1];
+	} else if (nspace && pnt) {
+	    /* If a namespace is given, and the local part matches,
+	     * then resolve the namespace and compare that too. */
+	    if (strcmp(pnt + 1, name) == 0) {
+		const char *uri = resolve_nspace(p->current, 
+						 attrs[n], pnt - attrs[n]);
+		if (uri && strcmp(uri, nspace) == 0)
+		    return attrs[n+1];
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+int ne_xml_mapid(const struct ne_xml_idmap map[], size_t maplen,
+                 const char *nspace, const char *name)
+{
+    size_t n;
+    
+    for (n = 0; n < maplen; n++)
+        if (strcmp(name, map[n].name) == 0 &&
+            strcmp(nspace, map[n].nspace) == 0)
+            return map[n].id;
+    
+    return 0;
+}
diff --git a/net/mmt/neon/src/ne_xml.h b/net/mmt/neon/src/ne_xml.h
new file mode 100644
index 0000000..7fcd477
--- /dev/null
+++ b/net/mmt/neon/src/ne_xml.h
@@ -0,0 +1,165 @@
+/* 
+   neon XML parser interface
+   Copyright (C) 1999-2007, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_XML_H
+#define NE_XML_H
+
+#include <sys/types.h> /* for size_t */
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* The neon XML interface filters a streamed XML tree through a stack
+ * of SAX "handlers".  A handler is made up of three callbacks
+ * (start-element, char-data, end-element).  Each start-element event
+ * is passed to each handler in the stack in turn until one until one
+ * accepts the element.  This handler then receives subsequent
+ * char-data and end-element events for the element.
+ *
+ * For each new start-element event, the search up the handler stack
+ * begins with the handler for the parent element (for the root
+ * element, at the base of the stack).
+ *
+ * For each accepted element, a "state" integer is stored, which is
+ * passed to the corresponding char-data and end-element callbacks for
+ * the element.  This integer is also passed to the start-element
+ * callback of child elements so they can determine context.
+ *
+ * If no handler in the stack accepts a particular element, it (and
+ * its children, if any) is ignored. */
+
+#define NE_XML_DECLINE (0)
+#define NE_XML_ABORT (-1)
+
+/* A start-element callback for element with given namespace/name.
+ * The callback may return:
+ *   <0  =>  abort the parse (NE_XML_ABORT)
+ *    0  =>  decline this element (NE_XML_DECLINE)
+ *   >0  =>  accept this element; value is state for this element.
+ *
+ * The 'parent' integer is the state returned by the handler of the 
+ * parent element.   The attributes array gives name/value pairs
+ * in atts[n] and atts[n+1] from n=0 up to atts[n]==NULL. */
+typedef int ne_xml_startelm_cb(void *userdata, int parent,
+                               const char *nspace, const char *name,
+                               const char **atts);
+
+/* state for the root element */
+#define NE_XML_STATEROOT (0)
+
+/* Character data callback; may return non-zero to abort the parse. */
+typedef int ne_xml_cdata_cb(void *userdata, int state,
+                            const char *cdata, size_t len);
+/* End element callback; may return non-zero to abort the parse. */
+typedef int ne_xml_endelm_cb(void *userdata, int state, 
+                             const char *nspace, const char *name);
+
+typedef struct ne_xml_parser_s ne_xml_parser;
+
+/* Create an XML parser. */
+ne_xml_parser *ne_xml_create(void);
+
+/* Push a new handler on the stack of parser 'p'. 'cdata' and/or
+ * 'endelm' may be NULL; startelm must be non-NULL. */
+void ne_xml_push_handler(ne_xml_parser *p,
+                         ne_xml_startelm_cb *startelm, 
+                         ne_xml_cdata_cb *cdata,
+                         ne_xml_endelm_cb *endelm,
+                         void *userdata);
+
+/* ne_xml_failed returns non-zero if there was an error during
+ * parsing, or zero if the parse completed successfully.  The return
+ * value is equal to that of the last ne_xml_parse() call for this
+ * parser object. */
+int ne_xml_failed(ne_xml_parser *p);
+
+/* Set error string for parser.  (The string may be truncated
+ * internally). */
+void ne_xml_set_error(ne_xml_parser *p, const char *msg);
+
+/* Return the error string (and never NULL).  After ne_xml_failed
+ * returns >0, this will describe the parse error.  Otherwise it will
+ * be a default error string. */
+const char *ne_xml_get_error(ne_xml_parser *p);
+
+/* Parse the given block of input of length len.  Parser must be
+ * called with len=0 to signify the end of the document (for that
+ * case, the block argument is ignored).  Returns zero on success, or
+ * non-zero on error: for an XML syntax error, a positive number is
+ * returned; if parsing is aborted by a caller-supplied callback, that
+ * callback's return value is returned. */
+int ne_xml_parse(ne_xml_parser *p, const char *block, size_t len);
+
+/* As ne_xml_parse, casting (ne_xml_parser *)userdata internally.
+ * (This function can be passed to ne_add_response_body_reader) */
+int ne_xml_parse_v(void *userdata, const char *block, size_t len);
+
+/* Return current line of document during parsing or after parsing is
+ * complete. */
+int ne_xml_currentline(ne_xml_parser *p);
+
+/* From a start_element callback which was passed 'attrs' using given
+ * parser, return attribute of given name and namespace.  If nspace is
+ * NULL, no namespace resolution is performed.  Note that this call is
+ * context-specific; if called outside a start_element callback,
+ * behaviour is undefined. */
+const char *ne_xml_get_attr(ne_xml_parser *parser,
+			    const char **attrs, const char *nspace, 
+			    const char *name);
+
+/* From a start_element callback, resolve a given XML Namespace
+ * prefix, if defined.  Given a non-NULL prefix, returns the namespace
+ * URI which corresponds to the prefix 'prefix' (of length 'length'),
+ * or NULL if no such namespace prefix is defined.  Given a NULL
+ * prefix, returns the default namespace URI or the empty string if
+ * none is defined.  Note that this call is context-specific; if
+ * called outside a start_element callback, behaviour is undefined. */
+const char *ne_xml_resolve_nspace(ne_xml_parser *parser, 
+                                  const char *prefix, size_t length);
+
+/* Return the encoding of the document being parsed.  May return NULL
+ * if no encoding is defined or if the XML declaration has not yet
+ * been parsed. */
+const char *ne_xml_doc_encoding(const ne_xml_parser *p);
+
+/* Destroy the parser object. */
+void ne_xml_destroy(ne_xml_parser *p);
+
+/* A utility interface for mapping {nspace, name} onto an integer. */
+struct ne_xml_idmap {
+    const char *nspace, *name;
+    int id;
+};
+
+/* Return the size of an idmap array */
+#define NE_XML_MAPLEN(map) (sizeof(map) / sizeof(struct ne_xml_idmap))
+
+/* Return the 'id' corresponding to {nspace, name}, or zero. */
+int ne_xml_mapid(const struct ne_xml_idmap map[], size_t maplen,
+                 const char *nspace, const char *name);
+
+/* media type, appropriate for adding to a Content-Type header */
+#define NE_XML_MEDIA_TYPE "application/xml"
+
+NE_END_DECLS
+
+#endif /* NE_XML_H */
diff --git a/net/mmt/neon/src/ne_xmlreq.c b/net/mmt/neon/src/ne_xmlreq.c
new file mode 100644
index 0000000..c4fbf5a
--- /dev/null
+++ b/net/mmt/neon/src/ne_xmlreq.c
@@ -0,0 +1,110 @@
+/* 
+   XML/HTTP response handling
+   Copyright (C) 2004-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "ne_internal.h"
+#include "ne_xmlreq.h"
+#include "ne_basic.h"
+#include "ne_string.h"
+
+/* Handle an XML response parse error, setting session error string
+ * and closing the connection. */
+static int parse_error(ne_session *sess, ne_xml_parser *parser)
+{
+    ne_set_error(sess, _("Could not parse response: %s"),
+                 ne_xml_get_error(parser));
+    ne_close_connection(sess);
+    return NE_ERROR;
+}
+
+int ne_xml_parse_response(ne_request *req, ne_xml_parser *parser)
+{
+    char buf[8000];
+    ssize_t bytes;
+    int ret = 0;
+
+    while ((bytes = ne_read_response_block(req, buf, sizeof buf)) > 0) {
+        ret = ne_xml_parse(parser, buf, bytes);
+        if (ret)
+            return parse_error(ne_get_session(req), parser);
+    }
+
+    if (bytes == 0) {
+        /* Tell the parser that end of document was reached: */
+        if (ne_xml_parse(parser, NULL, 0) == 0)
+            return NE_OK;
+        else
+            return parse_error(ne_get_session(req), parser);
+    } else {
+        return NE_ERROR;
+    }    
+}
+
+/* Returns non-zero if given content-type is an XML media type,
+ * following the RFC 3023 rules. */
+static int media_type_is_xml(const ne_content_type *ctype)
+{
+    size_t stlen;
+
+    return 
+        (ne_strcasecmp(ctype->type, "text") == 0
+         && ne_strcasecmp(ctype->subtype, "xml") == 0)
+        || (ne_strcasecmp(ctype->type, "application") == 0
+            && ne_strcasecmp(ctype->subtype, "xml") == 0)
+        || ((stlen = strlen(ctype->subtype)) > 4
+            && ne_strcasecmp(ctype->subtype + stlen - 4, "+xml") == 0);
+}
+
+int ne_xml_dispatch_request(ne_request *req, ne_xml_parser *parser)
+{
+    int ret;
+
+    do {
+        int parseit = 0;
+
+        ret = ne_begin_request(req);
+        if (ret) break;
+        
+        if (ne_get_status(req)->klass == 2) {
+            ne_content_type ctype;
+            
+            if (ne_get_content_type(req, &ctype) == 0) {
+                parseit = media_type_is_xml(&ctype);
+                ne_free(ctype.value);
+            }
+        }
+
+        if (parseit)
+            ret = ne_xml_parse_response(req, parser);
+        else
+            ret = ne_discard_response(req);
+        
+        if (ret == NE_OK)
+            ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    return ret;
+}
+
diff --git a/net/mmt/neon/src/ne_xmlreq.h b/net/mmt/neon/src/ne_xmlreq.h
new file mode 100644
index 0000000..1bf667d
--- /dev/null
+++ b/net/mmt/neon/src/ne_xmlreq.h
@@ -0,0 +1,51 @@
+/* 
+   XML/HTTP response handling
+   Copyright (C) 2004-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_XMLREQ_H
+#define NE_XMLREQ_H
+
+#include "ne_request.h"
+#include "ne_xml.h"
+
+NE_BEGIN_DECLS
+
+/* Read the HTTP response body using calls to ne_read_response_block
+ * (so must be enclosed by ne_begin_request/ne_end_request calls), and
+ * parse it as an XML document, using the given parser.  Returns NE_*
+ * error codes.  If an XML parse error occurs, the session error
+ * string is set to the XML parser's error string, and NE_ERROR is
+ * returned. */
+int ne_xml_parse_response(ne_request *req, ne_xml_parser *parser);
+
+/* Dispatch the HTTP request, parsing the response body as an XML
+ * document using the given parser, if the response status class is
+ * 2xx and an XML media type is specified for the response entity.  If
+ * a non-2xx response code is given, or a non-XML media type is
+ * specified, then the response body will be silently discarded.
+ *
+ * Returns NE_* error codes.  If an XML parse error occurs, the
+ * session error string is set to the XML parser's error string, and
+ * NE_ERROR is returned. */
+int ne_xml_dispatch_request(ne_request *req, ne_xml_parser *parser);
+
+NE_END_DECLS
+
+#endif /* NE_XMLREQ_H */
diff --git a/net/mmt/neon/src/neon.vers b/net/mmt/neon/src/neon.vers
new file mode 100644
index 0000000..bed99c2
--- /dev/null
+++ b/net/mmt/neon/src/neon.vers
@@ -0,0 +1,22 @@
+# GNU linker version script for neon.
+# All symbols in <= 0.28.x use default unversioned.
+
+NEON_0_29 {
+    ne_iaddr_raw;
+    ne_sock_writev;
+    ne_sock_fullwritev;
+    ne_sock_set_error;
+    ne_sock_proxy;
+    ne_session_system_proxy;
+    ne_session_socks_proxy;
+    ne_acl3744_set;
+    ne_buffer_qappend;
+    ne_strnqdup;
+};
+
+NEON_0_30 {
+    ne_ssl_clicert_import;
+    ne_addr_canonical;
+    ne_ssl_context_get_flag;
+    ne_set_addrlist2;
+};
diff --git a/net/mmt/ntp/HOWTO b/net/mmt/ntp/HOWTO
new file mode 100644
index 0000000..cf0e7429
--- /dev/null
+++ b/net/mmt/ntp/HOWTO
@@ -0,0 +1,177 @@
+The goal of ntpclient is not only to set your computer's clock
+right once, but keep it there.
+
+First, a note on typical 1990's and 2000's computer crystals.  They
+are truly pathetic.  A "real" crystal oscillator (TCXO) usually has
+an initial set error of less than 5 ppm, and variation over time, voltage,
+and temperature measured in tenths of a ppm (and an OCXO can reach 0.3 ppm
+stability over ten years and 85C temperature swing).  The devices used
+in conventional PC motherboards and single board computers, however,
+often have initial set errors up to 150 ppm, and will vary 5 ppm over
+the course of a day-night cycle in a pseudo-air-conditioned space.
+
+[Operating system software can sometimes exacerbate the problem.  I
+have seen some i686 Red Hat 7.3 systems run the clock at 512 Hz, or 953
+microseconds per tick, giving a built in 64 ppm error.  Even the normally
+exemplary DEC Alpha has, when run with Linux, a truly awful calibration
+scheme; Linux runs it with a nominal ticks per second of 1024, which
+gives a tick value of 977, theoretical additional error -448 ppm, actual
+frequency observed -443.7 ppm.]
+
+Still, the pattern is clear: the first and largest error of a crystal
+is its initial set error.  I strongly urge the calibration of each computer,
+and storing its frequency error in a non-volatile medium, before you
+do anything else with time setting and locking.  While you could do it
+in a few seconds using an accurate frequency counter, below I show a
+software-only method using ntpclient and a high quality NTP server.
+
+To perform the activities described, you need a way to control and monitor
+your system's clock -- both its frequency and value.  On Linux, the
+kernel API is described in adjtimex(2).  There are two programs that
+I know of that provide shell-level access to this interface, both called
+adjtimex(1).
+
+One is written by Steven Dick and Jim Van Zandt, see the adjtimex* files in
+http://metalab.unc.edu/pub/Linux/system/admin/time/
+It uses long options, and includes some interesting functionality beyond
+the basic exposure of adjtimex(2).
+
+I (Larry Doolittle) wrote the other; it uses short options, and has no
+bloat^H^H^H^H^Hextra features.  I include the code here for a standalone
+version; it is also incorporated into busybox (http://www.busybox.net),
+although you may have to select it at compile time, like any other component.
+
+Fortunately (and not coincidentally) the core functions of the two adjtimex
+programs can be used interchangeably, as long as you only use the short option
+variant of the Dick/Van Zandt adjtimex.  The options discussed here are:
+       -f    frequency (integer kernel units)
+       -o    time offset in microseconds
+       -t    kernel tick (microseconds per jiffy)
+
+First, set the time approximately right, as root:
+   ntpclient -s -h $NTPHOST
+You should see a single line printed like
+36765 4980.373    1341.0     39.7  956761.4    839.2  0
+Get used to this line: column headers are
+ 1. day since 1900
+ 2. seconds since midnight
+ 3. elapsed time for NTP transaction (microseconds)
+ 4. internal server delay (microseconds)
+ 5. clock difference between your computer and the NTP server (microseconds)
+ 6. dispersion reported by server (microseconds)
+ 7. your computer's adjtimex frequency (ppm * 65536)
+So in the example above, your computer's clock was a bit more than
+0.95 seconds fast, compared to the clock on $NTPHOST.
+Now check that the clock setting worked.
+   ntpclient -c 1 -h $NTPHOST
+36765 4993.512    1345.0     40.9    3615.3    839.2  0
+So now the time difference is only a few milliseconds.
+
+On to measure the frequency calibration for your system.
+If you're in a hurry, it's OK to only spend 20 minutes on this step.
+    ntpclient -i 60 -c 20 -h $NTPHOST >$(hostname).ntp.log &
+
+Otherwise, you will learn much more about your system and its communication
+with the NTP server by letting the log run for 24 hours.
+    ntpclient -i 300 -c 288 -h $NTPHOST >$(hostname).ntp.log &
+
+Things to watch for in the above log:
+
+If the last column (kernel frequency fine tune) ever changes, you haven't
+turned off other time adjustment programs.  AFAIK the only programs around
+that would move this number are ntpclient and xntpd.  On most out-of-the-box
+systems, that last column should start zero and stay zero.
+
+Use gnuplot to plot the resulting file as follows:
+   plot "HOSTNAME.ntp.log" using (($1-36765)*86400+$2):5:($3+$6) with yerrorbars
+This shows time error (microseconds) as a function of elapsed time (seconds).
+The error bars show the uncertainty in the measurement.  Ideally, it would
+be a smooth, straight line, where the slope represents the frequency error
+of your crystal.
+
+If an occasional point is both off-center and has a large error bar, it shows
+a transaction got delayed somewhere in the process, either inside the server,
+or one of the two UDP packet propagation steps.  This is normal, and ntpclient
+can deal with those quite well.  If points are not evenly spaced on the
+horizontal axis, packets were actually lost; this is less common, but still OK.
+
+If the error bar becomes suddenly large, and takes a few minutes to slowly
+recover, your NTP host (presumably xntpd) had problems communicating with
+_its_ server, and reported that problem to you by increasing its "dispersion"
+(this is a hack, required by xntpd's core incorrect assumption that errors
+in network delays have Gaussian statistics; ntpclient does not have this flaw).
+
+If there are sudden large, persistent steps in error, some other program is
+making step changes to time.  Check for, e.g., ntpdate run as a cron job.
+If your client machine is OK, check for problems on the _host_ machine.
+
+Assuming the graph above is clean, and has non-garbled data for the first
+and last points, you can run it through the enclosed awk script (rate.awk)
+to determine the appropriate frequency value.
+$ awk -f rate.awk <test.dat
+delta-t 119400 seconds
+delta-o -142308 useconds
+slope -1.19186 ppm
+old frequency -1240000 ( -18.9209 ppm)
+new frequency -1318109 ( -20.1127 ppm)
+$
+
+For now, you should plug in the new frequency value
+   adjtimex -f -1318109
+Then reset the clock
+   ntpclient -s -h $NTPHOST
+and ponder how it makes sense in _your_ (possibly embedded) environment
+to have the number -1318109 applied via adjtimex every time your machine
+boots.  Or, simpler still, combine these two steps using a post-2005 version:
+   ntpclient -f -1318109 -s -h $NTPHOST
+
+If the frequency offset (absolute value) is greater than about 230 ppm
+(15073280), you have a problem: you may be able to fix it with the -t
+option to adjtimex, or you need to hack phaselock.c, that has a
+maximum adjustment extent of +/- 250 ppm built into phaselock.c (change
+the #define MAX_CORRECT and rebuild ntpclient).  I'd like to suggest that
+you replace the defective crystal instead, but I understand that is rarely
+practical.
+
+On to ntpclient -l.  This is actually easy, if you performed and understood
+the previous steps.  Run
+  ntpclient -l -h $NTPHOST
+in the background.  It will make small (probably less than 3 ppm) adjustments
+to the system frequency to keep the clocks locked.  Typical performance over
+Ethernet (even through a few routers) is a worst case error of +/- 10 ms.
+
+I won't try to tell you _where_ to put the boot time commands.  They should
+boil down to:
+   adjtimex -f $NONVOLATILE_MEMORY_VALUE
+   ntpclient -s -i 15 -g 10000 -h $NTPHOST
+   ntpclient -l -h $NTPHOST >some_log_file
+The second line makes explicit the retries that may be required for this
+UDP-based time protocol.  If the first time request takes longer than 10000
+microseconds to resolve, or the packets get lost, it instructs ntpclient to
+try again 15 seconds later (the minimum retry period mandated by RFC-4330),
+and it won't exit until it gets such a suitable response.
+
+As of 2006, ntpclient can in theory combine the three lines above into one:
+   ntpclient -f $NONVOLATILE_MEMORY_VALUE -s -l -i 600 -g 10000 -h $NTPHOST >some_log_file
+This can streamline the startup process, since you may be able to avoid a
+layer of shell scripting.  On the other hand, it is less tested, and there
+is no (current) means to independently set the packet interval for the
+set and lock phases.
+
+It's an interesting question how sensitive the boot process should be
+to the time set process.  If you have a battery backed hardware clock,
+there's not much problem running for a while without a network-accurate
+system clock.  In that case you could put both ntpclient commands into a
+background script, and the only possible issue is the sudden (but probably
+small) warp of the clock at the indefinite time in the boot sequence when
+ntpclient gets its acceptable answer.  On the other hand, some embedded
+computers have no clue what time it is until the network responds.  Any
+files created will be marked Jan 1 1970, and other application-dependent
+issues may arise if there is a nonsense time on the system during later
+parts of the boot sequence.  Then you may well want to enforce completion
+of the first ntpclient before starting your application.  If this is too
+drastic for you, and you want a fallback mode when the time server is dead,
+add a "-c 5" switch to the end of that ntpclient command, giving at most 5
+retries, if something goes wrong with the time set.  For that approach to be
+useful, consider patching the source to lower the minimum packet send
+interval from the RFC-4330-mandated 15 seconds.
diff --git a/net/mmt/ntp/Makefile b/net/mmt/ntp/Makefile
new file mode 100644
index 0000000..34cef76
--- /dev/null
+++ b/net/mmt/ntp/Makefile
@@ -0,0 +1,37 @@
+# A long time ago, far, far away, under Solaris, you needed to
+#    CFLAGS += -xO2 -Xc
+#    LDLIBS += -lnsl -lsocket
+# To cross-compile
+#    CC = arm-linux-gcc
+# To check for lint
+#    CFLAGS += -Wpointer-arith -Wcast-align -Wcast-qual -Wshadow -Wundef \
+#     -Waggregate-return -Wnested-externs -Winline -Wwrite-strings -Wstrict-prototypes
+
+# This is old-school networking code, making the traditional cast between
+# struct sockaddr* and struct sockaddr_in*.  Thus a modern gcc needs:
+CFLAGS += -fno-strict-aliasing
+
+CFLAGS += -std=c89
+CFLAGS += -W -Wall
+CFLAGS += -O2
+# CFLAGS += -DPRECISION_SIOCGSTAMP
+#CFLAGS += -DENABLE_DEBUG
+#CFLAGS += -DENABLE_REPLAY
+# CFLAGS += -DUSE_OBSOLETE_GETTIMEOFDAY
+
+LDFLAGS += -lrt
+
+all: ntpclient
+
+test: ntpclient
+	./ntpclient -d -r <test.dat
+
+ntpclient: ntpclient.o phaselock.o
+	$(CC) -o ntpclient ntpclient.o phaselock.o $(LDFLAGS) 
+
+ntpclient.o phaselock.o: ntpclient.h
+
+adjtimex: adjtimex.o
+
+clean:
+	rm -f ntpclient adjtimex *.o
diff --git a/net/mmt/ntp/ntp.gyp b/net/mmt/ntp/ntp.gyp
new file mode 100644
index 0000000..6ec9ea7
--- /dev/null
+++ b/net/mmt/ntp/ntp.gyp
@@ -0,0 +1,80 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libntp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'ntp',
+      'sources': [
+        'ntpclient.c',
+        'phaselock.c',
+      ],
+      'defines': [
+        'LIBNTP'
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '-std=c89',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lrt',
+          ],
+        }],
+      ],
+    },
+  ],
+}
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
new file mode 100644
index 0000000..802d176
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.c
@@ -0,0 +1,743 @@
+/*
+ * ntpclient.c - NTP client
+ *
+ * Copyright (C) 1997, 1999, 2000, 2003, 2006, 2007, 2010  Larry Doolittle  <larry@doolittle.boa.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Write more documentation  :-(
+ *      - Support leap second processing
+ *      - Support IPv6
+ *      - Support multiple (interleaved) servers
+ *
+ *  Compile with -DPRECISION_SIOCGSTAMP if your machine really has it.
+ *  There are patches floating around to add this to Linux, but
+ *  usually you only get an answer to the nearest jiffy.
+ *  Hint for Linux hacker wannabes: look at the usage of get_fast_time()
+ *  in net/core/dev.c, and its definition in kernel/time.c .
+ *
+ *  If the compile gives you any flak, check below in the section
+ *  labelled "XXX fixme - non-automatic build configuration".
+ */
+
+#define _POSIX_C_SOURCE 199309
+#define _BSD_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>     /* gethostbyname */
+#include <arpa/inet.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#ifdef PRECISION_SIOCGSTAMP
+#include <sys/ioctl.h>
+#endif
+#ifdef USE_OBSOLETE_GETTIMEOFDAY
+#include <sys/time.h>
+#endif
+
+#include "ntpclient.h"
+
+/* Default to the RFC-4330 specified value */
+#ifndef MIN_INTERVAL
+#define MIN_INTERVAL 15
+#endif
+
+#ifdef ENABLE_DEBUG
+#define DEBUG_OPTION "d"
+int debug=0;
+#else
+#define DEBUG_OPTION
+#define debug 0
+#endif
+
+#ifdef ENABLE_REPLAY
+#define  REPLAY_OPTION   "r"
+#else
+#define  REPLAY_OPTION
+#endif
+
+/* global tuning parameter */
+extern double min_delay;
+
+/* prototype for function defined in phaselock.c */
+extern int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq);
+
+extern char *optarg;  /* according to man 2 getopt */
+
+#include <stdint.h>
+typedef uint32_t u32;  /* universal for C99 */
+/* typedef u_int32_t u32;   older Linux installs? */
+
+/* XXX fixme - non-automatic build configuration */
+#ifdef __linux__
+#include <sys/utsname.h>
+#include <sys/time.h>
+#include <sys/timex.h>
+#include <netdb.h>
+#else
+extern struct hostent *gethostbyname(const char *name);
+extern int h_errno;
+#define herror(hostname) \
+	fprintf(stderr,"Error %d looking up hostname %s\n", h_errno,hostname)
+#endif
+/* end configuration for host systems */
+
+#define JAN_1970        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define NTP_PORT (123)
+
+/* How to multiply by 4294.967296 quickly (and not quite exactly)
+ * without using floating point or greater than 32-bit integers.
+ * If you want to fix the last 12 microseconds of error, add in
+ * (2911*(x))>>28)
+ */
+#define NTPFRAC(x) ( 4294*(x) + ( (1981*(x))>>11 ) )
+
+/* The reverse of the above, needed if we want to set our microsecond
+ * clock (via clock_settime) based on the incoming time in NTP format.
+ * Basically exact.
+ */
+#define USEC(x) ( ( (x) >> 12 ) - 759 * ( ( ( (x) >> 10 ) + 32768 ) >> 16 ) )
+
+/* Converts NTP delay and dispersion, apparently in seconds scaled
+ * by 65536, to microseconds.  RFC-1305 states this time is in seconds,
+ * doesn't mention the scaling.
+ * Should somehow be the same as 1000000 * x / 65536
+ */
+#define sec2u(x) ( (x) * 15.2587890625 )
+
+struct ntptime {
+	unsigned int coarse;
+	unsigned int fine;
+};
+
+struct ntp_control {
+	u32 time_of_send[2];
+	int live;
+	int set_clock;   /* non-zero presumably needs root privs */
+	int probe_count;
+	int cycle_time;
+	int goodness;
+	int cross_check;
+	char serv_addr[4];
+};
+
+/* prototypes for some local routines */
+static void send_packet(int usd, u32 time_sent[2]);
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time);
+/* static void udp_handle(int usd, char *data, int data_len, struct sockaddr *sa_source, int sa_len); */
+
+static int get_current_freq(void)
+{
+	/* OS dependent routine to get the current value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes=0;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static int set_freq(int new_freq)
+{
+	/* OS dependent routine to set a new value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes = ADJ_FREQUENCY;
+	txc.freq = new_freq;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static void set_time(struct ntptime *new)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to set the system clock
+	 */
+	struct timespec tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_nsec = USEC(new->fine)*1000;
+	if (clock_settime(CLOCK_REALTIME, &tv_set)<0) {
+		perror("clock_settime");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.9lu\n", tv_set.tv_sec, tv_set.tv_nsec);
+	}
+#else
+	/* Traditional Linux way to set the system clock
+	 */
+	struct timeval tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_usec = USEC(new->fine);
+	if (settimeofday(&tv_set,NULL)<0) {
+		perror("settimeofday");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.6lu\n", tv_set.tv_sec, tv_set.tv_usec);
+	}
+#endif
+}
+
+static void ntpc_gettime(u32 *time_coarse, u32 *time_fine)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to get the system time
+	 */
+	struct timespec now;
+	clock_gettime(CLOCK_REALTIME, &now);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_nsec/1000);
+#else
+	/* Traditional Linux way to get the system time
+	 */
+	struct timeval now;
+	gettimeofday(&now, NULL);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_usec);
+#endif
+}
+
+static void send_packet(int usd, u32 time_sent[2])
+{
+	u32 data[12];
+#define LI 0
+#define VN 3
+#define MODE 3
+#define STRATUM 0
+#define POLL 4
+#define PREC -6
+
+	if (debug) fprintf(stderr,"Sending ...\n");
+	if (sizeof data != 48) {
+		fprintf(stderr,"size error\n");
+		return;
+	}
+	memset(data,0,sizeof data);
+	data[0] = htonl (
+		( LI << 30 ) | ( VN << 27 ) | ( MODE << 24 ) |
+		( STRATUM << 16) | ( POLL << 8 ) | ( PREC & 0xff ) );
+	data[1] = htonl(1<<16);  /* Root Delay (seconds) */
+	data[2] = htonl(1<<16);  /* Root Dispersion (seconds) */
+	ntpc_gettime(time_sent, time_sent+1);
+	data[10] = htonl(time_sent[0]); /* Transmit Timestamp coarse */
+	data[11] = htonl(time_sent[1]); /* Transmit Timestamp fine   */
+	send(usd,data,48,0);
+}
+
+static void get_packet_timestamp(int usd, struct ntptime *udp_arrival_ntp)
+{
+#ifdef PRECISION_SIOCGSTAMP
+	/* XXX broken */
+	struct timeval udp_arrival;
+	if ( ioctl(usd, SIOCGSTAMP, &udp_arrival) < 0 ) {
+		perror("ioctl-SIOCGSTAMP");
+		gettimeofday(&udp_arrival, NULL);
+	}
+	udp_arrival_ntp->coarse = udp_arrival.tv_sec + JAN_1970;
+	udp_arrival_ntp->fine   = NTPFRAC(udp_arrival.tv_usec);
+#else
+	(void) usd;  /* not used */
+	ntpc_gettime(&udp_arrival_ntp->coarse, &udp_arrival_ntp->fine);
+#endif
+}
+
+static int check_source(int data_len, struct sockaddr *sa_source, unsigned int sa_len, struct ntp_control *ntpc)
+{
+	struct sockaddr_in *sa_in=(struct sockaddr_in *)sa_source;
+	(void) sa_len;  /* not used */
+	if (debug) {
+		printf("packet of length %d received\n",data_len);
+		if (sa_source->sa_family==AF_INET) {
+			printf("Source: INET Port %d host %s\n",
+				ntohs(sa_in->sin_port),inet_ntoa(sa_in->sin_addr));
+		} else {
+			printf("Source: Address family %d\n",sa_source->sa_family);
+		}
+	}
+	/* we could check that the source is the server we expect, but
+	 * Denys Vlasenko recommends against it: multihomed hosts get it
+	 * wrong too often. */
+#if 0
+	if (memcmp(ntpc->serv_addr, &(sa_in->sin_addr), 4)!=0) {
+		return 1;  /* fault */
+	}
+#else
+	(void) ntpc; /* not used */
+#endif
+	if (NTP_PORT != ntohs(sa_in->sin_port)) {
+		return 1;  /* fault */
+	}
+	return 0;
+}
+
+static double ntpdiff( struct ntptime *start, struct ntptime *stop)
+{
+	int a;
+	unsigned int b;
+	a = stop->coarse - start->coarse;
+	if (stop->fine >= start->fine) {
+		b = stop->fine - start->fine;
+	} else {
+		b = start->fine - stop->fine;
+		b = ~b;
+		a -= 1;
+	}
+
+	return a*1.e6 + b * (1.e6/4294967296.0);
+}
+
+/* Does more than print, so this name is bogus.
+ * It also makes time adjustments, both sudden (-s)
+ * and phase-locking (-l).
+ * sets *error to the number of microseconds uncertainty in answer
+ * returns 0 normally, 1 if the message fails sanity checks
+ */
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time)
+{
+/* straight out of RFC-1305 Appendix A */
+	int li, vn, mode, stratum, poll, prec;
+	int delay, disp, refid;
+	struct ntptime reftime, orgtime, rectime, xmttime;
+	double el_time,st_time,skew1,skew2;
+	int freq;
+#ifdef ENABLE_DEBUG
+	const char *drop_reason=NULL;
+#endif
+
+#define Data(i) ntohl(((u32 *)data)[i])
+	li      = Data(0) >> 30 & 0x03;
+	vn      = Data(0) >> 27 & 0x07;
+	mode    = Data(0) >> 24 & 0x07;
+	stratum = Data(0) >> 16 & 0xff;
+	poll    = Data(0) >>  8 & 0xff;
+	prec    = Data(0)       & 0xff;
+	if (prec & 0x80) prec|=0xffffff00;
+	delay   = Data(1);
+	disp    = Data(2);
+	refid   = Data(3);
+	reftime.coarse = Data(4);
+	reftime.fine   = Data(5);
+	orgtime.coarse = Data(6);
+	orgtime.fine   = Data(7);
+	rectime.coarse = Data(8);
+	rectime.fine   = Data(9);
+	xmttime.coarse = Data(10);
+	xmttime.fine   = Data(11);
+#undef Data
+
+	if (debug) {
+	printf("LI=%d  VN=%d  Mode=%d  Stratum=%d  Poll=%d  Precision=%d\n",
+		li, vn, mode, stratum, poll, prec);
+	printf("Delay=%.1f  Dispersion=%.1f  Refid=%u.%u.%u.%u\n",
+		sec2u(delay),sec2u(disp),
+		refid>>24&0xff, refid>>16&0xff, refid>>8&0xff, refid&0xff);
+	printf("Reference %u.%.6u\n", reftime.coarse, USEC(reftime.fine));
+	printf("(sent)    %u.%.6u\n", ntpc->time_of_send[0], USEC(ntpc->time_of_send[1]));
+	printf("Originate %u.%.6u\n", orgtime.coarse, USEC(orgtime.fine));
+	printf("Receive   %u.%.6u\n", rectime.coarse, USEC(rectime.fine));
+	printf("Transmit  %u.%.6u\n", xmttime.coarse, USEC(xmttime.fine));
+	printf("Our recv  %u.%.6u\n", arrival->coarse, USEC(arrival->fine));
+	}
+	el_time=ntpdiff(&orgtime,arrival);   /* elapsed */
+	st_time=ntpdiff(&rectime,&xmttime);  /* stall */
+	skew1=ntpdiff(&orgtime,&rectime);
+	skew2=ntpdiff(&xmttime,arrival);
+	freq=get_current_freq();
+	if (debug) {
+	printf("Total elapsed: %9.2f\n"
+	       "Server stall:  %9.2f\n"
+	       "Slop:          %9.2f\n",
+		el_time, st_time, el_time-st_time);
+	printf("Skew:          %9.2f\n"
+	       "Frequency:     %9d\n"
+	       " day   second     elapsed    stall     skew  dispersion  freq\n",
+		(skew1-skew2)/2, freq);
+	}
+
+	/* error checking, see RFC-4330 section 5 */
+#ifdef ENABLE_DEBUG
+#define FAIL(x) do { drop_reason=(x); goto fail;} while (0)
+#else
+#define FAIL(x) goto fail;
+#endif
+	if (ntpc->cross_check) {
+		if (li == 3) FAIL("LI==3");  /* unsynchronized */
+		if (vn < 3) FAIL("VN<3");   /* RFC-4330 documents SNTP v4, but we interoperate with NTP v3 */
+		if (mode != 4) FAIL("MODE!=3");
+		if (orgtime.coarse != ntpc->time_of_send[0] ||
+		    orgtime.fine   != ntpc->time_of_send[1] ) FAIL("ORG!=sent");
+		if (xmttime.coarse == 0 && xmttime.fine == 0) FAIL("XMT==0");
+		if (delay > 65536 || delay < -65536) FAIL("abs(DELAY)>65536");
+		if (disp  > 65536 || disp  < -65536) FAIL("abs(DISP)>65536");
+		if (stratum == 0) FAIL("STRATUM==0");  /* kiss o' death */
+#undef FAIL
+	}
+
+	/* XXX should I do this if debug flag is set? */
+	if (ntpc->set_clock) { /* you'd better be root, or ntpclient will exit here! */
+		set_time(&xmttime);
+	}
+
+	/* Not the ideal order for printing, but we want to be sure
+	 * to do all the time-sensitive thinking (and time setting)
+	 * before we start the output, especially fflush() (which
+	 * could be slow).  Of course, if debug is turned on, speed
+	 * has gone down the drain anyway. */
+	if (ntpc->live) {
+		int new_freq;
+		new_freq = contemplate_data(arrival->coarse, (skew1-skew2)/2,
+			el_time+sec2u(disp), freq);
+		if (!debug && new_freq != freq) set_freq(new_freq);
+	}
+
+    if (ntp_time) {
+        ntp_time->coarse = arrival->coarse;
+        ntp_time->fine = arrival->fine;
+    }else {
+	    printf("%d %.5d.%.3d  %8.1f %8.1f  %8.1f %8.1f %9d\n",
+		    arrival->coarse/86400, arrival->coarse%86400,
+		    arrival->fine/4294967, el_time, st_time,
+		    (skew1-skew2)/2, sec2u(disp), freq);
+	    fflush(stdout);
+    }
+	*error = el_time-st_time;
+
+	return 0;
+fail:
+#ifdef ENABLE_DEBUG
+	printf("%d %.5d.%.3d  rejected packet: %s\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967, drop_reason);
+#else
+	printf("%d %.5d.%.3d  rejected packet\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967);
+#endif
+	return 1;
+}
+
+static void stuff_net_addr(struct in_addr *p, char *hostname)
+{
+	struct hostent *ntpserver;
+	ntpserver=gethostbyname(hostname);
+	if (ntpserver == NULL) {
+		herror(hostname);
+		return;
+	}
+	if (ntpserver->h_length != 4) {
+		/* IPv4 only, until I get a chance to test IPv6 */
+		fprintf(stderr,"oops %d\n",ntpserver->h_length);
+        return;
+	}
+	memcpy(&(p->s_addr),ntpserver->h_addr_list[0],4);
+}
+
+static void setup_receive(int usd, unsigned int interface, short port)
+{
+	struct sockaddr_in sa_rcvr;
+	memset(&sa_rcvr,0,sizeof sa_rcvr);
+	sa_rcvr.sin_family=AF_INET;
+	sa_rcvr.sin_addr.s_addr=htonl(interface);
+	sa_rcvr.sin_port=htons(port);
+	if(bind(usd,(struct sockaddr *) &sa_rcvr,sizeof sa_rcvr) == -1) {
+		perror("bind");
+		fprintf(stderr,"could not bind to udp port %d\n",port);
+        return;
+	}
+	/* listen(usd,3); this isn't TCP; thanks Alexander! */
+}
+
+static void setup_transmit(int usd, char *host, short port, struct ntp_control *ntpc)
+{
+	struct sockaddr_in sa_dest;
+	memset(&sa_dest,0,sizeof sa_dest);
+	sa_dest.sin_family=AF_INET;
+	stuff_net_addr(&(sa_dest.sin_addr),host);
+	memcpy(ntpc->serv_addr,&(sa_dest.sin_addr),4); /* XXX asumes IPv4 */
+	sa_dest.sin_port=htons(port);
+	if (connect(usd,(struct sockaddr *)&sa_dest,sizeof sa_dest)==-1)
+		{perror("connect");return;}
+}
+
+static void primary_loop(int usd, struct ntp_control *ntpc, struct ntp_time_t* ntp_time)
+{
+	fd_set fds;
+	struct sockaddr sa_xmit;
+	int i, pack_len, probes_sent, error;
+	socklen_t sa_xmit_len;
+	struct timeval to;
+	struct ntptime udp_arrival_ntp;
+	static u32 incoming_word[325];
+#define incoming ((char *) incoming_word)
+#define sizeof_incoming (sizeof incoming_word)
+
+	if (debug) printf("Listening...\n");
+
+	probes_sent=0;
+	sa_xmit_len=sizeof sa_xmit;
+	to.tv_sec=0;
+	to.tv_usec=0;
+	for (;;) {
+		FD_ZERO(&fds);
+		FD_SET(usd,&fds);
+		i=select(usd+1,&fds,NULL,NULL,&to);  /* Wait on read or error */
+		if ((i!=1)||(!FD_ISSET(usd,&fds))) {
+			if (i<0) {
+				if (errno != EINTR) perror("select");
+				continue;
+			}
+			if (to.tv_sec == 0) {
+				if (probes_sent >= ntpc->probe_count &&
+					ntpc->probe_count != 0) break;
+				send_packet(usd,ntpc->time_of_send);
+				++probes_sent;
+				to.tv_sec=ntpc->cycle_time;
+				to.tv_usec=0;
+			}
+			continue;
+		}
+		pack_len=recvfrom(usd,incoming,sizeof_incoming,0,
+		                  &sa_xmit,&sa_xmit_len);
+		error = ntpc->goodness;
+		if (pack_len<0) {
+			perror("recvfrom");
+		} else if (pack_len>0 && (unsigned)pack_len<sizeof_incoming){
+			get_packet_timestamp(usd, &udp_arrival_ntp);
+			if (check_source(pack_len, &sa_xmit, sa_xmit_len, ntpc)!=0) continue;
+			if (rfc1305print(incoming_word, &udp_arrival_ntp, ntpc, &error, ntp_time)!=0) continue;
+			/* udp_handle(usd,incoming,pack_len,&sa_xmit,sa_xmit_len); */
+		} else {
+			printf("Ooops.  pack_len=%d\n",pack_len);
+			fflush(stdout);
+		}
+		/* best rollover option: specify -g, -s, and -l.
+		 * simpler rollover option: specify -s and -l, which
+		 * triggers a magic -c 1 */
+		if ((error < ntpc->goodness && ntpc->goodness != 0) ||
+		    (probes_sent >= ntpc->probe_count && ntpc->probe_count != 0)) {
+			ntpc->set_clock = 0;
+			if (!ntpc->live) break;
+		}
+	}
+#undef incoming
+#undef sizeof_incoming
+}
+
+#ifdef ENABLE_REPLAY
+static void do_replay(void)
+{
+	char line[100];
+	int n, day, freq, absolute;
+	float sec, el_time, st_time, disp;
+	double skew, errorbar;
+	int simulated_freq = 0;
+	unsigned int last_fake_time = 0;
+	double fake_delta_time = 0.0;
+
+	while (fgets(line,sizeof line,stdin)) {
+		n=sscanf(line,"%d %f %f %f %lf %f %d",
+			&day, &sec, &el_time, &st_time, &skew, &disp, &freq);
+		if (n==7) {
+			fputs(line,stdout);
+			absolute=day*86400+(int)sec;
+			errorbar=el_time+disp;
+			if (debug) printf("contemplate %u %.1f %.1f %d\n",
+				absolute,skew,errorbar,freq);
+			if (last_fake_time==0) simulated_freq=freq;
+			fake_delta_time += (absolute-last_fake_time)*((double)(freq-simulated_freq))/65536;
+			if (debug) printf("fake %f %d \n", fake_delta_time, simulated_freq);
+			skew += fake_delta_time;
+			freq = simulated_freq;
+			last_fake_time = absolute;
+			simulated_freq = contemplate_data(absolute, skew, errorbar, freq);
+		} else {
+			fprintf(stderr,"Replay input error\n");
+            return;
+		}
+	}
+}
+#endif
+
+static void usage(char *argv0)
+{
+	fprintf(stderr,
+	"Usage: %s [-c count]"
+#ifdef ENABLE_DEBUG
+	" [-d]"
+#endif
+	" [-f frequency] [-g goodness] -h hostname\n"
+	"\t[-i interval] [-l] [-p port] [-q min_delay]"
+#ifdef ENABLE_REPLAY
+	" [-r]"
+#endif
+	" [-s] [-t]\n",
+	argv0);
+}
+
+#ifdef LIBNTP 
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time) {
+    if (!host || !ntp_time) return -1;
+    int argc = 1;
+    char *argv[] = {"ntp_get_time"};
+
+	char *hostname=(char *)host;
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=1;
+	ntpc.cycle_time=1;
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
+#else
+int main(int argc, char *argv[]) {
+    struct ntp_time_t* ntp_time = NULL;
+	char *hostname=NULL;          /* must be set */
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=0;           /* default of 0 means loop forever */
+	ntpc.cycle_time=600;          /* seconds */
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
+#endif
+	int usd;  /* socket */
+	int c;
+	/* These parameters are settable from the command line
+	   the initializations here provide default behavior */
+	short int udp_local_port=0;   /* default of 0 means kernel chooses */
+	int initial_freq;             /* initial freq value to use */
+
+	for (;;) {
+		c = getopt( argc, argv, "c:" DEBUG_OPTION "f:g:h:i:lp:q:" REPLAY_OPTION "st");
+		if (c == EOF) break;
+		switch (c) {
+			case 'c':
+				ntpc.probe_count = atoi(optarg);
+				break;
+#ifdef ENABLE_DEBUG
+			case 'd':
+				++debug;
+				break;
+#endif
+			case 'f':
+				initial_freq = atoi(optarg);
+				if (debug) printf("initial frequency %d\n",
+						initial_freq);
+				set_freq(initial_freq);
+				break;
+			case 'g':
+				ntpc.goodness = atoi(optarg);
+				break;
+			case 'h':
+				hostname = optarg;
+				break;
+			case 'i':
+				ntpc.cycle_time = atoi(optarg);
+				break;
+			case 'l':
+				(ntpc.live)++;
+				break;
+			case 'p':
+				udp_local_port = atoi(optarg);
+				break;
+			case 'q':
+				min_delay = atof(optarg);
+				break;
+#ifdef ENABLE_REPLAY
+			case 'r':
+				do_replay();
+                return -1;
+				break;
+#endif
+			case 's':
+				(ntpc.set_clock)++;
+				break;
+
+			case 't':
+				(ntpc.cross_check)=0;
+				break;
+
+			default:
+				usage(argv[0]);
+                return -1;
+		}
+	}
+	if (hostname == NULL) {
+		usage(argv[0]);
+        return -1;
+	}
+
+	if (ntpc.set_clock && !ntpc.live && !ntpc.goodness && !ntpc.probe_count) {
+		ntpc.probe_count = 1;
+	}
+
+	/* respect only applicable MUST of RFC-4330 */
+	if (ntpc.probe_count != 1 && ntpc.cycle_time < MIN_INTERVAL) {
+		ntpc.cycle_time = MIN_INTERVAL;
+	}
+
+	if (debug) {
+		printf("Configuration:\n"
+		"  -c probe_count %d\n"
+		"  -d (debug)     %d\n"
+		"  -g goodness    %d\n"
+		"  -h hostname    %s\n"
+		"  -i interval    %d\n"
+		"  -l live        %d\n"
+		"  -p local_port  %d\n"
+		"  -q min_delay   %f\n"
+		"  -s set_clock   %d\n"
+		"  -x cross_check %d\n",
+		ntpc.probe_count, debug, ntpc.goodness,
+		hostname, ntpc.cycle_time, ntpc.live, udp_local_port, min_delay,
+		ntpc.set_clock, ntpc.cross_check );
+	}
+
+	/* Startup sequence */
+	if ((usd=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==-1) {
+        perror ("socket");
+        return -1;
+    }
+
+	setup_receive(usd, INADDR_ANY, udp_local_port);
+
+	setup_transmit(usd, hostname, NTP_PORT, &ntpc);
+
+	primary_loop(usd, &ntpc, ntp_time);
+
+	close(usd);
+	return 0;
+}
diff --git a/net/mmt/ntp/ntpclient.h b/net/mmt/ntp/ntpclient.h
new file mode 100644
index 0000000..bb756dd
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.h
@@ -0,0 +1,20 @@
+#ifndef NET_MMT_NTP_NTPCLIENT_H_
+#define NET_MMT_NTP_NTPCLIENT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//#define JAN_1970_SEC        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define JAN_1970_SEC        2208988800
+struct ntp_time_t {
+	unsigned int coarse;
+	unsigned int fine;
+};
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/net/mmt/ntp/phaselock.c b/net/mmt/ntp/phaselock.c
new file mode 100644
index 0000000..d1ab598
--- /dev/null
+++ b/net/mmt/ntp/phaselock.c
@@ -0,0 +1,339 @@
+/*
+ * phaselock.c - Phase locking for NTP client
+ *
+ * Copyright (C) 2000, 2007  Larry Doolittle  <larry@doolittle.boa.org>
+ * Last hack: 30 December, 2007
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Subtract configurable amount from errorbar
+ *      - Build in general run-time access to tune parameters
+ *      - Sculpt code so it's legible, this version is out of control
+ *      - Write documentation  :-(
+ */
+
+#include <stdio.h>
+#include "ntpclient.h"
+
+/* when present, debug is a true global */
+#ifdef ENABLE_DEBUG
+extern int debug;
+#else
+#define debug 0
+#endif
+
+double min_delay = 800.0;  /* global, user-changeable, units are microseconds */
+
+#define RING_SIZE 16
+#define MAX_CORRECT 250   /* ppm change to system clock */
+#define MAX_C ((MAX_CORRECT)*65536)
+static struct datum {
+	unsigned int absolute;
+	double skew;
+	double errorbar;
+	int freq;
+	/* s.s.min and s.s.max (skews) are "corrected" to what they would
+	 * have been if freq had been constant at its current value during
+	 * the measurements.
+	 */
+	union {
+		struct { double min; double max; } s;
+		double ss[2];
+	} s;
+	/*
+	double smin;
+	double smax;
+	 */
+} d_ring[RING_SIZE];
+
+static struct _seg {
+	double slope;
+	double offset;
+} maxseg[RING_SIZE+1], minseg[RING_SIZE+1];
+
+#if 0
+/* draw a line from a to c, what the offset is of that line
+ * where that line matches b's slope coordinate.
+ */
+static double interpolate(struct _seg *a, struct _seg *b, struct _seg *c)
+{
+	double x, y;
+	x = (b->slope - a->slope) / (c->slope  - a->slope) ;
+	y =         a->offset + x * (c->offset - a->offset);
+	return y;
+}
+#endif
+
+static int next_up(int i) { int r = i+1; if (r>=RING_SIZE) r=0; return r;}
+static int next_dn(int i) { int r = i-1; if (r<0) r=RING_SIZE-1; return r;}
+
+/* Looks at the line segments that start at point j, that end at
+ * all following points (ending at index rp).  The initial point
+ * is on curve s0, the ending point is on curve s1.  The curve choice
+ * (s.min vs. s.max) is based on the index in ss[].  The scan
+ * looks for the largest (sign=0) or smallest (sign=1) slope.
+ */
+static int search(int rp, int j, int s0, int s1, int sign, struct _seg *answer)
+{
+	double dt, slope;
+	int n, nextj=0, cinit=1;
+	for (n=next_up(j); n!=next_up(rp); n=next_up(n)) {
+		if (0 && debug) printf("d_ring[%d].s.ss[%d]=%f d_ring[%d].s.ss[%d]=%f\n",
+			n, s0, d_ring[n].s.ss[s0], j, s1, d_ring[j].s.ss[s1]);
+		dt = d_ring[n].absolute - d_ring[j].absolute;
+		slope = (d_ring[n].s.ss[s0] - d_ring[j].s.ss[s1]) / dt;
+		if (0 && debug) printf("slope %d%d%d [%d,%d] = %f\n",
+			s0, s1, sign, j, n, slope);
+		if (cinit || (slope < answer->slope) ^ sign) {
+			answer->slope = slope;
+			answer->offset = d_ring[n].s.ss[s0] +
+				slope*(d_ring[rp].absolute - d_ring[n].absolute);
+			cinit = 0;
+			nextj = n;
+		}
+	}
+	return nextj;
+}
+
+/* Pseudo-class for finding consistent frequency shift */
+#define MIN_INIT 20
+static struct _polygon {
+	double l_min;
+	double r_min;
+} df;
+
+static void polygon_reset(void)
+{
+	df.l_min = MIN_INIT;
+	df.r_min = MIN_INIT;
+}
+
+static double find_df(int *flag)
+{
+	if (df.l_min == 0.0) {
+		if (df.r_min == 0.0) {
+			return 0.0;   /* every point was OK */
+		} else {
+			return -df.r_min;
+		}
+	} else {
+		if (df.r_min == 0.0) {
+			return df.l_min;
+		} else {
+			if (flag) *flag=1;
+			return 0.0;   /* some points on each side,
+			               * or no data at all */
+		}
+	}
+}
+
+/* Finds the amount of delta-f required to move a point onto a
+ * target line in delta-f/delta-t phase space.  Any line is OK
+ * as long as it's not convex and never returns greater than
+ * MIN_INIT. */
+static double find_shift(double slope, double offset)
+{
+	double shift  = slope - offset/600.0;
+	double shift2 = slope + 0.3 - offset/6000.0;
+	if (shift2 < shift) shift = shift2;
+	if (debug) printf("find_shift %f %f -> %f\n", slope, offset, shift);
+	if (shift  < 0) return 0.0;
+	return shift;
+}
+
+static void polygon_point(struct _seg *s)
+{
+	double l, r;
+	if (debug) printf("loop %f %f\n", s->slope, s->offset);
+	l = find_shift(- s->slope,   s->offset);
+	r = find_shift(  s->slope, - s->offset);
+	if (l < df.l_min) df.l_min = l;
+	if (r < df.r_min) df.r_min = r;
+	if (debug) printf("constraint left:  %f %f \n", l, df.l_min);
+	if (debug) printf("constraint right: %f %f \n", r, df.r_min);
+}
+
+/* Something like linear feedback to be used when we are "close" to
+ * phase lock.  Not really used at the moment:  the logic in find_df()
+ * never sets the flag. */
+static double find_df_center(struct _seg *min, struct _seg *max, double gross_df)
+{
+	const double crit_time=1000.0;
+	double slope  = 0.5 * (max->slope  + min->slope)+gross_df;
+	double dslope =       (max->slope  - min->slope);
+	double offset = 0.5 * (max->offset + min->offset);
+	double doffset =      (max->offset - min->offset);
+	double delta1 = -offset/ 600.0 - slope;
+	double delta2 = -offset/1800.0 - slope;
+	double delta  = 0.0;
+	double factor = crit_time/(crit_time+doffset+dslope*1200.0);
+	if (offset <  0 && delta2 > 0) delta = delta2;
+	if (offset <  0 && delta1 < 0) delta = delta1;
+	if (offset >= 0 && delta1 > 0) delta = delta1;
+	if (offset >= 0 && delta2 < 0) delta = delta2;
+	if (max->offset < -crit_time || min->offset > crit_time) return 0.0;
+	if (debug) printf("find_df_center %f %f\n", delta, factor);
+	return factor*delta;
+}
+
+int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq)
+{
+	/*  Here is the actual phase lock loop.
+	 *  Need to keep a ring buffer of points to make a rational
+	 *  decision how to proceed.  if (debug) print a lot.
+	 */
+	static int rp=0, valid=0;
+	int both_sides_now=0;
+	int j, n, c, max_avail, min_avail, dinit;
+	int nextj=0;	/* initialization not needed; but gcc can't figure out my logic */
+	double cum;
+	struct _seg check, save_min, save_max;
+	double last_slope;
+	int delta_freq;
+	double delta_f;
+	int inconsistent=0, max_imax, max_imin=0, min_imax, min_imin=0;
+	int computed_freq=freq;
+
+	if (debug) printf("xontemplate %u %.1f %.1f %d\n",absolute,skew,errorbar,freq);
+	d_ring[rp].absolute = absolute;
+	d_ring[rp].skew     = skew;
+	d_ring[rp].errorbar = errorbar - min_delay;   /* quick hack to speed things up */
+	d_ring[rp].freq     = freq;
+
+	if (valid<RING_SIZE) ++valid;
+	if (valid==RING_SIZE) {
+		/*
+		 * Pass 1: correct for wandering freq's */
+		cum = 0.0;
+		if (debug) printf("\n");
+		for (j=rp; ; j=n) {
+			d_ring[j].s.s.max = d_ring[j].skew - cum + d_ring[j].errorbar;
+			d_ring[j].s.s.min = d_ring[j].skew - cum - d_ring[j].errorbar;
+			if (debug) printf("hist %d %d %f %f %f\n",j,d_ring[j].absolute-absolute,
+				cum,d_ring[j].s.s.min,d_ring[j].s.s.max);
+			n=next_dn(j);
+			if (n == rp) break;
+			/* Assume the freq change took place immediately after
+			 * the data was taken; this is valid for the case where
+			 * this program was responsible for the change.
+			 */
+			cum = cum + (d_ring[j].absolute-d_ring[n].absolute) *
+				(double)(d_ring[j].freq-freq)/65536;
+		}
+		/*
+		 * Pass 2: find the convex down envelope of s.max, composed of
+		 * line segments in s.max vs. absolute space, which are
+		 * points in freq vs. dt space.  Find points in order of increasing
+		 * slope == freq */
+		dinit=1; last_slope=-2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 1, 1, 0, &maxseg[c]);
+			        search(rp, j, 0, 1, 1, &check);
+			if (check.slope < maxseg[c].slope && check.slope > last_slope &&
+			    (dinit || check.slope < save_min.slope)) {dinit=0; save_min=check; }
+			if (debug) printf("maxseg[%d] = %f *x+ %f\n",
+				 c, maxseg[c].slope, maxseg[c].offset);
+			last_slope = maxseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("mincross %f *x+ %f\n", save_min.slope, save_min.offset);
+		max_avail=c;
+		/*
+		 * Pass 3: find the convex up envelope of s.min, composed of
+		 * line segments in s.min vs. absolute space, which are
+		 * points in freq vs. dt space.  These points are found in
+		 * order of decreasing slope. */
+		dinit=1; last_slope=+2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 0, 0, 1, &minseg[c]);
+			        search(rp, j, 1, 0, 0, &check);
+			if (check.slope > minseg[c].slope && check.slope < last_slope &&
+			    (dinit || check.slope < save_max.slope)) {dinit=0; save_max=check; }
+			if (debug) printf("minseg[%d] = %f *x+ %f\n",
+				 c, minseg[c].slope, minseg[c].offset);
+			last_slope = minseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("maxcross %f *x+ %f\n", save_max.slope, save_max.offset);
+		min_avail=c;
+		/*
+		 * Pass 4: splice together the convex polygon that forms
+		 * the envelope of slope/offset coordinates that are consistent
+		 * with the observed data.  The order of calls to polygon_point
+		 * doesn't matter for the frequency shift determination, but
+		 * the order chosen is nice for visual display. */
+		if (!inconsistent) {
+		polygon_reset();
+		polygon_point(&save_min);
+		for (dinit=1, c=1; c<max_avail; c++) {
+			if (dinit && maxseg[c].slope > save_min.slope) {
+				max_imin = c-1;
+				maxseg[max_imin] = save_min;
+				dinit = 0;
+			}
+			if (maxseg[c].slope > save_max.slope)
+				break;
+			if (dinit==0) polygon_point(&maxseg[c]);
+		}
+		if (dinit && debug) printf("found maxseg vs. save_min inconsistency\n");
+		if (dinit) inconsistent=1;
+		max_imax = c;
+		maxseg[max_imax] = save_max;
+
+		polygon_point(&save_max);
+		for (dinit=1, c=1; c<min_avail; c++) {
+			if (dinit && minseg[c].slope < save_max.slope) {
+				max_imin = c-1;
+				minseg[min_imin] = save_max;
+				dinit = 0;
+			}
+			if (minseg[c].slope < save_min.slope)
+				break;
+			if (dinit==0) polygon_point(&minseg[c]);
+		}
+		if (dinit && debug) printf("found minseg vs. save_max inconsistency\n");
+		if (dinit) inconsistent=1;
+		min_imax = c;
+		minseg[min_imax] = save_max;
+
+		/* not needed for analysis, but shouldn't hurt either */
+		if (debug) polygon_point(&save_min);
+		} /* !inconsistent */
+
+		/*
+		 * Pass 5: decide on a new freq */
+		if (inconsistent) {
+			printf("# inconsistent\n");
+		} else {
+			delta_f = find_df(&both_sides_now);
+			if (debug) printf("find_df() = %e\n", delta_f);
+			delta_f += find_df_center(&save_min,&save_max, delta_f);
+			delta_freq = delta_f*65536+.5;
+			if (debug) printf("delta_f %f  delta_freq %d  bsn %d\n", delta_f, delta_freq, both_sides_now);
+			computed_freq -= delta_freq;
+			printf ("# box [( %.3f , %.1f ) ",  save_min.slope, save_min.offset);
+			printf (      " ( %.3f , %.1f )] ", save_max.slope, save_max.offset);
+			printf (" delta_f %.3f  computed_freq %d\n", delta_f, computed_freq);
+
+			if (computed_freq < -MAX_C) computed_freq=-MAX_C;
+			if (computed_freq >  MAX_C) computed_freq= MAX_C;
+		}
+	}
+	rp = (rp+1)%RING_SIZE;
+	return computed_freq;
+}
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..75bd21c 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -36,6 +36,11 @@
         'use_v8_in_net%': 1,
         'enable_built_in_dns%': 1,
       }],
+      ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+        'os_include': 'linux'
+      }],
+      ['OS=="mac"', {'os_include': 'mac'}],
+      ['OS=="win"', {'os_include': 'win32'}],
     ],
   },
   'includes': [
@@ -96,11 +101,21 @@
         '../url/url.gyp:url_lib',
         'net_derived_sources',
         'net_resources',
+        '../net/mmt/mpu/mpu.gyp:libmpu',
+        '../net/mmt/mmtp/mmtp.gyp:libmmtp',
+        '../net/mmt/ntp/ntp.gyp:libntp',
+        '../net/mmt/neon/neon.gyp:libneon',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
         '<@(net_non_nacl_sources)',
       ],
+      'include_dirs': [
+        '../skia/config',
+        '../third_party/skia/include/core',
+        '../third_party/libxml/src/include',
+        '../third_party/libxml/<(os_include)/include',
+      ],
       'defines': [
         'NET_IMPLEMENTATION',
       ],
@@ -180,6 +195,14 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..514a577 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,13 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_control.cc',
+      'mmt/mmt_parser.cc',
+      'mmt/mmt_stream.cc',
+      'mmt/mmt_utils.cc',
+      'mmt/mmt_http.cc',
+      'mmt/mmt_packet.cc',
+      'mmt/mmt_screen.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1139,6 +1146,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1184,6 +1193,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..69f64f4
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,33 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : task_runner_(task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {
+  LOG(INFO) << __func__;
+}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  return new URLRequestMmtJob(request, network_delegate, task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..9ad37af
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for Mmt jobs. If |network_delegate_| is NULL,
+// then all mmt requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..cbdf642 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  if (mmt_enabled_) {
+    job_factory->SetProtocolHandler(
+        "mmt",
+        new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+  }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..bb4d30a 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -117,6 +118,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +210,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_job.cc b/net/url_request/url_request_job.cc
index 2deb0f5..e740b25 100644
--- a/net/url_request/url_request_job.cc
+++ b/net/url_request/url_request_job.cc
@@ -49,8 +49,10 @@ URLRequestJob::URLRequestJob(URLRequest* request,
       network_delegate_(network_delegate),
       weak_factory_(this) {
   base::PowerMonitor* power_monitor = base::PowerMonitor::Get();
-  if (power_monitor)
+  if (power_monitor) {
+    power_monitor->RemoveObserver(this);
     power_monitor->AddObserver(this);
+  }
 }
 
 void URLRequestJob::SetUpload(UploadDataStream* upload) {
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..ef7153b
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,349 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/url_request_mmt_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+#include "net/mmt/mmt_inc.h"
+
+namespace net {
+
+// TODO implement ReadMetaInfo as one scope refptr
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
+      total_size(0),
+      read_offset(0),
+      remaining_bytes(0),
+      dest(nullptr),
+      dest_size(0) {
+}
+
+URLRequestMmtJob::URLRequestMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : URLRequestJob(request, network_delegate),
+      task_runner_(task_runner),
+      weak_ptr_factory_(this) {
+  LOG(INFO) << __func__ << " thiz=" << this;
+  mmt::StartMmtCtrl();
+  read_info_.url = request_->url();
+  GetRequestID(&content_.tab, request_);
+  content_.tab.postui = &URLRequestMmtJob::DoPostUI;
+}
+
+void URLRequestMmtJob::Start() {
+  mmt::stream_info_t sinfo;
+  sinfo.func = &URLRequestMmtJob::DoStart;
+  mmt::PostCtrlTask(mmt::kMmtTagOpen, request_->url(), sinfo, this, content_.tab);
+}
+
+void URLRequestMmtJob::Kill() {
+  mmt::PostCtrlTask(mmt::kMmtTagClose, request_->url(), this, content_.tab);
+
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
+
+  if (read_info_.remaining_bytes < dest_size)
+    dest_size = static_cast<int>(read_info_.remaining_bytes);
+
+  // If we should copy zero bytes because |remaining_bytes| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  mmt::stream_info_t sinfo;
+  sinfo.buf = dest;
+  sinfo.size = dest_size;
+  sinfo.offset = read_info_.read_offset;
+  sinfo.func = &URLRequestMmtJob::DoRead;
+
+  // return ERR_IO_PENDING if aysnc read
+  int rv = mmt::PostCtrlTask(mmt::kMmtTagRead, request_->url(), sinfo, this, content_.tab);
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    read_info_.remaining_bytes -= rv;
+    read_info_.read_offset += rv;
+    DCHECK_GE(read_info_.remaining_bytes, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  return false;
+}
+
+Filter* URLRequestMmtJob::SetupFilter() const {
+  return NULL;
+}
+
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  std::string spec = request_->url().spec();
+  if (spec.find("type=video") != std::string::npos)
+    *mime_type = std::string("video/mp4");
+  else if (spec.find("type=audio") != std::string::npos)
+    *mime_type = std::string("audio/mp4");
+  else
+    *mime_type = std::string("text/html");
+  return true;
+}
+
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+      LOG(INFO) << __func__ << " ranges.size=" << ranges.size()
+        << " first=" << byte_range_.first_byte_position()
+        << " last=" << byte_range_.last_byte_position();
+    }
+  }
+}
+
+URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " thiz=" << this << " request_=" << request_;
+}
+
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  LOG(INFO) << __func__ << " lret=" << lret;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), lret));
+  }
+}
+
+void URLRequestMmtJob::DidStart(long lret) {
+  int result = OK;
+  if (lret <= 0) {
+    result = ERR_FAILED;
+  }
+
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidStart"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  read_info_.total_size = lret;
+  if (!byte_range_.ComputeBounds(read_info_.total_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  read_info_.remaining_bytes = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  read_info_.read_offset = byte_range_.first_byte_position();
+  DCHECK_GE(read_info_.remaining_bytes, 0);
+
+  LOG(INFO) << __func__ 
+    << " remaining_bytes=" << read_info_.remaining_bytes
+    << " first=" << byte_range_.first_byte_position()
+    << " last=" << byte_range_.last_byte_position();
+
+  set_expected_content_size(read_info_.remaining_bytes);
+  NotifyHeadersComplete();
+}
+
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  if (lret < 0) {
+    LOG(INFO) << __func__ << " lret=" << lret << 
+        " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
+    return;
+  }
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, lret));
+  }
+}
+
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, long size) {
+  int result = size;
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    read_info_.remaining_bytes -= result;
+    read_info_.read_offset += result;
+    DCHECK_GE(read_info_.remaining_bytes, 0);
+  }
+
+  if (result == OK) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+void URLRequestMmtJob::DoTest(void* ptr) {
+}
+
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
+
+/// for storage testing
+void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
+    LOG(INFO) << __func__ << " set value";
+    std::string szkey = "xyz";
+    std::string szvalue = "test yzxu 123";
+    scoped_ptr<base::Value> value;
+    value.reset(new base::StringValue(szvalue));
+    storage->Set(ValueStore::DEFAULTS, szkey, *value);
+}
+
+bool URLRequestMmtJob::GetRequestID(mmt::tab_t* tab, const URLRequest* request) {
+    if (!tab) return false;
+    const content::ResourceRequestInfo* rinfo = 
+        content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        tab->routing_id = rinfo->GetRouteID();
+    }
+
+    bool is_ok = content::ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &tab->process_id, &tab->frame_id);
+    LOG(INFO) << __func__ 
+        << ", render_process_id: " << tab->process_id
+        << ", render_frame_id: " << tab->frame_id
+        << ", routing ID: " << tab->routing_id;
+    return is_ok;
+}
+
+
+// for extension and chrome.storage
+// GetExtension(web_contents->GetBrowserContext());
+bool URLRequestMmtJob::GetExtension(content::BrowserContext* context) {
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    if (!frontend) {
+        LOG(INFO) << __func__ << " frontend is nullptr";
+        return false;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    if (!registry) {
+        LOG(INFO) << __func__ << " registry is nullptr";
+        return false;
+    }
+
+    const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+    for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+        if (extension->name() == "org.chromium.cictrl") {
+            LOG(INFO) << __func__ 
+                << " extension name=" << extension->name()
+                << " extension id=" << extension->id();
+            frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, base::Bind(&URLRequestMmtJob::StorageCallback));
+            break;
+        }
+    }
+    return true;
+}
+
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::tabscript_t script) {
+    int process_id = script.tab.process_id;
+    int frame_id = script.tab.frame_id;
+    content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(process_id, frame_id);
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+    if (!rfh) {
+        LOG(INFO) << __func__ << " rfh is nullptr, head=" << script.head;
+        return;
+    }
+
+    content::WebContents* web_contents = content::WebContents::FromRenderFrameHost(rfh);
+    if (!web_contents) {
+        LOG(INFO) << __func__ << " web_contents is nullptr";
+        return;
+    }
+
+    int tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+    GURL tab_url = web_contents->GetURL();
+    content::RenderFrameHost* main_frame = web_contents->GetMainFrame();
+    LOG(INFO) << __func__  
+        << " main_frame=" << main_frame << ", head=" << script.head
+        << " tab id=" << tab_id << ", tab url=" << tab_url;
+
+    if (script.head == mmt::kMmtTagTab) {
+        script.tab.tab_id = tab_id;
+        script.tab.tab_url = tab_url;
+        mmt::PostCtrlTask(mmt::kMmtTagCI, tab_url, "", script.tab);
+        return;
+    }
+
+    if (main_frame && !script.body.empty()) {
+        if (script.head == mmt::kMmtTagCSS) { // for css
+            web_contents->InsertCSS(script.body);
+        }else if(script.head == mmt::kMmtTagJS) { // for js
+            main_frame->ExecuteJavaScript(base::ASCIIToUTF16(script.body.c_str()));
+        }
+    }
+}
+
+void URLRequestMmtJob::DoPostUI(const mmt::tabscript_t& script) {
+    LOG(INFO) << __func__ << " head=" << script.head;
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+            base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, script));
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..c576879
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,101 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_control.h"
+
+
+class ValueStore;
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+namespace content {
+class BrowserContext;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading file URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const scoped_refptr<base::TaskRunner>& mmt_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+ private:
+  // Callback after data is asynchronously read from the file into |buf|.
+  struct ReadMetaInfo {
+    ReadMetaInfo();
+    int64 total_size;
+    int64 read_offset;
+    int64 remaining_bytes;
+
+    IOBuffer* dest;
+    int32 dest_size;
+    GURL url;
+  };
+
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidStart(long iret);
+
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidRead(net::IOBuffer* iobuf, long size);
+
+  static void DoTest(void* ptr);
+  void DidTest(void* ptr);
+
+  // get info for render
+  static void StorageCallback(ValueStore* storage);
+  static bool GetRequestID(mmt::tab_t* tab, const URLRequest* request);
+  static bool GetExtension(content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::tabscript_t script);
+  static void DoPostUI(const mmt::tabscript_t& script);
+
+ private:
+  const scoped_refptr<base::TaskRunner> task_runner_;
+
+  HttpByteRange byte_range_;
+  ReadMetaInfo read_info_;
+  mmt::content_t content_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
