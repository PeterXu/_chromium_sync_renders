From 9401570e18af49e61c3e7401cea75d30db89c06f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 03:45:47 -0800
Subject: [PATCH 01/92] a. fix revision of .DEPS.git; b. simulate mmt:// as
 file://

---
 .DEPS.git                                      |    2 +-
 build/common.gypi                              |    7 +
 components/cronet/tools/cr_cronet.py           |    2 +-
 net/BUILD.gn                                   |   17 ++
 net/url_request/mmt_protocol_handler.cc        |   57 +++++
 net/url_request/mmt_protocol_handler.h         |   44 ++++
 net/url_request/url_request_context_builder.cc |   15 ++
 net/url_request/url_request_context_builder.h  |   11 +
 net/url_request/url_request_mmt_job.cc         |  326 ++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h          |  110 ++++++++
 10 files changed, 589 insertions(+), 2 deletions(-)
 create mode 100644 net/url_request/mmt_protocol_handler.cc
 create mode 100644 net/url_request/mmt_protocol_handler.h
 create mode 100644 net/url_request/url_request_mmt_job.cc
 create mode 100644 net/url_request/url_request_mmt_job.h

diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..ffd9746 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,19 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "base/directory_lister.cc",
+      "base/directory_lister.h",
+      "url_request/url_request_file_dir_job.cc",
+      "url_request/url_request_file_dir_job.h",
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..3b62225
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request->url(), &file_path);
+
+  // Check file access permissions.
+  if (!network_delegate ||
+      !network_delegate->CanAccessFile(*request, file_path)) {
+    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
+  }
+
+  // We need to decide whether to create URLRequestFileJob for file access or
+  // URLRequestFileDirJob for directory access. To avoid accessing the
+  // filesystem, we only look at the path string here.
+  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // which doesn't end with a slash, should really be treated as a directory,
+  // and it then redirects to the URLRequestFileDirJob.
+  if (is_file &&
+      file_path.EndsWithSeparator() &&
+      file_path.IsAbsolute()) {
+    return new URLRequestFileDirJob(request, network_delegate, file_path);
+  }
+
+  // Use a regular file request job for all non-directories (including invalid
+  // file names).
+  return new URLRequestFileJob(request, network_delegate, file_path,
+                               file_task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..28ca9b6
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
+// then all file requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..efb9e5c 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+    if (mmt_enabled_) {
+      job_factory->SetProtocolHandler(
+      "mmt",
+      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+    }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..2aff0dd 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -117,6 +117,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +209,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..4443c1b
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,326 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
+// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_file_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/files/file_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace net {
+
+URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequesetMmtJob::URLRequesetMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const base::FilePath& file_path,
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : URLRequestJob(request, network_delegate),
+      file_path_(file_path),
+      stream_(new FileStream(file_task_runner)),
+      file_task_runner_(file_task_runner),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void URLRequesetMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  file_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequesetMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequesetMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+Filter* URLRequesetMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
+
+bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
+  return false;
+}
+
+void URLRequesetMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
+}
+
+void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+}
+
+void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
+
+URLRequesetMmtJob::~URLRequesetMmtJob() {
+}
+
+void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
+}
+
+void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+
+  // We use URLRequesetMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequesetMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequesetMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
+  }
+}
+
+void URLRequesetMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
+
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..1ff88d2
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,110 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const base::FilePath& file_path,
+                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
+
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  HttpByteRange byte_range_;
+  int64 remaining_bytes_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
-- 
1.7.9.5


From 819ebb00f5f4b906fa46955091a2613e2f22f1be Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 05:57:57 -0800
Subject: [PATCH 02/92] fix building error for mmt protocol

---
 net/BUILD.gn                            |    4 ---
 net/net.gyp                             |   12 +++++++
 net/net.gypi                            |    4 +++
 net/url_request/mmt_protocol_handler.cc |    6 ++--
 net/url_request/url_request_mmt_job.cc  |   60 +++++++++++++++----------------
 5 files changed, 49 insertions(+), 37 deletions(-)

diff --git a/net/BUILD.gn b/net/BUILD.gn
index ffd9746..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -143,10 +143,6 @@ component("net") {
 
   if (disable_mmt_support) {
     sources -= [
-      "base/directory_lister.cc",
-      "base/directory_lister.h",
-      "url_request/url_request_file_dir_job.cc",
-      "url_request/url_request_file_dir_job.h",
       "url_request/url_request_mmt_job.cc",
       "url_request/url_request_mmt_job.h",
       "url_request/mmt_protocol_handler.cc",
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..1597f24 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,18 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'base/directory_lister.cc',
+            'base/directory_lister.h',
+            'url_request/url_request_file_dir_job.cc',
+            'url_request/url_request_file_dir_job.h',
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..ee879d2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1135,6 +1135,8 @@
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1178,6 +1180,8 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 3b62225..86afe03 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -32,10 +32,10 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
   }
 
-  // We need to decide whether to create URLRequestFileJob for file access or
+  // We need to decide whether to create URLRequestMmtJob for file access or
   // URLRequestFileDirJob for directory access. To avoid accessing the
   // filesystem, we only look at the path string here.
-  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // The code in the URLRequestMmtJob::Start() method discovers that a path,
   // which doesn't end with a slash, should really be treated as a directory,
   // and it then redirects to the URLRequestFileDirJob.
   if (is_file &&
@@ -46,7 +46,7 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
 
   // Use a regular file request job for all non-directories (including invalid
   // file names).
-  return new URLRequestFileJob(request, network_delegate, file_path,
+  return new URLRequestMmtJob(request, network_delegate, file_path,
                                file_task_runner_);
 }
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4443c1b..c5b8f9c 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -9,15 +9,15 @@
 // to do background file reads for us.
 //
 // Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
-// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
 // attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
 // signal from the OS that the overlapped read has completed.  It does so by
 // leveraging the MessageLoop::WatchObject API.
 
-#include "net/url_request/url_request_file_job.h"
+#include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
@@ -47,14 +47,14 @@
 
 namespace net {
 
-URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
     : file_size(0),
       mime_type_result(false),
       file_exists(false),
       is_directory(false) {
 }
 
-URLRequesetMmtJob::URLRequesetMmtJob(
+URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
     const base::FilePath& file_path,
@@ -66,25 +66,25 @@ URLRequesetMmtJob::URLRequesetMmtJob(
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
-void URLRequesetMmtJob::Start() {
+void URLRequestMmtJob::Start() {
   FileMetaInfo* meta_info = new FileMetaInfo();
   file_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
                  base::Unretained(meta_info)),
-      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(meta_info)));
 }
 
-void URLRequesetMmtJob::Kill() {
+void URLRequestMmtJob::Kill() {
   stream_.reset();
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
 }
 
-bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
@@ -103,7 +103,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
 
   int rv = stream_->Read(dest,
                          dest_size,
-                         base::Bind(&URLRequesetMmtJob::DidRead,
+                         base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
   if (rv >= 0) {
@@ -123,7 +123,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   if (meta_info_.is_directory) {
     // This happens when we discovered the file is a directory, so needs a
@@ -160,13 +160,13 @@ bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
 #endif
 }
 
-Filter* URLRequesetMmtJob::SetupFilter() const {
+Filter* URLRequestMmtJob::SetupFilter() const {
   // Bug 9936 - .svgz files needs to be decompressed.
   return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
       ? Filter::GZipFactory() : NULL;
 }
 
-bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
   if (meta_info_.mime_type_result) {
     *mime_type = meta_info_.mime_type;
@@ -175,7 +175,7 @@ bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
   return false;
 }
 
-void URLRequesetMmtJob::SetExtraRequestHeaders(
+void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
@@ -196,16 +196,16 @@ void URLRequesetMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
 }
 
-void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
 }
 
-URLRequesetMmtJob::~URLRequesetMmtJob() {
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                       FileMetaInfo* meta_info) {
   base::File::Info file_info;
   meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
@@ -219,10 +219,10 @@ void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                                     &meta_info->mime_type);
 }
 
-void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
   meta_info_ = *meta_info;
 
-  // We use URLRequesetMmtJob to handle files as well as directories without
+  // We use URLRequestMmtJob to handle files as well as directories without
   // trailing slash.
   // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
   // we will append trailing slash and redirect to FileDirJob.
@@ -243,16 +243,16 @@ void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
               base::File::FLAG_READ |
               base::File::FLAG_ASYNC;
   int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
                                     weak_ptr_factory_.GetWeakPtr()));
   if (rv != ERR_IO_PENDING)
     DidOpen(rv);
 }
 
-void URLRequesetMmtJob::DidOpen(int result) {
+void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -273,11 +273,11 @@ void URLRequesetMmtJob::DidOpen(int result) {
     // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
     tracked_objects::ScopedTracker tracking_profile1(
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequesetMmtJob::DidOpen 1"));
+            "423948 URLRequestMmtJob::DidOpen 1"));
 
     int rv = stream_->Seek(base::File::FROM_BEGIN,
                            byte_range_.first_byte_position(),
-                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                           base::Bind(&URLRequestMmtJob::DidSeek,
                                       weak_ptr_factory_.GetWeakPtr()));
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
@@ -292,7 +292,7 @@ void URLRequesetMmtJob::DidOpen(int result) {
   }
 }
 
-void URLRequesetMmtJob::DidSeek(int64 result) {
+void URLRequestMmtJob::DidSeek(int64 result) {
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -304,7 +304,7 @@ void URLRequesetMmtJob::DidSeek(int64 result) {
   NotifyHeadersComplete();
 }
 
-void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
-- 
1.7.9.5


From 1f5976f34f579f4c08029b399da98dd8943d4a07 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 25 Dec 2014 20:59:17 -0800
Subject: [PATCH 03/92] register mmt:// into chromium

---
 .../api/web_navigation/frame_navigation_state.cc   |    1 +
 chrome/browser/history/in_memory_url_index.cc      |    1 +
 chrome/browser/prerender/prerender_util.cc         |    3 +++
 chrome/browser/profiles/profile_io_data.cc         |   14 ++++++++++++++
 .../supervised_user/supervised_user_url_filter.cc  |    1 +
 chrome/browser/ui/location_bar/origin_chip_info.cc |    1 +
 chrome/browser/web_applications/web_app.cc         |    1 +
 .../navigation_metrics/navigation_metrics.cc       |    2 ++
 content/browser/browser_url_handler_impl.cc        |    1 +
 .../browser/child_process_security_policy_impl.cc  |    1 +
 content/common/savable_url_schemes.cc              |    1 +
 .../browser/api/web_request/web_request_api.cc     |    2 +-
 .../api/web_request/web_request_permissions.cc     |    2 +-
 extensions/common/extension.cc                     |    3 ++-
 extensions/common/url_pattern.cc                   |    2 ++
 extensions/common/url_pattern.h                    |    7 ++++---
 extensions/common/user_script.cc                   |    3 ++-
 extensions/renderer/dispatcher.cc                  |    1 +
 url/url_constants.cc                               |    1 +
 url/url_constants.h                                |    1 +
 url/url_util.cc                                    |    3 ++-
 21 files changed, 44 insertions(+), 8 deletions(-)

diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..d76a909 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+          content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..e4ed0ad 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,9 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_CHROMEUI   = 1 << 4,
-    SCHEME_EXTENSION  = 1 << 5,
-    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 4,
+    SCHEME_CHROMEUI   = 1 << 5,
+    SCHEME_EXTENSION  = 1 << 6,
+    SCHEME_FILESYSTEM = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
-- 
1.7.9.5


From b6a5c50865dee23020da0b887d3cd5da9d3f29da Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 31 Dec 2014 18:21:04 -0800
Subject: [PATCH 04/92] implement mmt protocol's framework

---
 chrome/browser/profiles/profile_io_data.cc     |    5 +-
 extensions/common/url_pattern.h                |    8 +-
 media/filters/ffmpeg_glue.cc                   |    2 +-
 net/mmt/mmt_information.h                      |   25 +++
 net/mmt/mmt_transaction.cc                     |   37 +++++
 net/mmt/mmt_transaction.h                      |   71 +++++++++
 net/mmt/mmt_transaction_factory.h              |   31 ++++
 net/mmt/mmt_transaction_impl.cc                |  195 ++++++++++++++++++++++++
 net/mmt/mmt_transaction_impl.h                 |   81 ++++++++++
 net/net.gyp                                    |    4 -
 net/net.gypi                                   |   10 +-
 net/url_request/mmt_protocol_handler.cc        |   34 +----
 net/url_request/mmt_protocol_handler.h         |   11 +-
 net/url_request/url_request_context_builder.cc |    2 +-
 net/url_request/url_request_mmt_job.cc         |  165 +++++---------------
 net/url_request/url_request_mmt_job.h          |   47 +-----
 16 files changed, 498 insertions(+), 230 deletions(-)
 create mode 100644 net/mmt/mmt_information.h
 create mode 100644 net/mmt/mmt_transaction.cc
 create mode 100644 net/mmt/mmt_transaction.h
 create mode 100644 net/mmt/mmt_transaction_factory.h
 create mode 100644 net/mmt/mmt_transaction_impl.cc
 create mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index d76a909..9d89cb3 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1219,10 +1219,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #if !defined(DISABLE_MMT_SUPPORT)
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(
-          content::BrowserThread::GetBlockingPool()->
-              GetTaskRunnerWithShutdownBehavior(
-                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+      new net::MmtProtocolHandler());
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index e4ed0ad..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,10 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_MMT        = 1 << 4,
-    SCHEME_CHROMEUI   = 1 << 5,
-    SCHEME_EXTENSION  = 1 << 6,
-    SCHEME_FILESYSTEM = 1 << 7,
+    SCHEME_CHROMEUI   = 1 << 4,
+    SCHEME_EXTENSION  = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..dabd7d5 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 256 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
new file mode 100644
index 0000000..60ed7e4
--- /dev/null
+++ b/net/mmt/mmt_information.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_INFORMATION_H_
+#define NET_MMT_MMT_INFORMATION_H_
+
+#include "url/gurl.h"
+
+namespace net {
+
+class MmtRequestInfo {
+ public:
+  // The requested URL.
+  GURL url;
+};
+
+class MmtResponseInfo {
+ public:
+
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
new file mode 100644
index 0000000..1f0e8c7
--- /dev/null
+++ b/net/mmt/mmt_transaction.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2008 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction.h"
+#include "net/mmt/mmt_transaction_impl.h"
+#include "net/mmt/mmt_transaction_factory.h"
+
+namespace net {
+
+class MmtTransactionFactoryImpl : public MmtTransactionFactory {
+public:
+  MmtTransactionFactoryImpl() : suspended_(false) {
+  }
+  virtual ~MmtTransactionFactoryImpl() override {
+  }
+
+  virtual MmtTransaction* CreateTransaction() override {
+    if (suspended_)
+      return NULL;
+
+    return new MmtTransactionImpl();
+  }
+
+  virtual void Suspend(bool suspend) override {
+    suspended_ = suspend;
+  }
+
+private:
+  bool suspended_;
+};
+
+MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
+  return new MmtTransactionFactoryImpl();
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
new file mode 100644
index 0000000..d3c225d
--- /dev/null
+++ b/net/mmt/mmt_transaction.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_H_
+#define NET_MMT_MMT_TRANSACTION_H_
+
+#include "net/base/completion_callback.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_states.h"
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtResponseInfo;
+class MmtRequestInfo;
+class BoundNetLog;
+
+// Represents a single MMT transaction.
+class NET_EXPORT_PRIVATE MmtTransaction {
+ public:
+  // Stops any pending IO and destroys the transaction object.
+  virtual ~MmtTransaction() {}
+
+  // Starts the MMT transaction (i.e., sends the MMT request).
+  //
+  // Returns OK if the transaction could be started synchronously, which means
+  // that the request was served from the cache (only supported for directory
+  // listings).  ERR_IO_PENDING is returned to indicate that the
+  // CompletionCallback will be notified once response info is available or if
+  // an IO error occurs.  Any other return value indicates that the transaction
+  // could not be started.
+  //
+  // Regardless of the return value, the caller is expected to keep the
+  // request_info object alive until Destroy is called on the transaction.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  // Profiling information for the request is saved to |net_log| if non-NULL.
+  virtual int Start(const MmtRequestInfo* request_info,
+                    const CompletionCallback& callback,
+                    const BoundNetLog& net_log) = 0;
+
+  // Once response info is available for the transaction, response data may be
+  // read by calling this method.
+  //
+  // Response data is copied into the given buffer and the number of bytes
+  // copied is returned.  ERR_IO_PENDING is returned if response data is not
+  // yet available.  The CompletionCallback is notified when the data copy
+  // completes, and it is passed the number of bytes that were successfully
+  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
+  // the error.  Any other negative return value indicates that the transaction
+  // could not be read.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  virtual int Read(IOBuffer* buf,
+                   int buf_len,
+                   const CompletionCallback& callback) = 0;
+
+  // Returns the response info for this transaction or NULL if the response
+  // info is not available.
+  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
+
+  // Returns the load state for this transaction.
+  virtual LoadState GetLoadState() const = 0;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
new file mode 100644
index 0000000..b9b1e6a
--- /dev/null
+++ b/net/mmt/mmt_transaction_factory.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
+#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
+
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtTransaction;
+
+// An interface to a class that can create MmtTransaction objects.
+class NET_EXPORT MmtTransactionFactory {
+ public:
+  virtual ~MmtTransactionFactory() {}
+
+  // Creates a MmtTransaction object.
+  virtual MmtTransaction* CreateTransaction() = 0;
+
+  // Suspends the creation of new transactions. If |suspend| is false, creation
+  // of new transactions is resumed.
+  virtual void Suspend(bool suspend) = 0;
+
+  static MmtTransactionFactory* CreateFactory();
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
new file mode 100644
index 0000000..2e512b5
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction_impl.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/compiler_specific.h"
+#include "base/metrics/histogram.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "net/base/address_list.h"
+#include "net/base/connection_type_histograms.h"
+#include "net/base/escape.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_log.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+
+//const int kMmtBufLen = 256*1024;
+
+namespace net {
+
+MmtTransactionImpl::MmtTransactionImpl() :
+      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
+                              base::Unretained(this))),
+      request_(NULL),
+      read_data_buf_len_(0),
+      next_state_(STATE_NONE)
+{}
+
+MmtTransactionImpl::~MmtTransactionImpl() {
+}
+
+int MmtTransactionImpl::Stop(int error) {
+  LOG(INFO) << "Stop";
+  next_state_ = STATE_STOP;
+  last_error_ = error;
+  return OK;
+}
+
+int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+  return ERR_NOT_IMPLEMENTED;
+}
+
+int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
+                                 const CompletionCallback& callback,
+                                 const BoundNetLog& net_log) {
+  LOG(INFO) << "Start, url=" << request_info->url;
+
+  net_log_ = net_log;
+  request_ = request_info;
+  next_state_ = STATE_CONNECT;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+
+  return OK;
+}
+
+int MmtTransactionImpl::Read(IOBuffer* buf,
+                                int buf_len,
+                                const CompletionCallback& callback) {
+  LOG(INFO) << "Read, buf_len=" << buf_len;
+  DCHECK(buf);
+  DCHECK_GT(buf_len, 0);
+
+  read_data_buf_ = buf;
+  read_data_buf_len_ = buf_len;
+
+  next_state_ = STATE_READ;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+  return rv;
+}
+
+const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
+  LOG(INFO) << "GetResponseInfo";
+  return &response_;
+}
+
+LoadState MmtTransactionImpl::GetLoadState() const {
+  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
+  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
+  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  return LOAD_STATE_IDLE;
+}
+
+void MmtTransactionImpl::ResetStateForRestart() {
+  user_callback_.Reset();
+  response_ = MmtResponseInfo();
+  read_data_buf_ = NULL;
+  read_data_buf_len_ = 0;
+  last_error_ = OK;
+  next_state_ = STATE_NONE;
+}
+
+void MmtTransactionImpl::DoCallback(int rv) {
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
+
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
+}
+
+void MmtTransactionImpl::OnIOComplete(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION(
+          "436634 MmtTransactionImpl::OnIOComplete"));
+
+  int rv = DoLoop(result);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
+}
+
+int MmtTransactionImpl::DoLoop(int result) {
+  DCHECK(next_state_ != STATE_NONE);
+
+  int rv = result;
+  do {
+    State state = next_state_;
+    next_state_ = STATE_NONE;
+    switch (state) {
+      case STATE_STOP:
+        DCHECK(rv == OK);
+        rv = DoStop();
+        break;
+      case STATE_CONNECT:
+        DCHECK(rv == OK);
+        rv = DoConnect();
+        break;
+      case STATE_CONNECT_COMPLETE:
+        rv = DoConnectComplete(rv);
+        break;
+      case STATE_READ:
+        DCHECK(rv == OK);
+        rv = DoRead();
+        break;
+      case STATE_READ_COMPLETE:
+        rv = DoReadComplete(rv);
+        break;
+      default:
+        NOTREACHED() << "bad state";
+        rv = ERR_UNEXPECTED;
+        break;
+    }
+  } while (rv != ERR_IO_PENDING);
+  return rv;
+}
+
+
+// Data Connection
+
+int MmtTransactionImpl::DoStop() {
+  next_state_ = STATE_READ;
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnect() {
+  next_state_ = STATE_CONNECT_COMPLETE;
+  // TODO: open file/network and then call io_callback_
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnectComplete(int result) {
+  if (result != OK)
+    return Stop(result);
+  return OK;
+}
+
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+
+  next_state_ = STATE_READ_COMPLETE;
+  read_data_buf_->data()[0] = 0;
+  //TODO: read data from network/file
+  return 0;
+}
+
+int MmtTransactionImpl::DoReadComplete(int result) {
+  return result;
+}
+
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
new file mode 100644
index 0000000..098ee53
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
+#define NET_MMT_MMT_TRANSACTION_IMPL_H_
+
+#include <string>
+#include <utility>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "net/base/address_list.h"
+#include "net/base/auth.h"
+#include "net/base/net_log.h"
+#include "net/dns/host_resolver.h"
+#include "net/dns/single_request_host_resolver.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+
+namespace net {
+
+class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
+ public:
+  MmtTransactionImpl();
+  virtual ~MmtTransactionImpl() override;
+
+  virtual int Stop(int error);
+  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
+
+  // MmtTransaction methods:
+  virtual int Start(const MmtRequestInfo* request_info,
+            const CompletionCallback& callback,
+            const BoundNetLog& net_log) override;
+  virtual int Read(IOBuffer* buf,
+           int buf_len,
+           const CompletionCallback& callback) override;
+  virtual const MmtResponseInfo* GetResponseInfo() const override;
+  virtual LoadState GetLoadState() const override;
+
+ private:
+  void ResetStateForRestart();
+  void DoCallback(int result);
+  void OnIOComplete(int result);
+  int DoLoop(int result);
+
+  int DoStop();
+  int DoConnect();
+  int DoConnectComplete(int result);
+  int DoRead();
+  int DoReadComplete(int result);
+
+  enum State {
+    STATE_STOP,
+    STATE_CONNECT,
+    STATE_CONNECT_COMPLETE,
+    STATE_READ,
+    STATE_READ_COMPLETE,
+    STATE_NONE
+  };
+
+private:
+  CompletionCallback io_callback_;
+  CompletionCallback user_callback_;
+
+  BoundNetLog net_log_;
+  const MmtRequestInfo* request_;
+  MmtResponseInfo response_;
+
+  scoped_refptr<IOBuffer> read_data_buf_;
+  int read_data_buf_len_;
+
+  int last_error_;
+  State next_state_;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gyp b/net/net.gyp
index 1597f24..eb27320 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -182,10 +182,6 @@
         }],
         ['disable_mmt_support==1', {
           'sources!': [
-            'base/directory_lister.cc',
-            'base/directory_lister.h',
-            'url_request/url_request_file_dir_job.cc',
-            'url_request/url_request_file_dir_job.h',
             'url_request/url_request_mmt_job.cc',
             'url_request/url_request_mmt_job.h',
             'url_request/mmt_protocol_handler.cc',
diff --git a/net/net.gypi b/net/net.gypi
index ee879d2..0d6cbf7 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1131,12 +1131,16 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1180,8 +1184,6 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 86afe03..416660f 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,48 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
-#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "net/url_request/url_request_mmt_job.h"
+#include "url/gurl.h"
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
+MmtProtocolHandler::MmtProtocolHandler() {}
 
 MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request->url(), &file_path);
-
-  // Check file access permissions.
-  if (!network_delegate ||
-      !network_delegate->CanAccessFile(*request, file_path)) {
-    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
-  }
-
-  // We need to decide whether to create URLRequestMmtJob for file access or
-  // URLRequestFileDirJob for directory access. To avoid accessing the
-  // filesystem, we only look at the path string here.
-  // The code in the URLRequestMmtJob::Start() method discovers that a path,
-  // which doesn't end with a slash, should really be treated as a directory,
-  // and it then redirects to the URLRequestFileDirJob.
-  if (is_file &&
-      file_path.EndsWithSeparator() &&
-      file_path.IsAbsolute()) {
-    return new URLRequestFileDirJob(request, network_delegate, file_path);
-  }
-
-  // Use a regular file request job for all non-directories (including invalid
-  // file names).
-  return new URLRequestMmtJob(request, network_delegate, file_path,
-                               file_task_runner_);
+  LOG(INFO) << "mmt url: " << request->url();
+  return new URLRequestMmtJob(request, network_delegate);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 28ca9b6..237c703 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,22 +12,16 @@
 
 class GURL;
 
-namespace base {
-class TaskRunner;
-}
-
 namespace net {
 
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
-// then all file requests will fail with ERR_ACCESS_DENIED.
+// Implements a ProtocolHandler for MMT jobs. 
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  explicit MmtProtocolHandler();
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +29,6 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index efb9e5c..1eda830 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -411,7 +411,7 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     if (mmt_enabled_) {
       job_factory->SetProtocolHandler(
       "mmt",
-      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+      new MmtProtocolHandler());
     }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c5b8f9c..b53b76e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -21,16 +21,12 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
-#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
@@ -38,47 +34,25 @@
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate,
-    const base::FilePath& file_path,
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    NetworkDelegate* network_delegate)
     : URLRequestJob(request, network_delegate),
-      file_path_(file_path),
-      stream_(new FileStream(file_task_runner)),
-      file_task_runner_(file_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
 void URLRequestMmtJob::Start() {
-  FileMetaInfo* meta_info = new FileMetaInfo();
-  file_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+  // TODO
+  LOG(INFO) << "Start";
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  // TODO
+  LOG(INFO) << "Kill";
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -87,6 +61,7 @@ void URLRequestMmtJob::Kill() {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
+  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
   DCHECK_GE(remaining_bytes_, 0);
@@ -101,11 +76,13 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
+  int rv = 0;
+  // TODO
+  //int rv = StreamRead(dest,
+  //                    dest_size,
+  //                    base::Bind(&URLRequestMmtJob::DidRead,
+  //                               weak_ptr_factory_.GetWeakPtr(),
+  //                               make_scoped_refptr(dest)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -125,58 +102,27 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
+  // TODO
+  LOG(INFO) << "IsRedirectResponse";
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  // TODO
+  LOG(INFO) << "SetupFilter";
+  return NULL; 
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
+  // TODO
+  LOG(INFO) << "GetMimeType";
+  *mime_type = std::string("application/x-mmt");
+  return true;
 }
 
-void URLRequestMmtJob::SetExtraRequestHeaders(
-    const HttpRequestHeaders& headers) {
+void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
+  LOG(INFO) << "SetExtraRequestHeaders";
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -197,59 +143,18 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::OnSeekComplete(int64 result) {
+  LOG(INFO) << "OnSeekComplete";
 }
 
 void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+  LOG(INFO) << "OnReadComplete";
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
-}
-
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
-  }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
 void URLRequestMmtJob::DidOpen(int result) {
+  LOG(INFO) << "DidOpen";
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
@@ -259,7 +164,8 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  int total_size = 0;
+  if (!byte_range_.ComputeBounds(total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -275,10 +181,13 @@ void URLRequestMmtJob::DidOpen(int result) {
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "423948 URLRequestMmtJob::DidOpen 1"));
 
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
+    int rv = 0; 
+    // TODO: seek to byte_range_.first_byte_position()
+    // int rv = StreamSeek(FROM_BEGIN,
+    //                     byte_range_.first_byte_position(),
+    //                     base::Bind(&URLRequestMmtJob::DidSeek,
+    //                                weak_ptr_factory_.GetWeakPtr()));
+    //  
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
       // into DidSeek().
@@ -293,6 +202,7 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
+  LOG(INFO) << "DidSeek";
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -305,6 +215,7 @@ void URLRequestMmtJob::DidSeek(int64 result) {
 }
 
 void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  LOG(INFO) << "DidRead";
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 1ff88d2..b9e871f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,7 +8,6 @@
 #include <string>
 #include <vector>
 
-#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
@@ -16,24 +15,13 @@
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
-namespace base {
-class TaskRunner;
-}
-namespace file_util {
-struct FileInfo;
-}
-
 namespace net {
 
-class FileStream;
-
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate,
-                    const base::FilePath& file_path,
-                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+                    NetworkDelegate* network_delegate);
 
   // URLRequestJob:
   void Start() override;
@@ -53,36 +41,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   int64 remaining_bytes() const { return remaining_bytes_; }
 
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
@@ -93,10 +52,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
 
-- 
1.7.9.5


From 31d7185f5b54cef7759d7a428bcc41f507c605aa Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 1 Jan 2015 00:11:27 -0800
Subject: [PATCH 05/92] write mmt module like ftp

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 +
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 +
 chrome/browser/profiles/profile_io_data.cc         |    6 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/mmt/mmt_information.h                          |    7 +
 net/mmt/mmt_transaction_impl.cc                    |   37 ++-
 net/net.gypi                                       |   12 +-
 net/url_request/mmt_protocol_handler.cc            |   13 +-
 net/url_request/mmt_protocol_handler.h             |    5 +-
 net/url_request/url_request_context_builder.cc     |   12 +-
 net/url_request/url_request_context_builder.h      |    2 +
 net/url_request/url_request_mmt_job.cc             |  255 ++++++++------------
 net/url_request/url_request_mmt_job.h              |   42 ++--
 15 files changed, 213 insertions(+), 216 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index 798bea3..d47b636 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,6 +261,11 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -270,7 +275,8 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -328,7 +334,8 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -368,7 +375,8 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get());
+                                            ftp_factory_.get(),
+                                            mmt_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index 900dbfc..fa54638 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,6 +21,7 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -146,6 +147,7 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 8b39439..4f21760 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,6 +54,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -581,6 +582,11 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -597,7 +603,8 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -662,7 +669,8 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -749,7 +757,8 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get()));
+                              ftp_factory_.get(),
+                              mmt_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 383fc40..505da31 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,6 +34,7 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -229,6 +230,7 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 9d89cb3..2b8537b 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,7 +1162,8 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory,
+    net::MmtTransactionFactory* mmt_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1217,9 +1218,10 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
+  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler());
+      new net::MmtProtocolHandler(mmt_transaction_factory));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index 244107f..fcc9fef 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,6 +34,7 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
+#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -60,6 +61,7 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -358,7 +360,8 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory,
+      net::MmtTransactionFactory* mmt_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 60ed7e4..92d7e17 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -17,7 +17,14 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
+  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  }
 
+  // Expected content size, in bytes, as reported by SIZE command. Only valid
+  // for file downloads. -1 means unknown size.
+  int64 expected_content_size;
+
+  bool is_local;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index 2e512b5..aef7733 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -38,7 +38,7 @@ MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << "Stop";
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
@@ -51,14 +51,16 @@ int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callb
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                                  const CompletionCallback& callback,
                                  const BoundNetLog& net_log) {
-  LOG(INFO) << "Start, url=" << request_info->url;
+  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
 
   net_log_ = net_log;
   request_ = request_info;
   next_state_ = STATE_CONNECT;
+#if 0
   int rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
 
   return OK;
 }
@@ -66,7 +68,7 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
 int MmtTransactionImpl::Read(IOBuffer* buf,
                                 int buf_len,
                                 const CompletionCallback& callback) {
-  LOG(INFO) << "Read, buf_len=" << buf_len;
+  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
@@ -74,21 +76,32 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_len_ = buf_len;
 
   next_state_ = STATE_READ;
-  int rv = DoLoop(OK);
+  int rv = OK;
+#if 0
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << "GetResponseInfo";
+  LOG(INFO) << __FUNCTION__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
-  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
-  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  switch (next_state_) {
+    case STATE_NONE: 
+      return LOAD_STATE_IDLE;
+    case STATE_CONNECT:
+      return LOAD_STATE_CONNECTING; 
+    case STATE_READ:
+      return LOAD_STATE_READING_RESPONSE;
+    default: 
+      break;
+  }
   return LOAD_STATE_IDLE;
 }
 
@@ -112,6 +125,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -161,35 +175,40 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_CONNECT_COMPLETE;
   // TODO: open file/network and then call io_callback_
   return OK;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
+  LOG(INFO) << __FUNCTION__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
   //TODO: read data from network/file
+  // impement one callback to mmt receiver
   return 0;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   return result;
 }
 
-
 }  // namespace net
diff --git a/net/net.gypi b/net/net.gypi
index 0d6cbf7..0335fc6 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,8 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1131,12 +1133,6 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
@@ -1145,6 +1141,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1190,6 +1188,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 416660f..a671486 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,21 @@
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler() {}
+MmtProtocolHandler::MmtProtocolHandler(
+    MmtTransactionFactory* mmt_transaction_factory)
+    : mmt_transaction_factory_(mmt_transaction_factory) {
+  DCHECK(mmt_transaction_factory_);
+}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
   LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request, network_delegate);
+  return new URLRequestMmtJob(request,
+                              network_delegate,
+                              mmt_transaction_factory_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 237c703..10bfe1d 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -14,6 +14,7 @@ class GURL;
 
 namespace net {
 
+class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
@@ -21,7 +22,7 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler();
+  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -29,6 +30,8 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
+  MmtTransactionFactory* mmt_transaction_factory_;
+
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 1eda830..dee151e 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,6 +18,7 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -408,11 +409,12 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-    if (mmt_enabled_) {
-      job_factory->SetProtocolHandler(
-      "mmt",
-      new MmtProtocolHandler());
-    }
+  if (mmt_enabled_) {
+    mmt_transaction_factory_.reset(
+        MmtTransactionFactory::CreateFactory());
+    job_factory->SetProtocolHandler("mmt",
+        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+  }
 #endif
 
   storage->set_job_factory(job_factory);
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index 2aff0dd..c2cec99 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -226,6 +227,7 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
+  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b53b76e..6b14fdd 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,8 +31,15 @@
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_transaction_factory.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
 #include "url/gurl.h"
 
@@ -40,198 +47,126 @@ namespace net {
 
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate)
+    NetworkDelegate* network_delegate,
+    MmtTransactionFactory* mmt_transaction_factory)
     : URLRequestJob(request, network_delegate),
-      remaining_bytes_(0),
-      weak_ptr_factory_(this) {}
-
-void URLRequestMmtJob::Start() {
-  // TODO
-  LOG(INFO) << "Start";
-}
-
-void URLRequestMmtJob::Kill() {
-  // TODO
-  LOG(INFO) << "Kill";
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
+      read_in_progress_(false),
+      mmt_transaction_factory_(mmt_transaction_factory),
+      weak_ptr_factory_(this) {
+  DCHECK(mmt_transaction_factory);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
-                                    int dest_size,
-                                    int* bytes_read) {
-  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
-  DCHECK_NE(dest_size, 0);
-  DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size) {
-    *bytes_read = 0;
-    return true;
-  }
-
-  int rv = 0;
-  // TODO
-  //int rv = StreamRead(dest,
-  //                    dest_size,
-  //                    base::Bind(&URLRequestMmtJob::DidRead,
-  //                               weak_ptr_factory_.GetWeakPtr(),
-  //                               make_scoped_refptr(dest)));
-  if (rv >= 0) {
-    // Data is immediately available.
-    *bytes_read = rv;
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-    return true;
-  }
-
-  // Otherwise, a read error occured.  We may just need to wait...
-  if (rv == ERR_IO_PENDING) {
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
-  return false;
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  // TODO
-  LOG(INFO) << "IsRedirectResponse";
+#if 0
+bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
+  // Disallow all redirects.
   return false;
 }
-
-Filter* URLRequestMmtJob::SetupFilter() const {
-  // TODO
-  LOG(INFO) << "SetupFilter";
-  return NULL; 
-}
+#endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  DCHECK(request_);
-  // TODO
   LOG(INFO) << "GetMimeType";
-  *mime_type = std::string("application/x-mmt");
-  return true;
-}
-
-void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
-  LOG(INFO) << "SetExtraRequestHeaders";
-  std::string range_header;
-  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
-    // We only care about "Range" header here.
-    std::vector<HttpByteRange> ranges;
-    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        // We don't support multiple range requests in one single URL request,
-        // because we need to do multipart encoding here.
-        // TODO(hclam): decide whether we want to support multiple range
-        // requests.
-        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-      }
-    }
+  DCHECK(request_);
+  if (mmt_transaction_->GetResponseInfo()->is_local) {
+    *mime_type = "text/vnd.chromium.local";
+    return true;
   }
+  return false;
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-  LOG(INFO) << "OnSeekComplete";
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << "Start";
+  DCHECK(!mmt_transaction_);
+  StartMmtTransaction();
 }
 
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-  LOG(INFO) << "OnReadComplete";
-}
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << "Kill";
+  if (mmt_transaction_)
+    mmt_transaction_.reset();
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
-void URLRequestMmtJob::DidOpen(int result) {
-  LOG(INFO) << "DidOpen";
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
-
-  if (result != OK) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-    return;
+int URLRequestMmtJob::StartMmtTransaction() {
+  // Create a transaction.
+  DCHECK(!mmt_transaction_);
+  mmt_request_info_.url = request_->url();
+  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+
+  // No matter what, we want to report our status as IO pending since we will
+  // be notifying our consumer asynchronously via OnStartCompleted.
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  int rv = ERR_FAILED;
+  if (mmt_transaction_) {
+    rv = mmt_transaction_->Start(
+        &mmt_request_info_,
+        base::Bind(&URLRequestMmtJob::OnStartCompleted,
+                   base::Unretained(this)),
+        request_->net_log());
+    if (rv == ERR_IO_PENDING)
+      return rv;
   }
+  return rv;
+}
 
-  int total_size = 0;
-  if (!byte_range_.ComputeBounds(total_size)) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
+void URLRequestMmtJob::OnStartCompleted(int result) {
+  // Clear the IO_PENDING status
+  SetStatus(URLRequestStatus());
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
-                     byte_range_.first_byte_position() + 1;
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = 0; 
-    // TODO: seek to byte_range_.first_byte_position()
-    // int rv = StreamSeek(FROM_BEGIN,
-    //                     byte_range_.first_byte_position(),
-    //                     base::Bind(&URLRequestMmtJob::DidSeek,
-    //                                weak_ptr_factory_.GetWeakPtr()));
-    //  
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
+  // Note that mmt_transaction_ may be NULL due to a creation failure.
+  if (mmt_transaction_) {
+    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+    // the content size information manually.
+    set_expected_content_size(
+        mmt_transaction_->GetResponseInfo()->expected_content_size);
   }
-}
 
-void URLRequestMmtJob::DidSeek(int64 result) {
-  LOG(INFO) << "DidSeek";
-  OnSeekComplete(result);
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
+  if (result == OK) {
+    NotifyHeadersComplete();
+  }else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
   }
-
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  LOG(INFO) << "DidRead";
-  if (result > 0) {
-    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  OnReadComplete(buf.get(), result);
-  buf = NULL;
-
+void URLRequestMmtJob::OnReadCompleted(int result) {
+  read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  } else {
+    // Clear the IO_PENDING status
+    SetStatus(URLRequestStatus());
+  }
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
+                                    int buf_size,
+                                    int* bytes_read) {
+  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  DCHECK_NE(buf_size, 0);
+  DCHECK(bytes_read);
+  DCHECK(!read_in_progress_);
+
+  int rv = mmt_transaction_->Read(buf, buf_size,
+                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
+                                             base::Unretained(this)));
+  if (rv >= 0) {
+    *bytes_read = rv;
+    return true;
   }
 
-  NotifyReadComplete(result);
+  if (rv == ERR_IO_PENDING) {
+    read_in_progress_ = true;
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index b9e871f..cf3036e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -11,50 +11,46 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
 namespace net {
 
+class NetworkDelegate;
+class MmtTransactionFactory;
+
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate);
+                   NetworkDelegate* network_delegate,
+                   MmtTransactionFactory* mmt_transaction_factory);
+
+ protected:
+  ~URLRequestMmtJob() override;
 
-  // URLRequestJob:
+  // Overridden from URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
-
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
- protected:
-  ~URLRequestMmtJob() override;
-
-  int64 remaining_bytes() const { return remaining_bytes_; }
 
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
+  int StartMmtTransaction();
+  void OnStartCompleted(int result);
+  void OnReadCompleted(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+ private:
+  MmtRequestInfo mmt_request_info_;
+  scoped_ptr<MmtTransaction> mmt_transaction_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
+  bool read_in_progress_;
 
+  MmtTransactionFactory* mmt_transaction_factory_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From 98f736ef3da53d6612b334658ba702e4ee2fcd1f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 2 Jan 2015 21:03:24 -0800
Subject: [PATCH 06/92] to implement mmt with the support of local file

---
 .gitignore                             |    2 +
 net/mmt/mmt_transaction_impl.cc        |   86 +++++++++++++++++++++-----------
 net/mmt/mmt_transaction_impl.h         |    4 ++
 net/url_request/url_request_mmt_job.cc |   26 ++++++----
 4 files changed, 80 insertions(+), 38 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8fa6763..a0181c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -437,3 +437,5 @@ v8.log
 /win8/metro_driver/metro_driver_version_resources.xml
 /x86-generic_out/
 /xcodebuild
+.xtags
+diff.log
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index aef7733..d927ab4 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -14,6 +14,12 @@
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
 #include "net/base/address_list.h"
 #include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
@@ -31,67 +37,66 @@ MmtTransactionImpl::MmtTransactionImpl() :
                               base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
-      next_state_(STATE_NONE)
-{}
+      next_state_(STATE_NONE) {
+}
 
 MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", error=" << error;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
 }
 
-int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+int MmtTransactionImpl::RestartIgnoringLastError(
+    const CompletionCallback& callback) {
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                                 const CompletionCallback& callback,
-                                 const BoundNetLog& net_log) {
-  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
-
+                              const CompletionCallback& callback,
+                              const BoundNetLog& net_log) {
+  LOG(INFO) << __func__ << ", url=" << request_info->url;
   net_log_ = net_log;
   request_ = request_info;
+
+  int rv = OK;
   next_state_ = STATE_CONNECT;
-#if 0
-  int rv = DoLoop(OK);
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
 
-  return OK;
+  return rv;
 }
 
+// @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
-                                int buf_len,
-                                const CompletionCallback& callback) {
-  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
+                             int buf_len,
+                             const CompletionCallback& callback) {
+  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
 
-  next_state_ = STATE_READ;
   int rv = OK;
-#if 0
+  next_state_ = STATE_READ;
   rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,7 +130,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -175,39 +180,62 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  LOG(INFO) << __func__ << ", is_file=" << is_file;
+  if (!is_file) {
+    return ERR_FAILED;
+  }
+
   next_state_ = STATE_CONNECT_COMPLETE;
-  // TODO: open file/network and then call io_callback_
-  return OK;
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path, flags, io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoConnectComplete(rv);
+  }
+  LOG(INFO) << __func__ << ", rv=" << rv;
+  return rv;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
+
   //TODO: read data from network/file
   // impement one callback to mmt receiver
-  return 0;
+  int rv = stream_->Read(read_data_buf_.get(),
+                         read_data_buf_len_,
+                         io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoReadComplete(rv);
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   return result;
 }
 
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 098ee53..fc25de2 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -22,6 +22,8 @@
 
 namespace net {
 
+class FileStream;
+
 class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
  public:
   MmtTransactionImpl();
@@ -69,6 +71,8 @@ private:
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
 
+  scoped_ptr<FileStream> stream_;
+
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6b14fdd..0fdb5a9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,8 +67,8 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << "GetMimeType";
-  DCHECK(request_);
+  LOG(INFO) << __FUNCTION__;
+  DCHECK(!mmt_transaction_);
   if (mmt_transaction_->GetResponseInfo()->is_local) {
     *mime_type = "text/vnd.chromium.local";
     return true;
@@ -77,13 +77,12 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << "Start";
-  DCHECK(!mmt_transaction_);
+  LOG(INFO) << __FUNCTION__;
   StartMmtTransaction();
 }
 
 void URLRequestMmtJob::Kill() {
-  LOG(INFO) << "Kill";
+  LOG(INFO) << __FUNCTION__;
   if (mmt_transaction_)
     mmt_transaction_.reset();
 
@@ -92,8 +91,12 @@ void URLRequestMmtJob::Kill() {
 }
 
 int URLRequestMmtJob::StartMmtTransaction() {
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(!mmt_transaction_);
+
+  // Create a transaction.
+  DCHECK(request_);
+  DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
 
@@ -107,13 +110,15 @@ int URLRequestMmtJob::StartMmtTransaction() {
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-    if (rv == ERR_IO_PENDING)
-      return rv;
   }
+  
+  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
   return rv;
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
@@ -133,6 +138,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -147,7 +154,8 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
+
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-- 
1.7.9.5


From 703dcc0d46897a4fce93a647879bc12bb546ec7e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 5 Jan 2015 07:06:50 -0800
Subject: [PATCH 07/92] done to support mmt local file

---
 net/mmt/mmt_information.h              |   15 ++-
 net/mmt/mmt_transaction.h              |    3 +
 net/mmt/mmt_transaction_impl.cc        |  224 ++++++++++++++++++--------------
 net/mmt/mmt_transaction_impl.h         |   17 +--
 net/url_request/url_request_mmt_job.cc |   80 ++++++------
 net/url_request/url_request_mmt_job.h  |    2 +-
 6 files changed, 189 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 92d7e17..3cf1f4d 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -6,6 +6,8 @@
 #define NET_MMT_MMT_INFORMATION_H_
 
 #include "url/gurl.h"
+#include "base/files/file_path.h"
+#include "net/http/http_byte_range.h"
 
 namespace net {
 
@@ -17,14 +19,17 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
-  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  MmtResponseInfo() {
+    total_size = 0;
+    read_offset = 0;
+    expected_content_size = 0;
   }
 
-  // Expected content size, in bytes, as reported by SIZE command. Only valid
-  // for file downloads. -1 means unknown size.
+  int64 total_size;
+  int64 read_offset;
   int64 expected_content_size;
-
-  bool is_local;
+  HttpByteRange byte_range;
+  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index d3c225d..9e45cbf 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -15,6 +15,7 @@ namespace net {
 class MmtResponseInfo;
 class MmtRequestInfo;
 class BoundNetLog;
+class HttpByteRange;
 
 // Represents a single MMT transaction.
 class NET_EXPORT_PRIVATE MmtTransaction {
@@ -64,6 +65,8 @@ class NET_EXPORT_PRIVATE MmtTransaction {
 
   // Returns the load state for this transaction.
   virtual LoadState GetLoadState() const = 0;
+
+  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index d927ab4..a090386 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -16,78 +16,92 @@
 #include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "base/threading/thread.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/address_list.h"
-#include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
 #include "net/mmt/mmt_information.h"
 
-//const int kMmtBufLen = 256*1024;
 
 namespace net {
 
 MmtTransactionImpl::MmtTransactionImpl() :
-      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
-                              base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
+  base::ThreadRestrictions::SetIOAllowed(true);
+  thread_.reset(new base::Thread("MMT Thread"));
+  thread_->StartWithOptions(
+      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
+  response_ = MmtResponseInfo();
+  stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
+  LOG(INFO) << __func__;
+  Stop(OK);
 }
 
 int MmtTransactionImpl::Stop(int error) {
   LOG(INFO) << __func__ << ", error=" << error;
-  next_state_ = STATE_STOP;
+
   last_error_ = error;
-  return OK;
+  next_state_ = STATE_STOP;
+  int rv = DoStop();
+  return rv;
 }
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
+  LOG(INFO) << __func__;
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                               const CompletionCallback& callback,
                               const BoundNetLog& net_log) {
-  LOG(INFO) << __func__ << ", url=" << request_info->url;
-  net_log_ = net_log;
   request_ = request_info;
+  user_callback_ = callback;
+  net_log_ = net_log;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_CONNECT;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  int rv = DoConnect();
+  DoCallback(rv);
+  return true;
+#endif
 }
 
 // @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
                              int buf_len,
                              const CompletionCallback& callback) {
-  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
-
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
+  user_callback_ = callback;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_READ;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOComplete,
+                   base::Unretained(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  return DoRead();
+#endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
@@ -110,7 +124,15 @@ LoadState MmtTransactionImpl::GetLoadState() const {
   return LOAD_STATE_IDLE;
 }
 
+void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
+  LOG(INFO) << __func__ 
+    << " range[" << range.first_byte_position() 
+    << ", "  << range.last_byte_position() << "]";
+  response_.byte_range = range;
+}
+
 void MmtTransactionImpl::ResetStateForRestart() {
+  LOG(INFO) << __func__ ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -119,26 +141,76 @@ void MmtTransactionImpl::ResetStateForRestart() {
   next_state_ = STATE_NONE;
 }
 
-void MmtTransactionImpl::DoCallback(int rv) {
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
+int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __func__;
+  next_state_ = STATE_NONE;
+  if (stream_) {
+    fclose((FILE*)stream_);
+    stream_ = nullptr;
+  }
+  return OK;
+}
 
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
+int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  if (!is_file) {
+    LOG(ERROR) << __func__ << ", invalid file";
+    return ERR_FAILED;
+  }
+  response_.file_path = file_path;
+
+  int64 file_size = 0;
+  if(!base::GetFileSize(file_path, &file_size)) {
+    LOG(ERROR) << __func__ << ", invalid file size";
+    return ERR_FAILED;
+  }
+
+  response_.total_size = file_size;
+  HttpByteRange byte_range = response_.byte_range;
+  if (!byte_range.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+  }
+
+  if (byte_range.first_byte_position() >= 0) {
+    response_.read_offset = byte_range.first_byte_position();
+  }else {
+    response_.read_offset = 0;
+  }
+  response_.expected_content_size = response_.total_size - response_.read_offset;
+  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
+        << ", total_size=" << response_.total_size
+        << ", content_size=" << response_.expected_content_size;
+
+  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  if (!fp) {
+    LOG(ERROR) << __func__ << ", fail to open file";
+    return ERR_FAILED;
+  }
+  stream_ = (void*)fp;
+
+  return OK;
 }
 
-void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION(
-          "436634 MmtTransactionImpl::OnIOComplete"));
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+  DCHECK(stream_);
+  read_data_buf_->data()[0] = 0;
 
-  int rv = DoLoop(result);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
+  FILE *fp = (FILE *)stream_;
+  int64 offset = response_.read_offset;
+  fseek(fp, offset, SEEK_SET);
+  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
+  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  if (rv > 0) {
+    response_.read_offset += rv;
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoLoop(int result) {
@@ -157,86 +229,38 @@ int MmtTransactionImpl::DoLoop(int result) {
         DCHECK(rv == OK);
         rv = DoConnect();
         break;
-      case STATE_CONNECT_COMPLETE:
-        rv = DoConnectComplete(rv);
-        break;
       case STATE_READ:
         DCHECK(rv == OK);
         rv = DoRead();
         break;
-      case STATE_READ_COMPLETE:
-        rv = DoReadComplete(rv);
-        break;
       default:
         NOTREACHED() << "bad state";
         rv = ERR_UNEXPECTED;
         break;
     }
-  } while (rv != ERR_IO_PENDING);
+  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
   return rv;
 }
 
-
-// Data Connection
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
-  next_state_ = STATE_READ;
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
-
-  // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  LOG(INFO) << __func__ << ", is_file=" << is_file;
-  if (!is_file) {
-    return ERR_FAILED;
-  }
-
-  next_state_ = STATE_CONNECT_COMPLETE;
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path, flags, io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoConnectComplete(rv);
-  }
+void MmtTransactionImpl::DoCallback(int rv) {
   LOG(INFO) << __func__ << ", rv=" << rv;
-  return rv;
-}
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
 
-int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  if (result != OK)
-    return Stop(result);
-  return OK;
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
 }
 
-int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __func__;
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-
-  next_state_ = STATE_READ_COMPLETE;
-  read_data_buf_->data()[0] = 0;
-
-  //TODO: read data from network/file
-  // impement one callback to mmt receiver
-  int rv = stream_->Read(read_data_buf_.get(),
-                         read_data_buf_len_,
-                         io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoReadComplete(rv);
-  }
-  return rv;
+void MmtTransactionImpl::OnIOPrepare() {
 }
 
-int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  return result;
+void MmtTransactionImpl::OnIOComplete() {
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  int rv = DoLoop(OK);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
 }
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index fc25de2..1f98423 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,6 +20,10 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
+namespace base {
+class Thread;
+}
+
 namespace net {
 
 class FileStream;
@@ -41,25 +45,22 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
            const CompletionCallback& callback) override;
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
+  virtual void SetRequestHeaders(HttpByteRange &range) override;
 
  private:
   void ResetStateForRestart();
+  void OnIOPrepare();
+  void OnIOComplete();
   void DoCallback(int result);
-  void OnIOComplete(int result);
   int DoLoop(int result);
-
   int DoStop();
   int DoConnect();
-  int DoConnectComplete(int result);
   int DoRead();
-  int DoReadComplete(int result);
 
   enum State {
     STATE_STOP,
     STATE_CONNECT,
-    STATE_CONNECT_COMPLETE,
     STATE_READ,
-    STATE_READ_COMPLETE,
     STATE_NONE
   };
 
@@ -70,9 +71,9 @@ private:
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
+  scoped_ptr<base::Thread> thread_;
 
-  scoped_ptr<FileStream> stream_;
-
+  void* stream_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0fdb5a9..051fcba 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,31 +67,33 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(!mmt_transaction_);
-  if (mmt_transaction_->GetResponseInfo()->is_local) {
-    *mime_type = "text/vnd.chromium.local";
-    return true;
-  }
   return false;
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  StartMmtTransaction();
-}
-
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  if (mmt_transaction_)
-    mmt_transaction_.reset();
-
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  LOG(INFO) << __func__;
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
 }
 
-int URLRequestMmtJob::StartMmtTransaction() {
-  LOG(INFO) << __FUNCTION__;
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << __func__;
   DCHECK(!mmt_transaction_);
 
   // Create a transaction.
@@ -99,36 +101,38 @@ int URLRequestMmtJob::StartMmtTransaction() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  int rv = ERR_FAILED;
-  if (mmt_transaction_) {
-    rv = mmt_transaction_->Start(
+  mmt_transaction_->Start(
         &mmt_request_info_,
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-  }
-  
-  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
-  return rv;
+}
+
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << __FUNCTION__;
+  mmt_transaction_.reset();
+
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  DCHECK(mmt_transaction_);
+
+  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
-  // Note that mmt_transaction_ may be NULL due to a creation failure.
-  if (mmt_transaction_) {
-    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-    // the content size information manually.
-    set_expected_content_size(
-        mmt_transaction_->GetResponseInfo()->expected_content_size);
-  }
+  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+  // the content size information manually.
+  set_expected_content_size(content_size);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -141,7 +145,7 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
   LOG(INFO) << __FUNCTION__ << ", result=" << result;
 
   read_in_progress_ = false;
-  if (result == 0) {
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -149,16 +153,16 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
     // Clear the IO_PENDING status
     SetStatus(URLRequestStatus());
   }
+  NotifyReadComplete(result);
 }
 
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
-
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
+  DCHECK(mmt_transaction_);
 
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cf3036e..6630861 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -37,9 +37,9 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
-  int StartMmtTransaction();
   void OnStartCompleted(int result);
   void OnReadCompleted(int result);
 
-- 
1.7.9.5


From c104100b2c0308afa500558d75b42b8a9bf488ac Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 05:58:52 -0800
Subject: [PATCH 08/92] TODO: support async io

---
 chrome/browser/profiles/profile_io_data.cc     |    6 +-
 net/mmt/mmt_information.h                      |    4 +-
 net/mmt/mmt_transaction.h                      |    6 ++
 net/mmt/mmt_transaction_impl.cc                |  122 ++++++++++++------------
 net/mmt/mmt_transaction_impl.h                 |    9 +-
 net/url_request/mmt_protocol_handler.cc        |    9 +-
 net/url_request/mmt_protocol_handler.h         |    9 +-
 net/url_request/url_request_context_builder.cc |    3 +-
 net/url_request/url_request_mmt_job.cc         |   12 ++-
 net/url_request/url_request_mmt_job.h          |    5 +-
 10 files changed, 110 insertions(+), 75 deletions(-)

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 2b8537b..7cb34a4 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1221,7 +1221,11 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
   DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(mmt_transaction_factory));
+      new net::MmtProtocolHandler(
+            mmt_transaction_factory,
+            content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 3cf1f4d..514a185 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -22,14 +22,14 @@ class MmtResponseInfo {
   MmtResponseInfo() {
     total_size = 0;
     read_offset = 0;
+    remaining_bytes = 0;
     expected_content_size = 0;
   }
 
   int64 total_size;
   int64 read_offset;
+  int64 remaining_bytes;
   int64 expected_content_size;
-  HttpByteRange byte_range;
-  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index 9e45cbf..05a07fd 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -10,6 +10,11 @@
 #include "net/base/load_states.h"
 #include "net/base/net_export.h"
 
+
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtResponseInfo;
@@ -67,6 +72,7 @@ class NET_EXPORT_PRIVATE MmtTransaction {
   virtual LoadState GetLoadState() const = 0;
 
   virtual void SetRequestHeaders(HttpByteRange &range) = 0;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index a090386..ee2274c 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -6,23 +6,15 @@
 
 #include "base/bind.h"
 #include "base/bind_helpers.h"
-#include "base/compiler_specific.h"
-#include "base/metrics/histogram.h"
-#include "base/profiler/scoped_tracker.h"
-#include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/thread_task_runner_handle.h"
-#include "base/threading/thread.h"
+#include "base/threading/thread_restrictions.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
@@ -31,25 +23,26 @@
 
 namespace net {
 
+#ifndef TAG
+#define TAG "["<<__func__<<" thiz="<<this<<"]"
+#endif
+
 MmtTransactionImpl::MmtTransactionImpl() :
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
   base::ThreadRestrictions::SetIOAllowed(true);
-  thread_.reset(new base::Thread("MMT Thread"));
-  thread_->StartWithOptions(
-      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
   response_ = MmtResponseInfo();
   stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
-  LOG(INFO) << __func__;
   Stop(OK);
+  LOG(INFO) << TAG;
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __func__ << ", error=" << error;
+  LOG(INFO) << TAG << ", error=" << error;
 
   last_error_ = error;
   next_state_ = STATE_STOP;
@@ -59,7 +52,7 @@ int MmtTransactionImpl::Stop(int error) {
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return ERR_NOT_IMPLEMENTED;
 }
 
@@ -69,13 +62,15 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
   request_ = request_info;
   user_callback_ = callback;
   net_log_ = net_log;
-
-#if 0
   next_state_ = STATE_CONNECT;
-  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
         base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
-  return bpost ? OK : ERR_FAILED;
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   int rv = DoConnect();
   DoCallback(rv);
@@ -92,25 +87,33 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
   user_callback_ = callback;
-
-#if 0
   next_state_ = STATE_READ;
-  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOComplete,
-                   base::Unretained(this)));
-  return bpost ? OK : ERR_FAILED;
+
+  if (response_.remaining_bytes < buf_len)
+    buf_len = static_cast<int>(response_.remaining_bytes);
+    
+  if (buf_len <= 0)
+    return 0;
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   return DoRead();
 #endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,14 +128,18 @@ LoadState MmtTransactionImpl::GetLoadState() const {
 }
 
 void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << __func__ 
+  LOG(INFO) << TAG 
     << " range[" << range.first_byte_position() 
     << ", "  << range.last_byte_position() << "]";
-  response_.byte_range = range;
+  byte_range_ = range;
+}
+
+void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
+  task_runner_ = runner;
 }
 
 void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << __func__ ;
+  LOG(INFO) << TAG ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -142,7 +149,7 @@ void MmtTransactionImpl::ResetStateForRestart() {
 }
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   next_state_ = STATE_NONE;
   if (stream_) {
     fclose((FILE*)stream_);
@@ -152,46 +159,42 @@ int MmtTransactionImpl::DoStop() {
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
+  LOG(INFO) << TAG << ", url=" << request_->url;
 
   // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  if (!is_file) {
-    LOG(ERROR) << __func__ << ", invalid file";
+  if(!FileURLToFilePath(request_->url, &file_path_)) {
+    LOG(ERROR) << TAG << ", invalid file";
     return ERR_FAILED;
   }
-  response_.file_path = file_path;
 
-  int64 file_size = 0;
-  if(!base::GetFileSize(file_path, &file_size)) {
-    LOG(ERROR) << __func__ << ", invalid file size";
+  response_.total_size = 0;
+  if(!base::GetFileSize(file_path_, &response_.total_size)) {
+    LOG(ERROR) << TAG << ", invalid file size";
     return ERR_FAILED;
   }
 
-  response_.total_size = file_size;
-  HttpByteRange byte_range = response_.byte_range;
-  if (!byte_range.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+  if (!byte_range_.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
     return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
   }
 
-  if (byte_range.first_byte_position() >= 0) {
-    response_.read_offset = byte_range.first_byte_position();
-  }else {
-    response_.read_offset = 0;
-  }
-  response_.expected_content_size = response_.total_size - response_.read_offset;
-  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
-        << ", total_size=" << response_.total_size
-        << ", content_size=" << response_.expected_content_size;
+  response_.read_offset = byte_range_.first_byte_position();
+  response_.remaining_bytes = byte_range_.last_byte_position() -
+    byte_range_.first_byte_position() + 1;
+  DCHECK_GE(response_.remaining_bytes, 0);
+
+  LOG(INFO) << TAG 
+    << ", total_size=" << response_.total_size
+    << ", read_offset=" << response_.read_offset
+    << ", content_size=" << response_.expected_content_size;
 
-  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  FILE *fp = base::OpenFile(file_path_, "rb");
   if (!fp) {
-    LOG(ERROR) << __func__ << ", fail to open file";
+    LOG(ERROR) << TAG << ", fail to open file";
     return ERR_FAILED;
   }
   stream_ = (void*)fp;
+  response_.expected_content_size = response_.remaining_bytes;
 
   return OK;
 }
@@ -206,9 +209,10 @@ int MmtTransactionImpl::DoRead() {
   int64 offset = response_.read_offset;
   fseek(fp, offset, SEEK_SET);
   int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
   if (rv > 0) {
     response_.read_offset += rv;
+    response_.remaining_bytes -= rv;
   }
   return rv;
 }
@@ -243,7 +247,7 @@ int MmtTransactionImpl::DoLoop(int result) {
 }
 
 void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << __func__ << ", rv=" << rv;
+  LOG(INFO) << TAG << ", rv=" << rv;
   DCHECK(rv != ERR_IO_PENDING);
   DCHECK(!user_callback_.is_null());
 
@@ -257,7 +261,7 @@ void MmtTransactionImpl::OnIOPrepare() {
 }
 
 void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   int rv = DoLoop(OK);
   if (rv != ERR_IO_PENDING)
     DoCallback(rv);
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 1f98423..adbe735 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,9 +20,6 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
-namespace base {
-class Thread;
-}
 
 namespace net {
 
@@ -46,6 +43,7 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
   virtual void SetRequestHeaders(HttpByteRange &range) override;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
 
  private:
   void ResetStateForRestart();
@@ -65,15 +63,16 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   };
 
 private:
-  CompletionCallback io_callback_;
   CompletionCallback user_callback_;
+  scoped_refptr<base::TaskRunner> task_runner_;
 
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
-  scoped_ptr<base::Thread> thread_;
+  HttpByteRange byte_range_;
 
   void* stream_;
+  base::FilePath file_path_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index a671486..be497ff 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -15,8 +15,10 @@
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory)
-    : mmt_transaction_factory_(mmt_transaction_factory) {
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner) {
   DCHECK(mmt_transaction_factory_);
 }
 
@@ -28,7 +30,8 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
   LOG(INFO) << "mmt url: " << request->url();
   return new URLRequestMmtJob(request,
                               network_delegate,
-                              mmt_transaction_factory_);
+                              mmt_transaction_factory_,
+                              task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 10bfe1d..185ac8f 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,6 +12,10 @@
 
 class GURL;
 
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtTransactionFactory;
@@ -22,7 +26,9 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
+  explicit MmtProtocolHandler(
+      MmtTransactionFactory* mmt_transaction_factory,
+      const scoped_refptr<base::TaskRunner>& task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -31,6 +37,7 @@ class NET_EXPORT MmtProtocolHandler :
 
  private:
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index dee151e..4e5018f 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -413,7 +413,8 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     mmt_transaction_factory_.reset(
         MmtTransactionFactory::CreateFactory());
     job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
+                               context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 051fcba..2806657 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -48,10 +48,12 @@ namespace net {
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory)
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
       mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   DCHECK(mmt_transaction_factory);
 }
@@ -72,7 +74,6 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
-  LOG(INFO) << __func__;
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -101,6 +102,7 @@ void URLRequestMmtJob::Start() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetTaskRunner(task_runner_);
   mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
@@ -167,6 +169,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
                                              base::Unretained(this)));
+  LOG(INFO) << __func__ << ", rv=" << rv;
   if (rv >= 0) {
     *bytes_read = rv;
     return true;
@@ -181,4 +184,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   return false;
 }
 
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  return false;
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6630861..7defe8f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -27,7 +27,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
                    NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory);
+                   MmtTransactionFactory* mmt_transaction_factory,
+                   const scoped_refptr<base::TaskRunner> task_runner);
 
  protected:
   ~URLRequestMmtJob() override;
@@ -36,6 +37,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
@@ -51,6 +53,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool read_in_progress_;
 
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From a4756644ac026b657ab354dd256b0fba042e58a9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:10:33 -0800
Subject: [PATCH 09/92] remove seperate mmt

---
 net/mmt/mmt_information.h              |   37 -----
 net/mmt/mmt_transaction.cc             |   37 -----
 net/mmt/mmt_transaction.h              |   80 ----------
 net/mmt/mmt_transaction_factory.h      |   31 ----
 net/mmt/mmt_transaction_impl.cc        |  270 --------------------------------
 net/mmt/mmt_transaction_impl.h         |   85 ----------
 net/net.gypi                           |    2 -
 net/url_request/url_request_mmt_job.cc |   81 +++++-----
 net/url_request/url_request_mmt_job.h  |   12 +-
 9 files changed, 51 insertions(+), 584 deletions(-)
 delete mode 100644 net/mmt/mmt_information.h
 delete mode 100644 net/mmt/mmt_transaction.cc
 delete mode 100644 net/mmt/mmt_transaction.h
 delete mode 100644 net/mmt/mmt_transaction_factory.h
 delete mode 100644 net/mmt/mmt_transaction_impl.cc
 delete mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
deleted file mode 100644
index 514a185..0000000
--- a/net/mmt/mmt_information.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2010 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_INFORMATION_H_
-#define NET_MMT_MMT_INFORMATION_H_
-
-#include "url/gurl.h"
-#include "base/files/file_path.h"
-#include "net/http/http_byte_range.h"
-
-namespace net {
-
-class MmtRequestInfo {
- public:
-  // The requested URL.
-  GURL url;
-};
-
-class MmtResponseInfo {
- public:
-  MmtResponseInfo() {
-    total_size = 0;
-    read_offset = 0;
-    remaining_bytes = 0;
-    expected_content_size = 0;
-  }
-
-  int64 total_size;
-  int64 read_offset;
-  int64 remaining_bytes;
-  int64 expected_content_size;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
deleted file mode 100644
index 1f0e8c7..0000000
--- a/net/mmt/mmt_transaction.cc
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2008 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction.h"
-#include "net/mmt/mmt_transaction_impl.h"
-#include "net/mmt/mmt_transaction_factory.h"
-
-namespace net {
-
-class MmtTransactionFactoryImpl : public MmtTransactionFactory {
-public:
-  MmtTransactionFactoryImpl() : suspended_(false) {
-  }
-  virtual ~MmtTransactionFactoryImpl() override {
-  }
-
-  virtual MmtTransaction* CreateTransaction() override {
-    if (suspended_)
-      return NULL;
-
-    return new MmtTransactionImpl();
-  }
-
-  virtual void Suspend(bool suspend) override {
-    suspended_ = suspend;
-  }
-
-private:
-  bool suspended_;
-};
-
-MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
-  return new MmtTransactionFactoryImpl();
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
deleted file mode 100644
index 05a07fd..0000000
--- a/net/mmt/mmt_transaction.h
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_H_
-#define NET_MMT_MMT_TRANSACTION_H_
-
-#include "net/base/completion_callback.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_states.h"
-#include "net/base/net_export.h"
-
-
-namespace base {
-class TaskRunner;
-}
-
-namespace net {
-
-class MmtResponseInfo;
-class MmtRequestInfo;
-class BoundNetLog;
-class HttpByteRange;
-
-// Represents a single MMT transaction.
-class NET_EXPORT_PRIVATE MmtTransaction {
- public:
-  // Stops any pending IO and destroys the transaction object.
-  virtual ~MmtTransaction() {}
-
-  // Starts the MMT transaction (i.e., sends the MMT request).
-  //
-  // Returns OK if the transaction could be started synchronously, which means
-  // that the request was served from the cache (only supported for directory
-  // listings).  ERR_IO_PENDING is returned to indicate that the
-  // CompletionCallback will be notified once response info is available or if
-  // an IO error occurs.  Any other return value indicates that the transaction
-  // could not be started.
-  //
-  // Regardless of the return value, the caller is expected to keep the
-  // request_info object alive until Destroy is called on the transaction.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  // Profiling information for the request is saved to |net_log| if non-NULL.
-  virtual int Start(const MmtRequestInfo* request_info,
-                    const CompletionCallback& callback,
-                    const BoundNetLog& net_log) = 0;
-
-  // Once response info is available for the transaction, response data may be
-  // read by calling this method.
-  //
-  // Response data is copied into the given buffer and the number of bytes
-  // copied is returned.  ERR_IO_PENDING is returned if response data is not
-  // yet available.  The CompletionCallback is notified when the data copy
-  // completes, and it is passed the number of bytes that were successfully
-  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
-  // the error.  Any other negative return value indicates that the transaction
-  // could not be read.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  virtual int Read(IOBuffer* buf,
-                   int buf_len,
-                   const CompletionCallback& callback) = 0;
-
-  // Returns the response info for this transaction or NULL if the response
-  // info is not available.
-  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
-
-  // Returns the load state for this transaction.
-  virtual LoadState GetLoadState() const = 0;
-
-  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
deleted file mode 100644
index b9b1e6a..0000000
--- a/net/mmt/mmt_transaction_factory.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
-#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
-
-#include "net/base/net_export.h"
-
-namespace net {
-
-class MmtTransaction;
-
-// An interface to a class that can create MmtTransaction objects.
-class NET_EXPORT MmtTransactionFactory {
- public:
-  virtual ~MmtTransactionFactory() {}
-
-  // Creates a MmtTransaction object.
-  virtual MmtTransaction* CreateTransaction() = 0;
-
-  // Suspends the creation of new transactions. If |suspend| is false, creation
-  // of new transactions is resumed.
-  virtual void Suspend(bool suspend) = 0;
-
-  static MmtTransactionFactory* CreateFactory();
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
deleted file mode 100644
index ee2274c..0000000
--- a/net/mmt/mmt_transaction_impl.cc
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction_impl.h"
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/strings/string_util.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/thread_task_runner_handle.h"
-#include "base/threading/thread_restrictions.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
-#include "net/base/net_log.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-
-
-namespace net {
-
-#ifndef TAG
-#define TAG "["<<__func__<<" thiz="<<this<<"]"
-#endif
-
-MmtTransactionImpl::MmtTransactionImpl() :
-      request_(NULL),
-      read_data_buf_len_(0),
-      next_state_(STATE_NONE) {
-  base::ThreadRestrictions::SetIOAllowed(true);
-  response_ = MmtResponseInfo();
-  stream_ = nullptr;
-}
-
-MmtTransactionImpl::~MmtTransactionImpl() {
-  Stop(OK);
-  LOG(INFO) << TAG;
-}
-
-int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << TAG << ", error=" << error;
-
-  last_error_ = error;
-  next_state_ = STATE_STOP;
-  int rv = DoStop();
-  return rv;
-}
-
-int MmtTransactionImpl::RestartIgnoringLastError(
-    const CompletionCallback& callback) {
-  LOG(INFO) << TAG;
-  return ERR_NOT_IMPLEMENTED;
-}
-
-int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                              const CompletionCallback& callback,
-                              const BoundNetLog& net_log) {
-  request_ = request_info;
-  user_callback_ = callback;
-  net_log_ = net_log;
-  next_state_ = STATE_CONNECT;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  int rv = DoConnect();
-  DoCallback(rv);
-  return true;
-#endif
-}
-
-// @return 0 if end, >0 if normal, < 0 if waiting or error
-int MmtTransactionImpl::Read(IOBuffer* buf,
-                             int buf_len,
-                             const CompletionCallback& callback) {
-  DCHECK(buf);
-  DCHECK_GT(buf_len, 0);
-  read_data_buf_ = buf;
-  read_data_buf_len_ = buf_len;
-  user_callback_ = callback;
-  next_state_ = STATE_READ;
-
-  if (response_.remaining_bytes < buf_len)
-    buf_len = static_cast<int>(response_.remaining_bytes);
-    
-  if (buf_len <= 0)
-    return 0;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  return DoRead();
-#endif
-}
-
-const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << TAG;
-  return &response_;
-}
-
-LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  switch (next_state_) {
-    case STATE_NONE: 
-      return LOAD_STATE_IDLE;
-    case STATE_CONNECT:
-      return LOAD_STATE_CONNECTING; 
-    case STATE_READ:
-      return LOAD_STATE_READING_RESPONSE;
-    default: 
-      break;
-  }
-  return LOAD_STATE_IDLE;
-}
-
-void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << TAG 
-    << " range[" << range.first_byte_position() 
-    << ", "  << range.last_byte_position() << "]";
-  byte_range_ = range;
-}
-
-void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
-  task_runner_ = runner;
-}
-
-void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << TAG ;
-  user_callback_.Reset();
-  response_ = MmtResponseInfo();
-  read_data_buf_ = NULL;
-  read_data_buf_len_ = 0;
-  last_error_ = OK;
-  next_state_ = STATE_NONE;
-}
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << TAG;
-  next_state_ = STATE_NONE;
-  if (stream_) {
-    fclose((FILE*)stream_);
-    stream_ = nullptr;
-  }
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << TAG << ", url=" << request_->url;
-
-  // TODO: open file/network
-  if(!FileURLToFilePath(request_->url, &file_path_)) {
-    LOG(ERROR) << TAG << ", invalid file";
-    return ERR_FAILED;
-  }
-
-  response_.total_size = 0;
-  if(!base::GetFileSize(file_path_, &response_.total_size)) {
-    LOG(ERROR) << TAG << ", invalid file size";
-    return ERR_FAILED;
-  }
-
-  if (!byte_range_.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
-    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
-  }
-
-  response_.read_offset = byte_range_.first_byte_position();
-  response_.remaining_bytes = byte_range_.last_byte_position() -
-    byte_range_.first_byte_position() + 1;
-  DCHECK_GE(response_.remaining_bytes, 0);
-
-  LOG(INFO) << TAG 
-    << ", total_size=" << response_.total_size
-    << ", read_offset=" << response_.read_offset
-    << ", content_size=" << response_.expected_content_size;
-
-  FILE *fp = base::OpenFile(file_path_, "rb");
-  if (!fp) {
-    LOG(ERROR) << TAG << ", fail to open file";
-    return ERR_FAILED;
-  }
-  stream_ = (void*)fp;
-  response_.expected_content_size = response_.remaining_bytes;
-
-  return OK;
-}
-
-int MmtTransactionImpl::DoRead() {
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-  DCHECK(stream_);
-  read_data_buf_->data()[0] = 0;
-
-  FILE *fp = (FILE *)stream_;
-  int64 offset = response_.read_offset;
-  fseek(fp, offset, SEEK_SET);
-  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
-  if (rv > 0) {
-    response_.read_offset += rv;
-    response_.remaining_bytes -= rv;
-  }
-  return rv;
-}
-
-int MmtTransactionImpl::DoLoop(int result) {
-  DCHECK(next_state_ != STATE_NONE);
-
-  int rv = result;
-  do {
-    State state = next_state_;
-    next_state_ = STATE_NONE;
-    switch (state) {
-      case STATE_STOP:
-        DCHECK(rv == OK);
-        rv = DoStop();
-        break;
-      case STATE_CONNECT:
-        DCHECK(rv == OK);
-        rv = DoConnect();
-        break;
-      case STATE_READ:
-        DCHECK(rv == OK);
-        rv = DoRead();
-        break;
-      default:
-        NOTREACHED() << "bad state";
-        rv = ERR_UNEXPECTED;
-        break;
-    }
-  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
-  return rv;
-}
-
-void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << TAG << ", rv=" << rv;
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
-
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
-}
-
-void MmtTransactionImpl::OnIOPrepare() {
-}
-
-void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  int rv = DoLoop(OK);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
deleted file mode 100644
index adbe735..0000000
--- a/net/mmt/mmt_transaction_impl.h
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
-#define NET_MMT_MMT_TRANSACTION_IMPL_H_
-
-#include <string>
-#include <utility>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "net/base/address_list.h"
-#include "net/base/auth.h"
-#include "net/base/net_log.h"
-#include "net/dns/host_resolver.h"
-#include "net/dns/single_request_host_resolver.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
-
-
-namespace net {
-
-class FileStream;
-
-class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
- public:
-  MmtTransactionImpl();
-  virtual ~MmtTransactionImpl() override;
-
-  virtual int Stop(int error);
-  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
-
-  // MmtTransaction methods:
-  virtual int Start(const MmtRequestInfo* request_info,
-            const CompletionCallback& callback,
-            const BoundNetLog& net_log) override;
-  virtual int Read(IOBuffer* buf,
-           int buf_len,
-           const CompletionCallback& callback) override;
-  virtual const MmtResponseInfo* GetResponseInfo() const override;
-  virtual LoadState GetLoadState() const override;
-  virtual void SetRequestHeaders(HttpByteRange &range) override;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
-
- private:
-  void ResetStateForRestart();
-  void OnIOPrepare();
-  void OnIOComplete();
-  void DoCallback(int result);
-  int DoLoop(int result);
-  int DoStop();
-  int DoConnect();
-  int DoRead();
-
-  enum State {
-    STATE_STOP,
-    STATE_CONNECT,
-    STATE_READ,
-    STATE_NONE
-  };
-
-private:
-  CompletionCallback user_callback_;
-  scoped_refptr<base::TaskRunner> task_runner_;
-
-  BoundNetLog net_log_;
-  const MmtRequestInfo* request_;
-  MmtResponseInfo response_;
-  HttpByteRange byte_range_;
-
-  void* stream_;
-  base::FilePath file_path_;
-  scoped_refptr<IOBuffer> read_data_buf_;
-  int read_data_buf_len_;
-
-  int last_error_;
-  State next_state_;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gypi b/net/net.gypi
index 0335fc6..ad08a23 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,8 +700,6 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2806657..bd64769 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,10 +52,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
-      mmt_transaction_factory_(mmt_transaction_factory),
+      total_bytes_(0),
+      read_offset_(0),
+      remaining_bytes_(0),
       task_runner_(task_runner),
       weak_ptr_factory_(this) {
-  DCHECK(mmt_transaction_factory);
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
@@ -94,47 +95,39 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << __func__;
-  DCHECK(!mmt_transaction_);
-
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(request_);
-  DCHECK(mmt_transaction_factory_);
-  mmt_request_info_.url = request_->url();
-  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
-  mmt_transaction_->SetTaskRunner(task_runner_);
-  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  mmt_transaction_->Start(
-        &mmt_request_info_,
-        base::Bind(&URLRequestMmtJob::OnStartCompleted,
-                   base::Unretained(this)),
-        request_->net_log());
+
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoStart, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidStart, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
 }
 
 void URLRequestMmtJob::Kill() {
   LOG(INFO) << __FUNCTION__;
-  mmt_transaction_.reset();
-
   URLRequestJob::Kill();
   weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  DCHECK(mmt_transaction_);
-
-  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
-  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
   // MMT obviously doesn't have HTTP Content-Length header. We have to pass
   // the content size information manually.
-  set_expected_content_size(content_size);
+  set_expected_content_size(remaining_bytes_);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -144,7 +137,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   read_in_progress_ = false;
   if (result == OK) {
@@ -164,23 +158,25 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-  DCHECK(mmt_transaction_);
-
-  int rv = mmt_transaction_->Read(buf, buf_size,
-                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
-                                             base::Unretained(this)));
-  LOG(INFO) << __func__ << ", rv=" << rv;
-  if (rv >= 0) {
-    *bytes_read = rv;
+
+  if (remaining_bytes_ < buf_len)
+    buf_len = static_cast<int>(remaining_bytes_);
+
+  if (buf_len == 0) {
+    *bytes_read = 0;
     return true;
   }
 
-  if (rv == ERR_IO_PENDING) {
-    read_in_progress_ = true;
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoRead, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidRead, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
+  read_in_progress_ = true;
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
   return false;
 }
 
@@ -189,4 +185,13 @@ bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
   return false;
 }
 
+void URLRequestMmtJob::DoStart(int* result) {
+}
+void URLRequestMmtJob::DidStart(const int* result) {
+}
+void URLRequestMmtJob::DoRead(int* result) {
+}
+void URLRequestMmtJob::DidRead(const int* result) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 7defe8f..d00ca95 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -42,17 +42,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
+  void DoStart(int* result);
+  void DidStart(const int* result);
   void OnStartCompleted(int result);
+
+  void DoRead(int* result);
+  void DidRead(const int* result);
   void OnReadCompleted(int result);
 
  private:
-  MmtRequestInfo mmt_request_info_;
-  scoped_ptr<MmtTransaction> mmt_transaction_;
-
   HttpByteRange byte_range_;
   bool read_in_progress_;
+  int64 total_bytes_;
+  int64 read_offset_;
+  int64 remaining_bytes_;
 
-  MmtTransactionFactory* mmt_transaction_factory_;
   const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9140756855d7ba36e0346996e9ac7f1ce82667de Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:32:07 -0800
Subject: [PATCH 10/92] add mmt local support

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 -
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 -
 chrome/browser/profiles/profile_io_data.cc         |    5 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/url_request/mmt_protocol_handler.cc            |   20 +-
 net/url_request/mmt_protocol_handler.h             |   11 +-
 net/url_request/url_request_context_builder.cc     |    9 +-
 net/url_request/url_request_context_builder.h      |    1 -
 net/url_request/url_request_mmt_job.cc             |  327 +++++++++++++-------
 net/url_request/url_request_mmt_job.h              |   87 ++++--
 12 files changed, 304 insertions(+), 194 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index d47b636..798bea3 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,11 +261,6 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -275,8 +270,7 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -334,8 +328,7 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -375,8 +368,7 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get(),
-                                            mmt_factory_.get());
+                                            ftp_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index fa54638..900dbfc 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,7 +21,6 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -147,7 +146,6 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 4f21760..8b39439 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,7 +54,6 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -582,11 +581,6 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -603,8 +597,7 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -669,8 +662,7 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -757,8 +749,7 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get(),
-                              mmt_factory_.get()));
+                              ftp_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 505da31..383fc40 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,7 +34,6 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -230,7 +229,6 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 7cb34a4..fee77fb 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,8 +1162,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory,
-    net::MmtTransactionFactory* mmt_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1218,11 +1217,9 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
       new net::MmtProtocolHandler(
-            mmt_transaction_factory,
             content::BrowserThread::GetBlockingPool()->
               GetTaskRunnerWithShutdownBehavior(
                   base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index fcc9fef..244107f 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,7 +34,6 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
-#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -61,7 +60,6 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -360,8 +358,7 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory,
-      net::MmtTransactionFactory* mmt_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index be497ff..19a5fbb 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,32 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
+#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
-#include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_mmt_job.h"
-#include "url/gurl.h"
 
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner>& task_runner)
-    : mmt_transaction_factory_(mmt_transaction_factory),
-      task_runner_(task_runner) {
-  DCHECK(mmt_transaction_factory_);
-}
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    : mmt_task_runner_(mmt_task_runner) {}
 
-MmtProtocolHandler::~MmtProtocolHandler() {
-}
+MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request,
-                              network_delegate,
-                              mmt_transaction_factory_,
-                              task_runner_);
+  return new URLRequestMmtJob(request, network_delegate, mmt_task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 185ac8f..a823916 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -18,17 +18,16 @@ class TaskRunner;
 
 namespace net {
 
-class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for MMT jobs. 
+// Implements a ProtocolHandler for Mmt jobs. If |network_delegate_| is NULL,
+// then all mmt requests will fail with ERR_ACCESS_DENIED.
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
   explicit MmtProtocolHandler(
-      MmtTransactionFactory* mmt_transaction_factory,
-      const scoped_refptr<base::TaskRunner>& task_runner);
+      const scoped_refptr<base::TaskRunner>& mmt_task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -36,9 +35,7 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  MmtTransactionFactory* mmt_transaction_factory_;
-  const scoped_refptr<base::TaskRunner> task_runner_;
-
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 4e5018f..cbdf642 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,7 +18,6 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -410,11 +409,9 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 
 #if !defined(DISABLE_MMT_SUPPORT)
   if (mmt_enabled_) {
-    mmt_transaction_factory_.reset(
-        MmtTransactionFactory::CreateFactory());
-    job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
-                               context->GetFileThread()->message_loop_proxy()));
+    job_factory->SetProtocolHandler(
+        "mmt",
+        new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index c2cec99..bb4d30a 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -227,7 +227,6 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
-  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index bd64769..9d157d9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -2,74 +2,160 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// For loading files, we make use of overlapped i/o to ensure that reading from
-// the filesystem (e.g., a network filesystem) does not block the calling
-// thread.  An alternative approach would be to use a background thread or pool
-// of threads, but it seems better to leverage the operating system's ability
-// to do background file reads for us.
-//
-// Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
-// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequestMmtJob
-// attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequestMmtJob waits for a
-// signal from the OS that the overlapped read has completed.  It does so by
-// leveraging the MessageLoop::WatchObject API.
-
 #include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
+#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
+#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
-#include "net/http/http_response_headers.h"
-#include "net/http/http_transaction_factory.h"
-#include "net/url_request/url_request.h"
-#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
 namespace net {
 
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner> task_runner)
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      read_in_progress_(false),
-      total_bytes_(0),
-      read_offset_(0),
+      stream_(new FileStream(mmt_task_runner)),
+      mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
-      task_runner_(task_runner),
       weak_ptr_factory_(this) {
 }
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+void URLRequestMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequestMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
 }
 
-#if 0
-bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
-  // Disallow all redirects.
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
   return false;
 }
+
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
 #endif
+}
+
+Filter* URLRequestMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
   return false;
 }
 
@@ -94,104 +180,131 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(request_);
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
+}
 
-  // No matter what, we want to report our status as IO pending since we will
-  // be notifying our consumer asynchronously via OnStartCompleted.
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoStart, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidStart, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
 }
 
-void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
 
-  // Clear the IO_PENDING status
-  SetStatus(URLRequestStatus());
+  // We use URLRequestMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
 
-  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-  // the content size information manually.
-  set_expected_content_size(remaining_bytes_);
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
-  if (result == OK) {
-    NotifyHeadersComplete();
-  }else {
+  if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
   }
-}
 
-void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  read_in_progress_ = false;
-  if (result == OK) {
-    NotifyDone(URLRequestStatus());
-  } else if (result < 0) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequestMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequestMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
   } else {
-    // Clear the IO_PENDING status
-    SetStatus(URLRequestStatus());
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
   }
-  NotifyReadComplete(result);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
-                                    int buf_size,
-                                    int* bytes_read) {
-  DCHECK_NE(buf_size, 0);
-  DCHECK(bytes_read);
-  DCHECK(!read_in_progress_);
+void URLRequestMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  if (remaining_bytes_ < buf_len)
-    buf_len = static_cast<int>(remaining_bytes_);
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
 
-  if (buf_len == 0) {
-    *bytes_read = 0;
-    return true;
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
   }
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoRead, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidRead, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
-  read_in_progress_ = true;
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  return false;
-}
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  return false;
-}
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
 
-void URLRequestMmtJob::DoStart(int* result) {
-}
-void URLRequestMmtJob::DidStart(const int* result) {
-}
-void URLRequestMmtJob::DoRead(int* result) {
-}
-void URLRequestMmtJob::DidRead(const int* result) {
+  NotifyReadComplete(result);
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index d00ca95..5e93f97 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,56 +8,97 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
 namespace net {
 
-class NetworkDelegate;
-class MmtTransactionFactory;
+class FileStream;
 
-// A request job that handles reading mmt URLs
+// A request job that handles reading file URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                   NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory,
-                   const scoped_refptr<base::TaskRunner> task_runner);
+                    NetworkDelegate* network_delegate,
+                    const scoped_refptr<base::TaskRunner>& mmt_task_runner);
 
- protected:
-  ~URLRequestMmtJob() override;
-
-  // Overridden from URLRequestJob:
+  // URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
- private:
-  void DoStart(int* result);
-  void DidStart(const int* result);
-  void OnStartCompleted(int result);
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
 
-  void DoRead(int* result);
-  void DidRead(const int* result);
-  void OnReadCompleted(int result);
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
 
  private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+
   HttpByteRange byte_range_;
-  bool read_in_progress_;
-  int64 total_bytes_;
-  int64 read_offset_;
   int64 remaining_bytes_;
 
-  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From c9c8fc65c620b3909a80f0434818bef397a90dfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:41:00 -0800
Subject: [PATCH 11/92] OK for mmt local file

---
 net/url_request/url_request_mmt_job.cc |   50 ++------------------------------
 net/url_request/url_request_mmt_job.h  |    4 ---
 2 files changed, 2 insertions(+), 52 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 9d157d9..3e01eca 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
+  FileURLToFilePath(request_->url(), &file_path_);
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -109,53 +110,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  return NULL;
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
   return false;
 }
 
@@ -180,12 +143,6 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-}
-
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-}
-
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
@@ -277,7 +234,6 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
-  OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                                 ERR_REQUEST_RANGE_NOT_SATISFIABLE));
@@ -294,8 +250,6 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
     remaining_bytes_ -= result;
     DCHECK_GE(remaining_bytes_, 0);
   }
-
-  OnReadComplete(buf.get(), result);
   buf = NULL;
 
   if (result == 0) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 5e93f97..046bffe 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -43,10 +43,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
  protected:
   ~URLRequestMmtJob() override;
 
-- 
1.7.9.5


From 9db8aa65f97993cd6e1022f01c3fd934b87c398c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 09:07:06 -0800
Subject: [PATCH 12/92] save 1

---
 net/url_request/url_request_mmt_job.cc |   41 ++++++++++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h  |   11 +++++++++
 2 files changed, 52 insertions(+)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3e01eca..0eb13a1 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -39,6 +39,13 @@ URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
       is_directory(false) {
 }
 
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
+    : read_offset(0),
+      remaining_bytes(0),
+      dest(nullptr),
+      dest_size(0) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
@@ -52,6 +59,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
+  read_info_.file_path = file_path_;
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -86,15 +94,32 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
+#if 0
   int rv = stream_->Read(dest,
                          dest_size,
                          base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
+#endif
+  int rv = ERR_IO_PENDING;
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  read_info->file_path = read_info_.file_path;
+  read_info->read_offset = read_info_.read_offset;
+  read_info->dest = dest;
+  read_info->dest_size = dest_size;
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::DoRead, 
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidRead2,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
     remaining_bytes_ -= rv;
+    read_info_.remaining_bytes -= rv;
+    read_info_.read_offset += rv;
     DCHECK_GE(remaining_bytes_, 0);
     return true;
   }
@@ -108,6 +133,18 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
+  DidRead(read_info->dest, read_info->dest_size);
+}
+
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -208,6 +245,8 @@ void URLRequestMmtJob::DidOpen(int result) {
 
   remaining_bytes_ = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
+  read_info_.remaining_bytes = remaining_bytes_;
+  read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
   if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
@@ -248,6 +287,8 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
+    read_info_.remaining_bytes -= result;
+    read_info_.read_offset += result;
     DCHECK_GE(remaining_bytes_, 0);
   }
   buf = NULL;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 046bffe..82cc67f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -86,6 +86,16 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidSeek(int64 result);
 
   // Callback after data is asynchronously read from the file into |buf|.
+  struct ReadMetaInfo {
+    ReadMetaInfo();
+    int64 read_offset;
+    int64 remaining_bytes;
+    IOBuffer* dest;
+    int32 dest_size;
+    base::FilePath file_path;
+  };
+  static void DoRead(ReadMetaInfo* read_info);
+  void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
   scoped_ptr<FileStream> stream_;
@@ -94,6 +104,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
+  ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 476f6960e893cb2485861d2c4e9b23a314653228 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 22:53:52 -0800
Subject: [PATCH 13/92] [ok] for async read

---
 net/url_request/url_request_mmt_job.cc |  117 +++++++-------------------------
 net/url_request/url_request_mmt_job.h  |   37 ++--------
 2 files changed, 29 insertions(+), 125 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0eb13a1..c0c35e2 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -32,15 +32,12 @@
 
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
+// TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : read_offset(0),
+    : is_started(false),
+      handle(nullptr),
+      total_size(0),
+      read_offset(0),
       remaining_bytes(0),
       dest(nullptr),
       dest_size(0) {
@@ -51,7 +48,6 @@ URLRequestMmtJob::URLRequestMmtJob(
     NetworkDelegate* network_delegate,
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      stream_(new FileStream(mmt_task_runner)),
       mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {
@@ -60,18 +56,20 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
   read_info_.file_path = file_path_;
-  FileMetaInfo* meta_info = new FileMetaInfo();
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DoStart,
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidStart,
                  weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+                 base::Owned(read_info)));
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  if (read_info_.handle) fclose((FILE*)read_info_.handle);
+  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -94,17 +92,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-#if 0
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
-#endif
   int rv = ERR_IO_PENDING;
   ReadMetaInfo* read_info = new ReadMetaInfo;
-  read_info->file_path = read_info_.file_path;
-  read_info->read_offset = read_info_.read_offset;
+  *read_info = read_info_;
   read_info->dest = dest;
   read_info->dest_size = dest_size;
   mmt_task_runner_->PostTaskAndReply(
@@ -134,7 +124,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
   if (fp) {
     fseek(fp, read_info->read_offset, SEEK_SET);
     read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
@@ -183,48 +173,19 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
+void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
+  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
+void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  read_info_ = *read_info;
+
+  if (!read_info_.is_started) {
     DidOpen(ERR_FILE_NOT_FOUND);
     return;
   }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
+  DidOpen(OK);
 }
 
 void URLRequestMmtJob::DidOpen(int result) {
@@ -237,7 +198,7 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -249,36 +210,6 @@ void URLRequestMmtJob::DidOpen(int result) {
   read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
-  }
-}
-
-void URLRequestMmtJob::DidSeek(int64 result) {
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-
   set_expected_content_size(remaining_bytes_);
   NotifyHeadersComplete();
 }
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 82cc67f..50cf98f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -52,54 +52,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   base::FilePath file_path_;
 
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
+    bool is_started;
+    void* handle;
+    int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+  static void DoStart(ReadMetaInfo* read_info);
+  void DidStart(ReadMetaInfo* read_info);
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-- 
1.7.9.5


From c998a008a6dd587dac8c808247690530213e3a95 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 23:08:50 -0800
Subject: [PATCH 14/92] [ok] refine base on 476f696

---
 net/url_request/url_request_mmt_job.cc |   69 +++++++++++++-------------------
 net/url_request/url_request_mmt_job.h  |   17 +++-----
 2 files changed, 32 insertions(+), 54 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c0c35e2..2537c62 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -35,7 +35,6 @@ namespace net {
 // TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
     : is_started(false),
-      handle(nullptr),
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -49,13 +48,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
-      remaining_bytes_(0),
       weak_ptr_factory_(this) {
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &file_path_);
-  read_info_.file_path = file_path_;
+  FileURLToFilePath(request_->url(), &read_info_.file_path);
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -68,8 +65,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  if (read_info_.handle) fclose((FILE*)read_info_.handle);
-  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -80,12 +75,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
+  if (read_info_.remaining_bytes < dest_size)
+    dest_size = static_cast<int>(read_info_.remaining_bytes);
 
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // If we should copy zero bytes because |remaining_bytes| is zero, short
   // circuit here.
   if (!dest_size) {
     *bytes_read = 0;
@@ -101,16 +96,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoRead, 
                  base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead2,
+      base::Bind(&URLRequestMmtJob::DidRead,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
-    remaining_bytes_ -= rv;
     read_info_.remaining_bytes -= rv;
     read_info_.read_offset += rv;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
     return true;
   }
 
@@ -123,18 +117,6 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
-  }
-}
-void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
-  DidRead(read_info->dest, read_info->dest_size);
-}
-
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -146,7 +128,8 @@ Filter* URLRequestMmtJob::SetupFilter() const {
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  return false;
+  *mime_type = std::string("text/html");
+  return true;
 }
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
@@ -175,23 +158,18 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
   read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
-  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  int result = OK;
   read_info_ = *read_info;
-
   if (!read_info_.is_started) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
+    result = ERR_FAILED;
   }
-  DidOpen(OK);
-}
 
-void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidStart"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -204,25 +182,32 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
+  read_info_.remaining_bytes = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
-  read_info_.remaining_bytes = remaining_bytes_;
   read_info_.read_offset = byte_range_.first_byte_position();
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  set_expected_content_size(remaining_bytes_);
+  set_expected_content_size(read_info_.remaining_bytes);
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+
+void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
+  int result = read_info->dest_size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
     read_info_.remaining_bytes -= result;
     read_info_.read_offset += result;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  buf = NULL;
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 50cf98f..15e7600 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -46,37 +46,30 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  protected:
   ~URLRequestMmtJob() override;
 
-  int64 remaining_bytes() const { return remaining_bytes_; }
-
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
     bool is_started;
-    void* handle;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
+
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+
   static void DoStart(ReadMetaInfo* read_info);
   void DidStart(ReadMetaInfo* read_info);
+
   static void DoRead(ReadMetaInfo* read_info);
-  void DidRead2(ReadMetaInfo* read_info);
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+  void DidRead(ReadMetaInfo* read_info);
 
+ private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
   ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
-- 
1.7.9.5


From 3301a59dd29064a4c664bb210f1250b7d43bb2b9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:10:18 -0800
Subject: [PATCH 15/92] prepare to use mmt stream

---
 net/url_request/url_request_mmt_job.cc |   20 +++++++++++++-------
 net/url_request/url_request_mmt_job.h  |    3 ++-
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2537c62..59ce61d 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -52,7 +53,9 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &read_info_.file_path);
+  base::FilePath file_path;
+  FileURLToFilePath(request_->url(), &file_path);
+  read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -157,7 +160,8 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  read_info->is_started = base::GetFileSize(
+    base::FilePath(read_info->uri), &read_info->total_size);
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
@@ -192,12 +196,14 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
+#if 0
+  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
+  if (stream) {
+    read_info->dest_size = stream->Read(read_info->dest->data(), 
+                                      read_info->dest_size, 
+                                      read_info->read_offset);
   }
+#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 15e7600..227cf51 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,6 +7,7 @@
 
 #include <string>
 #include <vector>
+#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
@@ -57,7 +58,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    base::FilePath file_path;
+    std::string uri;
   };
 
   static void DoStart(ReadMetaInfo* read_info);
-- 
1.7.9.5


From 5419132e1312ea615b586cd218280c46b53869fe Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:41:53 -0800
Subject: [PATCH 16/92] add net/mmt module

---
 net/mmt/mmt_stream.cc                 |   40 ++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                  |   51 +++++++++++++++++++++++++++++++++
 net/net.gypi                          |    1 +
 net/url_request/url_request_mmt_job.h |    1 -
 4 files changed, 92 insertions(+), 1 deletion(-)
 create mode 100644 net/mmt/mmt_stream.cc
 create mode 100644 net/mmt/mmt_stream.h

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
new file mode 100644
index 0000000..28c19d8
--- /dev/null
+++ b/net/mmt/mmt_stream.cc
@@ -0,0 +1,40 @@
+#include "net/mmt/mmt_stream.h"
+
+namespace mmt {
+
+Stream::Stream(const std::string &uri) 
+    : uri_(uri), file_(nullptr) { 
+}
+
+Stream::~Stream() {
+}
+
+std::string Stream::getUri() {
+  return uri_;
+}
+
+int Stream::Read(char *buf, int size, int offset) {
+  return 0; 
+}
+
+StreamPool* StreamPool::ginst_ = nullptr;
+
+StreamPool::StreamPool() {
+}
+StreamPool::~StreamPool() {
+}
+
+StreamPtr StreamPool::getStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter == streams_.end()) {
+        return nullptr;
+    }
+    return iter->second;
+}
+
+StreamPtr StreamPool::addStream(std::string &uri) {
+    StreamPtr stream = getStream(uri);
+    return stream;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
new file mode 100644
index 0000000..d4761cf
--- /dev/null
+++ b/net/mmt/mmt_stream.h
@@ -0,0 +1,51 @@
+#ifndef NET_MMT_MMT_STREAM_H_
+#define NET_MMT_MMT_STREAM_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+
+namespace mmt {
+
+class Stream : public base::RefCounted<Stream> {
+public:
+    friend class StreamPool;
+    Stream(const std::string &uri);
+    std::string getUri();
+    int Read(char *buf, int size, int offset);
+
+protected:
+    virtual ~Stream();
+
+private:
+    std::string uri_;
+    FILE *file_;
+};
+
+//typedef scoped_refptr<Stream> StreamPtr;
+typedef Stream* StreamPtr;
+typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::map<std::string, StreamPtr>  streams_t;
+
+class StreamPool {
+public:
+    StreamPool();
+    ~StreamPool();
+
+    StreamPtr getStream(std::string &uri);
+    StreamPtr addStream(std::string &uri);
+    static StreamPool *inst();
+
+protected:
+    static StreamPool *ginst_; 
+
+private:
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+#endif
diff --git a/net/net.gypi b/net/net.gypi
index ad08a23..cc6c1b2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,7 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_stream.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 227cf51..3488cee 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,7 +7,6 @@
 
 #include <string>
 #include <vector>
-#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
-- 
1.7.9.5


From f35f026c2661c87da64c55512453e856b79a57ba Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:58:49 -0800
Subject: [PATCH 17/92] fix for compile

---
 net/mmt/mmt_stream.cc                  |   40 ++++++++++++++++++++++++++++++--
 net/mmt/mmt_stream.h                   |   14 +++++++----
 net/url_request/url_request_mmt_job.cc |    8 +++----
 3 files changed, 52 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 28c19d8..66e074f 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -7,16 +7,34 @@ Stream::Stream(const std::string &uri)
 }
 
 Stream::~Stream() {
+    Uninit();
 }
 
 std::string Stream::getUri() {
-  return uri_;
+    return uri_;
+}
+
+bool Stream::Init() {
+    if (file_) return true;
+    file_ = fopen(uri_.c_str(), "rb");
+    if (file_) return true;
+    return true;
 }
 
 int Stream::Read(char *buf, int size, int offset) {
-  return 0; 
+    if (!Init()) return -1;
+    fseek(file_, offset, SEEK_SET);
+    int iret = fread(buf, 1, size, file_);
+    return iret; 
+}
+
+void Stream::Uninit() {
+    LOG(INFO) << "Stream::Uninit";
+    if (file_) fclose(file_);
+    file_ = nullptr;
 }
 
+
 StreamPool* StreamPool::ginst_ = nullptr;
 
 StreamPool::StreamPool() {
@@ -34,7 +52,25 @@ StreamPtr StreamPool::getStream(std::string &uri) {
 
 StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
+    if (!stream.get()) {
+        stream = new Stream(uri);
+        streams_.insert(pair_t(uri, stream));
+    }
     return stream;
 }
 
+void StreamPool::delStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter != streams_.end()) {
+        streams_.erase(iter);
+    }
+}
+ 
+StreamPool *StreamPool::inst() {
+    if (!ginst_) {
+        ginst_ = new StreamPool;
+    }
+    return ginst_;
+}
+
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d4761cf..b8ba20b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -5,6 +5,7 @@
 #include <string>
 #include <vector>
 
+#include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 
@@ -12,21 +13,24 @@ namespace mmt {
 
 class Stream : public base::RefCounted<Stream> {
 public:
-    friend class StreamPool;
-    Stream(const std::string &uri);
+    explicit Stream(const std::string &uri);
     std::string getUri();
+    bool Init();
     int Read(char *buf, int size, int offset);
+    void Uninit();
 
 protected:
+    friend class base::RefCounted<Stream>;
     virtual ~Stream();
 
 private:
     std::string uri_;
     FILE *file_;
+
+    DISALLOW_COPY_AND_ASSIGN(Stream);
 };
 
-//typedef scoped_refptr<Stream> StreamPtr;
-typedef Stream* StreamPtr;
+typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
@@ -37,6 +41,8 @@ public:
 
     StreamPtr getStream(std::string &uri);
     StreamPtr addStream(std::string &uri);
+    void delStream(std::string &uri);
+
     static StreamPool *inst();
 
 protected:
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 59ce61d..05611a0 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+#include "net/mmt/mmt_stream.h"
 
 namespace net {
 
@@ -68,6 +69,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -196,14 +198,12 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-#if 0
-  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
-  if (stream) {
+  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
+  if (stream.get()) {
     read_info->dest_size = stream->Read(read_info->dest->data(), 
                                       read_info->dest_size, 
                                       read_info->read_offset);
   }
-#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-- 
1.7.9.5


From 1e6109a0a81a10ae15836801f854c4991dac4ec7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 06:51:25 -0800
Subject: [PATCH 18/92] [ok] add lock to proctection

---
 net/mmt/mmt_stream.cc |   20 +++++++++++++++++++-
 net/mmt/mmt_stream.h  |    3 +++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 66e074f..5a75700 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,6 +4,7 @@ namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
+    LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
 }
 
 Stream::~Stream() {
@@ -18,6 +19,14 @@ bool Stream::Init() {
     if (file_) return true;
     file_ = fopen(uri_.c_str(), "rb");
     if (file_) return true;
+    return false;
+}
+
+bool Stream::Prepare(int64 *size) {
+    if (!Init()) return false;
+    fseek(file_, 0L, SEEK_END);
+    int64 lret = ftell(file_);
+    *size = lret;
     return true;
 }
 
@@ -29,7 +38,7 @@ int Stream::Read(char *buf, int size, int offset) {
 }
 
 void Stream::Uninit() {
-    LOG(INFO) << "Stream::Uninit";
+    LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     if (file_) fclose(file_);
     file_ = nullptr;
 }
@@ -43,10 +52,13 @@ StreamPool::~StreamPool() {
 }
 
 StreamPtr StreamPool::getStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter == streams_.end()) {
+        lock_.Release();
         return nullptr;
     }
+    lock_.Release();
     return iter->second;
 }
 
@@ -54,16 +66,22 @@ StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
     if (!stream.get()) {
         stream = new Stream(uri);
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
+        lock_.Acquire();
         streams_.insert(pair_t(uri, stream));
+        lock_.Release();
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
     }
     return stream;
 }
 
 void StreamPool::delStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter != streams_.end()) {
         streams_.erase(iter);
     }
+    lock_.Release();
 }
  
 StreamPool *StreamPool::inst() {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b8ba20b..0d5e6eb 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -8,6 +8,7 @@
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
 
 namespace mmt {
 
@@ -16,6 +17,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
+    bool Prepare(int64 *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
@@ -50,6 +52,7 @@ protected:
 
 private:
     streams_t streams_;
+    base::Lock lock_;
 };
 
 } // namespace mmt
-- 
1.7.9.5


From c50f50a14b7cab3b699306a95c39c0ae505a4d35 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 12 Jan 2015 06:55:46 -0800
Subject: [PATCH 19/92] how to get web_contents from internal

---
 net/mmt/mmt_stream.cc                  |   96 ++++++++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                   |   13 +++++
 net/net.gyp                            |    4 ++
 net/url_request/url_request_mmt_job.cc |   11 ++++
 net/url_request/url_request_mmt_job.h  |    5 ++
 5 files changed, 129 insertions(+)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5a75700..e0dac96 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,7 +1,103 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/resource_context.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+
+using namespace content;
+
 namespace mmt {
 
+#if 0
+    //content::ResourceContext* rcontext = rinfo->GetContext();
+    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
+    //content::RenderThread::Get()->Send(message);
+    //ContentClient* client = GetContentClient();
+    //ContentBrowserClient* browser = client->browser();
+#endif
+
+bool GetRequestID(const net::URLRequest* request, Content* content) {
+    LOG(INFO) << __func__;
+    if (!content) return false;
+
+    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
+    }
+
+    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    if (is_ok) {
+        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
+            << ", render_frame_id: " << content->frame_id;
+    }
+
+    return is_ok;
+}
+
+static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
+    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
+    if (rfh) {
+        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+    }
+    return rfh;
+}
+
+#if 0
+static RenderView* Get_RenderView(int routing_id) {
+    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    if (rv) {
+        blink::WebView* web_view = rv->GetWebView();
+        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
+    }
+    return rv;
+}
+#endif
+
+static void Post_Fullscreen(int process_id, int frame_id) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    if (rfh) {
+        rfh = nullptr;
+    }
+}
+
+void PostTask(int msg_type, const Content* content) {
+    if (content) {
+        Post_Fullscreen(content->process_id, content->frame_id);
+    }
+}
+
+#if 0
+void Run_Javascript(const string js) {
+    // => RenderFrame
+    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        //content::ResourceContext* rcontext = rinfo->GetContext();
+        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
+            << ", frame id: " << rinfo->GetRenderFrameID();
+        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
+            js,
+            rinfo->GetRouteID(), 
+            false);
+        content::RenderThread::Get()->Send(message);
+    }
+}
+#endif
+
+
+///======================
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0d5e6eb..0ba5b97 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,8 +10,21 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+namespace net {
+class URLRequest;
+}
+
 namespace mmt {
 
+struct Content {
+    int process_id;
+    int frame_id;
+    int routing_id;
+};
+
+bool GetRequestID(const net::URLRequest* request, Content* content);
+void PostTask(int msg_type, const Content* content);
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/net.gyp b/net/net.gyp
index eb27320..242582f 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -101,6 +101,10 @@
         '<@(net_nacl_common_sources)',
         '<@(net_non_nacl_sources)',
       ],
+      'include_dirs': [
+         '../skia/config',
+         '../third_party/skia/include/core',
+      ],
       'defines': [
         'NET_IMPLEMENTATION',
       ],
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 05611a0..3437a6e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,6 +31,7 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
+#include "content/public/browser/browser_thread.h"
 
 namespace net {
 
@@ -51,6 +52,8 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::GetRequestID(request_, &content_);
+  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -59,6 +62,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoStart,
@@ -224,4 +228,11 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+}
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 3488cee..468db82 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,6 +15,7 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+#include "net/mmt/mmt_stream.h"
 
 namespace base {
 class TaskRunner;
@@ -66,11 +67,15 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
 
+  static void DoTest(void* ptr);
+  void DidTest(void* ptr);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
+  mmt::Content content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 491388d5953265f11bd2504c64cdb7e29f7cf986 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 06:16:27 -0800
Subject: [PATCH 20/92] try on for web_contents

---
 net/mmt/mmt_stream.cc                  |  118 +++++++++++++++++++++++++++++---
 net/mmt/mmt_stream.h                   |   10 +++
 net/url_request/url_request_mmt_job.cc |    3 +
 3 files changed, 121 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e0dac96..7572ae2 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,17 +1,24 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/browser_thread.h"
 #include "content/public/browser/resource_request_info.h"
 #include "content/public/browser/resource_context.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
+#include "content/public/browser/render_view_host.h"
+
 #include "content/public/common/content_client.h"
-#include "content/public/browser/browser_thread.h"
 #include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
 
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
+
 using namespace content;
 
 namespace mmt {
@@ -41,6 +48,13 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
             << ", render_frame_id: " << content->frame_id;
     }
 
+    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
+        << ", frame id=" << rinfo->GetRenderFrameID()
+        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
+        << ", is main frame=" << rinfo->IsMainFrame()
+        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
+        << "";
+
     return is_ok;
 }
 
@@ -48,14 +62,17 @@ static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
     if (rfh) {
         WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+        RenderViewHost* rvh = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
+        contents = nullptr;
+        rvh = nullptr;
     }
     return rfh;
 }
 
 #if 0
 static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
     if (rv) {
         blink::WebView* web_view = rv->GetWebView();
         LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
@@ -64,17 +81,93 @@ static RenderView* Get_RenderView(int routing_id) {
 }
 #endif
 
-static void Post_Fullscreen(int process_id, int frame_id) {
+void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
+    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
+    LOG(INFO) << __func__ << " rfh=" << rfh;
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+
+    if (rfh) {
+        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
+        content::WebUI* webui = web_contents->GetWebUI();
+        LOG(INFO) << __func__ << " webui=" << webui;
+
+        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view1=" << render_view1;
+        if (render_view1) {
+            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
+            LOG(INFO) << __func__ << " view1=" << view1;
+        }
+
+        WebContentsDelegate* delegate = web_contents->GetDelegate();
+        LOG(INFO) << __func__ << " delegate=" << delegate;
+
+        RenderFrameHost* main_frame = web_contents->GetMainFrame();
+        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
+        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
+        RenderViewHost* main_view = main_frame->GetRenderViewHost();
+        LOG(INFO) << __func__ << " main_view=" << main_view;
+        if (main_view) {
+            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
+            LOG(INFO) << __func__ << " view=" << view;
+        }
+
+        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
+        LOG(INFO) << __func__ << " browser_context=" << browser_context;
+
+        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view2=" << render_view2;
+        if (render_view2) {
+            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
+            LOG(INFO) << __func__ << " view2=" << view2;
+        }
+
+        GURL url = web_contents->GetURL();
+        LOG(INFO) << __func__ << " url=" << url;
+
+        js = "console.log(document.getElementById(\"Video1\"));";
+        LOG(INFO) << __func__ << " js=" << js;
+        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+
+        std::string css = "<style>"
+            "body{"
+                "font-family: Verdana, Cursor;"
+                "font-size: 10px;"
+                "font-weight: bold;"
+            "}"
+            "</style>";
+        web_contents->InsertCSS(css);
+
+        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //web_contents->ViewSource();
+        LOG(INFO) << __func__ << " END";
+    }
+}
+
+void Do_Fullscreen(const Content* content) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     if (rfh) {
         rfh = nullptr;
     }
 }
 
 void PostTask(int msg_type, const Content* content) {
-    if (content) {
-        Post_Fullscreen(content->process_id, content->frame_id);
+    switch(msg_type) {
+    case Msg_RunJavaScript:
+        static bool _brun = false;
+        if (content && !_brun) {
+            _brun = true;
+            Do_JavaScript(content, content->data);
+        }
+        break;
     }
 }
 
@@ -95,8 +188,13 @@ void Run_Javascript(const string js) {
 }
 #endif
 
+} // namespace mmt
 
-///======================
+
+///===============================
+/// for class Stream and StreamPool
+
+namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0ba5b97..2c937d3 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,15 +16,25 @@ class URLRequest;
 
 namespace mmt {
 
+enum {
+    Msg_RunJavaScript,
+};
+
 struct Content {
     int process_id;
     int frame_id;
     int routing_id;
+    std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
 
+} // namespace mmt
+
+
+namespace mmt {
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3437a6e..cdbd903 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
   DoTest((void*)&content_);
 }
 
@@ -62,6 +63,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -232,6 +234,7 @@ void URLRequestMmtJob::DoTest(void* ptr) {
     content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
                           base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 }
+
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
-- 
1.7.9.5


From d39bf190e6c5de4cf2f7fefb2fdb796c47dc228a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 16:48:22 -0800
Subject: [PATCH 21/92] add extension of cimsg

---
 .../docs/examples/api/cimsg/background.js          |   87 ++++++++++++
 .../docs/examples/api/cimsg/install_host.sh        |   40 ++++++
 .../docs/examples/api/cimsg/manifest.json          |   24 ++++
 .../docs/examples/api/cimsg/native-messaging-cimsg |  142 ++++++++++++++++++++
 .../examples/api/cimsg/org.chromium.cimsg.json     |   13 ++
 5 files changed, 306 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/background.js
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/manifest.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
new file mode 100644
index 0000000..11a23b8
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -0,0 +1,87 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+var port = null;
+var tabid = -1;
+
+var getKeys = function(obj){
+  var keys = [];
+  for(var key in obj){
+    keys.push(key);
+  }
+  return keys;
+}
+
+function parseJSON(data) {
+  return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function("return " + data))(); 
+}
+
+function logMsg(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript({
+        code: js
+    });
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS({
+        code: css
+    });
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cimsg";
+  port = chrome.runtime.connectNative(hostName);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+
+/// events
+chrome.tabs.onCreated.addListener(function(tab) {
+});
+chrome.tabs.onActivated.addListener(function(info) {
+  //chrome.tabs.executeScript({file: "ci.js"});
+});
+chrome.browserAction.onClicked.addListener(function(tab) {
+  chrome.tabs.executeScript({
+    code: 'document.body.style.backgroundColor="red"'
+  });
+});
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
+    tabid = tab.id;
+    connect();
+  }
+});
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
new file mode 100755
index 0000000..da7105e
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cimsg
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cimsg
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
new file mode 100644
index 0000000..fea9000
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
@@ -0,0 +1,24 @@
+{
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
+    "name": "org.chromium.cimsg",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium native messaging for ci",
+    "permissions": [
+        "tabs",
+        "nativeMessaging",
+        "activeTab",
+        "notifications",
+        "http://*/",
+        "https://*/",
+        "file://*/",
+        "mmt://*/"
+    ],
+   "browser_action": {
+        "default_title": "Make this page red"
+    },
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    }
+}
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
new file mode 100755
index 0000000..b321a25
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -0,0 +1,142 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  try:
+    jdata = JSONDecoder().decode(message);
+    if not jdata: return
+  except:
+    return
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  sys.stdout.flush()
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.bind((host, port))
+  while True:
+    try:
+      msg, addr = sock.recvfrom(65536)
+      send_message(msg.strip())
+    except: 
+      break
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  pass
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
new file mode 100644
index 0000000..2118005
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cimsg",
+  "description": "Chromium Native Messaging For CI",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
-- 
1.7.9.5


From e604015ed16aaabe322aa0ca2ac86e07e4ca9e34 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 00:18:10 -0800
Subject: [PATCH 22/92] refine cimsg extension

---
 .../docs/examples/api/cimsg/background.js          |    1 -
 .../docs/examples/api/cimsg/native-messaging-cimsg |   31 +++++---
 net/mmt/mmt_stream.cc                              |   83 ++++++++------------
 net/mmt/mmt_stream.h                               |    1 +
 net/url_request/url_request_mmt_job.cc             |    9 +--
 5 files changed, 56 insertions(+), 69 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
index 11a23b8..daf7dd5 100644
--- a/chrome/common/extensions/docs/examples/api/cimsg/background.js
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -79,7 +79,6 @@ chrome.browserAction.onClicked.addListener(function(tab) {
 });
 chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
   if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
-    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
     tabid = tab.id;
     connect();
   }
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
index b321a25..05279a2 100755
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -10,6 +10,8 @@ import struct
 import sys
 import threading
 import Queue
+
+import time
 import socket
 from json import JSONDecoder
 
@@ -23,29 +25,36 @@ except ImportError:
 # Helper function that sends a message to the webapp.
 def send_message(message):
   # message must be JSON string
-  try:
-    jdata = JSONDecoder().decode(message);
-    if not jdata: return
-  except:
-    return
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
   # Write message size.
   sys.stdout.write(struct.pack('I', len(message)))
   # Write the message itself.
   sys.stdout.write(message)
-  sys.stdout.flush()
+  try:
+    sys.stdout.flush()
+  except: return
 
 # Thread that reads messages from control point
 def read_ctrl_func():
   host = "localhost"
   port = 54321
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   sock.bind((host, port))
   while True:
-    try:
-      msg, addr = sock.recvfrom(65536)
-      send_message(msg.strip())
-    except: 
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
       break
+    send_message(msg)
+  sock.close()
 
 # Thread that reads messages from the webapp.
 def read_thread_func(queue):
@@ -115,7 +124,7 @@ def Daemon():
   rthread.daemon = True
   rthread.start()
   read_ctrl_func()
-  pass
+  sys.exit(0)
 
 def Main():
   if not Tkinter:
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7572ae2..996b6a0 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -17,19 +17,41 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/threading/thread_restrictions.h"
+#include "net/udp/udp_socket.h"
+#include "net/base/io_buffer.h"
+#include "base/memory/ref_counted.h"
 
 
 using namespace content;
 
 namespace mmt {
 
-#if 0
-    //content::ResourceContext* rcontext = rinfo->GetContext();
-    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
-    //content::RenderThread::Get()->Send(message);
-    //ContentClient* client = GetContentClient();
-    //ContentBrowserClient* browser = client->browser();
-#endif
+void PostCtrl(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+}
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
@@ -58,32 +80,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
-    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
-    if (rfh) {
-        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        RenderViewHost* rvh = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
-        contents = nullptr;
-        rvh = nullptr;
-    }
-    return rfh;
-}
-
-#if 0
-static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
-    if (rv) {
-        blink::WebView* web_view = rv->GetWebView();
-        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
-    }
-    return rv;
-}
-#endif
-
 void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
@@ -153,12 +151,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
 void Do_Fullscreen(const Content* content) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
-    if (rfh) {
-        rfh = nullptr;
-    }
 }
 
+//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 void PostTask(int msg_type, const Content* content) {
     switch(msg_type) {
     case Msg_RunJavaScript:
@@ -171,23 +167,6 @@ void PostTask(int msg_type, const Content* content) {
     }
 }
 
-#if 0
-void Run_Javascript(const string js) {
-    // => RenderFrame
-    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        //content::ResourceContext* rcontext = rinfo->GetContext();
-        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
-            << ", frame id: " << rinfo->GetRenderFrameID();
-        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
-            js,
-            rinfo->GetRouteID(), 
-            false);
-        content::RenderThread::Get()->Send(message);
-    }
-}
-#endif
-
 } // namespace mmt
 
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 2c937d3..4abe1d2 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -29,6 +29,7 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
+void PostCtrl(std::string msg);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index cdbd903..0a54267 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,8 +53,6 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
-  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
-  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -63,7 +61,6 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
-  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -228,11 +225,13 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
+
+  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
+  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From 94263660d2c90151eaf57ed68df115e6c73acc62 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 05:50:16 -0800
Subject: [PATCH 23/92] add ctrl center

---
 net/mmt/mmt_stream.cc                  |   87 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |    5 +-
 net/url_request/url_request_mmt_job.cc |    3 --
 3 files changed, 89 insertions(+), 6 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 996b6a0..7f7b98a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -16,16 +16,98 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
-#include "base/threading/thread_restrictions.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+
+#include "base/threading/thread_restrictions.h"
 #include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
 
 
 using namespace content;
 
 namespace mmt {
 
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        std::string head;
+        std::string body;
+    };
+
+    CtrlCenter() : SimpleThread("ctrlcenter"){}
+    virtual ~CtrlCenter() {}
+
+    virtual void Run() override {
+        running_ = true;
+        while(loop_) {
+            Message msg;
+            if (!Pop(msg)) {
+                Wait(500);
+                continue;
+            }
+
+            if (msg.head == "@ctrl") {
+                PostCtrl(msg.body);
+            }else if (msg.head == "@uri") {
+                std::string uri = msg.body;
+                StreamPtr stream = new Stream(uri);
+                streams_.insert(pair_t(uri, stream));
+            }
+            Wait(100);
+        };
+        running_ = false;
+    }
+
+    void Wait(int ms) {
+        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    }
+    void Reset() {
+        loop_ = true;
+    }
+    bool IsRunning() {
+        return running_;
+    }
+
+    bool Pop(Message &msg) {
+        if (queue_.empty())
+            return false;
+        lock_.Acquire();
+        msg = queue_.back();
+        queue_.pop_back();
+        lock_.Release();
+        return true;
+    }
+
+    void Push(Message &msg) {
+        lock_.Acquire();
+        queue_.insert(queue_.begin(), msg);
+        lock_.Release();
+    }
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+static CtrlCenter *gCenter = nullptr;
+
+void StartCtrlCenter() {
+    if (!gCenter) {
+        gCenter = new CtrlCenter;
+    }
+    if (gCenter->IsRunning()) {
+        return;
+    }
+    gCenter->Reset();
+    gCenter->Start();
+}
+
 void PostCtrl(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
@@ -37,6 +119,7 @@ void PostCtrl(std::string msg) {
     std::string szaddr = "127.0.0.1";
     net::IPAddressNumber ipnum;
     if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
         LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
         return;
     }
@@ -45,12 +128,14 @@ void PostCtrl(std::string msg) {
     struct sockaddr addr;
     socklen_t addrlen;
     if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
         LOG(INFO) << __func__ << " ToSockAddr failed";
         return;
     }
 
     int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
     LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
 }
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 4abe1d2..c574235 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,6 +16,9 @@ class URLRequest;
 
 namespace mmt {
 
+void StartCtrlCenter();
+void PostCtrl(std::string msg);
+
 enum {
     Msg_RunJavaScript,
 };
@@ -29,8 +32,6 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
-void PostCtrl(std::string msg);
-
 } // namespace mmt
 
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0a54267..62e2a0b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -225,9 +225,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
-
-  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
-  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-- 
1.7.9.5


From 9dc889f35c23920985fccce016609b431856b6ad Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 06:53:00 -0800
Subject: [PATCH 24/92] refine ctrl center 1

---
 net/mmt/mmt_stream.cc                  |  282 ++++++++++----------------------
 net/mmt/mmt_stream.h                   |   64 +++++---
 net/url_request/url_request_mmt_job.cc |   10 +-
 3 files changed, 135 insertions(+), 221 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7f7b98a..6aa5855 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -12,6 +12,7 @@
 #include "content/public/renderer/render_thread.h"
 #include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
@@ -19,84 +20,18 @@
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
 
-#include "base/threading/thread_restrictions.h"
-#include "base/memory/ref_counted.h"
-#include "base/threading/simple_thread.h"
-#include "base/synchronization/lock.h"
-#include "base/threading/platform_thread.h"
-#include "base/time/time.h"
-
 
 using namespace content;
 
 namespace mmt {
 
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        std::string head;
-        std::string body;
-    };
-
-    CtrlCenter() : SimpleThread("ctrlcenter"){}
-    virtual ~CtrlCenter() {}
-
-    virtual void Run() override {
-        running_ = true;
-        while(loop_) {
-            Message msg;
-            if (!Pop(msg)) {
-                Wait(500);
-                continue;
-            }
-
-            if (msg.head == "@ctrl") {
-                PostCtrl(msg.body);
-            }else if (msg.head == "@uri") {
-                std::string uri = msg.body;
-                StreamPtr stream = new Stream(uri);
-                streams_.insert(pair_t(uri, stream));
-            }
-            Wait(100);
-        };
-        running_ = false;
-    }
-
-    void Wait(int ms) {
-        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
-    }
-    void Reset() {
-        loop_ = true;
-    }
-    bool IsRunning() {
-        return running_;
-    }
-
-    bool Pop(Message &msg) {
-        if (queue_.empty())
-            return false;
-        lock_.Acquire();
-        msg = queue_.back();
-        queue_.pop_back();
-        lock_.Release();
-        return true;
-    }
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+}
+void PostNativeMsg(std::string msg);
 
-    void Push(Message &msg) {
-        lock_.Acquire();
-        queue_.insert(queue_.begin(), msg);
-        lock_.Release();
-    }
 
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
 static CtrlCenter *gCenter = nullptr;
-
 void StartCtrlCenter() {
     if (!gCenter) {
         gCenter = new CtrlCenter;
@@ -108,7 +43,77 @@ void StartCtrlCenter() {
     gCenter->Start();
 }
 
-void PostCtrl(std::string msg) {
+void PostCtrlMsg(CtrlCenter::Message &msg) {
+    if (!gCenter) return;
+    gCenter->Push(msg);
+}
+
+CtrlCenter::Message::Message() {}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::~CtrlCenter() {}
+
+void CtrlCenter::Run() {
+    running_ = true;
+    while(loop_) {
+        Message msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        if (msg.head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (msg.head == "@open") {
+            std::string uri = msg.uri;
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(pair_t(uri, stream));
+            int64 size;
+            stream->Prepare(&size);
+            if (msg.func1) {
+                msg.func1(msg.thiz, size);
+            }
+        }else if (msg.head == "@read") {
+            std::string uri = msg.uri;
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                char* buf = new char[msg.size];
+                int iret = stream->Read(buf, msg.size, msg.offset);
+                if (iret > 0 && msg.func2) {
+                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                }
+                delete buf;
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+}
+
+void CtrlCenter::Reset() {
+    loop_ = true;
+}
+bool CtrlCenter::IsRunning() {
+    return running_;
+}
+
+bool CtrlCenter::Pop(Message &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void CtrlCenter::Push(Message &msg) {
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+void PostNativeMsg(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
         LOG(INFO) << __func__ << " Open failed sock=" << sock;
@@ -138,6 +143,11 @@ void PostCtrl(std::string msg) {
     close(sock);
 }
 
+} // namespace mmt
+
+
+namespace mmt {
+
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
     if (!content) return false;
@@ -165,10 +175,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void Do_JavaScript(const Content* content, std::string js) {
-    LOG(INFO) << __func__;
+void GetRenderFrameInfo(Content* content) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
@@ -176,79 +184,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        content::WebUI* webui = web_contents->GetWebUI();
-        LOG(INFO) << __func__ << " webui=" << webui;
-
-        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view1=" << render_view1;
-        if (render_view1) {
-            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
-            LOG(INFO) << __func__ << " view1=" << view1;
-        }
-
-        WebContentsDelegate* delegate = web_contents->GetDelegate();
-        LOG(INFO) << __func__ << " delegate=" << delegate;
-
-        RenderFrameHost* main_frame = web_contents->GetMainFrame();
-        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
-        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
-        RenderViewHost* main_view = main_frame->GetRenderViewHost();
-        LOG(INFO) << __func__ << " main_view=" << main_view;
-        if (main_view) {
-            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
-            LOG(INFO) << __func__ << " view=" << view;
-        }
-
-        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
-        LOG(INFO) << __func__ << " browser_context=" << browser_context;
-
-        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view2=" << render_view2;
-        if (render_view2) {
-            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
-            LOG(INFO) << __func__ << " view2=" << view2;
+        if (web_contents) {
+            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+            content->url = web_contents->GetURL();
         }
-
-        GURL url = web_contents->GetURL();
-        LOG(INFO) << __func__ << " url=" << url;
-
-        js = "console.log(document.getElementById(\"Video1\"));";
-        LOG(INFO) << __func__ << " js=" << js;
-        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-
-        std::string css = "<style>"
-            "body{"
-                "font-family: Verdana, Cursor;"
-                "font-size: 10px;"
-                "font-weight: bold;"
-            "}"
-            "</style>";
-        web_contents->InsertCSS(css);
-
-        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //web_contents->ViewSource();
-        LOG(INFO) << __func__ << " END";
-    }
-}
-
-void Do_Fullscreen(const Content* content) {
-    LOG(INFO) << __func__;
-}
-
-//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
-void PostTask(int msg_type, const Content* content) {
-    switch(msg_type) {
-    case Msg_RunJavaScript:
-        static bool _brun = false;
-        if (content && !_brun) {
-            _brun = true;
-            Do_JavaScript(content, content->data);
-        }
-        break;
     }
 }
 
@@ -260,6 +199,9 @@ void PostTask(int msg_type, const Content* content) {
 
 namespace mmt {
 
+Content::Content() {
+}
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -301,52 +243,4 @@ void Stream::Uninit() {
     file_ = nullptr;
 }
 
-
-StreamPool* StreamPool::ginst_ = nullptr;
-
-StreamPool::StreamPool() {
-}
-StreamPool::~StreamPool() {
-}
-
-StreamPtr StreamPool::getStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter == streams_.end()) {
-        lock_.Release();
-        return nullptr;
-    }
-    lock_.Release();
-    return iter->second;
-}
-
-StreamPtr StreamPool::addStream(std::string &uri) {
-    StreamPtr stream = getStream(uri);
-    if (!stream.get()) {
-        stream = new Stream(uri);
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
-        lock_.Acquire();
-        streams_.insert(pair_t(uri, stream));
-        lock_.Release();
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
-    }
-    return stream;
-}
-
-void StreamPool::delStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter != streams_.end()) {
-        streams_.erase(iter);
-    }
-    lock_.Release();
-}
- 
-StreamPool *StreamPool::inst() {
-    if (!ginst_) {
-        ginst_ = new StreamPool;
-    }
-    return ginst_;
-}
-
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c574235..f01bf95 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,28 +10,33 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+#include "base/threading/thread_restrictions.h"
+#include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
+
+#include "url/gurl.h"
+
 namespace net {
 class URLRequest;
 }
 
 namespace mmt {
 
-void StartCtrlCenter();
-void PostCtrl(std::string msg);
-
-enum {
-    Msg_RunJavaScript,
-};
-
 struct Content {
+    Content();
     int process_id;
     int frame_id;
     int routing_id;
+    int tab_id;
+    GURL url;
     std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void PostTask(int msg_type, const Content* content);
+void GetRenderFrameInfo(Content* content);
 } // namespace mmt
 
 
@@ -61,25 +66,46 @@ typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
-class StreamPool {
-public:
-    StreamPool();
-    ~StreamPool();
+} // namespace mmt
 
-    StreamPtr getStream(std::string &uri);
-    StreamPtr addStream(std::string &uri);
-    void delStream(std::string &uri);
 
-    static StreamPool *inst();
 
-protected:
-    static StreamPool *ginst_; 
+namespace mmt {
+
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        Message();
+        std::string head;
+        std::string body;
+        std::string uri;
+        int   size;
+        int   offset;
+        void* thiz;
+        void (*func1)(void*, int);
+        void (*func2)(void*, unsigned char*, int);
+    };
+
+    CtrlCenter();
+    virtual ~CtrlCenter();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(Message &msg);
+    void Push(Message &msg);
 
 private:
-    streams_t streams_;
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
     base::Lock lock_;
+    streams_t streams_;
 };
 
+void StartCtrlCenter();
+void PostCtrlMsg(CtrlCenter::Message &msg);
+
 } // namespace mmt
 
 #endif
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 62e2a0b..484e885 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,8 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
@@ -72,7 +74,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -201,12 +202,6 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
-  if (stream.get()) {
-    read_info->dest_size = stream->Read(read_info->dest->data(), 
-                                      read_info->dest_size, 
-                                      read_info->read_offset);
-  }
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
@@ -228,7 +223,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From f49992582f0ff00df30003dc978cd37e78f3eb9c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 08:24:21 -0800
Subject: [PATCH 25/92] refine ctrl center 2 [thread]

---
 net/mmt/mmt_stream.cc                  |   56 ++++++++++++++++++++++++--------
 net/mmt/mmt_stream.h                   |   16 ++++++---
 net/url_request/url_request_mmt_job.cc |   29 ++++++-----------
 net/url_request/url_request_mmt_job.h  |    4 +--
 4 files changed, 66 insertions(+), 39 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6aa5855..59be61b 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -19,6 +19,7 @@
 #include "base/files/file_util.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
 
 
 using namespace content;
@@ -26,7 +27,7 @@ using namespace content;
 namespace mmt {
 
 void Wait(int ms) {
-    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
 void PostNativeMsg(std::string msg);
 
@@ -41,6 +42,7 @@ void StartCtrlCenter() {
     }
     gCenter->Reset();
     gCenter->Start();
+    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
 }
 
 void PostCtrlMsg(CtrlCenter::Message &msg) {
@@ -48,11 +50,33 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+
+#if 1
+    base::FilePath file_path;
+    net::FileURLToFilePath(gurl, &file_path);
+    msg.url = file_path.value();
+#else
+    std::ostringstream sstr;
+    sstr << gurl;
+    msg.url = sstr.str();
+#endif
+
+    PostCtrlMsg(msg);
+}
+
 CtrlCenter::Message::Message() {}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
+    running_ = false;
+}
 CtrlCenter::~CtrlCenter() {}
 
 void CtrlCenter::Run() {
+    LOG(INFO) << __func__ << " begin";
     running_ = true;
     while(loop_) {
         Message msg;
@@ -60,27 +84,28 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
+        LOG(INFO) << __func__ << " head=" << msg.head;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
-            std::string uri = msg.uri;
-            StreamPtr stream = new Stream(uri);
-            streams_.insert(pair_t(uri, stream));
-            int64 size;
+            std::string url = msg.url;
+            StreamPtr stream = new Stream(url);
+            streams_.insert(pair_t(url, stream));
+            int64 size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
-                msg.func1(msg.thiz, size);
+                msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@read") {
-            std::string uri = msg.uri;
-            streams_t::iterator iter = streams_.find(uri);
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 char* buf = new char[msg.size];
                 int iret = stream->Read(buf, msg.size, msg.offset);
-                if (iret > 0 && msg.func2) {
-                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                if (msg.func2) {
+                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
                 }
                 delete buf;
             }
@@ -88,6 +113,7 @@ void CtrlCenter::Run() {
         Wait(100);
     };
     running_ = false;
+    LOG(INFO) << __func__ << " end";
 }
 
 void CtrlCenter::Reset() {
@@ -108,6 +134,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
+    LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -149,7 +176,6 @@ void PostNativeMsg(std::string msg) {
 namespace mmt {
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
-    LOG(INFO) << __func__;
     if (!content) return false;
 
     const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
@@ -186,7 +212,11 @@ void GetRenderFrameInfo(Content* content) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
             content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            content->url = web_contents->GetURL();
+            std::ostringstream sstr;
+            sstr << web_contents->GetURL();
+            content->tab_url = sstr.str();
+            LOG(INFO) << __func__ << " tab id=" << content->tab_id
+                << ", tab url=" << content->tab_url;
         }
     }
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index f01bf95..fc9fa5c 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -4,6 +4,7 @@
 #include <map>
 #include <string>
 #include <vector>
+#include <sstream>
 
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
@@ -31,7 +32,7 @@ struct Content {
     int frame_id;
     int routing_id;
     int tab_id;
-    GURL url;
+    std::string tab_url;
     std::string data;
 };
 
@@ -72,18 +73,22 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 
 namespace mmt {
 
+typedef void (*func1_t)(void*, int);
+typedef void (*func2_t)(void*, unsigned char*, int);
+
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
         std::string head;
         std::string body;
-        std::string uri;
+        std::string url;
+        int   tab_id;
         int   size;
         int   offset;
-        void* thiz;
-        void (*func1)(void*, int);
-        void (*func2)(void*, unsigned char*, int);
+        func1_t func1;
+        func2_t func2;
+        void* ptr;
     };
 
     CtrlCenter();
@@ -105,6 +110,7 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 484e885..5694a52 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,25 +52,14 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
-  base::FilePath file_path;
-  FileURLToFilePath(request_->url(), &file_path);
-  read_info_.uri = file_path.value();
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoStart,
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidStart,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -165,15 +154,16 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(
-    base::FilePath(read_info->uri), &read_info->total_size);
+void URLRequestMmtJob::DoStart(void* thiz, int iret) {
+    LOG(INFO) << __func__ << " iret=" << iret;
+    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
+    if (job)
+        job->DidStart(iret);
 }
 
-void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+void URLRequestMmtJob::DidStart(int iret) {
   int result = OK;
-  read_info_ = *read_info;
-  if (!read_info_.is_started) {
+  if (iret <= 0) {
     result = ERR_FAILED;
   }
 
@@ -186,6 +176,7 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
     return;
   }
 
+  read_info_.total_size = iret;
   if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 468db82..eaf4cb7 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -61,8 +61,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(ReadMetaInfo* read_info);
-  void DidStart(ReadMetaInfo* read_info);
+  static void DoStart(void *thiz, int iret);
+  void DidStart(int iret);
 
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
-- 
1.7.9.5


From c27370eb2691b633941da8f62d7f13384a62baa0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 10:03:03 -0800
Subject: [PATCH 26/92] refine ctrl center 3

---
 net/mmt/mmt_stream.cc                  |   65 +++++++++++++++++++++++++-------
 net/mmt/mmt_stream.h                   |    9 ++++-
 net/url_request/url_request_mmt_job.cc |   42 ++++++++++-----------
 net/url_request/url_request_mmt_job.h  |    7 ++--
 4 files changed, 82 insertions(+), 41 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 59be61b..9aee8d5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -50,26 +50,57 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-
+std::string GURL2string(GURL& gurl) {
+    std::string url;
 #if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    msg.url = file_path.value();
+    url = file_path.value();
 #else
     std::ostringstream sstr;
     sstr << gurl;
-    msg.url = sstr.str();
+    url = sstr.str();
 #endif
+    return url;
+}
 
+void PostCtrlTask(std::string head, GURL gurl) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+void PostCtrlTask(std::string head, GURL gurl, 
+    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.buf = iobuf;
+    msg.size = size;
+    msg.offset = offset;
+    msg.func2 = func2;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
 
-CtrlCenter::Message::Message() {}
+CtrlCenter::Message::Message() {
+    tab_id = -1;
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func1 = nullptr;
+    func2 = nullptr;
+    ptr = nullptr;
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -84,7 +115,7 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head;
+        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
@@ -97,17 +128,23 @@ void CtrlCenter::Run() {
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
+        }else if (msg.head == "@close") {
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                stream->Uninit();
+                streams_.erase(iter);
+            }
         }else if (msg.head == "@read") {
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                char* buf = new char[msg.size];
-                int iret = stream->Read(buf, msg.size, msg.offset);
+                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
                 if (msg.func2) {
-                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
+                    msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
-                delete buf;
             }
         }
         Wait(100);
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index fc9fa5c..5e52510 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -22,6 +22,7 @@
 
 namespace net {
 class URLRequest;
+class IOBuffer;
 }
 
 namespace mmt {
@@ -74,7 +75,7 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, unsigned char*, int);
+typedef void (*func2_t)(void*, void*, int);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -84,6 +85,8 @@ public:
         std::string body;
         std::string url;
         int   tab_id;
+
+        net::IOBuffer* buf;
         int   size;
         int   offset;
         func1_t func1;
@@ -110,7 +113,9 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
-void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl);
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 5694a52..eb5177b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -36,8 +36,7 @@
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
-URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : is_started(false),
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -63,6 +62,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::PostCtrlTask("@close", request_->url());
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -86,17 +86,8 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-  read_info->dest = dest;
-  read_info->dest_size = dest_size;
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoRead, 
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
+    &URLRequestMmtJob::DoRead, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -154,11 +145,13 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(void* thiz, int iret) {
-    LOG(INFO) << __func__ << " iret=" << iret;
-    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
-    if (job)
-        job->DidStart(iret);
+void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
+  }
 }
 
 void URLRequestMmtJob::DidStart(int iret) {
@@ -192,11 +185,18 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+  }
 }
 
-void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-  int result = read_info->dest_size;
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     read_info_.remaining_bytes -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index eaf4cb7..093763e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -51,7 +51,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
-    bool is_started;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
@@ -61,11 +60,11 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void *thiz, int iret);
+  static void DoStart(void* ptr, int iret);
   void DidStart(int iret);
 
-  static void DoRead(ReadMetaInfo* read_info);
-  void DidRead(ReadMetaInfo* read_info);
+  static void DoRead(void* ptr, void* data, int size);
+  void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
-- 
1.7.9.5


From 520ecb646b1cc59e1cc4c058f2b7907919084c4a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:28 -0800
Subject: [PATCH 27/92] enhance log for ctrl

---
 net/mmt/mmt_stream.cc                  |   16 ++++++++++------
 net/mmt/mmt_stream.h                   |    2 +-
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 9aee8d5..780490a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -115,25 +115,26 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             StreamPtr stream = new Stream(url);
             streams_.insert(pair_t(url, stream));
-            int64 size = -1;
+            long size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@close") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                stream->Uninit();
+                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -142,6 +143,9 @@ void CtrlCenter::Run() {
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
+                LOG(INFO) << __func__ << " head=" << msg.head 
+                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
+                    << " size=" << msg.size << " ptr=" << msg.ptr;
                 if (msg.func2) {
                     msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
@@ -171,7 +175,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
-    LOG(INFO) << __func__;
+    //LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -289,10 +293,10 @@ bool Stream::Init() {
     return false;
 }
 
-bool Stream::Prepare(int64 *size) {
+bool Stream::Prepare(long *size) {
     if (!Init()) return false;
     fseek(file_, 0L, SEEK_END);
-    int64 lret = ftell(file_);
+    long lret = ftell(file_);
     *size = lret;
     return true;
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 5e52510..bfb6711 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -49,7 +49,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
-    bool Prepare(int64 *size);
+    bool Prepare(long *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index eb5177b..493c6bb 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-- 
1.7.9.5


From da105b21fbc0786947a0d42355247ef1caa21577 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:54 -0800
Subject: [PATCH 28/92] add cictrl module

---
 .../docs/examples/api/cictrl/background.js         |   15 +++++++++
 .../docs/examples/api/cictrl/content_scripts.js    |   33 ++++++++++++++++++++
 .../docs/examples/api/cictrl/manifest.json         |   24 ++++++++++++++
 3 files changed, 72 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/background.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/manifest.json

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
new file mode 100644
index 0000000..e6b3978
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -0,0 +1,15 @@
+
+function log(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
+    log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
+    if (request.greeting == "hello" && sender.tab) {
+        sendResponse({farewell: "goodbye"});
+        chrome.tabs.executeScript(sender.tab.id, {
+            code: 'document.body.style.backgroundColor="red"'
+        });
+    }
+});
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
new file mode 100644
index 0000000..a73420c
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -0,0 +1,33 @@
+// detect the changes of storage and apply them into current page
+
+function log(msg) {
+    //alert(msg);
+    console.log(msg);
+}
+
+// for chrome.storage.local
+chrome.storage.onChanged.addListener(function(changes, namespace) {
+    if (namespace != "local") {
+        log("donot process the namespace = " + namespace);
+        return;
+    }
+
+    for (key in changes) {
+        var storageChange = changes[key];
+        log('Storage key "%s" in namespace "%s" changed. ' +
+            'Old value was "%s", new value is "%s".',
+            key,
+            namespace,
+            storageChange.oldValue,
+            storageChange.newValue);
+    }
+});
+
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
+// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+window.onload = function() {
+    log("window.onload");
+    chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
+        log(response.farewell);
+    });
+};
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
new file mode 100644
index 0000000..e955013
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -0,0 +1,24 @@
+{
+    "name" : "org.chromium.cictrl",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium ci control",
+    "permissions": [
+        "file://*/*",
+        "http://*/*",
+        "mmt://*/*",
+        "tabs", 
+        "storage"
+    ],
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    },
+    "content_scripts": [
+        {
+            "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
+            "run_at" : "document_end",
+            "js" : ["content_scripts.js"]
+        }
+    ]
+}
-- 
1.7.9.5


From d687ea44a680a4e9f951f085fb9b4522d30ac902 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 23:34:23 -0800
Subject: [PATCH 29/92] try chrome.storage module

---
 net/mmt/mmt_stream.cc                  |   66 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |   30 ++++++++++++++-
 net/url_request/url_request_mmt_job.cc |   38 +++++++++++++++++-
 net/url_request/url_request_mmt_job.h  |    4 ++
 4 files changed, 133 insertions(+), 5 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 780490a..1861832 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -21,6 +21,14 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 
 using namespace content;
 
@@ -91,6 +99,18 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
+// for @store
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.key = key;
+    msg.value = value;
+    msg.func3 = func3;
+    msg.ptr = ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
 
 CtrlCenter::Message::Message() {
     tab_id = -1;
@@ -101,6 +121,8 @@ CtrlCenter::Message::Message() {
     func2 = nullptr;
     ptr = nullptr;
 }
+CtrlCenter::Message::~Message() {
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -118,6 +140,12 @@ void CtrlCenter::Run() {
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
+        }else if (msg.head == "@test") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
+            Wait(5000);
+            if (msg.func3) {
+                msg.func3(msg.ptr, msg.key, msg.value);
+            }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
@@ -134,7 +162,6 @@ void CtrlCenter::Run() {
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -242,13 +269,43 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void GetRenderFrameInfo(Content* content) {
+void GetExtension(Content* content, BrowserContext* context) {
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    LOG(INFO) << __func__ << " frontend=" << frontend;
+    if (!frontend) {
+        return;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    LOG(INFO) << __func__ << " registry=" << registry;
+    if (registry) {
+        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+            LOG(INFO) << __func__ << " name=" << extension->name()
+                << " id=" << extension->id();
+            if (extension->name() == "org.chromium.cictrl") {
+                frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, content->storage_callback);
+                break;
+            }
+        }
+    }
+}
+
+
+void GetRenderFrameInfo(Content* content, bool has_storage) {
+    LOG(INFO) << __func__ << " begin";
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    LOG(INFO) << __func__ << " get rfh";
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
     }
 
+    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
@@ -258,6 +315,9 @@ void GetRenderFrameInfo(Content* content) {
             content->tab_url = sstr.str();
             LOG(INFO) << __func__ << " tab id=" << content->tab_id
                 << ", tab url=" << content->tab_url;
+            if (has_storage) {
+                GetExtension(content, web_contents->GetBrowserContext());
+            }
         }
     }
 }
@@ -272,6 +332,8 @@ namespace mmt {
 
 Content::Content() {
 }
+Content::~Content() {
+}
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index bfb6711..60e7979 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,6 +20,16 @@
 
 #include "url/gurl.h"
 
+#include "extensions/browser/api/storage/value_store_cache.h"
+
+class ValueStore;
+
+namespace extensions {
+class Extension;
+class StorageFrontend;
+class ValueStoreCache;
+}
+
 namespace net {
 class URLRequest;
 class IOBuffer;
@@ -29,16 +39,18 @@ namespace mmt {
 
 struct Content {
     Content();
+    ~Content();
+
     int process_id;
     int frame_id;
     int routing_id;
     int tab_id;
     std::string tab_url;
-    std::string data;
+    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content);
+void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -76,16 +88,25 @@ namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
+typedef void (*func3_t)(void*, std::string, std::string);
 
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
+        ~Message();
+
         std::string head;
         std::string body;
         std::string url;
         int   tab_id;
+        
+        // for storage
+        std::string key;
+        std::string value;
+        func3_t func3;
 
+        // for stream I/O
         net::IOBuffer* buf;
         int   size;
         int   offset;
@@ -113,9 +134,14 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+
 void PostCtrlTask(std::string head, GURL gurl);
+// for @open
 void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+// for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 493c6bb..4a8f832 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -33,6 +33,14 @@
 #include "net/mmt/mmt_stream.h"
 #include "content/public/browser/browser_thread.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -54,8 +62,9 @@ URLRequestMmtJob::URLRequestMmtJob(
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
+  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_));
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -204,6 +213,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
+  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
+  //  &URLRequestMmtJob::DoStore, (void*)this);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -214,6 +227,29 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+  }
+}
+void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
+    LOG(INFO) << __func__ << " set value";
+    std::string szkey = "xyz";
+    std::string szvalue = "test yzxu 123";
+    scoped_ptr<base::Value> value;
+    value.reset(new base::StringValue(szvalue));
+    storage->Set(ValueStore::DEFAULTS, szkey, *value);
+}
+void URLRequestMmtJob::DidStore() {
+  LOG(INFO) << __func__;
+  GetRenderFrameInfo(&content_);
+  //content_.frontend->RunWithStorage(content_.extension, 
+  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+}
+
 void URLRequestMmtJob::DoTest(void* ptr) {
 }
 
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 093763e..cfc23a1 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -69,6 +69,10 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
+  static void StorageCallback(ValueStore* storage);
+  static void DoStore(void* ptr, std::string key, std::string value);
+  void DidStore();
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
-- 
1.7.9.5


From 044d7229a379aa7a199cc5a089e9b13f9aac9bfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 00:51:36 -0800
Subject: [PATCH 30/92] testing failed for chrome.storage

---
 net/mmt/mmt_stream.cc                  |  115 ++---------------------------
 net/mmt/mmt_stream.h                   |   32 ++++----
 net/url_request/url_request_mmt_job.cc |  127 +++++++++++++++++++++++++-------
 net/url_request/url_request_mmt_job.h  |   11 ++-
 4 files changed, 133 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1861832..8bedeaf 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,19 +1,5 @@
 #include "net/mmt/mmt_stream.h"
 
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/resource_context.h"
-#include "content/public/browser/content_browser_client.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/render_view_host.h"
-
-#include "content/public/common/content_client.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
-#include "content/public/renderer/render_view.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -21,15 +7,6 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-
-
 using namespace content;
 
 namespace mmt {
@@ -99,12 +76,14 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
-// for @store
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, 
+    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
     CtrlCenter::Message msg;
     msg.head = head;
     msg.key = key;
     msg.value = value;
+    msg.content = *content;
     msg.func3 = func3;
     msg.ptr = ptr;
     msg.url = GURL2string(gurl);
@@ -144,7 +123,7 @@ void CtrlCenter::Run() {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             Wait(5000);
             if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value);
+                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
             }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
@@ -241,90 +220,6 @@ void PostNativeMsg(std::string msg) {
 } // namespace mmt
 
 
-namespace mmt {
-
-bool GetRequestID(const net::URLRequest* request, Content* content) {
-    if (!content) return false;
-
-    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        content->routing_id = rinfo->GetRouteID();
-        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
-    }
-
-    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
-            &content->process_id, &content->frame_id);
-    if (is_ok) {
-        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
-            << ", render_frame_id: " << content->frame_id;
-    }
-
-    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
-        << ", frame id=" << rinfo->GetRenderFrameID()
-        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
-        << ", is main frame=" << rinfo->IsMainFrame()
-        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
-        << "";
-
-    return is_ok;
-}
-
-void GetExtension(Content* content, BrowserContext* context) {
-    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
-    LOG(INFO) << __func__ << " frontend=" << frontend;
-    if (!frontend) {
-        return;
-    }
-
-    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
-    LOG(INFO) << __func__ << " registry=" << registry;
-    if (registry) {
-        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
-        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
-            LOG(INFO) << __func__ << " name=" << extension->name()
-                << " id=" << extension->id();
-            if (extension->name() == "org.chromium.cictrl") {
-                frontend->RunWithStorage(extension, 
-                    extensions::settings_namespace::LOCAL, content->storage_callback);
-                break;
-            }
-        }
-    }
-}
-
-
-void GetRenderFrameInfo(Content* content, bool has_storage) {
-    LOG(INFO) << __func__ << " begin";
-    content->tab_id = -1;
-    content->tab_url = "";
-
-    LOG(INFO) << __func__ << " get rfh";
-    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    if (rfh && rfh->GetParent()) {
-        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
-        rfh = rfh->GetParent();
-    }
-
-    LOG(INFO) << __func__ << " rfh=" << rfh;
-    if (rfh) {
-        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        if (web_contents) {
-            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            std::ostringstream sstr;
-            sstr << web_contents->GetURL();
-            content->tab_url = sstr.str();
-            LOG(INFO) << __func__ << " tab id=" << content->tab_id
-                << ", tab url=" << content->tab_url;
-            if (has_storage) {
-                GetExtension(content, web_contents->GetBrowserContext());
-            }
-        }
-    }
-}
-
-} // namespace mmt
-
-
 ///===============================
 /// for class Stream and StreamPool
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 60e7979..c725f0d 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,15 +20,22 @@
 
 #include "url/gurl.h"
 
-#include "extensions/browser/api/storage/value_store_cache.h"
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
 
-class ValueStore;
-
-namespace extensions {
-class Extension;
-class StorageFrontend;
-class ValueStoreCache;
-}
 
 namespace net {
 class URLRequest;
@@ -46,11 +53,8 @@ struct Content {
     int routing_id;
     int tab_id;
     std::string tab_url;
-    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
-bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -83,12 +87,11 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 } // namespace mmt
 
 
-
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string);
+typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -104,6 +107,7 @@ public:
         // for storage
         std::string key;
         std::string value;
+        mmt::Content content;
         func3_t func3;
 
         // for stream I/O
@@ -141,7 +145,7 @@ void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
 // for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 // for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4a8f832..6f79339 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,15 +31,6 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
-#include "content/public/browser/browser_thread.h"
-
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
 
 namespace net {
 
@@ -61,10 +52,9 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
-  mmt::GetRequestID(request_, &content_);
-  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
+  GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -213,10 +203,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
-  //  &URLRequestMmtJob::DoStore, (void*)this);
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
+  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
+    &URLRequestMmtJob::DoStore, (void*)this);
+  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -227,14 +217,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-  }
-}
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -243,11 +225,23 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    thiz->kvstoring_.first = key;
+    thiz->kvstoring_.second = value;
+    mmt::Content* pcontent = new mmt::Content;
+    *pcontent = *content;
+    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
+  }
+}
 void URLRequestMmtJob::DidStore() {
   LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_);
-  //content_.frontend->RunWithStorage(content_.extension, 
-  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+  GetRenderFrameInfo(&content_, true);
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
@@ -256,4 +250,83 @@ void URLRequestMmtJob::DoTest(void* ptr) {
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
+bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+    if (!content) return false;
+    const content::ResourceRequestInfo* rinfo = 
+        content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+    }
+
+    bool is_ok = content::ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    LOG(INFO) << __func__ 
+        << ", render_process_id: " << content->process_id
+        << ", render_frame_id: " << content->frame_id
+        << ", routing ID: " << content->routing_id;
+    return is_ok;
+}
+
+bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+    if (!content) return false;
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    if (!frontend) {
+        LOG(INFO) << __func__ << " frontend is nullptr";
+        return false;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    if (!registry) {
+        LOG(INFO) << __func__ << " registry is nullptr";
+        return false;
+    }
+
+    const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+    for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+        if (extension->name() == "org.chromium.cictrl") {
+            LOG(INFO) << __func__ 
+                << " extension name=" << extension->name()
+                << " extension id=" << extension->id();
+            frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, base::Bind(&URLRequestMmtJob::StorageCallback));
+            break;
+        }
+    }
+    return true;
+}
+
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+    if (!content) return;
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    content::RenderFrameHost* rfh = 
+        content::RenderFrameHost::FromID(content->process_id, content->frame_id);
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+    if (!rfh) {
+        LOG(INFO) << __func__ << " rfh is nullptr";
+        return;
+    }
+
+    content::WebContents* web_contents = 
+        content::WebContents::FromRenderFrameHost(rfh);
+    if (!web_contents) {
+        LOG(INFO) << __func__ << " web_contents is nullptr";
+        return;
+    }
+    content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+    std::ostringstream sstr;
+    sstr << web_contents->GetURL();
+    content->tab_url = sstr.str();
+    LOG(INFO) << __func__ 
+        << " tab id=" << content->tab_id
+        << ", tab url=" << content->tab_url;
+    if (has_storage) {
+        GetExtension(content, web_contents->GetBrowserContext());
+    }
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cfc23a1..6d3e3da 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -23,6 +23,9 @@ class TaskRunner;
 namespace file_util {
 struct FileInfo;
 }
+namespace content {
+class BrowserContext;
+}
 
 namespace net {
 
@@ -70,15 +73,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidTest(void* ptr);
 
   static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value);
+  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
   void DidStore();
 
+  // get info for render
+  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
+  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
   mmt::Content content_;
+  std::pair<std::string, std::string> kvstoring_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9c7e96016284709461f6c4fbff887242724cfff8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 01:45:22 -0800
Subject: [PATCH 31/92] refine for native messaging

---
 net/mmt/mmt_control.cc                 |  189 +++++++++++++++++++++++++++
 net/mmt/mmt_control.h                  |   71 ++++++++++
 net/mmt/mmt_inc.h                      |   40 ++++++
 net/mmt/mmt_stream.cc                  |  222 ++------------------------------
 net/mmt/mmt_stream.h                   |   89 +------------
 net/net.gypi                           |    1 +
 net/url_request/url_request_mmt_job.cc |   77 +++++------
 net/url_request/url_request_mmt_job.h  |   22 ++--
 8 files changed, 358 insertions(+), 353 deletions(-)
 create mode 100644 net/mmt/mmt_control.cc
 create mode 100644 net/mmt/mmt_control.h
 create mode 100644 net/mmt/mmt_inc.h

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
new file mode 100644
index 0000000..cd6274c
--- /dev/null
+++ b/net/mmt/mmt_control.cc
@@ -0,0 +1,189 @@
+#include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+static MmtControl *g_ctrl = nullptr;
+
+void StartMmtCtrl() {
+    if (!g_ctrl) {
+        g_ctrl = new MmtControl;
+    }
+    if (g_ctrl->IsRunning()) {
+        return;
+    }
+    g_ctrl->Reset();
+    g_ctrl->Start();
+    LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
+}
+
+void PostCtrlMsg(ctrl_msg_t &msg) {
+    if (!g_ctrl) return;
+    g_ctrl->Push(msg);
+}
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.body = body;
+    msg.tabid = tabid;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.sinfo = sinfo;
+    msg.ptr= ptr;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+} // namespace mmt
+
+
+/// for class MmtControl
+namespace mmt {
+
+ctrl_msg_t::ctrl_msg_t() {
+    head = "";
+    body = "";
+    uri = "";
+    tabid = -1;
+    ptr = nullptr;
+
+    sinfo.buf = nullptr;
+    sinfo.size = 0;
+    sinfo.offset = 0;
+    sinfo.func = nullptr;
+}
+ctrl_msg_t::~ctrl_msg_t() {
+}
+
+MmtControl::MmtControl() : SimpleThread("mmt_control"){
+    running_ = false;
+}
+MmtControl::~MmtControl() {}
+
+void MmtControl::Run() {
+    LOG(INFO) << __func__ << " begin";
+    running_ = true;
+    while(loop_) {
+        ctrl_msg_t msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        std::string head = msg.head;
+        std::string uri = msg.uri;
+        LOG(INFO) << __func__ << " head=" << head << " uri=" << uri;
+
+        if (head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (head == "@test") {
+            //..
+        }else if (msg.head == "@open") {
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(stream_t(uri, stream));
+            long lsize = -1;
+            stream->Prepare(&lsize);
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+            }
+        }else if (msg.head == "@close") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                streams_.erase(iter);
+            }
+        }else if (msg.head == "@read") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+                LOG(INFO) << __func__ 
+                    << " head=" << head 
+                    << " iret=" << iret 
+                    << " uri=" << uri
+                    << " size=" << msg.sinfo.size 
+                    << " offset=" << msg.sinfo.offset 
+                    << " ptr=" << msg.ptr;
+                if (msg.sinfo.func) {
+                    msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+                }
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+    LOG(INFO) << __func__ << " end";
+}
+
+void MmtControl::Reset() {
+    loop_ = true;
+}
+bool MmtControl::IsRunning() {
+    return running_;
+}
+
+bool MmtControl::Pop(ctrl_msg_t &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void MmtControl::Push(ctrl_msg_t &msg) {
+    //LOG(INFO) << __func__;
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+
+void PostNativeMsg(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
+}
+
+} // namespace mmt
+
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
new file mode 100644
index 0000000..f02c47c
--- /dev/null
+++ b/net/mmt/mmt_control.h
@@ -0,0 +1,71 @@
+#ifndef NET_MMT_MMT_CONTROL_H_
+#define NET_MMT_MMT_CONTROL_H_
+
+#include <string>
+#include "net/mmt/mmt_stream.h"
+
+namespace net {
+class IOBuffer;
+}
+
+namespace mmt {
+
+struct stream_info_t;
+// (ptr, stream_info_t, errno)
+typedef void (*stream_func_t)(void*, stream_info_t&, int);
+struct stream_info_t {
+    net::IOBuffer*  buf;
+    int             size;
+    int             offset;
+    stream_func_t   func;
+};
+
+struct ctrl_msg_t {
+    ctrl_msg_t();
+    ~ctrl_msg_t();
+
+    std::string head;
+    std::string body;
+    std::string uri;
+    int   tabid;
+    void* ptr;
+
+    stream_info_t sinfo;
+};
+
+class MmtControl : public base::SimpleThread {
+public:
+    MmtControl();
+    virtual ~MmtControl();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(ctrl_msg_t& msg);
+    void Push(ctrl_msg_t& msg);
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<ctrl_msg_t> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+
+namespace mmt {
+
+void StartMmtCtrl();
+void PostNativeMsg(std::string msg);
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl);
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+} // namespace mmt
+
+#endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
new file mode 100644
index 0000000..f5ba4f7
--- /dev/null
+++ b/net/mmt/mmt_inc.h
@@ -0,0 +1,40 @@
+#ifndef NET_MMT_MMT_INC_H_
+#define NET_MMT_MMT_INC_H_
+
+#include <string>
+#include <sstream>
+
+#include "base/values.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+
+#include "net/base/file_stream.h"
+#include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
+#include "net/udp/udp_socket.h"
+
+#include "extensions/common/extension.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "url/gurl.h"
+
+namespace mmt{
+void Wait(int ms);
+std::string GURL2FilePath(GURL& gurl);
+std::string GURL2String(GURL& gurl);
+}
+
+#endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 8bedeaf..6e5be76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,235 +1,34 @@
 #include "net/mmt/mmt_stream.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "net/udp/udp_socket.h"
-#include "net/base/io_buffer.h"
-#include "net/base/filename_util.h"
-
-using namespace content;
+#include "net/mmt/mmt_inc.h"
 
 namespace mmt {
 
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-void PostNativeMsg(std::string msg);
-
-
-static CtrlCenter *gCenter = nullptr;
-void StartCtrlCenter() {
-    if (!gCenter) {
-        gCenter = new CtrlCenter;
-    }
-    if (gCenter->IsRunning()) {
-        return;
-    }
-    gCenter->Reset();
-    gCenter->Start();
-    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
-}
-
-void PostCtrlMsg(CtrlCenter::Message &msg) {
-    if (!gCenter) return;
-    gCenter->Push(msg);
-}
-
-std::string GURL2string(GURL& gurl) {
+std::string GURL2FilePath(GURL& gurl) {
     std::string url;
-#if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    url = file_path.value();
-#else
+    return file_path.value();
+}
+std::string GURL2String(GURL& gurl) {
     std::ostringstream sstr;
     sstr << gurl;
-    url = sstr.str();
-#endif
-    return url;
-}
-
-void PostCtrlTask(std::string head, GURL gurl) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-void PostCtrlTask(std::string head, GURL gurl, 
-    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.buf = iobuf;
-    msg.size = size;
-    msg.offset = offset;
-    msg.func2 = func2;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, 
-    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.key = key;
-    msg.value = value;
-    msg.content = *content;
-    msg.func3 = func3;
-    msg.ptr = ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-
-CtrlCenter::Message::Message() {
-    tab_id = -1;
-    buf = nullptr;
-    size = 0;
-    offset = 0;
-    func1 = nullptr;
-    func2 = nullptr;
-    ptr = nullptr;
-}
-CtrlCenter::Message::~Message() {
-}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
-    running_ = false;
-}
-CtrlCenter::~CtrlCenter() {}
-
-void CtrlCenter::Run() {
-    LOG(INFO) << __func__ << " begin";
-    running_ = true;
-    while(loop_) {
-        Message msg;
-        if (!Pop(msg)) {
-            Wait(500);
-            continue;
-        }
-
-        if (msg.head == "@ctrl") {
-            PostNativeMsg(msg.body);
-        }else if (msg.head == "@test") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            Wait(5000);
-            if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
-            }
-        }else if (msg.head == "@open") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            StreamPtr stream = new Stream(url);
-            streams_.insert(pair_t(url, stream));
-            long size = -1;
-            stream->Prepare(&size);
-            if (msg.func1) {
-                msg.func1(msg.ptr, size);
-            }
-        }else if (msg.head == "@close") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                streams_.erase(iter);
-            }
-        }else if (msg.head == "@read") {
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
-                LOG(INFO) << __func__ << " head=" << msg.head 
-                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
-                    << " size=" << msg.size << " ptr=" << msg.ptr;
-                if (msg.func2) {
-                    msg.func2(msg.ptr, (void*)msg.buf, iret);
-                }
-            }
-        }
-        Wait(100);
-    };
-    running_ = false;
-    LOG(INFO) << __func__ << " end";
+    return sstr.str();
 }
 
-void CtrlCenter::Reset() {
-    loop_ = true;
+content_t::content_t() {
 }
-bool CtrlCenter::IsRunning() {
-    return running_;
-}
-
-bool CtrlCenter::Pop(Message &msg) {
-    if (queue_.empty())
-        return false;
-    lock_.Acquire();
-    msg = queue_.back();
-    queue_.pop_back();
-    lock_.Release();
-    return true;
-}
-
-void CtrlCenter::Push(Message &msg) {
-    //LOG(INFO) << __func__;
-    lock_.Acquire();
-    queue_.insert(queue_.begin(), msg);
-    lock_.Release();
-}
-
-void PostNativeMsg(std::string msg) {
-    int sock = socket(AF_INET, SOCK_DGRAM, 0);
-    if(sock <= 0) {
-        LOG(INFO) << __func__ << " Open failed sock=" << sock;
-        return;
-    }
-    
-    int port = 54321;
-    std::string szaddr = "127.0.0.1";
-    net::IPAddressNumber ipnum;
-    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
-        return;
-    }
-
-    net::IPEndPoint ip(ipnum, port);
-    struct sockaddr addr;
-    socklen_t addrlen;
-    if(!ip.ToSockAddr(&addr, &addrlen)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ToSockAddr failed";
-        return;
-    }
-
-    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
-    LOG(INFO) << __func__ << " sendto iret=" << iret;
-    close(sock);
+content_t::~content_t() {
 }
 
 } // namespace mmt
 
 
-///===============================
 /// for class Stream and StreamPool
-
 namespace mmt {
 
-Content::Content() {
-}
-Content::~Content() {
-}
-
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -260,8 +59,11 @@ bool Stream::Prepare(long *size) {
 
 int Stream::Read(char *buf, int size, int offset) {
     if (!Init()) return -1;
-    fseek(file_, offset, SEEK_SET);
+    int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
+    if (iret <= 0) {
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+    }
     return iret; 
 }
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c725f0d..b4d11b9 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -17,36 +17,19 @@
 #include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
 #include "base/time/time.h"
-
 #include "url/gurl.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-
 
+class ValueStore;
 namespace net {
-class URLRequest;
 class IOBuffer;
 }
 
 namespace mmt {
 
-struct Content {
-    Content();
-    ~Content();
+struct content_t {
+    content_t();
+    ~content_t();
 
     int process_id;
     int frame_id;
@@ -81,72 +64,10 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::pair<std::string, StreamPtr> stream_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
 } // namespace mmt
 
 
-namespace mmt {
-
-typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
-
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        Message();
-        ~Message();
-
-        std::string head;
-        std::string body;
-        std::string url;
-        int   tab_id;
-        
-        // for storage
-        std::string key;
-        std::string value;
-        mmt::Content content;
-        func3_t func3;
-
-        // for stream I/O
-        net::IOBuffer* buf;
-        int   size;
-        int   offset;
-        func1_t func1;
-        func2_t func2;
-        void* ptr;
-    };
-
-    CtrlCenter();
-    virtual ~CtrlCenter();
-    virtual void Run() override;
-
-    void Reset();
-    bool IsRunning();
-    bool Pop(Message &msg);
-    void Push(Message &msg);
-
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
-
-void StartCtrlCenter();
-void PostCtrlMsg(CtrlCenter::Message &msg);
-
-void PostCtrlTask(std::string head, GURL gurl);
-// for @open
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
-// for @read
-void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
-
-} // namespace mmt
-
 #endif
diff --git a/net/net.gypi b/net/net.gypi
index cc6c1b2..99959ba 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -701,6 +701,7 @@
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
       'mmt/mmt_stream.cc',
+      'mmt/mmt_control.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6f79339..b985b58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -6,7 +6,6 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
@@ -14,9 +13,6 @@
 #include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
@@ -24,13 +20,12 @@
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_file_dir_job.h"
-#include "url/gurl.h"
 
 #if defined(OS_WIN)
 #include "base/win/shortcut.h"
 #endif
 
-#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
 
 namespace net {
 
@@ -46,19 +41,21 @@ URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    const scoped_refptr<base::TaskRunner>& task_runner)
     : URLRequestJob(request, network_delegate),
-      mmt_task_runner_(mmt_task_runner),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::StartCtrlCenter();
+  mmt::StartMmtCtrl();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
-  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.func = &URLRequestMmtJob::DoStart;
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -86,8 +83,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
-    &URLRequestMmtJob::DoRead, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.buf = dest;
+  sinfo.size = dest_size;
+  sinfo.offset = read_info_.read_offset;
+  sinfo.func = &URLRequestMmtJob::DoRead;
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -143,9 +144,10 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
@@ -185,12 +187,13 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
-  LOG(INFO) << __func__ << " data size=" << size;
+void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret << 
+    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
   }
 }
 
@@ -203,10 +206,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
-    &URLRequestMmtJob::DoStore, (void*)this);
-  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -217,6 +216,14 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+}
+
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
+
+/// for storage testing
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -225,32 +232,8 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    thiz->kvstoring_.first = key;
-    thiz->kvstoring_.second = value;
-    mmt::Content* pcontent = new mmt::Content;
-    *pcontent = *content;
-    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
-  }
-}
-void URLRequestMmtJob::DidStore() {
-  LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_, true);
-}
-
-void URLRequestMmtJob::DoTest(void* ptr) {
-}
-
-void URLRequestMmtJob::DidTest(void* ptr) {
-}
 
-bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+bool URLRequestMmtJob::GetRequestID(mmt::content_t* content, const URLRequest* request) {
     if (!content) return false;
     const content::ResourceRequestInfo* rinfo = 
         content::ResourceRequestInfo::ForRequest(request);
@@ -267,7 +250,7 @@ bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* req
     return is_ok;
 }
 
-bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserContext* context) {
     if (!content) return false;
     extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
     if (!frontend) {
@@ -295,7 +278,7 @@ bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserConte
     return true;
 }
 
-void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
     if (!content) return;
     content->tab_id = -1;
     content->tab_url = "";
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6d3e3da..25ee072 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,7 +15,9 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_control.h"
 
 namespace base {
 class TaskRunner;
@@ -63,31 +65,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void* ptr, int iret);
+  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, void* data, int size);
+  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
-  static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
-  void DidStore();
-
   // get info for render
-  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
-  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
-  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+  static void StorageCallback(ValueStore* storage);
+  static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
+  static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
 
  private:
-  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
-  mmt::Content content_;
-  std::pair<std::string, std::string> kvstoring_;
+  mmt::content_t content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 3e265c6c92f0a6ce0b9006f8fa1bed688c8072c9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 02:41:17 -0800
Subject: [PATCH 32/92] refine cictrl to support native msg

---
 .../docs/examples/api/cictrl/background.js         |   60 +++++++-
 .../docs/examples/api/cictrl/content_scripts.js    |   16 +--
 .../docs/examples/api/cictrl/manifest.json         |    6 +-
 .../docs/examples/api/cictrl/res/install_host.sh   |   40 ++++++
 .../api/cictrl/res/native-messaging-cictrl         |  151 ++++++++++++++++++++
 .../api/cictrl/res/org.chromium.cictrl.json        |   13 ++
 .../docs/examples/api/cictrl/res/uninstall_host.sh |   25 ++++
 7 files changed, 297 insertions(+), 14 deletions(-)
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
index e6b3978..7f2c324 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/background.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -1,15 +1,69 @@
+var port = null;
 
 function log(msg) {
+  msg = "[CI] " + msg;
   //alert(msg);
   console.log(msg);
 }
 
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  tabid = message["tabid"];
+  if (tabid == undefined) {
+    logMsg("no valid tabid");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript(tabid, {code: js});
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS(tabid, {code: css});
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cictrl";
+  port = chrome.runtime.connectNative(hostName);
+  log("port=" + port);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+// listen tab event
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    log("tabs complete id=" + tab.id);
+  }
+});
+
+// listen message
 chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
     log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
     if (request.greeting == "hello" && sender.tab) {
+        log("recv msg from tabs id=" + sender.tab.id);
+        connect();
         sendResponse({farewell: "goodbye"});
-        chrome.tabs.executeScript(sender.tab.id, {
-            code: 'document.body.style.backgroundColor="red"'
-        });
     }
 });
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
index a73420c..745d2ff 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -1,12 +1,12 @@
-// detect the changes of storage and apply them into current page
-
 function log(msg) {
     //alert(msg);
     console.log(msg);
 }
 
 // for chrome.storage.local
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
 chrome.storage.onChanged.addListener(function(changes, namespace) {
+    log("storage.onChanged");
     if (namespace != "local") {
         log("donot process the namespace = " + namespace);
         return;
@@ -14,17 +14,13 @@ chrome.storage.onChanged.addListener(function(changes, namespace) {
 
     for (key in changes) {
         var storageChange = changes[key];
-        log('Storage key "%s" in namespace "%s" changed. ' +
-            'Old value was "%s", new value is "%s".',
-            key,
-            namespace,
-            storageChange.oldValue,
-            storageChange.newValue);
+        log("Storage key " + key + " in namespace " + namespace + " changed. " +
+            "Old value was " + storageChange.oldValue + ", new value is " + storageChange.newValue);
     }
 });
 
-// chrome.storage.StorageArea.get()/set()/remove()/clear()
-// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+// document.readyState == "loading/interactive/complete"; 
+// it can ensure this script to be ran after window.onload
 window.onload = function() {
     log("window.onload");
     chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
index e955013..e86769b 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -1,12 +1,16 @@
 {
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
     "name" : "org.chromium.cictrl",
     "version": "1.0",
     "manifest_version": 2,
     "description": "chromium ci control",
     "permissions": [
+        "mmt://*/*",
         "file://*/*",
         "http://*/*",
-        "mmt://*/*",
+        "https://*/",
+        "nativeMessaging",
+        "notifications",
         "tabs", 
         "storage"
     ],
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
new file mode 100755
index 0000000..85f19b0
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cictrl
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
new file mode 100755
index 0000000..05279a2
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -0,0 +1,151 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+
+import time
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  try:
+    sys.stdout.flush()
+  except: return
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+  sock.bind((host, port))
+  while True:
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
+      break
+    send_message(msg)
+  sock.close()
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  sys.exit(0)
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
new file mode 100644
index 0000000..26aaa64
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cictrl",
+  "description": "Chromium Native Messaging For CI Control",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
new file mode 100755
index 0000000..52f9909
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Google/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromoium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR='$HOME/.config/chromium/NativeMessagingHosts'
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+rm $TARGET_DIR/org.chromium.cictrl.json
+echo Native messaging host $HOST_NAME has been uninstalled.
-- 
1.7.9.5


From 4150cc290d8ebe02dba5b62153cefac877814b7a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 03:06:43 -0800
Subject: [PATCH 33/92] try to fix mmt_stream read error

---
 net/mmt/mmt_control.cc                 |    2 +-
 net/mmt/mmt_stream.cc                  |    9 ++++++---
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index cd6274c..f7eba41 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -124,7 +124,7 @@ void MmtControl::Run() {
                 }
             }
         }
-        Wait(100);
+        Wait(10);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6e5be76..1674c20 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -51,9 +51,11 @@ bool Stream::Init() {
 
 bool Stream::Prepare(long *size) {
     if (!Init()) return false;
-    fseek(file_, 0L, SEEK_END);
+    int ierr = fseek(file_, 0L, SEEK_END);
     long lret = ftell(file_);
-    *size = lret;
+    if (size)
+        *size = lret;
+    LOG(INFO) << __func__ << " ierr=" << ierr << " lret=" << lret;
     return true;
 }
 
@@ -62,7 +64,8 @@ int Stream::Read(char *buf, int size, int offset) {
     int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
     if (iret <= 0) {
-        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret 
+            << " size=" << size << " offset=" << offset;
     }
     return iret; 
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b985b58..85bbe58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -145,6 +145,7 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 
 URLRequestMmtJob::~URLRequestMmtJob() {
   LOG(INFO) << __func__ << " thiz=" << this;
+  mmt::PostCtrlTask("@close", request_->url());
 }
 
 void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
-- 
1.7.9.5


From 22e6e75525838282b935c22dd7b98433b7706ce4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 04:59:30 -0800
Subject: [PATCH 34/92] fix read error

---
 net/mmt/mmt_control.cc                 |    6 +++---
 net/mmt/mmt_control.h                  |    9 ++++++---
 net/mmt/mmt_inc.h                      |    1 +
 net/url_request/url_request_mmt_job.cc |   16 +++++++++-------
 net/url_request/url_request_mmt_job.h  |    6 +++---
 5 files changed, 22 insertions(+), 16 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index f7eba41..516dee8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -40,11 +40,11 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     PostCtrlMsg(msg);
 }
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.sinfo = sinfo;
-    msg.ptr= ptr;
+    msg.ptr = ptr;
     msg.uri = GURL2FilePath(gurl);
     PostCtrlMsg(msg);
 }
@@ -118,7 +118,7 @@ void MmtControl::Run() {
                     << " uri=" << uri
                     << " size=" << msg.sinfo.size 
                     << " offset=" << msg.sinfo.offset 
-                    << " ptr=" << msg.ptr;
+                    << " ptr=" << msg.ptr.get();
                 if (msg.sinfo.func) {
                     msg.sinfo.func(msg.ptr, msg.sinfo, iret);
                 }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f02c47c..635328e 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -6,13 +6,16 @@
 
 namespace net {
 class IOBuffer;
+class URLRequestJob;
 }
 
 namespace mmt {
 
 struct stream_info_t;
+typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
+
 // (ptr, stream_info_t, errno)
-typedef void (*stream_func_t)(void*, stream_info_t&, int);
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
 struct stream_info_t {
     net::IOBuffer*  buf;
     int             size;
@@ -28,7 +31,7 @@ struct ctrl_msg_t {
     std::string body;
     std::string uri;
     int   tabid;
-    void* ptr;
+    job_refptr_t ptr;
 
     stream_info_t sinfo;
 };
@@ -65,7 +68,7 @@ void PostCtrlTask(std::string head, GURL gurl);
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index f5ba4f7..6bec3f4 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -13,6 +13,7 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 #include "net/udp/udp_socket.h"
+#include "net/url_request/url_request_job.h"
 
 #include "extensions/common/extension.h"
 #include "extensions/browser/extension_system.h"
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 85bbe58..a3d4b6f 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -47,6 +47,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartMmtCtrl();
+  read_info_.url = request_->url();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
@@ -55,7 +56,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   mmt::stream_info_t sinfo;
   sinfo.func = &URLRequestMmtJob::DoStart;
-  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -88,7 +89,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
-  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -144,13 +145,14 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " begin thiz=" << this;
+  mmt::PostCtrlTask("@close", read_info_.url);
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::PostCtrlTask("@close", request_->url());
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
@@ -188,10 +190,10 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 25ee072..dd34d13 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -62,13 +62,13 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    std::string uri;
+    GURL url;
   };
 
-  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
-- 
1.7.9.5


From 0dfe33f0e0532f705868d1d620b3c01031c05115 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 23:48:36 -0800
Subject: [PATCH 35/92] refine url_request and mmt

---
 net/mmt/mmt_control.cc                  |   41 ++++++++++++++++++++++---------
 net/mmt/mmt_control.h                   |    4 +--
 net/url_request/mmt_protocol_handler.cc |   10 +++++---
 net/url_request/mmt_protocol_handler.h  |    4 +--
 net/url_request/url_request_mmt_job.cc  |    4 +--
 5 files changed, 40 insertions(+), 23 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 516dee8..464548f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -22,13 +22,6 @@ void PostCtrlMsg(ctrl_msg_t &msg) {
     g_ctrl->Push(msg);
 }
 
-// for @close
-void PostCtrlTask(std::string head, GURL gurl) {
-    ctrl_msg_t msg;
-    msg.head = head;
-    msg.uri = GURL2FilePath(gurl);
-    PostCtrlMsg(msg);
-}
 
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
@@ -39,6 +32,14 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.uri = GURL2FilePath(gurl);
     PostCtrlMsg(msg);
 }
+// for @close
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.ptr = refptr;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
 // for @open and @read
 void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
@@ -70,6 +71,14 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
+static std::string mmtjob_key(std::string name, void* ptr) {
+    std::stringstream sstr;
+    sstr << name << "@" << ptr;
+    std::string key;
+    sstr >> key;
+    return key;
+}
+
 MmtControl::MmtControl() : SimpleThread("mmt_control"){
     running_ = false;
 }
@@ -81,34 +90,42 @@ void MmtControl::Run() {
     while(loop_) {
         ctrl_msg_t msg;
         if (!Pop(msg)) {
-            Wait(500);
+            Wait(100);
             continue;
         }
 
         std::string head = msg.head;
         std::string uri = msg.uri;
-        LOG(INFO) << __func__ << " head=" << head << " uri=" << uri;
 
         if (head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (head == "@test") {
             //..
         }else if (msg.head == "@open") {
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
             StreamPtr stream = new Stream(uri);
-            streams_.insert(stream_t(uri, stream));
+            streams_.insert(stream_t(key, stream));
             long lsize = -1;
             stream->Prepare(&lsize);
             if (msg.sinfo.func) {
                 msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
             }
         }else if (msg.head == "@close") {
-            streams_t::iterator iter = streams_.find(uri);
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
+            streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
-            streams_t::iterator iter = streams_.find(uri);
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
+            streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 635328e..00a88ef 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -63,10 +63,10 @@ namespace mmt {
 void StartMmtCtrl();
 void PostNativeMsg(std::string msg);
 
-// for @close
-void PostCtrlTask(std::string head, GURL gurl);
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
+// for @close
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
 // for @open and @read
 void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 19a5fbb..69f64f4 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,16 @@
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
-    : mmt_task_runner_(mmt_task_runner) {}
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : task_runner_(task_runner) {}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+  LOG(INFO) << __func__;
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  return new URLRequestMmtJob(request, network_delegate, mmt_task_runner_);
+  return new URLRequestMmtJob(request, network_delegate, task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index a823916..9ad37af 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -27,7 +27,7 @@ class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
   explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& mmt_task_runner);
+      const scoped_refptr<base::TaskRunner>& task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +35,7 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index a3d4b6f..e920fed 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -60,7 +60,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::PostCtrlTask("@close", request_->url());
+  mmt::PostCtrlTask("@close", request_->url(), this);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -145,8 +145,6 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
-  LOG(INFO) << __func__ << " begin thiz=" << this;
-  mmt::PostCtrlTask("@close", read_info_.url);
   LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-- 
1.7.9.5


From dc08539e5fcd696ddd757887c73b67b556b9cfc1 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 23:57:56 -0800
Subject: [PATCH 36/92] [ok] fixed read crash

---
 net/url_request/url_request_job.cc |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/net/url_request/url_request_job.cc b/net/url_request/url_request_job.cc
index 2deb0f5..e740b25 100644
--- a/net/url_request/url_request_job.cc
+++ b/net/url_request/url_request_job.cc
@@ -49,8 +49,10 @@ URLRequestJob::URLRequestJob(URLRequest* request,
       network_delegate_(network_delegate),
       weak_factory_(this) {
   base::PowerMonitor* power_monitor = base::PowerMonitor::Get();
-  if (power_monitor)
+  if (power_monitor) {
+    power_monitor->RemoveObserver(this);
     power_monitor->AddObserver(this);
+  }
 }
 
 void URLRequestJob::SetUpload(UploadDataStream* upload) {
-- 
1.7.9.5


From 4179176ababfe8153b923c206d74b12b3c7f13ce Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 00:28:51 -0800
Subject: [PATCH 37/92] [ok] refine for mmt play

---
 net/mmt/mmt_control.cc                 |   15 ++++++++++-----
 net/mmt/mmt_stream.cc                  |    4 ++--
 net/url_request/url_request_mmt_job.cc |    4 ++++
 3 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 464548f..80259f8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -87,10 +87,11 @@ MmtControl::~MmtControl() {}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
+    int ms = 100;
     while(loop_) {
         ctrl_msg_t msg;
         if (!Pop(msg)) {
-            Wait(100);
+            Wait(ms);
             continue;
         }
 
@@ -103,7 +104,7 @@ void MmtControl::Run() {
             //..
         }else if (msg.head == "@open") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             StreamPtr stream = new Stream(uri);
             streams_.insert(stream_t(key, stream));
@@ -112,23 +113,26 @@ void MmtControl::Run() {
             if (msg.sinfo.func) {
                 msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
             }
+            ms = 100;
         }else if (msg.head == "@close") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 streams_.erase(iter);
             }
+            ms = 100;
         }else if (msg.head == "@read") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+#if 0
                 LOG(INFO) << __func__ 
                     << " head=" << head 
                     << " iret=" << iret 
@@ -136,12 +140,13 @@ void MmtControl::Run() {
                     << " size=" << msg.sinfo.size 
                     << " offset=" << msg.sinfo.offset 
                     << " ptr=" << msg.ptr.get();
+#endif
                 if (msg.sinfo.func) {
                     msg.sinfo.func(msg.ptr, msg.sinfo, iret);
                 }
             }
+            ms = 10;
         }
-        Wait(10);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1674c20..524e8c5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -31,7 +31,7 @@ namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
-    LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
+    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
 }
 
 Stream::~Stream() {
@@ -71,7 +71,7 @@ int Stream::Read(char *buf, int size, int offset) {
 }
 
 void Stream::Uninit() {
-    LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
+    //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     if (file_) fclose(file_);
     file_ = nullptr;
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index e920fed..9222356 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -189,8 +189,10 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
+#if 0
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
+#endif
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -199,7 +201,9 @@ void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo,
 }
 
 void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+#if 0
   LOG(INFO) << __func__ << " data size=" << size;
+#endif
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-- 
1.7.9.5


From bb985498de4cf9bc385c865e13faffb04e349d4c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 04:49:13 -0800
Subject: [PATCH 38/92] refine ctrl

---
 net/mmt/mmt_control.cc                 |    5 +++--
 net/mmt/mmt_stream.cc                  |    5 +++++
 net/url_request/url_request_mmt_job.cc |    2 --
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 80259f8..77c6e9b 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -104,7 +104,7 @@ void MmtControl::Run() {
             //..
         }else if (msg.head == "@open") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             StreamPtr stream = new Stream(uri);
             streams_.insert(stream_t(key, stream));
@@ -116,7 +116,7 @@ void MmtControl::Run() {
             ms = 100;
         }else if (msg.head == "@close") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
@@ -147,6 +147,7 @@ void MmtControl::Run() {
             }
             ms = 10;
         }
+        Wait(ms);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 524e8c5..e3387c1 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -19,6 +19,11 @@ std::string GURL2String(GURL& gurl) {
 }
 
 content_t::content_t() {
+    process_id = 0;
+    frame_id = 0;
+    routing_id = 0;
+    tab_id = 0;
+    tab_url = "";
 }
 content_t::~content_t() {
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 9222356..4254650 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -189,10 +189,8 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-#if 0
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
-#endif
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-- 
1.7.9.5


From 5e93f5396d4ae5e24402ec5bbc28befc0e65701f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 06:25:26 -0800
Subject: [PATCH 39/92] refine ctrl 2

---
 net/mmt/mmt_control.cc |  103 ++++++++++++++++++++++++++----------------------
 net/mmt/mmt_control.h  |   10 ++++-
 net/mmt/mmt_inc.h      |    2 -
 net/mmt/mmt_stream.cc  |   11 ------
 4 files changed, 63 insertions(+), 63 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 77c6e9b..468ff55 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -29,7 +29,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.head = head;
     msg.body = body;
     msg.tabid = tabid;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @close
@@ -37,7 +37,7 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.ptr = refptr;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @open and @read
@@ -46,7 +46,7 @@ void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_
     msg.head = head;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 
@@ -59,7 +59,6 @@ namespace mmt {
 ctrl_msg_t::ctrl_msg_t() {
     head = "";
     body = "";
-    uri = "";
     tabid = -1;
     ptr = nullptr;
 
@@ -71,7 +70,8 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
-static std::string mmtjob_key(std::string name, void* ptr) {
+static std::string mmtjob_key(GURL url, void* ptr) {
+    std::string name = url.spec();
     std::stringstream sstr;
     sstr << name << "@" << ptr;
     std::string key;
@@ -84,6 +84,52 @@ MmtControl::MmtControl() : SimpleThread("mmt_control"){
 }
 MmtControl::~MmtControl() {}
 
+// for I/O stream
+void MmtControl::StreamOpen(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    // TODO: for local file testing
+    long lsize = -1;
+    StreamPtr stream = new Stream(msg.url.spec());
+    streams_.insert(stream_t(key, stream));
+    stream->Prepare(&lsize);
+    if (msg.sinfo.func) {
+        msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+    }
+}
+void MmtControl::StreamRead(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    streams_t::iterator iter = streams_.find(key);
+    if (iter != streams_.end()) {
+        StreamPtr stream = iter->second;
+        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+#if 0
+        LOG(INFO) << __func__ 
+            << " head=" << head 
+            << " iret=" << iret 
+            << " url=" << url
+            << " size=" << msg.sinfo.size 
+            << " offset=" << msg.sinfo.offset 
+            << " ptr=" << msg.ptr.get();
+#endif
+        if (msg.sinfo.func) {
+            msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+        }
+    }
+}
+void MmtControl::StreamClose(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    streams_t::iterator iter = streams_.find(key);
+    if (iter != streams_.end()) {
+        StreamPtr stream = iter->second;
+        streams_.erase(iter);
+    }
+}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
@@ -96,55 +142,17 @@ void MmtControl::Run() {
         }
 
         std::string head = msg.head;
-        std::string uri = msg.uri;
-
         if (head == "@ctrl") {
             PostNativeMsg(msg.body);
-        }else if (head == "@test") {
-            //..
+            ms = 100;
         }else if (msg.head == "@open") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            StreamPtr stream = new Stream(uri);
-            streams_.insert(stream_t(key, stream));
-            long lsize = -1;
-            stream->Prepare(&lsize);
-            if (msg.sinfo.func) {
-                msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
-            }
+            StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            streams_t::iterator iter = streams_.find(key);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                streams_.erase(iter);
-            }
+            StreamClose(msg);
             ms = 100;
         }else if (msg.head == "@read") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            streams_t::iterator iter = streams_.find(key);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
-#if 0
-                LOG(INFO) << __func__ 
-                    << " head=" << head 
-                    << " iret=" << iret 
-                    << " uri=" << uri
-                    << " size=" << msg.sinfo.size 
-                    << " offset=" << msg.sinfo.offset 
-                    << " ptr=" << msg.ptr.get();
-#endif
-                if (msg.sinfo.func) {
-                    msg.sinfo.func(msg.ptr, msg.sinfo, iret);
-                }
-            }
+            StreamRead(msg);
             ms = 10;
         }
         Wait(ms);
@@ -171,7 +179,6 @@ bool MmtControl::Pop(ctrl_msg_t &msg) {
 }
 
 void MmtControl::Push(ctrl_msg_t &msg) {
-    //LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 00a88ef..da9ee23 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -29,8 +29,8 @@ struct ctrl_msg_t {
 
     std::string head;
     std::string body;
-    std::string uri;
-    int   tabid;
+    GURL url;
+    int tabid;
     job_refptr_t ptr;
 
     stream_info_t sinfo;
@@ -47,6 +47,12 @@ public:
     bool Pop(ctrl_msg_t& msg);
     void Push(ctrl_msg_t& msg);
 
+protected:
+    // operations for I/O stream
+    void StreamOpen(ctrl_msg_t msg);
+    void StreamRead(ctrl_msg_t msg);
+    void StreamClose(ctrl_msg_t msg);
+
 private:
     bool loop_;
     bool running_;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 6bec3f4..e87612a 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -34,8 +34,6 @@
 
 namespace mmt{
 void Wait(int ms);
-std::string GURL2FilePath(GURL& gurl);
-std::string GURL2String(GURL& gurl);
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e3387c1..2004741 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,17 +6,6 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-std::string GURL2FilePath(GURL& gurl) {
-    std::string url;
-    base::FilePath file_path;
-    net::FileURLToFilePath(gurl, &file_path);
-    return file_path.value();
-}
-std::string GURL2String(GURL& gurl) {
-    std::ostringstream sstr;
-    sstr << gurl;
-    return sstr.str();
-}
 
 content_t::content_t() {
     process_id = 0;
-- 
1.7.9.5


From dbf1a55b79e846e7b2631e77fb507a14a33920b4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 22:24:40 -0800
Subject: [PATCH 40/92] todo: for sequence

---
 net/mmt/mmt_control.cc |    2 +-
 net/mmt/mmt_inc.h      |    2 +
 net/mmt/mmt_stream.cc  |  194 +++++++++++++++++++++++++++++++++++++++++++-----
 net/mmt/mmt_stream.h   |   20 ++++-
 4 files changed, 196 insertions(+), 22 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 468ff55..a66abf6 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -91,7 +91,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
 
     // TODO: for local file testing
     long lsize = -1;
-    StreamPtr stream = new Stream(msg.url.spec());
+    StreamPtr stream = new Stream(msg.url);
     streams_.insert(stream_t(key, stream));
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index e87612a..ebe8715 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -3,6 +3,7 @@
 
 #include <string>
 #include <sstream>
+#include <iomanip>
 
 #include "base/values.h"
 #include "base/strings/utf_string_conversions.h"
@@ -34,6 +35,7 @@
 
 namespace mmt{
 void Wait(int ms);
+std::string GURL2FilePath(GURL gurl);
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 2004741..5c93597 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,6 +6,61 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
+std::string Int2String(int value, int width=0) {
+    std::string szval;
+    std::stringstream sstr;
+    if (width == 0)
+        sstr << value;
+    else
+        sstr << std::setfill('0') << std::setw(width)<< value;
+    sstr >> szval;
+    return szval;
+}
+int String2Int(std::string value) {
+    int ival = -1;
+    std::stringstream sstr;
+    sstr << value;
+    sstr >> ival;
+    return ival;
+}
+std::string GURL2FilePath(GURL gurl) {
+    std::string szpath;
+    base::FilePath file_path;
+    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
+    if (is_file) {
+        szpath = file_path.value();
+    }
+    return szpath;
+}
+std::string GetQueryValue(std::string query, std::string key) {
+    std::string value;
+    std::string::size_type begin, end;
+
+    key += "=";
+    begin = query.find(key);
+    if (begin != std::string::npos) {
+        begin += key.size();
+        end = query.find("=", begin);
+        if (end == std::string::npos)
+            end = query.size();
+        value = query.substr(begin, end-begin);
+    }
+    return value;
+}
+bool GetRangeValue(std::string range, int &lval, int &rval) {
+    bool bok = false;
+    std::string lstr = "0";
+    std::string rstr = "9999999";
+    int begin = range.find("-");
+    if (begin >= 0) {
+        lstr = range.substr(0, begin);
+        rstr = range.substr(begin+1, range.size()-begin);
+        bok = true;
+    }
+    lval = String2Int(lstr);
+    rval = String2Int(rstr);
+    return bok;
+}
 
 content_t::content_t() {
     process_id = 0;
@@ -23,51 +78,154 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
-Stream::Stream(const std::string &uri) 
-    : uri_(uri), file_(nullptr) { 
-    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
+Stream::Stream(const GURL &url) 
+    : url_(url), file_(nullptr) { 
+    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
+    midx_.begin = -1;
+    midx_.end = -1;
+    midx_.cur = -1;
 }
 
 Stream::~Stream() {
     Uninit();
 }
 
-std::string Stream::getUri() {
-    return uri_;
+GURL Stream::getUrl() {
+    return url_;
 }
 
 bool Stream::Init() {
     if (file_) return true;
-    file_ = fopen(uri_.c_str(), "rb");
-    if (file_) return true;
-    return false;
-}
 
+    // default file if it is html
+    std::string fname = GURL2FilePath(url_);
+
+    if (midx_.cur == -1) {
+        // if exists query, then should redirect to real file name
+        std::string query = url_.query();
+        if (!query.empty()) { // media sequence
+            std::string mtype = GetQueryValue(query, "type");
+            if (mtype.empty()) return false;
+
+            // compute the sequence of media
+            if (midx_.begin < 0 || midx_.end < 0) {
+                std::string range = GetQueryValue(query, "sequence_num");
+                GetRangeValue(range, midx_.begin, midx_.end);
+            }
+
+            // choose the current sequence
+            midx_.cur = midx_.begin;
+        }
+    }
+
+    if (midx_.cur >= 0) {
+        if (midx_.cur < midx_.begin || midx_.cur > midx_.end)
+            return false;
+
+        std::string mtype = GetQueryValue(url_.query(), "type");
+        if (mtype == "audio") {
+            fname = fname + "/Channel1_Audio1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+        }else if (mtype == "video") {
+            fname = fname + "/Channel1_Video1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+        }
+    }
+    file_ = fopen(fname.c_str(), "rb");
+    offmap_[midx_.cur] = offset_t();
+    
+    // compute the file size and its current offset
+    int ierr = fseek(file_, 0L, SEEK_END);
+    offmap_[midx_.cur].size = ftell(file_);
+    offmap_[midx_.cur].off = 0;
+    if (midx_.cur > midx_.begin) { // media sequence
+        offmap_[midx_.cur].off = offmap_[midx_.cur-1].off + offmap_[midx_.cur-1].size;
+    }
+    ierr = fseek(file_, 0L, SEEK_SET);
+
+    return (file_ != nullptr);
+}
 bool Stream::Prepare(long *size) {
     if (!Init()) return false;
-    int ierr = fseek(file_, 0L, SEEK_END);
-    long lret = ftell(file_);
-    if (size)
-        *size = lret;
-    LOG(INFO) << __func__ << " ierr=" << ierr << " lret=" << lret;
+    long lret = 1<<30; // default 1GB
+    if (midx_.cur == -1) {
+        lret = offmap_[midx_.cur].size;
+    }
+    if (size)   *size = lret;
+    LOG(INFO) << __func__ << " lret=" << lret;
     return true;
 }
+long Stream::Seek(int offset, int whence) {
+    if (!Init()) return -1;
 
+    long lret = -1;
+    if (midx_.cur == -1) { // for html file
+        int ierr = fseek(file_, offset, whence);
+        if (ierr == 0) {
+            lret = ftell(file_);
+        }
+    }else { // for media sequence
+        int idx = -1;
+        int off = -1;
+        if (offset < offmap_[midx_.cur].off) { // backward
+            Close();
+            for (int k=midx_.cur; k >= midx_.begin; k--) {
+                off = offset - offmap_[k].off;
+                if (off > 0) {
+                    idx = k;
+                    break;
+                }
+            }
+        }else if (offset >= offmap_[midx_.cur].off + offmap_[midx_.cur].size) { //forward
+            for(int k=midx_.cur+1; k <= midx_.end; k++) {
+                Close();
+                if(!Init()) return -1;
+                off = offmap_[k].off + offmap_[k].size - offset;
+                if (off > 0) {
+                    idx = k;
+                    break;
+                }
+            }
+        }else {
+            idx = midx_.cur;
+            off = offset - offmap_[midx_.cur].off;
+        }
+
+        if (idx == -1) return -1;
+        midx_.cur = idx;
+        if (!Init()) return -1;
+        int ierr = fseek(file_, off, whence);
+        if (ierr != 0) return -1;
+        lret = ftell(file_);
+    }
+    return lret;
+}
 int Stream::Read(char *buf, int size, int offset) {
     if (!Init()) return -1;
-    int ierr = fseek(file_, offset, SEEK_SET);
+
+    long lret = Seek(offset, SEEK_SET);
+    if (lret < 0) return -1;
+
     int iret = fread(buf, 1, size, file_);
     if (iret <= 0) {
-        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret 
+        LOG(INFO) << __func__ << " iret=" << iret 
             << " size=" << size << " offset=" << offset;
+    }else if (iret < size) {
+        lret = Seek(offset+iret, SEEK_SET);
+        if (lret < 0) return iret;
+        iret += fread(buf, 1, size - iret, file_);
     }
     return iret; 
 }
+void Stream::Close() {
+    if (file_) fclose(file_);
+    file_ = nullptr;
+}
 
 void Stream::Uninit() {
     //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
-    if (file_) fclose(file_);
-    file_ = nullptr;
+    Close();
+    midx_.begin = -1;
+    midx_.end = -1;
+    midx_.cur = -1;
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b4d11b9..189916b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -43,13 +43,25 @@ struct content_t {
 
 namespace mmt {
 
+struct triple_t {
+    int begin;
+    int end;
+    int cur;
+};
+struct offset_t {
+    offset_t() : off(0), size(0) {}
+    long off;
+    long size;
+};
 class Stream : public base::RefCounted<Stream> {
 public:
-    explicit Stream(const std::string &uri);
-    std::string getUri();
+    explicit Stream(const GURL &url);
+    GURL getUrl();
     bool Init();
     bool Prepare(long *size);
+    long Seek(int offset, int whence);
     int Read(char *buf, int size, int offset);
+    void Close();
     void Uninit();
 
 protected:
@@ -57,7 +69,9 @@ protected:
     virtual ~Stream();
 
 private:
-    std::string uri_;
+    GURL url_;
+    triple_t midx_;
+    std::map<int, offset_t> offmap_;
     FILE *file_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
-- 
1.7.9.5


From 883e9107151456f6fc8d2507ed7802be333870fc Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 20 Jan 2015 18:28:31 -0800
Subject: [PATCH 41/92] todo: refine for sequence

---
 net/mmt/mmt_control.cc                 |    3 +-
 net/mmt/mmt_control.h                  |    2 +-
 net/mmt/mmt_stream.cc                  |  123 ++++++++++++++++++--------------
 net/mmt/mmt_stream.h                   |    3 +-
 net/url_request/url_request_mmt_job.cc |   24 +++++--
 5 files changed, 93 insertions(+), 62 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index a66abf6..28d1ff4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -41,13 +41,14 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
     PostCtrlMsg(msg);
 }
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
     msg.url = gurl;
     PostCtrlMsg(msg);
+    return -1; // IO_PENDING
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index da9ee23..df79ea1 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -74,7 +74,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @close
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5c93597..c3e89a6 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -40,7 +40,7 @@ std::string GetQueryValue(std::string query, std::string key) {
     begin = query.find(key);
     if (begin != std::string::npos) {
         begin += key.size();
-        end = query.find("=", begin);
+        end = query.find("&", begin);
         if (end == std::string::npos)
             end = query.size();
         value = query.substr(begin, end-begin);
@@ -54,7 +54,9 @@ bool GetRangeValue(std::string range, int &lval, int &rval) {
     int begin = range.find("-");
     if (begin >= 0) {
         lstr = range.substr(0, begin);
+        if (lstr.empty()) lstr = "-1";
         rstr = range.substr(begin+1, range.size()-begin);
+        if (rstr.empty()) rstr = "9999999";
         bok = true;
     }
     lval = String2Int(lstr);
@@ -94,58 +96,71 @@ GURL Stream::getUrl() {
     return url_;
 }
 
-bool Stream::Init() {
-    if (file_) return true;
-
-    // default file if it is html
-    std::string fname = GURL2FilePath(url_);
+bool Stream::ParseSequence(int& index) {
+    // if exists query, then should redirect to real file name
+    std::string query = url_.query();
+    if (!query.empty()) { // media sequence
+        std::string mtype = GetQueryValue(query, "type");
+        std::string range = GetQueryValue(query, "sequence_num");
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
+        if (mtype.empty()) return false;
+
+        // compute the sequence of media
+        GetRangeValue(range, midx_.begin, midx_.end);
+        index = midx_.begin;
+        LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
+        if (index < 0 || midx_.begin > midx_.end) return false;
+    }else {
+        index = -1;
+    }
+    return true;
+}
 
-    if (midx_.cur == -1) {
-        // if exists query, then should redirect to real file name
-        std::string query = url_.query();
-        if (!query.empty()) { // media sequence
-            std::string mtype = GetQueryValue(query, "type");
-            if (mtype.empty()) return false;
-
-            // compute the sequence of media
-            if (midx_.begin < 0 || midx_.end < 0) {
-                std::string range = GetQueryValue(query, "sequence_num");
-                GetRangeValue(range, midx_.begin, midx_.end);
-            }
+bool Stream::Init(int index) {
+    if (file_) return true;
 
-            // choose the current sequence
-            midx_.cur = midx_.begin;
-        }
+    if(index < 0 && !ParseSequence(index)) {
+        LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
+        return false;
     }
 
-    if (midx_.cur >= 0) {
-        if (midx_.cur < midx_.begin || midx_.cur > midx_.end)
+    // default file is html
+    std::string fname = GURL2FilePath(url_);
+    if (index >= 0) {
+        if (index < midx_.begin || index > midx_.end)
             return false;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
-            fname = fname + "/Channel1_Audio1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+            fname = fname + "/audio/Channel1_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == "video") {
-            fname = fname + "/Channel1_Video1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+            fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
+    LOG(INFO) << __func__ << " fname=" << fname;
+
+    // open and get file size
     file_ = fopen(fname.c_str(), "rb");
-    offmap_[midx_.cur] = offset_t();
-    
-    // compute the file size and its current offset
+    if (!file_) return false;
     int ierr = fseek(file_, 0L, SEEK_END);
-    offmap_[midx_.cur].size = ftell(file_);
-    offmap_[midx_.cur].off = 0;
-    if (midx_.cur > midx_.begin) { // media sequence
-        offmap_[midx_.cur].off = offmap_[midx_.cur-1].off + offmap_[midx_.cur-1].size;
-    }
+    long lret = ftell(file_);
     ierr = fseek(file_, 0L, SEEK_SET);
 
-    return (file_ != nullptr);
+    offmap_[index] = offset_t();
+    offmap_[index].off = 0;
+    offmap_[index].size = lret;
+    if (index > midx_.begin) { // media sequence
+        offmap_[index].off = offmap_[index-1].off + offmap_[index-1].size;
+    }
+    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+
+    midx_.cur = index;
+    return true;
 }
 bool Stream::Prepare(long *size) {
-    if (!Init()) return false;
+    if (!Init(midx_.cur)) return false;
     long lret = 1<<30; // default 1GB
+    //lret = 1029855;
     if (midx_.cur == -1) {
         lret = offmap_[midx_.cur].size;
     }
@@ -154,10 +169,11 @@ bool Stream::Prepare(long *size) {
     return true;
 }
 long Stream::Seek(int offset, int whence) {
-    if (!Init()) return -1;
+    if (!Init(midx_.cur)) return -1;
 
     long lret = -1;
-    if (midx_.cur == -1) { // for html file
+    int cur = midx_.cur;
+    if (cur == -1) { // for html file
         int ierr = fseek(file_, offset, whence);
         if (ierr == 0) {
             lret = ftell(file_);
@@ -165,19 +181,19 @@ long Stream::Seek(int offset, int whence) {
     }else { // for media sequence
         int idx = -1;
         int off = -1;
-        if (offset < offmap_[midx_.cur].off) { // backward
+        if (offset < offmap_[cur].off) { // backward
             Close();
-            for (int k=midx_.cur; k >= midx_.begin; k--) {
+            for (int k=cur; k >= midx_.begin; k--) {
                 off = offset - offmap_[k].off;
                 if (off > 0) {
                     idx = k;
                     break;
                 }
             }
-        }else if (offset >= offmap_[midx_.cur].off + offmap_[midx_.cur].size) { //forward
-            for(int k=midx_.cur+1; k <= midx_.end; k++) {
+        }else if (offset >= offmap_[cur].off + offmap_[cur].size) { //forward
+            for(int k=cur+1; k <= midx_.end; k++) {
                 Close();
-                if(!Init()) return -1;
+                if(!Init(k)) break;
                 off = offmap_[k].off + offmap_[k].size - offset;
                 if (off > 0) {
                     idx = k;
@@ -185,21 +201,22 @@ long Stream::Seek(int offset, int whence) {
                 }
             }
         }else {
-            idx = midx_.cur;
-            off = offset - offmap_[midx_.cur].off;
+            idx = cur;
+            off = offset - offmap_[cur].off;
         }
+        LOG(INFO) << __func__ << " cur=" << cur << " next=" << idx << " relative off=" << off;
 
         if (idx == -1) return -1;
-        midx_.cur = idx;
-        if (!Init()) return -1;
+        if (!Init(idx)) return -1;
         int ierr = fseek(file_, off, whence);
-        if (ierr != 0) return -1;
-        lret = ftell(file_);
+        if (ierr == 0)
+            lret = ftell(file_);
     }
+    LOG(INFO) << __func__ << " lret=" << lret << " offset=" << offset;
     return lret;
 }
 int Stream::Read(char *buf, int size, int offset) {
-    if (!Init()) return -1;
+    if (!Init(midx_.cur)) return -1;
 
     long lret = Seek(offset, SEEK_SET);
     if (lret < 0) return -1;
@@ -209,9 +226,11 @@ int Stream::Read(char *buf, int size, int offset) {
         LOG(INFO) << __func__ << " iret=" << iret 
             << " size=" << size << " offset=" << offset;
     }else if (iret < size) {
-        lret = Seek(offset+iret, SEEK_SET);
-        if (lret < 0) return iret;
-        iret += fread(buf, 1, size - iret, file_);
+        //lret = Seek(offset+iret, SEEK_SET);
+        //if (lret < 0) return iret;
+        //iret += fread(buf+iret, 1, size-iret, file_);
+        Close();
+        midx_.cur++;
     }
     return iret; 
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 189916b..066d257 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -57,7 +57,8 @@ class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const GURL &url);
     GURL getUrl();
-    bool Init();
+    bool ParseSequence(int& index);
+    bool Init(int index);
     bool Prepare(long *size);
     long Seek(int offset, int whence);
     int Read(char *buf, int size, int offset);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4254650..77084d7 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -83,13 +83,14 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = ERR_IO_PENDING;
   mmt::stream_info_t sinfo;
   sinfo.buf = dest;
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
-  mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
+
+  // return ERR_IO_PENDING if aysnc read
+  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -140,6 +141,9 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
         NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                                     ERR_REQUEST_RANGE_NOT_SATISFIABLE));
       }
+      LOG(INFO) << __func__ << " ranges.size=" << ranges.size()
+        << " first=" << byte_range_.first_byte_position()
+        << " last=" << byte_range_.last_byte_position();
     }
   }
 }
@@ -184,13 +188,18 @@ void URLRequestMmtJob::DidStart(int iret) {
   read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(read_info_.remaining_bytes, 0);
 
+  LOG(INFO) << __func__ 
+    << " remaining_bytes=" << read_info_.remaining_bytes
+    << " first=" << byte_range_.first_byte_position()
+    << " last=" << byte_range_.last_byte_position();
+
   set_expected_content_size(read_info_.remaining_bytes);
   NotifyHeadersComplete();
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret << 
-    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
+    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -199,9 +208,6 @@ void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo,
 }
 
 void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
-#if 0
-  LOG(INFO) << __func__ << " data size=" << size;
-#endif
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
@@ -210,7 +216,11 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
 
-  if (result == 0) {
+  // fix error
+  if (result == -1)
+    result = OK;
+
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-- 
1.7.9.5


From 44a47ddd15273071675737687556dd2c4ae7e633 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 21 Jan 2015 05:46:10 -0800
Subject: [PATCH 42/92] todo: enable streaming for mmt

---
 .../docs/examples/api/cimsg/native-messaging-cimsg |    5 ++++-
 content/browser/loader/async_resource_handler.cc   |    5 ++++-
 media/blink/buffered_data_source.cc                |    3 ++-
 media/blink/buffered_data_source.h                 |    2 +-
 media/blink/buffered_resource_loader.cc            |    9 ++++++++-
 media/filters/ffmpeg_glue.cc                       |    2 +-
 net/mmt/mmt_stream.cc                              |    1 -
 net/url_request/url_request_mmt_job.cc             |    8 +++++++-
 8 files changed, 27 insertions(+), 8 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
index 05279a2..2b31c6b 100755
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -26,7 +26,10 @@ except ImportError:
 def send_message(message):
   # message must be JSON string
   if len(message) < 16: return
-  jdata = JSONDecoder().decode(message)
+  try:
+    jdata = JSONDecoder().decode(message)
+  except:
+    jdata = None
   if not jdata: return
 
   # Write message size.
diff --git a/content/browser/loader/async_resource_handler.cc b/content/browser/loader/async_resource_handler.cc
index 51b0a744..241384d 100644
--- a/content/browser/loader/async_resource_handler.cc
+++ b/content/browser/loader/async_resource_handler.cc
@@ -39,7 +39,7 @@ namespace {
 
 static int kBufferSize = 1024 * 512;
 static int kMinAllocationSize = 1024 * 4;
-static int kMaxAllocationSize = 1024 * 32;
+static int kMaxAllocationSize = 1024 * 128;
 
 void GetNumericArg(const std::string& name, int* result) {
   const std::string& value =
@@ -57,6 +57,9 @@ void InitializeResourceBufferConstants() {
   GetNumericArg("resource-buffer-size", &kBufferSize);
   GetNumericArg("resource-buffer-min-allocation-size", &kMinAllocationSize);
   GetNumericArg("resource-buffer-max-allocation-size", &kMaxAllocationSize);
+  LOG(INFO) << __func__ << " kBufferSize=" << kBufferSize
+    << " kMinAllocationSize=" << kMinAllocationSize
+    << " kMaxAllocationSize" << kMaxAllocationSize;
 }
 
 int CalcUsedPercentage(int bytes_read, int buffer_size) {
diff --git a/media/blink/buffered_data_source.cc b/media/blink/buffered_data_source.cc
index e3e12e0..af69dc2 100644
--- a/media/blink/buffered_data_source.cc
+++ b/media/blink/buffered_data_source.cc
@@ -18,7 +18,7 @@ namespace {
 // BufferedDataSource has an intermediate buffer, this value governs the initial
 // size of that buffer. It is set to 32KB because this is a typical read size
 // of FFmpeg.
-const int kInitialReadBufferSize = 32768;
+const int kInitialReadBufferSize = 32768 * 4;
 
 // Number of cache misses or read failures we allow for a single Read() before
 // signaling an error.
@@ -264,6 +264,7 @@ bool BufferedDataSource::GetSize(int64* size_out) {
 }
 
 bool BufferedDataSource::IsStreaming() {
+  LOG(INFO) << __func__ << " streaming_=" << streaming_;
   return streaming_;
 }
 
diff --git a/media/blink/buffered_data_source.h b/media/blink/buffered_data_source.h
index b047c19..0b08887 100644
--- a/media/blink/buffered_data_source.h
+++ b/media/blink/buffered_data_source.h
@@ -105,7 +105,7 @@ class MEDIA_EXPORT BufferedDataSource : public DataSource {
   void MediaIsPaused();
 
   // Returns true if the resource is local.
-  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS(); }
+  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS() && !url_.SchemeIs(url::kMmtScheme); }
 
   // DataSource implementation.
   // Called from demuxer thread.
diff --git a/media/blink/buffered_resource_loader.cc b/media/blink/buffered_resource_loader.cc
index d88266d..a3afd89 100644
--- a/media/blink/buffered_resource_loader.cc
+++ b/media/blink/buffered_resource_loader.cc
@@ -320,6 +320,7 @@ int64 BufferedResourceLoader::instance_size() {
 }
 
 bool BufferedResourceLoader::range_supported() {
+  LOG(INFO) << "BufferedResourceLoader::range_supported() = " << range_supported_;
   return range_supported_;
 }
 
@@ -426,7 +427,13 @@ void BufferedResourceLoader::didReceiveResponse(
         return;
       }
     }
-
+  } else if (url_.SchemeIs(url::kMmtScheme)){
+    instance_size_ = content_length_;
+    LOG(INFO) << "BufferedResourceLoader::didReceiveResponse" 
+        << " content_length_=" << content_length_
+        << " first_byte_position_=" << first_byte_position_
+        << " last_byte_position_=" << last_byte_position_
+        << " instance_size_=" << instance_size_; 
   } else {
     CHECK_EQ(instance_size_, kPositionNotSpecified);
     if (content_length_ != kPositionNotSpecified) {
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index dabd7d5..6c77ba4 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 256 * 1024 };
+enum { kBufferSize = 128 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index c3e89a6..f473d76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -160,7 +160,6 @@ bool Stream::Init(int index) {
 bool Stream::Prepare(long *size) {
     if (!Init(midx_.cur)) return false;
     long lret = 1<<30; // default 1GB
-    //lret = 1029855;
     if (midx_.cur == -1) {
         lret = offmap_[midx_.cur].size;
     }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 77084d7..6cdffa9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -120,7 +120,13 @@ Filter* URLRequestMmtJob::SetupFilter() const {
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  *mime_type = std::string("text/html");
+  std::string spec = request_->url().spec();
+  if (spec.find("type=video") != std::string::npos)
+    *mime_type = std::string("video/mp4");
+  else if (spec.find("type=audio") != std::string::npos)
+    *mime_type = std::string("audio/mp4");
+  else
+    *mime_type = std::string("text/html");
   return true;
 }
 
-- 
1.7.9.5


From 963527b8e7ee0abbab12d33d29ebe6efd2d9bc41 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 22 Jan 2015 22:11:28 -0800
Subject: [PATCH 43/92] Add mpu module into chrome

---
 net/mmt/mpu/Makefile       |   21 +
 net/mmt/mpu/mp4.c          | 3945 ++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mpu/mp4.h          | 1218 ++++++++++++++
 net/mmt/mpu/mpu.gyp        |   85 +
 net/mmt/mpu/stream.c       |  390 +++++
 net/mmt/mpu/stream.h       |  143 ++
 net/mmt/mpu/test_parser.cc |   40 +
 7 files changed, 5842 insertions(+)
 create mode 100644 net/mmt/mpu/Makefile
 create mode 100644 net/mmt/mpu/mp4.c
 create mode 100644 net/mmt/mpu/mp4.h
 create mode 100644 net/mmt/mpu/mpu.gyp
 create mode 100644 net/mmt/mpu/stream.c
 create mode 100644 net/mmt/mpu/stream.h
 create mode 100644 net/mmt/mpu/test_parser.cc

diff --git a/net/mmt/mpu/Makefile b/net/mmt/mpu/Makefile
new file mode 100644
index 0000000..021f39c
--- /dev/null
+++ b/net/mmt/mpu/Makefile
@@ -0,0 +1,21 @@
+TARGET = parser
+OBJS = stream.o mp4.o test_parser.o
+CFLAGS = -I../../../
+LDFLAGS = -lm
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
new file mode 100644
index 0000000..9e64657
--- /dev/null
+++ b/net/mmt/mpu/mp4.c
@@ -0,0 +1,3945 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include <math.h>
+#include <stdarg.h>
+#include "net/mmt/mpu/mp4.h"
+
+void *debug_malloc(size_t size, const char *file, int line, const char *func)
+{
+    void *p;
+    p = malloc(size);
+    printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
+            file, line, func, size, (unsigned long)p);
+    return p;
+}
+
+void *debug_free(char *p)
+{
+    if(NULL!=(p))
+    {
+        free(p) ;
+        p = NULL;
+    }
+}
+
+
+#define msg_Dbg(x) do {} while (0)
+#define msg_Warn(x) do {} while (0)
+#define msg_Err(x) do {} while (0)
+
+#ifndef M_PI
+#define M_PI       3.14159265358979323846
+#endif
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+#define FREENULL(a) do { free( a ); a = NULL; } while(0)
+
+#define MP4_GETX_PRIVATE(dst, code, size) do { \
+    if( (i_read) >= (size) ) { dst = (code); p_peek += (size); } \
+    else { dst = 0; }   \
+    i_read -= (size);   \
+} while(0)
+
+static uint32_t mp4_box_headersize( mp4_box_t *p_box )
+{
+    return 8
+        + ( p_box->i_shortsize == 1 ? 8 : 0 )
+        + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
+}
+
+static uint32_t Get24bBE( const uint8_t *p )
+{
+    return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
+}
+
+#define MP4_GET1BYTE( dst )  MP4_GETX_PRIVATE( dst, *p_peek, 1 )
+#define MP4_GET2BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE16(*(uint16_t*)p_peek), 2 )
+#define MP4_GET3BYTES( dst ) MP4_GETX_PRIVATE( dst, Get24bBE(p_peek), 3 )
+#define MP4_GET4BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE32(*(uint32_t*)p_peek), 4 )
+#define MP4_GET8BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE64(*(uint64_t*)p_peek), 8 )
+#define MP4_GETFOURCC( dst ) MP4_GETX_PRIVATE( dst, \
+        MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
+
+#define MP4_GETVERSIONFLAGS( p_void ) \
+    MP4_GET1BYTE( p_void->version ); \
+MP4_GET3BYTES( p_void->flags )
+
+#define MP4_GETSTRINGZ( p_str )         \
+    if( (i_read > 0) && (p_peek[0]) )   \
+{       \
+    const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
+    p_str = malloc( __i_copy__+1 );               \
+    if( p_str ) \
+    { \
+        memcpy( p_str, p_peek, __i_copy__ ); \
+        p_str[__i_copy__] = 0; \
+    } \
+    p_peek += __i_copy__ + 1;   \
+    i_read -= __i_copy__ + 1;   \
+}       \
+else    \
+{       \
+    p_str = NULL; \
+}
+
+#define MP4_READBOX_ENTER( mp4_box_data_TYPE_t ) \
+    int64_t  i_read = p_box->i_size; \
+uint8_t *p_peek, *p_buff; \
+int i_actually_read; \
+if( !( p_peek = p_buff = malloc( i_read ) ) ) \
+{ \
+    return( 0 ); \
+} \
+i_actually_read = stream_read( p_stream, p_peek, i_read ); \
+if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
+{ \
+    free( p_buff ); \
+    return( 0 ); \
+} \
+p_peek += mp4_box_headersize( p_box ); \
+i_read -= mp4_box_headersize( p_box ); \
+if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
+{ \
+    free( p_buff ); \
+    return( 0 ); \
+}
+
+#define MP4_READBOX_EXIT( i_code ) \
+    do \
+{ \
+    free( p_buff ); \
+    if( i_read < 0 ) \
+    printf( "Not enough data" ); \
+    return( i_code ); \
+} while (0)
+
+
+/* Some assumptions:
+ * The input method HAS to be seekable
+ */
+
+/* This macro is used when we want to printf the box type
+ * APPLE annotation box is :
+ *  either 0xA9 + 24-bit ASCII text string (and 0xA9 isn't printable)
+ *  either 32-bit ASCII text string
+ */
+#define MP4_BOX_TYPE_ASCII() ( ((char*)&p_box->i_type)[0] != (char)0xA9 )
+
+
+static void CreateUUID( uuid_t *p_uuid, uint32_t i_fourcc )
+{
+    /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
+    /* FIXME implement this */
+    (void)p_uuid;
+    (void)i_fourcc;
+}
+
+static int drms_init( void *_p_drms, uint32_t i_type,
+        uint8_t *p_info, uint32_t i_len )
+{
+    return 1;
+}
+
+static void GetUUID( uuid_t *p_uuid, const uint8_t *p_buff )
+{
+    memcpy( p_uuid, p_buff, 16 );
+}
+
+/* convert 16.16 fixed point to floating point */
+static double conv_fx( int32_t fx ) {
+    double fp = fx;
+    fp /= 65536.0;
+    return fp;
+}
+
+/* some functions for mp4 encoding of variables */
+#ifdef MP4_VERBOSE
+static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
+{
+    int i_day;
+    int i_hour;
+    int i_min;
+    int i_sec;
+
+    /* date begin at 1 jan 1904 */
+    i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
+
+    i_day = i_date / ( 60*60*24);
+    i_hour = ( i_date /( 60*60 ) ) % 60;
+    i_min  = ( i_date / 60 ) % 60;
+    i_sec =  i_date % 60;
+    sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
+}
+#endif
+
+/*****************************************************************************
+ * MP4_ReadBoxCommon : Load only common parameters for all boxes
+ *****************************************************************************
+ * p_box need to be an already allocated mp4_box_t, and all data
+ *  will only be peek not read
+ *
+ * RETURN : 0 if it fail, 1 otherwise
+ *****************************************************************************/
+int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int      i_read;
+    const uint8_t *p_buff = malloc(32);
+    const uint8_t *p_peek = p_buff;
+
+    if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+    {
+        free(p_buff);
+        return 0;
+    }
+
+    p_box->i_pos = stream_tell( p_stream );
+
+    p_box->data.p_data = NULL;
+    p_box->p_father = NULL;
+    p_box->p_first  = NULL;
+    p_box->p_last  = NULL;
+    p_box->p_next   = NULL;
+
+    MP4_GET4BYTES( p_box->i_shortsize );
+    MP4_GETFOURCC( p_box->i_type );
+
+    /* Now special case */
+
+    if( p_box->i_shortsize == 1 )
+    {
+        /* get the true size on 64 bits */
+        MP4_GET8BYTES( p_box->i_size );
+    }
+    else
+    {
+        p_box->i_size = p_box->i_shortsize;
+        /* XXX size of 0 means that the box extends to end of file */
+    }
+
+    if( p_box->i_type == ATOM_uuid )
+    {
+        /* get extented type on 16 bytes */
+        GetUUID( &p_box->i_uuid, p_peek );
+        p_peek += 16; i_read -= 16;
+    }
+    else
+    {
+        CreateUUID( &p_box->i_uuid, p_box->i_type );
+    }
+
+    free(p_buff);
+
+    // #ifdef MP4_VERBOSE
+    //    if( p_box->i_size )
+    //    {
+    //       if MP4_BOX_TYPE_ASCII()
+    //           printf( "found Box: %4.4s size %"PRId64,
+    //          (char*)&p_box->i_type, p_box->i_size );
+    //       else
+    //           printf( "found Box: c%3.3s size %"PRId64,
+    //          (char*)&p_box->i_type+1, p_box->i_size );
+    //    }
+    // #endif
+
+    return 1;
+}
+
+/*****************************************************************************
+ * MP4_NextBox : Go to the next box
+ *****************************************************************************
+ * if p_box == NULL, go to the next box in which we are( at the begining ).
+ *****************************************************************************/
+static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t box;
+
+    if( !p_box )
+    {
+        MP4_ReadBoxCommon( p_stream, &box );
+        p_box = &box;
+    }
+
+    if( !p_box->i_size )
+    {
+        return 2; /* Box with infinite size */
+    }
+
+    if( p_box->p_father )
+    {
+        const int64_t i_box_end = p_box->i_size + p_box->i_pos;
+        const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
+
+        /* check if it's within p-father */
+        if( i_box_end >= i_father_end )
+        {
+            if( i_box_end > i_father_end )
+                printf(  "out of bound child" );
+            return 0; /* out of bound */
+        }
+    }
+
+    if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
+    {
+        return 0;
+    }
+
+    return 1;
+}
+
+/*****************************************************************************
+ * For all known box a loader is given,
+ *  XXX: all common struct have to be already read by MP4_ReadBoxCommon
+ *       after called one of theses functions, file position is unknown
+ *       you need to call MP4_GotoBox to go where you want
+ *****************************************************************************/
+static int MP4_ReadBoxContainerRaw( stream_t *p_stream, mp4_box_t *p_container )
+{
+    mp4_box_t *p_box;
+
+    if( stream_tell( p_stream ) + 8 >
+            (int64_t)(p_container->i_pos + p_container->i_size) )
+    {
+        /* there is no box to load */
+        return 0;
+    }
+
+    do
+    {
+        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
+
+        /* chain this box with the father and the other at same level */
+        if( !p_container->p_first ) p_container->p_first = p_box;
+        else p_container->p_last->p_next = p_box;
+        p_container->p_last = p_box;
+
+    } while( MP4_NextBox( p_stream, p_box ) == 1 );
+
+    return 1;
+}
+
+static int MP4_ReadBoxContainer( stream_t *p_stream, mp4_box_t *p_container )
+{
+    if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
+    {
+        /* container is empty, 8 stand for the first header in this box */
+        return 1;
+    }
+
+    /* enter box */
+    stream_seek( p_stream, p_container->i_pos +
+            mp4_box_headersize( p_container ), SEEK_SET );
+
+    return MP4_ReadBoxContainerRaw( p_stream, p_container );
+}
+
+static void MP4_FreeBox_Common( mp4_box_t *p_box )
+{
+    /* Up to now do nothing */
+    (void)p_box;
+}
+
+static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
+{
+    /* XXX sometime moov is hiden in a free box */
+    if( p_box->p_father &&
+            p_box->p_father->i_type == ATOM_root &&
+            p_box->i_type == ATOM_free )
+    {
+        const uint8_t *p_buff = malloc(44);
+        const uint8_t *p_peek = p_buff;
+        int     i_read;
+        uint32_t i_fcc;
+
+        i_read  = stream_peek( p_stream, p_peek, 44 );
+
+        p_peek += mp4_box_headersize( p_box ) + 4;
+        i_read -= mp4_box_headersize( p_box ) + 4;
+
+        if( i_read >= 8 )
+        {
+            i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
+
+            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
+            {
+                printf( "detected moov hidden in a free box ..." );
+
+                p_box->i_type = ATOM_foov;
+                free(p_buff);
+                return MP4_ReadBoxContainer( p_stream, p_box );
+            }
+        }
+        free(p_buff);
+    }
+
+    /* Nothing to do */
+    // #ifdef MP4_VERBOSE
+    //    if MP4_BOX_TYPE_ASCII()
+    //        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
+    //    else
+    //        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
+    // #endif
+
+    return 1;
+}
+
+#   define likely(p)   (!!(p))
+#   define unlikely(p) (!!(p))
+
+static int MP4_ReadBox_ftyp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
+
+    MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
+    MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
+
+    if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
+    {
+        unsigned int i = 0;
+        uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
+            calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
+
+        if( unlikely( tab == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+
+        for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
+        {
+            MP4_GETFOURCC( tab[i] );
+        }
+    }
+    else
+    {
+        p_box->data.p_ftyp->compatible_brands = NULL;
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_ftyp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_ftyp->compatible_brands );
+}
+
+static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int mmpu_buf;
+    int i;
+    MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
+    MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
+    MP4_GET1BYTE(mmpu_buf);
+    p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
+    p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
+    MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
+    MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
+    MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
+    p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
+    for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
+    {
+
+        MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
+    }
+
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
+
+    if( p_box->data.p_tfdt->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+    }
+
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_mmpu( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_mmpu->asset_id_value );
+}
+
+
+static int MP4_ReadBox_mvhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_mvhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );
+
+    if( p_box->data.p_mvhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mvhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mvhd->duration );
+    }
+    MP4_GET4BYTES( p_box->data.p_mvhd->rate );
+    MP4_GET2BYTES( p_box->data.p_mvhd->volume );
+    MP4_GET2BYTES( p_box->data.p_mvhd->reserved1 );
+
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->reserved2[i] );
+    }
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->matrix[i] );
+    }
+    for( i = 0; i < 6; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->predefined[i] );
+    }
+
+    MP4_GET4BYTES( p_box->data.p_mvhd->next_track_id );
+
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time,
+            p_box->data.p_mvhd->modification_time );
+    if( p_box->data.p_mvhd->rate )
+    {
+        MP4_ConvertDate2Str( s_duration,
+                p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
+    }
+    else
+    {
+        s_duration[0] = 0;
+    }
+    printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
+            s_creation_time,
+            s_modification_time,
+            (uint32_t)p_box->data.p_mvhd->timescale,
+            s_duration,
+            (float)p_box->data.p_mvhd->rate / (1<<16 ),
+            (float)p_box->data.p_mvhd->volume / 256 ,
+            (uint32_t)p_box->data.p_mvhd->next_track_id );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mfhd_t );
+
+    MP4_GET4BYTES( p_box->data.p_mfhd->sequence_number );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"mfhd\" sequence number %d",
+            p_box->data.p_mfhd->sequence_number );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_tfhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfhd );
+
+    MP4_GET4BYTES( p_box->data.p_tfhd->track_ID );
+
+    if( p_box->data.p_tfhd->version == 0 )
+    {
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_BASE_DATA_OFFSET )
+            MP4_GET8BYTES( p_box->data.p_tfhd->base_data_offset );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            MP4_GET4BYTES( p_box->data.p_tfhd->sample_description_index );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_duration );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_size );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_flags );
+
+#ifdef MP4_VERBOSE
+        char psz_base[128] = "\0";
+        char psz_desc[128] = "\0";
+        char psz_dura[128] = "\0";
+        char psz_size[128] = "\0";
+        char psz_flag[128] = "\0";
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )
+            snprintf(psz_base, sizeof(psz_base), "base offset %"PRId64, p_box->data.p_tfhd->base_data_offset);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            snprintf(psz_desc, sizeof(psz_desc), "sample description index %d", p_box->data.p_tfhd->sample_description_index);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            snprintf(psz_dura, sizeof(psz_dura), "sample duration %d", p_box->data.p_tfhd->default_sample_duration);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            snprintf(psz_size, sizeof(psz_size), "sample size %d", p_box->data.p_tfhd->default_sample_size);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            snprintf(psz_flag, sizeof(psz_flag), "sample flags 0x%x", p_box->data.p_tfhd->default_sample_flags);
+
+        printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
+                p_box->data.p_tfhd->i_version,
+                p_box->data.p_tfhd->i_flags,
+                p_box->data.p_tfhd->track_ID,
+                psz_base, psz_desc, psz_dura, psz_size, psz_flag );
+#endif
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_trun_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_trun );
+
+    MP4_GET4BYTES( p_box->data.p_trun->sample_count );
+
+    if( p_box->data.p_trun->flags & MP4_TRUN_DATA_OFFSET )
+        MP4_GET4BYTES( p_box->data.p_trun->data_offset );
+    if( p_box->data.p_trun->flags & MP4_TRUN_FIRST_FLAGS )
+        MP4_GET4BYTES( p_box->data.p_trun->first_sample_flags );
+
+    p_box->data.p_trun->samples =
+        calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
+    if ( p_box->data.p_trun->samples == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_sample->duration );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_sample->size );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_sample->flags );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_TIME_OFFSET )
+            MP4_GET4BYTES( p_sample->composition_time_offset );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
+            p_box->data.p_trun->version,
+            p_box->data.p_trun->flags,
+            p_box->data.p_trun->sample_count );
+
+    for( unsigned int i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+        printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
+                i, p_sample->i_flags, p_sample->duration,
+                p_sample->i_size, p_sample->composition_time_offset );
+    }
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_trun( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_trun->samples );
+}
+
+
+static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    double rotation;    //angle in degrees to be rotated clockwise
+    double scale[2];    // scale factor; sx = scale[0] , sy = scale[1]
+    double translate[2];// amount to translate; tx = translate[0] , ty = translate[1]
+    int *matrix = NULL;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_tkhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tkhd );
+
+    if( p_box->data.p_tkhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET8BYTES( p_box->data.p_tkhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET4BYTES( p_box->data.p_tkhd->duration );
+    }
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved2[i] );
+    }
+    MP4_GET2BYTES( p_box->data.p_tkhd->layer );
+    MP4_GET2BYTES( p_box->data.p_tkhd->predefined );
+    MP4_GET2BYTES( p_box->data.p_tkhd->volume );
+    MP4_GET2BYTES( p_box->data.p_tkhd->reserved3 );
+
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->matrix[i] );
+    }
+    MP4_GET4BYTES( p_box->data.p_tkhd->width );
+    MP4_GET4BYTES( p_box->data.p_tkhd->height );
+
+
+    matrix = p_box->data.p_tkhd->matrix;
+
+    translate[0] = conv_fx(matrix[6]);
+    translate[1] = conv_fx(matrix[7]);
+
+    scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +
+            conv_fx(matrix[3]) * conv_fx(matrix[3]));
+    scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +
+            conv_fx(matrix[4]) * conv_fx(matrix[4]));
+
+    rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;
+
+    if (rotation < 0)
+        rotation += 360.;
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->modification_time );
+    MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->duration );
+
+    printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
+            "Matrix: %i %i %i %i %i %i %i %i %i",
+            s_creation_time,
+            s_modification_time,
+            s_duration,
+            p_box->data.p_tkhd->track_ID,
+            p_box->data.p_tkhd->layer,
+            (float)p_box->data.p_tkhd->volume / 256 ,
+            rotation,
+            scale[0],
+            scale[1],
+            translate[0],
+            translate[1],
+            (float)p_box->data.p_tkhd->width / 65536,
+            (float)p_box->data.p_tkhd->height / 65536,
+            p_box->data.p_tkhd->matrix[0],
+            p_box->data.p_tkhd->matrix[1],
+            p_box->data.p_tkhd->matrix[2],
+            p_box->data.p_tkhd->matrix[3],
+            p_box->data.p_tkhd->matrix[4],
+            p_box->data.p_tkhd->matrix[5],
+            p_box->data.p_tkhd->matrix[6],
+            p_box->data.p_tkhd->matrix[7],
+            p_box->data.p_tkhd->matrix[8] );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hint( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_hint_t );
+
+    MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint16_t i_language;
+    unsigned int i = 0;
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    MP4_READBOX_ENTER( mp4_box_data_mdhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mdhd );
+
+    if( p_box->data.p_mdhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mdhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mdhd->duration );
+    }
+    p_box->data.p_mdhd->language_code = i_language = SwapBE16( p_peek );
+    for( i = 0; i < 3; i++ )
+    {
+        p_box->data.p_mdhd->language[i] =
+            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_mdhd->predefined );
+
+    // #ifdef MP4_VERBOSE
+    //     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
+    //     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
+    //     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
+    //      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
+    //                   s_creation_time,
+    //                   s_modification_time,
+    //                   (uint32_t)p_box->data.p_mdhd->timescale,
+    //                   s_duration,
+    //                   p_box->data.p_mdhd->language[0],
+    //                   p_box->data.p_mdhd->language[1],
+    //                   p_box->data.p_mdhd->language[2] );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hdlr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_hdlr_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hdlr );
+
+    MP4_GETFOURCC( p_box->data.p_hdlr->predefined );
+    MP4_GETFOURCC( p_box->data.p_hdlr->handler_type );
+
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    p_box->data.p_hdlr->psz_name = NULL;
+
+    if( i_read > 0 )
+    {
+        uint8_t *psz = p_box->data.p_hdlr->psz_name = malloc( i_read + 1 );
+        if( unlikely( psz == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        if( p_box->data.p_hdlr->predefined == MP4_FOURCC( 'm', 'h', 'l', 'r' ) )
+        {
+            uint8_t i_len;
+            int i_copy;
+
+            MP4_GET1BYTE( i_len );
+            i_copy = min( i_read, i_len );
+
+            memcpy( psz, p_peek, i_copy );
+            p_box->data.p_hdlr->psz_name[i_copy] = '\0';
+        }
+        else
+        {
+            memcpy( psz, p_peek, i_read );
+            p_box->data.p_hdlr->psz_name[i_read] = '\0';
+        }
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
+            (char*)&p_box->data.p_hdlr->handler_type,
+            p_box->data.p_hdlr->psz_name );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_hdlr( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_hdlr->psz_name );
+}
+
+static int MP4_ReadBox_vmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
+
+    MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
+    for( i = 0; i < 3; i++ )
+    {
+        MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
+            p_box->data.p_vmhd->i_graphics_mode,
+            p_box->data.p_vmhd->i_opcolor[0],
+            p_box->data.p_vmhd->i_opcolor[1],
+            p_box->data.p_vmhd->i_opcolor[2] );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_smhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_smhd );
+
+
+
+    MP4_GET2BYTES( p_box->data.p_smhd->balance );
+
+    MP4_GET2BYTES( p_box->data.p_smhd->reserved );
+
+    // #ifdef MP4_VERBOSE
+    //      printf( "read box: \"smhd\" balance %f",
+    //                       (float)p_box->data.p_smhd->balance / 256 );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_hmhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hmhd );
+
+    MP4_GET2BYTES( p_box->data.p_hmhd->max_PDU_size );
+    MP4_GET2BYTES( p_box->data.p_hmhd->avg_PDU_size );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->max_bitrate );
+    MP4_GET4BYTES( p_box->data.p_hmhd->avg_bitrate );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->reserved );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
+            p_box->data.p_hmhd->max_PDU_size,
+            p_box->data.p_hmhd->avg_PDU_size,
+            p_box->data.p_hmhd->max_bitrate,
+            p_box->data.p_hmhd->avg_bitrate );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_url( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_url_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_url );
+    MP4_GETSTRINGZ( p_box->data.p_url->psz_location );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"url\" url: %s",
+            p_box->data.p_url->psz_location );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_url( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_url->psz_location );
+}
+
+static int MP4_ReadBox_urn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_urn_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_urn );
+
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_name );
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"urn\" name %s location %s",
+            p_box->data.p_urn->psz_name,
+            p_box->data.p_urn->psz_location );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_urn( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_urn->psz_name );
+    FREENULL( p_box->data.p_urn->psz_location );
+}
+
+
+static int MP4_ReadBox_dref( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_dref_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_dref );
+
+    MP4_GET4BYTES( p_box->data.p_dref->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"dref\" entry-count %d",
+            p_box->data.p_dref->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stts->sample_count );
+    FREENULL( p_box->data.p_stts->sample_delta );
+}
+
+static int MP4_ReadBox_stts( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_stts_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stts );
+    MP4_GET4BYTES( p_box->data.p_stts->entry_count );
+
+    p_box->data.p_stts->sample_count =
+        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stts->sample_delta =
+        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+    if( p_box->data.p_stts->sample_count == NULL
+            || p_box->data.p_stts->sample_delta == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
+        MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stts\" entry-count %d",
+            p_box->data.p_stts->entry_count );
+
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_ctts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_ctts->sample_count );
+    FREENULL( p_box->data.p_ctts->sample_offset );
+}
+
+static int MP4_ReadBox_ctts( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_ctts_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
+
+    MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
+
+    p_box->data.p_ctts->sample_count =
+        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+    p_box->data.p_ctts->sample_offset =
+        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+    if( ( p_box->data.p_ctts->sample_count == NULL )
+            || ( p_box->data.p_ctts->sample_offset == NULL ) )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
+        MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"ctts\" entry-count %d",
+            p_box->data.p_ctts->entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadLengthDescriptor( uint8_t **pp_peek, int64_t  *i_read )
+{
+    unsigned int i_b;
+    unsigned int i_len = 0;
+    do
+    {
+        i_b = **pp_peek;
+
+        (*pp_peek)++;
+        (*i_read)--;
+        i_len = ( i_len << 7 ) + ( i_b&0x7f );
+    } while( i_b&0x80 );
+    return( i_len );
+}
+
+
+static void MP4_FreeBox_esds( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_esds->es_descriptor.psz_URL );
+    if( p_box->data.p_esds->es_descriptor.decConfigDescr )
+    {
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr->decoder_specific_info );
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr );
+    }
+}
+
+static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
+{
+#define es_descriptor p_box->data.p_esds->es_descriptor
+    unsigned int i_len;
+    unsigned int i_flags;
+    unsigned int i_type;
+
+    MP4_READBOX_ENTER( mp4_box_data_esds_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_esds );
+
+
+    MP4_GET1BYTE( i_type );
+    if( i_type == 0x03 ) /* MP4ESDescrTag */
+    {
+        i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+        printf( "found esds MPEG4ESDescr (%dBytes)",
+                i_len );
+#endif
+
+        MP4_GET2BYTES( es_descriptor.ES_ID );
+        MP4_GET1BYTE( i_flags );
+        es_descriptor.b_stream_dependence = ( (i_flags&0x80) != 0);
+        es_descriptor.b_url = ( (i_flags&0x40) != 0);
+        es_descriptor.b_OCRstream = ( (i_flags&0x20) != 0);
+
+        es_descriptor.stream_priority = i_flags&0x1f;
+        if( es_descriptor.b_stream_dependence )
+        {
+            MP4_GET2BYTES( es_descriptor.depend_on_ES_ID );
+        }
+        if( es_descriptor.b_url )
+        {
+            unsigned int i_len;
+
+            MP4_GET1BYTE( i_len );
+            es_descriptor.psz_URL = malloc( i_len + 1 );
+            if( es_descriptor.psz_URL )
+            {
+                memcpy( es_descriptor.psz_URL, p_peek, i_len );
+                es_descriptor.psz_URL[i_len] = 0;
+            }
+            p_peek += i_len;
+            i_read -= i_len;
+        }
+        else
+        {
+            es_descriptor.psz_URL = NULL;
+        }
+        if( es_descriptor.b_OCRstream )
+        {
+            MP4_GET2BYTES( es_descriptor.OCR_ES_ID );
+        }
+        MP4_GET1BYTE( i_type ); /* get next type */
+    }
+
+    if( i_type != 0x04)/* MP4DecConfigDescrTag */
+    {
+        es_descriptor.decConfigDescr = NULL;
+        MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+    printf( "found esds MP4DecConfigDescr (%dBytes)",
+            i_len );
+#endif
+
+    es_descriptor.decConfigDescr =
+        calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
+    if( unlikely( es_descriptor.decConfigDescr == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET1BYTE( es_descriptor.decConfigDescr->objectTypeIndication );
+    MP4_GET1BYTE( i_flags );
+    es_descriptor.decConfigDescr->streamType = i_flags >> 2;
+    es_descriptor.decConfigDescr->b_upStream = ( i_flags >> 1 )&0x01;
+    MP4_GET3BYTES( es_descriptor.decConfigDescr->buffer_sizeDB );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->max_bitrate );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->avg_bitrate );
+    MP4_GET1BYTE( i_type );
+    if( i_type !=  0x05 )/* MP4DecSpecificDescrTag */
+    {
+        es_descriptor.decConfigDescr->decoder_specific_info_len = 0;
+        es_descriptor.decConfigDescr->decoder_specific_info  = NULL;
+        MP4_READBOX_EXIT( 1 );
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+    printf( "found esds MP4DecSpecificDescr (%dBytes)",
+            i_len );
+#endif
+    if( i_len > i_read )
+        MP4_READBOX_EXIT( 0 );
+
+    es_descriptor.decConfigDescr->decoder_specific_info_len = i_len;
+    es_descriptor.decConfigDescr->decoder_specific_info = malloc( i_len );
+    if( unlikely( es_descriptor.decConfigDescr->decoder_specific_info == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    memcpy( es_descriptor.decConfigDescr->decoder_specific_info,
+            p_peek, i_len );
+
+    MP4_READBOX_EXIT( 1 );
+#undef es_descriptor
+}
+
+static void MP4_FreeBox_avcC( mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC = p_box->data.p_avcC;
+    int i;
+
+    if( p_avcC->avcC > 0 ) FREENULL( p_avcC->p_avcC );
+
+    if( p_avcC->p_sps )
+    {
+        for( i = 0; i < p_avcC->sps; i++ )
+            FREENULL( p_avcC->p_sps[i] );
+    }
+    if( p_avcC->p_pps )
+    {
+        for( i = 0; i < p_avcC->pps; i++ )
+            FREENULL( p_avcC->p_pps[i] );
+    }
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->p_sps );
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->sps_length );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->p_pps );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->pps_length );
+}
+
+static int MP4_ReadBox_avcC( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC;
+    int i;
+
+    MP4_READBOX_ENTER( mp4_box_data_avcC_t );
+    p_avcC = p_box->data.p_avcC;
+
+    p_avcC->avcC = i_read;
+    if( p_avcC->avcC > 0 )
+    {
+        uint8_t * p = p_avcC->p_avcC = malloc( p_avcC->avcC );
+        if( p )
+            memcpy( p, p_peek, i_read );
+    }
+
+    MP4_GET1BYTE( p_avcC->version );
+    MP4_GET1BYTE( p_avcC->profile );
+    MP4_GET1BYTE( p_avcC->profile_compatibility );
+    MP4_GET1BYTE( p_avcC->level );
+    MP4_GET1BYTE( p_avcC->reserved1 );
+    p_avcC->length_size = (p_avcC->reserved1&0x03) + 1;
+    p_avcC->reserved1 >>= 2;
+
+    MP4_GET1BYTE( p_avcC->reserved2 );
+    p_avcC->sps = p_avcC->reserved2&0x1f;
+    p_avcC->reserved2 >>= 5;
+
+    if( p_avcC->sps > 0 )
+    {
+        p_avcC->sps_length = calloc( p_avcC->sps, sizeof( uint16_t ) );
+        p_avcC->p_sps = calloc( p_avcC->sps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->sps_length || !p_avcC->p_sps )
+            goto error;
+
+        for( i = 0; i < p_avcC->sps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->sps_length[i] );
+            p_avcC->p_sps[i] = malloc( p_avcC->sps_length[i] );
+            if( p_avcC->p_sps[i] )
+                memcpy( p_avcC->p_sps[i], p_peek, p_avcC->sps_length[i] );
+
+            p_peek += p_avcC->sps_length[i];
+            i_read -= p_avcC->sps_length[i];
+        }
+    }
+
+    MP4_GET1BYTE( p_avcC->pps );
+    if( p_avcC->pps > 0 )
+    {
+        p_avcC->pps_length = calloc( p_avcC->pps, sizeof( uint16_t ) );
+        p_avcC->p_pps = calloc( p_avcC->pps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->pps_length || !p_avcC->p_pps )
+            goto error;
+
+        for( i = 0; i < p_avcC->pps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->pps_length[i] );
+            p_avcC->p_pps[i] = malloc( p_avcC->pps_length[i] );
+            if( p_avcC->p_pps[i] )
+                memcpy( p_avcC->p_pps[i], p_peek, p_avcC->pps_length[i] );
+
+            p_peek += p_avcC->pps_length[i];
+            i_read -= p_avcC->pps_length[i];
+        }
+    }
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
+    //              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
+    //              p_avcC->i_length_size,
+    //              p_avcC->i_sps, p_avcC->i_pps );
+    //     for( i = 0; i < p_avcC->i_sps; i++ )
+    //     {
+    //          printf( "         - sps[%d] length=%d",
+    //                  i, p_avcC->i_sps_length[i] );
+    //     }
+    //     for( i = 0; i < p_avcC->i_pps; i++ )
+    //     {
+    //          printf( "         - pps[%d] length=%d",
+    //                  i, p_avcC->i_pps_length[i] );
+    //     }
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+
+error:
+    MP4_READBOX_EXIT( 0 );
+}
+
+static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_dac3_t *p_dac3;
+    unsigned i_header;
+
+    MP4_READBOX_ENTER( mp4_box_data_dac3_t );
+
+    p_dac3 = p_box->data.p_dac3;
+
+    MP4_GET3BYTES( i_header );
+
+    p_dac3->fscod = ( i_header >> 22 ) & 0x03;
+    p_dac3->bsid  = ( i_header >> 17 ) & 0x01f;
+    p_dac3->bsmod = ( i_header >> 14 ) & 0x07;
+    p_dac3->acmod = ( i_header >> 11 ) & 0x07;
+    p_dac3->lfeon = ( i_header >> 10 ) & 0x01;
+    p_dac3->bitrate_code = ( i_header >> 5) & 0x1f;
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
+            p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_enda( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_enda_t *p_enda;
+    MP4_READBOX_ENTER( mp4_box_data_enda_t );
+
+    p_enda = p_box->data.p_enda;
+
+    MP4_GET2BYTES( p_enda->little_endian );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_gnre( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_gnre_t *p_gnre;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_gnre_t );
+
+    p_gnre = p_box->data.p_gnre;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 10 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET2BYTES( p_gnre->genre );
+    if( p_gnre->genre == 0 )
+        MP4_READBOX_EXIT( 0 );
+#ifdef MP4_VERBOSE
+    printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_trkn_t *p_trkn;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_trkn_t );
+
+    p_trkn = p_box->data.p_trkn;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 12 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( p_trkn->track_number );
+
+    // #ifdef MP4_VERBOSE
+    //      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
+    // #endif
+
+    if( i_data_len > 15 )
+    {
+        MP4_GET4BYTES( p_trkn->track_total );
+
+        // #ifdef MP4_VERBOSE
+        //         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
+        // #endif
+
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
+    p_box->data.p_sample_soun->qt_description = NULL;
+
+    /* Sanity check needed because the "wave" box does also contain an
+     * "mp4a" box that we don't understand. */
+    if( i_read < 28 )
+    {
+        i_read -= 30;
+        MP4_READBOX_EXIT( 1 );
+    }
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
+
+    /*
+     * XXX hack -> produce a copy of the nearly complete chunk
+     */
+    p_box->data.p_sample_soun->qt_description = 0;
+    p_box->data.p_sample_soun->p_qt_description = NULL;
+    if( i_read > 0 )
+    {
+        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
+        if( p_box->data.p_sample_soun->p_qt_description )
+        {
+            p_box->data.p_sample_soun->qt_description = i_read;
+            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
+        }
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
+    MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
+
+    if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
+    {
+        /* SoundDescriptionV1 */
+        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
+
+#ifdef MP4_VERBOSE
+        printf(
+                "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
+                "bytes/frame=%d bytes/sample=%d",
+                p_box->data.p_sample_soun->i_sample_per_packet,
+                p_box->data.p_sample_soun->i_bytes_per_packet,
+                p_box->data.p_sample_soun->i_bytes_per_frame,
+                p_box->data.p_sample_soun->i_bytes_per_sample );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 44, SEEK_SET );
+    }
+    else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
+    {
+        /* SoundDescriptionV2 */
+        double f_sample_rate;
+        int64_t dummy;
+        uint32_t i_channel;
+
+        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+        MP4_GET8BYTES( dummy );
+        memcpy( &f_sample_rate, &dummy, 8 );
+
+        printf( "read box: %f Hz", f_sample_rate );
+        p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
+        p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
+
+        MP4_GET4BYTES( i_channel );
+        p_box->data.p_sample_soun->channelcount = i_channel;
+
+#ifdef MP4_VERBOSE
+        printf( "read box: \"soun\" V2" );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
+    }
+    else
+    {
+        p_box->data.p_sample_soun->sample_per_packet = 0;
+        p_box->data.p_sample_soun->bytes_per_packet = 0;
+        p_box->data.p_sample_soun->bytes_per_frame = 0;
+        p_box->data.p_sample_soun->bytes_per_sample = 0;
+
+#ifdef MP4_VERBOSE
+        printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
+                i_read );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 28, SEEK_SET );
+    }
+
+    if( p_box->i_type == ATOM_drms )
+    {
+        assert(0);
+        //         char *home = config_GetUserDir( VLC_HOME_DIR );
+        //         if( home != NULL )
+        //         {
+        //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
+        //             if( p_box->data.p_sample_soun->p_drms == NULL )
+        //                 msg_Err( p_stream, "drms_alloc() failed" );
+        //         }
+    }
+
+    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
+    {
+        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
+        p_box->data.p_sample_soun->channelcount = 1;
+    }
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"soun\" in stsd channel %d "
+            "sample size %d sample rate %f",
+            p_box->data.p_sample_soun->channelcount,
+            p_box->data.p_sample_soun->samplesize,
+            (float)p_box->data.p_sample_soun->sampleratehi +
+            (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+/*****************************************************************************
+ * aes_s: AES keys structure
+ *****************************************************************************
+ * This structure stores a set of keys usable for encryption and decryption
+ * with the AES/Rijndael algorithm.
+ *****************************************************************************/
+#define AES_KEY_COUNT 10
+#define PATH_MAX 260
+struct aes_s
+{
+    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+};
+
+/*****************************************************************************
+ * drms_s: DRMS structure
+ *****************************************************************************
+ * This structure stores the static information needed to decrypt DRMS data.
+ *****************************************************************************/
+struct drms_s
+{
+    uint32_t i_user;
+    uint32_t i_key;
+    uint8_t  p_iviv[ 16 ];
+    uint8_t *p_name;
+
+    uint32_t p_key[ 4 ];
+    struct aes_s aes;
+
+    char     psz_homedir[ PATH_MAX ];
+};
+
+/*****************************************************************************
+ * drms_free: free a previously allocated DRMS structure
+ *****************************************************************************/
+void drms_free( void *_p_drms )
+{
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+
+    //free( (void *)p_drms->p_name );
+    free( p_drms->p_name );
+    free( p_drms );
+}
+
+
+static void MP4_FreeBox_sample_soun( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_soun->p_qt_description );
+
+    if( p_box->i_type == ATOM_drms )
+    {
+        if( p_box->data.p_sample_soun->drms )
+        {
+            drms_free( p_box->data.p_sample_soun->drms );
+        }
+    }
+}
+
+
+int MP4_ReadBox_sample_vide( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
+
+    /*
+     * XXX hack -> produce a copy of the nearly complete chunk
+     */
+    if( i_read > 0 )
+    {
+        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
+        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+        p_box->data.p_sample_vide->qt_image_description = i_read;
+        memcpy( p_box->data.p_sample_vide->p_qt_image_description,
+                p_peek, i_read );
+    }
+    else
+    {
+        p_box->data.p_sample_vide->qt_image_description = 0;
+        p_box->data.p_sample_vide->p_qt_image_description = NULL;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->width );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->height );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
+
+    memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
+    p_peek += 32; i_read -= 32;
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
+
+    if( p_box->i_type == ATOM_drmi )
+    {
+        assert(0);
+        //         char *home = config_GetUserDir( VLC_HOME_DIR );
+        //         if( home != NULL )
+        //         {
+        //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
+        //             if( p_box->data.p_sample_vide->p_drms == NULL )
+        //                 msg_Err( p_stream, "drms_alloc() failed" );
+        //         }
+    }
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"vide\" in stsd %dx%d depth %d",
+            p_box->data.p_sample_vide->width,
+            p_box->data.p_sample_vide->height,
+            p_box->data.p_sample_vide->depth );
+
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+void MP4_FreeBox_sample_vide( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
+
+    if( p_box->i_type == ATOM_drmi )
+    {
+        if( p_box->data.p_sample_vide->drms )
+        {
+            drms_free( p_box->data.p_sample_vide->drms );
+        }
+    }
+}
+
+
+int MP4_ReadBox_sample_mmth( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    unsigned int  mmth_buf;
+    int j;
+    MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
+
+
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
+    MP4_GET1BYTE(mmth_buf);
+    p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
+    p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
+    p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
+
+    /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
+      MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
+      p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
+      for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
+      {
+
+      MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
+      }*/
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_mp4s( stream_t *p_stream, mp4_box_t *p_box )
+{
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+    return 1;
+}
+
+static int MP4_ReadBox_sample_text( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int32_t t;
+
+    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+    MP4_GET4BYTES( t );
+    switch( t )
+    {
+        /* FIXME search right signification */
+        case 1: // Center
+            p_box->data.p_sample_text->justification_horizontal = 1;
+            p_box->data.p_sample_text->justification_vertical = 1;
+            break;
+        case -1:    // Flush Right
+            p_box->data.p_sample_text->justification_horizontal = -1;
+            p_box->data.p_sample_text->justification_vertical = -1;
+            break;
+        case -2:    // Flush p_first
+            p_box->data.p_sample_text->justification_horizontal = 0;
+            p_box->data.p_sample_text->justification_vertical = 0;
+            break;
+        case 0: // Flush Default
+        default:
+            p_box->data.p_sample_text->justification_horizontal = 1;
+            p_box->data.p_sample_text->justification_vertical = -1;
+            break;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
+    p_box->data.p_sample_text->background_color[3] = 0;
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"text\" in stsd text" );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
+
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"tx3g\" in stsd text" );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+#if 0
+/* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */
+static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_text->psz_text_name );
+}
+#endif
+
+
+static int MP4_ReadBox_stsd( stream_t *p_stream, mp4_box_t *p_box )
+{
+
+    MP4_READBOX_ENTER( mp4_box_data_stsd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
+
+    MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsd\" entry-count %d",
+            p_box->data.p_stsd->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stsz( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsz_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
+
+    MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
+    MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
+
+    if( p_box->data.p_stsz->sample_size == 0 )
+    {
+        p_box->data.p_stsz->entry_size =
+            calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
+        if( unlikely( !p_box->data.p_stsz->entry_size ) )
+            MP4_READBOX_EXIT( 0 );
+
+        for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
+        {
+            MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
+        }
+    }
+    else
+        p_box->data.p_stsz->entry_size = NULL;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsz\" sample-size %d sample-count %d",
+            p_box->data.p_stsz->sample_size,
+            p_box->data.p_stsz->sample_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stsz( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsz->entry_size );
+}
+
+static void MP4_FreeBox_stsc( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsc->first_chunk );
+    FREENULL( p_box->data.p_stsc->samples_per_chunk );
+    FREENULL( p_box->data.p_stsc->sample_description_index );
+}
+
+static int MP4_ReadBox_stsc( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsc_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
+
+    MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
+
+    p_box->data.p_stsc->first_chunk =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsc->samples_per_chunk =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsc->sample_description_index =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    if( unlikely( p_box->data.p_stsc->first_chunk == NULL
+                || p_box->data.p_stsc->samples_per_chunk == NULL
+                || p_box->data.p_stsc->sample_description_index == NULL ) )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
+        MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
+        MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsc\" entry-count %d",
+            p_box->data.p_stsc->entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_stco_co64( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_co64_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
+
+    MP4_GET4BYTES( p_box->data.p_co64->entry_count );
+
+    p_box->data.p_co64->chunk_offset =
+        calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
+    if( p_box->data.p_co64->chunk_offset == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
+    {
+        if( p_box->i_type == ATOM_stco )
+        {
+            if( i_read < 4 )
+            {
+                break;
+            }
+            MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
+        }
+        else
+        {
+            if( i_read < 8 )
+            {
+                break;
+            }
+            MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
+        }
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"co64\" entry-count %d",
+            p_box->data.p_co64->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stco_co64( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_co64->chunk_offset );
+}
+
+static int MP4_ReadBox_stss( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stss_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stss );
+
+    MP4_GET4BYTES( p_box->data.p_stss->entry_count );
+
+    p_box->data.p_stss->sample_number =
+        calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
+    if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
+    {
+
+        MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
+        /* XXX in libmp4 sample begin at 0 */
+        p_box->data.p_stss->sample_number[i]--;
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stss\" entry-count %d",
+            p_box->data.p_stss->i_entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stss( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stss->sample_number );
+}
+
+static void MP4_FreeBox_stsh( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsh->shadowed_sample_number );
+    FREENULL( p_box->data.p_stsh->sync_sample_number );
+}
+
+static int MP4_ReadBox_stsh( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsh_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
+
+
+    MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
+
+    p_box->data.p_stsh->shadowed_sample_number =
+        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsh->sync_sample_number =
+        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+
+    if( p_box->data.p_stsh->shadowed_sample_number == NULL
+            || p_box->data.p_stsh->sync_sample_number == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
+        MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsh\" entry-count %d",
+            p_box->data.p_stsh->i_entry_count );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stdp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stdp_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
+
+    p_box->data.p_stdp->priority =
+        calloc( i_read / 2, sizeof(uint16_t) );
+
+    if( unlikely( !p_box->data.p_stdp->priority ) )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < i_read / 2 ; i++ )
+    {
+        MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+            i_read / 2 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stdp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stdp->priority );
+}
+
+static void MP4_FreeBox_padb( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_padb->reserved1 );
+    FREENULL( p_box->data.p_padb->pad2 );
+    FREENULL( p_box->data.p_padb->reserved2 );
+    FREENULL( p_box->data.p_padb->pad1 );
+}
+
+static int MP4_ReadBox_padb( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t count;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_padb_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_padb );
+
+    MP4_GET4BYTES( p_box->data.p_padb->sample_count );
+    count = (p_box->data.p_padb->sample_count + 1) / 2;
+
+    p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
+    if( p_box->data.p_padb->reserved1 == NULL
+            || p_box->data.p_padb->pad2 == NULL
+            || p_box->data.p_padb->reserved2 == NULL
+            || p_box->data.p_padb->pad1 == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; i < i_read / 2 ; i++ )
+    {
+        if( i >= count )
+        {
+            MP4_READBOX_EXIT( 0 );
+        }
+        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
+        p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
+        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
+        p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
+
+        p_peek += 1; i_read -= 1;
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+            i_read / 2 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_elst( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_elst->segment_duration );
+    FREENULL( p_box->data.p_elst->media_time );
+    FREENULL( p_box->data.p_elst->media_rate_integer );
+    FREENULL( p_box->data.p_elst->media_rate_fraction );
+}
+
+static int MP4_ReadBox_elst( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_elst_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_elst );
+
+
+    MP4_GET4BYTES( p_box->data.p_elst->entry_count );
+
+    p_box->data.p_elst->segment_duration =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+    p_box->data.p_elst->media_time =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+    p_box->data.p_elst->media_rate_integer =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+    p_box->data.p_elst->media_rate_fraction =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+    if( p_box->data.p_elst->segment_duration == NULL
+            || p_box->data.p_elst->media_time == NULL
+            || p_box->data.p_elst->media_rate_integer == NULL
+            || p_box->data.p_elst->media_rate_fraction == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+
+    for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
+    {
+        if( p_box->data.p_elst->version == 1 )
+        {
+
+            MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
+
+            MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
+        }
+        else
+        {
+
+            MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
+
+            MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
+            p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
+        }
+
+        MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
+        MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"elst\" entry-count %lu",
+            (unsigned long)p_box->data.p_elst->entry_count );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i_language;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_cprt_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
+
+    i_language = SwapBE16( p_peek );
+    for( i = 0; i < 3; i++ )
+    {
+        p_box->data.p_cprt->language[i] =
+            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+    }
+    p_peek += 2; i_read -= 2;
+    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cprt\" language %c%c%c notice %s",
+            p_box->data.p_cprt->language[0],
+            p_box->data.p_cprt->language[1],
+            p_box->data.p_cprt->language[2],
+            p_box->data.p_cprt->psz_notice );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_cprt( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_cprt->psz_notice );
+}
+
+
+static int MP4_ReadBox_dcom( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_dcom_t );
+
+    MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"dcom\" compression algorithm : %4.4s",
+            (char*)&p_box->data.p_dcom->algorithm );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cmvd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
+
+    MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
+
+    p_box->data.p_cmvd->compressed_size = i_read;
+
+    if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
+        MP4_READBOX_EXIT( 0 );
+
+    /* now copy compressed data */
+    memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
+
+    p_box->data.p_cmvd->b_compressed = 1;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmvd\" compressed data size %d",
+            p_box->data.p_cmvd->compressed_size );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_cmvd( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_cmvd->data );
+}
+
+
+static int MP4_ReadBox_cmov( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t *p_dcom;
+    mp4_box_t *p_cmvd;
+
+#ifdef HAVE_ZLIB_H
+    stream_t *p_stream_memory;
+    z_stream z_data;
+    uint8_t *p_data;
+    int i_result;
+#endif
+
+    if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
+        return 0;
+
+    if( !p_box->p_father ||
+            ( p_box->p_father->i_type != ATOM_moov &&
+              p_box->p_father->i_type != ATOM_foov ) )
+    {
+        printf( "Read box: \"cmov\" box alone" );
+        return 1;
+    }
+
+    if( !MP4_ReadBoxContainer( p_stream, p_box ) )
+    {
+        return 0;
+    }
+
+    if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
+            ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
+            p_cmvd->data.p_cmvd->data == NULL )
+    {
+        printf( "read box: \"cmov\" incomplete" );
+        return 0;
+    }
+
+    if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
+    {
+        printf( "read box: \"cmov\" compression algorithm : %4.4s "
+                "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
+        return 0;
+    }
+
+#ifndef HAVE_ZLIB_H
+    printf(  "read box: \"cmov\" zlib unsupported" );
+    return 0;
+#else
+
+    /* decompress data */
+    /* allocate a new buffer */
+    if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
+        return 0;
+    /* init default structures */
+    z_data.next_in   = p_cmvd->data.p_cmvd->data;
+    z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
+    z_data.next_out  = p_data;
+    z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
+    z_data.zalloc    = (alloc_func)Z_NULL;
+    z_data.zfree     = (free_func)Z_NULL;
+    z_data.opaque    = (voidpf)Z_NULL;
+
+    /* init zlib */
+    if( inflateInit( &z_data ) != Z_OK )
+    {
+        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+        free( p_data );
+        return 0;
+    }
+
+    /* uncompress */
+    i_result = inflate( &z_data, Z_NO_FLUSH );
+    if( i_result != Z_OK && i_result != Z_STREAM_END )
+    {
+        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+        free( p_data );
+        return 0;
+    }
+
+    if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
+    {
+        printf( "read box: \"cmov\" uncompressing data size "
+                "mismatch" );
+    }
+    p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
+
+    /* close zlib */
+    if( inflateEnd( &z_data ) != Z_OK )
+    {
+        printf( "read box: \"cmov\" error while uncompressing "
+                "data (ignored)" );
+    }
+
+    free( p_cmvd->data.p_cmvd->p_data );
+    p_cmvd->data.p_cmvd->data = p_data;
+    p_cmvd->data.p_cmvd->b_compressed = 0;
+
+    printf( "read box: \"cmov\" box successfully uncompressed" );
+
+    /* now create a memory stream */
+    p_stream_memory =
+        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
+                p_cmvd->data.p_cmvd->uncompressed_size, true );
+
+    /* and read uncompressd moov */
+    p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
+
+    stream_Delete( p_stream_memory );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmov\" compressed movie header completed");
+#endif
+
+    return p_box->data.p_cmov->moov ? 1 : 0;
+#endif /* HAVE_ZLIB_H */
+}
+
+static int MP4_ReadBox_rdrf( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_len;
+    unsigned i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
+    MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
+    MP4_GET4BYTES( i_len );
+    i_len++;
+
+    if( i_len > 0 )
+    {
+        p_box->data.p_rdrf->psz_ref = malloc( i_len );
+        if( p_box->data.p_rdrf->psz_ref == NULL )
+            MP4_READBOX_EXIT( 0 );
+        i_len--;
+
+        for( i = 0; i < i_len; i++ )
+        {
+            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
+        }
+        p_box->data.p_rdrf->psz_ref[i_len] = '\0';
+    }
+    else
+    {
+        p_box->data.p_rdrf->psz_ref = NULL;
+    }
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rdrf\" type:%4.4s ref %s",
+            (char*)&p_box->data.p_rdrf->ref_type,
+            p_box->data.p_rdrf->psz_ref );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_rdrf( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_rdrf->psz_ref );
+}
+
+
+static int MP4_ReadBox_rmdr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
+
+    MP4_GET4BYTES( p_box->data.p_rmdr->rate );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmdr\" rate:%d",
+            p_box->data.p_rmdr->rate );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmqu( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
+
+    MP4_GET4BYTES( p_box->data.p_rmqu->quality );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmqu\" quality:%d",
+            p_box->data.p_rmqu->quality );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmvc( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
+
+    MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
+    MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
+    MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
+    MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
+            (char*)&p_box->data.p_rmvc->gestaltType,
+            p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
+            p_box->data.p_rmvc->checkType );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_frma( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_frma_t );
+
+    MP4_GETFOURCC( p_box->data.p_frma->type );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"frma\" i_type:%4.4s",
+            (char *)&p_box->data.p_frma->i_type );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_skcr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_skcr_t );
+
+    MP4_GET4BYTES( p_box->data.p_skcr->init );
+    MP4_GET4BYTES( p_box->data.p_skcr->encr );
+    MP4_GET4BYTES( p_box->data.p_skcr->decr );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"skcr\" i_init:%d i_encr:%d i_decr:%d",
+            p_box->data.p_skcr->init,
+            p_box->data.p_skcr->encr,
+            p_box->data.p_skcr->decr );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_drms( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t *p_drms_box = p_box;
+    void *p_drms = NULL;
+
+    MP4_READBOX_ENTER( uint8_t );
+
+    do
+    {
+        p_drms_box = p_drms_box->p_father;
+    } while( p_drms_box && p_drms_box->i_type != ATOM_drms
+            && p_drms_box->i_type != ATOM_drmi );
+
+    if( p_drms_box && p_drms_box->i_type == ATOM_drms )
+        p_drms = p_drms_box->data.p_sample_soun->drms;
+    else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
+        p_drms = p_drms_box->data.p_sample_vide->drms;
+
+    if( p_drms_box && p_drms )
+    {
+        int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
+        if( i_ret )
+        {
+            assert(0);
+            //             const char *psz_error;
+            // 
+            //             switch( i_ret )
+            //             {
+            //                 case -1: psz_error = "unimplemented"; break;
+            //                 case -2: psz_error = "invalid argument"; break;
+            //                 case -3: psz_error = "could not get system key"; break;
+            //                 case -4: psz_error = "could not get SCI data"; break;
+            //                 case -5: psz_error = "no user key found in SCI data"; break;
+            //                 case -6: psz_error = "invalid user key"; break;
+            //                 default: psz_error = "unknown error"; break;
+            //             }
+            //             if MP4_BOX_TYPE_ASCII()
+            //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
+            //                         (char *)&p_box->i_type, psz_error );
+            //             else
+            //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
+            //                         (char *)&p_box->i_type+1, psz_error );
+            // 
+            //             drms_free( p_drms );
+            // 
+            //             if( p_drms_box->i_type == ATOM_drms )
+            //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
+            //             else if( p_drms_box->i_type == ATOM_drmi )
+            //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
+        }
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_name( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_name_t );
+
+    p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
+    if( p_box->data.p_name->psz_text == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
+    p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"name\" text=`%s'",
+            p_box->data.p_name->psz_text );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_name( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_name->psz_text );
+}
+
+static int MP4_ReadBox_0xa9xxx( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint16_t i16;
+
+    MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
+
+    p_box->data.p_0xa9xxx->psz_text = NULL;
+
+    MP4_GET2BYTES( i16 );
+
+    if( i16 > 0 )
+    {
+        int i_length = i16;
+
+        MP4_GET2BYTES( i16 );
+        if( i_length >= i_read ) i_length = i_read + 1;
+
+        p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
+        if( p_box->data.p_0xa9xxx->psz_text == NULL )
+            MP4_READBOX_EXIT( 0 );
+
+        i_length--;
+        memcpy( p_box->data.p_0xa9xxx->psz_text,
+                p_peek, i_length );
+        p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
+
+#ifdef MP4_VERBOSE
+        printf(
+                "read box: \"c%3.3s\" text=`%s'",
+                ((char*)&p_box->i_type + 1),
+                p_box->data.p_0xa9xxx->psz_text );
+#endif
+    }
+    else
+    {
+        uint32_t i_data_len;
+        uint32_t i_data_tag;
+        /* try iTune/Quicktime format, rewind to start */
+        p_peek -= 2; i_read += 2;
+        // we are expecting a 'data' box
+
+        MP4_GET4BYTES( i_data_len );
+        if( i_data_len > i_read ) i_data_len = i_read;
+        MP4_GETFOURCC( i_data_tag );
+        if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
+        {
+            /* data box contains a version/flags field */
+            uint32_t i_version;
+            uint32_t i_reserved;
+            MP4_GET4BYTES( i_version );
+            MP4_GET4BYTES( i_reserved );
+            // version should be 0, flags should be 1 for text, 0 for data
+            if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
+            {
+                // the rest is the text
+                i_data_len -= 12;
+                p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
+                if( p_box->data.p_0xa9xxx->psz_text == NULL )
+                    MP4_READBOX_EXIT( 0 );
+
+                memcpy( p_box->data.p_0xa9xxx->psz_text,
+                        p_peek, i_data_len );
+                p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
+#ifdef MP4_VERBOSE
+                printf(
+                        "read box: \"c%3.3s\" text=`%s'",
+                        ((char*)&p_box->i_type+1),
+                        p_box->data.p_0xa9xxx->psz_text );
+#endif
+            }
+            else
+            {
+                // TODO: handle data values for ID3 tag values, track num or cover art,etc...
+            }
+        }
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_0xa9xxx( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_0xa9xxx->psz_text );
+}
+
+/* Chapter support */
+static void MP4_FreeBox_chpl( mp4_box_t *p_box )
+{
+    mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
+    unsigned int i;
+    for(  i = 0; i < p_chpl->chapter; i++ )
+        free( p_chpl->p_chapter[i].psz_name );
+}
+
+static int MP4_ReadBox_chpl( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_chpl_t *p_chpl;
+    uint32_t i_dummy;
+    int i;
+    MP4_READBOX_ENTER( mp4_box_data_chpl_t );
+
+    p_chpl = p_box->data.p_chpl;
+
+    MP4_GETVERSIONFLAGS( p_chpl );
+
+    MP4_GET4BYTES( i_dummy );
+
+    MP4_GET1BYTE( p_chpl->chapter );
+
+    for( i = 0; i < p_chpl->chapter; i++ )
+    {
+        uint64_t i_start;
+        uint8_t i_len;
+        int i_copy;
+        MP4_GET8BYTES( i_start );
+        MP4_GET1BYTE( i_len );
+
+        p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
+        if( !p_chpl->p_chapter[i].psz_name )
+            MP4_READBOX_EXIT( 0 );
+
+        i_copy = min( i_len, i_read );
+        if( i_copy > 0 )
+            memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
+        p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
+        p_chpl->p_chapter[i].start = i_start;
+
+        p_peek += i_copy;
+        i_read -= i_copy;
+    }
+    /* Bubble sort by increasing start date */
+    do
+    {
+        for( i = 0; i < p_chpl->chapter - 1; i++ )
+        {
+            if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
+            {
+                char *psz = p_chpl->p_chapter[i+1].psz_name;
+                int64_t i64 = p_chpl->p_chapter[i+1].start;
+
+                p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
+                p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
+
+                p_chpl->p_chapter[i].psz_name = psz;
+                p_chpl->p_chapter[i].start = i64;
+
+                i = -1;
+                break;
+            }
+        }
+    } while( i == -1 );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chpl\" %d chapters",
+            p_chpl->chapter );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tref_generic( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
+
+    p_box->data.p_tref_generic->track_ID = NULL;
+    p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
+    if( p_box->data.p_tref_generic->entry_count > 0 )
+        p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
+    if( p_box->data.p_tref_generic->track_ID == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chap\" %d references",
+            p_box->data.p_tref_generic->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_tref_generic( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_tref_generic->track_ID );
+}
+
+static int MP4_ReadBox_meta( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint8_t meta_data[8];
+    int i_actually_read;
+
+    // skip over box header
+    i_actually_read = stream_read( p_stream, meta_data, 8 );
+    if( i_actually_read < 8 )
+        return 0;
+
+    /* meta content starts with a 4 byte version/flags value (should be 0) */
+    i_actually_read = stream_read( p_stream, meta_data, 4 );
+    if( i_actually_read < 4 )
+        return 0;
+
+    /* then it behaves like a container */
+    return MP4_ReadBoxContainerRaw( p_stream, p_box );
+}
+
+static int MP4_ReadBox_iods( stream_t *p_stream, mp4_box_t *p_box )
+{
+    char i_unused;
+
+    MP4_READBOX_ENTER( mp4_box_data_iods_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_iods );
+
+    MP4_GET1BYTE( i_unused ); /* tag */
+    MP4_GET1BYTE( i_unused ); /* length */
+
+    MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
+                                                               are used for other flags */
+    MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
+            "visual: %i, graphics: %i",
+            p_box->data.p_iods->object_descriptor >> 6,
+            p_box->data.p_iods->OD_profile_level,
+            p_box->data.p_iods->scene_profile_level,
+            p_box->data.p_iods->audio_profile_level,
+            p_box->data.p_iods->visual_profile_level,
+            p_box->data.p_iods->graphics_profile_level );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_pasp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_pasp_t );
+
+    MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
+    MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"paps\" %dx%d",
+            p_box->data.p_pasp->horizontal_spacing,
+            p_box->data.p_pasp->vertical_spacing);
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mehd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mehd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
+    if( p_box->data.p_mehd->version == 1 )
+        MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
+    else /* version == 0 */
+        MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"mehd\" frag dur. %"PRIu64"",
+            p_box->data.p_mehd->fragment_duration );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trex( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_trex_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_trex );
+
+    MP4_GET4BYTES( p_box->data.p_trex->track_ID );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
+
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"trex\" trackID: %"PRIu32"",
+    //              p_box->data.p_trex->track_ID );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sdtp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_sample_count;
+    uint32_t i;
+    mp4_box_data_sdtp_t *p_sdtp = NULL;
+    MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
+    p_sdtp = p_box->data.p_sdtp;
+    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
+    i_sample_count = i_read;
+
+    p_sdtp->sample_table = calloc( i_sample_count, 1 );
+
+    if( !p_sdtp->sample_table )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < i_sample_count; i++ )
+        MP4_GET1BYTE( p_sdtp->sample_table[i] );
+
+    // #ifdef MP4_VERBOSE
+    //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
+    //      printf(
+    //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
+    //                  p_sdtp->sample_table[0],
+    //                  p_sdtp->sample_table[1],
+    //                  p_sdtp->sample_table[2],
+    //                  p_sdtp->sample_table[3] );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_sdtp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sdtp->sample_table );
+}
+
+static int MP4_ReadBox_mfro( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mfro_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
+    MP4_GET4BYTES( p_box->data.p_mfro->size );
+
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"mfro\" size: %"PRIu32"",
+    //              p_box->data.p_mfro->i_size);
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfra( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_number_of_entries;
+    mp4_box_data_tfra_t *p_tfra;
+    uint32_t i_lengths;
+    size_t size;
+    uint32_t i;
+    MP4_READBOX_ENTER( mp4_box_data_tfra_t );
+    p_tfra = p_box->data.p_tfra;
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
+
+    MP4_GET4BYTES( p_tfra->track_ID );
+    i_lengths = 0;
+    MP4_GET4BYTES( i_lengths );
+    MP4_GET4BYTES( p_tfra->number_of_entries );
+    i_number_of_entries = p_tfra->number_of_entries;
+    p_tfra->length_size_of_traf_num = i_lengths >> 4;
+    p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
+    p_tfra->length_size_of_sample_num = i_lengths & 0x03;
+
+    size = 4 + 4*p_tfra->version; /* size in {4, 8} */
+    p_tfra->time = calloc( i_number_of_entries, size );
+    p_tfra->moof_offset = calloc( i_number_of_entries, size );
+
+    size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
+    p_tfra->traf_number = calloc( i_number_of_entries, size );
+    size = 1 + p_tfra->length_size_of_trun_num;
+    p_tfra->trun_number = calloc( i_number_of_entries, size );
+    size = 1 + p_tfra->length_size_of_sample_num;
+    p_tfra->sample_number = calloc( i_number_of_entries, size );
+
+    if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
+            || !p_tfra->trun_number || !p_tfra->sample_number )
+        goto error;
+
+    for( i = 0; i < i_number_of_entries; i++ )
+    {
+        if( p_tfra->version == 1 )
+        {
+            MP4_GET8BYTES( p_tfra->time[i*2] );
+            MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
+        }
+        else
+        {
+            MP4_GET4BYTES( p_tfra->time[i] );
+            MP4_GET4BYTES( p_tfra->moof_offset[i] );
+        }
+        switch (p_tfra->length_size_of_traf_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->traf_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->traf_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->traf_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->traf_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+
+        switch (p_tfra->length_size_of_trun_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->trun_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->trun_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->trun_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->trun_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+
+        switch (p_tfra->length_size_of_sample_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->sample_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->sample_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->sample_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->sample_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+    }
+
+    // #ifdef MP4_VERBOSE
+    //     if( p_tfra->version == 0 )
+    //     {
+    //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
+    //                          p_tfra->time[0], p_tfra->moof_offset[0] );
+    // 
+    //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
+    //                          p_tfra->time[1], p_tfra->moof_offset[1] );
+    //     }
+    //     else
+    //     {
+    //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
+    //                 ((uint64_t *)(p_tfra->time))[0],
+    //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
+    // 
+    //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
+    //                 ((uint64_t *)(p_tfra->time))[1],
+    //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
+    //     }
+    // 
+    //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
+    //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+error:
+    MP4_READBOX_EXIT( 0 );
+}
+
+static void MP4_FreeBox_tfra( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_tfra->time );
+    FREENULL( p_box->data.p_tfra->moof_offset );
+    FREENULL( p_box->data.p_tfra->traf_number );
+    FREENULL( p_box->data.p_tfra->trun_number );
+    FREENULL( p_box->data.p_tfra->sample_number );
+}
+
+
+/* For generic */
+static int MP4_ReadBox_default( stream_t *p_stream, mp4_box_t *p_box )
+{
+    if( !p_box->p_father )
+    {
+        goto unknown;
+    }
+    if( p_box->p_father->i_type == ATOM_stsd )
+    {
+        mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
+        mp4_box_t *p_hdlr;
+
+        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
+                (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
+        {
+            goto unknown;
+        }
+        switch( p_hdlr->data.p_hdlr->handler_type )
+        {
+            case ATOM_soun:
+                return MP4_ReadBox_sample_soun( p_stream, p_box );
+            case ATOM_vide:
+                return MP4_ReadBox_sample_vide( p_stream, p_box );
+            case ATOM_text:
+                return MP4_ReadBox_sample_text( p_stream, p_box );
+            case ATOM_mmth:
+                return MP4_ReadBox_sample_mmth( p_stream, p_box );
+            case ATOM_tx3g:
+            case ATOM_sbtl:
+                return MP4_ReadBox_sample_tx3g( p_stream, p_box );
+            default:
+                printf(
+                        "unknown handler type in stsd (incompletely loaded1)" );
+                return 1;
+        }
+    }
+
+unknown:
+    if MP4_BOX_TYPE_ASCII()
+        printf(
+                "unknown box type %4.4s (incompletely loaded2)",
+                (char*)&p_box->i_type );
+    else
+        printf(
+                "unknown box type c%3.3s (incompletely loaded3)",
+                (char*)&p_box->i_type+1 );
+
+    return 1;
+}
+
+static const struct
+{
+    uint32_t i_type;
+    int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
+    void (*MP4_FreeBox_function )( mp4_box_t *p_box );
+} MP4_Box_Function [] =
+{
+    /* Containers */
+    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+
+    /* specific box */
+    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
+    { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
+    { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
+    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
+    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
+    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
+    { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
+    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
+    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
+    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
+    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
+    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
+    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
+    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
+    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
+    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
+    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
+    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
+    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
+    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
+    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
+    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
+    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
+    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
+    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
+    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
+    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
+    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
+    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
+    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
+    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
+    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
+    { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
+    { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
+    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
+    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
+
+    /* Nothing to do with this box */
+    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+
+    /* for codecs */
+    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+
+    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
+    { ATOM_mjht,    MP4_ReadBox_default,      NULL },
+
+    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
+
+    /* XXX there is 2 box where we could find this entry stbl and tref*/
+    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
+    { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
+
+    /* found in tref box */
+    { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
+    { ATOM_ipir,    MP4_ReadBox_default,      NULL },
+    { ATOM_mpod,    MP4_ReadBox_default,      NULL },
+    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
+
+    /* found in hnti */
+    { ATOM_rtp,     MP4_ReadBox_default,      NULL },
+
+    /* found in rmra */
+    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
+    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
+    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
+    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
+
+    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
+    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
+
+    /* found in udta */
+    { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+
+    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
+
+    /* iTunes/Quicktime meta info */
+    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
+    { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
+
+    /* found in smoothstreaming */
+    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
+    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
+    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
+    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
+    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
+    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
+    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
+    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
+
+    /* Last entry */
+    { 0,              MP4_ReadBox_default,      NULL }
+};
+
+
+//get full struct of the mp4,main function
+mp4_box_t *MP4_BoxGetRoot(stream_t * s)
+{
+    mp4_box_t *p_root;
+    stream_t *p_stream;
+    int i_result;
+
+    p_root = malloc( sizeof( mp4_box_t ) );
+    if( p_root == NULL )
+        return NULL;
+
+    p_root->i_pos = 0;
+    p_root->i_type = ATOM_root;
+    p_root->i_shortsize = 1;
+
+    stream_seek(s, 0, SEEK_END);
+    p_root->i_size = stream_tell(s);
+    stream_seek(s, 0, SEEK_SET);
+
+    CreateUUID( &p_root->i_uuid, p_root->i_type );
+
+    //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
+    p_root->data.p_data = NULL;
+    p_root->p_father    = NULL;
+    p_root->p_first     = NULL;
+    p_root->p_last      = NULL;
+    p_root->p_next      = NULL;
+
+    p_stream = s;
+
+    i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
+
+    if( i_result )
+    {
+        mp4_box_t *p_moov;
+        mp4_box_t *p_cmov;
+
+        /* check if there is a cmov, if so replace
+           compressed moov by  uncompressed one */
+        if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
+                    ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
+                ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
+                  ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
+        {
+            /* rename the compressed moov as a box to skip */
+            p_moov->i_type = ATOM_skip;
+
+            /* get uncompressed p_moov */
+            p_moov = p_cmov->data.p_cmov->moov;
+            p_cmov->data.p_cmov->moov = NULL;
+
+            /* make p_root father of this new moov */
+            p_moov->p_father = p_root;
+
+            /* insert this new moov box as first child of p_root */
+            p_moov->p_next = p_root->p_first;
+            p_root->p_first = p_moov;
+        }
+    }
+
+    return p_root;
+}
+
+//after  get full struct of the mp4,you can use this function to get the special box
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
+{
+    //mp4_box_t *cur = p_head, *prev = NULL;
+    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+                return(cur); /**/
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    return(cur); /**/
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    return(cur); /**/
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+    return(NULL);
+}
+
+void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type)
+{
+    mp4_box_t *cur = p_head, *prev = NULL;
+    //mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    //mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+
+                //*search_box=cur;
+                free(cur);
+                free(prev);
+                break;
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    //*search_box=cur;
+                    free(cur);
+                    free(prev);
+                    break;
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    //*search_box=cur;
+                    free(cur);
+                    free(prev);
+                    break;
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+
+}
+
+//after  get full struct of the mp4,you can use this function to get the special box
+int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type)
+{
+    //mp4_box_t *cur = p_head, *prev = NULL;
+    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+                printf("1\n");
+                //return(1); /**/
+                //					return(cur); /**/
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    printf("2\n");
+                    //              		return(2); /**/
+                    //						return(cur); /**/
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    printf("3\n");
+                    //              	return(3); /**/
+                    //						return(cur); /**/
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+    printf("aa0\n");
+    //    return(0);
+}
+/*****************************************************************************
+ * MP4_ReadBox : parse the actual box and the children
+ *  XXX : Do not go to the next box
+ *****************************************************************************/
+static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
+{
+    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    unsigned int i_index;
+
+    if( p_box == NULL )
+        return NULL;
+
+    if( !MP4_ReadBoxCommon( p_stream, p_box ) )
+    {
+        printf( "cannot read one box" );
+        free( p_box );
+        return NULL;
+    }
+    if( !p_box->i_size )
+    {
+        printf( "found an empty box (null size)" );
+        free( p_box );
+        return NULL;
+    }
+    p_box->p_father = p_father;
+
+    /* Now search function to call */
+    for( i_index = 0; ; i_index++ )
+    {
+        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+                ( MP4_Box_Function[i_index].i_type == 0 ) )
+        {
+            break;
+        }
+    }
+
+    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
+    {
+        MP4_BoxFree( p_stream, p_box );
+        return NULL;
+    }
+
+    return p_box;
+}
+
+void MP4_BoxFree( stream_t *s, mp4_box_t *p_box )
+{
+    unsigned int i_index;
+    mp4_box_t    *p_child;
+
+    if( !p_box )
+        return; /* hehe */
+
+    for( p_child = p_box->p_first; p_child != NULL; )
+    {
+        mp4_box_t *p_next;
+
+        p_next = p_child->p_next;
+        MP4_BoxFree( s, p_child );
+        p_child = p_next;
+    }
+
+    /* Now search function to call */
+    if( p_box->data.p_data )
+    {
+        for( i_index = 0; ; i_index++ )
+        {
+            if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+                    ( MP4_Box_Function[i_index].i_type == 0 ) )
+            {
+                break;
+            }
+        }
+        if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
+        {
+            /* Should not happen */
+            if MP4_BOX_TYPE_ASCII()
+                printf(
+                        "cannot free box %4.4s, type unknown",
+                        (char*)&p_box->i_type );
+            else
+                printf(
+                        "cannot free box c%3.3s, type unknown",
+                        (char*)&p_box->i_type+1 );
+        }
+        else
+        {
+            MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
+        }
+        free( p_box->data.p_data );
+    }
+    free( p_box );
+}
+
+/*****************************************************************************
+ *****************************************************************************
+ **
+ **  High level methods to acces an MP4 file
+ **
+ *****************************************************************************
+ *****************************************************************************/
+static void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )
+{
+    size_t i_len ;
+    if( !*ppsz_path[0] )
+    {
+        *ppsz_token = NULL;
+        *pi_number = 0;
+        return;
+    }
+    i_len = strcspn( *ppsz_path, "/[" );
+    if( !i_len && **ppsz_path == '/' )
+    {
+        i_len = 1;
+    }
+    *ppsz_token = malloc( i_len + 1 );
+
+    memcpy( *ppsz_token, *ppsz_path, i_len );
+
+    (*ppsz_token)[i_len] = '\0';
+
+    *ppsz_path += i_len;
+
+    if( **ppsz_path == '[' )
+    {
+        (*ppsz_path)++;
+        *pi_number = strtol( *ppsz_path, NULL, 10 );
+        while( **ppsz_path && **ppsz_path != ']' )
+        {
+            (*ppsz_path)++;
+        }
+        if( **ppsz_path == ']' )
+        {
+            (*ppsz_path)++;
+        }
+    }
+    else
+    {
+        *pi_number = 0;
+    }
+    while( **ppsz_path == '/' )
+    {
+        (*ppsz_path)++;
+    }
+}
+
+static void MP4_BoxGet_Internal(mp4_box_t **pp_result,
+        mp4_box_t *p_box, const char *psz_fmt, va_list args)
+{
+    char *psz_dup;
+    char *psz_path = malloc(4096);
+    char *psz_token;
+
+    if( !p_box )
+    {
+        *pp_result = NULL;
+        return;
+    }
+
+    if( vsprintf( psz_path, psz_fmt, args ) == -1 )
+        psz_path = NULL;
+
+    if( !psz_path || !psz_path[0] )
+    {
+        free( psz_path );
+        *pp_result = NULL;
+        return;
+    }
+
+    //    fprintf( stderr, "path:'%s'\n", psz_path );
+    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
+    for( ; ; )
+    {
+        int i_number;
+
+        get_token( &psz_path, &psz_token, &i_number );
+        //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
+        //                 psz_path,psz_token,i_number );
+        if( !psz_token )
+        {
+            free( psz_dup );
+            *pp_result = p_box;
+            return;
+        }
+        else
+            if( !strcmp( psz_token, "/" ) )
+            {
+                /* Find root box */
+                while( p_box && p_box->i_type != ATOM_root )
+                {
+                    p_box = p_box->p_father;
+                }
+                if( !p_box )
+                {
+                    goto error_box;
+                }
+            }
+            else
+                if( !strcmp( psz_token, "." ) )
+                {
+                    /* Do nothing */
+                }
+                else
+                    if( !strcmp( psz_token, ".." ) )
+                    {
+                        p_box = p_box->p_father;
+                        if( !p_box )
+                        {
+                            goto error_box;
+                        }
+                    }
+                    else
+                        if( strlen( psz_token ) == 4 )
+                        {
+                            uint32_t i_fourcc;
+                            i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
+                                    psz_token[2], psz_token[3] );
+                            p_box = p_box->p_first;
+                            for( ; ; )
+                            {
+                                if( !p_box )
+                                {
+                                    goto error_box;
+                                }
+                                if( p_box->i_type == i_fourcc )
+                                {
+                                    if( !i_number )
+                                    {
+                                        break;
+                                    }
+                                    i_number--;
+                                }
+                                p_box = p_box->p_next;
+                            }
+                        }
+                        else
+                            if( *psz_token == '\0' )
+                            {
+                                p_box = p_box->p_first;
+                                for( ; ; )
+                                {
+                                    if( !p_box )
+                                    {
+                                        goto error_box;
+                                    }
+                                    if( !i_number )
+                                    {
+                                        break;
+                                    }
+                                    i_number--;
+                                    p_box = p_box->p_next;
+                                }
+                            }
+                            else
+                            {
+                                //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
+                                goto error_box;
+                            }
+
+        FREENULL( psz_token );
+    }
+
+    return;
+
+error_box:
+    free( psz_token );
+    free( psz_dup );
+    *pp_result = NULL;
+    return;
+}
+
+mp4_box_t * MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...)
+{
+    va_list args;
+    mp4_box_t *p_result;
+
+    va_start( args, psz_fmt );
+    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
+    va_end( args );
+
+    return( p_result );
+}
+
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
new file mode 100644
index 0000000..1d045dd
--- /dev/null
+++ b/net/mmt/mpu/mp4.h
@@ -0,0 +1,1218 @@
+#ifndef NET_MMT_MPU_MP4_H_
+#define NET_MMT_MPU_MP4_H_
+
+#include "net/mmt/mpu/stream.h"
+
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_tfdt MP4_FOURCC( 't', 'f', 'd', 't' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_foov MP4_FOURCC( 'f', 'o', 'o', 'v' )
+#define ATOM_cmov MP4_FOURCC( 'c', 'm', 'o', 'v' )
+#define ATOM_dcom MP4_FOURCC( 'd', 'c', 'o', 'm' )
+#define ATOM_cmvd MP4_FOURCC( 'c', 'm', 'v', 'd' )
+
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+#define ATOM_skip MP4_FOURCC( 's', 'k', 'i', 'p' )
+#define ATOM_free MP4_FOURCC( 'f', 'r', 'e', 'e' )
+#define ATOM_udta MP4_FOURCC( 'u', 'd', 't', 'a' )
+#define ATOM_wide MP4_FOURCC( 'w', 'i', 'd', 'e' )
+
+#define ATOM_data MP4_FOURCC( 'd', 'a', 't', 'a' )
+
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mvhd MP4_FOURCC( 'm', 'v', 'h', 'd' )
+#define ATOM_tkhd MP4_FOURCC( 't', 'k', 'h', 'd' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_tref MP4_FOURCC( 't', 'r', 'e', 'f' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_mdhd MP4_FOURCC( 'm', 'd', 'h', 'd' )
+#define ATOM_hdlr MP4_FOURCC( 'h', 'd', 'l', 'r' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_vmhd MP4_FOURCC( 'v', 'm', 'h', 'd' )
+#define ATOM_smhd MP4_FOURCC( 's', 'm', 'h', 'd' )
+#define ATOM_hmhd MP4_FOURCC( 'h', 'm', 'h', 'd' )
+#define ATOM_dinf MP4_FOURCC( 'd', 'i', 'n', 'f' )
+#define ATOM_url  MP4_FOURCC( 'u', 'r', 'l', ' ' )
+#define ATOM_urn  MP4_FOURCC( 'u', 'r', 'n', ' ' )
+#define ATOM_dref MP4_FOURCC( 'd', 'r', 'e', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stts MP4_FOURCC( 's', 't', 't', 's' )
+#define ATOM_ctts MP4_FOURCC( 'c', 't', 't', 's' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_stsz MP4_FOURCC( 's', 't', 's', 'z' )
+#define ATOM_stz2 MP4_FOURCC( 's', 't', 'z', '2' )
+#define ATOM_stsc MP4_FOURCC( 's', 't', 's', 'c' )
+#define ATOM_stco MP4_FOURCC( 's', 't', 'c', 'o' )
+#define ATOM_co64 MP4_FOURCC( 'c', 'o', '6', '4' )
+#define ATOM_stss MP4_FOURCC( 's', 't', 's', 's' )
+#define ATOM_stsh MP4_FOURCC( 's', 't', 's', 'h' )
+#define ATOM_stdp MP4_FOURCC( 's', 't', 'd', 'p' )
+#define ATOM_padb MP4_FOURCC( 'p', 'a', 'd', 'b' )
+#define ATOM_edts MP4_FOURCC( 'e', 'd', 't', 's' )
+#define ATOM_elst MP4_FOURCC( 'e', 'l', 's', 't' )
+#define ATOM_mvex MP4_FOURCC( 'm', 'v', 'e', 'x' )
+#define ATOM_sdtp MP4_FOURCC( 's', 'd', 't', 'p' )
+#define ATOM_trex MP4_FOURCC( 't', 'r', 'e', 'x' )
+#define ATOM_mehd MP4_FOURCC( 'm', 'e', 'h', 'd' )
+#define ATOM_mfhd MP4_FOURCC( 'm', 'f', 'h', 'd' )
+#define ATOM_traf MP4_FOURCC( 't', 'r', 'a', 'f' )
+#define ATOM_tfhd MP4_FOURCC( 't', 'f', 'h', 'd' )
+#define ATOM_trun MP4_FOURCC( 't', 'r', 'u', 'n' )
+#define ATOM_cprt MP4_FOURCC( 'c', 'p', 'r', 't' )
+#define ATOM_iods MP4_FOURCC( 'i', 'o', 'd', 's' )
+#define ATOM_pasp MP4_FOURCC( 'p', 'a', 's', 'p' )
+#define ATOM_mfra MP4_FOURCC( 'm', 'f', 'r', 'a' )
+#define ATOM_mfro MP4_FOURCC( 'm', 'f', 'r', 'o' )
+#define ATOM_tfra MP4_FOURCC( 't', 'f', 'r', 'a' )
+
+#define ATOM_nmhd MP4_FOURCC( 'n', 'm', 'h', 'd' )
+#define ATOM_mp2v MP4_FOURCC( 'm', 'p', '2', 'v' )
+#define ATOM_mp4v MP4_FOURCC( 'm', 'p', '4', 'v' )
+#define ATOM_mp4a MP4_FOURCC( 'm', 'p', '4', 'a' )
+#define ATOM_mp4s MP4_FOURCC( 'm', 'p', '4', 's' )
+#define ATOM_vide MP4_FOURCC( 'v', 'i', 'd', 'e' )
+#define ATOM_soun MP4_FOURCC( 's', 'o', 'u', 'n' )
+#define ATOM_mmth MP4_FOURCC( 'm', 'm', 't', 'h' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_hdv2 MP4_FOURCC( 'h', 'd', 'v', '2' )
+
+#define ATOM_dpnd MP4_FOURCC( 'd', 'p', 'n', 'd' )
+#define ATOM_ipir MP4_FOURCC( 'i', 'p', 'i', 'r' )
+#define ATOM_mpod MP4_FOURCC( 'm', 'p', 'o', 'd' )
+#define ATOM_hnti MP4_FOURCC( 'h', 'n', 't', 'i' )
+#define ATOM_rtp  MP4_FOURCC( 'r', 't', 'p', ' ' )
+
+#define ATOM_isom MP4_FOURCC( 'i', 's', 'o', 'm' )
+#define ATOM_3gp4 MP4_FOURCC( '3', 'g', 'p', '4' )
+#define ATOM_esds MP4_FOURCC( 'e', 's', 'd', 's' )
+
+#define ATOM__mp3 MP4_FOURCC( '.', 'm', 'p', '3' )
+#define ATOM_ms02 MP4_FOURCC( 'm', 's', 0x0, 0x02 )
+#define ATOM_ms11 MP4_FOURCC( 'm', 's', 0x0, 0x11 )
+#define ATOM_ms55 MP4_FOURCC( 'm', 's', 0x0, 0x55 )
+#define ATOM_twos MP4_FOURCC( 't', 'w', 'o', 's' )
+#define ATOM_sowt MP4_FOURCC( 's', 'o', 'w', 't' )
+#define ATOM_QDMC MP4_FOURCC( 'Q', 'D', 'M', 'C' )
+#define ATOM_QDM2 MP4_FOURCC( 'Q', 'D', 'M', '2' )
+#define ATOM_ima4 MP4_FOURCC( 'i', 'm', 'a', '4' )
+#define ATOM_IMA4 MP4_FOURCC( 'I', 'M', 'A', '4' )
+#define ATOM_dvi  MP4_FOURCC( 'd', 'v', 'i', ' ' )
+#define ATOM_MAC3 MP4_FOURCC( 'M', 'A', 'C', '3' )
+#define ATOM_MAC6 MP4_FOURCC( 'M', 'A', 'C', '6' )
+#define ATOM_alaw MP4_FOURCC( 'a', 'l', 'a', 'w' )
+#define ATOM_ulaw MP4_FOURCC( 'u', 'l', 'a', 'w' )
+#define ATOM_Qclp MP4_FOURCC( 'Q', 'c', 'l', 'p' )
+#define ATOM_samr MP4_FOURCC( 's', 'a', 'm', 'r' )
+#define ATOM_sawb MP4_FOURCC( 's', 'a', 'w', 'b' )
+#define ATOM_OggS MP4_FOURCC( 'O', 'g', 'g', 'S' )
+#define ATOM_alac MP4_FOURCC( 'a', 'l', 'a', 'c' )
+#define ATOM_dac3 MP4_FOURCC( 'd', 'a', 'c', '3' )
+#define ATOM_dec3 MP4_FOURCC( 'd', 'e', 'c', '3' )
+#define ATOM_enda MP4_FOURCC( 'e', 'n', 'd', 'a' )
+#define ATOM_gnre MP4_FOURCC( 'g', 'n', 'r', 'e' )
+#define ATOM_trkn MP4_FOURCC( 't', 'r', 'k', 'n' )
+
+#define ATOM_zlib MP4_FOURCC( 'z', 'l', 'i', 'b' )
+#define ATOM_SVQ1 MP4_FOURCC( 'S', 'V', 'Q', '1' )
+#define ATOM_SVQ3 MP4_FOURCC( 'S', 'V', 'Q', '3' )
+#define ATOM_ZyGo MP4_FOURCC( 'Z', 'y', 'G', 'o' )
+#define ATOM_3IV1 MP4_FOURCC( '3', 'I', 'V', '1' )
+#define ATOM_3iv1 MP4_FOURCC( '3', 'i', 'v', '1' )
+#define ATOM_3IV2 MP4_FOURCC( '3', 'I', 'V', '2' )
+#define ATOM_3iv2 MP4_FOURCC( '3', 'i', 'v', '2' )
+#define ATOM_3IVD MP4_FOURCC( '3', 'I', 'V', 'D' )
+#define ATOM_3ivd MP4_FOURCC( '3', 'i', 'v', 'd' )
+#define ATOM_3VID MP4_FOURCC( '3', 'V', 'I', 'D' )
+#define ATOM_3vid MP4_FOURCC( '3', 'v', 'i', 'd' )
+#define ATOM_h263 MP4_FOURCC( 'h', '2', '6', '3' )
+#define ATOM_s263 MP4_FOURCC( 's', '2', '6', '3' )
+#define ATOM_DIVX MP4_FOURCC( 'D', 'I', 'V', 'X' )
+#define ATOM_XVID MP4_FOURCC( 'X', 'V', 'I', 'D' )
+#define ATOM_cvid MP4_FOURCC( 'c', 'v', 'i', 'd' )
+#define ATOM_mjpa MP4_FOURCC( 'm', 'j', 'p', 'a' )
+#define ATOM_mjpb MP4_FOURCC( 'm', 'j', 'q', 't' )
+#define ATOM_mjqt MP4_FOURCC( 'm', 'j', 'h', 't' )
+#define ATOM_mjht MP4_FOURCC( 'm', 'j', 'p', 'b' )
+#define ATOM_VP31 MP4_FOURCC( 'V', 'P', '3', '1' )
+#define ATOM_vp31 MP4_FOURCC( 'v', 'p', '3', '1' )
+#define ATOM_h264 MP4_FOURCC( 'h', '2', '6', '4' )
+#define ATOM_qdrw MP4_FOURCC( 'q', 'd', 'r', 'w' )
+
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+#define ATOM_m4ds MP4_FOURCC( 'm', '4', 'd', 's' )
+
+#define ATOM_dvc  MP4_FOURCC( 'd', 'v', 'c', ' ' )
+#define ATOM_dvp  MP4_FOURCC( 'd', 'v', 'p', ' ' )
+#define ATOM_dv5n MP4_FOURCC( 'd', 'v', '5', 'n' )
+#define ATOM_dv5p MP4_FOURCC( 'd', 'v', '5', 'p' )
+#define ATOM_raw  MP4_FOURCC( 'r', 'a', 'w', ' ' )
+
+#define ATOM_jpeg MP4_FOURCC( 'j', 'p', 'e', 'g' )
+
+#define ATOM_yv12 MP4_FOURCC( 'y', 'v', '1', '2' )
+#define ATOM_yuv2 MP4_FOURCC( 'y', 'u', 'v', '2' )
+
+#define ATOM_rmra MP4_FOURCC( 'r', 'm', 'r', 'a' )
+#define ATOM_rmda MP4_FOURCC( 'r', 'm', 'd', 'a' )
+#define ATOM_rdrf MP4_FOURCC( 'r', 'd', 'r', 'f' )
+#define ATOM_rmdr MP4_FOURCC( 'r', 'm', 'd', 'r' )
+#define ATOM_rmvc MP4_FOURCC( 'r', 'm', 'v', 'c' )
+#define ATOM_rmcd MP4_FOURCC( 'r', 'm', 'c', 'd' )
+#define ATOM_rmqu MP4_FOURCC( 'r', 'm', 'q', 'u' )
+#define ATOM_alis MP4_FOURCC( 'a', 'l', 'i', 's' )
+
+#define ATOM_gmhd MP4_FOURCC( 'g', 'm', 'h', 'd' )
+#define ATOM_wave MP4_FOURCC( 'w', 'a', 'v', 'e' )
+
+#define ATOM_drms MP4_FOURCC( 'd', 'r', 'm', 's' )
+#define ATOM_sinf MP4_FOURCC( 's', 'i', 'n', 'f' )
+#define ATOM_schi MP4_FOURCC( 's', 'c', 'h', 'i' )
+#define ATOM_user MP4_FOURCC( 'u', 's', 'e', 'r' )
+#define ATOM_key  MP4_FOURCC( 'k', 'e', 'y', ' ' )
+#define ATOM_iviv MP4_FOURCC( 'i', 'v', 'i', 'v' )
+#define ATOM_name MP4_FOURCC( 'n', 'a', 'm', 'e' )
+#define ATOM_priv MP4_FOURCC( 'p', 'r', 'i', 'v' )
+#define ATOM_drmi MP4_FOURCC( 'd', 'r', 'm', 'i' )
+#define ATOM_frma MP4_FOURCC( 'f', 'r', 'm', 'a' )
+#define ATOM_skcr MP4_FOURCC( 's', 'k', 'c', 'r' )
+
+#define ATOM_text MP4_FOURCC( 't', 'e', 'x', 't' )
+#define ATOM_tx3g MP4_FOURCC( 't', 'x', '3', 'g' )
+#define ATOM_subp MP4_FOURCC( 's', 'u', 'b', 'p' )
+#define ATOM_sbtl MP4_FOURCC( 's', 'b', 't', 'l' )
+
+#define ATOM_0xa9nam MP4_FOURCC( 0xa9, 'n', 'a', 'm' )
+#define ATOM_0xa9aut MP4_FOURCC( 0xa9, 'a', 'u', 't' )
+#define ATOM_0xa9cpy MP4_FOURCC( 0xa9, 'c', 'p', 'y' )
+#define ATOM_0xa9inf MP4_FOURCC( 0xa9, 'i', 'n', 'f' )
+#define ATOM_0xa9ART MP4_FOURCC( 0xa9, 'A', 'R', 'T' )
+#define ATOM_0xa9des MP4_FOURCC( 0xa9, 'd', 'e', 's' )
+#define ATOM_0xa9dir MP4_FOURCC( 0xa9, 'd', 'i', 'r' )
+#define ATOM_0xa9cmt MP4_FOURCC( 0xa9, 'c', 'm', 't' )
+#define ATOM_0xa9req MP4_FOURCC( 0xa9, 'r', 'e', 'q' )
+#define ATOM_0xa9day MP4_FOURCC( 0xa9, 'd', 'a', 'y' )
+#define ATOM_0xa9fmt MP4_FOURCC( 0xa9, 'f', 'm', 't' )
+#define ATOM_0xa9prd MP4_FOURCC( 0xa9, 'p', 'r', 'd' )
+#define ATOM_0xa9prf MP4_FOURCC( 0xa9, 'p', 'r', 'f' )
+#define ATOM_0xa9src MP4_FOURCC( 0xa9, 's', 'r', 'c' )
+#define ATOM_0xa9alb MP4_FOURCC( 0xa9, 'a', 'l', 'b' )
+#define ATOM_0xa9dis MP4_FOURCC( 0xa9, 'd', 'i', 's' )
+#define ATOM_0xa9enc MP4_FOURCC( 0xa9, 'e', 'n', 'c' )
+#define ATOM_0xa9trk MP4_FOURCC( 0xa9, 't', 'r', 'k' )
+#define ATOM_0xa9url MP4_FOURCC( 0xa9, 'u', 'r', 'l' )
+#define ATOM_0xa9dsa MP4_FOURCC( 0xa9, 'd', 's', 'a' )
+#define ATOM_0xa9hst MP4_FOURCC( 0xa9, 'h', 's', 't' )
+#define ATOM_0xa9ope MP4_FOURCC( 0xa9, 'o', 'p', 'e' )
+#define ATOM_0xa9wrt MP4_FOURCC( 0xa9, 'w', 'r', 't' )
+#define ATOM_0xa9com MP4_FOURCC( 0xa9, 'c', 'o', 'm' )
+#define ATOM_0xa9gen MP4_FOURCC( 0xa9, 'g', 'e', 'n' )
+#define ATOM_0xa9too MP4_FOURCC( 0xa9, 't', 'o', 'o' )
+#define ATOM_0xa9wrn MP4_FOURCC( 0xa9, 'w', 'r', 'n' )
+#define ATOM_0xa9swr MP4_FOURCC( 0xa9, 's', 'w', 'r' )
+#define ATOM_0xa9mak MP4_FOURCC( 0xa9, 'm', 'a', 'k' )
+#define ATOM_0xa9mod MP4_FOURCC( 0xa9, 'm', 'o', 'd' )
+#define ATOM_0xa9PRD MP4_FOURCC( 0xa9, 'P', 'R', 'D' )
+#define ATOM_0xa9grp MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_0xa9lyr MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_chpl MP4_FOURCC( 'c', 'h', 'p', 'l' )
+#define ATOM_WLOC MP4_FOURCC( 'W', 'L', 'O', 'C' )
+
+#define ATOM_meta MP4_FOURCC( 'm', 'e', 't', 'a' )
+#define ATOM_ilst MP4_FOURCC( 'i', 'l', 's', 't' )
+
+#define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
+
+
+
+typedef struct uuid_s
+{
+   uint8_t b[16];
+} uuid_t;
+
+/* specific structure for all boxes */
+typedef struct mp4_box_data_ftyp_s
+{
+   uint32_t major_brand;
+   uint32_t minor_version;
+
+   uint32_t compatible_brands_count;
+   uint32_t *compatible_brands;
+
+} mp4_box_data_ftyp_t;
+
+typedef struct mp4_box_data_mmpu_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint8_t  is_complete;
+	uint8_t  reserved;
+   uint32_t mpu_sequence_number;
+   uint32_t asset_id_scheme;
+   uint32_t asset_id_length;
+   char *asset_id_value;
+
+} mp4_box_data_mmpu_t;
+
+typedef struct mp4_box_data_tfdt_s
+{
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+
+} mp4_box_data_tfdt_t;
+
+typedef struct mp4_box_data_mvhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+
+} mp4_box_data_mvhd_t;
+
+#define MP4_TRACK_ENABLED    0x000001
+#define MP4_TRACK_IN_MOVIE   0x000002
+#define MP4_TRACK_IN_PREVIEW 0x000004
+
+typedef struct mp4_box_data_tkhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t track_id;
+   uint32_t reserved;
+   uint64_t duration;
+
+   uint32_t reserved2[2];
+   int16_t  layer;
+   int16_t  predefined;
+
+   int16_t  volume;
+   uint16_t reserved3;
+   int32_t  matrix[9];
+   int32_t  width;
+   int32_t  height;
+
+} mp4_box_data_tkhd_t;
+
+typedef struct mp4_box_data_hint_s
+{
+
+	uint32_t track_IDs;
+
+} mp4_box_data_hint_t;
+
+typedef struct mp4_box_data_mdhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   /* one bit for pad */
+   uint16_t language_code;
+   /* unsigned int(5)[3] language difference with 0x60*/
+   unsigned char language[3];
+   uint16_t predefined;
+
+} mp4_box_data_mdhd_t;
+
+typedef struct mp4_box_data_hdlr_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t predefined;
+    uint32_t handler_type; /* "vide" "soun" "hint" "odsm" "crsm" "sdsm" "m7sm" "ocsm" "ipsm" "mjsm" */
+
+    unsigned char *psz_name; /* in UTF-8 */
+
+} mp4_box_data_hdlr_t;
+
+typedef struct mp4_box_data_vmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  graphics_mode;
+   int16_t  opcolor[3];
+
+} mp4_box_data_vmhd_t;
+
+typedef struct mp4_box_data_smhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  balance;
+   int16_t  reserved;
+
+} mp4_box_data_smhd_t;
+
+typedef struct mp4_box_data_hmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t max_PDU_size;
+   uint16_t avg_PDU_size;
+   uint32_t max_bitrate;
+   uint32_t avg_bitrate;
+   uint32_t reserved;
+
+} mp4_box_data_hmhd_t;
+
+typedef struct mp4_box_data_url_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   char *psz_location;
+
+} mp4_box_data_url_t;
+
+typedef struct mp4_box_data_urn_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    char *psz_name;
+    char *psz_location;
+
+} mp4_box_data_urn_t;
+
+typedef struct mp4_box_data_dref_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_dref_t;
+
+typedef struct mp4_box_data_stts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_delta;
+
+} mp4_box_data_stts_t;
+
+typedef struct mp4_box_data_ctts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_offset;
+
+} mp4_box_data_ctts_t;
+
+
+typedef struct mp4_box_data_sample_soun_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    //uint32_t reserved2[2];
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint16_t channelcount;
+    uint16_t samplesize;
+    uint16_t predefined;
+    uint16_t reserved3;
+    uint16_t sampleratehi; /* timescale of track */
+    uint16_t sampleratelo;
+
+    /* for version 1 (reserved1[0] == 1) */
+    uint32_t sample_per_packet;
+    uint32_t bytes_per_packet;
+    uint32_t bytes_per_frame;
+    uint32_t bytes_per_sample;
+
+    /* XXX hack */
+    int     qt_description;
+    uint8_t *p_qt_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_soun_t;
+
+typedef struct mp4_box_data_sample_vide_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint32_t qt_temporal_quality;
+    uint32_t qt_spatial_quality;
+
+    int16_t  width;
+    int16_t  height;
+
+    uint32_t horizresolution;
+    uint32_t vertresolution;
+
+    uint32_t qt_data_size;
+    uint16_t qt_frame_count;
+
+    uint8_t  compressorname[32];
+    int16_t  depth;
+
+    int16_t  qt_color_table;
+
+    /* XXX hack ImageDescription */
+    int     qt_image_description;
+    uint8_t *p_qt_image_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_vide_t;
+
+typedef struct mp4_box_data_sample_mmth_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t hinttrackversion;
+    uint16_t highestcompatibleversion;
+    uint16_t packet_id;
+    uint8_t has_mfus_flag;
+    uint8_t is_timed;
+    uint8_t reserved;
+    /*uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;*/
+
+} mp4_box_data_sample_mmth_t;
+
+typedef struct mp4_box_data_mmthsample_s
+{
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t moviefragmentsequencenumber;
+	uint32_t samplenumber;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+	uint16_t item_ID;
+
+} mp4_box_data_mmthsample_t;
+
+typedef struct mp4_box_data_muli_s
+{
+	uint8_t multilayer_flag:1;
+	uint8_t reserved0:7;
+	uint8_t dependency_id:3;
+	uint8_t depth_flag:1;
+	uint8_t reserved1:4;
+	uint8_t temporal_id:3;
+	uint8_t reserved2:1;
+	uint8_t quality_id:4;
+	uint8_t priority_id:6;
+	uint16_t view_id:10;
+
+	uint8_t layer_id:6;
+	//uint8_t temporal_id:3;
+	uint8_t reserved3:7;
+
+} mp4_box_data_muli_t;
+
+
+
+#define MP4_TEXT_DISPLAY_FLAG_DONT_DISPLAY       (1<<0)
+#define MP4_TEXT_DISPLAY_FLAG_AUTO_SCALE         (1<<1)
+#define MP4_TEXT_DISPLAY_FLAG_CLIP_TO_TEXT_BOX   (1<<2)
+#define MP4_TEXT_DISPLAY_FLAG_USE_MOVIE_BG_COLOR (1<<3)
+#define MP4_TEXT_DISPLAY_FLAG_SHRINK_TEXT_BOX_TO_FIT (1<<4)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_IN          (1<<5)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_OUT         (1<<6)
+#define MP4_TEXT_DISPLAY_FLAG_HORIZONTAL_SCROLL  (1<<7)
+#define MP4_TEXT_DISPLAY_FLAG_REVERSE_SCROLL     (1<<8)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_SCROLL  (1<<9)
+#define MP4_TEXT_DISPLAY_FLAG_FLOW_HORIZONTAL    (1<<10)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_KARAOKE (1<<11)
+#define MP4_TEXT_DISPLAY_FLAG_DROP_SHADOW        (1<<12)
+#define MP4_TEXT_DISPLAY_FLAG_ANTI_ALIAS         (1<<13)
+#define MP4_TEXT_DISPLAY_FLAG_KEYED_TEXT         (1<<14)
+#define MP4_TEXT_DISPLAY_FLAG_INVERSE_HILITE     (1<<15)
+#define MP4_TEXT_DISPLAY_FLAG_COLOR_HILITE       (1<<16)
+#define MP4_TEXT_DISPLAY_FLAG_WRITE_VERTICALLY   (1<<17)
+
+typedef struct
+{
+    uint32_t reserved1;
+    uint16_t reserved2;
+
+    uint16_t data_reference_index;
+
+    uint32_t display_flags;   // TextDescription and Tx3gDescription
+
+    int8_t justification_horizontal; // left(0), centered(1), right(-1)
+    int8_t justification_vertical;   // top(0), centered(1), bottom(-1)
+
+    uint16_t background_color[4];
+
+    uint16_t text_box_top;
+    uint16_t text_box_left;
+    uint16_t text_box_bottom;
+    uint16_t text_box_right;
+
+    // TODO to complete
+} mp4_box_data_sample_text_t;
+
+typedef struct mp4_box_data_sample_hint_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint8_t *data;
+
+} mp4_box_data_sample_hint_t;
+
+typedef struct mp4_box_data_moviehintinformation_rtp_s
+{
+    uint32_t description_format;
+    unsigned char *psz_text;
+
+} mp4_box_data_moviehintinformation_rtp_t;
+
+
+
+typedef struct mp4_box_data_stsd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    /* it contains SampleEntry handled as if it was Box */
+
+} mp4_box_data_stsd_t;
+
+
+typedef struct mp4_box_data_stsz_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array , empty if sample_size != 0 */
+
+} mp4_box_data_stsz_t;
+
+typedef struct mp4_box_data_stz2_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size; /* 24 bits */
+    uint8_t  field_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array: unsigned int(field_size) entry_size */
+
+} mp4_box_data_stz2_t;
+
+typedef struct mp4_box_data_stsc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *first_chunk; /* theses are arrays */
+    uint32_t *samples_per_chunk;
+    uint32_t *sample_description_index;
+
+} mp4_box_data_stsc_t;
+
+
+typedef struct mp4_box_data_co64_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *chunk_offset;
+
+} mp4_box_data_co64_t;
+
+
+typedef struct mp4_box_data_stss_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_number;
+
+} mp4_box_data_stss_t;
+
+typedef struct mp4_box_data_stsh_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *shadowed_sample_number;
+    uint32_t *sync_sample_number;
+
+} mp4_box_data_stsh_t;
+
+typedef struct mp4_box_data_stdp_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint16_t *priority;
+
+} mp4_box_data_stdp_t;
+
+typedef struct mp4_box_data_padb_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_count;
+
+    uint16_t *reserved1;   /* 1bit  */
+    uint16_t *pad2;        /* 3bits */
+    uint16_t *reserved2;   /* 1bit  */
+    uint16_t *pad1;        /* 3bits */
+
+
+} mp4_box_data_padb_t;
+
+
+typedef struct mp4_box_data_elst_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *segment_duration;
+    int64_t  *media_time;
+    uint16_t *media_rate_integer;
+    uint16_t *media_rate_fraction;
+
+
+} mp4_box_data_elst_t;
+
+typedef struct mp4_box_data_cprt_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    /* 1 pad bit */
+    unsigned char language[3];
+
+    char *psz_notice;
+} mp4_box_data_cprt_t;
+
+
+/* DecoderConfigDescriptor */
+typedef struct mp4_descriptor_decoder_config_s
+{
+    uint8_t objectTypeIndication;
+    uint8_t streamType;
+    int     b_upStream;
+    int     buffer_sizeDB;
+    int     max_bitrate;
+    int     avg_bitrate;
+
+    int     decoder_specific_info_len;
+    uint8_t *decoder_specific_info;
+    /* some other stuff */
+
+} mp4_descriptor_decoder_config_t;
+
+typedef struct mp4_descriptor_SL_config_s
+{
+
+    int dummy; /* ANSI C forbids empty structures */
+
+} mp4_descriptor_SL_config_t;
+
+
+typedef struct mp4_descriptor_ES_s
+{
+    uint16_t ES_ID;
+    int      b_stream_dependence;
+    int      b_url;
+    int      b_OCRstream;
+    int      stream_priority;
+
+    int      depend_on_ES_ID; /* if b_stream_dependence set */
+
+    unsigned char *psz_URL;
+
+    uint16_t OCR_ES_ID;       /* if b_OCRstream */
+    mp4_descriptor_decoder_config_t *decConfigDescr;
+
+    mp4_descriptor_SL_config_t *slConfigDescr;
+
+    /* some other stuff ... */
+
+} mp4_descriptor_ES_t;
+
+/* ES descriptor */
+typedef struct mp4_box_data_esds_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    mp4_descriptor_ES_t es_descriptor;
+
+} mp4_box_data_esds_t;
+
+
+typedef struct mp4_box_data_dcom_s
+{
+    uint32_t algorithm; /* fourcc */
+
+} mp4_box_data_dcom_t;
+
+typedef struct mp4_box_data_cmvd_s
+{
+    uint32_t uncompressed_size;
+    uint32_t compressed_size;
+
+    int     b_compressed; /* Set to 1 if compressed data, 0 if uncompressed */
+    uint8_t *data;
+
+} mp4_box_data_cmvd_t;
+
+typedef struct mp4_box_data_cmov_s
+{
+    struct mp4_box_s *moov; /* uncompressed moov */
+
+} mp4_box_data_cmov_t;
+
+typedef struct
+{
+    uint32_t type;
+} mp4_box_data_frma_t;
+
+typedef struct
+{
+    uint32_t init;
+    uint32_t encr;
+    uint32_t decr;
+} mp4_box_data_skcr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t ref_type;
+    char     *psz_ref;
+
+} mp4_box_data_rdrf_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t rate;
+
+} mp4_box_data_rmdr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t gestaltType;
+    uint32_t val1;
+    uint32_t val2;
+    uint16_t checkType;   /* 0: val1 is version min
+                               1: gestalt value & val2 == val1 */
+
+} mp4_box_data_rmvc_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+
+} mp4_box_data_rmcd_t;
+
+typedef struct
+{
+    uint32_t quality;
+
+} mp4_box_data_rmqu_t;
+
+typedef struct mp4_box_data_mfhd_s
+{
+    uint32_t sequence_number;
+
+    uint8_t *vendor_extension;
+
+} mp4_box_data_mfhd_t;
+
+#define MP4_TFHD_BASE_DATA_OFFSET     (1LL<<0)
+#define MP4_TFHD_SAMPLE_DESC_INDEX    (1LL<<1)
+#define MP4_TFHD_DFLT_SAMPLE_DURATION (1LL<<3)
+#define MP4_TFHD_DFLT_SAMPLE_SIZE     (1LL<<4)
+#define MP4_TFHD_DFLT_SAMPLE_FLAGS    (1LL<<5)
+typedef struct mp4_box_data_tfhd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t track_ID;
+
+    /* optional fields */
+    uint64_t base_data_offset;
+    uint32_t sample_description_index;
+    uint32_t default_sample_duration;
+    uint32_t default_sample_size;
+    uint32_t default_sample_flags;
+
+} mp4_box_data_tfhd_t;
+
+#define MP4_TRUN_DATA_OFFSET         (1<<0)
+#define MP4_TRUN_FIRST_FLAGS         (1<<2)
+#define MP4_TRUN_SAMPLE_DURATION     (1<<8)
+#define MP4_TRUN_SAMPLE_SIZE         (1<<9)
+#define MP4_TRUN_SAMPLE_FLAGS        (1<<10)
+#define MP4_TRUN_SAMPLE_TIME_OFFSET  (1<<11)
+typedef struct mp4_descriptor_trun_sample_t
+{
+    uint32_t duration;
+    uint32_t size;
+    uint32_t flags;
+    uint32_t composition_time_offset;
+} mp4_descriptor_trun_sample_t;
+
+typedef struct mp4_box_data_trun_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t sample_count;
+
+    /* optional fields */
+    uint32_t data_offset;
+    uint32_t first_sample_flags;
+
+    mp4_descriptor_trun_sample_t *samples;
+
+} mp4_box_data_trun_t;
+
+
+
+typedef struct mp4_box_data_0xa9xxx_s
+{
+   char *psz_text;
+
+} mp4_box_data_0xa9xxx_t;
+
+typedef struct mp4_box_data_name_s
+{
+   char *psz_text;
+
+} mp4_box_data_name_t;
+
+typedef struct mp4_box_data_tref_generic_s
+{
+   uint32_t entry_count;
+   uint32_t *track_ID;
+
+} mp4_box_data_tref_generic_t;
+
+typedef struct mp4_box_data_chpl_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t chapter;
+   struct
+   {
+      char    *psz_name;
+      int64_t  start;
+   } p_chapter[256];
+} mp4_box_data_chpl_t;
+
+typedef struct mp4_box_data_avcC_s
+{
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+
+} mp4_box_data_avcC_t;
+
+typedef struct mp4_box_data_dac3_s
+{
+   uint8_t fscod;
+   uint8_t bsid;
+   uint8_t bsmod;
+   uint8_t acmod;
+   uint8_t lfeon;
+   uint8_t bitrate_code;
+
+} mp4_box_data_dac3_t;
+
+typedef struct mp4_box_data_enda_s
+{
+   uint16_t little_endian;
+
+} mp4_box_data_enda_t;
+
+typedef struct mp4_box_data_gnre_s
+{
+   uint16_t genre;
+
+} mp4_box_data_gnre_t;
+
+typedef struct mp4_box_data_trkn_s
+{
+   uint32_t track_number;
+   uint32_t track_total;
+
+} mp4_box_data_trkn_t;
+
+typedef struct mp4_box_data_iods_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t object_descriptor;
+   uint8_t OD_profile_level;
+   uint8_t scene_profile_level;
+   uint8_t audio_profile_level;
+   uint8_t visual_profile_level;
+   uint8_t graphics_profile_level;
+
+} mp4_box_data_iods_t;
+
+typedef struct mp4_box_data_pasp_s
+{
+   uint32_t horizontal_spacing;
+   uint32_t vertical_spacing;
+} mp4_box_data_pasp_t;
+
+typedef struct mp4_box_data_mehd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t fragment_duration;
+} mp4_box_data_mehd_t;
+
+typedef struct mp4_box_data_trex_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t default_sample_description_index;
+   uint32_t default_sample_duration;
+   uint32_t default_sample_size;
+   uint32_t default_sample_flags;
+} mp4_box_data_trex_t;
+
+typedef struct mp4_box_data_sdtp_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t *sample_table;
+} mp4_box_data_sdtp_t;
+
+typedef struct mp4_box_data_mfro_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t size;
+} mp4_box_data_mfro_t;
+
+typedef struct mp4_box_data_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} mp4_box_data_tfra_t;
+
+typedef union mp4_box_data_s
+{
+   mp4_box_data_ftyp_t *p_ftyp;
+   mp4_box_data_mmpu_t *p_mmpu;
+   mp4_box_data_tfdt_t *p_tfdt;
+   mp4_box_data_mvhd_t *p_mvhd;
+   mp4_box_data_mfhd_t *p_mfhd;
+   mp4_box_data_tfhd_t *p_tfhd;
+   mp4_box_data_trun_t *p_trun;
+   mp4_box_data_tkhd_t *p_tkhd;
+   mp4_box_data_hint_t *p_hint;
+   mp4_box_data_mdhd_t *p_mdhd;
+   mp4_box_data_hdlr_t *p_hdlr;
+   mp4_box_data_vmhd_t *p_vmhd;
+   mp4_box_data_smhd_t *p_smhd;
+   mp4_box_data_hmhd_t *p_hmhd;
+   mp4_box_data_url_t  *p_url;
+   mp4_box_data_urn_t  *p_urn;
+   mp4_box_data_dref_t *p_dref;
+   mp4_box_data_stts_t *p_stts;
+   mp4_box_data_ctts_t *p_ctts;
+   mp4_box_data_stsd_t *p_stsd;
+   mp4_box_data_sample_vide_t *p_sample_vide;
+   mp4_box_data_sample_soun_t *p_sample_soun;
+   mp4_box_data_sample_text_t *p_sample_text;
+   mp4_box_data_sample_hint_t *p_sample_hint;
+   mp4_box_data_sample_mmth_t *p_sample_mmth;
+
+   mp4_box_data_esds_t *p_esds;
+   mp4_box_data_avcC_t *p_avcC;
+   mp4_box_data_dac3_t *p_dac3;
+   mp4_box_data_enda_t *p_enda;
+   mp4_box_data_gnre_t *p_gnre;
+   mp4_box_data_trkn_t *p_trkn;
+   mp4_box_data_iods_t *p_iods;
+   mp4_box_data_pasp_t *p_pasp;
+   mp4_box_data_trex_t *p_trex;
+   mp4_box_data_mehd_t *p_mehd;
+   mp4_box_data_sdtp_t *p_sdtp;
+
+   mp4_box_data_tfra_t *p_tfra;
+   mp4_box_data_mfro_t *p_mfro;
+
+   mp4_box_data_stsz_t *p_stsz;
+   mp4_box_data_stz2_t *p_stz2;
+   mp4_box_data_stsc_t *p_stsc;
+   mp4_box_data_co64_t *p_co64;
+   mp4_box_data_stss_t *p_stss;
+   mp4_box_data_stsh_t *p_stsh;
+   mp4_box_data_stdp_t *p_stdp;
+   mp4_box_data_padb_t *p_padb;
+   mp4_box_data_elst_t *p_elst;
+   mp4_box_data_cprt_t *p_cprt;
+
+   mp4_box_data_dcom_t *p_dcom;
+   mp4_box_data_cmvd_t *p_cmvd;
+   mp4_box_data_cmov_t *p_cmov;
+
+   mp4_box_data_moviehintinformation_rtp_t p_moviehintinformation_rtp;
+
+   mp4_box_data_frma_t *p_frma;
+   mp4_box_data_skcr_t *p_skcr;
+
+   mp4_box_data_rdrf_t *p_rdrf;
+   mp4_box_data_rmdr_t *p_rmdr;
+   mp4_box_data_rmqu_t *p_rmqu;
+   mp4_box_data_rmvc_t *p_rmvc;
+
+   mp4_box_data_0xa9xxx_t *p_0xa9xxx;
+   mp4_box_data_chpl_t *p_chpl;
+   mp4_box_data_tref_generic_t *p_tref_generic;
+   mp4_box_data_name_t *p_name;
+   void *p_data;
+} mp4_box_data_t;
+
+typedef struct mp4_box_s
+{
+   int64_t i_pos;
+   uint32_t i_type;
+   uint32_t i_shortsize;
+   uuid_t i_uuid;
+   uint64_t i_size;
+   mp4_box_data_t data;
+   struct mp4_box_s* p_father;
+   struct mp4_box_s* p_first;
+   struct mp4_box_s* p_last;
+   struct mp4_box_s* p_next;
+} mp4_box_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+mp4_box_t *MP4_BoxGetRoot(stream_t * s);
+void MP4_BoxFree(stream_t * s, mp4_box_t *box);
+static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
+mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
+void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type);
+int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NET_MMT_MPU_MP4_H_
diff --git a/net/mmt/mpu/mpu.gyp b/net/mmt/mpu/mpu.gyp
new file mode 100644
index 0000000..8f5acf2
--- /dev/null
+++ b/net/mmt/mpu/mpu.gyp
@@ -0,0 +1,85 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmpu',
+      'type': '<(component)',
+      'product_name': 'libmpu',  # Don't conflict with OpenSSL's libssl
+      'sources': [
+        'stream.c',
+        'mp4.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
new file mode 100644
index 0000000..f512657
--- /dev/null
+++ b/net/mmt/mpu/stream.c
@@ -0,0 +1,390 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include "net/mmt/mpu/stream.h"
+
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+
+void* file_open(stream_t *stream_s, const char* filename, int mode)
+{
+   FILE* file = NULL;
+   const char* mode_fopen = NULL;
+   if ((mode & MODE_READWRITEFILTER) == MODE_READ)
+      mode_fopen = "rb";
+   else
+      if (mode & MODE_EXISTING)
+         mode_fopen = "r+b";
+      else
+         if (mode & MODE_CREATE)
+            mode_fopen = "wb";
+   if ((filename != NULL) && (mode_fopen != NULL))
+      file = fopen(filename, mode_fopen);
+   stream_s->opaque = (void*)file;
+
+   return file;
+}
+
+int file_read(stream_t *stream_s, void* buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fread(buf, 1, size, file);
+}
+
+int file_write(stream_t *stream_s, void *buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fwrite(buf, 1, size, file);
+}
+
+int file_peek(stream_t *stream_s, void* buf, int size)
+{
+   uint32_t offset = file_tell(stream_s);
+   int ret = file_read(stream_s, buf, size);
+   file_seek(stream_s, offset, SEEK_SET);
+   return ret;
+}
+
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fseek(file, offset, whence);
+}
+
+uint64_t file_tell(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return ftell(file);
+}
+
+int file_close(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fclose(file);
+}
+
+stream_t* create_file_stream()
+{
+   stream_t* s = malloc(sizeof(stream_t));
+   s->open = file_open;
+   s->read = file_read;
+   s->write = file_write;
+   s->peek = file_peek;
+   s->seek = file_seek;
+   s->tell = file_tell;
+   s->close = file_close;
+   return s;
+}
+
+void destory_file_stream(stream_t* stream_s)
+{
+   free(stream_s);
+}
+
+stream_t* create_buf_file_stream()
+{
+   buf_stream_t* s = malloc(sizeof(buf_stream_t));
+   stream_t* file_s = create_file_stream();
+   s->s = *file_s;
+   destory_file_stream(file_s);
+   s->s.read = buf_file_read;
+   s->s.write = buf_file_write;
+   s->s.peek = buf_file_peek;
+   s->s.seek = buf_file_seek;
+   s->s.close = buf_file_close;
+   s->read_buf_s.buf = malloc(READ_BUFFER_SIZE);
+   s->read_buf_s.bufsize = -1;
+   s->read_buf_s.offset = 0;
+   s->write_buf_s.buf = malloc(WRITE_BUFFER_SIZE);
+   s->write_buf_s.bufsize = 0;
+   s->write_buf_s.offset = 0;
+   s->offset = 0;
+   return (stream_t*)s;
+}
+
+void destory_buf_file_stream(stream_t* stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   free(s->read_buf_s.buf);
+   free(s->write_buf_s.buf);
+   free(stream_s);
+}
+
+int buf_file_read(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int length = 0, remainder = 0, position = 0;
+
+   while (size > 0)
+   {
+      int read_bytes = 0;
+      if (s->read_buf_s.offset > s->offset || 
+         s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset ||
+         s->read_buf_s.bufsize == -1)
+      {
+         int read_bytes, ret;
+         // offset, .
+         ret = file_seek(stream_s, s->offset, SEEK_SET);
+         if (ret != 0)
+         {
+            assert(0);
+            return ret;       // ERROR!!!
+         }
+         read_bytes = file_read(stream_s, s->read_buf_s.buf, READ_BUFFER_SIZE);
+         if (read_bytes < 0)
+            return read_bytes; // ERROR!!!
+         if (read_bytes == 0)
+            return length;
+         if (s->read_buf_s.bufsize == -1)
+            s->read_buf_s.offset = s->offset;
+         else
+            s->read_buf_s.offset += s->read_buf_s.bufsize;
+         s->read_buf_s.bufsize = read_bytes;
+      }
+
+      position = s->offset - s->read_buf_s.offset;
+      remainder = s->read_buf_s.bufsize - position;
+      read_bytes = min(size, remainder);
+
+      memcpy((char*)buf + length, 
+         (char*)s->read_buf_s.buf + position, read_bytes);
+
+      length += read_bytes;
+      position += read_bytes;
+      size -= read_bytes;
+      remainder -= read_bytes;
+      s->offset += read_bytes;
+   }
+
+   return length;
+}
+
+int buf_file_write(stream_t *stream_s, void *buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.offset + s->write_buf_s.bufsize == s->offset &&
+      s->write_buf_s.bufsize + size < WRITE_BUFFER_SIZE)
+   {
+      memcpy((char*)s->write_buf_s.buf + s->write_buf_s.bufsize, buf, size);
+      s->write_buf_s.bufsize += size;
+      s->offset += size;
+      return size;
+   }
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   if (size > WRITE_BUFFER_SIZE)
+   {
+      int ret = file_seek(stream_s, s->offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != size)
+      {
+         int n = file_write(stream_s, (char*)buf + write_bytes, size - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->offset += size;
+      return write_bytes;
+   }
+   else
+   {
+      memcpy(s->write_buf_s.buf, buf, size);
+      s->write_buf_s.offset = s->offset;
+      s->offset += size;
+      s->write_buf_s.bufsize = size;
+      return size;
+   }
+}
+
+int buf_file_peek(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int ret = 0;
+   int len = 0;
+
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   len = file_read(stream_s, buf, size);
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   return len;
+}
+
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   uint64_t ret = 0;
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+   ret = file_seek(stream_s, offset, whence);
+   if (ret != 0)
+      return ret;
+   s->offset = file_tell(stream_s);
+   if (s->read_buf_s.offset > s->offset || 
+      s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset)
+      s->read_buf_s.bufsize = -1;
+   else
+      s->read_buf_s.offset = s->offset;
+   return ret;
+}
+
+int buf_file_close(stream_t *stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   return file_close(stream_s);
+}
+
+
+
+uint16_t Swap16(uint16_t x)
+{
+   return ((x<<8)|(x>>8));
+}
+
+uint32_t Swap32(uint32_t x)
+{
+   return((x<<24)|((x<<8)&0x00FF0000)|((x>>8)&0x0000FF00)|(x>>24));
+}
+
+uint64_t Swap64(uint64_t x)
+{
+   uint32_t hi, lo;
+
+   /* Separate into high and low 32-bit values and swap them */
+   lo = (uint32_t)(x & 0xFFFFFFFF);
+   x >>= 32;
+   hi = (uint32_t)(x & 0xFFFFFFFF);
+   x = Swap32(lo);
+   x <<= 32;
+   x |= Swap32(hi);
+   return(x);
+}
+
+uint16_t read_le16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE16(value));
+}
+
+uint16_t read_be16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE16(value));
+}
+
+uint32_t read_le32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE32(value));
+}
+
+uint32_t read_be32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE32(value));
+}
+
+uint64_t read_le64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE64(value));
+}
+
+uint64_t read_be64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE64(value));
+}
+
+int write_le16(stream_t *dst, uint16_t value)
+{
+   value = SwapLE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be16(stream_t *dst, uint16_t value)
+{
+   value = SwapBE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le32(stream_t *dst, uint32_t value)
+{
+   value = SwapLE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be32(stream_t *dst, uint32_t value)
+{
+   value = SwapBE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le64(stream_t *dst, uint64_t value)
+{
+   value = SwapLE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be64(stream_t *dst, uint64_t value)
+{
+   value = SwapBE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
new file mode 100644
index 0000000..34e8feb
--- /dev/null
+++ b/net/mmt/mpu/stream.h
@@ -0,0 +1,143 @@
+#ifndef NET_MMT_MPU_STREAM_H_
+#define NET_MMT_MPU_STREAM_H_
+
+#include <stdint.h>
+
+#ifndef _STDINT_H
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned uint32_t;
+//typedef long long int64_t;
+typedef unsigned long long uint64_t;
+//typedef unsigned long size_t;
+#endif
+
+#define MODE_READ             (1)
+#define MODE_WRITE            (2)
+#define MODE_READWRITEFILTER  (3)
+#define MODE_EXISTING         (4)
+#define MODE_CREATE           (8)
+
+typedef struct stream {
+   void* (*open)(struct stream *stream_s, const char* filename, int mode);
+   int (*read)(struct stream *stream_s, void* buf, int size);
+   int (*write)(struct stream *stream_s, void *buf, int size);
+   int (*peek)(struct stream *stream_s, void* buf, int size);
+   uint64_t (*seek)(struct stream *stream_s, int64_t offset, int whence);
+   uint64_t (*tell)(struct stream *stream_s);
+   int (*close)(struct stream *stream_s);
+   void* opaque;
+} stream_t;
+
+#define stream_open(s, filename, mode) ((stream_t*)s)->open(((stream_t*)s), filename, mode)
+#define stream_read(s, buf, size) ((stream_t*)s)->read(((stream_t*)s), buf, size)
+#define stream_write(s, buf, size) ((stream_t*)s)->write(((stream_t*)s), buf, size)
+#define stream_peek(s, buf, size) ((stream_t*)s)->peek(((stream_t*)s), buf, size)
+#define stream_seek(s, offset, whence) ((stream_t*)s)->seek(((stream_t*)s), offset, whence)
+#define stream_tell(s) ((stream_t*)s)->tell(((stream_t*)s))
+#define stream_close(s) ((stream_t*)s)->close(((stream_t*)s))
+
+void* file_open(stream_t *stream_s, const char* filename, int mode);
+int file_read(stream_t *stream_s, void* buf, int size);
+int file_write(stream_t *stream_s, void *buf, int size);
+int file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence);
+uint64_t file_tell(stream_t *stream_s);
+int file_close(stream_t *stream_s);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+stream_t* create_file_stream();
+void destory_file_stream(stream_t* stream_s);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#define READ_BUFFER_SIZE   10485760
+#define WRITE_BUFFER_SIZE  10485760
+
+typedef struct buf_stream {
+   stream_t s;
+
+   struct read_buf {
+      void* buf;        
+      int64_t bufsize; 
+      int64_t offset; 
+   } read_buf_s;
+
+   struct write_buf {
+      void* buf;     
+      int64_t bufsize;
+      int64_t offset;
+   } write_buf_s;
+
+   uint64_t offset; 
+
+} buf_stream_t;
+
+int buf_file_read(stream_t *stream_s, void* buf, int size);
+int buf_file_write(stream_t *stream_s, void *buf, int size);
+int buf_file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence);
+int buf_file_close(stream_t *stream_s);
+
+stream_t* create_buf_file_stream();
+void destory_buf_file_stream(stream_t* stream_s);
+
+#define LIL_ENDIAN_INTERNAL	1234
+#define BIG_ENDIAN_INTERNAL	4321
+
+#ifndef BYTEORDER
+#if defined(__hppa__) || \
+   defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \
+   (defined(__MIPS__) && defined(__MISPEB__)) || \
+   defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
+   defined(__sparc__)
+#define BYTEORDER	BIG_ENDIAN_INTERNAL
+#else
+#define BYTEORDER	LIL_ENDIAN_INTERNAL
+#endif
+#endif /* !BYTEORDER */
+
+uint16_t Swap16(uint16_t x);
+uint32_t Swap32(uint32_t x);
+uint64_t Swap64(uint64_t x);
+
+#if BYTEORDER == LIL_ENDIAN
+#define SwapLE16(X)	(X)
+#define SwapLE32(X)	(X)
+#define SwapLE64(X)	(X)
+#define SwapBE16(X)	Swap16(X)
+#define SwapBE32(X)	Swap32(X)
+#define SwapBE64(X)	Swap64(X)
+#else
+#define SwapLE16(X)	Swap16(X)
+#define SwapLE32(X)	Swap32(X)
+#define SwapLE64(X)	Swap64(X)
+#define SwapBE16(X)	(X)
+#define SwapBE32(X)	(X)
+#define SwapBE64(X)	(X)
+#endif
+
+uint16_t read_le16(stream_t *src);
+uint16_t read_be16(stream_t *src);
+uint32_t read_le32(stream_t *src);
+uint32_t read_be32(stream_t *src);
+uint64_t read_le64(stream_t *src);
+uint64_t read_be64(stream_t *src);
+
+int write_le16(stream_t *dst, uint16_t value);
+int write_be16(stream_t *dst, uint16_t value);
+int write_le32(stream_t *dst, uint32_t value);
+int write_be32(stream_t *dst, uint32_t value);
+int write_le64(stream_t *dst, uint64_t value);
+int write_be64(stream_t *dst, uint64_t value);
+
+#endif // NET_MMT_MPU_STREAM_H_
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
new file mode 100644
index 0000000..8c7ae7e
--- /dev/null
+++ b/net/mmt/mpu/test_parser.cc
@@ -0,0 +1,40 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "stream.h"
+#include "mp4.h"
+
+int main(int argc, char* argv[])
+{
+    if (argc != 2) {
+        printf("usage: %s mp4file\n", argv[0]);
+        exit(1);
+    }
+
+    mp4_box_t *root = NULL;
+    stream_t* s = NULL;
+
+    s = create_file_stream();
+    if (stream_open(s, argv[1], MODE_READ) == 0)
+        return -1;
+
+    root = MP4_BoxGetRoot(s);
+    if (!root) return -1;
+    printf("root: %p itype=%u ftyp=%u moof=%u\n", root, root->i_type,
+        ATOM_ftyp, ATOM_moof);
+
+    mp4_box_t* box = NULL;
+    box = MP4_BoxSearchBox(root, ATOM_ftyp);
+    printf("ftyp: %p\n", box);
+
+    box = MP4_BoxSearchBox(root, ATOM_moof);
+    printf("moof: %p\n", box);
+
+    MP4_BoxFree(s, root);
+
+    stream_close(s);
+    destory_file_stream(s);
+
+    return 0;
+}
+
-- 
1.7.9.5


From 6fd9a1a6b18bcae1c43d561c2b4968f4996b03c2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 17:39:48 -0800
Subject: [PATCH 44/92] add custom mp4atom

---
 net/mmt/mpu/mp4atom.h |  154 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 154 insertions(+)
 create mode 100644 net/mmt/mpu/mp4atom.h

diff --git a/net/mmt/mpu/mp4atom.h b/net/mmt/mpu/mp4atom.h
new file mode 100644
index 0000000..52e68ce
--- /dev/null
+++ b/net/mmt/mpu/mp4atom.h
@@ -0,0 +1,154 @@
+#ifndef NET_MMT_MPU_MP4ATOM_H_
+#define NET_MMT_MPU_MP4ATOM_H_
+
+#include <stdint.h>
+
+typedef struct uuid_s{
+    uint8_t b[16];
+} uuid_t;
+
+#define MP4_FOURCC( a, b, c, d ) \
+    (((uint32_t)a) | (((uint32_t)b)<<8) | (((uint32_t)c)<<16) | (((uint32_t)d)<<24))
+
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+
+// pps/sps: moov -> trak -> mdia -> minf -> stbl -> stsd -> avcl -> avcC
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+
+// moof
+
+
+typedef struct atom_ftyp_s {
+    uint32_t major_brand;
+    uint32_t minor_version;
+    uint32_t compatible_brands_count;
+    uint32_t *compatible_brands;
+} atom_ftyp_t;
+
+typedef struct atom_mmpu_s {
+    uint8_t  version;
+    uint32_t flags;
+    uint8_t  is_complete;
+    uint8_t  reserved;
+    uint32_t mpu_sequence_number;
+    uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;
+} atom_mmpu_t;
+
+typedef struct atom_tfdt_s {
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+} atom_tfdt_t;
+
+typedef struct atom_mvhd_s {
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+} atom_mvhd_t;
+
+typedef struct atom_mfhd_s {
+    uint32_t sequence_number;
+    uint8_t *vendor_extension;
+} atom_mfhd_t;
+
+typedef struct atom_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} atom_tfra_t;
+
+typedef struct atom_avcC_s {
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+} atom_avcC_t;
+
+
+// common atoms
+//  a) ftyp
+//  b) avcC in moov/trak/mdia/minf/stbl/stsd/avcl
+//  c) mdat
+// common containers: 
+//  a) moov/trak/mdia/minf/stbl/stsd/avcl
+//  b) moof/
+
+// for some atom containers
+typedef unsigned char* data_t;
+typedef struct atom_info_s {
+    int     pos;
+    int     type;
+    uuid_t  uuid;
+    char    name[5]; // box name: 4chars + '\0'
+    int     size;
+    data_t  data;
+}atom_info_t;
+
+typedef struct mp4_root_s {
+    atom_info_t ftyp; // required
+    atom_info_t mmpu; // required
+    atom_info_t moov; // required
+    atom_info_t moof; // the first moof
+    atom_info_t mdat;
+    int     size;
+    data_t  data;
+}mp4_root_t;
+
+#endif // NET_MMT_MPU_MP4ATOM_H_
-- 
1.7.9.5


From 8ee07403a94e37d41daab9bf7e66828c512d93f8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 17:44:21 -0800
Subject: [PATCH 45/92] update with new version of mpuparser

---
 net/mmt/mpu/Makefile       |    4 +-
 net/mmt/mpu/mp4.c          | 4508 ++++++++++++++++++++++----------------------
 net/mmt/mpu/mp4.h          |    5 +-
 net/mmt/mpu/stream.c       |    2 +-
 net/mmt/mpu/stream.h       |   41 +-
 net/mmt/mpu/test_parser.cc |   20 +-
 6 files changed, 2256 insertions(+), 2324 deletions(-)

diff --git a/net/mmt/mpu/Makefile b/net/mmt/mpu/Makefile
index 021f39c..cfb990c 100644
--- a/net/mmt/mpu/Makefile
+++ b/net/mmt/mpu/Makefile
@@ -9,10 +9,10 @@ $(TARGET): $(OBJS)
 	$(CC) -o $@ $(OBJS) $(LDFLAGS)
 
 %.o:%.c
-	$(CC) $(CFLAGS) -o $@ -c $<
+	$(CC) -g $(CFLAGS) -o $@ -c $<
 
 %.o:%.cc
-	$(CC) $(CFLAGS) -o $@ -c $<
+	$(CC) -g $(CFLAGS) -o $@ -c $<
 	
 clean:
 	@rm -f $(OBJS)
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index 9e64657..bc6af51 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -1,4 +1,4 @@
-#include <stdio.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <memory.h>
 #include <assert.h>
@@ -8,22 +8,37 @@
 
 void *debug_malloc(size_t size, const char *file, int line, const char *func)
 {
-    void *p;
-    p = malloc(size);
-    printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
+        void *p;
+
+        p = malloc(size);
+        printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
             file, line, func, size, (unsigned long)p);
-    return p;
+        return p;
 }
 
+//#define malloc(s) debug_malloc(s, __FILE__, __LINE__, __func__)
 void *debug_free(char *p)
 {
-    if(NULL!=(p))
-    {
-        free(p) ;
-        p = NULL;
-    }
+        //printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,  __func__, (unsigned long)p);
+            if(NULL!=(p))
+            {
+            	free(p) ;
+                p = NULL;
+            }
+
 }
 
+//#define free(p)  do {                                                                                   \
+//        printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,            \
+//            __func__, (unsigned long)p);                                                       \
+//        if (p) {                                                                                                     \
+//          free(p);                                                                                                 \
+//          p = NULL;                                                                                           \
+//       }                                                                                                               \
+//} while (0)
+
+//#define free(p) debug_free(p)
+
 
 #define msg_Dbg(x) do {} while (0)
 #define msg_Warn(x) do {} while (0)
@@ -40,18 +55,18 @@ void *debug_free(char *p)
     if( (i_read) >= (size) ) { dst = (code); p_peek += (size); } \
     else { dst = 0; }   \
     i_read -= (size);   \
-} while(0)
+  } while(0)
 
 static uint32_t mp4_box_headersize( mp4_box_t *p_box )
 {
-    return 8
-        + ( p_box->i_shortsize == 1 ? 8 : 0 )
-        + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
+   return 8
+      + ( p_box->i_shortsize == 1 ? 8 : 0 )
+      + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
 }
 
 static uint32_t Get24bBE( const uint8_t *p )
 {
-    return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
+   return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
 }
 
 #define MP4_GET1BYTE( dst )  MP4_GETX_PRIVATE( dst, *p_peek, 1 )
@@ -60,60 +75,60 @@ static uint32_t Get24bBE( const uint8_t *p )
 #define MP4_GET4BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE32(*(uint32_t*)p_peek), 4 )
 #define MP4_GET8BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE64(*(uint64_t*)p_peek), 8 )
 #define MP4_GETFOURCC( dst ) MP4_GETX_PRIVATE( dst, \
-        MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
+                MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
 
 #define MP4_GETVERSIONFLAGS( p_void ) \
     MP4_GET1BYTE( p_void->version ); \
-MP4_GET3BYTES( p_void->flags )
+    MP4_GET3BYTES( p_void->flags )
 
 #define MP4_GETSTRINGZ( p_str )         \
     if( (i_read > 0) && (p_peek[0]) )   \
-{       \
-    const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
-    p_str = malloc( __i_copy__+1 );               \
-    if( p_str ) \
-    { \
-        memcpy( p_str, p_peek, __i_copy__ ); \
-        p_str[__i_copy__] = 0; \
-    } \
-    p_peek += __i_copy__ + 1;   \
-    i_read -= __i_copy__ + 1;   \
-}       \
-else    \
-{       \
-    p_str = NULL; \
-}
+    {       \
+        const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
+        p_str = malloc( __i_copy__+1 );               \
+        if( p_str ) \
+        { \
+             memcpy( p_str, p_peek, __i_copy__ ); \
+             p_str[__i_copy__] = 0; \
+        } \
+        p_peek += __i_copy__ + 1;   \
+        i_read -= __i_copy__ + 1;   \
+    }       \
+    else    \
+    {       \
+        p_str = NULL; \
+    }
 
 #define MP4_READBOX_ENTER( mp4_box_data_TYPE_t ) \
     int64_t  i_read = p_box->i_size; \
-uint8_t *p_peek, *p_buff; \
-int i_actually_read; \
-if( !( p_peek = p_buff = malloc( i_read ) ) ) \
-{ \
-    return( 0 ); \
-} \
-i_actually_read = stream_read( p_stream, p_peek, i_read ); \
-if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
-{ \
-    free( p_buff ); \
-    return( 0 ); \
-} \
-p_peek += mp4_box_headersize( p_box ); \
-i_read -= mp4_box_headersize( p_box ); \
-if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
-{ \
-    free( p_buff ); \
-    return( 0 ); \
-}
+    uint8_t *p_peek, *p_buff; \
+    int i_actually_read; \
+    if( !( p_peek = p_buff = malloc( i_read ) ) ) \
+    { \
+        return( 0 ); \
+    } \
+    i_actually_read = stream_read( p_stream, p_peek, i_read ); \
+    if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    } \
+    p_peek += mp4_box_headersize( p_box ); \
+    i_read -= mp4_box_headersize( p_box ); \
+    if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    }
 
 #define MP4_READBOX_EXIT( i_code ) \
     do \
-{ \
-    free( p_buff ); \
-    if( i_read < 0 ) \
-    printf( "Not enough data" ); \
-    return( i_code ); \
-} while (0)
+    { \
+        free( p_buff ); \
+        if( i_read < 0 ) \
+            printf( "Not enough data" ); \
+        return( i_code ); \
+    } while (0)
 
 
 /* Some assumptions:
@@ -130,47 +145,47 @@ if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
 
 static void CreateUUID( uuid_t *p_uuid, uint32_t i_fourcc )
 {
-    /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
-    /* FIXME implement this */
-    (void)p_uuid;
-    (void)i_fourcc;
+   /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
+   /* FIXME implement this */
+   (void)p_uuid;
+   (void)i_fourcc;
 }
 
 static int drms_init( void *_p_drms, uint32_t i_type,
-        uint8_t *p_info, uint32_t i_len )
+              uint8_t *p_info, uint32_t i_len )
 {
-    return 1;
+   return 1;
 }
 
 static void GetUUID( uuid_t *p_uuid, const uint8_t *p_buff )
 {
-    memcpy( p_uuid, p_buff, 16 );
+   memcpy( p_uuid, p_buff, 16 );
 }
 
 /* convert 16.16 fixed point to floating point */
 static double conv_fx( int32_t fx ) {
-    double fp = fx;
-    fp /= 65536.0;
-    return fp;
+   double fp = fx;
+   fp /= 65536.0;
+   return fp;
 }
 
 /* some functions for mp4 encoding of variables */
 #ifdef MP4_VERBOSE
 static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
 {
-    int i_day;
-    int i_hour;
-    int i_min;
-    int i_sec;
+   int i_day;
+   int i_hour;
+   int i_min;
+   int i_sec;
 
-    /* date begin at 1 jan 1904 */
-    i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
+   /* date begin at 1 jan 1904 */
+   i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
 
-    i_day = i_date / ( 60*60*24);
-    i_hour = ( i_date /( 60*60 ) ) % 60;
-    i_min  = ( i_date / 60 ) % 60;
-    i_sec =  i_date % 60;
-    sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
+   i_day = i_date / ( 60*60*24);
+   i_hour = ( i_date /( 60*60 ) ) % 60;
+   i_min  = ( i_date / 60 ) % 60;
+   i_sec =  i_date % 60;
+   sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
 }
 #endif
 
@@ -184,66 +199,66 @@ static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
  *****************************************************************************/
 int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
 {
-    int      i_read;
-    const uint8_t *p_buff = malloc(32);
-    const uint8_t *p_peek = p_buff;
-
-    if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
-    {
-        free(p_buff);
-        return 0;
-    }
-
-    p_box->i_pos = stream_tell( p_stream );
-
-    p_box->data.p_data = NULL;
-    p_box->p_father = NULL;
-    p_box->p_first  = NULL;
-    p_box->p_last  = NULL;
-    p_box->p_next   = NULL;
-
-    MP4_GET4BYTES( p_box->i_shortsize );
-    MP4_GETFOURCC( p_box->i_type );
-
-    /* Now special case */
-
-    if( p_box->i_shortsize == 1 )
-    {
-        /* get the true size on 64 bits */
-        MP4_GET8BYTES( p_box->i_size );
-    }
-    else
-    {
-        p_box->i_size = p_box->i_shortsize;
-        /* XXX size of 0 means that the box extends to end of file */
-    }
-
-    if( p_box->i_type == ATOM_uuid )
-    {
-        /* get extented type on 16 bytes */
-        GetUUID( &p_box->i_uuid, p_peek );
-        p_peek += 16; i_read -= 16;
-    }
-    else
-    {
-        CreateUUID( &p_box->i_uuid, p_box->i_type );
-    }
-
-    free(p_buff);
-
-    // #ifdef MP4_VERBOSE
-    //    if( p_box->i_size )
-    //    {
-    //       if MP4_BOX_TYPE_ASCII()
-    //           printf( "found Box: %4.4s size %"PRId64,
-    //          (char*)&p_box->i_type, p_box->i_size );
-    //       else
-    //           printf( "found Box: c%3.3s size %"PRId64,
-    //          (char*)&p_box->i_type+1, p_box->i_size );
-    //    }
-    // #endif
-
-    return 1;
+   int      i_read;
+   const uint8_t *p_buff = malloc(32);
+   const uint8_t *p_peek = p_buff;
+
+   if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+   {
+      free(p_buff);
+      return 0;
+   }
+
+   p_box->i_pos = stream_tell( p_stream );
+
+   p_box->data.p_data = NULL;
+   p_box->p_father = NULL;
+   p_box->p_first  = NULL;
+   p_box->p_last  = NULL;
+   p_box->p_next   = NULL;
+
+   MP4_GET4BYTES( p_box->i_shortsize );
+   MP4_GETFOURCC( p_box->i_type );
+
+   /* Now special case */
+
+   if( p_box->i_shortsize == 1 )
+   {
+      /* get the true size on 64 bits */
+      MP4_GET8BYTES( p_box->i_size );
+   }
+   else
+   {
+      p_box->i_size = p_box->i_shortsize;
+      /* XXX size of 0 means that the box extends to end of file */
+   }
+
+   if( p_box->i_type == ATOM_uuid )
+   {
+      /* get extented type on 16 bytes */
+      GetUUID( &p_box->i_uuid, p_peek );
+      p_peek += 16; i_read -= 16;
+   }
+   else
+   {
+      CreateUUID( &p_box->i_uuid, p_box->i_type );
+   }
+
+   free(p_buff);
+
+// #ifdef MP4_VERBOSE
+//    if( p_box->i_size )
+//    {
+//       if MP4_BOX_TYPE_ASCII()
+//           printf( "found Box: %4.4s size %"PRId64,
+//          (char*)&p_box->i_type, p_box->i_size );
+//       else
+//           printf( "found Box: c%3.3s size %"PRId64,
+//          (char*)&p_box->i_type+1, p_box->i_size );
+//    }
+// #endif
+
+   return 1;
 }
 
 /*****************************************************************************
@@ -253,39 +268,39 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
  *****************************************************************************/
 static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t box;
+   mp4_box_t box;
 
-    if( !p_box )
-    {
-        MP4_ReadBoxCommon( p_stream, &box );
-        p_box = &box;
-    }
+   if( !p_box )
+   {
+      MP4_ReadBoxCommon( p_stream, &box );
+      p_box = &box;
+   }
 
-    if( !p_box->i_size )
-    {
-        return 2; /* Box with infinite size */
-    }
+   if( !p_box->i_size )
+   {
+      return 2; /* Box with infinite size */
+   }
 
-    if( p_box->p_father )
-    {
-        const int64_t i_box_end = p_box->i_size + p_box->i_pos;
-        const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
+   if( p_box->p_father )
+   {
+      const int64_t i_box_end = p_box->i_size + p_box->i_pos;
+      const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
 
-        /* check if it's within p-father */
-        if( i_box_end >= i_father_end )
-        {
-            if( i_box_end > i_father_end )
-                printf(  "out of bound child" );
-            return 0; /* out of bound */
-        }
-    }
+      /* check if it's within p-father */
+      if( i_box_end >= i_father_end )
+      {
+         if( i_box_end > i_father_end )
+        	 printf(  "out of bound child" );
+         return 0; /* out of bound */
+      }
+   }
 
-    if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
-    {
-        return 0;
-    }
+   if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
+   {
+      return 0;
+   }
 
-    return 1;
+   return 1;
 }
 
 /*****************************************************************************
@@ -296,92 +311,92 @@ static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
  *****************************************************************************/
 static int MP4_ReadBoxContainerRaw( stream_t *p_stream, mp4_box_t *p_container )
 {
-    mp4_box_t *p_box;
+   mp4_box_t *p_box;
 
-    if( stream_tell( p_stream ) + 8 >
-            (int64_t)(p_container->i_pos + p_container->i_size) )
-    {
-        /* there is no box to load */
-        return 0;
-    }
+   if( stream_tell( p_stream ) + 8 >
+      (int64_t)(p_container->i_pos + p_container->i_size) )
+   {
+      /* there is no box to load */
+      return 0;
+   }
 
-    do
-    {
-        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
+   do
+   {
+      if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
 
-        /* chain this box with the father and the other at same level */
-        if( !p_container->p_first ) p_container->p_first = p_box;
-        else p_container->p_last->p_next = p_box;
-        p_container->p_last = p_box;
+      /* chain this box with the father and the other at same level */
+      if( !p_container->p_first ) p_container->p_first = p_box;
+      else p_container->p_last->p_next = p_box;
+      p_container->p_last = p_box;
 
-    } while( MP4_NextBox( p_stream, p_box ) == 1 );
+   } while( MP4_NextBox( p_stream, p_box ) == 1 );
 
-    return 1;
+   return 1;
 }
 
 static int MP4_ReadBoxContainer( stream_t *p_stream, mp4_box_t *p_container )
 {
-    if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
-    {
-        /* container is empty, 8 stand for the first header in this box */
-        return 1;
-    }
-
-    /* enter box */
-    stream_seek( p_stream, p_container->i_pos +
-            mp4_box_headersize( p_container ), SEEK_SET );
+   if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
+   {
+      /* container is empty, 8 stand for the first header in this box */
+      return 1;
+   }
 
-    return MP4_ReadBoxContainerRaw( p_stream, p_container );
+   /* enter box */
+   stream_seek( p_stream, p_container->i_pos +
+      mp4_box_headersize( p_container ), SEEK_SET );
+ 
+   return MP4_ReadBoxContainerRaw( p_stream, p_container );
 }
 
 static void MP4_FreeBox_Common( mp4_box_t *p_box )
 {
-    /* Up to now do nothing */
-    (void)p_box;
+   /* Up to now do nothing */
+   (void)p_box;
 }
 
 static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
 {
-    /* XXX sometime moov is hiden in a free box */
-    if( p_box->p_father &&
-            p_box->p_father->i_type == ATOM_root &&
-            p_box->i_type == ATOM_free )
-    {
-        const uint8_t *p_buff = malloc(44);
-        const uint8_t *p_peek = p_buff;
-        int     i_read;
-        uint32_t i_fcc;
+   /* XXX sometime moov is hiden in a free box */
+   if( p_box->p_father &&
+      p_box->p_father->i_type == ATOM_root &&
+      p_box->i_type == ATOM_free )
+   {
+      const uint8_t *p_buff = malloc(44);
+      const uint8_t *p_peek = p_buff;
+      int     i_read;
+      uint32_t i_fcc;
 
-        i_read  = stream_peek( p_stream, p_peek, 44 );
+      i_read  = stream_peek( p_stream, p_peek, 44 );
 
-        p_peek += mp4_box_headersize( p_box ) + 4;
-        i_read -= mp4_box_headersize( p_box ) + 4;
+      p_peek += mp4_box_headersize( p_box ) + 4;
+      i_read -= mp4_box_headersize( p_box ) + 4;
 
-        if( i_read >= 8 )
-        {
-            i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
+      if( i_read >= 8 )
+      {
+         i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
 
-            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
-            {
-                printf( "detected moov hidden in a free box ..." );
+         if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
+         {
+            printf( "detected moov hidden in a free box ..." );
 
-                p_box->i_type = ATOM_foov;
-                free(p_buff);
-                return MP4_ReadBoxContainer( p_stream, p_box );
-            }
-        }
-        free(p_buff);
-    }
+            p_box->i_type = ATOM_foov;
+            free(p_buff);
+            return MP4_ReadBoxContainer( p_stream, p_box );
+         }
+      }
+      free(p_buff);
+   }
 
-    /* Nothing to do */
-    // #ifdef MP4_VERBOSE
-    //    if MP4_BOX_TYPE_ASCII()
-    //        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
-    //    else
-    //        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
-    // #endif
+   /* Nothing to do */
+// #ifdef MP4_VERBOSE
+//    if MP4_BOX_TYPE_ASCII()
+//        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
+//    else
+//        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
+// #endif
 
-    return 1;
+   return 1;
 }
 
 #   define likely(p)   (!!(p))
@@ -389,86 +404,86 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_ftyp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
+   MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
 
-    MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
-    MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
+   MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
+   MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
 
-    if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
-    {
-        unsigned int i = 0;
-        uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
-            calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
+   if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
+   {
+      unsigned int i = 0;
+      uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
+         calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
 
-        if( unlikely( tab == NULL ) )
-            MP4_READBOX_EXIT( 0 );
+      if( unlikely( tab == NULL ) )
+         MP4_READBOX_EXIT( 0 );
 
-        for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
-        {
-            MP4_GETFOURCC( tab[i] );
-        }
-    }
-    else
-    {
-        p_box->data.p_ftyp->compatible_brands = NULL;
-    }
+      for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
+      {
+         MP4_GETFOURCC( tab[i] );
+      }
+   }
+   else
+   {
+      p_box->data.p_ftyp->compatible_brands = NULL;
+   }
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_ftyp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_ftyp->compatible_brands );
+   FREENULL( p_box->data.p_ftyp->compatible_brands );
 }
 
 static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int mmpu_buf;
-    int i;
-    MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
-    MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
-    MP4_GET1BYTE(mmpu_buf);
-    p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
-    p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
-    MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
-    MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
-    MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
-    p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
-    for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
-    {
+   unsigned int mmpu_buf;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
+   MP4_GET1BYTE(mmpu_buf);
+   p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
+   p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
+   MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
+   MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
+   p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
+   for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
+   {
 
-        MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
-    }
+	   MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
+   }
 
 
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
+   MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
 
-    if( p_box->data.p_tfdt->version )
-    {
-        MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+       if( p_box->data.p_tfdt->version )
+       {
+           MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
 
-    }
-    else
-    {
-        MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+       }
+       else
+       {
+           MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
 
-    }
+       }
 
 
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_mmpu( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_mmpu->asset_id_value );
+   FREENULL( p_box->data.p_mmpu->asset_id_value );
 }
 
 
@@ -522,24 +537,24 @@ static int MP4_ReadBox_mvhd(  stream_t *p_stream, mp4_box_t *p_box )
 #ifdef MP4_VERBOSE
     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
     MP4_ConvertDate2Str( s_modification_time,
-            p_box->data.p_mvhd->modification_time );
+                         p_box->data.p_mvhd->modification_time );
     if( p_box->data.p_mvhd->rate )
     {
         MP4_ConvertDate2Str( s_duration,
-                p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
+                 p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
     }
     else
     {
         s_duration[0] = 0;
     }
-    printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
-            s_creation_time,
-            s_modification_time,
-            (uint32_t)p_box->data.p_mvhd->timescale,
-            s_duration,
-            (float)p_box->data.p_mvhd->rate / (1<<16 ),
-            (float)p_box->data.p_mvhd->volume / 256 ,
-            (uint32_t)p_box->data.p_mvhd->next_track_id );
+     printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
+                  s_creation_time,
+                  s_modification_time,
+                  (uint32_t)p_box->data.p_mvhd->timescale,
+                  s_duration,
+                  (float)p_box->data.p_mvhd->rate / (1<<16 ),
+                  (float)p_box->data.p_mvhd->volume / 256 ,
+                  (uint32_t)p_box->data.p_mvhd->next_track_id );
 #endif
     MP4_READBOX_EXIT( 1 );
 }
@@ -551,8 +566,8 @@ static int MP4_ReadBox_mfhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_mfhd->sequence_number );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"mfhd\" sequence number %d",
-            p_box->data.p_mfhd->sequence_number );
+     printf( "read box: \"mfhd\" sequence number %d",
+                  p_box->data.p_mfhd->sequence_number );
 #endif
     MP4_READBOX_EXIT( 1 );
 }
@@ -595,11 +610,11 @@ static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
         if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
             snprintf(psz_flag, sizeof(psz_flag), "sample flags 0x%x", p_box->data.p_tfhd->default_sample_flags);
 
-        printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
-                p_box->data.p_tfhd->i_version,
-                p_box->data.p_tfhd->i_flags,
-                p_box->data.p_tfhd->track_ID,
-                psz_base, psz_desc, psz_dura, psz_size, psz_flag );
+         printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
+                    p_box->data.p_tfhd->i_version,
+                    p_box->data.p_tfhd->i_flags,
+                    p_box->data.p_tfhd->track_ID,
+                    psz_base, psz_desc, psz_dura, psz_size, psz_flag );
 #endif
     }
 
@@ -608,7 +623,7 @@ static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
+   unsigned int i;
     MP4_READBOX_ENTER( mp4_box_data_trun_t );
 
     MP4_GETVERSIONFLAGS( p_box->data.p_trun );
@@ -621,7 +636,7 @@ static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
         MP4_GET4BYTES( p_box->data.p_trun->first_sample_flags );
 
     p_box->data.p_trun->samples =
-        calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
+      calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
     if ( p_box->data.p_trun->samples == NULL )
         MP4_READBOX_EXIT( 0 );
 
@@ -639,17 +654,17 @@ static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
     }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
-            p_box->data.p_trun->version,
-            p_box->data.p_trun->flags,
-            p_box->data.p_trun->sample_count );
+     printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
+                  p_box->data.p_trun->version,
+                  p_box->data.p_trun->flags,
+                  p_box->data.p_trun->sample_count );
 
     for( unsigned int i = 0; i<p_box->data.p_trun->sample_count; i++ )
     {
         mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
-        printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
-                i, p_sample->i_flags, p_sample->duration,
-                p_sample->i_size, p_sample->composition_time_offset );
+         printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
+                        i, p_sample->i_flags, p_sample->duration,
+                        p_sample->i_size, p_sample->composition_time_offset );
     }
 #endif
 
@@ -712,19 +727,19 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_tkhd->width );
     MP4_GET4BYTES( p_box->data.p_tkhd->height );
 
-
+    
     matrix = p_box->data.p_tkhd->matrix;
-
+    
     translate[0] = conv_fx(matrix[6]);
     translate[1] = conv_fx(matrix[7]);
-
+    
     scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +
-            conv_fx(matrix[3]) * conv_fx(matrix[3]));
+                    conv_fx(matrix[3]) * conv_fx(matrix[3]));
     scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +
-            conv_fx(matrix[4]) * conv_fx(matrix[4]));
-
+                    conv_fx(matrix[4]) * conv_fx(matrix[4]));
+    
     rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;
-
+    
     if (rotation < 0)
         rotation += 360.;
 
@@ -733,30 +748,30 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->modification_time );
     MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->duration );
 
-    printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
+     printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
             "Matrix: %i %i %i %i %i %i %i %i %i",
-            s_creation_time,
-            s_modification_time,
-            s_duration,
-            p_box->data.p_tkhd->track_ID,
-            p_box->data.p_tkhd->layer,
-            (float)p_box->data.p_tkhd->volume / 256 ,
-            rotation,
-            scale[0],
-            scale[1],
-            translate[0],
-            translate[1],
-            (float)p_box->data.p_tkhd->width / 65536,
-            (float)p_box->data.p_tkhd->height / 65536,
-            p_box->data.p_tkhd->matrix[0],
-            p_box->data.p_tkhd->matrix[1],
-            p_box->data.p_tkhd->matrix[2],
-            p_box->data.p_tkhd->matrix[3],
-            p_box->data.p_tkhd->matrix[4],
-            p_box->data.p_tkhd->matrix[5],
-            p_box->data.p_tkhd->matrix[6],
-            p_box->data.p_tkhd->matrix[7],
-            p_box->data.p_tkhd->matrix[8] );
+                  s_creation_time,
+                  s_modification_time,
+                  s_duration,
+                  p_box->data.p_tkhd->track_ID,
+                  p_box->data.p_tkhd->layer,
+                  (float)p_box->data.p_tkhd->volume / 256 ,
+                  rotation,
+                  scale[0],
+                  scale[1],
+                  translate[0],
+                  translate[1],
+                  (float)p_box->data.p_tkhd->width / 65536,
+                  (float)p_box->data.p_tkhd->height / 65536,
+                  p_box->data.p_tkhd->matrix[0],
+                  p_box->data.p_tkhd->matrix[1],
+                  p_box->data.p_tkhd->matrix[2],
+                  p_box->data.p_tkhd->matrix[3],
+                  p_box->data.p_tkhd->matrix[4],
+                  p_box->data.p_tkhd->matrix[5],
+                  p_box->data.p_tkhd->matrix[6],
+                  p_box->data.p_tkhd->matrix[7],
+                  p_box->data.p_tkhd->matrix[8] );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -765,11 +780,11 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_hint( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_hint_t );
+   MP4_READBOX_ENTER( mp4_box_data_hint_t );
 
-    MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
+   MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -804,24 +819,24 @@ static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
     for( i = 0; i < 3; i++ )
     {
         p_box->data.p_mdhd->language[i] =
-            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+                    ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
     }
 
     MP4_GET2BYTES( p_box->data.p_mdhd->predefined );
 
-    // #ifdef MP4_VERBOSE
-    //     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
-    //     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
-    //     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
-    //      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
-    //                   s_creation_time,
-    //                   s_modification_time,
-    //                   (uint32_t)p_box->data.p_mdhd->timescale,
-    //                   s_duration,
-    //                   p_box->data.p_mdhd->language[0],
-    //                   p_box->data.p_mdhd->language[1],
-    //                   p_box->data.p_mdhd->language[2] );
-    // #endif
+// #ifdef MP4_VERBOSE
+//     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
+//     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
+//     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
+//      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
+//                   s_creation_time,
+//                   s_modification_time,
+//                   (uint32_t)p_box->data.p_mdhd->timescale,
+//                   s_duration,
+//                   p_box->data.p_mdhd->language[0],
+//                   p_box->data.p_mdhd->language[1],
+//                   p_box->data.p_mdhd->language[2] );
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 }
@@ -869,9 +884,9 @@ static int MP4_ReadBox_hdlr( stream_t *p_stream, mp4_box_t *p_box )
     }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
-            (char*)&p_box->data.p_hdlr->handler_type,
-            p_box->data.p_hdlr->psz_name );
+         printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
+                   (char*)&p_box->data.p_hdlr->handler_type,
+                   p_box->data.p_hdlr->psz_name );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -884,25 +899,25 @@ static void MP4_FreeBox_hdlr( mp4_box_t *p_box )
 
 static int MP4_ReadBox_vmhd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
+   MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
 
-    MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
-    for( i = 0; i < 3; i++ )
-    {
-        MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
-    }
+   MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
+   for( i = 0; i < 3; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
+   }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
-            p_box->data.p_vmhd->i_graphics_mode,
-            p_box->data.p_vmhd->i_opcolor[0],
-            p_box->data.p_vmhd->i_opcolor[1],
-            p_box->data.p_vmhd->i_opcolor[2] );
+     printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
+                      p_box->data.p_vmhd->i_graphics_mode,
+                      p_box->data.p_vmhd->i_opcolor[0],
+                      p_box->data.p_vmhd->i_opcolor[1],
+                      p_box->data.p_vmhd->i_opcolor[2] );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
@@ -917,10 +932,10 @@ static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
 
     MP4_GET2BYTES( p_box->data.p_smhd->reserved );
 
-    // #ifdef MP4_VERBOSE
-    //      printf( "read box: \"smhd\" balance %f",
-    //                       (float)p_box->data.p_smhd->balance / 256 );
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"smhd\" balance %f",
+//                       (float)p_box->data.p_smhd->balance / 256 );
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 }
@@ -941,11 +956,11 @@ static int MP4_ReadBox_hmhd( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_hmhd->reserved );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
-            p_box->data.p_hmhd->max_PDU_size,
-            p_box->data.p_hmhd->avg_PDU_size,
-            p_box->data.p_hmhd->max_bitrate,
-            p_box->data.p_hmhd->avg_bitrate );
+     printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
+                      p_box->data.p_hmhd->max_PDU_size,
+                      p_box->data.p_hmhd->avg_PDU_size,
+                      p_box->data.p_hmhd->max_bitrate,
+                      p_box->data.p_hmhd->avg_bitrate );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -959,8 +974,8 @@ static int MP4_ReadBox_url( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GETSTRINGZ( p_box->data.p_url->psz_location );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"url\" url: %s",
-            p_box->data.p_url->psz_location );
+     printf( "read box: \"url\" url: %s",
+                       p_box->data.p_url->psz_location );
 
 #endif
     MP4_READBOX_EXIT( 1 );
@@ -982,9 +997,9 @@ static int MP4_ReadBox_urn( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"urn\" name %s location %s",
-            p_box->data.p_urn->psz_name,
-            p_box->data.p_urn->psz_location );
+     printf( "read box: \"urn\" name %s location %s",
+                      p_box->data.p_urn->psz_name,
+                      p_box->data.p_urn->psz_location );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1008,8 +1023,8 @@ static int MP4_ReadBox_dref( stream_t *p_stream, mp4_box_t *p_box )
     MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"dref\" entry-count %d",
-            p_box->data.p_dref->entry_count );
+     printf( "read box: \"dref\" entry-count %d",
+                      p_box->data.p_dref->entry_count );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1023,35 +1038,35 @@ static void MP4_FreeBox_stts( mp4_box_t *p_box )
 
 static int MP4_ReadBox_stts( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
-    MP4_READBOX_ENTER( mp4_box_data_stts_t );
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_stts_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stts );
-    MP4_GET4BYTES( p_box->data.p_stts->entry_count );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stts );
+   MP4_GET4BYTES( p_box->data.p_stts->entry_count );
 
-    p_box->data.p_stts->sample_count =
-        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stts->sample_delta =
-        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
-    if( p_box->data.p_stts->sample_count == NULL
-            || p_box->data.p_stts->sample_delta == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_stts->sample_count =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stts->sample_delta =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_stts->sample_count == NULL
+      || p_box->data.p_stts->sample_delta == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
-        MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
-    }
+   for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stts\" entry-count %d",
-            p_box->data.p_stts->entry_count );
+      p_box->data.p_stts->entry_count );
 
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1063,35 +1078,35 @@ static void MP4_FreeBox_ctts( mp4_box_t *p_box )
 
 static int MP4_ReadBox_ctts( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_ctts_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_ctts_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
+   MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
 
-    MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
+   MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
 
-    p_box->data.p_ctts->sample_count =
-        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
-    p_box->data.p_ctts->sample_offset =
-        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
-    if( ( p_box->data.p_ctts->sample_count == NULL )
-            || ( p_box->data.p_ctts->sample_offset == NULL ) )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_ctts->sample_count =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_ctts->sample_offset =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   if( ( p_box->data.p_ctts->sample_count == NULL )
+      || ( p_box->data.p_ctts->sample_offset == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
-        MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
-    }
+   for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"ctts\" entry-count %d",
-            p_box->data.p_ctts->entry_count );
+      p_box->data.p_ctts->entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1139,8 +1154,8 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
         i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-        printf( "found esds MPEG4ESDescr (%dBytes)",
-                i_len );
+         printf( "found esds MPEG4ESDescr (%dBytes)",
+                 i_len );
 #endif
 
         MP4_GET2BYTES( es_descriptor.ES_ID );
@@ -1181,19 +1196,19 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
 
     if( i_type != 0x04)/* MP4DecConfigDescrTag */
     {
-        es_descriptor.decConfigDescr = NULL;
-        MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
+         es_descriptor.decConfigDescr = NULL;
+         MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
     }
 
     i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-    printf( "found esds MP4DecConfigDescr (%dBytes)",
-            i_len );
+         printf( "found esds MP4DecConfigDescr (%dBytes)",
+                 i_len );
 #endif
 
     es_descriptor.decConfigDescr =
-        calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
+            calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
     if( unlikely( es_descriptor.decConfigDescr == NULL ) )
         MP4_READBOX_EXIT( 0 );
 
@@ -1215,8 +1230,8 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
     i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-    printf( "found esds MP4DecSpecificDescr (%dBytes)",
-            i_len );
+         printf( "found esds MP4DecSpecificDescr (%dBytes)",
+                 i_len );
 #endif
     if( i_len > i_read )
         MP4_READBOX_EXIT( 0 );
@@ -1324,23 +1339,23 @@ static int MP4_ReadBox_avcC( stream_t *p_stream, mp4_box_t *p_box )
             i_read -= p_avcC->pps_length[i];
         }
     }
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
-    //              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
-    //              p_avcC->i_length_size,
-    //              p_avcC->i_sps, p_avcC->i_pps );
-    //     for( i = 0; i < p_avcC->i_sps; i++ )
-    //     {
-    //          printf( "         - sps[%d] length=%d",
-    //                  i, p_avcC->i_sps_length[i] );
-    //     }
-    //     for( i = 0; i < p_avcC->i_pps; i++ )
-    //     {
-    //          printf( "         - pps[%d] length=%d",
-    //                  i, p_avcC->i_pps_length[i] );
-    //     }
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf(
+//              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
+//              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
+//              p_avcC->i_length_size,
+//              p_avcC->i_sps, p_avcC->i_pps );
+//     for( i = 0; i < p_avcC->i_sps; i++ )
+//     {
+//          printf( "         - sps[%d] length=%d",
+//                  i, p_avcC->i_sps_length[i] );
+//     }
+//     for( i = 0; i < p_avcC->i_pps; i++ )
+//     {
+//          printf( "         - pps[%d] length=%d",
+//                  i, p_avcC->i_pps_length[i] );
+//     }
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 
@@ -1356,7 +1371,7 @@ static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
     MP4_READBOX_ENTER( mp4_box_data_dac3_t );
 
     p_dac3 = p_box->data.p_dac3;
-
+    
     MP4_GET3BYTES( i_header );
 
     p_dac3->fscod = ( i_header >> 22 ) & 0x03;
@@ -1367,9 +1382,9 @@ static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
     p_dac3->bitrate_code = ( i_header >> 5) & 0x1f;
 
 #ifdef MP4_VERBOSE
-    printf(
-            "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
-            p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
+     printf(
+             "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
+             p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1385,8 +1400,8 @@ static int MP4_ReadBox_enda( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET2BYTES( p_enda->little_endian );
 
 #ifdef MP4_VERBOSE
-    printf(
-            "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
+     printf(
+             "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1415,7 +1430,7 @@ static int MP4_ReadBox_gnre( stream_t *p_stream, mp4_box_t *p_box )
     if( p_gnre->genre == 0 )
         MP4_READBOX_EXIT( 0 );
 #ifdef MP4_VERBOSE
-    printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
+     printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1442,17 +1457,17 @@ static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( i_reserved );
     MP4_GET4BYTES( p_trkn->track_number );
 
-    // #ifdef MP4_VERBOSE
-    //      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
+// #endif
 
     if( i_data_len > 15 )
     {
-        MP4_GET4BYTES( p_trkn->track_total );
+       MP4_GET4BYTES( p_trkn->track_total );
 
-        // #ifdef MP4_VERBOSE
-        //         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
-        // #endif
+// #ifdef MP4_VERBOSE
+//         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
+// #endif
 
     }
 
@@ -1462,420 +1477,420 @@ static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
-    p_box->data.p_sample_soun->qt_description = NULL;
-
-    /* Sanity check needed because the "wave" box does also contain an
-     * "mp4a" box that we don't understand. */
-    if( i_read < 28 )
-    {
-        i_read -= 30;
-        MP4_READBOX_EXIT( 1 );
-    }
-
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
-
-    /*
-     * XXX hack -> produce a copy of the nearly complete chunk
-     */
-    p_box->data.p_sample_soun->qt_description = 0;
-    p_box->data.p_sample_soun->p_qt_description = NULL;
-    if( i_read > 0 )
-    {
-        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
-        if( p_box->data.p_sample_soun->p_qt_description )
-        {
-            p_box->data.p_sample_soun->qt_description = i_read;
-            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
-        }
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
-    MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
-
-    if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
-    {
-        /* SoundDescriptionV1 */
-        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
+   p_box->data.p_sample_soun->qt_description = NULL;
+
+   /* Sanity check needed because the "wave" box does also contain an
+   * "mp4a" box that we don't understand. */
+   if( i_read < 28 )
+   {
+      i_read -= 30;
+      MP4_READBOX_EXIT( 1 );
+   }
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   p_box->data.p_sample_soun->qt_description = 0;
+   p_box->data.p_sample_soun->p_qt_description = NULL;
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
+      if( p_box->data.p_sample_soun->p_qt_description )
+      {
+         p_box->data.p_sample_soun->qt_description = i_read;
+         memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
+      }
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
+
+   if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
+   {
+      /* SoundDescriptionV1 */
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
 
 #ifdef MP4_VERBOSE
-        printf(
-                "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
-                "bytes/frame=%d bytes/sample=%d",
-                p_box->data.p_sample_soun->i_sample_per_packet,
-                p_box->data.p_sample_soun->i_bytes_per_packet,
-                p_box->data.p_sample_soun->i_bytes_per_frame,
-                p_box->data.p_sample_soun->i_bytes_per_sample );
+       printf(
+         "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
+         "bytes/frame=%d bytes/sample=%d",
+         p_box->data.p_sample_soun->i_sample_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_frame,
+         p_box->data.p_sample_soun->i_bytes_per_sample );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 44, SEEK_SET );
-    }
-    else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
-    {
-        /* SoundDescriptionV2 */
-        double f_sample_rate;
-        int64_t dummy;
-        uint32_t i_channel;
-
-        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
-        MP4_GET8BYTES( dummy );
-        memcpy( &f_sample_rate, &dummy, 8 );
-
-        printf( "read box: %f Hz", f_sample_rate );
-        p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
-        p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
-
-        MP4_GET4BYTES( i_channel );
-        p_box->data.p_sample_soun->channelcount = i_channel;
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 44, SEEK_SET );
+   }
+   else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
+   {
+      /* SoundDescriptionV2 */
+      double f_sample_rate;
+      int64_t dummy;
+      uint32_t i_channel;
+
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET8BYTES( dummy );
+      memcpy( &f_sample_rate, &dummy, 8 );
+
+       printf( "read box: %f Hz", f_sample_rate );
+      p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
+      p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
+
+      MP4_GET4BYTES( i_channel );
+      p_box->data.p_sample_soun->channelcount = i_channel;
 
 #ifdef MP4_VERBOSE
-        printf( "read box: \"soun\" V2" );
+       printf( "read box: \"soun\" V2" );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
-    }
-    else
-    {
-        p_box->data.p_sample_soun->sample_per_packet = 0;
-        p_box->data.p_sample_soun->bytes_per_packet = 0;
-        p_box->data.p_sample_soun->bytes_per_frame = 0;
-        p_box->data.p_sample_soun->bytes_per_sample = 0;
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
+   }
+   else
+   {
+      p_box->data.p_sample_soun->sample_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_frame = 0;
+      p_box->data.p_sample_soun->bytes_per_sample = 0;
 
 #ifdef MP4_VERBOSE
-        printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
-                i_read );
+       printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
+         i_read );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 28, SEEK_SET );
-    }
-
-    if( p_box->i_type == ATOM_drms )
-    {
-        assert(0);
-        //         char *home = config_GetUserDir( VLC_HOME_DIR );
-        //         if( home != NULL )
-        //         {
-        //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
-        //             if( p_box->data.p_sample_soun->p_drms == NULL )
-        //                 msg_Err( p_stream, "drms_alloc() failed" );
-        //         }
-    }
-
-    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
-    {
-        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
-        p_box->data.p_sample_soun->channelcount = 1;
-    }
-
-    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28, SEEK_SET );
+   }
+
+   if( p_box->i_type == ATOM_drms )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_soun->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
+   {
+      /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
+      p_box->data.p_sample_soun->channelcount = 1;
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"soun\" in stsd channel %d "
-            "sample size %d sample rate %f",
-            p_box->data.p_sample_soun->channelcount,
-            p_box->data.p_sample_soun->samplesize,
-            (float)p_box->data.p_sample_soun->sampleratehi +
-            (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
+      "sample size %d sample rate %f",
+      p_box->data.p_sample_soun->channelcount,
+      p_box->data.p_sample_soun->samplesize,
+      (float)p_box->data.p_sample_soun->sampleratehi +
+      (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 /*****************************************************************************
- * aes_s: AES keys structure
- *****************************************************************************
- * This structure stores a set of keys usable for encryption and decryption
- * with the AES/Rijndael algorithm.
- *****************************************************************************/
+* aes_s: AES keys structure
+*****************************************************************************
+* This structure stores a set of keys usable for encryption and decryption
+* with the AES/Rijndael algorithm.
+*****************************************************************************/
 #define AES_KEY_COUNT 10
 #define PATH_MAX 260
 struct aes_s
 {
-    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
-    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+   uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+   uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
 };
 
 /*****************************************************************************
- * drms_s: DRMS structure
- *****************************************************************************
- * This structure stores the static information needed to decrypt DRMS data.
- *****************************************************************************/
+* drms_s: DRMS structure
+*****************************************************************************
+* This structure stores the static information needed to decrypt DRMS data.
+*****************************************************************************/
 struct drms_s
 {
-    uint32_t i_user;
-    uint32_t i_key;
-    uint8_t  p_iviv[ 16 ];
-    uint8_t *p_name;
+   uint32_t i_user;
+   uint32_t i_key;
+   uint8_t  p_iviv[ 16 ];
+   uint8_t *p_name;
 
-    uint32_t p_key[ 4 ];
-    struct aes_s aes;
+   uint32_t p_key[ 4 ];
+   struct aes_s aes;
 
-    char     psz_homedir[ PATH_MAX ];
+   char     psz_homedir[ PATH_MAX ];
 };
 
 /*****************************************************************************
- * drms_free: free a previously allocated DRMS structure
- *****************************************************************************/
+* drms_free: free a previously allocated DRMS structure
+*****************************************************************************/
 void drms_free( void *_p_drms )
 {
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+   struct drms_s *p_drms = (struct drms_s *)_p_drms;
 
-    //free( (void *)p_drms->p_name );
-    free( p_drms->p_name );
-    free( p_drms );
+   //free( (void *)p_drms->p_name );
+   free( p_drms->p_name );
+   free( p_drms );
 }
 
 
 static void MP4_FreeBox_sample_soun( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_soun->p_qt_description );
+   FREENULL( p_box->data.p_sample_soun->p_qt_description );
 
-    if( p_box->i_type == ATOM_drms )
-    {
-        if( p_box->data.p_sample_soun->drms )
-        {
-            drms_free( p_box->data.p_sample_soun->drms );
-        }
-    }
+   if( p_box->i_type == ATOM_drms )
+   {
+      if( p_box->data.p_sample_soun->drms )
+      {
+         drms_free( p_box->data.p_sample_soun->drms );
+      }
+   }
 }
 
 
 int MP4_ReadBox_sample_vide( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
-
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
-
-    /*
-     * XXX hack -> produce a copy of the nearly complete chunk
-     */
-    if( i_read > 0 )
-    {
-        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
-        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
-            MP4_READBOX_EXIT( 0 );
-        p_box->data.p_sample_vide->qt_image_description = i_read;
-        memcpy( p_box->data.p_sample_vide->p_qt_image_description,
-                p_peek, i_read );
-    }
-    else
-    {
-        p_box->data.p_sample_vide->qt_image_description = 0;
-        p_box->data.p_sample_vide->p_qt_image_description = NULL;
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->width );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->height );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
-
-    memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
-    p_peek += 32; i_read -= 32;
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
-
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
-
-    if( p_box->i_type == ATOM_drmi )
-    {
-        assert(0);
-        //         char *home = config_GetUserDir( VLC_HOME_DIR );
-        //         if( home != NULL )
-        //         {
-        //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
-        //             if( p_box->data.p_sample_vide->p_drms == NULL )
-        //                 msg_Err( p_stream, "drms_alloc() failed" );
-        //         }
-    }
-
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
+      if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
+         MP4_READBOX_EXIT( 0 );
+      p_box->data.p_sample_vide->qt_image_description = i_read;
+      memcpy( p_box->data.p_sample_vide->p_qt_image_description,
+         p_peek, i_read );
+   }
+   else
+   {
+      p_box->data.p_sample_vide->qt_image_description = 0;
+      p_box->data.p_sample_vide->p_qt_image_description = NULL;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->width );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->height );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
+
+   memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
+   p_peek += 32; i_read -= 32;
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
+
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
+
+   if( p_box->i_type == ATOM_drmi )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_vide->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"vide\" in stsd %dx%d depth %d",
-            p_box->data.p_sample_vide->width,
-            p_box->data.p_sample_vide->height,
-            p_box->data.p_sample_vide->depth );
+      p_box->data.p_sample_vide->width,
+      p_box->data.p_sample_vide->height,
+      p_box->data.p_sample_vide->depth );
 
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 void MP4_FreeBox_sample_vide( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
+   FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
 
-    if( p_box->i_type == ATOM_drmi )
-    {
-        if( p_box->data.p_sample_vide->drms )
-        {
-            drms_free( p_box->data.p_sample_vide->drms );
-        }
-    }
+   if( p_box->i_type == ATOM_drmi )
+   {
+      if( p_box->data.p_sample_vide->drms )
+      {
+         drms_free( p_box->data.p_sample_vide->drms );
+      }
+   }
 }
 
 
 int MP4_ReadBox_sample_mmth( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    unsigned int  mmth_buf;
-    int j;
-    MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
+   unsigned int i = 0;
+   unsigned int  mmth_buf;
+   int j;
+   MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
 
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
-    }
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
+   }
 
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
 
 
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
-    MP4_GET1BYTE(mmth_buf);
-    p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
-    p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
-    p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
+   MP4_GET1BYTE(mmth_buf);
+   p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
+   p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
+   p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
 
-    /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
-      MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
-      p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
-      for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
-      {
+   /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
+   p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
+   for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
+	  {
 
-      MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
-      }*/
+	   MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
+	  }*/
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_sample_mp4s( stream_t *p_stream, mp4_box_t *p_box )
 {
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
-    return 1;
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
+   return 1;
 }
 
 static int MP4_ReadBox_sample_text( stream_t *p_stream, mp4_box_t *p_box )
 {
-    int32_t t;
-
-    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
-
-    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
-    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
-
-    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
-
-    MP4_GET4BYTES( t );
-    switch( t )
-    {
-        /* FIXME search right signification */
-        case 1: // Center
-            p_box->data.p_sample_text->justification_horizontal = 1;
-            p_box->data.p_sample_text->justification_vertical = 1;
-            break;
-        case -1:    // Flush Right
-            p_box->data.p_sample_text->justification_horizontal = -1;
-            p_box->data.p_sample_text->justification_vertical = -1;
-            break;
-        case -2:    // Flush p_first
-            p_box->data.p_sample_text->justification_horizontal = 0;
-            p_box->data.p_sample_text->justification_vertical = 0;
-            break;
-        case 0: // Flush Default
-        default:
-            p_box->data.p_sample_text->justification_horizontal = 1;
-            p_box->data.p_sample_text->justification_vertical = -1;
-            break;
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
-    p_box->data.p_sample_text->background_color[3] = 0;
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+   int32_t t;
+
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+   MP4_GET4BYTES( t );
+   switch( t )
+   {
+      /* FIXME search right signification */
+   case 1: // Center
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = 1;
+      break;
+   case -1:    // Flush Right
+      p_box->data.p_sample_text->justification_horizontal = -1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   case -2:    // Flush p_first
+      p_box->data.p_sample_text->justification_horizontal = 0;
+      p_box->data.p_sample_text->justification_vertical = 0;
+      break;
+   case 0: // Flush Default
+   default:
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
+   p_box->data.p_sample_text->background_color[3] = 0;
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"text\" in stsd text" );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
 
-    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
-    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
 
-    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
 
-    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
 
-    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
 
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
 
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"tx3g\" in stsd text" );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1883,7 +1898,7 @@ static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
 /* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */
 static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_text->psz_text_name );
+   FREENULL( p_box->data.p_sample_text->psz_text_name );
 }
 #endif
 
@@ -1891,2055 +1906,1952 @@ static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
 static int MP4_ReadBox_stsd( stream_t *p_stream, mp4_box_t *p_box )
 {
 
-    MP4_READBOX_ENTER( mp4_box_data_stsd_t );
+   MP4_READBOX_ENTER( mp4_box_data_stsd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
 
-    MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
 
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
 
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsd\" entry-count %d",
-            p_box->data.p_stsd->entry_count );
+      p_box->data.p_stsd->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_stsz( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsz_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsz_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
 
-    MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
-    MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
 
-    if( p_box->data.p_stsz->sample_size == 0 )
-    {
-        p_box->data.p_stsz->entry_size =
-            calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
-        if( unlikely( !p_box->data.p_stsz->entry_size ) )
-            MP4_READBOX_EXIT( 0 );
+   if( p_box->data.p_stsz->sample_size == 0 )
+   {
+      p_box->data.p_stsz->entry_size =
+         calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
+      if( unlikely( !p_box->data.p_stsz->entry_size ) )
+         MP4_READBOX_EXIT( 0 );
 
-        for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
-        {
-            MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
-        }
-    }
-    else
-        p_box->data.p_stsz->entry_size = NULL;
+      for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
+      {
+         MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
+      }
+   }
+   else
+      p_box->data.p_stsz->entry_size = NULL;
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsz\" sample-size %d sample-count %d",
-            p_box->data.p_stsz->sample_size,
-            p_box->data.p_stsz->sample_count );
+      p_box->data.p_stsz->sample_size,
+      p_box->data.p_stsz->sample_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stsz( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsz->entry_size );
+   FREENULL( p_box->data.p_stsz->entry_size );
 }
 
 static void MP4_FreeBox_stsc( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsc->first_chunk );
-    FREENULL( p_box->data.p_stsc->samples_per_chunk );
-    FREENULL( p_box->data.p_stsc->sample_description_index );
+   FREENULL( p_box->data.p_stsc->first_chunk );
+   FREENULL( p_box->data.p_stsc->samples_per_chunk );
+   FREENULL( p_box->data.p_stsc->sample_description_index );
 }
 
 static int MP4_ReadBox_stsc( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsc_t );
-
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
-
-    MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
-
-    p_box->data.p_stsc->first_chunk =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsc->samples_per_chunk =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsc->sample_description_index =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    if( unlikely( p_box->data.p_stsc->first_chunk == NULL
-                || p_box->data.p_stsc->samples_per_chunk == NULL
-                || p_box->data.p_stsc->sample_description_index == NULL ) )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
-
-    for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
-        MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
-        MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
-    }
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsc_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
+
+   MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
+
+   p_box->data.p_stsc->first_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->samples_per_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->sample_description_index =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stsc->first_chunk == NULL
+      || p_box->data.p_stsc->samples_per_chunk == NULL
+      || p_box->data.p_stsc->sample_description_index == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsc\" entry-count %d",
-            p_box->data.p_stsc->entry_count );
+      p_box->data.p_stsc->entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_stco_co64( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_co64_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_co64_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
+   MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
 
-    MP4_GET4BYTES( p_box->data.p_co64->entry_count );
+   MP4_GET4BYTES( p_box->data.p_co64->entry_count );
 
-    p_box->data.p_co64->chunk_offset =
-        calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
-    if( p_box->data.p_co64->chunk_offset == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_co64->chunk_offset =
+      calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
+   if( p_box->data.p_co64->chunk_offset == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
-    {
-        if( p_box->i_type == ATOM_stco )
-        {
-            if( i_read < 4 )
-            {
-                break;
-            }
-            MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
-        }
-        else
-        {
-            if( i_read < 8 )
-            {
-                break;
-            }
-            MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
-        }
-    }
+   for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
+   {
+      if( p_box->i_type == ATOM_stco )
+      {
+         if( i_read < 4 )
+         {
+            break;
+         }
+         MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+      else
+      {
+         if( i_read < 8 )
+         {
+            break;
+         }
+         MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"co64\" entry-count %d",
-            p_box->data.p_co64->entry_count );
+      p_box->data.p_co64->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stco_co64( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_co64->chunk_offset );
+   FREENULL( p_box->data.p_co64->chunk_offset );
 }
 
 static int MP4_ReadBox_stss( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stss_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stss_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stss );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stss );
 
-    MP4_GET4BYTES( p_box->data.p_stss->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stss->entry_count );
 
-    p_box->data.p_stss->sample_number =
-        calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
-    if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_stss->sample_number =
+      calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
-    {
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
+   {
 
-        MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
-        /* XXX in libmp4 sample begin at 0 */
-        p_box->data.p_stss->sample_number[i]--;
-    }
+      MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
+      /* XXX in libmp4 sample begin at 0 */
+      p_box->data.p_stss->sample_number[i]--;
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stss\" entry-count %d",
-            p_box->data.p_stss->i_entry_count );
+      p_box->data.p_stss->i_entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stss( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stss->sample_number );
+   FREENULL( p_box->data.p_stss->sample_number );
 }
 
 static void MP4_FreeBox_stsh( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsh->shadowed_sample_number );
-    FREENULL( p_box->data.p_stsh->sync_sample_number );
+   FREENULL( p_box->data.p_stsh->shadowed_sample_number );
+   FREENULL( p_box->data.p_stsh->sync_sample_number );
 }
 
 static int MP4_ReadBox_stsh( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsh_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsh_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
 
 
-    MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
 
-    p_box->data.p_stsh->shadowed_sample_number =
-        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsh->sync_sample_number =
-        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsh->shadowed_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsh->sync_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
 
-    if( p_box->data.p_stsh->shadowed_sample_number == NULL
-            || p_box->data.p_stsh->sync_sample_number == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   if( p_box->data.p_stsh->shadowed_sample_number == NULL
+      || p_box->data.p_stsh->sync_sample_number == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
-        MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
-    }
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
+      MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsh\" entry-count %d",
-            p_box->data.p_stsh->i_entry_count );
+      p_box->data.p_stsh->i_entry_count );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_stdp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stdp_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stdp_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
 
-    p_box->data.p_stdp->priority =
-        calloc( i_read / 2, sizeof(uint16_t) );
+   p_box->data.p_stdp->priority =
+      calloc( i_read / 2, sizeof(uint16_t) );
 
-    if( unlikely( !p_box->data.p_stdp->priority ) )
-        MP4_READBOX_EXIT( 0 );
+   if( unlikely( !p_box->data.p_stdp->priority ) )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < i_read / 2 ; i++ )
-    {
-        MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
-    }
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stdp\" entry-count %"PRId64,
-            i_read / 2 );
+      i_read / 2 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stdp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stdp->priority );
+   FREENULL( p_box->data.p_stdp->priority );
 }
 
 static void MP4_FreeBox_padb( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_padb->reserved1 );
-    FREENULL( p_box->data.p_padb->pad2 );
-    FREENULL( p_box->data.p_padb->reserved2 );
-    FREENULL( p_box->data.p_padb->pad1 );
+   FREENULL( p_box->data.p_padb->reserved1 );
+   FREENULL( p_box->data.p_padb->pad2 );
+   FREENULL( p_box->data.p_padb->reserved2 );
+   FREENULL( p_box->data.p_padb->pad1 );
 }
 
 static int MP4_ReadBox_padb( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t count;
-    unsigned int i = 0;
+   uint32_t count;
+   unsigned int i = 0;
 
-    MP4_READBOX_ENTER( mp4_box_data_padb_t );
+   MP4_READBOX_ENTER( mp4_box_data_padb_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_padb );
+   MP4_GETVERSIONFLAGS( p_box->data.p_padb );
 
-    MP4_GET4BYTES( p_box->data.p_padb->sample_count );
-    count = (p_box->data.p_padb->sample_count + 1) / 2;
+   MP4_GET4BYTES( p_box->data.p_padb->sample_count );
+   count = (p_box->data.p_padb->sample_count + 1) / 2;
 
-    p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
-    if( p_box->data.p_padb->reserved1 == NULL
-            || p_box->data.p_padb->pad2 == NULL
-            || p_box->data.p_padb->reserved2 == NULL
-            || p_box->data.p_padb->pad1 == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
+   if( p_box->data.p_padb->reserved1 == NULL
+      || p_box->data.p_padb->pad2 == NULL
+      || p_box->data.p_padb->reserved2 == NULL
+      || p_box->data.p_padb->pad1 == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; i < i_read / 2 ; i++ )
-    {
-        if( i >= count )
-        {
-            MP4_READBOX_EXIT( 0 );
-        }
-        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
-        p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
-        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
-        p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      if( i >= count )
+      {
+         MP4_READBOX_EXIT( 0 );
+      }
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
+      p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
+      p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
 
-        p_peek += 1; i_read -= 1;
-    }
+      p_peek += 1; i_read -= 1;
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stdp\" entry-count %"PRId64,
-            i_read / 2 );
+      i_read / 2 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_elst( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_elst->segment_duration );
-    FREENULL( p_box->data.p_elst->media_time );
-    FREENULL( p_box->data.p_elst->media_rate_integer );
-    FREENULL( p_box->data.p_elst->media_rate_fraction );
+   FREENULL( p_box->data.p_elst->segment_duration );
+   FREENULL( p_box->data.p_elst->media_time );
+   FREENULL( p_box->data.p_elst->media_rate_integer );
+   FREENULL( p_box->data.p_elst->media_rate_fraction );
 }
 
 static int MP4_ReadBox_elst( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_elst_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_elst_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_elst );
+   MP4_GETVERSIONFLAGS( p_box->data.p_elst );
 
 
-    MP4_GET4BYTES( p_box->data.p_elst->entry_count );
+   MP4_GET4BYTES( p_box->data.p_elst->entry_count );
 
-    p_box->data.p_elst->segment_duration =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
-    p_box->data.p_elst->media_time =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
-    p_box->data.p_elst->media_rate_integer =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
-    p_box->data.p_elst->media_rate_fraction =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
-    if( p_box->data.p_elst->segment_duration == NULL
-            || p_box->data.p_elst->media_time == NULL
-            || p_box->data.p_elst->media_rate_integer == NULL
-            || p_box->data.p_elst->media_rate_fraction == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_elst->segment_duration =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_time =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_rate_integer =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   p_box->data.p_elst->media_rate_fraction =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   if( p_box->data.p_elst->segment_duration == NULL
+      || p_box->data.p_elst->media_time == NULL
+      || p_box->data.p_elst->media_rate_integer == NULL
+      || p_box->data.p_elst->media_rate_fraction == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
 
-    for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
-    {
-        if( p_box->data.p_elst->version == 1 )
-        {
+   for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
+   {
+      if( p_box->data.p_elst->version == 1 )
+      {
 
-            MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
+         MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
 
-            MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
-        }
-        else
-        {
+         MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
+      }
+      else
+      {
 
-            MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
+         MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
 
-            MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
-            p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
-        }
+         MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
+         p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
+      }
 
-        MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
-        MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
-    }
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"elst\" entry-count %lu",
-            (unsigned long)p_box->data.p_elst->entry_count );
+      (unsigned long)p_box->data.p_elst->entry_count );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i_language;
-    unsigned int i = 0;
+   unsigned int i_language;
+   unsigned int i = 0;
 
-    MP4_READBOX_ENTER( mp4_box_data_cprt_t );
+   MP4_READBOX_ENTER( mp4_box_data_cprt_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
+   MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
 
-    i_language = SwapBE16( p_peek );
-    for( i = 0; i < 3; i++ )
-    {
-        p_box->data.p_cprt->language[i] =
-            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
-    }
-    p_peek += 2; i_read -= 2;
-    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
+   i_language = SwapBE16( p_peek );
+   for( i = 0; i < 3; i++ )
+   {
+      p_box->data.p_cprt->language[i] =
+         ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+   }
+   p_peek += 2; i_read -= 2;
+   MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cprt\" language %c%c%c notice %s",
-            p_box->data.p_cprt->language[0],
-            p_box->data.p_cprt->language[1],
-            p_box->data.p_cprt->language[2],
-            p_box->data.p_cprt->psz_notice );
+      p_box->data.p_cprt->language[0],
+      p_box->data.p_cprt->language[1],
+      p_box->data.p_cprt->language[2],
+      p_box->data.p_cprt->psz_notice );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_cprt( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_cprt->psz_notice );
+   FREENULL( p_box->data.p_cprt->psz_notice );
 }
 
 
 static int MP4_ReadBox_dcom( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_dcom_t );
+   MP4_READBOX_ENTER( mp4_box_data_dcom_t );
 
-    MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
+   MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"dcom\" compression algorithm : %4.4s",
-            (char*)&p_box->data.p_dcom->algorithm );
+      "read box: \"dcom\" compression algorithm : %4.4s",
+      (char*)&p_box->data.p_dcom->algorithm );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_cmvd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
+   MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
 
-    MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
+   MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
 
-    p_box->data.p_cmvd->compressed_size = i_read;
+   p_box->data.p_cmvd->compressed_size = i_read;
 
-    if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
-        MP4_READBOX_EXIT( 0 );
+   if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
+      MP4_READBOX_EXIT( 0 );
 
-    /* now copy compressed data */
-    memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
+   /* now copy compressed data */
+   memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
 
-    p_box->data.p_cmvd->b_compressed = 1;
+   p_box->data.p_cmvd->b_compressed = 1;
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cmvd\" compressed data size %d",
-            p_box->data.p_cmvd->compressed_size );
+      p_box->data.p_cmvd->compressed_size );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 static void MP4_FreeBox_cmvd( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_cmvd->data );
+   FREENULL( p_box->data.p_cmvd->data );
 }
 
 
 static int MP4_ReadBox_cmov( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t *p_dcom;
-    mp4_box_t *p_cmvd;
+   mp4_box_t *p_dcom;
+   mp4_box_t *p_cmvd;
 
 #ifdef HAVE_ZLIB_H
-    stream_t *p_stream_memory;
-    z_stream z_data;
-    uint8_t *p_data;
-    int i_result;
+   stream_t *p_stream_memory;
+   z_stream z_data;
+   uint8_t *p_data;
+   int i_result;
 #endif
 
-    if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
-        return 0;
-
-    if( !p_box->p_father ||
-            ( p_box->p_father->i_type != ATOM_moov &&
-              p_box->p_father->i_type != ATOM_foov ) )
-    {
-        printf( "Read box: \"cmov\" box alone" );
-        return 1;
-    }
-
-    if( !MP4_ReadBoxContainer( p_stream, p_box ) )
-    {
-        return 0;
-    }
-
-    if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
-            ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
-            p_cmvd->data.p_cmvd->data == NULL )
-    {
-        printf( "read box: \"cmov\" incomplete" );
-        return 0;
-    }
-
-    if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
-    {
-        printf( "read box: \"cmov\" compression algorithm : %4.4s "
-                "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
-        return 0;
-    }
+   if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
+      return 0;
+
+   if( !p_box->p_father ||
+      ( p_box->p_father->i_type != ATOM_moov &&
+      p_box->p_father->i_type != ATOM_foov ) )
+   {
+      printf( "Read box: \"cmov\" box alone" );
+      return 1;
+   }
+
+   if( !MP4_ReadBoxContainer( p_stream, p_box ) )
+   {
+      return 0;
+   }
+
+   if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
+      ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
+      p_cmvd->data.p_cmvd->data == NULL )
+   {
+      printf( "read box: \"cmov\" incomplete" );
+      return 0;
+   }
+
+   if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
+   {
+      printf( "read box: \"cmov\" compression algorithm : %4.4s "
+         "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
+      return 0;
+   }
 
 #ifndef HAVE_ZLIB_H
-    printf(  "read box: \"cmov\" zlib unsupported" );
-    return 0;
+   printf(  "read box: \"cmov\" zlib unsupported" );
+   return 0;
 #else
 
-    /* decompress data */
-    /* allocate a new buffer */
-    if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
-        return 0;
-    /* init default structures */
-    z_data.next_in   = p_cmvd->data.p_cmvd->data;
-    z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
-    z_data.next_out  = p_data;
-    z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
-    z_data.zalloc    = (alloc_func)Z_NULL;
-    z_data.zfree     = (free_func)Z_NULL;
-    z_data.opaque    = (voidpf)Z_NULL;
-
-    /* init zlib */
-    if( inflateInit( &z_data ) != Z_OK )
-    {
-        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
-        free( p_data );
-        return 0;
-    }
-
-    /* uncompress */
-    i_result = inflate( &z_data, Z_NO_FLUSH );
-    if( i_result != Z_OK && i_result != Z_STREAM_END )
-    {
-        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
-        free( p_data );
-        return 0;
-    }
-
-    if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
-    {
-        printf( "read box: \"cmov\" uncompressing data size "
-                "mismatch" );
-    }
-    p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
-
-    /* close zlib */
-    if( inflateEnd( &z_data ) != Z_OK )
-    {
-        printf( "read box: \"cmov\" error while uncompressing "
-                "data (ignored)" );
-    }
-
-    free( p_cmvd->data.p_cmvd->p_data );
-    p_cmvd->data.p_cmvd->data = p_data;
-    p_cmvd->data.p_cmvd->b_compressed = 0;
+   /* decompress data */
+   /* allocate a new buffer */
+   if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
+      return 0;
+   /* init default structures */
+   z_data.next_in   = p_cmvd->data.p_cmvd->data;
+   z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
+   z_data.next_out  = p_data;
+   z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
+   z_data.zalloc    = (alloc_func)Z_NULL;
+   z_data.zfree     = (free_func)Z_NULL;
+   z_data.opaque    = (voidpf)Z_NULL;
+
+   /* init zlib */
+   if( inflateInit( &z_data ) != Z_OK )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   /* uncompress */
+   i_result = inflate( &z_data, Z_NO_FLUSH );
+   if( i_result != Z_OK && i_result != Z_STREAM_END )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
+   {
+      printf( "read box: \"cmov\" uncompressing data size "
+         "mismatch" );
+   }
+   p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
+
+   /* close zlib */
+   if( inflateEnd( &z_data ) != Z_OK )
+   {
+      printf( "read box: \"cmov\" error while uncompressing "
+         "data (ignored)" );
+   }
+
+   free( p_cmvd->data.p_cmvd->p_data );
+   p_cmvd->data.p_cmvd->data = p_data;
+   p_cmvd->data.p_cmvd->b_compressed = 0;
 
     printf( "read box: \"cmov\" box successfully uncompressed" );
 
-    /* now create a memory stream */
-    p_stream_memory =
-        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
-                p_cmvd->data.p_cmvd->uncompressed_size, true );
+   /* now create a memory stream */
+   p_stream_memory =
+      stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
+      p_cmvd->data.p_cmvd->uncompressed_size, true );
 
-    /* and read uncompressd moov */
-    p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
+   /* and read uncompressd moov */
+   p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
 
-    stream_Delete( p_stream_memory );
+   stream_Delete( p_stream_memory );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cmov\" compressed movie header completed");
 #endif
 
-    return p_box->data.p_cmov->moov ? 1 : 0;
+   return p_box->data.p_cmov->moov ? 1 : 0;
 #endif /* HAVE_ZLIB_H */
 }
 
 static int MP4_ReadBox_rdrf( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_len;
-    unsigned i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
+   uint32_t i_len;
+   unsigned i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
-    MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
-    MP4_GET4BYTES( i_len );
-    i_len++;
+   MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
+   MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
+   MP4_GET4BYTES( i_len );
+   i_len++;
 
-    if( i_len > 0 )
-    {
-        p_box->data.p_rdrf->psz_ref = malloc( i_len );
-        if( p_box->data.p_rdrf->psz_ref == NULL )
-            MP4_READBOX_EXIT( 0 );
-        i_len--;
+   if( i_len > 0 )
+   {
+      p_box->data.p_rdrf->psz_ref = malloc( i_len );
+      if( p_box->data.p_rdrf->psz_ref == NULL )
+         MP4_READBOX_EXIT( 0 );
+      i_len--;
 
-        for( i = 0; i < i_len; i++ )
-        {
-            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
-        }
-        p_box->data.p_rdrf->psz_ref[i_len] = '\0';
-    }
-    else
-    {
-        p_box->data.p_rdrf->psz_ref = NULL;
-    }
+      for( i = 0; i < i_len; i++ )
+      {
+         MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
+      }
+      p_box->data.p_rdrf->psz_ref[i_len] = '\0';
+   }
+   else
+   {
+      p_box->data.p_rdrf->psz_ref = NULL;
+   }
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rdrf\" type:%4.4s ref %s",
-            (char*)&p_box->data.p_rdrf->ref_type,
-            p_box->data.p_rdrf->psz_ref );
+      "read box: \"rdrf\" type:%4.4s ref %s",
+      (char*)&p_box->data.p_rdrf->ref_type,
+      p_box->data.p_rdrf->psz_ref );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_rdrf( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_rdrf->psz_ref );
+   FREENULL( p_box->data.p_rdrf->psz_ref );
 }
 
 
 static int MP4_ReadBox_rmdr( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
+   MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
 
-    MP4_GET4BYTES( p_box->data.p_rmdr->rate );
+   MP4_GET4BYTES( p_box->data.p_rmdr->rate );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmdr\" rate:%d",
-            p_box->data.p_rmdr->rate );
+      "read box: \"rmdr\" rate:%d",
+      p_box->data.p_rmdr->rate );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_rmqu( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
+   MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
 
-    MP4_GET4BYTES( p_box->data.p_rmqu->quality );
+   MP4_GET4BYTES( p_box->data.p_rmqu->quality );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmqu\" quality:%d",
-            p_box->data.p_rmqu->quality );
+      "read box: \"rmqu\" quality:%d",
+      p_box->data.p_rmqu->quality );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_rmvc( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
+   MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
 
-    MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
-    MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
-    MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
-    MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
+   MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
+   MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
-            (char*)&p_box->data.p_rmvc->gestaltType,
-            p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
-            p_box->data.p_rmvc->checkType );
+      "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
+      (char*)&p_box->data.p_rmvc->gestaltType,
+      p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
+      p_box->data.p_rmvc->checkType );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_frma( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_frma_t );
+   MP4_READBOX_ENTER( mp4_box_data_frma_t );
 
-    MP4_GETFOURCC( p_box->data.p_frma->type );
+   MP4_GETFOURCC( p_box->data.p_frma->type );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"frma\" i_type:%4.4s",
-            (char *)&p_box->data.p_frma->i_type );
+      (char *)&p_box->data.p_frma->i_type );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_skcr( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_skcr_t );
+   MP4_READBOX_ENTER( mp4_box_data_skcr_t );
 
-    MP4_GET4BYTES( p_box->data.p_skcr->init );
-    MP4_GET4BYTES( p_box->data.p_skcr->encr );
-    MP4_GET4BYTES( p_box->data.p_skcr->decr );
+   MP4_GET4BYTES( p_box->data.p_skcr->init );
+   MP4_GET4BYTES( p_box->data.p_skcr->encr );
+   MP4_GET4BYTES( p_box->data.p_skcr->decr );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"skcr\" i_init:%d i_encr:%d i_decr:%d",
-            p_box->data.p_skcr->init,
-            p_box->data.p_skcr->encr,
-            p_box->data.p_skcr->decr );
+      p_box->data.p_skcr->init,
+      p_box->data.p_skcr->encr,
+      p_box->data.p_skcr->decr );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_drms( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t *p_drms_box = p_box;
-    void *p_drms = NULL;
+   mp4_box_t *p_drms_box = p_box;
+   void *p_drms = NULL;
 
-    MP4_READBOX_ENTER( uint8_t );
+   MP4_READBOX_ENTER( uint8_t );
 
-    do
-    {
-        p_drms_box = p_drms_box->p_father;
-    } while( p_drms_box && p_drms_box->i_type != ATOM_drms
-            && p_drms_box->i_type != ATOM_drmi );
+   do
+   {
+      p_drms_box = p_drms_box->p_father;
+   } while( p_drms_box && p_drms_box->i_type != ATOM_drms
+      && p_drms_box->i_type != ATOM_drmi );
 
-    if( p_drms_box && p_drms_box->i_type == ATOM_drms )
-        p_drms = p_drms_box->data.p_sample_soun->drms;
-    else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
-        p_drms = p_drms_box->data.p_sample_vide->drms;
-
-    if( p_drms_box && p_drms )
-    {
-        int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
-        if( i_ret )
-        {
-            assert(0);
-            //             const char *psz_error;
-            // 
-            //             switch( i_ret )
-            //             {
-            //                 case -1: psz_error = "unimplemented"; break;
-            //                 case -2: psz_error = "invalid argument"; break;
-            //                 case -3: psz_error = "could not get system key"; break;
-            //                 case -4: psz_error = "could not get SCI data"; break;
-            //                 case -5: psz_error = "no user key found in SCI data"; break;
-            //                 case -6: psz_error = "invalid user key"; break;
-            //                 default: psz_error = "unknown error"; break;
-            //             }
-            //             if MP4_BOX_TYPE_ASCII()
-            //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
-            //                         (char *)&p_box->i_type, psz_error );
-            //             else
-            //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
-            //                         (char *)&p_box->i_type+1, psz_error );
-            // 
-            //             drms_free( p_drms );
-            // 
-            //             if( p_drms_box->i_type == ATOM_drms )
-            //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
-            //             else if( p_drms_box->i_type == ATOM_drmi )
-            //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
-        }
-    }
+   if( p_drms_box && p_drms_box->i_type == ATOM_drms )
+      p_drms = p_drms_box->data.p_sample_soun->drms;
+   else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
+      p_drms = p_drms_box->data.p_sample_vide->drms;
 
-    MP4_READBOX_EXIT( 1 );
+   if( p_drms_box && p_drms )
+   {
+      int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
+      if( i_ret )
+      {
+         assert(0);
+         //             const char *psz_error;
+         // 
+         //             switch( i_ret )
+         //             {
+         //                 case -1: psz_error = "unimplemented"; break;
+         //                 case -2: psz_error = "invalid argument"; break;
+         //                 case -3: psz_error = "could not get system key"; break;
+         //                 case -4: psz_error = "could not get SCI data"; break;
+         //                 case -5: psz_error = "no user key found in SCI data"; break;
+         //                 case -6: psz_error = "invalid user key"; break;
+         //                 default: psz_error = "unknown error"; break;
+         //             }
+         //             if MP4_BOX_TYPE_ASCII()
+         //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
+         //                         (char *)&p_box->i_type, psz_error );
+         //             else
+         //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
+         //                         (char *)&p_box->i_type+1, psz_error );
+         // 
+         //             drms_free( p_drms );
+         // 
+         //             if( p_drms_box->i_type == ATOM_drms )
+         //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
+         //             else if( p_drms_box->i_type == ATOM_drmi )
+         //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
+      }
+   }
+
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_name( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_name_t );
+   MP4_READBOX_ENTER( mp4_box_data_name_t );
 
-    p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
-    if( p_box->data.p_name->psz_text == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
+   if( p_box->data.p_name->psz_text == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
-    p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
+   memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
+   p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"name\" text=`%s'",
-            p_box->data.p_name->psz_text );
+      p_box->data.p_name->psz_text );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_name( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_name->psz_text );
+   FREENULL( p_box->data.p_name->psz_text );
 }
 
 static int MP4_ReadBox_0xa9xxx( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint16_t i16;
+   uint16_t i16;
 
-    MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
+   MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
 
-    p_box->data.p_0xa9xxx->psz_text = NULL;
+   p_box->data.p_0xa9xxx->psz_text = NULL;
 
-    MP4_GET2BYTES( i16 );
+   MP4_GET2BYTES( i16 );
 
-    if( i16 > 0 )
-    {
-        int i_length = i16;
+   if( i16 > 0 )
+   {
+      int i_length = i16;
 
-        MP4_GET2BYTES( i16 );
-        if( i_length >= i_read ) i_length = i_read + 1;
+      MP4_GET2BYTES( i16 );
+      if( i_length >= i_read ) i_length = i_read + 1;
 
-        p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
-        if( p_box->data.p_0xa9xxx->psz_text == NULL )
-            MP4_READBOX_EXIT( 0 );
+      p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
+      if( p_box->data.p_0xa9xxx->psz_text == NULL )
+         MP4_READBOX_EXIT( 0 );
 
-        i_length--;
-        memcpy( p_box->data.p_0xa9xxx->psz_text,
-                p_peek, i_length );
-        p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
+      i_length--;
+      memcpy( p_box->data.p_0xa9xxx->psz_text,
+         p_peek, i_length );
+      p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
 
 #ifdef MP4_VERBOSE
-        printf(
-                "read box: \"c%3.3s\" text=`%s'",
-                ((char*)&p_box->i_type + 1),
-                p_box->data.p_0xa9xxx->psz_text );
+       printf(
+         "read box: \"c%3.3s\" text=`%s'",
+         ((char*)&p_box->i_type + 1),
+         p_box->data.p_0xa9xxx->psz_text );
 #endif
-    }
-    else
-    {
-        uint32_t i_data_len;
-        uint32_t i_data_tag;
-        /* try iTune/Quicktime format, rewind to start */
-        p_peek -= 2; i_read += 2;
-        // we are expecting a 'data' box
-
-        MP4_GET4BYTES( i_data_len );
-        if( i_data_len > i_read ) i_data_len = i_read;
-        MP4_GETFOURCC( i_data_tag );
-        if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
-        {
-            /* data box contains a version/flags field */
-            uint32_t i_version;
-            uint32_t i_reserved;
-            MP4_GET4BYTES( i_version );
-            MP4_GET4BYTES( i_reserved );
-            // version should be 0, flags should be 1 for text, 0 for data
-            if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
-            {
-                // the rest is the text
-                i_data_len -= 12;
-                p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
-                if( p_box->data.p_0xa9xxx->psz_text == NULL )
-                    MP4_READBOX_EXIT( 0 );
-
-                memcpy( p_box->data.p_0xa9xxx->psz_text,
-                        p_peek, i_data_len );
-                p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
+   }
+   else
+   {
+      uint32_t i_data_len;
+      uint32_t i_data_tag;
+      /* try iTune/Quicktime format, rewind to start */
+      p_peek -= 2; i_read += 2;
+      // we are expecting a 'data' box
+
+      MP4_GET4BYTES( i_data_len );
+      if( i_data_len > i_read ) i_data_len = i_read;
+      MP4_GETFOURCC( i_data_tag );
+      if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
+      {
+         /* data box contains a version/flags field */
+         uint32_t i_version;
+         uint32_t i_reserved;
+         MP4_GET4BYTES( i_version );
+         MP4_GET4BYTES( i_reserved );
+         // version should be 0, flags should be 1 for text, 0 for data
+         if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
+         {
+            // the rest is the text
+            i_data_len -= 12;
+            p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
+            if( p_box->data.p_0xa9xxx->psz_text == NULL )
+               MP4_READBOX_EXIT( 0 );
+
+            memcpy( p_box->data.p_0xa9xxx->psz_text,
+               p_peek, i_data_len );
+            p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
 #ifdef MP4_VERBOSE
-                printf(
-                        "read box: \"c%3.3s\" text=`%s'",
-                        ((char*)&p_box->i_type+1),
-                        p_box->data.p_0xa9xxx->psz_text );
+             printf(
+               "read box: \"c%3.3s\" text=`%s'",
+               ((char*)&p_box->i_type+1),
+               p_box->data.p_0xa9xxx->psz_text );
 #endif
-            }
-            else
-            {
-                // TODO: handle data values for ID3 tag values, track num or cover art,etc...
-            }
-        }
-    }
+         }
+         else
+         {
+            // TODO: handle data values for ID3 tag values, track num or cover art,etc...
+         }
+      }
+   }
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 static void MP4_FreeBox_0xa9xxx( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_0xa9xxx->psz_text );
+   FREENULL( p_box->data.p_0xa9xxx->psz_text );
 }
 
 /* Chapter support */
 static void MP4_FreeBox_chpl( mp4_box_t *p_box )
 {
-    mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
-    unsigned int i;
-    for(  i = 0; i < p_chpl->chapter; i++ )
-        free( p_chpl->p_chapter[i].psz_name );
+   mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
+   unsigned int i;
+   for(  i = 0; i < p_chpl->chapter; i++ )
+      free( p_chpl->p_chapter[i].psz_name );
 }
 
 static int MP4_ReadBox_chpl( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_data_chpl_t *p_chpl;
-    uint32_t i_dummy;
-    int i;
-    MP4_READBOX_ENTER( mp4_box_data_chpl_t );
+   mp4_box_data_chpl_t *p_chpl;
+   uint32_t i_dummy;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_chpl_t );
 
-    p_chpl = p_box->data.p_chpl;
+   p_chpl = p_box->data.p_chpl;
 
-    MP4_GETVERSIONFLAGS( p_chpl );
+   MP4_GETVERSIONFLAGS( p_chpl );
 
-    MP4_GET4BYTES( i_dummy );
+   MP4_GET4BYTES( i_dummy );
 
-    MP4_GET1BYTE( p_chpl->chapter );
+   MP4_GET1BYTE( p_chpl->chapter );
 
-    for( i = 0; i < p_chpl->chapter; i++ )
-    {
-        uint64_t i_start;
-        uint8_t i_len;
-        int i_copy;
-        MP4_GET8BYTES( i_start );
-        MP4_GET1BYTE( i_len );
-
-        p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
-        if( !p_chpl->p_chapter[i].psz_name )
-            MP4_READBOX_EXIT( 0 );
+   for( i = 0; i < p_chpl->chapter; i++ )
+   {
+      uint64_t i_start;
+      uint8_t i_len;
+      int i_copy;
+      MP4_GET8BYTES( i_start );
+      MP4_GET1BYTE( i_len );
 
-        i_copy = min( i_len, i_read );
-        if( i_copy > 0 )
-            memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
-        p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
-        p_chpl->p_chapter[i].start = i_start;
+      p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
+      if( !p_chpl->p_chapter[i].psz_name )
+         MP4_READBOX_EXIT( 0 );
 
-        p_peek += i_copy;
-        i_read -= i_copy;
-    }
-    /* Bubble sort by increasing start date */
-    do
-    {
-        for( i = 0; i < p_chpl->chapter - 1; i++ )
-        {
-            if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
-            {
-                char *psz = p_chpl->p_chapter[i+1].psz_name;
-                int64_t i64 = p_chpl->p_chapter[i+1].start;
+      i_copy = min( i_len, i_read );
+      if( i_copy > 0 )
+         memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
+      p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
+      p_chpl->p_chapter[i].start = i_start;
 
-                p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
-                p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
+      p_peek += i_copy;
+      i_read -= i_copy;
+   }
+   /* Bubble sort by increasing start date */
+   do
+   {
+      for( i = 0; i < p_chpl->chapter - 1; i++ )
+      {
+         if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
+         {
+            char *psz = p_chpl->p_chapter[i+1].psz_name;
+            int64_t i64 = p_chpl->p_chapter[i+1].start;
 
-                p_chpl->p_chapter[i].psz_name = psz;
-                p_chpl->p_chapter[i].start = i64;
+            p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
+            p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
 
-                i = -1;
-                break;
-            }
-        }
-    } while( i == -1 );
+            p_chpl->p_chapter[i].psz_name = psz;
+            p_chpl->p_chapter[i].start = i64;
+
+            i = -1;
+            break;
+         }
+      }
+   } while( i == -1 );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"chpl\" %d chapters",
-            p_chpl->chapter );
+      p_chpl->chapter );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tref_generic( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
-    MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
 
-    p_box->data.p_tref_generic->track_ID = NULL;
-    p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
-    if( p_box->data.p_tref_generic->entry_count > 0 )
-        p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
-    if( p_box->data.p_tref_generic->track_ID == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_tref_generic->track_ID = NULL;
+   p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
+   if( p_box->data.p_tref_generic->entry_count > 0 )
+      p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_tref_generic->track_ID == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
-    }
+   for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"chap\" %d references",
-            p_box->data.p_tref_generic->entry_count );
+      p_box->data.p_tref_generic->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_tref_generic( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_tref_generic->track_ID );
+   FREENULL( p_box->data.p_tref_generic->track_ID );
 }
 
 static int MP4_ReadBox_meta( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint8_t meta_data[8];
-    int i_actually_read;
+   uint8_t meta_data[8];
+   int i_actually_read;
 
-    // skip over box header
-    i_actually_read = stream_read( p_stream, meta_data, 8 );
-    if( i_actually_read < 8 )
-        return 0;
+   // skip over box header
+   i_actually_read = stream_read( p_stream, meta_data, 8 );
+   if( i_actually_read < 8 )
+      return 0;
 
-    /* meta content starts with a 4 byte version/flags value (should be 0) */
-    i_actually_read = stream_read( p_stream, meta_data, 4 );
-    if( i_actually_read < 4 )
-        return 0;
+   /* meta content starts with a 4 byte version/flags value (should be 0) */
+   i_actually_read = stream_read( p_stream, meta_data, 4 );
+   if( i_actually_read < 4 )
+      return 0;
 
-    /* then it behaves like a container */
-    return MP4_ReadBoxContainerRaw( p_stream, p_box );
+   /* then it behaves like a container */
+   return MP4_ReadBoxContainerRaw( p_stream, p_box );
 }
 
 static int MP4_ReadBox_iods( stream_t *p_stream, mp4_box_t *p_box )
 {
-    char i_unused;
+   char i_unused;
 
-    MP4_READBOX_ENTER( mp4_box_data_iods_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_iods );
+   MP4_READBOX_ENTER( mp4_box_data_iods_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_iods );
 
-    MP4_GET1BYTE( i_unused ); /* tag */
-    MP4_GET1BYTE( i_unused ); /* length */
+   MP4_GET1BYTE( i_unused ); /* tag */
+   MP4_GET1BYTE( i_unused ); /* length */
 
-    MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
-                                                               are used for other flags */
-    MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
+   MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
+                                                           are used for other flags */
+   MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
-            "visual: %i, graphics: %i",
-            p_box->data.p_iods->object_descriptor >> 6,
-            p_box->data.p_iods->OD_profile_level,
-            p_box->data.p_iods->scene_profile_level,
-            p_box->data.p_iods->audio_profile_level,
-            p_box->data.p_iods->visual_profile_level,
-            p_box->data.p_iods->graphics_profile_level );
+      "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
+      "visual: %i, graphics: %i",
+      p_box->data.p_iods->object_descriptor >> 6,
+      p_box->data.p_iods->OD_profile_level,
+      p_box->data.p_iods->scene_profile_level,
+      p_box->data.p_iods->audio_profile_level,
+      p_box->data.p_iods->visual_profile_level,
+      p_box->data.p_iods->graphics_profile_level );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_pasp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_pasp_t );
+   MP4_READBOX_ENTER( mp4_box_data_pasp_t );
 
-    MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
-    MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
+   MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
+   MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"paps\" %dx%d",
-            p_box->data.p_pasp->horizontal_spacing,
-            p_box->data.p_pasp->vertical_spacing);
+      "read box: \"paps\" %dx%d",
+      p_box->data.p_pasp->horizontal_spacing,
+      p_box->data.p_pasp->vertical_spacing);
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_mehd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_mehd_t );
+   MP4_READBOX_ENTER( mp4_box_data_mehd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
-    if( p_box->data.p_mehd->version == 1 )
-        MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
-    else /* version == 0 */
-        MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
+   MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
+   if( p_box->data.p_mehd->version == 1 )
+      MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
+   else /* version == 0 */
+      MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"mehd\" frag dur. %"PRIu64"",
-            p_box->data.p_mehd->fragment_duration );
+      "read box: \"mehd\" frag dur. %"PRIu64"",
+      p_box->data.p_mehd->fragment_duration );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_trex( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_trex_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_trex );
+   MP4_READBOX_ENTER( mp4_box_data_trex_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_trex );
 
-    MP4_GET4BYTES( p_box->data.p_trex->track_ID );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
+   MP4_GET4BYTES( p_box->data.p_trex->track_ID );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
 
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"trex\" trackID: %"PRIu32"",
-    //              p_box->data.p_trex->track_ID );
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"trex\" trackID: %"PRIu32"",
+   //              p_box->data.p_trex->track_ID );
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_sdtp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_sample_count;
-    uint32_t i;
-    mp4_box_data_sdtp_t *p_sdtp = NULL;
-    MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
-    p_sdtp = p_box->data.p_sdtp;
-    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
-    i_sample_count = i_read;
+   uint32_t i_sample_count;
+   uint32_t i;
+   mp4_box_data_sdtp_t *p_sdtp = NULL;
+   MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
+   p_sdtp = p_box->data.p_sdtp;
+   MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
+   i_sample_count = i_read;
 
-    p_sdtp->sample_table = calloc( i_sample_count, 1 );
+   p_sdtp->sample_table = calloc( i_sample_count, 1 );
 
-    if( !p_sdtp->sample_table )
-        MP4_READBOX_EXIT( 0 );
+   if( !p_sdtp->sample_table )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < i_sample_count; i++ )
-        MP4_GET1BYTE( p_sdtp->sample_table[i] );
+   for( i = 0; i < i_sample_count; i++ )
+      MP4_GET1BYTE( p_sdtp->sample_table[i] );
 
-    // #ifdef MP4_VERBOSE
-    //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
-    //      printf(
-    //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
-    //                  p_sdtp->sample_table[0],
-    //                  p_sdtp->sample_table[1],
-    //                  p_sdtp->sample_table[2],
-    //                  p_sdtp->sample_table[3] );
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
+   //      printf(
+   //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
+   //                  p_sdtp->sample_table[0],
+   //                  p_sdtp->sample_table[1],
+   //                  p_sdtp->sample_table[2],
+   //                  p_sdtp->sample_table[3] );
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_sdtp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sdtp->sample_table );
+   FREENULL( p_box->data.p_sdtp->sample_table );
 }
 
 static int MP4_ReadBox_mfro( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_mfro_t );
+   MP4_READBOX_ENTER( mp4_box_data_mfro_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
-    MP4_GET4BYTES( p_box->data.p_mfro->size );
+   MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
+   MP4_GET4BYTES( p_box->data.p_mfro->size );
 
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"mfro\" size: %"PRIu32"",
-    //              p_box->data.p_mfro->i_size);
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"mfro\" size: %"PRIu32"",
+   //              p_box->data.p_mfro->i_size);
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tfra( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_number_of_entries;
-    mp4_box_data_tfra_t *p_tfra;
-    uint32_t i_lengths;
-    size_t size;
-    uint32_t i;
-    MP4_READBOX_ENTER( mp4_box_data_tfra_t );
-    p_tfra = p_box->data.p_tfra;
-    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
-
-    MP4_GET4BYTES( p_tfra->track_ID );
-    i_lengths = 0;
-    MP4_GET4BYTES( i_lengths );
-    MP4_GET4BYTES( p_tfra->number_of_entries );
-    i_number_of_entries = p_tfra->number_of_entries;
-    p_tfra->length_size_of_traf_num = i_lengths >> 4;
-    p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
-    p_tfra->length_size_of_sample_num = i_lengths & 0x03;
-
-    size = 4 + 4*p_tfra->version; /* size in {4, 8} */
-    p_tfra->time = calloc( i_number_of_entries, size );
-    p_tfra->moof_offset = calloc( i_number_of_entries, size );
-
-    size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
-    p_tfra->traf_number = calloc( i_number_of_entries, size );
-    size = 1 + p_tfra->length_size_of_trun_num;
-    p_tfra->trun_number = calloc( i_number_of_entries, size );
-    size = 1 + p_tfra->length_size_of_sample_num;
-    p_tfra->sample_number = calloc( i_number_of_entries, size );
-
-    if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
-            || !p_tfra->trun_number || !p_tfra->sample_number )
-        goto error;
-
-    for( i = 0; i < i_number_of_entries; i++ )
-    {
-        if( p_tfra->version == 1 )
-        {
-            MP4_GET8BYTES( p_tfra->time[i*2] );
-            MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
-        }
-        else
-        {
-            MP4_GET4BYTES( p_tfra->time[i] );
-            MP4_GET4BYTES( p_tfra->moof_offset[i] );
-        }
-        switch (p_tfra->length_size_of_traf_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->traf_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->traf_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->traf_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->traf_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-
-        switch (p_tfra->length_size_of_trun_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->trun_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->trun_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->trun_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->trun_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-
-        switch (p_tfra->length_size_of_sample_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->sample_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->sample_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->sample_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->sample_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-    }
-
-    // #ifdef MP4_VERBOSE
-    //     if( p_tfra->version == 0 )
-    //     {
-    //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
-    //                          p_tfra->time[0], p_tfra->moof_offset[0] );
-    // 
-    //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
-    //                          p_tfra->time[1], p_tfra->moof_offset[1] );
-    //     }
-    //     else
-    //     {
-    //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
-    //                 ((uint64_t *)(p_tfra->time))[0],
-    //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
-    // 
-    //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
-    //                 ((uint64_t *)(p_tfra->time))[1],
-    //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
-    //     }
-    // 
-    //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
-    //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
-    // #endif
-
-    MP4_READBOX_EXIT( 1 );
+   uint32_t i_number_of_entries;
+   mp4_box_data_tfra_t *p_tfra;
+   uint32_t i_lengths;
+   size_t size;
+   uint32_t i;
+   MP4_READBOX_ENTER( mp4_box_data_tfra_t );
+   p_tfra = p_box->data.p_tfra;
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
+
+   MP4_GET4BYTES( p_tfra->track_ID );
+   i_lengths = 0;
+   MP4_GET4BYTES( i_lengths );
+   MP4_GET4BYTES( p_tfra->number_of_entries );
+   i_number_of_entries = p_tfra->number_of_entries;
+   p_tfra->length_size_of_traf_num = i_lengths >> 4;
+   p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
+   p_tfra->length_size_of_sample_num = i_lengths & 0x03;
+
+   size = 4 + 4*p_tfra->version; /* size in {4, 8} */
+   p_tfra->time = calloc( i_number_of_entries, size );
+   p_tfra->moof_offset = calloc( i_number_of_entries, size );
+
+   size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
+   p_tfra->traf_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_trun_num;
+   p_tfra->trun_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_sample_num;
+   p_tfra->sample_number = calloc( i_number_of_entries, size );
+
+   if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
+      || !p_tfra->trun_number || !p_tfra->sample_number )
+      goto error;
+
+   for( i = 0; i < i_number_of_entries; i++ )
+   {
+      if( p_tfra->version == 1 )
+      {
+         MP4_GET8BYTES( p_tfra->time[i*2] );
+         MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
+      }
+      else
+      {
+         MP4_GET4BYTES( p_tfra->time[i] );
+         MP4_GET4BYTES( p_tfra->moof_offset[i] );
+      }
+      switch (p_tfra->length_size_of_traf_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->traf_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->traf_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->traf_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->traf_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_trun_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->trun_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->trun_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->trun_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->trun_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_sample_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->sample_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->sample_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->sample_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->sample_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+   }
+
+   // #ifdef MP4_VERBOSE
+   //     if( p_tfra->version == 0 )
+   //     {
+   //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
+   //                          p_tfra->time[0], p_tfra->moof_offset[0] );
+   // 
+   //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
+   //                          p_tfra->time[1], p_tfra->moof_offset[1] );
+   //     }
+   //     else
+   //     {
+   //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[0],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
+   // 
+   //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[1],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
+   //     }
+   // 
+   //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
+   //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
 error:
-    MP4_READBOX_EXIT( 0 );
+   MP4_READBOX_EXIT( 0 );
 }
 
 static void MP4_FreeBox_tfra( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_tfra->time );
-    FREENULL( p_box->data.p_tfra->moof_offset );
-    FREENULL( p_box->data.p_tfra->traf_number );
-    FREENULL( p_box->data.p_tfra->trun_number );
-    FREENULL( p_box->data.p_tfra->sample_number );
+   FREENULL( p_box->data.p_tfra->time );
+   FREENULL( p_box->data.p_tfra->moof_offset );
+   FREENULL( p_box->data.p_tfra->traf_number );
+   FREENULL( p_box->data.p_tfra->trun_number );
+   FREENULL( p_box->data.p_tfra->sample_number );
 }
 
 
 /* For generic */
 static int MP4_ReadBox_default( stream_t *p_stream, mp4_box_t *p_box )
 {
-    if( !p_box->p_father )
-    {
-        goto unknown;
-    }
-    if( p_box->p_father->i_type == ATOM_stsd )
-    {
-        mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
-        mp4_box_t *p_hdlr;
-
-        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
-                (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
-        {
-            goto unknown;
-        }
-        switch( p_hdlr->data.p_hdlr->handler_type )
-        {
-            case ATOM_soun:
-                return MP4_ReadBox_sample_soun( p_stream, p_box );
-            case ATOM_vide:
-                return MP4_ReadBox_sample_vide( p_stream, p_box );
-            case ATOM_text:
-                return MP4_ReadBox_sample_text( p_stream, p_box );
-            case ATOM_mmth:
-                return MP4_ReadBox_sample_mmth( p_stream, p_box );
-            case ATOM_tx3g:
-            case ATOM_sbtl:
-                return MP4_ReadBox_sample_tx3g( p_stream, p_box );
-            default:
-                printf(
-                        "unknown handler type in stsd (incompletely loaded1)" );
-                return 1;
-        }
-    }
+   if( !p_box->p_father )
+   {
+      goto unknown;
+   }
+   if( p_box->p_father->i_type == ATOM_stsd )
+   {
+      mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
+      mp4_box_t *p_hdlr;
+
+      if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
+         (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
+      {
+         goto unknown;
+      }
+      switch( p_hdlr->data.p_hdlr->handler_type )
+      {
+      case ATOM_soun:
+         return MP4_ReadBox_sample_soun( p_stream, p_box );
+      case ATOM_vide:
+         return MP4_ReadBox_sample_vide( p_stream, p_box );
+      case ATOM_text:
+         return MP4_ReadBox_sample_text( p_stream, p_box );
+      case ATOM_mmth:
+         return MP4_ReadBox_sample_mmth( p_stream, p_box );
+      case ATOM_tx3g:
+      case ATOM_sbtl:
+         return MP4_ReadBox_sample_tx3g( p_stream, p_box );
+      default:
+    	  printf(
+            "unknown handler type in stsd (incompletely loaded1)" );
+         return 1;
+      }
+   }
 
 unknown:
-    if MP4_BOX_TYPE_ASCII()
-        printf(
-                "unknown box type %4.4s (incompletely loaded2)",
-                (char*)&p_box->i_type );
-    else
-        printf(
-                "unknown box type c%3.3s (incompletely loaded3)",
-                (char*)&p_box->i_type+1 );
+   if MP4_BOX_TYPE_ASCII()
+      printf(
+      "unknown box type %4.4s (incompletely loaded2)",
+      (char*)&p_box->i_type );
+   else
+	   printf(
+      "unknown box type c%3.3s (incompletely loaded3)",
+      (char*)&p_box->i_type+1 );
 
-    return 1;
+   return 1;
 }
 
 static const struct
 {
-    uint32_t i_type;
-    int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
-    void (*MP4_FreeBox_function )( mp4_box_t *p_box );
+   uint32_t i_type;
+   int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
+   void (*MP4_FreeBox_function )( mp4_box_t *p_box );
 } MP4_Box_Function [] =
 {
-    /* Containers */
-    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-
-    /* specific box */
-    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
-    { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
-    { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
-    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
-    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
-    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
-    { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
-    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
-    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
-    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
-    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
-    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
-    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
-    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
-    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
-    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
-    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
-    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
-    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
-    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
-    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
-    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
-    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
-    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
-    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
-    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
-    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
-    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
-    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
-    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
-    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
-    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
-    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
-    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
-    { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
-    { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
-    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
-    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
-
-    /* Nothing to do with this box */
-    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-
-    /* for codecs */
-    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-
-    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
-    { ATOM_mjht,    MP4_ReadBox_default,      NULL },
-
-    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
-
-    /* XXX there is 2 box where we could find this entry stbl and tref*/
-    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
-    { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
-
-    /* found in tref box */
-    { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
-    { ATOM_ipir,    MP4_ReadBox_default,      NULL },
-    { ATOM_mpod,    MP4_ReadBox_default,      NULL },
-    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
-
-    /* found in hnti */
-    { ATOM_rtp,     MP4_ReadBox_default,      NULL },
-
-    /* found in rmra */
-    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
-    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
-    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
-    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
-
-    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
-    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
-
-    /* found in udta */
-    { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-
-    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
-
-    /* iTunes/Quicktime meta info */
-    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
-    { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
-
-    /* found in smoothstreaming */
-    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
-    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
-    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
-    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
-    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
-    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
-    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
-    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
-
-    /* Last entry */
-    { 0,              MP4_ReadBox_default,      NULL }
+   /* Containers */
+   { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+
+   /* specific box */
+   { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
+   { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
+   { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
+   { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
+   { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
+   { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
+   { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
+   { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
+   { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
+   { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
+   { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
+   { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
+   { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
+   { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
+   { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
+   { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
+   { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
+   { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
+   { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
+   { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
+   { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
+   { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
+   { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
+   { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
+   { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
+   { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
+   { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
+   { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
+   { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
+   { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
+   { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
+   { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
+   { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
+   { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
+   { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
+   { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
+
+   /* Nothing to do with this box */
+   { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+
+   /* for codecs */
+   { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+
+   { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
+   { ATOM_mjht,    MP4_ReadBox_default,      NULL },
+
+   { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
+
+   /* XXX there is 2 box where we could find this entry stbl and tref*/
+   { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
+   { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
+
+   /* found in tref box */
+   { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
+   { ATOM_ipir,    MP4_ReadBox_default,      NULL },
+   { ATOM_mpod,    MP4_ReadBox_default,      NULL },
+   { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
+
+   /* found in hnti */
+   { ATOM_rtp,     MP4_ReadBox_default,      NULL },
+
+   /* found in rmra */
+   { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
+   { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
+   { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
+   { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
+
+   { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
+   { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
+
+   /* found in udta */
+   { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+
+   { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
+
+   /* iTunes/Quicktime meta info */
+   { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
+   { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
+
+   /* found in smoothstreaming */
+   { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
+   { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
+   { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
+   { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
+   { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
+   { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
+   { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
+   { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
+
+   /* Last entry */
+   { 0,              MP4_ReadBox_default,      NULL }
 };
 
 
 //get full struct of the mp4,main function
 mp4_box_t *MP4_BoxGetRoot(stream_t * s)
 {
-    mp4_box_t *p_root;
-    stream_t *p_stream;
-    int i_result;
+   mp4_box_t *p_root;
+   stream_t *p_stream;
+   int i_result;
 
-    p_root = malloc( sizeof( mp4_box_t ) );
-    if( p_root == NULL )
-        return NULL;
+   p_root = malloc( sizeof( mp4_box_t ) );
+   if( p_root == NULL )
+      return NULL;
 
-    p_root->i_pos = 0;
-    p_root->i_type = ATOM_root;
-    p_root->i_shortsize = 1;
+   p_root->i_pos = 0;
+   p_root->i_type = ATOM_root;
+   p_root->i_shortsize = 1;
 
-    stream_seek(s, 0, SEEK_END);
-    p_root->i_size = stream_tell(s);
-    stream_seek(s, 0, SEEK_SET);
+   stream_seek(s, 0, SEEK_END);
+   p_root->i_size = stream_tell(s);
+   stream_seek(s, 0, SEEK_SET);
 
-    CreateUUID( &p_root->i_uuid, p_root->i_type );
+   CreateUUID( &p_root->i_uuid, p_root->i_type );
 
-    //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
-    p_root->data.p_data = NULL;
-    p_root->p_father    = NULL;
-    p_root->p_first     = NULL;
-    p_root->p_last      = NULL;
-    p_root->p_next      = NULL;
+   //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
+   p_root->data.p_data = NULL;
+   p_root->p_father    = NULL;
+   p_root->p_first     = NULL;
+   p_root->p_last      = NULL;
+   p_root->p_next      = NULL;
 
-    p_stream = s;
+   p_stream = s;
 
-    i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
+   i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
 
-    if( i_result )
-    {
-        mp4_box_t *p_moov;
-        mp4_box_t *p_cmov;
-
-        /* check if there is a cmov, if so replace
-           compressed moov by  uncompressed one */
-        if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
-                    ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
-                ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
-                  ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
-        {
-            /* rename the compressed moov as a box to skip */
-            p_moov->i_type = ATOM_skip;
+   if( i_result )
+   {
+      mp4_box_t *p_moov;
+      mp4_box_t *p_cmov;
 
-            /* get uncompressed p_moov */
-            p_moov = p_cmov->data.p_cmov->moov;
-            p_cmov->data.p_cmov->moov = NULL;
+      /* check if there is a cmov, if so replace
+      compressed moov by  uncompressed one */
+      if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
+         ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
+      {
+         /* rename the compressed moov as a box to skip */
+         p_moov->i_type = ATOM_skip;
 
-            /* make p_root father of this new moov */
-            p_moov->p_father = p_root;
+         /* get uncompressed p_moov */
+         p_moov = p_cmov->data.p_cmov->moov;
+         p_cmov->data.p_cmov->moov = NULL;
 
-            /* insert this new moov box as first child of p_root */
-            p_moov->p_next = p_root->p_first;
-            p_root->p_first = p_moov;
-        }
-    }
+         /* make p_root father of this new moov */
+         p_moov->p_father = p_root;
+
+         /* insert this new moov box as first child of p_root */
+         p_moov->p_next = p_root->p_first;
+         p_root->p_first = p_moov;
+      }
+   }
 
-    return p_root;
+   return p_root;
 }
 
-//after  get full struct of the mp4,you can use this function to get the special box
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 {
-    //mp4_box_t *cur = p_head, *prev = NULL;
-    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
+	//mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+	mp4_box_t *cur = p_head;
 
     while (cur != NULL)
     {
-        if (cur->p_first == NULL)          // 1.
+		if (cur->i_type==ATOM_moov||cur->i_type==ATOM_trak||cur->i_type==ATOM_mdia||cur->i_type==ATOM_moof \
+			||cur->i_type==ATOM_minf||cur->i_type==ATOM_stbl||cur->i_type==ATOM_dinf||cur->i_type==ATOM_edts \
+			||cur->i_type==ATOM_udta||cur->i_type==ATOM_nmhd||cur->i_type==ATOM_hnti||cur->i_type==ATOM_rmra \
+			||cur->i_type==ATOM_rmda||cur->i_type==ATOM_tref||cur->i_type==ATOM_gmhd||cur->i_type==ATOM_wave \
+			||cur->i_type==ATOM_ilst||cur->i_type==ATOM_mvex||cur->i_type==ATOM_stsd||cur->i_type==ATOM_tref \
+			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root)
         {
-            if(cur->i_type == i_type)
-            {
-                return(cur); /**/
-            }
-            cur = cur->p_next;
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type==i_type)
+				return cur;
+        	 // find predecessor
+			else {
+				cur = cur->p_first;
+				return MP4_BoxSearchBox(cur, i_type);
+			}
         }
         else
         {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type == i_type)
+				{
+					return(cur); /*Find the box*/
+				}
+            else 
+				if(cur->p_next)
+					cur = cur->p_next;
+				else if(cur->p_father->p_next)
+					cur = cur->p_father->p_next;
+                else if (cur->p_father->p_father) {
+				    if(cur->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next;
+				    else {
+					    printf("Format not supported!\n");
+					    return NULL;
+				    }
+                }else {
+					printf("Format not supported!\n");
+					return NULL;
+				}
 
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    return(cur); /**/
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    return(cur); /**/
-                }
-                cur = cur->p_next;
-            }
         }
     }
     return(NULL);
 }
-
-void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type)
-{
-    mp4_box_t *cur = p_head, *prev = NULL;
-    //mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    //mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
-
-    while (cur != NULL)
-    {
-        if (cur->p_first == NULL)          // 1.
-        {
-            if(cur->i_type == i_type)
-            {
-
-                //*search_box=cur;
-                free(cur);
-                free(prev);
-                break;
-            }
-            cur = cur->p_next;
-        }
-        else
-        {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
-
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    //*search_box=cur;
-                    free(cur);
-                    free(prev);
-                    break;
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    //*search_box=cur;
-                    free(cur);
-                    free(prev);
-                    break;
-                }
-                cur = cur->p_next;
-            }
-        }
-    }
-
-}
-
-//after  get full struct of the mp4,you can use this function to get the special box
-int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type)
-{
-    //mp4_box_t *cur = p_head, *prev = NULL;
-    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
-
-    while (cur != NULL)
-    {
-        if (cur->p_first == NULL)          // 1.
-        {
-            if(cur->i_type == i_type)
-            {
-                printf("1\n");
-                //return(1); /**/
-                //					return(cur); /**/
-            }
-            cur = cur->p_next;
-        }
-        else
-        {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
-
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    printf("2\n");
-                    //              		return(2); /**/
-                    //						return(cur); /**/
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    printf("3\n");
-                    //              	return(3); /**/
-                    //						return(cur); /**/
-                }
-                cur = cur->p_next;
-            }
-        }
-    }
-    printf("aa0\n");
-    //    return(0);
-}
 /*****************************************************************************
- * MP4_ReadBox : parse the actual box and the children
- *  XXX : Do not go to the next box
- *****************************************************************************/
+* MP4_ReadBox : parse the actual box and the children
+*  XXX : Do not go to the next box
+*****************************************************************************/
 static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
 {
-    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    unsigned int i_index;
-
-    if( p_box == NULL )
-        return NULL;
-
-    if( !MP4_ReadBoxCommon( p_stream, p_box ) )
-    {
-        printf( "cannot read one box" );
-        free( p_box );
-        return NULL;
-    }
-    if( !p_box->i_size )
-    {
-        printf( "found an empty box (null size)" );
-        free( p_box );
-        return NULL;
-    }
-    p_box->p_father = p_father;
-
-    /* Now search function to call */
-    for( i_index = 0; ; i_index++ )
-    {
-        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
-                ( MP4_Box_Function[i_index].i_type == 0 ) )
-        {
-            break;
-        }
-    }
+   mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+   unsigned int i_index;
+
+   if( p_box == NULL )
+      return NULL;
+
+   if( !MP4_ReadBoxCommon( p_stream, p_box ) )
+   {
+      printf( "cannot read one box" );
+      free( p_box );
+      return NULL;
+   }
+   if( !p_box->i_size )
+   {
+       printf( "found an empty box (null size)" );
+      free( p_box );
+      return NULL;
+   }
+   p_box->p_father = p_father;
+
+   /* Now search function to call */
+   for( i_index = 0; ; i_index++ )
+   {
+      if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+         ( MP4_Box_Function[i_index].i_type == 0 ) )
+      {
+         break;
+      }
+   }
 
-    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
-    {
-        MP4_BoxFree( p_stream, p_box );
-        return NULL;
-    }
+   if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
+   {
+      MP4_BoxFree( p_stream, p_box );
+      return NULL;
+   }
 
-    return p_box;
+   return p_box;
 }
 
 void MP4_BoxFree( stream_t *s, mp4_box_t *p_box )
 {
-    unsigned int i_index;
-    mp4_box_t    *p_child;
+   unsigned int i_index;
+   mp4_box_t    *p_child;
 
-    if( !p_box )
-        return; /* hehe */
+   if( !p_box )
+      return; /* hehe */
 
-    for( p_child = p_box->p_first; p_child != NULL; )
-    {
-        mp4_box_t *p_next;
+   for( p_child = p_box->p_first; p_child != NULL; )
+   {
+      mp4_box_t *p_next;
 
-        p_next = p_child->p_next;
-        MP4_BoxFree( s, p_child );
-        p_child = p_next;
-    }
+      p_next = p_child->p_next;
+      MP4_BoxFree( s, p_child );
+      p_child = p_next;
+   }
 
-    /* Now search function to call */
-    if( p_box->data.p_data )
-    {
-        for( i_index = 0; ; i_index++ )
-        {
-            if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
-                    ( MP4_Box_Function[i_index].i_type == 0 ) )
-            {
-                break;
-            }
-        }
-        if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
-        {
-            /* Should not happen */
-            if MP4_BOX_TYPE_ASCII()
-                printf(
-                        "cannot free box %4.4s, type unknown",
-                        (char*)&p_box->i_type );
-            else
-                printf(
-                        "cannot free box c%3.3s, type unknown",
-                        (char*)&p_box->i_type+1 );
-        }
-        else
-        {
-            MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
-        }
-        free( p_box->data.p_data );
-    }
-    free( p_box );
+   /* Now search function to call */
+   if( p_box->data.p_data )
+   {
+      for( i_index = 0; ; i_index++ )
+      {
+         if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+            ( MP4_Box_Function[i_index].i_type == 0 ) )
+         {
+            break;
+         }
+      }
+      if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
+      {
+         /* Should not happen */
+         if MP4_BOX_TYPE_ASCII()
+		printf(
+            "cannot free box %4.4s, type unknown",
+            (char*)&p_box->i_type );
+         else
+        	 printf(
+            "cannot free box c%3.3s, type unknown",
+            (char*)&p_box->i_type+1 );
+      }
+      else
+      {
+         MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
+      }
+      free( p_box->data.p_data );
+   }
+   free( p_box );
 }
 
 /*****************************************************************************
- *****************************************************************************
- **
- **  High level methods to acces an MP4 file
- **
- *****************************************************************************
- *****************************************************************************/
+*****************************************************************************
+**
+**  High level methods to acces an MP4 file
+**
+*****************************************************************************
+*****************************************************************************/
 static void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )
 {
-    size_t i_len ;
-    if( !*ppsz_path[0] )
-    {
-        *ppsz_token = NULL;
-        *pi_number = 0;
-        return;
-    }
-    i_len = strcspn( *ppsz_path, "/[" );
-    if( !i_len && **ppsz_path == '/' )
-    {
-        i_len = 1;
-    }
-    *ppsz_token = malloc( i_len + 1 );
-
-    memcpy( *ppsz_token, *ppsz_path, i_len );
-
-    (*ppsz_token)[i_len] = '\0';
-
-    *ppsz_path += i_len;
-
-    if( **ppsz_path == '[' )
-    {
-        (*ppsz_path)++;
-        *pi_number = strtol( *ppsz_path, NULL, 10 );
-        while( **ppsz_path && **ppsz_path != ']' )
-        {
-            (*ppsz_path)++;
-        }
-        if( **ppsz_path == ']' )
-        {
-            (*ppsz_path)++;
-        }
-    }
-    else
-    {
-        *pi_number = 0;
-    }
-    while( **ppsz_path == '/' )
-    {
-        (*ppsz_path)++;
-    }
+   size_t i_len ;
+   if( !*ppsz_path[0] )
+   {
+      *ppsz_token = NULL;
+      *pi_number = 0;
+      return;
+   }
+   i_len = strcspn( *ppsz_path, "/[" );
+   if( !i_len && **ppsz_path == '/' )
+   {
+      i_len = 1;
+   }
+   *ppsz_token = malloc( i_len + 1 );
+
+   memcpy( *ppsz_token, *ppsz_path, i_len );
+
+   (*ppsz_token)[i_len] = '\0';
+
+   *ppsz_path += i_len;
+
+   if( **ppsz_path == '[' )
+   {
+      (*ppsz_path)++;
+      *pi_number = strtol( *ppsz_path, NULL, 10 );
+      while( **ppsz_path && **ppsz_path != ']' )
+      {
+         (*ppsz_path)++;
+      }
+      if( **ppsz_path == ']' )
+      {
+         (*ppsz_path)++;
+      }
+   }
+   else
+   {
+      *pi_number = 0;
+   }
+   while( **ppsz_path == '/' )
+   {
+      (*ppsz_path)++;
+   }
 }
 
 static void MP4_BoxGet_Internal(mp4_box_t **pp_result,
-        mp4_box_t *p_box, const char *psz_fmt, va_list args)
-{
-    char *psz_dup;
-    char *psz_path = malloc(4096);
-    char *psz_token;
-
-    if( !p_box )
-    {
-        *pp_result = NULL;
-        return;
-    }
-
-    if( vsprintf( psz_path, psz_fmt, args ) == -1 )
-        psz_path = NULL;
-
-    if( !psz_path || !psz_path[0] )
-    {
-        free( psz_path );
-        *pp_result = NULL;
-        return;
-    }
-
-    //    fprintf( stderr, "path:'%s'\n", psz_path );
-    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
-    for( ; ; )
-    {
-        int i_number;
-
-        get_token( &psz_path, &psz_token, &i_number );
-        //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
-        //                 psz_path,psz_token,i_number );
-        if( !psz_token )
-        {
-            free( psz_dup );
-            *pp_result = p_box;
-            return;
-        }
-        else
-            if( !strcmp( psz_token, "/" ) )
+   mp4_box_t *p_box, const char *psz_fmt, va_list args)
+{
+   char *psz_dup;
+   char *psz_path = malloc(4096);
+   char *psz_token;
+
+   if( !p_box )
+   {
+      *pp_result = NULL;
+      return;
+   }
+
+   if( vsprintf( psz_path, psz_fmt, args ) == -1 )
+      psz_path = NULL;
+
+   if( !psz_path || !psz_path[0] )
+   {
+      free( psz_path );
+      *pp_result = NULL;
+      return;
+   }
+
+   //    fprintf( stderr, "path:'%s'\n", psz_path );
+   psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
+   for( ; ; )
+   {
+      int i_number;
+
+      get_token( &psz_path, &psz_token, &i_number );
+      //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
+      //                 psz_path,psz_token,i_number );
+      if( !psz_token )
+      {
+         free( psz_dup );
+         *pp_result = p_box;
+         return;
+      }
+      else
+         if( !strcmp( psz_token, "/" ) )
+         {
+            /* Find root box */
+            while( p_box && p_box->i_type != ATOM_root )
+            {
+               p_box = p_box->p_father;
+            }
+            if( !p_box )
+            {
+               goto error_box;
+            }
+         }
+         else
+            if( !strcmp( psz_token, "." ) )
             {
-                /* Find root box */
-                while( p_box && p_box->i_type != ATOM_root )
-                {
-                    p_box = p_box->p_father;
-                }
-                if( !p_box )
-                {
-                    goto error_box;
-                }
+               /* Do nothing */
             }
             else
-                if( !strcmp( psz_token, "." ) )
-                {
-                    /* Do nothing */
-                }
-                else
-                    if( !strcmp( psz_token, ".." ) )
-                    {
-                        p_box = p_box->p_father;
+               if( !strcmp( psz_token, ".." ) )
+               {
+                  p_box = p_box->p_father;
+                  if( !p_box )
+                  {
+                     goto error_box;
+                  }
+               }
+               else
+                  if( strlen( psz_token ) == 4 )
+                  {
+                     uint32_t i_fourcc;
+                     i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
+                        psz_token[2], psz_token[3] );
+                     p_box = p_box->p_first;
+                     for( ; ; )
+                     {
                         if( !p_box )
                         {
-                            goto error_box;
+                           goto error_box;
                         }
-                    }
-                    else
-                        if( strlen( psz_token ) == 4 )
+                        if( p_box->i_type == i_fourcc )
                         {
-                            uint32_t i_fourcc;
-                            i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
-                                    psz_token[2], psz_token[3] );
-                            p_box = p_box->p_first;
-                            for( ; ; )
-                            {
-                                if( !p_box )
-                                {
-                                    goto error_box;
-                                }
-                                if( p_box->i_type == i_fourcc )
-                                {
-                                    if( !i_number )
-                                    {
-                                        break;
-                                    }
-                                    i_number--;
-                                }
-                                p_box = p_box->p_next;
-                            }
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
                         }
-                        else
-                            if( *psz_token == '\0' )
-                            {
-                                p_box = p_box->p_first;
-                                for( ; ; )
-                                {
-                                    if( !p_box )
-                                    {
-                                        goto error_box;
-                                    }
-                                    if( !i_number )
-                                    {
-                                        break;
-                                    }
-                                    i_number--;
-                                    p_box = p_box->p_next;
-                                }
-                            }
-                            else
-                            {
-                                //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
-                                goto error_box;
-                            }
-
-        FREENULL( psz_token );
-    }
+                        p_box = p_box->p_next;
+                     }
+                  }
+                  else
+                     if( *psz_token == '\0' )
+                     {
+                        p_box = p_box->p_first;
+                        for( ; ; )
+                        {
+                           if( !p_box )
+                           {
+                              goto error_box;
+                           }
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
+                           p_box = p_box->p_next;
+                        }
+                     }
+                     else
+                     {
+                        //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
+                        goto error_box;
+                     }
+
+                     FREENULL( psz_token );
+   }
 
-    return;
+   return;
 
 error_box:
-    free( psz_token );
-    free( psz_dup );
-    *pp_result = NULL;
-    return;
+   free( psz_token );
+   free( psz_dup );
+   *pp_result = NULL;
+   return;
 }
 
 mp4_box_t * MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...)
 {
-    va_list args;
-    mp4_box_t *p_result;
+   va_list args;
+   mp4_box_t *p_result;
 
-    va_start( args, psz_fmt );
-    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
-    va_end( args );
+   va_start( args, psz_fmt );
+   MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
+   va_end( args );
 
-    return( p_result );
+   return( p_result );
 }
 
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 1d045dd..3ce4bf5 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1202,17 +1202,14 @@ typedef struct mp4_box_s
 #ifdef __cplusplus
 extern "C" {
 #endif
-
 mp4_box_t *MP4_BoxGetRoot(stream_t * s);
 void MP4_BoxFree(stream_t * s, mp4_box_t *box);
 static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
 mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
-void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type);
-int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type);
-
 #ifdef __cplusplus
 }
 #endif
 
+
 #endif // NET_MMT_MPU_MP4_H_
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
index f512657..571d68b 100644
--- a/net/mmt/mpu/stream.c
+++ b/net/mmt/mpu/stream.c
@@ -1,12 +1,12 @@
 #include <stdio.h>
 #include <stdlib.h>
+#include <malloc.h>
 #include <memory.h>
 #include <assert.h>
 #include "net/mmt/mpu/stream.h"
 
 #define max(a,b) a>b?a:b
 #define min(a,b) a>b?b:a
-
 void* file_open(stream_t *stream_s, const char* filename, int mode)
 {
    FILE* file = NULL;
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index 34e8feb..6d570b4 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -1,8 +1,7 @@
 #ifndef NET_MMT_MPU_STREAM_H_
 #define NET_MMT_MPU_STREAM_H_
 
-#include <stdint.h>
-
+// .
 #ifndef _STDINT_H
 typedef signed char int8_t;
 typedef unsigned char uint8_t;
@@ -10,17 +9,19 @@ typedef short int16_t;
 typedef unsigned short uint16_t;
 typedef int int32_t;
 typedef unsigned uint32_t;
-//typedef long long int64_t;
+typedef long int int64_t;
 typedef unsigned long long uint64_t;
 //typedef unsigned long size_t;
 #endif
 
+// .
 #define MODE_READ             (1)
 #define MODE_WRITE            (2)
 #define MODE_READWRITEFILTER  (3)
 #define MODE_EXISTING         (4)
 #define MODE_CREATE           (8)
 
+// .
 typedef struct stream {
    void* (*open)(struct stream *stream_s, const char* filename, int mode);
    int (*read)(struct stream *stream_s, void* buf, int size);
@@ -32,6 +33,7 @@ typedef struct stream {
    void* opaque;
 } stream_t;
 
+// .
 #define stream_open(s, filename, mode) ((stream_t*)s)->open(((stream_t*)s), filename, mode)
 #define stream_read(s, buf, size) ((stream_t*)s)->read(((stream_t*)s), buf, size)
 #define stream_write(s, buf, size) ((stream_t*)s)->write(((stream_t*)s), buf, size)
@@ -40,6 +42,7 @@ typedef struct stream {
 #define stream_tell(s) ((stream_t*)s)->tell(((stream_t*)s))
 #define stream_close(s) ((stream_t*)s)->close(((stream_t*)s))
 
+// .
 void* file_open(stream_t *stream_s, const char* filename, int mode);
 int file_read(stream_t *stream_s, void* buf, int size);
 int file_write(stream_t *stream_s, void *buf, int size);
@@ -51,15 +54,15 @@ int file_close(stream_t *stream_s);
 #ifdef __cplusplus
 extern "C" {
 #endif
-
+// .
 stream_t* create_file_stream();
 void destory_file_stream(stream_t* stream_s);
-
 #ifdef __cplusplus
 }
 #endif
 
 
+// stream.
 #define READ_BUFFER_SIZE   10485760
 #define WRITE_BUFFER_SIZE  10485760
 
@@ -67,32 +70,38 @@ typedef struct buf_stream {
    stream_t s;
 
    struct read_buf {
-      void* buf;        
-      int64_t bufsize; 
-      int64_t offset; 
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
    } read_buf_s;
 
    struct write_buf {
-      void* buf;     
-      int64_t bufsize;
-      int64_t offset;
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
    } write_buf_s;
 
-   uint64_t offset; 
+   uint64_t offset;     // offset.
 
 } buf_stream_t;
 
+// .
 int buf_file_read(stream_t *stream_s, void* buf, int size);
 int buf_file_write(stream_t *stream_s, void *buf, int size);
 int buf_file_peek(stream_t *stream_s, void* buf, int size);
 uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence);
 int buf_file_close(stream_t *stream_s);
 
+// .
 stream_t* create_buf_file_stream();
 void destory_buf_file_stream(stream_t* stream_s);
 
-#define LIL_ENDIAN_INTERNAL	1234
-#define BIG_ENDIAN_INTERNAL	4321
+// .
+#undef LIL_ENDIAN
+#undef BIG_ENDIAN
+#define LIL_ENDIAN	1234
+#define BIG_ENDIAN	4321
+/* #define BYTEORDER    1234 ? . */
 
 #ifndef BYTEORDER
 #if defined(__hppa__) || \
@@ -100,9 +109,9 @@ void destory_buf_file_stream(stream_t* stream_s);
    (defined(__MIPS__) && defined(__MISPEB__)) || \
    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
    defined(__sparc__)
-#define BYTEORDER	BIG_ENDIAN_INTERNAL
+#define BYTEORDER	BIG_ENDIAN
 #else
-#define BYTEORDER	LIL_ENDIAN_INTERNAL
+#define BYTEORDER	LIL_ENDIAN
 #endif
 #endif /* !BYTEORDER */
 
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 8c7ae7e..e65bf45 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -25,10 +25,24 @@ int main(int argc, char* argv[])
 
     mp4_box_t* box = NULL;
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
-    printf("ftyp: %p\n", box);
+    if (box) {
+        printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
+
+    box = MP4_BoxSearchBox(box, ATOM_moof);
+    if (box) {
+        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
 
-    box = MP4_BoxSearchBox(root, ATOM_moof);
-    printf("moof: %p\n", box);
+    box = MP4_BoxSearchBox(box, ATOM_mdat);
+    if (box) {
+        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
+
+    box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
+    if (box) {
+        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
 
     MP4_BoxFree(s, root);
 
-- 
1.7.9.5


From c6e01c1e02463b95cde82b850627a27ca18b1068 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 18:38:12 -0800
Subject: [PATCH 46/92] add tool curfile

---
 net/mmt/mpu/cutfile.c |   29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 net/mmt/mpu/cutfile.c

diff --git a/net/mmt/mpu/cutfile.c b/net/mmt/mpu/cutfile.c
new file mode 100644
index 0000000..d977505
--- /dev/null
+++ b/net/mmt/mpu/cutfile.c
@@ -0,0 +1,29 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]) {
+    if (argc != 4) {
+        printf("usage: %s infile offset outfile\n", argv[0]);
+        return 1;
+    }
+
+    int offset = atoi(argv[2]);
+    if (offset < 0) return -1;
+    FILE* infp = fopen(argv[1], "rb");
+    if (!infp) return 1;
+    int ierr = fseek(infp, offset, SEEK_SET);
+    if (ierr != 0)  return -1;
+
+    FILE* outfp = fopen(argv[3], "wb");
+    if (!outfp) return 1;
+
+    char data[128*1024];
+    while(1) {
+        int iret = fread(data, 1, sizeof(data), infp);
+        if (iret <= 0) break;
+        fwrite(data, 1, iret, outfp);
+    }
+    fclose(infp);
+    fclose(outfp);
+    return 0;
+}
-- 
1.7.9.5


From 6b8d549be173dfd29bc13d925806d7f239d82e74 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 04:32:30 -0800
Subject: [PATCH 47/92] [todo] integrate with mpu parser

---
 net/mmt/mmt_control.cc |    8 +--
 net/mmt/mmt_control.h  |    2 +-
 net/mmt/mmt_stream.cc  |  143 ++++++++++++++++++------------------------------
 net/mmt/mmt_stream.h   |   38 +++++++++----
 net/mmt/mpu/mp4.h      |    2 +-
 5 files changed, 87 insertions(+), 106 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 28d1ff4..4b51ef8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -93,7 +93,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     // TODO: for local file testing
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
-    streams_.insert(stream_t(key, stream));
+    streams_.insert(StreamPtr_t(key, stream));
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
@@ -103,10 +103,10 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
-    streams_t::iterator iter = streams_.find(key);
+    StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
-        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
 #if 0
         LOG(INFO) << __func__ 
             << " head=" << head 
@@ -125,7 +125,7 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
-    streams_t::iterator iter = streams_.find(key);
+    StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index df79ea1..3f09941 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -58,7 +58,7 @@ private:
     bool running_;
     std::vector<ctrl_msg_t> queue_;
     base::Lock lock_;
-    streams_t streams_;
+    StreamPtrs_t streams_;
 };
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index f473d76..bae7daf 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,5 +1,6 @@
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_inc.h"
+#include "net/mmt/mpu/mp4.h"
 
 namespace mmt {
 
@@ -92,10 +93,6 @@ Stream::~Stream() {
     Uninit();
 }
 
-GURL Stream::getUrl() {
-    return url_;
-}
-
 bool Stream::ParseSequence(int& index) {
     // if exists query, then should redirect to real file name
     std::string query = url_.query();
@@ -115,20 +112,31 @@ bool Stream::ParseSequence(int& index) {
     }
     return true;
 }
+bool Stream::Prepare(long *size) {
+    if (!Open(nullptr, 0)) return false;
 
-bool Stream::Init(int index) {
-    if (file_) return true;
+    long lret = 1<<30; // default 1GB
+    if (midx_.cur == -1) {
+        lret = offmap_[midx_.cur].size; // for single file or the 1st file
+    }
+    if (size)   *size = lret;
+    LOG(INFO) << __func__ << " lret=" << lret;
+    return true;
+}
+void* Stream::Open(const char* filename, int mode) {
+    if (file_) return (void *)file_;
 
+    int index = midx_.cur;
     if(index < 0 && !ParseSequence(index)) {
         LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
-        return false;
+        return nullptr;
     }
 
     // default file is html
     std::string fname = GURL2FilePath(url_);
     if (index >= 0) {
         if (index < midx_.begin || index > midx_.end)
-            return false;
+            return nullptr;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
@@ -137,109 +145,64 @@ bool Stream::Init(int index) {
             fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
-    LOG(INFO) << __func__ << " fname=" << fname;
+    LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
-    // open and get file size
+    // open and get file size for the 1st seq
     file_ = fopen(fname.c_str(), "rb");
-    if (!file_) return false;
+    if (!file_) return nullptr;
+
     int ierr = fseek(file_, 0L, SEEK_END);
+    if (ierr != 0) return nullptr; 
     long lret = ftell(file_);
     ierr = fseek(file_, 0L, SEEK_SET);
+    if (ierr != 0) return nullptr; 
 
-    offmap_[index] = offset_t();
-    offmap_[index].off = 0;
-    offmap_[index].size = lret;
-    if (index > midx_.begin) { // media sequence
-        offmap_[index].off = offmap_[index-1].off + offmap_[index-1].size;
-    }
-    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+    if (index != midx_.cur) {
+        mp4_box_t* root = MP4_BoxGetRoot((stream_t *)this);
+        mp4_box_t* box = MP4_BoxSearchBox(root, ATOM_ftyp);
+        box = MP4_BoxSearchBox(box, ATOM_moof);
+        if (!box) return nullptr;
+        offmap_[index] = offset_t(box->i_pos, lret);
 
-    midx_.cur = index;
-    return true;
-}
-bool Stream::Prepare(long *size) {
-    if (!Init(midx_.cur)) return false;
-    long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) {
-        lret = offmap_[midx_.cur].size;
+        ierr = fseek(file_, box->i_pos, SEEK_SET);
+        if (ierr != 0) return nullptr; 
+    }else {
+        offmap_[index] = offset_t(0, lret);
     }
-    if (size)   *size = lret;
-    LOG(INFO) << __func__ << " lret=" << lret;
-    return true;
-}
-long Stream::Seek(int offset, int whence) {
-    if (!Init(midx_.cur)) return -1;
 
-    long lret = -1;
-    int cur = midx_.cur;
-    if (cur == -1) { // for html file
-        int ierr = fseek(file_, offset, whence);
-        if (ierr == 0) {
-            lret = ftell(file_);
-        }
-    }else { // for media sequence
-        int idx = -1;
-        int off = -1;
-        if (offset < offmap_[cur].off) { // backward
-            Close();
-            for (int k=cur; k >= midx_.begin; k--) {
-                off = offset - offmap_[k].off;
-                if (off > 0) {
-                    idx = k;
-                    break;
-                }
-            }
-        }else if (offset >= offmap_[cur].off + offmap_[cur].size) { //forward
-            for(int k=cur+1; k <= midx_.end; k++) {
-                Close();
-                if(!Init(k)) break;
-                off = offmap_[k].off + offmap_[k].size - offset;
-                if (off > 0) {
-                    idx = k;
-                    break;
-                }
-            }
-        }else {
-            idx = cur;
-            off = offset - offmap_[cur].off;
-        }
-        LOG(INFO) << __func__ << " cur=" << cur << " next=" << idx << " relative off=" << off;
+    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
-        if (idx == -1) return -1;
-        if (!Init(idx)) return -1;
-        int ierr = fseek(file_, off, whence);
-        if (ierr == 0)
-            lret = ftell(file_);
-    }
-    LOG(INFO) << __func__ << " lret=" << lret << " offset=" << offset;
-    return lret;
+    midx_.cur = index;
+    return file_;
 }
-int Stream::Read(char *buf, int size, int offset) {
-    if (!Init(midx_.cur)) return -1;
-
-    long lret = Seek(offset, SEEK_SET);
-    if (lret < 0) return -1;
+int Stream::Read(void *buf, int size) {
+    if (!Open(nullptr, 0)) return -1;
 
     int iret = fread(buf, 1, size, file_);
-    if (iret <= 0) {
-        LOG(INFO) << __func__ << " iret=" << iret 
-            << " size=" << size << " offset=" << offset;
-    }else if (iret < size) {
-        //lret = Seek(offset+iret, SEEK_SET);
-        //if (lret < 0) return iret;
-        //iret += fread(buf+iret, 1, size-iret, file_);
+    if (iret < size) {
         Close();
-        midx_.cur++;
+        if (midx_.cur != -1) midx_.cur++; // goto next file
     }
     return iret; 
 }
-void Stream::Close() {
+int Stream::Write(void *buf, int size) {
+    return -1;
+}
+int Stream::Peek(void *buf, int size) {
+    return -1;
+}
+uint64_t Stream::Seek(int64_t offset, int whence) {
+    return fseek(file_, offset, whence);
+}
+uint64_t Stream::Tell() {
+    return ftell(file_);
+}
+int Stream::Close() {
     if (file_) fclose(file_);
     file_ = nullptr;
+    return 0;
 }
-
 void Stream::Uninit() {
-    //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     Close();
     midx_.begin = -1;
     midx_.end = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 066d257..deb8aea 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -50,21 +50,39 @@ struct triple_t {
 };
 struct offset_t {
     offset_t() : off(0), size(0) {}
+    offset_t(long off, long size) : off(off), size(size) {}
+
     long off;
     long size;
 };
-class Stream : public base::RefCounted<Stream> {
+
+class IStream {
+public:
+   virtual void*    Open(const char* filename, int mode) = 0;
+   virtual int      Read(void* buf, int size) = 0;
+   virtual int      Write(void *buf, int size) = 0;
+   virtual int      Peek(void* buf, int size) = 0;
+   virtual uint64_t Seek(int64_t offset, int whence) = 0;
+   virtual uint64_t Tell() = 0;
+   virtual int      Close() = 0;
+
+   virtual ~IStream() {}
+};
+
+class Stream : public IStream, public base::RefCounted<Stream> {
 public:
+    virtual void*    Open(const char* fname, int mode) override;
+    virtual int      Read(void* buf, int size) override;
+    virtual int      Write(void *buf, int size) override;
+    virtual int      Peek(void* buf, int size) override;
+    virtual uint64_t Seek(int64_t offset, int whence) override;
+    virtual uint64_t Tell() override;
+    virtual int      Close() override;
+
     explicit Stream(const GURL &url);
-    GURL getUrl();
-    bool ParseSequence(int& index);
-    bool Init(int index);
     bool Prepare(long *size);
-    long Seek(int offset, int whence);
-    int Read(char *buf, int size, int offset);
-    void Close();
+    bool ParseSequence(int& index);
     void Uninit();
-
 protected:
     friend class base::RefCounted<Stream>;
     virtual ~Stream();
@@ -79,8 +97,8 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> stream_t;
-typedef std::map<std::string, StreamPtr>  streams_t;
+typedef std::pair<std::string, StreamPtr> StreamPtr_t;
+typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
 
 } // namespace mmt
 
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 3ce4bf5..13134d0 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1204,7 +1204,7 @@ extern "C" {
 #endif
 mp4_box_t *MP4_BoxGetRoot(stream_t * s);
 void MP4_BoxFree(stream_t * s, mp4_box_t *box);
-static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
+mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
 mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
 #ifdef __cplusplus
-- 
1.7.9.5


From ec3ff649b1263681b4d73808271449de65d31fa2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 05:27:54 -0800
Subject: [PATCH 48/92] [todo] add mpu to chrome

---
 net/mmt/mmt_stream.cc      |   37 +++++++++++++++++++++----------------
 net/mmt/mpu/mp4.c          |   24 ++++++++++++------------
 net/mmt/mpu/mp4.h          |    2 +-
 net/mmt/mpu/mpu.gyp        |    6 ++++--
 net/mmt/mpu/stream.c       |    2 +-
 net/mmt/mpu/test_parser.cc |    5 -----
 net/net.gyp                |    1 +
 7 files changed, 40 insertions(+), 37 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index bae7daf..378382e 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -81,8 +81,7 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
-Stream::Stream(const GURL &url) 
-    : url_(url), file_(nullptr) { 
+Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
     midx_.end = -1;
@@ -116,8 +115,8 @@ bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
     long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) {
-        lret = offmap_[midx_.cur].size; // for single file or the 1st file
+    if (midx_.cur == -1) { // for one single file
+        lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -151,6 +150,7 @@ void* Stream::Open(const char* filename, int mode) {
     file_ = fopen(fname.c_str(), "rb");
     if (!file_) return nullptr;
 
+    // get file size
     int ierr = fseek(file_, 0L, SEEK_END);
     if (ierr != 0) return nullptr; 
     long lret = ftell(file_);
@@ -158,28 +158,33 @@ void* Stream::Open(const char* filename, int mode) {
     if (ierr != 0) return nullptr; 
 
     if (index != midx_.cur) {
-        mp4_box_t* root = MP4_BoxGetRoot((stream_t *)this);
-        mp4_box_t* box = MP4_BoxSearchBox(root, ATOM_ftyp);
-        box = MP4_BoxSearchBox(box, ATOM_moof);
-        if (!box) return nullptr;
-        offmap_[index] = offset_t(box->i_pos, lret);
-
-        ierr = fseek(file_, box->i_pos, SEEK_SET);
+        mp4_box_t* root = MP4_BoxGetRoot((stream_t*)this);
+        mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+        mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
+        LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
+        long offset = -1;
+        if (box) offset = box->i_pos;
+        MP4_BoxFree((stream_t*)this, root);
+        if (offset == -1) return nullptr;
+        
+        // seek to the 1st moof-box
+        offmap_[index] = offset_t(offset, lret);
+        ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
-    }else {
+    }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
-
-    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+    LOG(INFO) << __func__ << " index=" << index
+        << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
     midx_.cur = index;
-    return file_;
+    return (void *)file_;
 }
 int Stream::Read(void *buf, int size) {
     if (!Open(nullptr, 0)) return -1;
 
     int iret = fread(buf, 1, size, file_);
-    if (iret < size) {
+    if (iret < size) { // read to eof
         Close();
         if (midx_.cur != -1) midx_.cur++; // goto next file
     }
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index bc6af51..adf2898 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -4,7 +4,7 @@
 #include <assert.h>
 #include <math.h>
 #include <stdarg.h>
-#include "net/mmt/mpu/mp4.h"
+#include "mp4.h"
 
 void *debug_malloc(size_t size, const char *file, int line, const char *func)
 {
@@ -25,7 +25,7 @@ void *debug_free(char *p)
             	free(p) ;
                 p = NULL;
             }
-
+            return p;
 }
 
 //#define free(p)  do {                                                                                   \
@@ -203,9 +203,9 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
    const uint8_t *p_buff = malloc(32);
    const uint8_t *p_peek = p_buff;
 
-   if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+   if( ( ( i_read = stream_peek( p_stream, (void*)p_peek, 32 ) ) < 8 ) )
    {
-      free(p_buff);
+      free((void*)p_buff);
       return 0;
    }
 
@@ -244,7 +244,7 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
       CreateUUID( &p_box->i_uuid, p_box->i_type );
    }
 
-   free(p_buff);
+   free((void*)p_buff);
 
 // #ifdef MP4_VERBOSE
 //    if( p_box->i_size )
@@ -367,7 +367,7 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
       int     i_read;
       uint32_t i_fcc;
 
-      i_read  = stream_peek( p_stream, p_peek, 44 );
+      i_read  = stream_peek( p_stream, (void *)p_peek, 44 );
 
       p_peek += mp4_box_headersize( p_box ) + 4;
       i_read -= mp4_box_headersize( p_box ) + 4;
@@ -381,11 +381,11 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
             printf( "detected moov hidden in a free box ..." );
 
             p_box->i_type = ATOM_foov;
-            free(p_buff);
+            free((void *)p_buff);
             return MP4_ReadBoxContainer( p_stream, p_box );
          }
       }
-      free(p_buff);
+      free((void *)p_buff);
    }
 
    /* Nothing to do */
@@ -815,7 +815,7 @@ static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
         MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
         MP4_GET4BYTES( p_box->data.p_mdhd->duration );
     }
-    p_box->data.p_mdhd->language_code = i_language = SwapBE16( p_peek );
+    p_box->data.p_mdhd->language_code = i_language = SwapBE16( (uint16_t)p_peek );
     for( i = 0; i < 3; i++ )
     {
         p_box->data.p_mdhd->language[i] =
@@ -1479,7 +1479,7 @@ static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
 {
    unsigned int i = 0;
    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
-   p_box->data.p_sample_soun->qt_description = NULL;
+   p_box->data.p_sample_soun->qt_description = 0;
 
    /* Sanity check needed because the "wave" box does also contain an
    * "mp4a" box that we don't understand. */
@@ -2289,7 +2289,7 @@ static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
 
    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
 
-   i_language = SwapBE16( p_peek );
+   i_language = SwapBE16( (uint16_t)p_peek );
    for( i = 0; i < 3; i++ )
    {
       p_box->data.p_cprt->language[i] =
@@ -3576,7 +3576,7 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 * MP4_ReadBox : parse the actual box and the children
 *  XXX : Do not go to the next box
 *****************************************************************************/
-static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
+mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
 {
    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
    unsigned int i_index;
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 13134d0..8cff958 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1,7 +1,7 @@
 #ifndef NET_MMT_MPU_MP4_H_
 #define NET_MMT_MPU_MP4_H_
 
-#include "net/mmt/mpu/stream.h"
+#include "stream.h"
 
 
 #define MP4_FOURCC( a, b, c, d ) \
diff --git a/net/mmt/mpu/mpu.gyp b/net/mmt/mpu/mpu.gyp
index 8f5acf2..597fb94 100644
--- a/net/mmt/mpu/mpu.gyp
+++ b/net/mmt/mpu/mpu.gyp
@@ -22,8 +22,10 @@
   'targets': [
     {
       'target_name': 'libmpu',
-      'type': '<(component)',
-      'product_name': 'libmpu',  # Don't conflict with OpenSSL's libssl
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mpu',
       'sources': [
         'stream.c',
         'mp4.c',
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
index 571d68b..8be0258 100644
--- a/net/mmt/mpu/stream.c
+++ b/net/mmt/mpu/stream.c
@@ -3,7 +3,7 @@
 #include <malloc.h>
 #include <memory.h>
 #include <assert.h>
-#include "net/mmt/mpu/stream.h"
+#include "stream.h"
 
 #define max(a,b) a>b?a:b
 #define min(a,b) a>b?b:a
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index e65bf45..0a3e294 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -34,11 +34,6 @@ int main(int argc, char* argv[])
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
     }
 
-    box = MP4_BoxSearchBox(box, ATOM_mdat);
-    if (box) {
-        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
-
     box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
     if (box) {
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
diff --git a/net/net.gyp b/net/net.gyp
index 242582f..5b77dba 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -96,6 +96,7 @@
         '../url/url.gyp:url_lib',
         'net_derived_sources',
         'net_resources',
+        '../net/mmt/mpu/mpu.gyp:libmpu',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
-- 
1.7.9.5


From 8ef655e00ec8974453079c1fa3214808d54b711b Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 07:36:15 -0800
Subject: [PATCH 49/92] refile stream for mpu

---
 net/mmt/mmt_stream.cc      |   47 ++++++++++++++++++++++++++++++++++++++----
 net/mmt/mpu/stream.h       |   12 +++++------
 net/mmt/mpu/test_parser.cc |   49 ++++++++++++++++++++++++++++++++++++--------
 3 files changed, 89 insertions(+), 19 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 378382e..640fb07 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -81,6 +81,40 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
+void* mmtp_open(stream_t *s, const char* filename, int mode) {
+    return ((Stream*)s->opaque)->Open(filename, mode);
+}
+int mmtp_read(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Read(buf, size);
+}
+int mmtp_write(stream_t *s, void *buf, int size) {
+    return ((Stream*)s->opaque)->Write(buf, size);
+}
+int mmtp_peek(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Peek(buf, size);
+}
+uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
+    return ((Stream*)s->opaque)->Seek(offset, whence);
+}
+uint64_t mmtp_tell(stream_t *s) {
+    return ((Stream*)s->opaque)->Tell();
+}
+int mmtp_close(stream_t *s) {
+    return ((Stream*)s->opaque)->Close();
+}
+static stream_t* InitMpuStream(Stream* ptr) {
+    stream_t* s = (stream_t*)malloc(sizeof(stream_t));
+    s->opaque = (void*)ptr;
+    s->open = mmtp_open;
+    s->read = mmtp_read;
+    s->write = mmtp_write;
+    s->peek = mmtp_peek;
+    s->seek = mmtp_seek;
+    s->tell = mmtp_tell;
+    s->close = mmtp_close;
+    return s;
+}
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
@@ -157,14 +191,16 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != midx_.cur) {
-        mp4_box_t* root = MP4_BoxGetRoot((stream_t*)this);
+    if (index != midx_.begin) {
+        stream_t* s = InitMpuStream(this);
+        mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
         mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
         LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
         long offset = -1;
         if (box) offset = box->i_pos;
-        MP4_BoxFree((stream_t*)this, root);
+        MP4_BoxFree(s, root);
+        free(s);
         if (offset == -1) return nullptr;
         
         // seek to the 1st moof-box
@@ -194,7 +230,10 @@ int Stream::Write(void *buf, int size) {
     return -1;
 }
 int Stream::Peek(void *buf, int size) {
-    return -1;
+    long offset = ftell(file_);
+    int iret = fread(buf, 1, size, file_);
+    fseek(file_, offset, SEEK_SET);
+    return iret;
 }
 uint64_t Stream::Seek(int64_t offset, int whence) {
     return fseek(file_, offset, whence);
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index 6d570b4..e528a9e 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -97,10 +97,8 @@ stream_t* create_buf_file_stream();
 void destory_buf_file_stream(stream_t* stream_s);
 
 // .
-#undef LIL_ENDIAN
-#undef BIG_ENDIAN
-#define LIL_ENDIAN	1234
-#define BIG_ENDIAN	4321
+#define LIL_ENDIAN__	1234
+#define BIG_ENDIAN__	4321
 /* #define BYTEORDER    1234 ? . */
 
 #ifndef BYTEORDER
@@ -109,9 +107,9 @@ void destory_buf_file_stream(stream_t* stream_s);
    (defined(__MIPS__) && defined(__MISPEB__)) || \
    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
    defined(__sparc__)
-#define BYTEORDER	BIG_ENDIAN
+#define BYTEORDER	BIG_ENDIAN__
 #else
-#define BYTEORDER	LIL_ENDIAN
+#define BYTEORDER	LIL_ENDIAN__
 #endif
 #endif /* !BYTEORDER */
 
@@ -119,7 +117,7 @@ uint16_t Swap16(uint16_t x);
 uint32_t Swap32(uint32_t x);
 uint64_t Swap64(uint64_t x);
 
-#if BYTEORDER == LIL_ENDIAN
+#if BYTEORDER == LIL_ENDIAN__
 #define SwapLE16(X)	(X)
 #define SwapLE32(X)	(X)
 #define SwapLE64(X)	(X)
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 0a3e294..4263520 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -4,6 +4,35 @@
 #include "stream.h"
 #include "mp4.h"
 
+mp4_box_t* print_traf(mp4_box_t* box) {
+    printf("\n");
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_traf);
+        if (!box) break;
+        printf("traf: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+
+        box = MP4_BoxSearchBox(box, ATOM_tfhd);
+        if (!box) break;
+        else {
+            printf("tfhd: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%u size=%u\n", 
+                box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
+                box->data.p_tfhd->base_data_offset, box->data.p_tfhd->default_sample_size);
+        }
+
+        box = MP4_BoxSearchBox(box, ATOM_trun);
+        if (!box) break;
+        else {
+            printf("trun: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
+                box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
+                box->data.p_trun->data_offset);
+        }
+    }while(0);
+    printf("\n");
+    return box;
+}
+
 int main(int argc, char* argv[])
 {
     if (argc != 2) {
@@ -27,20 +56,24 @@ int main(int argc, char* argv[])
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
     if (box) {
         printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }else {
+        box = root;
     }
 
-    box = MP4_BoxSearchBox(box, ATOM_moof);
-    if (box) {
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_moof);
+        if (!box) break;
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
 
-    box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
-    if (box) {
-        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
+        box = print_traf(box);
+        box = print_traf(box);
 
-    MP4_BoxFree(s, root);
+        box = MP4_BoxSearchBox(box, ATOM_mdat);
+        if (!box) break;
+        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }while(1);
 
+    MP4_BoxFree(s, root);
     stream_close(s);
     destory_file_stream(s);
 
-- 
1.7.9.5


From a20772e9d65103c28fc3758341a3c130c7c99046 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 20:51:21 -0800
Subject: [PATCH 50/92] [ok][todo] for mmt parser and stream

---
 net/mmt/mmt_control.cc |   33 +---------------
 net/mmt/mmt_control.h  |    1 -
 net/mmt/mmt_inc.h      |    9 +++++
 net/mmt/mmt_parser.cc  |   21 ++++++++++
 net/mmt/mmt_parser.h   |   29 ++++++++++++++
 net/mmt/mmt_stream.cc  |   77 ++++--------------------------------
 net/mmt/mmt_stream.h   |    3 --
 net/mmt/mmt_utils.cc   |  101 ++++++++++++++++++++++++++++++++++++++++++++++++
 net/net.gyp            |   11 +++++-
 net/net.gypi           |    4 +-
 10 files changed, 181 insertions(+), 108 deletions(-)
 create mode 100644 net/mmt/mmt_parser.cc
 create mode 100644 net/mmt/mmt_parser.h
 create mode 100644 net/mmt/mmt_utils.cc

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 4b51ef8..6928caa 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -144,7 +144,7 @@ void MmtControl::Run() {
 
         std::string head = msg.head;
         if (head == "@ctrl") {
-            PostNativeMsg(msg.body);
+            SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
             StreamOpen(msg);
@@ -185,36 +185,5 @@ void MmtControl::Push(ctrl_msg_t &msg) {
     lock_.Release();
 }
 
-
-void PostNativeMsg(std::string msg) {
-    int sock = socket(AF_INET, SOCK_DGRAM, 0);
-    if(sock <= 0) {
-        LOG(INFO) << __func__ << " Open failed sock=" << sock;
-        return;
-    }
-    
-    int port = 54321;
-    std::string szaddr = "127.0.0.1";
-    net::IPAddressNumber ipnum;
-    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
-        return;
-    }
-
-    net::IPEndPoint ip(ipnum, port);
-    struct sockaddr addr;
-    socklen_t addrlen;
-    if(!ip.ToSockAddr(&addr, &addrlen)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ToSockAddr failed";
-        return;
-    }
-
-    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
-    LOG(INFO) << __func__ << " sendto iret=" << iret;
-    close(sock);
-}
-
 } // namespace mmt
 
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 3f09941..f597605 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -67,7 +67,6 @@ private:
 namespace mmt {
 
 void StartMmtCtrl();
-void PostNativeMsg(std::string msg);
 
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index ebe8715..485621b 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -5,6 +5,7 @@
 #include <sstream>
 #include <iomanip>
 
+#include "base/logging.h"
 #include "base/values.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
@@ -33,9 +34,17 @@
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "url/gurl.h"
 
+
 namespace mmt{
+
 void Wait(int ms);
+std::string Int2String(int value, int width=0);
+int String2Int(std::string value);
 std::string GURL2FilePath(GURL gurl);
+std::string GetQueryValue(std::string query, std::string key);
+bool GetRangeValue(std::string range, int &lval, int &rval);
+int SendToHost(std::string msg, std::string szaddr, int port);
+
 }
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
new file mode 100644
index 0000000..70ed2ed
--- /dev/null
+++ b/net/mmt/mmt_parser.cc
@@ -0,0 +1,21 @@
+#include "net/mmt/mmt_parser.h"
+
+#include "libxml/parser.h"
+
+namespace mmt {
+
+CiParser::CiParser(std::string xml) : xml_(xml) {
+}
+
+CiParser::~CiParser() {
+}
+
+bool Parse() {
+    return true;
+}
+
+bool Merge(const CiParser& parser) {
+    return true;
+}
+
+}
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
new file mode 100644
index 0000000..77a14d0
--- /dev/null
+++ b/net/mmt/mmt_parser.h
@@ -0,0 +1,29 @@
+#ifndef NET_MMT_MMT_PARSER_H_
+#define NET_MMT_MMT_PARSER_H_
+
+#include "base/memory/ref_counted.h"
+
+namespace mmt {
+
+class CiParser : public base::RefCounted<CiParser> {
+public:
+    explicit CiParser(std::string xml);
+
+    bool Parse();
+    bool Merge(const CiParser& parser);
+
+protected:
+    friend class base::RefCounted<CiParser>;
+    virtual ~CiParser();
+
+private:
+    std::string xml_;
+
+};
+typedef scoped_refptr<CiParser> CiParserPtr;
+
+
+} // namespace mmt
+
+
+#endif // NET_MMT_MMT_PARSER_H_
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 640fb07..bf8a3a6 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,67 +4,6 @@
 
 namespace mmt {
 
-void Wait(int ms) {
-    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
-}
-std::string Int2String(int value, int width=0) {
-    std::string szval;
-    std::stringstream sstr;
-    if (width == 0)
-        sstr << value;
-    else
-        sstr << std::setfill('0') << std::setw(width)<< value;
-    sstr >> szval;
-    return szval;
-}
-int String2Int(std::string value) {
-    int ival = -1;
-    std::stringstream sstr;
-    sstr << value;
-    sstr >> ival;
-    return ival;
-}
-std::string GURL2FilePath(GURL gurl) {
-    std::string szpath;
-    base::FilePath file_path;
-    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
-    if (is_file) {
-        szpath = file_path.value();
-    }
-    return szpath;
-}
-std::string GetQueryValue(std::string query, std::string key) {
-    std::string value;
-    std::string::size_type begin, end;
-
-    key += "=";
-    begin = query.find(key);
-    if (begin != std::string::npos) {
-        begin += key.size();
-        end = query.find("&", begin);
-        if (end == std::string::npos)
-            end = query.size();
-        value = query.substr(begin, end-begin);
-    }
-    return value;
-}
-bool GetRangeValue(std::string range, int &lval, int &rval) {
-    bool bok = false;
-    std::string lstr = "0";
-    std::string rstr = "9999999";
-    int begin = range.find("-");
-    if (begin >= 0) {
-        lstr = range.substr(0, begin);
-        if (lstr.empty()) lstr = "-1";
-        rstr = range.substr(begin+1, range.size()-begin);
-        if (rstr.empty()) rstr = "9999999";
-        bok = true;
-    }
-    lval = String2Int(lstr);
-    rval = String2Int(rstr);
-    return bok;
-}
-
 content_t::content_t() {
     process_id = 0;
     frame_id = 0;
@@ -78,28 +17,28 @@ content_t::~content_t() {
 } // namespace mmt
 
 
-/// for class Stream and StreamPool
+/// for class Stream
 namespace mmt {
 
-void* mmtp_open(stream_t *s, const char* filename, int mode) {
+static void* mmtp_open(stream_t *s, const char* filename, int mode) {
     return ((Stream*)s->opaque)->Open(filename, mode);
 }
-int mmtp_read(stream_t *s, void* buf, int size) {
+static int mmtp_read(stream_t *s, void* buf, int size) {
     return ((Stream*)s->opaque)->Read(buf, size);
 }
-int mmtp_write(stream_t *s, void *buf, int size) {
+static int mmtp_write(stream_t *s, void *buf, int size) {
     return ((Stream*)s->opaque)->Write(buf, size);
 }
-int mmtp_peek(stream_t *s, void* buf, int size) {
+static int mmtp_peek(stream_t *s, void* buf, int size) {
     return ((Stream*)s->opaque)->Peek(buf, size);
 }
-uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
+static uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
     return ((Stream*)s->opaque)->Seek(offset, whence);
 }
-uint64_t mmtp_tell(stream_t *s) {
+static uint64_t mmtp_tell(stream_t *s) {
     return ((Stream*)s->opaque)->Tell();
 }
-int mmtp_close(stream_t *s) {
+static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
 static stream_t* InitMpuStream(Stream* ptr) {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index deb8aea..d552463 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -6,15 +6,12 @@
 #include <vector>
 #include <sstream>
 
-#include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
 #include "base/threading/thread_restrictions.h"
-#include "base/memory/ref_counted.h"
 #include "base/threading/simple_thread.h"
-#include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
 #include "base/time/time.h"
 #include "url/gurl.h"
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
new file mode 100644
index 0000000..76b9776
--- /dev/null
+++ b/net/mmt/mmt_utils.cc
@@ -0,0 +1,101 @@
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
+}
+std::string Int2String(int value, int width) {
+    std::string szval;
+    std::stringstream sstr;
+    if (width == 0)
+        sstr << value;
+    else
+        sstr << std::setfill('0') << std::setw(width)<< value;
+    sstr >> szval;
+    return szval;
+}
+int String2Int(std::string value) {
+    int ival = -1;
+    std::stringstream sstr;
+    sstr << value;
+    sstr >> ival;
+    return ival;
+}
+std::string GURL2FilePath(GURL gurl) {
+    std::string szpath;
+    base::FilePath file_path;
+    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
+    if (is_file) {
+        szpath = file_path.value();
+    }
+    return szpath;
+}
+std::string GetQueryValue(std::string query, std::string key) {
+    std::string value;
+    std::string::size_type begin, end;
+
+    key += "=";
+    begin = query.find(key);
+    if (begin != std::string::npos) {
+        begin += key.size();
+        end = query.find("&", begin);
+        if (end == std::string::npos)
+            end = query.size();
+        value = query.substr(begin, end-begin);
+    }
+    return value;
+}
+bool GetRangeValue(std::string range, int &lval, int &rval) {
+    bool bok = false;
+    std::string lstr = "0";
+    std::string rstr = "9999999";
+    int begin = range.find("-");
+    if (begin >= 0) {
+        lstr = range.substr(0, begin);
+        if (lstr.empty()) lstr = "-1";
+        rstr = range.substr(begin+1, range.size()-begin);
+        if (rstr.empty()) rstr = "9999999";
+        bok = true;
+    }
+    lval = String2Int(lstr);
+    rval = String2Int(rstr);
+    return bok;
+}
+
+int SendToHost(std::string msg, std::string szaddr, int port) {
+    if (msg.empty() || szaddr.empty() || port <= 0) 
+        return -1;
+
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return -1;
+    }
+    
+    int iret = -1;
+    do{
+        net::IPAddressNumber ipnum;
+        if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+            LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+            break;
+        }
+
+        struct sockaddr addr;
+        socklen_t addrlen;
+        net::IPEndPoint ip(ipnum, port);
+        if(!ip.ToSockAddr(&addr, &addrlen)) {
+            LOG(INFO) << __func__ << " ToSockAddr failed";
+            break;
+        }
+
+        iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    }while(0);
+
+    close(sock);
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    return iret;
+}
+
+
+} // namespace mmt
diff --git a/net/net.gyp b/net/net.gyp
index 5b77dba..ceb82ee 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -36,6 +36,11 @@
         'use_v8_in_net%': 1,
         'enable_built_in_dns%': 1,
       }],
+      ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+        'os_include': 'linux'
+      }],
+      ['OS=="mac"', {'os_include': 'mac'}],
+      ['OS=="win"', {'os_include': 'win32'}],
     ],
   },
   'includes': [
@@ -103,8 +108,10 @@
         '<@(net_non_nacl_sources)',
       ],
       'include_dirs': [
-         '../skia/config',
-         '../third_party/skia/include/core',
+        '../skia/config',
+        '../third_party/skia/include/core',
+        '../third_party/libxml/src/include',
+        '../third_party/libxml/<(os_include)/include',
       ],
       'defines': [
         'NET_IMPLEMENTATION',
diff --git a/net/net.gypi b/net/net.gypi
index 99959ba..ea5c471 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,8 +700,10 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
-      'mmt/mmt_stream.cc',
       'mmt/mmt_control.cc',
+      'mmt/mmt_parser.cc',
+      'mmt/mmt_stream.cc',
+      'mmt/mmt_utils.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
-- 
1.7.9.5


From ab032b1415248b8109e9e72acfd2a85e6887f6f9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 00:03:18 -0800
Subject: [PATCH 51/92] [todo] implement xml parser

---
 net/mmt/mmt_parser.cc |   86 +++++++++++++++++++++++++++++++++++++++++++++++--
 net/mmt/mmt_parser.h  |    6 ++--
 net/mmt/mmt_stream.cc |    4 ++-
 net/mmt/mmt_stream.h  |    5 +--
 4 files changed, 93 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 70ed2ed..63ac417 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -1,16 +1,98 @@
 #include "net/mmt/mmt_parser.h"
+#include "net/mmt/mmt_stream.h"
 
 #include "libxml/parser.h"
 
 namespace mmt {
 
-CiParser::CiParser(std::string xml) : xml_(xml) {
+struct node {
+	char *name;
+	struct node *parent;
+};
+
+static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts)
+{
+    fprintf(stdout, "[xml][start] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+	while (NULL != atts && NULL != *atts) {
+        if (atts[0] && atts[1]) {
+            fprintf(stdout, "[xml][start] attr name=%s value=%s", atts[0], atts[1]);
+        }else if (atts[0]) {
+            fprintf(stdout, "[xml][start] attr name=%s", atts[0]);
+        }
+		atts += 2;
+	}
+}
+
+static void sax_end_element(void *x,const xmlChar *name)
+{
+    fprintf(stdout, "[xml][end] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+}
+
+static void sax_characters(void *x,const xmlChar *ch,int len)
+{
+}
+
+static void sax_pi(void *x,const xmlChar *target,const xmlChar *data)
+{
+    fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
+}
+
+static void sax_comment(void *x,const xmlChar *value)
+{
+    fprintf(stdout, "[xml][comment] %s\n", value);
+}
+
+static void sax_error(void *x,const char *msg,...)
+{
+	va_list ap;
+	va_start(ap,msg);
+	fputs("[xml][error] ",stderr);
+	vfprintf(stderr,msg,ap);
+	va_end(ap);
+}
+
+static void init(xmlSAXHandlerPtr sax)
+{
+	sax->startElement = sax_start_element;
+	sax->endElement = sax_end_element;
+	sax->characters = sax_characters;
+	sax->processingInstruction = sax_pi;
+	sax->comment = sax_comment;
+	sax->warning = sax_error;
+	sax->error = sax_error;
+	sax->fatalError = sax_error;
+}
+
+
+CiParser::CiParser(const std::string& fname) : fname_(fname) {
 }
 
 CiParser::~CiParser() {
 }
 
-bool Parse() {
+bool CiParser::ParseXml() {
+    if (fname_.empty()) return false;
+
+	xmlSAXHandler sax;
+	xmlParserCtxtPtr ctxt;
+
+	xmlSubstituteEntitiesDefault(1);
+	memset(&sax,'\0',sizeof(sax));
+	init(&sax);
+
+	ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
+    ctxt->_private = (void *)this;
+    LOG(INFO) << __func__ << " thiz=" << this;
+
+	int num;
+	char buffer[4096];
+    StreamPtr stream = new Stream(fname_);
+    if (!stream->Prepare(nullptr)) return false;
+	while (0 < (num = stream->Read(buffer,sizeof(buffer)))
+	   &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
+	xmlParseChunk(ctxt,NULL,0,1);
+	xmlFreeParserCtxt(ctxt);
+
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 77a14d0..6883afe 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -7,9 +7,9 @@ namespace mmt {
 
 class CiParser : public base::RefCounted<CiParser> {
 public:
-    explicit CiParser(std::string xml);
+    explicit CiParser(const std::string& fname);
 
-    bool Parse();
+    bool ParseXml();
     bool Merge(const CiParser& parser);
 
 protected:
@@ -17,7 +17,7 @@ protected:
     virtual ~CiParser();
 
 private:
-    std::string xml_;
+    std::string fname_;
 
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index bf8a3a6..5c40616 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -60,6 +60,8 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
     midx_.end = -1;
     midx_.cur = -1;
 }
+Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
+}
 
 Stream::~Stream() {
     Uninit();
@@ -130,7 +132,7 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != midx_.begin) {
+    if (index != -1 && index != midx_.begin) {
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d552463..6142b3a 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -76,8 +76,9 @@ public:
     virtual uint64_t Tell() override;
     virtual int      Close() override;
 
-    explicit Stream(const GURL &url);
-    bool Prepare(long *size);
+    explicit Stream(const GURL& url);
+    explicit Stream(const std::string& szurl);
+    bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
 protected:
-- 
1.7.9.5


From f61d90e750985f799c816d719495860a2a726ff3 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 04:35:36 -0800
Subject: [PATCH 52/92] [done] for xml parser

---
 net/mmt/mmt_parser.cc |  152 ++++++++++++++++++++++++++++++-------------------
 net/mmt/mmt_parser.h  |   31 +++++++++-
 2 files changed, 123 insertions(+), 60 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 63ac417..6e479b3 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -5,66 +5,66 @@
 
 namespace mmt {
 
-struct node {
-	char *name;
-	struct node *parent;
-};
-
-static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts)
-{
-    fprintf(stdout, "[xml][start] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
-	while (NULL != atts && NULL != *atts) {
+static const char kNoValue[] = "no-value";
+
+static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->AddNode((const char*)name);
+
+    while (NULL != atts && NULL != *atts) {
         if (atts[0] && atts[1]) {
-            fprintf(stdout, "[xml][start] attr name=%s value=%s", atts[0], atts[1]);
+            if (ptr) ptr->AddAttr((const char*)atts[0], (const char*)atts[1]);
         }else if (atts[0]) {
-            fprintf(stdout, "[xml][start] attr name=%s", atts[0]);
+            if (ptr) ptr->AddAttr((const char*)atts[0], kNoValue);
         }
-		atts += 2;
-	}
+        atts += 2;
+    }
 }
-
-static void sax_end_element(void *x,const xmlChar *name)
-{
-    fprintf(stdout, "[xml][end] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+static void sax_end_element(void *x,const xmlChar *name){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->EndNode((const char*)name);
 }
-
-static void sax_characters(void *x,const xmlChar *ch,int len)
-{
+static void sax_characters(void *x,const xmlChar *ch,int len){
 }
-
-static void sax_pi(void *x,const xmlChar *target,const xmlChar *data)
-{
+static void sax_pi(void *x,const xmlChar *target,const xmlChar *data){
     fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
 }
-
-static void sax_comment(void *x,const xmlChar *value)
-{
+static void sax_comment(void *x,const xmlChar *value) {
     fprintf(stdout, "[xml][comment] %s\n", value);
 }
-
-static void sax_error(void *x,const char *msg,...)
-{
-	va_list ap;
-	va_start(ap,msg);
-	fputs("[xml][error] ",stderr);
-	vfprintf(stderr,msg,ap);
-	va_end(ap);
+static void sax_error(void *x,const char *msg,...){
+    va_list ap;
+    va_start(ap,msg);
+    fputs("[xml][error] ",stderr);
+    vfprintf(stderr,msg,ap);
+    va_end(ap);
 }
 
-static void init(xmlSAXHandlerPtr sax)
-{
-	sax->startElement = sax_start_element;
-	sax->endElement = sax_end_element;
-	sax->characters = sax_characters;
-	sax->processingInstruction = sax_pi;
-	sax->comment = sax_comment;
-	sax->warning = sax_error;
-	sax->error = sax_error;
-	sax->fatalError = sax_error;
+static void init_sax(xmlSAXHandlerPtr sax) {
+    sax->startElement = sax_start_element;
+    sax->endElement = sax_end_element;
+    sax->characters = sax_characters;
+    sax->processingInstruction = sax_pi;
+    sax->comment = sax_comment;
+    sax->warning = sax_error;
+    sax->error = sax_error;
+    sax->fatalError = sax_error;
 }
 
+} // namespace mmt
+
 
-CiParser::CiParser(const std::string& fname) : fname_(fname) {
+namespace mmt {
+
+node_t::node_t(std::string name) 
+    : name(name), parent(nullptr) {
+}
+node_t::~node_t() {
+    nodes.clear();
+}
+
+CiParser::CiParser(const std::string& fname) 
+    : fname_(fname), root_(nullptr), cur_(nullptr) {
 }
 
 CiParser::~CiParser() {
@@ -73,31 +73,65 @@ CiParser::~CiParser() {
 bool CiParser::ParseXml() {
     if (fname_.empty()) return false;
 
-	xmlSAXHandler sax;
-	xmlParserCtxtPtr ctxt;
+    xmlSAXHandler sax;
+    xmlParserCtxtPtr ctxt;
 
-	xmlSubstituteEntitiesDefault(1);
-	memset(&sax,'\0',sizeof(sax));
-	init(&sax);
+    xmlSubstituteEntitiesDefault(1);
+    memset(&sax,'\0',sizeof(sax));
+    init_sax(&sax);
 
-	ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
+    ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
     ctxt->_private = (void *)this;
-    LOG(INFO) << __func__ << " thiz=" << this;
 
-	int num;
-	char buffer[4096];
     StreamPtr stream = new Stream(fname_);
     if (!stream->Prepare(nullptr)) return false;
-	while (0 < (num = stream->Read(buffer,sizeof(buffer)))
-	   &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
-	xmlParseChunk(ctxt,NULL,0,1);
-	xmlFreeParserCtxt(ctxt);
 
+    int num;
+    char buffer[4096];
+    while (0 < (num = stream->Read(buffer,sizeof(buffer)))
+            &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
+    xmlParseChunk(ctxt,NULL,0,1);
+    xmlFreeParserCtxt(ctxt);
+
+    return true;
+}
+
+bool CiParser::Merge(const CiParser& parser) {
+    return false;
+}
+
+bool CiParser::AddNode(std::string name) {
+    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    nodeptr_t node = new node_t(name);
+    if (!root_)  {
+        root_ = node;
+        cur_ = root_;
+        return true;
+    }
+
+    if (!cur_) return false; // the end of xml file
+    node->parent = cur_;
+    cur_->nodes.push_back(node);
+    cur_ = node;
     return true;
 }
 
-bool Merge(const CiParser& parser) {
+bool CiParser::EndNode(std::string name) {
+    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
+    if (!cur_) return false;
+    if (name != cur_->name) {
+        LOG(INFO) << __func__ << " name=" << name;
+    }
+    cur_ = cur_->parent;
     return true;
 }
 
+bool CiParser::AddAttr(std::string name, std::string value) {
+    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+        << " attr: " << name << " => " << value;
+    if (!cur_) return false;
+    cur_->attrs[name] = value;
+    return true;
 }
+
+} // namespace mmt
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 6883afe..b04718e 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -1,10 +1,34 @@
 #ifndef NET_MMT_MMT_PARSER_H_
 #define NET_MMT_MMT_PARSER_H_
 
+#include <map>
+#include <string>
+#include <vector>
 #include "base/memory/ref_counted.h"
 
 namespace mmt {
 
+struct attr_t {
+    std::string name;
+    std::string value;
+};
+
+struct node_t : public base::RefCounted<node_t>{
+public:
+    explicit node_t(std::string name);
+
+    std::string name;
+    std::map<std::string, std::string> attrs;
+    std::vector<scoped_refptr<node_t> > nodes; // sub-nodes
+    scoped_refptr<node_t> parent;
+
+protected:
+    friend class base::RefCounted<node_t>;
+    virtual ~node_t();
+};
+typedef scoped_refptr<node_t> nodeptr_t;
+
+
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
@@ -12,13 +36,18 @@ public:
     bool ParseXml();
     bool Merge(const CiParser& parser);
 
+    bool AddNode(std::string name);
+    bool EndNode(std::string name);
+    bool AddAttr(std::string name, std::string value);
+    
 protected:
     friend class base::RefCounted<CiParser>;
     virtual ~CiParser();
 
 private:
     std::string fname_;
-
+    nodeptr_t root_;
+    nodeptr_t cur_; // only for AddNode and AddAttr
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From 3eeae87fc0e1ff71073f3284e95252d1ff6ee828 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 08:22:36 -0800
Subject: [PATCH 53/92] [todo] process ci time range

---
 net/mmt/mmt_parser.cc |   54 +++++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mmt_parser.h  |   17 ++++++++--------
 2 files changed, 63 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 6e479b3..4be7897 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -126,11 +126,65 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
+int ParseTimeStr(std::string timestr) {
+    int sec = atoi(timestr.c_str());
+    std::string::size_type lpos, rpos;
+    lpos = timestr.find(":");
+    rpos = timestr.rfind(":");
+    if (lpos != std::string::npos) {
+        if (lpos != rpos) {
+            sec = sec * 3600;
+            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+        }else {
+            sec = sec * 60;
+        }
+    }
+    return sec;
+}
+
+bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
+    bool is_begin = true;
+    std::string::size_type pos;
+
+    pos = value.find(".begin");
+    if (pos == std::string::npos) {
+        is_begin = false;
+        pos = value.find(".end");
+    }
+    if (pos == std::string::npos) {
+        return false;
+    }
+
+    second = -2;
+    std::string idstr = value.substr(0, pos);
+    nodeptrs_t::iterator iter = node->nodes.begin();
+    for (; iter != node->nodes.end(); iter++) {
+        nodeptr_t sub = *iter;
+        if (sub->name == "mmtci:MediaSync") {
+            if (sub->attrs["refId"] == idstr) {
+                std::string timestr = (is_begin) ? sub->attrs["mmtci:begin"] : sub->attrs["mmtci:end"];
+                second = ParseTimeStr(timestr);
+            }
+        }
+    }
+    return true;
+}
+
 bool CiParser::AddAttr(std::string name, std::string value) {
     LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
         << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
+    if (name == "mmtci:begin" || name == "mmtci:end") {
+        int sec = -2;
+        if(!ParseTimeById(root_, value, sec))
+            sec = ParseTimeStr(value);
+        if (name == "mmtci:begin")
+            cur_->time.first = sec;
+        else
+            cur_->time.second = sec;
+        LOG(INFO) << __func__ << " sec=" << sec; 
+    }
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index b04718e..fa66194 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -8,25 +8,26 @@
 
 namespace mmt {
 
-struct attr_t {
-    std::string name;
-    std::string value;
-};
+struct node_t;
+typedef scoped_refptr<node_t> nodeptr_t;
+typedef std::map<std::string, std::string> attrs_t;
+typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
+typedef std::pair<int, int> range_t;
 
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
 
     std::string name;
-    std::map<std::string, std::string> attrs;
-    std::vector<scoped_refptr<node_t> > nodes; // sub-nodes
-    scoped_refptr<node_t> parent;
+    attrs_t attrs;
+    range_t time;     // for time range
+    nodeptrs_t nodes; // sub-nodes
+    nodeptr_t parent;
 
 protected:
     friend class base::RefCounted<node_t>;
     virtual ~node_t();
 };
-typedef scoped_refptr<node_t> nodeptr_t;
 
 
 class CiParser : public base::RefCounted<CiParser> {
-- 
1.7.9.5


From 912e65954b0a68c380bca2b13d6fd4a6a0ec0766 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 00:36:40 -0800
Subject: [PATCH 54/92] [todo] process <div><video><audio>

---
 net/mmt/mmt_parser.cc |  128 ++++++++++++++++++++++++++++++++++++++++++++-----
 net/mmt/mmt_parser.h  |   40 +++++++++++++++-
 2 files changed, 154 insertions(+), 14 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 4be7897..5a8d1e8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -7,6 +7,22 @@ namespace mmt {
 
 static const char kNoValue[] = "no-value";
 
+// node
+//static const char kCI[]             = "mmtci:CI";
+//static const char kview[]           = "mmtci:view";
+static const char kdivLocation[]    = "mmtci:divLocation";
+static const char kMediaSync[]      = "mmtci:MediaSync";
+static const char ksourceList[]     = "mmtci:sourceList";
+
+// attr
+static const char krefId[]      = "refId";
+static const char krefDiv[]     = "mmtci:refDiv";
+static const char kmediaSrc[]   = "mmtci:mediaSrc";
+static const char kbegin[]      = "mmtci:begin";
+static const char kend[]        = "mmtci:end";
+static const char kstyle[]      = "style";
+
+
 static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
     CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
     if (ptr) ptr->AddNode((const char*)name);
@@ -63,6 +79,17 @@ node_t::~node_t() {
     nodes.clear();
 }
 
+// for html tag <div>, <audio>, <video>
+html_div_t::html_div_t() {
+}
+html_div_t::~html_div_t() {
+}
+html_media_t::html_media_t() {
+}
+html_media_t::~html_media_t() {
+}
+
+
 CiParser::CiParser(const std::string& fname) 
     : fname_(fname), root_(nullptr), cur_(nullptr) {
 }
@@ -96,8 +123,84 @@ bool CiParser::ParseXml() {
     return true;
 }
 
-bool CiParser::Merge(const CiParser& parser) {
-    return false;
+bool CiParser::ParseHtmlTag() {
+    nodeptr_t node = root_;
+    if (!node) return false;
+
+    nodeptrs_t::iterator iter = node->nodes.begin();
+    for (; iter != node->nodes.end(); iter++) {
+        nodeptr_t sub = *iter;
+        if (sub->name == kdivLocation) {
+            if (sub->attrs.find(krefDiv) == sub->attrs.end())
+                continue;
+
+            divptr_t div = new html_div_t;
+            div->id = sub->attrs[krefDiv];
+            div->style = sub->attrs[kstyle];
+            divs_.push_back(div);
+        }else if (sub->name == kMediaSync) {
+            if (sub->attrs.find(krefId) == sub->attrs.end())
+                continue;
+
+            mediaptr_t media = new html_media_t;;
+            media->id = sub->attrs[krefId];
+            media->time = sub->time;
+            media->style = sub->attrs[kstyle];
+            if (sub->attrs.find(kmediaSrc) != sub->attrs.end())
+                media->srcs.push_back(sub->attrs[kmediaSrc]);
+
+            nodeptrs_t::iterator iter2 = sub->nodes.begin();
+            for (; iter2 != sub->nodes.end(); iter2++) {
+                nodeptr_t sub2 = *iter2;
+                if (sub2->name == ksourceList) {
+                    if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
+                        media->srcs.push_back(sub2->attrs[kmediaSrc]);
+                }
+            }
+            medias_.push_back(media);
+        }
+    }
+    return true;
+}
+bool CiParser::GetDivJS(std::string& divjs) {
+    if (divs_.empty()) return false;
+
+    std::vector<divptr_t>::iterator iter = divs_.begin();
+    for (; iter != divs_.end(); iter++) {
+        divptr_t div = *iter;
+        if (!div->style.empty()) {
+            divjs += div->id+"=document.getElementById('"+div->id+"');";
+            divjs += div->id+".style='"+div->style+"';";
+        }
+    }
+
+    return true;
+}
+bool CiParser::GetMediaJS(long current, std::string& mediajs) {
+    if (medias_.empty()) return false;
+
+    std::vector<mediaptr_t>::iterator iter = medias_.begin();
+    for (; iter != medias_.end(); iter++) {
+        mediaptr_t media = *iter;
+        int begin = media->time.first;
+        int end = media->time.second;
+        if (begin < 0) continue;
+        if (current < begin) continue;
+
+        std::string id = media->id;
+        bool bstart = (current<end || end<0);
+        if (bstart) {
+            if (!media->srcs.empty()) {
+                mediajs += id+"=document.getElementById('"+id+"');";
+                mediajs += id+".src="+media->srcs[0]+"');";
+                mediajs += id+".play();";
+            }
+        }else {
+            mediajs += id+"=document.getElementById('"+id+"');";
+            mediajs += id+".stop();";
+        }
+    }
+    return true;
 }
 
 bool CiParser::AddNode(std::string name) {
@@ -145,14 +248,15 @@ int ParseTimeStr(std::string timestr) {
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
-
     pos = value.find(".begin");
     if (pos == std::string::npos) {
         is_begin = false;
         pos = value.find(".end");
     }
+
     if (pos == std::string::npos) {
-        return false;
+        second = ParseTimeStr(value);
+        return true;
     }
 
     second = -2;
@@ -160,10 +264,11 @@ bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     nodeptrs_t::iterator iter = node->nodes.begin();
     for (; iter != node->nodes.end(); iter++) {
         nodeptr_t sub = *iter;
-        if (sub->name == "mmtci:MediaSync") {
-            if (sub->attrs["refId"] == idstr) {
-                std::string timestr = (is_begin) ? sub->attrs["mmtci:begin"] : sub->attrs["mmtci:end"];
+        if (sub->name == kMediaSync) {
+            if (sub->attrs[krefId] == idstr) {
+                std::string timestr = (is_begin) ? sub->attrs[kbegin] : sub->attrs[kend];
                 second = ParseTimeStr(timestr);
+                break;
             }
         }
     }
@@ -175,15 +280,14 @@ bool CiParser::AddAttr(std::string name, std::string value) {
         << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
-    if (name == "mmtci:begin" || name == "mmtci:end") {
+    if (name == kbegin || name == kend) {
         int sec = -2;
-        if(!ParseTimeById(root_, value, sec))
-            sec = ParseTimeStr(value);
-        if (name == "mmtci:begin")
+        ParseTimeById(root_, value, sec);
+        if (name == kbegin)
             cur_->time.first = sec;
         else
             cur_->time.second = sec;
-        LOG(INFO) << __func__ << " sec=" << sec; 
+        LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
     }
     return true;
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index fa66194..53a93aa 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -12,7 +12,7 @@ struct node_t;
 typedef scoped_refptr<node_t> nodeptr_t;
 typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
-typedef std::pair<int, int> range_t;
+typedef std::pair<long, long> range_t;
 
 struct node_t : public base::RefCounted<node_t>{
 public:
@@ -29,13 +29,46 @@ protected:
     virtual ~node_t();
 };
 
+// for tag <div>
+struct html_div_t : public base::RefCounted<html_div_t> {
+public: 
+    explicit html_div_t();
+
+    std::string id; // tag id
+    std::string style;
+
+protected:
+    friend class base::RefCounted<html_div_t>;
+    virtual ~html_div_t();
+};
+typedef scoped_refptr<html_div_t> divptr_t;
+
+// for tags of <audio> and <video>
+struct html_media_t : public base::RefCounted<html_media_t> { 
+public:
+    explicit html_media_t();
+
+    std::string id;     // tag id
+    range_t time;       // [begin, end]
+    std::string style;
+    std::vector<std::string> srcs;    //src list
+
+protected:
+    friend class base::RefCounted<html_media_t>;
+    virtual ~html_media_t();
+};
+typedef scoped_refptr<html_media_t> mediaptr_t;
+
 
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
 
     bool ParseXml();
-    bool Merge(const CiParser& parser);
+    bool ParseHtmlTag();
+
+    bool GetDivJS(std::string& divjs);
+    bool GetMediaJS(long current, std::string& mediajs);
 
     bool AddNode(std::string name);
     bool EndNode(std::string name);
@@ -49,6 +82,9 @@ private:
     std::string fname_;
     nodeptr_t root_;
     nodeptr_t cur_; // only for AddNode and AddAttr
+
+    std::vector<divptr_t> divs_;
+    std::vector<mediaptr_t> medias_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From f73314d3ed7697e9428b1aa5af4a7497c92c98dd Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 04:43:06 -0800
Subject: [PATCH 55/92] [todo] generate js

---
 net/mmt/mmt_control.cc |   17 ++++++++++
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_parser.cc  |   81 ++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_parser.h   |    8 ++++-
 4 files changed, 82 insertions(+), 25 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 6928caa..77390e3 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -131,6 +131,21 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
+void TestXmlParser() {
+    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    CiParserPtr parser = new CiParser(xml);
+    parser->ParseXml();
+    parser->ParseHtmlTag();
+    std::string js;
+    parser->GetDivJS(js);
+    LOG(INFO) << __func__ << " div js: " << js;
+    parser->GetMediaJS(0, js);
+    LOG(INFO) << __func__ << " media js1: " << js;
+    parser->GetMediaJS(1080, js);
+    LOG(INFO) << __func__ << " media js2: " << js;
+    parser->GetMediaJS(1086, js);
+    LOG(INFO) << __func__ << " media js3: " << js;
+}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
@@ -147,12 +162,14 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
+            TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
             StreamClose(msg);
             ms = 100;
         }else if (msg.head == "@read") {
+            //TODO: if io pending, should re-push this msg again.
             StreamRead(msg);
             ms = 10;
         }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f597605..185f8f4 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -3,6 +3,7 @@
 
 #include <string>
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_parser.h"
 
 namespace net {
 class IOBuffer;
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 5a8d1e8..890f2d8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -9,7 +9,7 @@ static const char kNoValue[] = "no-value";
 
 // node
 //static const char kCI[]             = "mmtci:CI";
-//static const char kview[]           = "mmtci:view";
+static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
 static const char ksourceList[]     = "mmtci:sourceList";
@@ -85,6 +85,7 @@ html_div_t::html_div_t() {
 html_div_t::~html_div_t() {
 }
 html_media_t::html_media_t() {
+    type = html_media_t::AVImage;
 }
 html_media_t::~html_media_t() {
 }
@@ -130,14 +131,20 @@ bool CiParser::ParseHtmlTag() {
     nodeptrs_t::iterator iter = node->nodes.begin();
     for (; iter != node->nodes.end(); iter++) {
         nodeptr_t sub = *iter;
-        if (sub->name == kdivLocation) {
-            if (sub->attrs.find(krefDiv) == sub->attrs.end())
-                continue;
-
-            divptr_t div = new html_div_t;
-            div->id = sub->attrs[krefDiv];
-            div->style = sub->attrs[kstyle];
-            divs_.push_back(div);
+        if (sub->name == kview) {
+            nodeptrs_t::iterator iter2 = sub->nodes.begin();
+            for (; iter2 != sub->nodes.end(); iter2++) {
+                nodeptr_t sub2 = *iter2;
+                if (sub2->name != kdivLocation) 
+                    continue;
+                if (sub2->attrs.find(krefDiv) == sub2->attrs.end())
+                    continue;
+
+                divptr_t div = new html_div_t;
+                div->id = sub2->attrs[krefDiv];
+                div->style = sub2->attrs[kstyle];
+                divs_.push_back(div);
+            }
         }else if (sub->name == kMediaSync) {
             if (sub->attrs.find(krefId) == sub->attrs.end())
                 continue;
@@ -146,15 +153,18 @@ bool CiParser::ParseHtmlTag() {
             media->id = sub->attrs[krefId];
             media->time = sub->time;
             media->style = sub->attrs[kstyle];
-            if (sub->attrs.find(kmediaSrc) != sub->attrs.end())
+            if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
+                media->type = html_media_t::AVImage;
                 media->srcs.push_back(sub->attrs[kmediaSrc]);
-
-            nodeptrs_t::iterator iter2 = sub->nodes.begin();
-            for (; iter2 != sub->nodes.end(); iter2++) {
-                nodeptr_t sub2 = *iter2;
-                if (sub2->name == ksourceList) {
-                    if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
-                        media->srcs.push_back(sub2->attrs[kmediaSrc]);
+            }else {
+                media->type = html_media_t::AVMedia;
+                nodeptrs_t::iterator iter2 = sub->nodes.begin();
+                for (; iter2 != sub->nodes.end(); iter2++) {
+                    nodeptr_t sub2 = *iter2;
+                    if (sub2->name == ksourceList) {
+                        if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
+                            media->srcs.push_back(sub2->attrs[kmediaSrc]);
+                    }
                 }
             }
             medias_.push_back(media);
@@ -162,23 +172,35 @@ bool CiParser::ParseHtmlTag() {
     }
     return true;
 }
+inline std::string GetObject(std::string id) {
+    return "g_"+id+"=document.getElementById('"+id+"');";
+}
+inline std::string SetAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+"='"+value+"';";
+}
+inline std::string CallFunc(std::string id, std::string name) {
+    return "g_"+id+"."+name+"();";
+}
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
 
+    divjs = "";
     std::vector<divptr_t>::iterator iter = divs_.begin();
     for (; iter != divs_.end(); iter++) {
         divptr_t div = *iter;
         if (!div->style.empty()) {
-            divjs += div->id+"=document.getElementById('"+div->id+"');";
-            divjs += div->id+".style='"+div->style+"';";
+            divjs += GetObject(div->id);
+            divjs += SetAttr(div->id, "style", div->style);
         }
     }
 
     return true;
 }
+
 bool CiParser::GetMediaJS(long current, std::string& mediajs) {
     if (medias_.empty()) return false;
 
+    mediajs = "";
     std::vector<mediaptr_t>::iterator iter = medias_.begin();
     for (; iter != medias_.end(); iter++) {
         mediaptr_t media = *iter;
@@ -190,14 +212,16 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
         std::string id = media->id;
         bool bstart = (current<end || end<0);
         if (bstart) {
+            mediajs += GetObject(id);
             if (!media->srcs.empty()) {
-                mediajs += id+"=document.getElementById('"+id+"');";
-                mediajs += id+".src="+media->srcs[0]+"');";
-                mediajs += id+".play();";
+                mediajs += SetAttr(id, "src", media->srcs[0]);
             }
+            mediajs += CallFunc(id, "play");
         }else {
-            mediajs += id+"=document.getElementById('"+id+"');";
-            mediajs += id+".stop();";
+            mediajs += GetObject(id);
+            if (media->type == html_media_t::AVImage)
+                mediajs += SetAttr(id, "src", "");
+            mediajs += CallFunc(id, "stop");
         }
     }
     return true;
@@ -238,8 +262,10 @@ int ParseTimeStr(std::string timestr) {
         if (lpos != rpos) {
             sec = sec * 3600;
             sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atoi(timestr.substr(rpos+1).c_str());
         }else {
             sec = sec * 60;
+            sec = sec + atoi(timestr.substr(lpos+1).c_str());
         }
     }
     return sec;
@@ -248,6 +274,13 @@ int ParseTimeStr(std::string timestr) {
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
+
+    pos = value.find(".click");
+    if (pos != std::string::npos) {
+        // todo: proc click event
+        return true;
+    }
+
     pos = value.find(".begin");
     if (pos == std::string::npos) {
         is_begin = false;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 53a93aa..1e84919 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -43,11 +43,17 @@ protected:
 };
 typedef scoped_refptr<html_div_t> divptr_t;
 
-// for tags of <audio> and <video>
+// for tags of <image>, <audio> and <video>
 struct html_media_t : public base::RefCounted<html_media_t> { 
 public:
+    enum {
+        AVImage,
+        AVMedia,
+    };
+
     explicit html_media_t();
 
+    int type;
     std::string id;     // tag id
     range_t time;       // [begin, end]
     std::string style;
-- 
1.7.9.5


From 5aa5018c9e4b9783dc545271999182fb9cad310c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 06:25:06 -0800
Subject: [PATCH 56/92] [ok] for video mmt

---
 net/mmt/mmt_control.cc                 |    4 ++--
 net/mmt/mmt_parser.cc                  |    3 +++
 net/mmt/mmt_parser.h                   |    2 ++
 net/mmt/mmt_stream.cc                  |    2 +-
 net/mmt/mmt_stream.h                   |    1 -
 net/url_request/url_request_mmt_job.cc |   11 +++++------
 6 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 77390e3..04a7f93 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -93,7 +93,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     // TODO: for local file testing
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
-    streams_.insert(StreamPtr_t(key, stream));
+    streams_[key] = stream;
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
@@ -162,7 +162,7 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
-            TestXmlParser();
+            //TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 890f2d8..0fc0e1c 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -74,9 +74,11 @@ namespace mmt {
 
 node_t::node_t(std::string name) 
     : name(name), parent(nullptr) {
+    time.first = time.second = -1;
 }
 node_t::~node_t() {
     nodes.clear();
+    parent = nullptr;
 }
 
 // for html tag <div>, <audio>, <video>
@@ -86,6 +88,7 @@ html_div_t::~html_div_t() {
 }
 html_media_t::html_media_t() {
     type = html_media_t::AVImage;
+    time.first = time.second = -1;
 }
 html_media_t::~html_media_t() {
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 1e84919..93a70cc 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -14,6 +14,7 @@ typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
 typedef std::pair<long, long> range_t;
 
+// for xml node
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
@@ -66,6 +67,7 @@ protected:
 typedef scoped_refptr<html_media_t> mediaptr_t;
 
 
+/// for xml sax parser
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5c40616..3c8e446 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -158,7 +158,7 @@ void* Stream::Open(const char* filename, int mode) {
     return (void *)file_;
 }
 int Stream::Read(void *buf, int size) {
-    if (!Open(nullptr, 0)) return -1;
+    if (!Open(nullptr, 0)) return -2;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 6142b3a..88907de 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -95,7 +95,6 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> StreamPtr_t;
 typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
 
 } // namespace mmt
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6cdffa9..807e5fa 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -204,8 +204,11 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  LOG(INFO) << __func__ << " iret=" << iret << 
-    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
+  if (iret < 0) {
+    LOG(INFO) << __func__ << " iret=" << iret << 
+        " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
+    return;
+  }
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -222,10 +225,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
 
-  // fix error
-  if (result == -1)
-    result = OK;
-
   if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
-- 
1.7.9.5


From e78a196a331e9abd4ee179efdd905c83240a4709 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 08:49:13 -0800
Subject: [PATCH 57/92] [ok] for seq start from 1

---
 net/mmt/mmt_control.cc                 |   53 ++++++++++++++++++++++++++++----
 net/mmt/mmt_control.h                  |    9 ++++--
 net/mmt/mmt_parser.cc                  |   13 ++++----
 net/url_request/url_request_mmt_job.cc |    6 ++--
 4 files changed, 64 insertions(+), 17 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 04a7f93..d74a076 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -27,26 +27,28 @@ void PostCtrlMsg(ctrl_msg_t &msg) {
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
+    msg.url = gurl;
     msg.body = body;
     msg.tabid = tabid;
-    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
-    msg.ptr = refptr;
     msg.url = gurl;
+    msg.ptr = refptr;
+    msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
 // for @open and @read
-int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
+    msg.url = gurl;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
-    msg.url = gurl;
+    msg.tabid = tabid;
     PostCtrlMsg(msg);
     return -1; // IO_PENDING
 }
@@ -88,7 +90,7 @@ MmtControl::~MmtControl() {}
 // for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tab=" << msg.tabid;
 
     // TODO: for local file testing
     long lsize = -1;
@@ -98,6 +100,8 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
     }
+
+    tabs_[msg.tabid] = (lsize > 0) ? "loading" : "failed";
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -130,6 +134,41 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
     }
+    tabs_[msg.tabid] = "loaded";
+}
+void MmtControl::CheckEvent() {
+    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+
+    std::map<int, std::string>::iterator iter;
+    for (iter=tabs_.begin(); iter != tabs_.end(); iter++) {
+        if (iter->second != "failed") {
+            CiParserPtr parser;
+            if (parsers_.find(iter->first) == parsers_.end()) {
+                parser = new CiParser(xml);
+                parser->ParseXml();
+                parser->ParseHtmlTag();
+                parsers_[iter->first] = parser;
+            }else {
+                parser = parsers_[iter->first];
+            }
+
+            if (iter->second == "loaded") {
+                std::string divjs, mediajs;
+                parser->GetDivJS(divjs);
+                parser->GetMediaJS(0, mediajs);
+
+                std::string js;
+                js += "{";
+                js += "\"tabid\" : " + Int2String(iter->first);
+                js += ", ";
+                js += "\"js\" : \"" + divjs + mediajs + "\"";
+                js += "}";
+                LOG(INFO) << __func__ << " js => " << js;
+                SendToHost(js, "127.0.0.1", 54321);
+                iter->second = "ci-init";
+            }
+        }
+    }
 }
 void TestXmlParser() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
@@ -151,6 +190,8 @@ void MmtControl::Run() {
     running_ = true;
     int ms = 100;
     while(loop_) {
+        CheckEvent();
+
         ctrl_msg_t msg;
         if (!Pop(msg)) {
             Wait(ms);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 185f8f4..0f7a52b 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -54,10 +54,15 @@ protected:
     void StreamRead(ctrl_msg_t msg);
     void StreamClose(ctrl_msg_t msg);
 
+    // check event and process it, such as A/V sync.
+    void CheckEvent();
+
 private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
+    std::map<int, std::string> tabs_;
+    std::map<int, CiParserPtr> parsers_;
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
@@ -72,9 +77,9 @@ void StartMmtCtrl();
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
 // for @open and @read
-int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 0fc0e1c..bee93e8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -182,7 +182,8 @@ inline std::string SetAttr(std::string id, std::string name, std::string value)
     return "g_"+id+"."+name+"='"+value+"';";
 }
 inline std::string CallFunc(std::string id, std::string name) {
-    return "g_"+id+"."+name+"();";
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+"!=undefined){" + func + "();}";  
 }
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
@@ -231,7 +232,7 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
 }
 
 bool CiParser::AddNode(std::string name) {
-    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    //LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
     if (!root_)  {
         root_ = node;
@@ -247,7 +248,7 @@ bool CiParser::AddNode(std::string name) {
 }
 
 bool CiParser::EndNode(std::string name) {
-    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
+    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
     if (!cur_) return false;
     if (name != cur_->name) {
         LOG(INFO) << __func__ << " name=" << name;
@@ -312,8 +313,8 @@ bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
 }
 
 bool CiParser::AddAttr(std::string name, std::string value) {
-    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
-        << " attr: " << name << " => " << value;
+    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+    //    << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
     if (name == kbegin || name == kend) {
@@ -323,7 +324,7 @@ bool CiParser::AddAttr(std::string name, std::string value) {
             cur_->time.first = sec;
         else
             cur_->time.second = sec;
-        LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
+        //LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
     }
     return true;
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 807e5fa..4e10c38 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -56,11 +56,11 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   mmt::stream_info_t sinfo;
   sinfo.func = &URLRequestMmtJob::DoStart;
-  mmt::PostCtrlTask("@open", request_->url(), sinfo, this);
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, this, content_.tab_id);
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::PostCtrlTask("@close", request_->url(), this);
+  mmt::PostCtrlTask("@close", request_->url(), this, content_.tab_id);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -90,7 +90,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.func = &URLRequestMmtJob::DoRead;
 
   // return ERR_IO_PENDING if aysnc read
-  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
+  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this, content_.tab_id);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
-- 
1.7.9.5


From ceacfcda24e0b584b7732891f4392e60a3dd54a1 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 23:19:22 -0800
Subject: [PATCH 58/92] fix non-json exception

---
 .../api/cictrl/res/native-messaging-cictrl         |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
index 05279a2..787b81e 100755
--- a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -13,6 +13,7 @@ import Queue
 
 import time
 import socket
+import signal
 from json import JSONDecoder
 
 gDaemon = True
@@ -26,7 +27,10 @@ except ImportError:
 def send_message(message):
   # message must be JSON string
   if len(message) < 16: return
-  jdata = JSONDecoder().decode(message)
+  try:
+    jdata = JSONDecoder().decode(message)
+  except:
+    jdata = None
   if not jdata: return
 
   # Write message size.
@@ -144,8 +148,14 @@ def Main():
   main_window.mainloop()
   sys.exit(0)
 
+def OnSignal(a, b):
+    sys.exit(0)
+    pass
 
 if __name__ == '__main__':
+  signal.signal(signal.SIGTERM, OnSignal)
+  signal.signal(signal.SIGINT, OnSignal)
+
   if gDaemon:   Daemon()
   else:         Main()
 
-- 
1.7.9.5


From 8259d50d0746ee613979875ea9dbe34ca83133ea Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 01:13:58 -0800
Subject: [PATCH 59/92] Add ci xml proc

---
 net/mmt/mmt_control.cc |   84 +++++++++++++++++++++++++++++++-----------------
 net/mmt/mmt_control.h  |   16 +++++++--
 2 files changed, 68 insertions(+), 32 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index d74a076..4f5b8af 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -73,6 +73,13 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
+cixml_t::cixml_t() {
+    status = "initing";
+}
+cixml_t::~cixml_t() {
+    parser = nullptr;
+}
+
 static std::string mmtjob_key(GURL url, void* ptr) {
     std::string name = url.spec();
     std::stringstream sstr;
@@ -90,7 +97,7 @@ MmtControl::~MmtControl() {}
 // for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tab=" << msg.tabid;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
 
     // TODO: for local file testing
     long lsize = -1;
@@ -100,8 +107,6 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
     }
-
-    tabs_[msg.tabid] = (lsize > 0) ? "loading" : "failed";
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -124,49 +129,69 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
             msg.sinfo.func(msg.ptr, msg.sinfo, iret);
         }
     }
+
+    if (msg.tabid > 0) {
+        if (cixmls_.find(msg.tabid) == cixmls_.end()) {
+            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
+            cixmls_[msg.tabid] = new cixml_t;;
+        }
+    }
 }
 void MmtControl::StreamClose(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
 
     StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
     }
-    tabs_[msg.tabid] = "loaded";
 }
 void MmtControl::CheckEvent() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
 
-    std::map<int, std::string>::iterator iter;
-    for (iter=tabs_.begin(); iter != tabs_.end(); iter++) {
-        if (iter->second != "failed") {
-            CiParserPtr parser;
-            if (parsers_.find(iter->first) == parsers_.end()) {
-                parser = new CiParser(xml);
+    std::map<int, cixmlptr_t>::iterator iter;
+    for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
+        cixmlptr_t cixml = iter->second;
+        if (!cixml) {
+            iter->second = new cixml_t;
+            continue;
+        }
+
+        CiParserPtr parser = cixml->parser;
+        if (cixml->status == "end") continue;
+
+        LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        if (cixml->status == "initing") {
+            if (!cixml->parser) {
+                cixml->parser = new CiParser(xml);
+            }
+            cixml->status = "loading";
+        }else if (cixml->status == "loading") {
+            if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
-                parsers_[iter->first] = parser;
-            }else {
-                parser = parsers_[iter->first];
             }
-
-            if (iter->second == "loaded") {
-                std::string divjs, mediajs;
-                parser->GetDivJS(divjs);
-                parser->GetMediaJS(0, mediajs);
-
-                std::string js;
-                js += "{";
-                js += "\"tabid\" : " + Int2String(iter->first);
-                js += ", ";
-                js += "\"js\" : \"" + divjs + mediajs + "\"";
-                js += "}";
-                LOG(INFO) << __func__ << " js => " << js;
-                SendToHost(js, "127.0.0.1", 54321);
-                iter->second = "ci-init";
+            cixml->status = "loaded";
+        }else if (cixml->status == "loaded") {
+            if (!parser) {
+                cixml->status = "end";
+                continue;
             }
+
+            std::string divjs, mediajs;
+            parser->GetDivJS(divjs);
+            parser->GetMediaJS(0, mediajs);
+
+            std::string js;
+            js += "{";
+            js += "\"tabid\" : " + Int2String(iter->first);
+            js += ", ";
+            js += "\"js\" : \"" + divjs + mediajs + "\"";
+            js += "}";
+            LOG(INFO) << __func__ << " js => " << js;
+            SendToHost(js, "127.0.0.1", 54321);
+            cixml->status = "end";
         }
     }
 }
@@ -203,7 +228,6 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
-            //TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 0f7a52b..3c096db 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -37,6 +37,19 @@ struct ctrl_msg_t {
     stream_info_t sinfo;
 };
 
+struct cixml_t : public base::RefCounted<cixml_t> {
+public:
+    cixml_t();
+    std::string status;
+    CiParserPtr parser;
+
+protected:
+    friend class base::RefCounted<cixml_t>;
+    virtual ~cixml_t();
+};
+typedef scoped_refptr<cixml_t> cixmlptr_t;
+
+
 class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
@@ -61,8 +74,7 @@ private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
-    std::map<int, std::string> tabs_;
-    std::map<int, CiParserPtr> parsers_;
+    std::map<int, cixmlptr_t> cixmls_; // tab id => ci xml
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
-- 
1.7.9.5


From 8524981bc2abe58903b9fd010f70093f1e044790 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 03:09:58 -0800
Subject: [PATCH 60/92] Add docs to mmt

---
 net/mmt/mmt_control.cc |   64 ++++++++++++++++++++----------------
 net/mmt/mmt_control.h  |   46 ++++++++++++++++++++------
 net/mmt/mmt_parser.cc  |   84 +++++++++++++++++++++++++++---------------------
 net/mmt/mmt_parser.h   |   29 +++++++++++------
 net/mmt/mmt_stream.cc  |   10 +++++-
 net/mmt/mmt_stream.h   |   21 ++++++++----
 6 files changed, 162 insertions(+), 92 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 4f5b8af..5dfc760 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -50,7 +50,7 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
     msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
-    return -1; // IO_PENDING
+    return -1; //> default IO_PENDING(-1) and Async Read
 }
 
 } // namespace mmt
@@ -80,6 +80,9 @@ cixml_t::~cixml_t() {
     parser = nullptr;
 }
 
+/**
+ * The algorithm to generate unique key for UrlRequestJob
+ */
 static std::string mmtjob_key(GURL url, void* ptr) {
     std::string name = url.spec();
     std::stringstream sstr;
@@ -94,7 +97,6 @@ MmtControl::MmtControl() : SimpleThread("mmt_control"){
 }
 MmtControl::~MmtControl() {}
 
-// for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
@@ -133,7 +135,8 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (msg.tabid > 0) {
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
-            cixmls_[msg.tabid] = new cixml_t;;
+            cixmlptr_t cixml = new cixml_t;
+            cixmls_[msg.tabid] = cixml;;
         }
     }
 }
@@ -148,53 +151,54 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
     }
 }
 void MmtControl::CheckEvent() {
+    // TODO for testing
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
 
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
         cixmlptr_t cixml = iter->second;
-        if (!cixml) {
-            iter->second = new cixml_t;
-            continue;
-        }
-
-        CiParserPtr parser = cixml->parser;
+        if (!cixml) continue;
         if (cixml->status == "end") continue;
 
         LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        std::string next_status = cixml->status;
+        CiParserPtr parser = cixml->parser;
+
         if (cixml->status == "initing") {
             if (!cixml->parser) {
                 cixml->parser = new CiParser(xml);
             }
-            cixml->status = "loading";
+            next_status = "loading";
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
             }
-            cixml->status = "loaded";
+            next_status = "loaded";
         }else if (cixml->status == "loaded") {
-            if (!parser) {
-                cixml->status = "end";
-                continue;
-            }
+            if (parser) {
+                std::string divjs, mediajs;
+                parser->GetDivJS(divjs);
+                parser->GetMediaJS(0, mediajs);
 
-            std::string divjs, mediajs;
-            parser->GetDivJS(divjs);
-            parser->GetMediaJS(0, mediajs);
-
-            std::string js;
-            js += "{";
-            js += "\"tabid\" : " + Int2String(iter->first);
-            js += ", ";
-            js += "\"js\" : \"" + divjs + mediajs + "\"";
-            js += "}";
-            LOG(INFO) << __func__ << " js => " << js;
-            SendToHost(js, "127.0.0.1", 54321);
-            cixml->status = "end";
+                std::string js;
+                js += "{";
+                js += "\"tabid\" : " + Int2String(iter->first);
+                js += ", ";
+                js += "\"js\" : \"" + divjs + mediajs + "\"";
+                js += "}";
+                LOG(INFO) << __func__ << " js => " << js;
+                SendToHost(js, "127.0.0.1", 54321);
+            }
+            next_status = "end";
         }
+        cixml->status = next_status;
     }
 }
+
+/**
+ * UnitTest for class CiParser
+ */
 void TestXmlParser() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
     CiParserPtr parser = new CiParser(xml);
@@ -210,6 +214,10 @@ void TestXmlParser() {
     parser->GetMediaJS(1086, js);
     LOG(INFO) << __func__ << " media js3: " << js;
 }
+
+/**
+ * Thread Main Loop
+ */
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 3c096db..6b9d6ae 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -1,6 +1,12 @@
 #ifndef NET_MMT_MMT_CONTROL_H_
 #define NET_MMT_MMT_CONTROL_H_
 
+/**
+ * Control center, 
+ *  which process mmt protocl, CI, Stream IO(mmtp) and A/V sync.
+ *  It will be activated by mmt:// protocol and only start one seperate thread.
+ */
+
 #include <string>
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_parser.h"
@@ -15,8 +21,16 @@ namespace mmt {
 struct stream_info_t;
 typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
 
-// (ptr, stream_info_t, errno)
+
+/**
+ * Stream IO callback function,
+ *  three parameters: (job object, stream_info_t, errno)
+ */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+
+/**
+ * Stream IO Information
+ */
 struct stream_info_t {
     net::IOBuffer*  buf;
     int             size;
@@ -24,19 +38,25 @@ struct stream_info_t {
     stream_func_t   func;
 };
 
+/**
+ * The message for Control Center.
+ */
 struct ctrl_msg_t {
     ctrl_msg_t();
     ~ctrl_msg_t();
 
-    std::string head;
+    std::string head;   //> msg tag: @open, @read, @close, @ctrl and etc.
     std::string body;
-    GURL url;
-    int tabid;
-    job_refptr_t ptr;
+    GURL url;           //> access url
+    int tabid;          //> chrome's tab id
+    job_refptr_t ptr;   //> job object
 
-    stream_info_t sinfo;
+    stream_info_t sinfo;    //> valid for @open, @read and @close
 };
 
+/**
+ * Structure for CI XML to process ci. 
+ */
 struct cixml_t : public base::RefCounted<cixml_t> {
 public:
     cixml_t();
@@ -50,6 +70,9 @@ protected:
 typedef scoped_refptr<cixml_t> cixmlptr_t;
 
 
+/**
+ * class for Control Center
+ */
 class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
@@ -62,19 +85,20 @@ public:
     void Push(ctrl_msg_t& msg);
 
 protected:
-    // operations for I/O stream
+    // Operations for I/O Stream
     void StreamOpen(ctrl_msg_t msg);
     void StreamRead(ctrl_msg_t msg);
     void StreamClose(ctrl_msg_t msg);
 
-    // check event and process it, such as A/V sync.
+    // Check CI events.
     void CheckEvent();
 
 private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
-    std::map<int, cixmlptr_t> cixmls_; // tab id => ci xml
+    std::map<int, cixmlptr_t> cixmls_; //> (tabid => cixml_t)
+
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
@@ -84,6 +108,7 @@ private:
 
 namespace mmt {
 
+// Start control center
 void StartMmtCtrl();
 
 // for @ctrl
@@ -92,6 +117,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
 // for @open and @read
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
+
 } // namespace mmt
 
-#endif
+#endif // NET_MMT_MMT_CONTROL_H_
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index bee93e8..45a7f72 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -7,14 +7,18 @@ namespace mmt {
 
 static const char kNoValue[] = "no-value";
 
-// node
+/**
+ * String constants for ci xml node
+ */
 //static const char kCI[]             = "mmtci:CI";
 static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
 static const char ksourceList[]     = "mmtci:sourceList";
 
-// attr
+/**
+ * String constants for ci xml attr
+ */
 static const char krefId[]      = "refId";
 static const char krefDiv[]     = "mmtci:refDiv";
 static const char kmediaSrc[]   = "mmtci:mediaSrc";
@@ -23,6 +27,9 @@ static const char kend[]        = "mmtci:end";
 static const char kstyle[]      = "style";
 
 
+/**
+ * callback functions for libxml2's sax parser
+ */
 static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
     CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
     if (ptr) ptr->AddNode((const char*)name);
@@ -67,6 +74,42 @@ static void init_sax(xmlSAXHandlerPtr sax) {
     sax->fatalError = sax_error;
 }
 
+/**
+ * Utils for generating javascript 
+ */
+inline std::string GetObject(std::string id) {
+    return "g_"+id+"=document.getElementById('"+id+"');";
+}
+inline std::string SetAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+"='"+value+"';";
+}
+inline std::string CallFunc(std::string id, std::string name) {
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+"!=undefined){" + func + "();}";  
+}
+
+/**
+ * To parse CI's time
+ */
+int ParseTimeStr(std::string timestr) {
+    int sec = atoi(timestr.c_str());
+    std::string::size_type lpos, rpos;
+    lpos = timestr.find(":");
+    rpos = timestr.rfind(":");
+    if (lpos != std::string::npos) {
+        if (lpos != rpos) {
+            sec = sec * 3600;
+            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atoi(timestr.substr(rpos+1).c_str());
+        }else {
+            sec = sec * 60;
+            sec = sec + atoi(timestr.substr(lpos+1).c_str());
+        }
+    }
+    return sec;
+}
+
+
 } // namespace mmt
 
 
@@ -81,13 +124,12 @@ node_t::~node_t() {
     parent = nullptr;
 }
 
-// for html tag <div>, <audio>, <video>
 html_div_t::html_div_t() {
 }
 html_div_t::~html_div_t() {
 }
+
 html_media_t::html_media_t() {
-    type = html_media_t::AVImage;
     time.first = time.second = -1;
 }
 html_media_t::~html_media_t() {
@@ -157,10 +199,8 @@ bool CiParser::ParseHtmlTag() {
             media->time = sub->time;
             media->style = sub->attrs[kstyle];
             if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
-                media->type = html_media_t::AVImage;
                 media->srcs.push_back(sub->attrs[kmediaSrc]);
             }else {
-                media->type = html_media_t::AVMedia;
                 nodeptrs_t::iterator iter2 = sub->nodes.begin();
                 for (; iter2 != sub->nodes.end(); iter2++) {
                     nodeptr_t sub2 = *iter2;
@@ -175,16 +215,7 @@ bool CiParser::ParseHtmlTag() {
     }
     return true;
 }
-inline std::string GetObject(std::string id) {
-    return "g_"+id+"=document.getElementById('"+id+"');";
-}
-inline std::string SetAttr(std::string id, std::string name, std::string value) {
-    return "g_"+id+"."+name+"='"+value+"';";
-}
-inline std::string CallFunc(std::string id, std::string name) {
-    std::string func = "g_"+id+"."+name;
-    return "if("+func+"!=undefined){" + func + "();}";  
-}
+
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
 
@@ -223,8 +254,7 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
             mediajs += CallFunc(id, "play");
         }else {
             mediajs += GetObject(id);
-            if (media->type == html_media_t::AVImage)
-                mediajs += SetAttr(id, "src", "");
+            mediajs += SetAttr(id, "src", "");
             mediajs += CallFunc(id, "stop");
         }
     }
@@ -257,24 +287,6 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
-int ParseTimeStr(std::string timestr) {
-    int sec = atoi(timestr.c_str());
-    std::string::size_type lpos, rpos;
-    lpos = timestr.find(":");
-    rpos = timestr.rfind(":");
-    if (lpos != std::string::npos) {
-        if (lpos != rpos) {
-            sec = sec * 3600;
-            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
-            sec = sec + atoi(timestr.substr(rpos+1).c_str());
-        }else {
-            sec = sec * 60;
-            sec = sec + atoi(timestr.substr(lpos+1).c_str());
-        }
-    }
-    return sec;
-}
-
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 93a70cc..7b84035 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -1,6 +1,10 @@
 #ifndef NET_MMT_MMT_PARSER_H_
 #define NET_MMT_MMT_PARSER_H_
 
+/**
+ * XML Parser for CI files which is based on libxml2.
+ */
+
 #include <map>
 #include <string>
 #include <vector>
@@ -14,7 +18,10 @@ typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
 typedef std::pair<long, long> range_t;
 
-// for xml node
+
+/**
+ * Structure for xml node
+ */
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
@@ -30,7 +37,10 @@ protected:
     virtual ~node_t();
 };
 
-// for tag <div>
+
+/** 
+ * Structure for html tag <div>
+ */
 struct html_div_t : public base::RefCounted<html_div_t> {
 public: 
     explicit html_div_t();
@@ -44,17 +54,14 @@ protected:
 };
 typedef scoped_refptr<html_div_t> divptr_t;
 
-// for tags of <image>, <audio> and <video>
+
+/** 
+ * Sturcture for tags of html <img>, <audio> and <video>
+ */
 struct html_media_t : public base::RefCounted<html_media_t> { 
 public:
-    enum {
-        AVImage,
-        AVMedia,
-    };
-
     explicit html_media_t();
 
-    int type;
     std::string id;     // tag id
     range_t time;       // [begin, end]
     std::string style;
@@ -67,7 +74,9 @@ protected:
 typedef scoped_refptr<html_media_t> mediaptr_t;
 
 
-/// for xml sax parser
+/** 
+ * class for parsing xml  
+ */
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 3c8e446..06600da 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -17,9 +17,11 @@ content_t::~content_t() {
 } // namespace mmt
 
 
-/// for class Stream
 namespace mmt {
 
+/**
+ * For mpu's stream io
+ */
 static void* mmtp_open(stream_t *s, const char* filename, int mode) {
     return ((Stream*)s->opaque)->Open(filename, mode);
 }
@@ -54,6 +56,12 @@ static stream_t* InitMpuStream(Stream* ptr) {
     return s;
 }
 
+} // namespace mmt
+
+
+
+namespace mmt {
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 88907de..cb78227 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -24,15 +24,18 @@ class IOBuffer;
 
 namespace mmt {
 
+/**
+ * Collect the information of URLRequestJob
+ */
 struct content_t {
     content_t();
     ~content_t();
 
-    int process_id;
-    int frame_id;
-    int routing_id;
-    int tab_id;
-    std::string tab_url;
+    int process_id; //> render process id
+    int frame_id;   //> render frame id
+    int routing_id; //> render host routing id 
+    int tab_id;     //> chrome's tab id
+    std::string tab_url;    //> chrome's tab url
 };
 
 } // namespace mmt
@@ -66,6 +69,9 @@ public:
    virtual ~IStream() {}
 };
 
+/**
+ * Stream IO for both local file and mmtp receiver
+ */
 class Stream : public IStream, public base::RefCounted<Stream> {
 public:
     virtual void*    Open(const char* fname, int mode) override;
@@ -81,14 +87,15 @@ public:
     bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
+
 protected:
     friend class base::RefCounted<Stream>;
     virtual ~Stream();
 
 private:
     GURL url_;
-    triple_t midx_;
-    std::map<int, offset_t> offmap_;
+    triple_t midx_; //> media index
+    std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
-- 
1.7.9.5


From cba363bcfdfba83f6da7facde395ddafdf941134 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 03:10:48 -0800
Subject: [PATCH 61/92] remove cimsg extension

---
 .../docs/examples/api/cimsg/background.js          |   86 -----------
 .../docs/examples/api/cimsg/install_host.sh        |   40 -----
 .../docs/examples/api/cimsg/manifest.json          |   24 ---
 .../docs/examples/api/cimsg/native-messaging-cimsg |  154 --------------------
 .../examples/api/cimsg/org.chromium.cimsg.json     |   13 --
 5 files changed, 317 deletions(-)
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/background.js
 delete mode 100755 chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/manifest.json
 delete mode 100755 chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
deleted file mode 100644
index daf7dd5..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/background.js
+++ /dev/null
@@ -1,86 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-var port = null;
-var tabid = -1;
-
-var getKeys = function(obj){
-  var keys = [];
-  for(var key in obj){
-    keys.push(key);
-  }
-  return keys;
-}
-
-function parseJSON(data) {
-  return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function("return " + data))(); 
-}
-
-function logMsg(msg) {
-  //alert(msg);
-  console.log(msg);
-}
-
-function sendNativeMessage(message) {
-  if (port == null) return;
-  if(typeof(message) != "object") {
-    logMsg(typeof(message) + " is not a json object");
-    return;
-  }
-  port.postMessage(message);
-}
-
-function onNativeMessage(message) {
-  if(typeof(message) != "object") {
-    logMsg(typeof(message) + " is not a json object");
-    return;
-  }
-
-  js = message["js"];
-  if (js != undefined) {
-    chrome.tabs.executeScript({
-        code: js
-    });
-  }
-
-  css = message["css"];
-  if (css != undefined) {
-    chrome.tabs.insertCSS({
-        code: css
-    });
-  }
-}
-
-function onDisconnected() {
-  port = null;
-}
-
-function connect() {
-  var hostName = "org.chromium.cimsg";
-  port = chrome.runtime.connectNative(hostName);
-  if (port != null) {
-    port.onMessage.addListener(onNativeMessage);
-    port.onDisconnect.addListener(onDisconnected);
-  }
-}
-
-
-/// events
-chrome.tabs.onCreated.addListener(function(tab) {
-});
-chrome.tabs.onActivated.addListener(function(info) {
-  //chrome.tabs.executeScript({file: "ci.js"});
-});
-chrome.browserAction.onClicked.addListener(function(tab) {
-  chrome.tabs.executeScript({
-    code: 'document.body.style.backgroundColor="red"'
-  });
-});
-chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
-  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
-    tabid = tab.id;
-    connect();
-  }
-});
-
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
deleted file mode 100755
index da7105e..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/bin/sh
-# Copyright 2013 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-set -e
-
-DIR="$( cd "$( dirname "$0" )" && pwd )"
-if [ $(uname -s) == 'Darwin' ]; then
-  if [ "$(whoami)" == "root" ]; then
-    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
-  else
-    TARGET_DIR=\
-        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
-  fi
-else
-  if [ "$(whoami)" == "root" ]; then
-    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
-  else
-    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
-  fi
-fi
-
-HOST_NAME=org.chromium.cimsg
-
-# Create directory to store native messaging host.
-mkdir -p $TARGET_DIR
-
-# Copy native messaging host manifest.
-cp $DIR/$HOST_NAME.json $TARGET_DIR
-
-# Update host path in the manifest.
-HOST_PATH=$DIR/native-messaging-cimsg
-ESCAPED_HOST_PATH=${HOST_PATH////\\/}
-sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
-
-# Set permissions for the manifest so that all users can read it.
-chmod o+r $TARGET_DIR/$HOST_NAME.json
-
-echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
deleted file mode 100644
index fea9000..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
+++ /dev/null
@@ -1,24 +0,0 @@
-{
-    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
-    "name": "org.chromium.cimsg",
-    "version": "1.0",
-    "manifest_version": 2,
-    "description": "chromium native messaging for ci",
-    "permissions": [
-        "tabs",
-        "nativeMessaging",
-        "activeTab",
-        "notifications",
-        "http://*/",
-        "https://*/",
-        "file://*/",
-        "mmt://*/"
-    ],
-   "browser_action": {
-        "default_title": "Make this page red"
-    },
-    "background": {
-        "scripts": ["background.js"],
-        "persistent": false
-    }
-}
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
deleted file mode 100755
index 2b31c6b..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ /dev/null
@@ -1,154 +0,0 @@
-#!/usr/bin/env python
-# Copyright (c) 2012 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# A simple native messaging host. Shows a Tkinter dialog with incoming messages
-# that also allows to send message back to the webapp.
-
-import struct
-import sys
-import threading
-import Queue
-
-import time
-import socket
-from json import JSONDecoder
-
-gDaemon = True
-try:
-  import Tkinter
-  import tkMessageBox
-except ImportError:
-  Tkinter = None
-
-# Helper function that sends a message to the webapp.
-def send_message(message):
-  # message must be JSON string
-  if len(message) < 16: return
-  try:
-    jdata = JSONDecoder().decode(message)
-  except:
-    jdata = None
-  if not jdata: return
-
-  # Write message size.
-  sys.stdout.write(struct.pack('I', len(message)))
-  # Write the message itself.
-  sys.stdout.write(message)
-  try:
-    sys.stdout.flush()
-  except: return
-
-# Thread that reads messages from control point
-def read_ctrl_func():
-  host = "localhost"
-  port = 54321
-  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
-  sock.sendto("@quit", (host,port))
-  sock.close()
-  time.sleep(3)
-  
-  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
-  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-  sock.bind((host, port))
-  while True:
-    msg, addr = sock.recvfrom(65536)
-    if msg[:5] == "@quit":
-      break
-    send_message(msg)
-  sock.close()
-
-# Thread that reads messages from the webapp.
-def read_thread_func(queue):
-  while True:
-    # Read the message length (first 4 bytes).
-    text_length_bytes = sys.stdin.read(4)
-    if len(text_length_bytes) == 0:
-      if queue: queue.put(None)
-      sys.exit(0)
-
-    # Unpack message length as 4 byte integer.
-    text_length = struct.unpack('i', text_length_bytes)[0]
-    # Read the text (JSON object) of the message.
-    text = sys.stdin.read(text_length).decode('utf-8')
-    if queue: queue.put(text)
-
-if Tkinter:
-  class NativeMessagingWindow(Tkinter.Frame):
-    def __init__(self, queue):
-      self.queue = queue
-
-      Tkinter.Frame.__init__(self)
-      self.pack()
-
-      self.text = Tkinter.Text(self)
-      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
-      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
-
-      self.messageContent = Tkinter.StringVar()
-      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
-      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
-
-      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
-      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
-
-      self.after(100, self.processMessages)
-
-    def processMessages(self):
-      while not self.queue.empty():
-        message = self.queue.get_nowait()
-        if message == None:
-          self.quit()
-          return
-        self.log("Received %s" % message)
-
-      self.after(100, self.processMessages)
-
-    def onSend(self):
-      #text = '{"text": "' + self.messageContent.get() + '"}'
-      text = self.messageContent.get()
-      self.log('Sending %s' % text)
-      try:
-        send_message(text)
-      except IOError:
-        tkMessageBox.showinfo('Native Messaging Example',
-                              'Failed to send message.')
-        sys.exit(1)
-
-    def log(self, message):
-      self.text.config(state=Tkinter.NORMAL)
-      self.text.insert(Tkinter.END, message + "\n")
-      self.text.config(state=Tkinter.DISABLED)
-
-def Daemon():
-  queue = Queue.Queue()
-  rthread = threading.Thread(target=read_thread_func, args=(queue,))
-  rthread.daemon = True
-  rthread.start()
-  read_ctrl_func()
-  sys.exit(0)
-
-def Main():
-  if not Tkinter:
-    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
-                 'mode. Please consider installing Tkinter."')
-    read_thread_func(None)
-    sys.exit(0)
-
-  queue = Queue.Queue()
-  main_window = NativeMessagingWindow(queue)
-  main_window.master.title('Native Messaging Example')
-
-  thread = threading.Thread(target=read_thread_func, args=(queue,))
-  thread.daemon = True
-  thread.start()
-
-  main_window.mainloop()
-  sys.exit(0)
-
-
-if __name__ == '__main__':
-  if gDaemon:   Daemon()
-  else:         Main()
-
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
deleted file mode 100644
index 2118005..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-{
-  "name": "org.chromium.cimsg",
-  "description": "Chromium Native Messaging For CI",
-  "path": "HOST_PATH",
-  "type": "stdio",
-  "allowed_origins": [
-    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
-  ]
-}
-- 
1.7.9.5


From cccf21a9c58182e21d2c40fce95afe71b4a094eb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:06:35 -0800
Subject: [PATCH 62/92] refine cictrl

---
 .../docs/examples/api/cictrl/content_scripts.js    |    1 +
 .../docs/examples/api/cictrl/manifest.json         |    2 +-
 .../api/cictrl/res/native-messaging-cictrl         |    2 +-
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
index 745d2ff..d22f883 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -1,4 +1,5 @@
 function log(msg) {
+    msg = "[CI] " + msg;
     //alert(msg);
     console.log(msg);
 }
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
index e86769b..15a90c6 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -21,7 +21,7 @@
     "content_scripts": [
         {
             "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
-            "run_at" : "document_end",
+            "run_at" : "document_start",
             "js" : ["content_scripts.js"]
         }
     ]
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
index 787b81e..94d6a43 100755
--- a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -48,7 +48,7 @@ def read_ctrl_func():
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.sendto("@quit", (host,port))
   sock.close()
-  time.sleep(3)
+  time.sleep(1)
   
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-- 
1.7.9.5


From febe5ce5538842172bbfa4125690f9657abedcc6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:07:11 -0800
Subject: [PATCH 63/92] refine ci control

---
 net/mmt/mmt_control.cc |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 5dfc760..1f6ca2f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -169,12 +169,14 @@ void MmtControl::CheckEvent() {
                 cixml->parser = new CiParser(xml);
             }
             next_status = "loading";
+            Wait(100);
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
             }
             next_status = "loaded";
+            Wait(100);
         }else if (cixml->status == "loaded") {
             if (parser) {
                 std::string divjs, mediajs;
@@ -187,6 +189,7 @@ void MmtControl::CheckEvent() {
                 js += ", ";
                 js += "\"js\" : \"" + divjs + mediajs + "\"";
                 js += "}";
+                Wait(1000);
                 LOG(INFO) << __func__ << " js => " << js;
                 SendToHost(js, "127.0.0.1", 54321);
             }
-- 
1.7.9.5


From ed538ff1fff318d5900af2bb233b0fe5ac3cd68f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:11:38 -0800
Subject: [PATCH 64/92] add docs for util

---
 net/mmt/mmt_inc.h    |   27 +++++++++++++++++++++++++++
 net/mmt/mmt_utils.cc |    5 +++++
 2 files changed, 32 insertions(+)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 485621b..bdac625 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -37,12 +37,39 @@
 
 namespace mmt{
 
+/**
+ * Wait millseconds
+ */
 void Wait(int ms);
+
+/**
+ * Convert int to string with fill 0 of width.
+ */
 std::string Int2String(int value, int width=0);
+
+/**
+ * Convert string to int
+ */
 int String2Int(std::string value);
+
+/**
+ * Convert GURL to file path
+ */
 std::string GURL2FilePath(GURL gurl);
+
+/**
+ * Parse models with ?k1=v1&k2=v2
+ */
 std::string GetQueryValue(std::string query, std::string key);
+
+/**
+ * Parse models with n1-n2, n1-.
+ */
 bool GetRangeValue(std::string range, int &lval, int &rval);
+
+/**
+ * Send to some host with msg over UDP
+ */
 int SendToHost(std::string msg, std::string szaddr, int port);
 
 }
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 76b9776..2aba4aa 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -5,6 +5,7 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
+
 std::string Int2String(int value, int width) {
     std::string szval;
     std::stringstream sstr;
@@ -15,6 +16,7 @@ std::string Int2String(int value, int width) {
     sstr >> szval;
     return szval;
 }
+
 int String2Int(std::string value) {
     int ival = -1;
     std::stringstream sstr;
@@ -22,6 +24,7 @@ int String2Int(std::string value) {
     sstr >> ival;
     return ival;
 }
+
 std::string GURL2FilePath(GURL gurl) {
     std::string szpath;
     base::FilePath file_path;
@@ -31,6 +34,7 @@ std::string GURL2FilePath(GURL gurl) {
     }
     return szpath;
 }
+
 std::string GetQueryValue(std::string query, std::string key) {
     std::string value;
     std::string::size_type begin, end;
@@ -46,6 +50,7 @@ std::string GetQueryValue(std::string query, std::string key) {
     }
     return value;
 }
+
 bool GetRangeValue(std::string range, int &lval, int &rval) {
     bool bok = false;
     std::string lstr = "0";
-- 
1.7.9.5


From d7e5e7579da635202fef2264d46ce175f6c463a6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 3 Feb 2015 22:03:15 -0800
Subject: [PATCH 65/92] [todo] to process ci begin/end/click

---
 net/mmt/mmt_control.cc |   41 +++--
 net/mmt/mmt_parser.cc  |  395 ++++++++++++++++++++++++++++++++----------------
 net/mmt/mmt_parser.h   |   82 +++++-----
 net/mmt/mmt_stream.cc  |   10 +-
 4 files changed, 334 insertions(+), 194 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 1f6ca2f..19785ef 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -150,6 +150,13 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
+void GetJsonData(int tabid, std::string js, std::string& json) {
+    json += "{";
+    json += "\"tabid\" : " + Int2String(tabid);
+    json += ", ";
+    json += "\"js\" : \"" + js + "\"";
+    json += "}";
+}
 void MmtControl::CheckEvent() {
     // TODO for testing
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
@@ -176,22 +183,16 @@ void MmtControl::CheckEvent() {
                 parser->ParseHtmlTag();
             }
             next_status = "loaded";
-            Wait(100);
+            Wait(1000);
         }else if (cixml->status == "loaded") {
             if (parser) {
-                std::string divjs, mediajs;
-                parser->GetDivJS(divjs);
-                parser->GetMediaJS(0, mediajs);
-
                 std::string js;
-                js += "{";
-                js += "\"tabid\" : " + Int2String(iter->first);
-                js += ", ";
-                js += "\"js\" : \"" + divjs + mediajs + "\"";
-                js += "}";
-                Wait(1000);
-                LOG(INFO) << __func__ << " js => " << js;
-                SendToHost(js, "127.0.0.1", 54321);
+                if(parser->GetHtmlJS(0, js) && !js.empty()) {
+                    std::string json;
+                    GetJsonData(iter->first, js, json);
+                    LOG(INFO) << __func__ << " json => " << json;
+                    SendToHost(json, "127.0.0.1", 54321);
+                }
             }
             next_status = "end";
         }
@@ -208,14 +209,12 @@ void TestXmlParser() {
     parser->ParseXml();
     parser->ParseHtmlTag();
     std::string js;
-    parser->GetDivJS(js);
-    LOG(INFO) << __func__ << " div js: " << js;
-    parser->GetMediaJS(0, js);
-    LOG(INFO) << __func__ << " media js1: " << js;
-    parser->GetMediaJS(1080, js);
-    LOG(INFO) << __func__ << " media js2: " << js;
-    parser->GetMediaJS(1086, js);
-    LOG(INFO) << __func__ << " media js3: " << js;
+    parser->GetHtmlJS(0, js);
+    LOG(INFO) << __func__ << " js1: " << js;
+    parser->GetHtmlJS(1080, js);
+    LOG(INFO) << __func__ << " js2: " << js;
+    parser->GetHtmlJS(1086, js);
+    LOG(INFO) << __func__ << " js3: " << js;
 }
 
 /**
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 45a7f72..3e5d17a 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -26,6 +26,14 @@ static const char kbegin[]      = "mmtci:begin";
 static const char kend[]        = "mmtci:end";
 static const char kstyle[]      = "style";
 
+/**
+ * Event constatnts for the value of kbegin and kend
+ */
+static const char kevinf[]      = "indefinite";
+static const char kevbegin[]    = ".begin";
+static const char kevend[]      = ".end";
+static const char kevclick[]    = ".click";
+
 
 /**
  * callback functions for libxml2's sax parser
@@ -77,36 +85,59 @@ static void init_sax(xmlSAXHandlerPtr sax) {
 /**
  * Utils for generating javascript 
  */
-inline std::string GetObject(std::string id) {
-    return "g_"+id+"=document.getElementById('"+id+"');";
+inline std::string GetJSObject(std::string id) {
+    return "g_"+id+" = document.getElementById('"+id+"');";
 }
-inline std::string SetAttr(std::string id, std::string name, std::string value) {
-    return "g_"+id+"."+name+"='"+value+"';";
+inline std::string SetJSBegin(std::string id) {
+    return "if(g_"+id+" != undefined) {";
 }
-inline std::string CallFunc(std::string id, std::string name) {
+inline std::string SetJSAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+" = '"+value+"';";
+}
+inline std::string SetJSFunc(std::string id, std::string name) {
     std::string func = "g_"+id+"."+name;
-    return "if("+func+"!=undefined){" + func + "();}";  
+    return "if("+func+" != undefined) {" + func + "();}";  
+}
+inline std::string SetJSEvent(std::string id, std::string name, std::string value) {
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+" != undefined) {" + func + " = function() {" + value + "}}";  
+}
+inline std::string SetJSEnd() {
+    return "}";
 }
 
 /**
- * To parse CI's time
+ * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
  */
-int ParseTimeStr(std::string timestr) {
-    int sec = atoi(timestr.c_str());
+long ParseTimeStr(std::string timestr) {
+    long ms = 0;
+    if (timestr == kevinf) {
+        return -1;
+    }
+
+#if 1
+    long sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
     rpos = timestr.rfind(":");
     if (lpos != std::string::npos) {
         if (lpos != rpos) {
             sec = sec * 3600;
-            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
-            sec = sec + atoi(timestr.substr(rpos+1).c_str());
+            sec = sec + 60 * atol(timestr.substr(lpos+1).c_str());
+            sec = sec + atol(timestr.substr(rpos+1).c_str());
         }else {
             sec = sec * 60;
-            sec = sec + atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atol(timestr.substr(lpos+1).c_str());
         }
     }
-    return sec;
+    ms = sec * 1000;
+#else
+    Time time;
+    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+        return 0;
+    ms = (long)base::Time::ToJsTime(); //milliseconds
+#endif
+    return ms;
 }
 
 
@@ -115,24 +146,23 @@ int ParseTimeStr(std::string timestr) {
 
 namespace mmt {
 
+event_t::event_t() {
+    is_event = false;   // default is time
+    is_timeout = 0;     // default non-timeout, that will be processed next time
+    time = -1;          // default infinite
+}
+
 node_t::node_t(std::string name) 
     : name(name), parent(nullptr) {
-    time.first = time.second = -1;
 }
 node_t::~node_t() {
     nodes.clear();
     parent = nullptr;
 }
 
-html_div_t::html_div_t() {
-}
-html_div_t::~html_div_t() {
-}
-
-html_media_t::html_media_t() {
-    time.first = time.second = -1;
+html_t::html_t() {
 }
-html_media_t::~html_media_t() {
+html_t::~html_t() {
 }
 
 
@@ -145,6 +175,8 @@ CiParser::~CiParser() {
 
 bool CiParser::ParseXml() {
     if (fname_.empty()) return false;
+    root_ = nullptr;
+    cur_ = nullptr;
 
     xmlSAXHandler sax;
     xmlParserCtxtPtr ctxt;
@@ -168,96 +200,207 @@ bool CiParser::ParseXml() {
 
     return true;
 }
+void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
+    if (!node) return;
+
+    std::string id;
+    if (node->name == kdivLocation)
+        id = node->attrs[krefDiv];
+    else if (node->name == kMediaSync)
+        id = node->attrs[krefId];
+    if (id.empty()) return;
+
+    std::string js0, js1;       // for time
+    std::string js00, js11;     // for click event
+    js0 = js1 = SetJSBegin(id);
+    js00 = js11 = SetJSBegin(id);
+
+    std::string style = node->attrs[kstyle];
+    if (!style.empty()) {
+        js0 += SetJSAttr(id, "style", style);
+        js1 += SetJSAttr(id, "style", style);
+    }
+
+    if (node->name == kMediaSync) {
+        // set media src
+        nodeptrs_t::iterator iter = node->nodes.begin();
+        for (; iter != node->nodes.end(); iter++) {
+            nodeptr_t sub = *iter;
+            if (sub->name != ksourceList) continue;
+            std::string src = sub->attrs[kmediaSrc];
+            js0 += SetJSAttr(id, "src", src);
+            js1 += SetJSAttr(id, "src", "");
+            break;
+        }
+        js0 += SetJSFunc(id, "play");
+    }
 
+    htmlptr_t html = new html_t;
+    html->node = node;
+    html->js[EHtmlBegin] = js0;
+    html->js[EHtmlEnd] = js1;
+    html->js[EHtmlClickBegin] = js00;
+    html->js[EHtmlClickEnd] = js11;
+    htmls[id] = html;
+}
+void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
+    if (!event.is_event || (event.event != kevbegin && event.event != kevend)) 
+        return;
+
+    event.is_event = false;
+    event.time = -1;
+    if (htmls_.find(event.id) != htmls_.end()) {
+        htmlptr_t html = htmls_[event.id];
+        // only support 1 level
+        if (event.event == kevbegin)
+            event.time = html->node->time.begin.time;
+        else
+            event.time = html->node->time.end.time; 
+    }
+}
 bool CiParser::ParseHtmlTag() {
     nodeptr_t node = root_;
     if (!node) return false;
+    htmls_.clear();
+
+    nodeptrs_t::iterator iter1;
 
-    nodeptrs_t::iterator iter = node->nodes.begin();
-    for (; iter != node->nodes.end(); iter++) {
-        nodeptr_t sub = *iter;
-        if (sub->name == kview) {
-            nodeptrs_t::iterator iter2 = sub->nodes.begin();
-            for (; iter2 != sub->nodes.end(); iter2++) {
+    // init html js
+    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2 = sub1->nodes.begin();
+            for (; iter2 != sub1->nodes.end(); iter2++) {
                 nodeptr_t sub2 = *iter2;
-                if (sub2->name != kdivLocation) 
-                    continue;
-                if (sub2->attrs.find(krefDiv) == sub2->attrs.end())
-                    continue;
-
-                divptr_t div = new html_div_t;
-                div->id = sub2->attrs[krefDiv];
-                div->style = sub2->attrs[kstyle];
-                divs_.push_back(div);
-            }
-        }else if (sub->name == kMediaSync) {
-            if (sub->attrs.find(krefId) == sub->attrs.end())
-                continue;
-
-            mediaptr_t media = new html_media_t;;
-            media->id = sub->attrs[krefId];
-            media->time = sub->time;
-            media->style = sub->attrs[kstyle];
-            if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
-                media->srcs.push_back(sub->attrs[kmediaSrc]);
-            }else {
-                nodeptrs_t::iterator iter2 = sub->nodes.begin();
-                for (; iter2 != sub->nodes.end(); iter2++) {
-                    nodeptr_t sub2 = *iter2;
-                    if (sub2->name == ksourceList) {
-                        if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
-                            media->srcs.push_back(sub2->attrs[kmediaSrc]);
-                    }
+                if (sub2->name == kdivLocation) {
+                    LOG(INFO) << __func__ << " process view's " << kdivLocation;
+                    InitHtmlJS(sub2, htmls_);
                 }
             }
-            medias_.push_back(media);
+        }else if (sub1->name == kdivLocation) { // krefDiv of <div>
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+            InitHtmlJS(sub1, htmls_);
+        }else if (sub1->name == kMediaSync) {   // krefId of <img>, <audio>, <video>
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+            InitHtmlJS(sub1, htmls_);
         }
     }
-    return true;
-}
 
-bool CiParser::GetDivJS(std::string& divjs) {
-    if (divs_.empty()) return false;
 
-    divjs = "";
-    std::vector<divptr_t>::iterator iter = divs_.begin();
-    for (; iter != divs_.end(); iter++) {
-        divptr_t div = *iter;
-        if (!div->style.empty()) {
-            divjs += GetObject(div->id);
-            divjs += SetAttr(div->id, "style", div->style);
+    //
+    // process html js
+    htmlmap_t::iterator iter;
+
+    // end for time
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        html->js[EHtmlBegin] += SetJSEnd();
+        html->js[EHtmlEnd] += SetJSEnd();
+    }
+
+    // process interaction events
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        event_t begin = node->time.begin;
+        if (begin.is_event) {
+            if (begin.event == kevclick) {
+                std::string js = SetJSEvent(begin.id, "onclick", html->js[EHtmlBegin]);
+                htmls_[begin.id]->js[EHtmlClickBegin] += js;
+            }else if (begin.event == kevbegin || begin.event == kevend) {
+                SetNodeTime(node->time.begin, node);
+            }
+
+        }
+
+        event_t end = node->time.end;
+        if (end.is_event) {
+            if (end.event == kevclick) {
+                std::string js = SetJSEvent(end.id, "onclick", html->js[EHtmlEnd]);
+                htmls_[end.id]->js[EHtmlClickEnd] += js;
+            }else if (end.event == kevbegin || end.event == kevend) {
+                SetNodeTime(node->time.end, node);
+            }
         }
     }
 
+    // end for event click
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        html->js[EHtmlClickBegin] += SetJSEnd();
+        html->js[EHtmlClickEnd] += SetJSEnd();
+    }
     return true;
 }
 
-bool CiParser::GetMediaJS(long current, std::string& mediajs) {
-    if (medias_.empty()) return false;
-
-    mediajs = "";
-    std::vector<mediaptr_t>::iterator iter = medias_.begin();
-    for (; iter != medias_.end(); iter++) {
-        mediaptr_t media = *iter;
-        int begin = media->time.first;
-        int end = media->time.second;
-        if (begin < 0) continue;
-        if (current < begin) continue;
-
-        std::string id = media->id;
-        bool bstart = (current<end || end<0);
-        if (bstart) {
-            mediajs += GetObject(id);
-            if (!media->srcs.empty()) {
-                mediajs += SetAttr(id, "src", media->srcs[0]);
-            }
-            mediajs += CallFunc(id, "play");
-        }else {
-            mediajs += GetObject(id);
-            mediajs += SetAttr(id, "src", "");
-            mediajs += CallFunc(id, "stop");
+/**
+ * To process both @begin and @end
+ */
+bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
+    long curtime = -1;
+    if (!cnode) return false;
+
+    event_t begin = cnode->time.begin;
+    if (begin.is_timeout > 0) return false;
+
+    if (begin.event == kevclick) {
+        ev = EHtmlClickBegin;
+        cnode->time.begin.is_timeout = 1;
+        return true;
+    }else {
+        ev = EHtmlBegin;
+        curtime = begin.time;
+    }
+
+    // search cnode's parent
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.begin.is_event) {
+            if (node->time.begin.time >= 0 && node->time.begin.time > curtime)
+                curtime = node->time.begin.time;
+        }
+    }while(true);
+
+    LOG(INFO) << __func__ << " node name=" << begin.id << " curtime=" << curtime << " current=" << current;
+    if (curtime < 0 || curtime <= current) {
+        cnode->time.begin.is_timeout = 1;
+        return true;
+    }
+    return false;
+}
+bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
+    return false;
+}
+bool CiParser::GetHtmlJS(long current, std::string& js) {
+    js = "";
+    if (htmls_.empty()) return false;
+
+    std::string js1, js2;
+
+    // init js object
+    htmlmap_t::iterator iter;
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        std::string id = iter->first;
+        js1 += GetJSObject(id);
+    }
+
+    // add js process
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        int ev;
+        if (ShouldBeginTime(current, node, ev)) {
+            js2 += html->js[ev];
+        }
+        if (ShouldEndTime(current, node, ev)) {
+            js2 += html->js[ev];
         }
     }
+
+    if (!js2.empty()) js = js1 + js2;
+
     return true;
 }
 
@@ -287,57 +430,47 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
-bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
-    bool is_begin = true;
+/**
+ * To parse the content of mmtci::begin or mmtci:end to event_t
+ */
+bool ParseTimeEvent(std::string value, event_t& event) {
+    // time's event
     std::string::size_type pos;
+    do {
+        pos = value.find(kevclick);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevbegin);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevend);
+        if (pos != std::string::npos) break;
+    }while(false);
 
-    pos = value.find(".click");
     if (pos != std::string::npos) {
-        // todo: proc click event
-        return true;
-    }
-
-    pos = value.find(".begin");
-    if (pos == std::string::npos) {
-        is_begin = false;
-        pos = value.find(".end");
-    }
-
-    if (pos == std::string::npos) {
-        second = ParseTimeStr(value);
-        return true;
-    }
-
-    second = -2;
-    std::string idstr = value.substr(0, pos);
-    nodeptrs_t::iterator iter = node->nodes.begin();
-    for (; iter != node->nodes.end(); iter++) {
-        nodeptr_t sub = *iter;
-        if (sub->name == kMediaSync) {
-            if (sub->attrs[krefId] == idstr) {
-                std::string timestr = (is_begin) ? sub->attrs[kbegin] : sub->attrs[kend];
-                second = ParseTimeStr(timestr);
-                break;
-            }
-        }
+        event.is_event = true;
+        event.id = value.substr(0, pos);
+        event.event = value.substr(pos);
+        LOG(INFO) << __func__ << " event.id=" << event.id << " event.event=" << event.event;
+    }else {
+        event.is_event = false;
+        event.time = ParseTimeStr(value);
+        LOG(INFO) << __func__ << " event.time=" << event.time;
     }
     return true;
 }
 
 bool CiParser::AddAttr(std::string name, std::string value) {
-    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
-    //    << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
     if (name == kbegin || name == kend) {
-        int sec = -2;
-        ParseTimeById(root_, value, sec);
-        if (name == kbegin)
-            cur_->time.first = sec;
-        else
-            cur_->time.second = sec;
-        //LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
+        //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+        //    << " attr: " << name << " => " << value;
     }
+    if (name == kbegin) {
+        ParseTimeEvent(value, cur_->time.begin);
+    }else if (name == kend) {
+        ParseTimeEvent(value, cur_->time.end);
+    }
+
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 7b84035..8eef4a8 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -16,7 +16,30 @@ struct node_t;
 typedef scoped_refptr<node_t> nodeptr_t;
 typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
-typedef std::pair<long, long> range_t;
+
+
+/**
+ * Structore for mmtci:begin and mmtci:end
+ */
+enum EHtmlEvent{
+    EHtmlBegin,
+    EHtmlEnd,
+    EHtmlClickBegin,
+    EHtmlClickEnd,
+};
+
+struct event_t {
+    event_t();
+    bool is_event;
+    int is_timeout;
+    std::string id;
+    std::string event;
+    long time;          // ms, valid if no id
+};
+struct citime_t {
+    event_t begin;
+    event_t end;
+};
 
 
 /**
@@ -28,8 +51,9 @@ public:
 
     std::string name;
     attrs_t attrs;
-    range_t time;     // for time range
-    nodeptrs_t nodes; // sub-nodes
+    citime_t time;      // for time range
+
+    nodeptrs_t nodes;   // sub-nodes
     nodeptr_t parent;
 
 protected:
@@ -37,41 +61,20 @@ protected:
     virtual ~node_t();
 };
 
-
-/** 
- * Structure for html tag <div>
- */
-struct html_div_t : public base::RefCounted<html_div_t> {
-public: 
-    explicit html_div_t();
-
-    std::string id; // tag id
-    std::string style;
-
-protected:
-    friend class base::RefCounted<html_div_t>;
-    virtual ~html_div_t();
-};
-typedef scoped_refptr<html_div_t> divptr_t;
-
-
-/** 
- * Sturcture for tags of html <img>, <audio> and <video>
- */
-struct html_media_t : public base::RefCounted<html_media_t> { 
+typedef std::map<int, std::string> jsmap_t;  // k/v: EHtmlEvent => ..
+struct html_t : public base::RefCounted<html_t>{
 public:
-    explicit html_media_t();
-
-    std::string id;     // tag id
-    range_t time;       // [begin, end]
-    std::string style;
-    std::vector<std::string> srcs;    //src list
+    explicit html_t();
+    std::string id;
+    jsmap_t js;
+    nodeptr_t node;
 
 protected:
-    friend class base::RefCounted<html_media_t>;
-    virtual ~html_media_t();
+    friend class base::RefCounted<html_t>;
+    virtual ~html_t();
 };
-typedef scoped_refptr<html_media_t> mediaptr_t;
+typedef scoped_refptr<html_t> htmlptr_t;
+typedef std::map<std::string, htmlptr_t> htmlmap_t; // k/v: tag id => ..
 
 
 /** 
@@ -83,9 +86,11 @@ public:
 
     bool ParseXml();
     bool ParseHtmlTag();
+    bool GetHtmlJS(long current, std::string& js);
 
-    bool GetDivJS(std::string& divjs);
-    bool GetMediaJS(long current, std::string& mediajs);
+    void SetNodeTime(event_t& event, nodeptr_t node);
+    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
 
     bool AddNode(std::string name);
     bool EndNode(std::string name);
@@ -98,10 +103,9 @@ protected:
 private:
     std::string fname_;
     nodeptr_t root_;
-    nodeptr_t cur_; // only for AddNode and AddAttr
+    nodeptr_t cur_; // only for AddNode/AddAttr
 
-    std::vector<divptr_t> divs_;
-    std::vector<mediaptr_t> medias_;
+    htmlmap_t htmls_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 06600da..e9aa6a7 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -43,7 +43,7 @@ static uint64_t mmtp_tell(stream_t *s) {
 static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
-static stream_t* InitMpuStream(Stream* ptr) {
+stream_t* InitMpuStream(Stream* ptr) {
     stream_t* s = (stream_t*)malloc(sizeof(stream_t));
     s->opaque = (void*)ptr;
     s->open = mmtp_open;
@@ -122,9 +122,9 @@ void* Stream::Open(const char* filename, int mode) {
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
-            fname = fname + "/audio/Channel1_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
+            fname = fname + "/audio/loveapartment_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == "video") {
-            fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
+            fname = fname + "/video/loveapartment_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
@@ -141,6 +141,7 @@ void* Stream::Open(const char* filename, int mode) {
     if (ierr != 0) return nullptr; 
 
     if (index != -1 && index != midx_.begin) {
+#if 1
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
@@ -156,6 +157,9 @@ void* Stream::Open(const char* filename, int mode) {
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
+#else
+        offmap_[index] = offset_t(0, lret);
+#endif
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
-- 
1.7.9.5


From a9af6db45debf43a7289f7735f9b659b86ea04d6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 05:56:35 -0800
Subject: [PATCH 66/92] [todo] add ntp interface to process event

---
 net/mmt/mmt_control.cc      |    7 +++---
 net/mmt/mmt_inc.h           |    5 +++++
 net/mmt/mmt_parser.cc       |   52 ++++++++++++++++++++++++++++++-------------
 net/mmt/mmt_utils.cc        |   12 ++++++++++
 net/mmt/mpu/moof_combine.sh |   19 ++++++++++++++++
 5 files changed, 77 insertions(+), 18 deletions(-)
 create mode 100644 net/mmt/mpu/moof_combine.sh

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 19785ef..acb27d4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -167,7 +167,7 @@ void MmtControl::CheckEvent() {
         if (!cixml) continue;
         if (cixml->status == "end") continue;
 
-        LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
         std::string next_status = cixml->status;
         CiParserPtr parser = cixml->parser;
 
@@ -187,14 +187,15 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loaded") {
             if (parser) {
                 std::string js;
-                if(parser->GetHtmlJS(0, js) && !js.empty()) {
+                long ntp = GetNTPTime();
+                if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
                 }
             }
-            next_status = "end";
+            //next_status = "end";
         }
         cixml->status = next_status;
     }
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index bdac625..74a0dea 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -72,6 +72,11 @@ bool GetRangeValue(std::string range, int &lval, int &rval);
  */
 int SendToHost(std::string msg, std::string szaddr, int port);
 
+/**
+ *
+ */
+long GetNTPTime();
+
 }
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 3e5d17a..cd71f93 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -99,8 +99,7 @@ inline std::string SetJSFunc(std::string id, std::string name) {
     return "if("+func+" != undefined) {" + func + "();}";  
 }
 inline std::string SetJSEvent(std::string id, std::string name, std::string value) {
-    std::string func = "g_"+id+"."+name;
-    return "if("+func+" != undefined) {" + func + " = function() {" + value + "}}";  
+    return "g_"+id+"."+name+" = function() {" + value + "}";  
 }
 inline std::string SetJSEnd() {
     return "}";
@@ -221,18 +220,33 @@ void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
         js1 += SetJSAttr(id, "style", style);
     }
 
+    // set media src
     if (node->name == kMediaSync) {
-        // set media src
-        nodeptrs_t::iterator iter = node->nodes.begin();
-        for (; iter != node->nodes.end(); iter++) {
-            nodeptr_t sub = *iter;
-            if (sub->name != ksourceList) continue;
-            std::string src = sub->attrs[kmediaSrc];
+        bool bfind = false;
+        // for <img>
+        if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
+            std::string src = node->attrs[kmediaSrc];
             js0 += SetJSAttr(id, "src", src);
             js1 += SetJSAttr(id, "src", "");
-            break;
+            bfind = true;
+        }else {
+            // for <audio> <video>
+            nodeptrs_t::iterator iter = node->nodes.begin();
+            for (; iter != node->nodes.end(); iter++) {
+                nodeptr_t sub = *iter;
+                if (sub->name != ksourceList) continue;
+                std::string src = sub->attrs[kmediaSrc];
+                js0 += SetJSAttr(id, "src", src);
+                js1 += SetJSAttr(id, "src", "");
+                bfind = true;
+                break;
+            }
+        }
+
+        if (bfind) {
+            js0 += SetJSFunc(id, "play");
+            js1 += SetJSFunc(id, "pause");
         }
-        js0 += SetJSFunc(id, "play");
     }
 
     htmlptr_t html = new html_t;
@@ -387,15 +401,23 @@ bool CiParser::GetHtmlJS(long current, std::string& js) {
     }
 
     // add js process
+    int ev;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
-        int ev;
-        if (ShouldBeginTime(current, node, ev)) {
-            js2 += html->js[ev];
-        }
         if (ShouldEndTime(current, node, ev)) {
-            js2 += html->js[ev];
+            if (ev == EHtmlClickEnd)
+                html = htmls_[node->time.end.id];
+            if (html) js2 += html->js[ev];
+        }
+    }
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        if (ShouldBeginTime(current, node, ev)) {
+            if (ev == EHtmlClickBegin)
+                html = htmls_[node->time.begin.id];
+            if (html) js2 += html->js[ev];
         }
     }
 
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 2aba4aa..ddcba66 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -102,5 +102,17 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
+long GetNTPTime() {
+    static long _last = 0;
+
+    struct timeval tv;
+    memset(&tv, 0, sizeof(tv));
+    gettimeofday(&tv, NULL);
+    long current = tv.tv_sec*1000 + tv.tv_usec/1000;
+    if (_last == 0) {
+        _last = current;
+    }
+    return current - _last;
+}
 
 } // namespace mmt
diff --git a/net/mmt/mpu/moof_combine.sh b/net/mmt/mpu/moof_combine.sh
new file mode 100644
index 0000000..5b6cf0e
--- /dev/null
+++ b/net/mmt/mpu/moof_combine.sh
@@ -0,0 +1,19 @@
+
+rm -rf audio
+mkdir -p audio
+
+apath="/home/yongzxu/Downloads/MPUFile/"
+apath="/home/yongzxu/Videos/mmt/loveapartment_0203/audio"
+name="loveapartment_Audio1_MPU"
+offset=1037
+
+for i in `seq 1 99`; do
+    [ $i -lt 10 ] && ./cutfile $apath/${name}_000$i.mp4 $offset audio/t$i.mp4 && continue
+    [ $i -lt 100 ] && ./cutfile $apath/${name}_00$i.mp4 $offset audio/t$i.mp4 && continue
+    [ $i -lt 250 ] && ./cutfile $apath/${name}_0$i.mp4 $offset audio/t$i.mp4 && continue
+done
+
+cp -f $apath/${name}_0000.mp4 /tmp/test_audio.mp4
+for i in `seq 1 99`; do
+    cat audio/t$i.mp4 >> /tmp/test_audio.mp4
+done
-- 
1.7.9.5


From a1e5262300701487c0063d9d275dfe591641bac6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 09:03:04 -0800
Subject: [PATCH 67/92] [todo] add ntp module

---
 net/mmt/mmt_inc.h       |    3 +-
 net/mmt/mmt_utils.cc    |   30 +-
 net/mmt/ntp/HOWTO       |  177 ++++++++++++
 net/mmt/ntp/Makefile    |   37 +++
 net/mmt/ntp/ntp.gyp     |   80 +++++
 net/mmt/ntp/ntpclient.c |  739 +++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/ntp/ntpclient.h |   18 ++
 net/mmt/ntp/phaselock.c |  339 ++++++++++++++++++++++
 net/net.gyp             |    1 +
 9 files changed, 1416 insertions(+), 8 deletions(-)
 create mode 100644 net/mmt/ntp/HOWTO
 create mode 100644 net/mmt/ntp/Makefile
 create mode 100644 net/mmt/ntp/ntp.gyp
 create mode 100644 net/mmt/ntp/ntpclient.c
 create mode 100644 net/mmt/ntp/ntpclient.h
 create mode 100644 net/mmt/ntp/phaselock.c

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 74a0dea..9a5761a 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -73,8 +73,9 @@ bool GetRangeValue(std::string range, int &lval, int &rval);
 int SendToHost(std::string msg, std::string szaddr, int port);
 
 /**
- *
+ * Get local/ntp time (ms)
  */
+long GetLocalTime();
 long GetNTPTime();
 
 }
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index ddcba66..6ff147e 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -1,5 +1,7 @@
 #include "net/mmt/mmt_inc.h"
 
+#include "net/mmt/ntp/ntpclient.h"
+
 namespace mmt {
 
 void Wait(int ms) {
@@ -102,17 +104,31 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
-long GetNTPTime() {
-    static long _last = 0;
-
+long GetLocalTime() {
     struct timeval tv;
     memset(&tv, 0, sizeof(tv));
     gettimeofday(&tv, NULL);
-    long current = tv.tv_sec*1000 + tv.tv_usec/1000;
-    if (_last == 0) {
-        _last = current;
+    return tv.tv_sec*1000 + tv.tv_usec/1000;
+}
+
+long GetNTPTime() {
+    static long _lastntp = 0;   // ntp time
+    static long _last = 0;      // local tome
+
+    if (_lastntp == 0) {
+        struct ntp_time_t ntp_time;
+        int iret = ntp_get_time("time.apple.com", &ntp_time);
+        _last = GetLocalTime();
+        if (iret == 0)
+            _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
+        else
+            _lastntp = _last;
+        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last;
     }
-    return current - _last;
+
+    long diff = GetLocalTime() - _last;
+    //long currentntp = _lastntp + diff;
+    return diff;
 }
 
 } // namespace mmt
diff --git a/net/mmt/ntp/HOWTO b/net/mmt/ntp/HOWTO
new file mode 100644
index 0000000..cf0e7429
--- /dev/null
+++ b/net/mmt/ntp/HOWTO
@@ -0,0 +1,177 @@
+The goal of ntpclient is not only to set your computer's clock
+right once, but keep it there.
+
+First, a note on typical 1990's and 2000's computer crystals.  They
+are truly pathetic.  A "real" crystal oscillator (TCXO) usually has
+an initial set error of less than 5 ppm, and variation over time, voltage,
+and temperature measured in tenths of a ppm (and an OCXO can reach 0.3 ppm
+stability over ten years and 85C temperature swing).  The devices used
+in conventional PC motherboards and single board computers, however,
+often have initial set errors up to 150 ppm, and will vary 5 ppm over
+the course of a day-night cycle in a pseudo-air-conditioned space.
+
+[Operating system software can sometimes exacerbate the problem.  I
+have seen some i686 Red Hat 7.3 systems run the clock at 512 Hz, or 953
+microseconds per tick, giving a built in 64 ppm error.  Even the normally
+exemplary DEC Alpha has, when run with Linux, a truly awful calibration
+scheme; Linux runs it with a nominal ticks per second of 1024, which
+gives a tick value of 977, theoretical additional error -448 ppm, actual
+frequency observed -443.7 ppm.]
+
+Still, the pattern is clear: the first and largest error of a crystal
+is its initial set error.  I strongly urge the calibration of each computer,
+and storing its frequency error in a non-volatile medium, before you
+do anything else with time setting and locking.  While you could do it
+in a few seconds using an accurate frequency counter, below I show a
+software-only method using ntpclient and a high quality NTP server.
+
+To perform the activities described, you need a way to control and monitor
+your system's clock -- both its frequency and value.  On Linux, the
+kernel API is described in adjtimex(2).  There are two programs that
+I know of that provide shell-level access to this interface, both called
+adjtimex(1).
+
+One is written by Steven Dick and Jim Van Zandt, see the adjtimex* files in
+http://metalab.unc.edu/pub/Linux/system/admin/time/
+It uses long options, and includes some interesting functionality beyond
+the basic exposure of adjtimex(2).
+
+I (Larry Doolittle) wrote the other; it uses short options, and has no
+bloat^H^H^H^H^Hextra features.  I include the code here for a standalone
+version; it is also incorporated into busybox (http://www.busybox.net),
+although you may have to select it at compile time, like any other component.
+
+Fortunately (and not coincidentally) the core functions of the two adjtimex
+programs can be used interchangeably, as long as you only use the short option
+variant of the Dick/Van Zandt adjtimex.  The options discussed here are:
+       -f    frequency (integer kernel units)
+       -o    time offset in microseconds
+       -t    kernel tick (microseconds per jiffy)
+
+First, set the time approximately right, as root:
+   ntpclient -s -h $NTPHOST
+You should see a single line printed like
+36765 4980.373    1341.0     39.7  956761.4    839.2  0
+Get used to this line: column headers are
+ 1. day since 1900
+ 2. seconds since midnight
+ 3. elapsed time for NTP transaction (microseconds)
+ 4. internal server delay (microseconds)
+ 5. clock difference between your computer and the NTP server (microseconds)
+ 6. dispersion reported by server (microseconds)
+ 7. your computer's adjtimex frequency (ppm * 65536)
+So in the example above, your computer's clock was a bit more than
+0.95 seconds fast, compared to the clock on $NTPHOST.
+Now check that the clock setting worked.
+   ntpclient -c 1 -h $NTPHOST
+36765 4993.512    1345.0     40.9    3615.3    839.2  0
+So now the time difference is only a few milliseconds.
+
+On to measure the frequency calibration for your system.
+If you're in a hurry, it's OK to only spend 20 minutes on this step.
+    ntpclient -i 60 -c 20 -h $NTPHOST >$(hostname).ntp.log &
+
+Otherwise, you will learn much more about your system and its communication
+with the NTP server by letting the log run for 24 hours.
+    ntpclient -i 300 -c 288 -h $NTPHOST >$(hostname).ntp.log &
+
+Things to watch for in the above log:
+
+If the last column (kernel frequency fine tune) ever changes, you haven't
+turned off other time adjustment programs.  AFAIK the only programs around
+that would move this number are ntpclient and xntpd.  On most out-of-the-box
+systems, that last column should start zero and stay zero.
+
+Use gnuplot to plot the resulting file as follows:
+   plot "HOSTNAME.ntp.log" using (($1-36765)*86400+$2):5:($3+$6) with yerrorbars
+This shows time error (microseconds) as a function of elapsed time (seconds).
+The error bars show the uncertainty in the measurement.  Ideally, it would
+be a smooth, straight line, where the slope represents the frequency error
+of your crystal.
+
+If an occasional point is both off-center and has a large error bar, it shows
+a transaction got delayed somewhere in the process, either inside the server,
+or one of the two UDP packet propagation steps.  This is normal, and ntpclient
+can deal with those quite well.  If points are not evenly spaced on the
+horizontal axis, packets were actually lost; this is less common, but still OK.
+
+If the error bar becomes suddenly large, and takes a few minutes to slowly
+recover, your NTP host (presumably xntpd) had problems communicating with
+_its_ server, and reported that problem to you by increasing its "dispersion"
+(this is a hack, required by xntpd's core incorrect assumption that errors
+in network delays have Gaussian statistics; ntpclient does not have this flaw).
+
+If there are sudden large, persistent steps in error, some other program is
+making step changes to time.  Check for, e.g., ntpdate run as a cron job.
+If your client machine is OK, check for problems on the _host_ machine.
+
+Assuming the graph above is clean, and has non-garbled data for the first
+and last points, you can run it through the enclosed awk script (rate.awk)
+to determine the appropriate frequency value.
+$ awk -f rate.awk <test.dat
+delta-t 119400 seconds
+delta-o -142308 useconds
+slope -1.19186 ppm
+old frequency -1240000 ( -18.9209 ppm)
+new frequency -1318109 ( -20.1127 ppm)
+$
+
+For now, you should plug in the new frequency value
+   adjtimex -f -1318109
+Then reset the clock
+   ntpclient -s -h $NTPHOST
+and ponder how it makes sense in _your_ (possibly embedded) environment
+to have the number -1318109 applied via adjtimex every time your machine
+boots.  Or, simpler still, combine these two steps using a post-2005 version:
+   ntpclient -f -1318109 -s -h $NTPHOST
+
+If the frequency offset (absolute value) is greater than about 230 ppm
+(15073280), you have a problem: you may be able to fix it with the -t
+option to adjtimex, or you need to hack phaselock.c, that has a
+maximum adjustment extent of +/- 250 ppm built into phaselock.c (change
+the #define MAX_CORRECT and rebuild ntpclient).  I'd like to suggest that
+you replace the defective crystal instead, but I understand that is rarely
+practical.
+
+On to ntpclient -l.  This is actually easy, if you performed and understood
+the previous steps.  Run
+  ntpclient -l -h $NTPHOST
+in the background.  It will make small (probably less than 3 ppm) adjustments
+to the system frequency to keep the clocks locked.  Typical performance over
+Ethernet (even through a few routers) is a worst case error of +/- 10 ms.
+
+I won't try to tell you _where_ to put the boot time commands.  They should
+boil down to:
+   adjtimex -f $NONVOLATILE_MEMORY_VALUE
+   ntpclient -s -i 15 -g 10000 -h $NTPHOST
+   ntpclient -l -h $NTPHOST >some_log_file
+The second line makes explicit the retries that may be required for this
+UDP-based time protocol.  If the first time request takes longer than 10000
+microseconds to resolve, or the packets get lost, it instructs ntpclient to
+try again 15 seconds later (the minimum retry period mandated by RFC-4330),
+and it won't exit until it gets such a suitable response.
+
+As of 2006, ntpclient can in theory combine the three lines above into one:
+   ntpclient -f $NONVOLATILE_MEMORY_VALUE -s -l -i 600 -g 10000 -h $NTPHOST >some_log_file
+This can streamline the startup process, since you may be able to avoid a
+layer of shell scripting.  On the other hand, it is less tested, and there
+is no (current) means to independently set the packet interval for the
+set and lock phases.
+
+It's an interesting question how sensitive the boot process should be
+to the time set process.  If you have a battery backed hardware clock,
+there's not much problem running for a while without a network-accurate
+system clock.  In that case you could put both ntpclient commands into a
+background script, and the only possible issue is the sudden (but probably
+small) warp of the clock at the indefinite time in the boot sequence when
+ntpclient gets its acceptable answer.  On the other hand, some embedded
+computers have no clue what time it is until the network responds.  Any
+files created will be marked Jan 1 1970, and other application-dependent
+issues may arise if there is a nonsense time on the system during later
+parts of the boot sequence.  Then you may well want to enforce completion
+of the first ntpclient before starting your application.  If this is too
+drastic for you, and you want a fallback mode when the time server is dead,
+add a "-c 5" switch to the end of that ntpclient command, giving at most 5
+retries, if something goes wrong with the time set.  For that approach to be
+useful, consider patching the source to lower the minimum packet send
+interval from the RFC-4330-mandated 15 seconds.
diff --git a/net/mmt/ntp/Makefile b/net/mmt/ntp/Makefile
new file mode 100644
index 0000000..34cef76
--- /dev/null
+++ b/net/mmt/ntp/Makefile
@@ -0,0 +1,37 @@
+# A long time ago, far, far away, under Solaris, you needed to
+#    CFLAGS += -xO2 -Xc
+#    LDLIBS += -lnsl -lsocket
+# To cross-compile
+#    CC = arm-linux-gcc
+# To check for lint
+#    CFLAGS += -Wpointer-arith -Wcast-align -Wcast-qual -Wshadow -Wundef \
+#     -Waggregate-return -Wnested-externs -Winline -Wwrite-strings -Wstrict-prototypes
+
+# This is old-school networking code, making the traditional cast between
+# struct sockaddr* and struct sockaddr_in*.  Thus a modern gcc needs:
+CFLAGS += -fno-strict-aliasing
+
+CFLAGS += -std=c89
+CFLAGS += -W -Wall
+CFLAGS += -O2
+# CFLAGS += -DPRECISION_SIOCGSTAMP
+#CFLAGS += -DENABLE_DEBUG
+#CFLAGS += -DENABLE_REPLAY
+# CFLAGS += -DUSE_OBSOLETE_GETTIMEOFDAY
+
+LDFLAGS += -lrt
+
+all: ntpclient
+
+test: ntpclient
+	./ntpclient -d -r <test.dat
+
+ntpclient: ntpclient.o phaselock.o
+	$(CC) -o ntpclient ntpclient.o phaselock.o $(LDFLAGS) 
+
+ntpclient.o phaselock.o: ntpclient.h
+
+adjtimex: adjtimex.o
+
+clean:
+	rm -f ntpclient adjtimex *.o
diff --git a/net/mmt/ntp/ntp.gyp b/net/mmt/ntp/ntp.gyp
new file mode 100644
index 0000000..6ec9ea7
--- /dev/null
+++ b/net/mmt/ntp/ntp.gyp
@@ -0,0 +1,80 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libntp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'ntp',
+      'sources': [
+        'ntpclient.c',
+        'phaselock.c',
+      ],
+      'defines': [
+        'LIBNTP'
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '-std=c89',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lrt',
+          ],
+        }],
+      ],
+    },
+  ],
+}
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
new file mode 100644
index 0000000..293eca0
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.c
@@ -0,0 +1,739 @@
+/*
+ * ntpclient.c - NTP client
+ *
+ * Copyright (C) 1997, 1999, 2000, 2003, 2006, 2007, 2010  Larry Doolittle  <larry@doolittle.boa.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Write more documentation  :-(
+ *      - Support leap second processing
+ *      - Support IPv6
+ *      - Support multiple (interleaved) servers
+ *
+ *  Compile with -DPRECISION_SIOCGSTAMP if your machine really has it.
+ *  There are patches floating around to add this to Linux, but
+ *  usually you only get an answer to the nearest jiffy.
+ *  Hint for Linux hacker wannabes: look at the usage of get_fast_time()
+ *  in net/core/dev.c, and its definition in kernel/time.c .
+ *
+ *  If the compile gives you any flak, check below in the section
+ *  labelled "XXX fixme - non-automatic build configuration".
+ */
+
+#define _POSIX_C_SOURCE 199309
+#define _BSD_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>     /* gethostbyname */
+#include <arpa/inet.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#ifdef PRECISION_SIOCGSTAMP
+#include <sys/ioctl.h>
+#endif
+#ifdef USE_OBSOLETE_GETTIMEOFDAY
+#include <sys/time.h>
+#endif
+
+#include "ntpclient.h"
+
+/* Default to the RFC-4330 specified value */
+#ifndef MIN_INTERVAL
+#define MIN_INTERVAL 15
+#endif
+
+#ifdef ENABLE_DEBUG
+#define DEBUG_OPTION "d"
+int debug=0;
+#else
+#define DEBUG_OPTION
+#define debug 0
+#endif
+
+#ifdef ENABLE_REPLAY
+#define  REPLAY_OPTION   "r"
+#else
+#define  REPLAY_OPTION
+#endif
+
+/* global tuning parameter */
+extern double min_delay;
+
+/* prototype for function defined in phaselock.c */
+extern int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq);
+
+extern char *optarg;  /* according to man 2 getopt */
+
+#include <stdint.h>
+typedef uint32_t u32;  /* universal for C99 */
+/* typedef u_int32_t u32;   older Linux installs? */
+
+/* XXX fixme - non-automatic build configuration */
+#ifdef __linux__
+#include <sys/utsname.h>
+#include <sys/time.h>
+#include <sys/timex.h>
+#include <netdb.h>
+#else
+extern struct hostent *gethostbyname(const char *name);
+extern int h_errno;
+#define herror(hostname) \
+	fprintf(stderr,"Error %d looking up hostname %s\n", h_errno,hostname)
+#endif
+/* end configuration for host systems */
+
+#define JAN_1970        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define NTP_PORT (123)
+
+/* How to multiply by 4294.967296 quickly (and not quite exactly)
+ * without using floating point or greater than 32-bit integers.
+ * If you want to fix the last 12 microseconds of error, add in
+ * (2911*(x))>>28)
+ */
+#define NTPFRAC(x) ( 4294*(x) + ( (1981*(x))>>11 ) )
+
+/* The reverse of the above, needed if we want to set our microsecond
+ * clock (via clock_settime) based on the incoming time in NTP format.
+ * Basically exact.
+ */
+#define USEC(x) ( ( (x) >> 12 ) - 759 * ( ( ( (x) >> 10 ) + 32768 ) >> 16 ) )
+
+/* Converts NTP delay and dispersion, apparently in seconds scaled
+ * by 65536, to microseconds.  RFC-1305 states this time is in seconds,
+ * doesn't mention the scaling.
+ * Should somehow be the same as 1000000 * x / 65536
+ */
+#define sec2u(x) ( (x) * 15.2587890625 )
+
+struct ntptime {
+	unsigned int coarse;
+	unsigned int fine;
+};
+
+struct ntp_control {
+	u32 time_of_send[2];
+	int live;
+	int set_clock;   /* non-zero presumably needs root privs */
+	int probe_count;
+	int cycle_time;
+	int goodness;
+	int cross_check;
+	char serv_addr[4];
+};
+
+/* prototypes for some local routines */
+static void send_packet(int usd, u32 time_sent[2]);
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time);
+/* static void udp_handle(int usd, char *data, int data_len, struct sockaddr *sa_source, int sa_len); */
+
+static int get_current_freq(void)
+{
+	/* OS dependent routine to get the current value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes=0;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static int set_freq(int new_freq)
+{
+	/* OS dependent routine to set a new value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes = ADJ_FREQUENCY;
+	txc.freq = new_freq;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static void set_time(struct ntptime *new)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to set the system clock
+	 */
+	struct timespec tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_nsec = USEC(new->fine)*1000;
+	if (clock_settime(CLOCK_REALTIME, &tv_set)<0) {
+		perror("clock_settime");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.9lu\n", tv_set.tv_sec, tv_set.tv_nsec);
+	}
+#else
+	/* Traditional Linux way to set the system clock
+	 */
+	struct timeval tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_usec = USEC(new->fine);
+	if (settimeofday(&tv_set,NULL)<0) {
+		perror("settimeofday");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.6lu\n", tv_set.tv_sec, tv_set.tv_usec);
+	}
+#endif
+}
+
+static void ntpc_gettime(u32 *time_coarse, u32 *time_fine)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to get the system time
+	 */
+	struct timespec now;
+	clock_gettime(CLOCK_REALTIME, &now);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_nsec/1000);
+#else
+	/* Traditional Linux way to get the system time
+	 */
+	struct timeval now;
+	gettimeofday(&now, NULL);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_usec);
+#endif
+}
+
+static void send_packet(int usd, u32 time_sent[2])
+{
+	u32 data[12];
+#define LI 0
+#define VN 3
+#define MODE 3
+#define STRATUM 0
+#define POLL 4
+#define PREC -6
+
+	if (debug) fprintf(stderr,"Sending ...\n");
+	if (sizeof data != 48) {
+		fprintf(stderr,"size error\n");
+		return;
+	}
+	memset(data,0,sizeof data);
+	data[0] = htonl (
+		( LI << 30 ) | ( VN << 27 ) | ( MODE << 24 ) |
+		( STRATUM << 16) | ( POLL << 8 ) | ( PREC & 0xff ) );
+	data[1] = htonl(1<<16);  /* Root Delay (seconds) */
+	data[2] = htonl(1<<16);  /* Root Dispersion (seconds) */
+	ntpc_gettime(time_sent, time_sent+1);
+	data[10] = htonl(time_sent[0]); /* Transmit Timestamp coarse */
+	data[11] = htonl(time_sent[1]); /* Transmit Timestamp fine   */
+	send(usd,data,48,0);
+}
+
+static void get_packet_timestamp(int usd, struct ntptime *udp_arrival_ntp)
+{
+#ifdef PRECISION_SIOCGSTAMP
+	/* XXX broken */
+	struct timeval udp_arrival;
+	if ( ioctl(usd, SIOCGSTAMP, &udp_arrival) < 0 ) {
+		perror("ioctl-SIOCGSTAMP");
+		gettimeofday(&udp_arrival, NULL);
+	}
+	udp_arrival_ntp->coarse = udp_arrival.tv_sec + JAN_1970;
+	udp_arrival_ntp->fine   = NTPFRAC(udp_arrival.tv_usec);
+#else
+	(void) usd;  /* not used */
+	ntpc_gettime(&udp_arrival_ntp->coarse, &udp_arrival_ntp->fine);
+#endif
+}
+
+static int check_source(int data_len, struct sockaddr *sa_source, unsigned int sa_len, struct ntp_control *ntpc)
+{
+	struct sockaddr_in *sa_in=(struct sockaddr_in *)sa_source;
+	(void) sa_len;  /* not used */
+	if (debug) {
+		printf("packet of length %d received\n",data_len);
+		if (sa_source->sa_family==AF_INET) {
+			printf("Source: INET Port %d host %s\n",
+				ntohs(sa_in->sin_port),inet_ntoa(sa_in->sin_addr));
+		} else {
+			printf("Source: Address family %d\n",sa_source->sa_family);
+		}
+	}
+	/* we could check that the source is the server we expect, but
+	 * Denys Vlasenko recommends against it: multihomed hosts get it
+	 * wrong too often. */
+#if 0
+	if (memcmp(ntpc->serv_addr, &(sa_in->sin_addr), 4)!=0) {
+		return 1;  /* fault */
+	}
+#else
+	(void) ntpc; /* not used */
+#endif
+	if (NTP_PORT != ntohs(sa_in->sin_port)) {
+		return 1;  /* fault */
+	}
+	return 0;
+}
+
+static double ntpdiff( struct ntptime *start, struct ntptime *stop)
+{
+	int a;
+	unsigned int b;
+	a = stop->coarse - start->coarse;
+	if (stop->fine >= start->fine) {
+		b = stop->fine - start->fine;
+	} else {
+		b = start->fine - stop->fine;
+		b = ~b;
+		a -= 1;
+	}
+
+	return a*1.e6 + b * (1.e6/4294967296.0);
+}
+
+/* Does more than print, so this name is bogus.
+ * It also makes time adjustments, both sudden (-s)
+ * and phase-locking (-l).
+ * sets *error to the number of microseconds uncertainty in answer
+ * returns 0 normally, 1 if the message fails sanity checks
+ */
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time)
+{
+/* straight out of RFC-1305 Appendix A */
+	int li, vn, mode, stratum, poll, prec;
+	int delay, disp, refid;
+	struct ntptime reftime, orgtime, rectime, xmttime;
+	double el_time,st_time,skew1,skew2;
+	int freq;
+#ifdef ENABLE_DEBUG
+	const char *drop_reason=NULL;
+#endif
+
+#define Data(i) ntohl(((u32 *)data)[i])
+	li      = Data(0) >> 30 & 0x03;
+	vn      = Data(0) >> 27 & 0x07;
+	mode    = Data(0) >> 24 & 0x07;
+	stratum = Data(0) >> 16 & 0xff;
+	poll    = Data(0) >>  8 & 0xff;
+	prec    = Data(0)       & 0xff;
+	if (prec & 0x80) prec|=0xffffff00;
+	delay   = Data(1);
+	disp    = Data(2);
+	refid   = Data(3);
+	reftime.coarse = Data(4);
+	reftime.fine   = Data(5);
+	orgtime.coarse = Data(6);
+	orgtime.fine   = Data(7);
+	rectime.coarse = Data(8);
+	rectime.fine   = Data(9);
+	xmttime.coarse = Data(10);
+	xmttime.fine   = Data(11);
+#undef Data
+
+	if (debug) {
+	printf("LI=%d  VN=%d  Mode=%d  Stratum=%d  Poll=%d  Precision=%d\n",
+		li, vn, mode, stratum, poll, prec);
+	printf("Delay=%.1f  Dispersion=%.1f  Refid=%u.%u.%u.%u\n",
+		sec2u(delay),sec2u(disp),
+		refid>>24&0xff, refid>>16&0xff, refid>>8&0xff, refid&0xff);
+	printf("Reference %u.%.6u\n", reftime.coarse, USEC(reftime.fine));
+	printf("(sent)    %u.%.6u\n", ntpc->time_of_send[0], USEC(ntpc->time_of_send[1]));
+	printf("Originate %u.%.6u\n", orgtime.coarse, USEC(orgtime.fine));
+	printf("Receive   %u.%.6u\n", rectime.coarse, USEC(rectime.fine));
+	printf("Transmit  %u.%.6u\n", xmttime.coarse, USEC(xmttime.fine));
+	printf("Our recv  %u.%.6u\n", arrival->coarse, USEC(arrival->fine));
+	}
+	el_time=ntpdiff(&orgtime,arrival);   /* elapsed */
+	st_time=ntpdiff(&rectime,&xmttime);  /* stall */
+	skew1=ntpdiff(&orgtime,&rectime);
+	skew2=ntpdiff(&xmttime,arrival);
+	freq=get_current_freq();
+	if (debug) {
+	printf("Total elapsed: %9.2f\n"
+	       "Server stall:  %9.2f\n"
+	       "Slop:          %9.2f\n",
+		el_time, st_time, el_time-st_time);
+	printf("Skew:          %9.2f\n"
+	       "Frequency:     %9d\n"
+	       " day   second     elapsed    stall     skew  dispersion  freq\n",
+		(skew1-skew2)/2, freq);
+	}
+
+	/* error checking, see RFC-4330 section 5 */
+#ifdef ENABLE_DEBUG
+#define FAIL(x) do { drop_reason=(x); goto fail;} while (0)
+#else
+#define FAIL(x) goto fail;
+#endif
+	if (ntpc->cross_check) {
+		if (li == 3) FAIL("LI==3");  /* unsynchronized */
+		if (vn < 3) FAIL("VN<3");   /* RFC-4330 documents SNTP v4, but we interoperate with NTP v3 */
+		if (mode != 4) FAIL("MODE!=3");
+		if (orgtime.coarse != ntpc->time_of_send[0] ||
+		    orgtime.fine   != ntpc->time_of_send[1] ) FAIL("ORG!=sent");
+		if (xmttime.coarse == 0 && xmttime.fine == 0) FAIL("XMT==0");
+		if (delay > 65536 || delay < -65536) FAIL("abs(DELAY)>65536");
+		if (disp  > 65536 || disp  < -65536) FAIL("abs(DISP)>65536");
+		if (stratum == 0) FAIL("STRATUM==0");  /* kiss o' death */
+#undef FAIL
+	}
+
+	/* XXX should I do this if debug flag is set? */
+	if (ntpc->set_clock) { /* you'd better be root, or ntpclient will exit here! */
+		set_time(&xmttime);
+	}
+
+	/* Not the ideal order for printing, but we want to be sure
+	 * to do all the time-sensitive thinking (and time setting)
+	 * before we start the output, especially fflush() (which
+	 * could be slow).  Of course, if debug is turned on, speed
+	 * has gone down the drain anyway. */
+	if (ntpc->live) {
+		int new_freq;
+		new_freq = contemplate_data(arrival->coarse, (skew1-skew2)/2,
+			el_time+sec2u(disp), freq);
+		if (!debug && new_freq != freq) set_freq(new_freq);
+	}
+
+    if (ntp_time) {
+        ntp_time->day = arrival->coarse/86400;
+        ntp_time->sec = arrival->coarse%86400;
+    }else {
+	    printf("%d %.5d.%.3d  %8.1f %8.1f  %8.1f %8.1f %9d\n",
+		    arrival->coarse/86400, arrival->coarse%86400,
+		    arrival->fine/4294967, el_time, st_time,
+		    (skew1-skew2)/2, sec2u(disp), freq);
+	    fflush(stdout);
+    }
+	*error = el_time-st_time;
+
+	return 0;
+fail:
+#ifdef ENABLE_DEBUG
+	printf("%d %.5d.%.3d  rejected packet: %s\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967, drop_reason);
+#else
+	printf("%d %.5d.%.3d  rejected packet\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967);
+#endif
+	return 1;
+}
+
+static void stuff_net_addr(struct in_addr *p, char *hostname)
+{
+	struct hostent *ntpserver;
+	ntpserver=gethostbyname(hostname);
+	if (ntpserver == NULL) {
+		herror(hostname);
+		return;
+	}
+	if (ntpserver->h_length != 4) {
+		/* IPv4 only, until I get a chance to test IPv6 */
+		fprintf(stderr,"oops %d\n",ntpserver->h_length);
+        return;
+	}
+	memcpy(&(p->s_addr),ntpserver->h_addr_list[0],4);
+}
+
+static void setup_receive(int usd, unsigned int interface, short port)
+{
+	struct sockaddr_in sa_rcvr;
+	memset(&sa_rcvr,0,sizeof sa_rcvr);
+	sa_rcvr.sin_family=AF_INET;
+	sa_rcvr.sin_addr.s_addr=htonl(interface);
+	sa_rcvr.sin_port=htons(port);
+	if(bind(usd,(struct sockaddr *) &sa_rcvr,sizeof sa_rcvr) == -1) {
+		perror("bind");
+		fprintf(stderr,"could not bind to udp port %d\n",port);
+        return;
+	}
+	/* listen(usd,3); this isn't TCP; thanks Alexander! */
+}
+
+static void setup_transmit(int usd, char *host, short port, struct ntp_control *ntpc)
+{
+	struct sockaddr_in sa_dest;
+	memset(&sa_dest,0,sizeof sa_dest);
+	sa_dest.sin_family=AF_INET;
+	stuff_net_addr(&(sa_dest.sin_addr),host);
+	memcpy(ntpc->serv_addr,&(sa_dest.sin_addr),4); /* XXX asumes IPv4 */
+	sa_dest.sin_port=htons(port);
+	if (connect(usd,(struct sockaddr *)&sa_dest,sizeof sa_dest)==-1)
+		{perror("connect");return;}
+}
+
+static void primary_loop(int usd, struct ntp_control *ntpc, struct ntp_time_t* ntp_time)
+{
+	fd_set fds;
+	struct sockaddr sa_xmit;
+	int i, pack_len, probes_sent, error;
+	socklen_t sa_xmit_len;
+	struct timeval to;
+	struct ntptime udp_arrival_ntp;
+	static u32 incoming_word[325];
+#define incoming ((char *) incoming_word)
+#define sizeof_incoming (sizeof incoming_word)
+
+	if (debug) printf("Listening...\n");
+
+	probes_sent=0;
+	sa_xmit_len=sizeof sa_xmit;
+	to.tv_sec=0;
+	to.tv_usec=0;
+	for (;;) {
+		FD_ZERO(&fds);
+		FD_SET(usd,&fds);
+		i=select(usd+1,&fds,NULL,NULL,&to);  /* Wait on read or error */
+		if ((i!=1)||(!FD_ISSET(usd,&fds))) {
+			if (i<0) {
+				if (errno != EINTR) perror("select");
+				continue;
+			}
+			if (to.tv_sec == 0) {
+				if (probes_sent >= ntpc->probe_count &&
+					ntpc->probe_count != 0) break;
+				send_packet(usd,ntpc->time_of_send);
+				++probes_sent;
+				to.tv_sec=ntpc->cycle_time;
+				to.tv_usec=0;
+			}
+			continue;
+		}
+		pack_len=recvfrom(usd,incoming,sizeof_incoming,0,
+		                  &sa_xmit,&sa_xmit_len);
+		error = ntpc->goodness;
+		if (pack_len<0) {
+			perror("recvfrom");
+		} else if (pack_len>0 && (unsigned)pack_len<sizeof_incoming){
+			get_packet_timestamp(usd, &udp_arrival_ntp);
+			if (check_source(pack_len, &sa_xmit, sa_xmit_len, ntpc)!=0) continue;
+			if (rfc1305print(incoming_word, &udp_arrival_ntp, ntpc, &error, ntp_time)!=0) continue;
+			/* udp_handle(usd,incoming,pack_len,&sa_xmit,sa_xmit_len); */
+		} else {
+			printf("Ooops.  pack_len=%d\n",pack_len);
+			fflush(stdout);
+		}
+		/* best rollover option: specify -g, -s, and -l.
+		 * simpler rollover option: specify -s and -l, which
+		 * triggers a magic -c 1 */
+		if ((error < ntpc->goodness && ntpc->goodness != 0) ||
+		    (probes_sent >= ntpc->probe_count && ntpc->probe_count != 0)) {
+			ntpc->set_clock = 0;
+			if (!ntpc->live) break;
+		}
+	}
+#undef incoming
+#undef sizeof_incoming
+}
+
+#ifdef ENABLE_REPLAY
+static void do_replay(void)
+{
+	char line[100];
+	int n, day, freq, absolute;
+	float sec, el_time, st_time, disp;
+	double skew, errorbar;
+	int simulated_freq = 0;
+	unsigned int last_fake_time = 0;
+	double fake_delta_time = 0.0;
+
+	while (fgets(line,sizeof line,stdin)) {
+		n=sscanf(line,"%d %f %f %f %lf %f %d",
+			&day, &sec, &el_time, &st_time, &skew, &disp, &freq);
+		if (n==7) {
+			fputs(line,stdout);
+			absolute=day*86400+(int)sec;
+			errorbar=el_time+disp;
+			if (debug) printf("contemplate %u %.1f %.1f %d\n",
+				absolute,skew,errorbar,freq);
+			if (last_fake_time==0) simulated_freq=freq;
+			fake_delta_time += (absolute-last_fake_time)*((double)(freq-simulated_freq))/65536;
+			if (debug) printf("fake %f %d \n", fake_delta_time, simulated_freq);
+			skew += fake_delta_time;
+			freq = simulated_freq;
+			last_fake_time = absolute;
+			simulated_freq = contemplate_data(absolute, skew, errorbar, freq);
+		} else {
+			fprintf(stderr,"Replay input error\n");
+            return;
+		}
+	}
+}
+#endif
+
+static void usage(char *argv0)
+{
+	fprintf(stderr,
+	"Usage: %s [-c count]"
+#ifdef ENABLE_DEBUG
+	" [-d]"
+#endif
+	" [-f frequency] [-g goodness] -h hostname\n"
+	"\t[-i interval] [-l] [-p port] [-q min_delay]"
+#ifdef ENABLE_REPLAY
+	" [-r]"
+#endif
+	" [-s] [-t]\n",
+	argv0);
+}
+
+#ifdef LIBNTP 
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time) {
+    if (!host || !ntp_time) return -1;
+    int argc = 4;
+    char* argv[] = {
+        "ntp_get_time",
+        "-h time.apple.com",
+        "-i 1",
+        "-c 1"
+    };
+#else
+int main(int argc, char *argv[]) {
+    struct ntp_time_t* ntp_time = NULL;
+#endif
+	int usd;  /* socket */
+	int c;
+	/* These parameters are settable from the command line
+	   the initializations here provide default behavior */
+	short int udp_local_port=0;   /* default of 0 means kernel chooses */
+	char *hostname=NULL;          /* must be set */
+	int initial_freq;             /* initial freq value to use */
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=0;           /* default of 0 means loop forever */
+	ntpc.cycle_time=600;          /* seconds */
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
+
+	for (;;) {
+		c = getopt( argc, argv, "c:" DEBUG_OPTION "f:g:h:i:lp:q:" REPLAY_OPTION "st");
+		if (c == EOF) break;
+		switch (c) {
+			case 'c':
+				ntpc.probe_count = atoi(optarg);
+				break;
+#ifdef ENABLE_DEBUG
+			case 'd':
+				++debug;
+				break;
+#endif
+			case 'f':
+				initial_freq = atoi(optarg);
+				if (debug) printf("initial frequency %d\n",
+						initial_freq);
+				set_freq(initial_freq);
+				break;
+			case 'g':
+				ntpc.goodness = atoi(optarg);
+				break;
+			case 'h':
+				hostname = optarg;
+				break;
+			case 'i':
+				ntpc.cycle_time = atoi(optarg);
+				break;
+			case 'l':
+				(ntpc.live)++;
+				break;
+			case 'p':
+				udp_local_port = atoi(optarg);
+				break;
+			case 'q':
+				min_delay = atof(optarg);
+				break;
+#ifdef ENABLE_REPLAY
+			case 'r':
+				do_replay();
+                return -1;
+				break;
+#endif
+			case 's':
+				(ntpc.set_clock)++;
+				break;
+
+			case 't':
+				(ntpc.cross_check)=0;
+				break;
+
+			default:
+				usage(argv[0]);
+                return -1;
+		}
+	}
+	if (hostname == NULL) {
+		usage(argv[0]);
+        return -1;
+	}
+
+	if (ntpc.set_clock && !ntpc.live && !ntpc.goodness && !ntpc.probe_count) {
+		ntpc.probe_count = 1;
+	}
+
+	/* respect only applicable MUST of RFC-4330 */
+	if (ntpc.probe_count != 1 && ntpc.cycle_time < MIN_INTERVAL) {
+		ntpc.cycle_time = MIN_INTERVAL;
+	}
+
+	if (debug) {
+		printf("Configuration:\n"
+		"  -c probe_count %d\n"
+		"  -d (debug)     %d\n"
+		"  -g goodness    %d\n"
+		"  -h hostname    %s\n"
+		"  -i interval    %d\n"
+		"  -l live        %d\n"
+		"  -p local_port  %d\n"
+		"  -q min_delay   %f\n"
+		"  -s set_clock   %d\n"
+		"  -x cross_check %d\n",
+		ntpc.probe_count, debug, ntpc.goodness,
+		hostname, ntpc.cycle_time, ntpc.live, udp_local_port, min_delay,
+		ntpc.set_clock, ntpc.cross_check );
+	}
+
+	/* Startup sequence */
+	if ((usd=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==-1) {
+        perror ("socket");
+        return -1;
+    }
+
+	setup_receive(usd, INADDR_ANY, udp_local_port);
+
+	setup_transmit(usd, hostname, NTP_PORT, &ntpc);
+
+	primary_loop(usd, &ntpc, ntp_time);
+
+	close(usd);
+	return 0;
+}
diff --git a/net/mmt/ntp/ntpclient.h b/net/mmt/ntp/ntpclient.h
new file mode 100644
index 0000000..c6aa46e
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.h
@@ -0,0 +1,18 @@
+#ifndef NET_MMT_NTP_NTPCLIENT_H_
+#define NET_MMT_NTP_NTPCLIENT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ntp_time_t {
+    int day;
+    float sec;
+};
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/net/mmt/ntp/phaselock.c b/net/mmt/ntp/phaselock.c
new file mode 100644
index 0000000..d1ab598
--- /dev/null
+++ b/net/mmt/ntp/phaselock.c
@@ -0,0 +1,339 @@
+/*
+ * phaselock.c - Phase locking for NTP client
+ *
+ * Copyright (C) 2000, 2007  Larry Doolittle  <larry@doolittle.boa.org>
+ * Last hack: 30 December, 2007
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Subtract configurable amount from errorbar
+ *      - Build in general run-time access to tune parameters
+ *      - Sculpt code so it's legible, this version is out of control
+ *      - Write documentation  :-(
+ */
+
+#include <stdio.h>
+#include "ntpclient.h"
+
+/* when present, debug is a true global */
+#ifdef ENABLE_DEBUG
+extern int debug;
+#else
+#define debug 0
+#endif
+
+double min_delay = 800.0;  /* global, user-changeable, units are microseconds */
+
+#define RING_SIZE 16
+#define MAX_CORRECT 250   /* ppm change to system clock */
+#define MAX_C ((MAX_CORRECT)*65536)
+static struct datum {
+	unsigned int absolute;
+	double skew;
+	double errorbar;
+	int freq;
+	/* s.s.min and s.s.max (skews) are "corrected" to what they would
+	 * have been if freq had been constant at its current value during
+	 * the measurements.
+	 */
+	union {
+		struct { double min; double max; } s;
+		double ss[2];
+	} s;
+	/*
+	double smin;
+	double smax;
+	 */
+} d_ring[RING_SIZE];
+
+static struct _seg {
+	double slope;
+	double offset;
+} maxseg[RING_SIZE+1], minseg[RING_SIZE+1];
+
+#if 0
+/* draw a line from a to c, what the offset is of that line
+ * where that line matches b's slope coordinate.
+ */
+static double interpolate(struct _seg *a, struct _seg *b, struct _seg *c)
+{
+	double x, y;
+	x = (b->slope - a->slope) / (c->slope  - a->slope) ;
+	y =         a->offset + x * (c->offset - a->offset);
+	return y;
+}
+#endif
+
+static int next_up(int i) { int r = i+1; if (r>=RING_SIZE) r=0; return r;}
+static int next_dn(int i) { int r = i-1; if (r<0) r=RING_SIZE-1; return r;}
+
+/* Looks at the line segments that start at point j, that end at
+ * all following points (ending at index rp).  The initial point
+ * is on curve s0, the ending point is on curve s1.  The curve choice
+ * (s.min vs. s.max) is based on the index in ss[].  The scan
+ * looks for the largest (sign=0) or smallest (sign=1) slope.
+ */
+static int search(int rp, int j, int s0, int s1, int sign, struct _seg *answer)
+{
+	double dt, slope;
+	int n, nextj=0, cinit=1;
+	for (n=next_up(j); n!=next_up(rp); n=next_up(n)) {
+		if (0 && debug) printf("d_ring[%d].s.ss[%d]=%f d_ring[%d].s.ss[%d]=%f\n",
+			n, s0, d_ring[n].s.ss[s0], j, s1, d_ring[j].s.ss[s1]);
+		dt = d_ring[n].absolute - d_ring[j].absolute;
+		slope = (d_ring[n].s.ss[s0] - d_ring[j].s.ss[s1]) / dt;
+		if (0 && debug) printf("slope %d%d%d [%d,%d] = %f\n",
+			s0, s1, sign, j, n, slope);
+		if (cinit || (slope < answer->slope) ^ sign) {
+			answer->slope = slope;
+			answer->offset = d_ring[n].s.ss[s0] +
+				slope*(d_ring[rp].absolute - d_ring[n].absolute);
+			cinit = 0;
+			nextj = n;
+		}
+	}
+	return nextj;
+}
+
+/* Pseudo-class for finding consistent frequency shift */
+#define MIN_INIT 20
+static struct _polygon {
+	double l_min;
+	double r_min;
+} df;
+
+static void polygon_reset(void)
+{
+	df.l_min = MIN_INIT;
+	df.r_min = MIN_INIT;
+}
+
+static double find_df(int *flag)
+{
+	if (df.l_min == 0.0) {
+		if (df.r_min == 0.0) {
+			return 0.0;   /* every point was OK */
+		} else {
+			return -df.r_min;
+		}
+	} else {
+		if (df.r_min == 0.0) {
+			return df.l_min;
+		} else {
+			if (flag) *flag=1;
+			return 0.0;   /* some points on each side,
+			               * or no data at all */
+		}
+	}
+}
+
+/* Finds the amount of delta-f required to move a point onto a
+ * target line in delta-f/delta-t phase space.  Any line is OK
+ * as long as it's not convex and never returns greater than
+ * MIN_INIT. */
+static double find_shift(double slope, double offset)
+{
+	double shift  = slope - offset/600.0;
+	double shift2 = slope + 0.3 - offset/6000.0;
+	if (shift2 < shift) shift = shift2;
+	if (debug) printf("find_shift %f %f -> %f\n", slope, offset, shift);
+	if (shift  < 0) return 0.0;
+	return shift;
+}
+
+static void polygon_point(struct _seg *s)
+{
+	double l, r;
+	if (debug) printf("loop %f %f\n", s->slope, s->offset);
+	l = find_shift(- s->slope,   s->offset);
+	r = find_shift(  s->slope, - s->offset);
+	if (l < df.l_min) df.l_min = l;
+	if (r < df.r_min) df.r_min = r;
+	if (debug) printf("constraint left:  %f %f \n", l, df.l_min);
+	if (debug) printf("constraint right: %f %f \n", r, df.r_min);
+}
+
+/* Something like linear feedback to be used when we are "close" to
+ * phase lock.  Not really used at the moment:  the logic in find_df()
+ * never sets the flag. */
+static double find_df_center(struct _seg *min, struct _seg *max, double gross_df)
+{
+	const double crit_time=1000.0;
+	double slope  = 0.5 * (max->slope  + min->slope)+gross_df;
+	double dslope =       (max->slope  - min->slope);
+	double offset = 0.5 * (max->offset + min->offset);
+	double doffset =      (max->offset - min->offset);
+	double delta1 = -offset/ 600.0 - slope;
+	double delta2 = -offset/1800.0 - slope;
+	double delta  = 0.0;
+	double factor = crit_time/(crit_time+doffset+dslope*1200.0);
+	if (offset <  0 && delta2 > 0) delta = delta2;
+	if (offset <  0 && delta1 < 0) delta = delta1;
+	if (offset >= 0 && delta1 > 0) delta = delta1;
+	if (offset >= 0 && delta2 < 0) delta = delta2;
+	if (max->offset < -crit_time || min->offset > crit_time) return 0.0;
+	if (debug) printf("find_df_center %f %f\n", delta, factor);
+	return factor*delta;
+}
+
+int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq)
+{
+	/*  Here is the actual phase lock loop.
+	 *  Need to keep a ring buffer of points to make a rational
+	 *  decision how to proceed.  if (debug) print a lot.
+	 */
+	static int rp=0, valid=0;
+	int both_sides_now=0;
+	int j, n, c, max_avail, min_avail, dinit;
+	int nextj=0;	/* initialization not needed; but gcc can't figure out my logic */
+	double cum;
+	struct _seg check, save_min, save_max;
+	double last_slope;
+	int delta_freq;
+	double delta_f;
+	int inconsistent=0, max_imax, max_imin=0, min_imax, min_imin=0;
+	int computed_freq=freq;
+
+	if (debug) printf("xontemplate %u %.1f %.1f %d\n",absolute,skew,errorbar,freq);
+	d_ring[rp].absolute = absolute;
+	d_ring[rp].skew     = skew;
+	d_ring[rp].errorbar = errorbar - min_delay;   /* quick hack to speed things up */
+	d_ring[rp].freq     = freq;
+
+	if (valid<RING_SIZE) ++valid;
+	if (valid==RING_SIZE) {
+		/*
+		 * Pass 1: correct for wandering freq's */
+		cum = 0.0;
+		if (debug) printf("\n");
+		for (j=rp; ; j=n) {
+			d_ring[j].s.s.max = d_ring[j].skew - cum + d_ring[j].errorbar;
+			d_ring[j].s.s.min = d_ring[j].skew - cum - d_ring[j].errorbar;
+			if (debug) printf("hist %d %d %f %f %f\n",j,d_ring[j].absolute-absolute,
+				cum,d_ring[j].s.s.min,d_ring[j].s.s.max);
+			n=next_dn(j);
+			if (n == rp) break;
+			/* Assume the freq change took place immediately after
+			 * the data was taken; this is valid for the case where
+			 * this program was responsible for the change.
+			 */
+			cum = cum + (d_ring[j].absolute-d_ring[n].absolute) *
+				(double)(d_ring[j].freq-freq)/65536;
+		}
+		/*
+		 * Pass 2: find the convex down envelope of s.max, composed of
+		 * line segments in s.max vs. absolute space, which are
+		 * points in freq vs. dt space.  Find points in order of increasing
+		 * slope == freq */
+		dinit=1; last_slope=-2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 1, 1, 0, &maxseg[c]);
+			        search(rp, j, 0, 1, 1, &check);
+			if (check.slope < maxseg[c].slope && check.slope > last_slope &&
+			    (dinit || check.slope < save_min.slope)) {dinit=0; save_min=check; }
+			if (debug) printf("maxseg[%d] = %f *x+ %f\n",
+				 c, maxseg[c].slope, maxseg[c].offset);
+			last_slope = maxseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("mincross %f *x+ %f\n", save_min.slope, save_min.offset);
+		max_avail=c;
+		/*
+		 * Pass 3: find the convex up envelope of s.min, composed of
+		 * line segments in s.min vs. absolute space, which are
+		 * points in freq vs. dt space.  These points are found in
+		 * order of decreasing slope. */
+		dinit=1; last_slope=+2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 0, 0, 1, &minseg[c]);
+			        search(rp, j, 1, 0, 0, &check);
+			if (check.slope > minseg[c].slope && check.slope < last_slope &&
+			    (dinit || check.slope < save_max.slope)) {dinit=0; save_max=check; }
+			if (debug) printf("minseg[%d] = %f *x+ %f\n",
+				 c, minseg[c].slope, minseg[c].offset);
+			last_slope = minseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("maxcross %f *x+ %f\n", save_max.slope, save_max.offset);
+		min_avail=c;
+		/*
+		 * Pass 4: splice together the convex polygon that forms
+		 * the envelope of slope/offset coordinates that are consistent
+		 * with the observed data.  The order of calls to polygon_point
+		 * doesn't matter for the frequency shift determination, but
+		 * the order chosen is nice for visual display. */
+		if (!inconsistent) {
+		polygon_reset();
+		polygon_point(&save_min);
+		for (dinit=1, c=1; c<max_avail; c++) {
+			if (dinit && maxseg[c].slope > save_min.slope) {
+				max_imin = c-1;
+				maxseg[max_imin] = save_min;
+				dinit = 0;
+			}
+			if (maxseg[c].slope > save_max.slope)
+				break;
+			if (dinit==0) polygon_point(&maxseg[c]);
+		}
+		if (dinit && debug) printf("found maxseg vs. save_min inconsistency\n");
+		if (dinit) inconsistent=1;
+		max_imax = c;
+		maxseg[max_imax] = save_max;
+
+		polygon_point(&save_max);
+		for (dinit=1, c=1; c<min_avail; c++) {
+			if (dinit && minseg[c].slope < save_max.slope) {
+				max_imin = c-1;
+				minseg[min_imin] = save_max;
+				dinit = 0;
+			}
+			if (minseg[c].slope < save_min.slope)
+				break;
+			if (dinit==0) polygon_point(&minseg[c]);
+		}
+		if (dinit && debug) printf("found minseg vs. save_max inconsistency\n");
+		if (dinit) inconsistent=1;
+		min_imax = c;
+		minseg[min_imax] = save_max;
+
+		/* not needed for analysis, but shouldn't hurt either */
+		if (debug) polygon_point(&save_min);
+		} /* !inconsistent */
+
+		/*
+		 * Pass 5: decide on a new freq */
+		if (inconsistent) {
+			printf("# inconsistent\n");
+		} else {
+			delta_f = find_df(&both_sides_now);
+			if (debug) printf("find_df() = %e\n", delta_f);
+			delta_f += find_df_center(&save_min,&save_max, delta_f);
+			delta_freq = delta_f*65536+.5;
+			if (debug) printf("delta_f %f  delta_freq %d  bsn %d\n", delta_f, delta_freq, both_sides_now);
+			computed_freq -= delta_freq;
+			printf ("# box [( %.3f , %.1f ) ",  save_min.slope, save_min.offset);
+			printf (      " ( %.3f , %.1f )] ", save_max.slope, save_max.offset);
+			printf (" delta_f %.3f  computed_freq %d\n", delta_f, computed_freq);
+
+			if (computed_freq < -MAX_C) computed_freq=-MAX_C;
+			if (computed_freq >  MAX_C) computed_freq= MAX_C;
+		}
+	}
+	rp = (rp+1)%RING_SIZE;
+	return computed_freq;
+}
diff --git a/net/net.gyp b/net/net.gyp
index ceb82ee..25d6654 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -102,6 +102,7 @@
         'net_derived_sources',
         'net_resources',
         '../net/mmt/mpu/mpu.gyp:libmpu',
+        '../net/mmt/ntp/ntp.gyp:libntp',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
-- 
1.7.9.5


From c486788156a04b1b23b837ec5647901f479f7f6d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 22:10:26 -0800
Subject: [PATCH 68/92] [ok] for current mmt

---
 net/mmt/mmt_control.cc                 |   29 ++++++++++++++++++++++------
 net/mmt/mmt_control.h                  |    4 ++++
 net/mmt/mmt_stream.cc                  |    5 ++++-
 net/mmt/mmt_stream.h                   |    6 +++++-
 net/mmt/mpu/moof_combine.sh            |    4 ++--
 net/url_request/url_request_mmt_job.cc |   33 +++++++++++++++++++++++++-------
 net/url_request/url_request_mmt_job.h  |    1 +
 7 files changed, 65 insertions(+), 17 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index acb27d4..91be573 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -33,11 +33,11 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     PostCtrlMsg(msg);
 }
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid) {
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.url = gurl;
-    msg.ptr = refptr;
+    msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
@@ -69,15 +69,22 @@ ctrl_msg_t::ctrl_msg_t() {
     sinfo.size = 0;
     sinfo.offset = 0;
     sinfo.func = nullptr;
+    sinfo.postui = nullptr;
 }
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
 cixml_t::cixml_t() {
     status = "initing";
+    parser = nullptr;
+    job = nullptr;
+    postui = nullptr;
 }
 cixml_t::~cixml_t() {
+    status = "uniniting";
     parser = nullptr;
+    job = nullptr;
+    postui = nullptr;
 }
 
 /**
@@ -132,12 +139,18 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         }
     }
 
+    // save information of current table
     if (msg.tabid > 0) {
+        cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
-            cixmlptr_t cixml = new cixml_t;
+            cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
+        }else {
+            cixml = cixmls_[msg.tabid];
         }
+        cixml->job = msg.ptr;
+        cixml->postui = msg.sinfo.postui;
     }
 }
 void MmtControl::StreamClose(ctrl_msg_t msg) {
@@ -159,7 +172,7 @@ void GetJsonData(int tabid, std::string js, std::string& json) {
 }
 void MmtControl::CheckEvent() {
     // TODO for testing
-    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    std::string xml = "mmt://localhost/tmp/ci.xml";
 
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
@@ -185,14 +198,18 @@ void MmtControl::CheckEvent() {
             next_status = "loaded";
             Wait(1000);
         }else if (cixml->status == "loaded") {
-            if (parser) {
+            if (parser && cixml->postui) {
                 std::string js;
                 long ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
+#if 0
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
+#else
+                    cixml->postui(cixml->job, "@js", js);
+#endif
                 }
             }
             //next_status = "end";
@@ -205,7 +222,7 @@ void MmtControl::CheckEvent() {
  * UnitTest for class CiParser
  */
 void TestXmlParser() {
-    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    std::string xml = "mmt://localhost/tmp/ci.xml";
     CiParserPtr parser = new CiParser(xml);
     parser->ParseXml();
     parser->ParseHtmlTag();
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 6b9d6ae..aa11a6c 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -27,6 +27,7 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
  *  three parameters: (job object, stream_info_t, errno)
  */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+typedef void (*postui_func_t) (job_refptr_t, const std::string, const std::string&);
 
 /**
  * Stream IO Information
@@ -36,6 +37,7 @@ struct stream_info_t {
     int             size;
     int             offset;
     stream_func_t   func;
+    postui_func_t   postui;
 };
 
 /**
@@ -62,6 +64,8 @@ public:
     cixml_t();
     std::string status;
     CiParserPtr parser;
+    job_refptr_t job;
+    postui_func_t postui;
 
 protected:
     friend class base::RefCounted<cixml_t>;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e9aa6a7..2d0440f 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -9,7 +9,10 @@ content_t::content_t() {
     frame_id = 0;
     routing_id = 0;
     tab_id = 0;
-    tab_url = "";
+    //tab_url = "";
+    
+    head = "";
+    body = "";
 }
 content_t::~content_t() {
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index cb78227..32712d3 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -35,7 +35,11 @@ struct content_t {
     int frame_id;   //> render frame id
     int routing_id; //> render host routing id 
     int tab_id;     //> chrome's tab id
-    std::string tab_url;    //> chrome's tab url
+    GURL tab_url;   //> chrome's tab url
+
+    // for extra message
+    std::string head;
+    std::string body;
 };
 
 } // namespace mmt
diff --git a/net/mmt/mpu/moof_combine.sh b/net/mmt/mpu/moof_combine.sh
index 5b6cf0e..78d964b 100644
--- a/net/mmt/mpu/moof_combine.sh
+++ b/net/mmt/mpu/moof_combine.sh
@@ -2,8 +2,8 @@
 rm -rf audio
 mkdir -p audio
 
-apath="/home/yongzxu/Downloads/MPUFile/"
-apath="/home/yongzxu/Videos/mmt/loveapartment_0203/audio"
+apath="$HOME/Downloads/MPUFile/"
+apath="$HOME/Videos/mmt/loveapartment_0203/audio"
 name="loveapartment_Audio1_MPU"
 offset=1037
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4e10c38..230ecff 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -88,6 +88,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
+  sinfo.postui = &URLRequestMmtJob::DoPostUI;
 
   // return ERR_IO_PENDING if aysnc read
   int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this, content_.tab_id);
@@ -299,7 +300,7 @@ bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserCon
 void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
     if (!content) return;
     content->tab_id = -1;
-    content->tab_url = "";
+    //content->tab_url = "";
 
     content::RenderFrameHost* rfh = 
         content::RenderFrameHost::FromID(content->process_id, content->frame_id);
@@ -318,16 +319,34 @@ void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_stor
         LOG(INFO) << __func__ << " web_contents is nullptr";
         return;
     }
+
     content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-    std::ostringstream sstr;
-    sstr << web_contents->GetURL();
-    content->tab_url = sstr.str();
-    LOG(INFO) << __func__ 
-        << " tab id=" << content->tab_id
-        << ", tab url=" << content->tab_url;
+    content->tab_url = web_contents->GetURL();
+    content::RenderFrameHost* main_frame = web_contents->GetMainFrame();
+    LOG(INFO) << __func__  
+        << " main_frame=" << main_frame << ", head=" << content->head
+        << " tab id=" << content->tab_id << ", tab url=" << content->tab_url;
+    if (main_frame) {
+        if(content->head == "@js" && !content->body.empty()) { // for js
+            main_frame->ExecuteJavaScript(base::ASCIIToUTF16(content->body.c_str()));
+        }
+    }
+
+    // for extension and chrome.storage
     if (has_storage) {
         GetExtension(content, web_contents->GetBrowserContext());
     }
 }
 
+void URLRequestMmtJob::DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body) {
+    LOG(INFO) << __func__;
+    scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
+    if (thiz) {
+        thiz->content_.head = head;
+        thiz->content_.body = body;
+        content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+            base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &thiz->content_, false));
+    }
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index dd34d13..ece9f1e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -79,6 +79,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
   static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
   static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
+  static void DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body);
 
  private:
   const scoped_refptr<base::TaskRunner> task_runner_;
-- 
1.7.9.5


From dc13475f1413a65318fc8df178e65b6ad13f077a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 06:16:41 -0800
Subject: [PATCH 69/92] [ok] refine docs for mmt_control

---
 net/mmt/mmt_control.cc |  153 ++++++++++++++++++++++++++++--------------------
 net/mmt/mmt_control.h  |   64 +++++++++++++-------
 2 files changed, 131 insertions(+), 86 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 91be573..95d2e56 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -3,6 +3,10 @@
 
 namespace mmt {
 
+static const int kMmtLoopInterval = 100; // ms
+static const int kMmtReadInterval = 10; // ms
+static const char kMmtDefaultXml[] = "mmt://localhost/tmp/ci.xml";
+
 static MmtControl *g_ctrl = nullptr;
 
 void StartMmtCtrl() {
@@ -17,13 +21,11 @@ void StartMmtCtrl() {
     LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
 }
 
-void PostCtrlMsg(ctrl_msg_t &msg) {
+static void PostCtrlMsg(ctrl_msg_t &msg) {
     if (!g_ctrl) return;
     g_ctrl->Push(msg);
 }
 
-
-// for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -32,7 +34,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
-// for @close
+
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -41,7 +43,7 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
-// for @open and @read
+
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -50,7 +52,47 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
     msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
-    return -1; //> default IO_PENDING(-1) and Async Read
+    return -1; 
+}
+
+/**
+ * UnitTest for class CiParser
+ */
+void TestXmlParser() {
+    std::string xml = kMmtDefaultXml;
+    CiParserPtr parser = new CiParser(xml);
+    parser->ParseXml();
+    parser->ParseHtmlTag();
+    std::string js;
+    parser->GetHtmlJS(0, js);
+    LOG(INFO) << __func__ << " js1: " << js;
+    parser->GetHtmlJS(1080, js);
+    LOG(INFO) << __func__ << " js2: " << js;
+    parser->GetHtmlJS(1086, js);
+    LOG(INFO) << __func__ << " js3: " << js;
+}
+
+/**
+ * To generate json data for mmt native message
+ */
+void GetJsonData(int tabid, std::string js, std::string& json) {
+    json += "{";
+    json += "\"tabid\" : " + Int2String(tabid);
+    json += ", ";
+    json += "\"js\" : \"" + js + "\"";
+    json += "}";
+}
+
+/**
+ * The algorithm to generate unique key for UrlRequestMmtJob
+ */
+static std::string mmtjob_key(GURL url, void* ptr) {
+    std::string name = url.spec();
+    std::stringstream sstr;
+    sstr << name << "@" << ptr;
+    std::string key;
+    sstr >> key;
+    return key;
 }
 
 } // namespace mmt
@@ -59,50 +101,52 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
 /// for class MmtControl
 namespace mmt {
 
+stream_info_t::stream_info_t() {
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func = nullptr;
+    postui = nullptr;
+}
+stream_info_t::~stream_info_t() {
+    buf = nullptr;
+    func = nullptr;
+    postui = nullptr;
+}
+
 ctrl_msg_t::ctrl_msg_t() {
     head = "";
     body = "";
     tabid = -1;
     ptr = nullptr;
-
-    sinfo.buf = nullptr;
-    sinfo.size = 0;
-    sinfo.offset = 0;
-    sinfo.func = nullptr;
-    sinfo.postui = nullptr;
 }
 ctrl_msg_t::~ctrl_msg_t() {
+    ptr = nullptr;
 }
 
 cixml_t::cixml_t() {
+    fname = "";
     status = "initing";
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
 }
 cixml_t::~cixml_t() {
-    status = "uniniting";
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
 }
 
-/**
- * The algorithm to generate unique key for UrlRequestJob
- */
-static std::string mmtjob_key(GURL url, void* ptr) {
-    std::string name = url.spec();
-    std::stringstream sstr;
-    sstr << name << "@" << ptr;
-    std::string key;
-    sstr >> key;
-    return key;
-}
 
 MmtControl::MmtControl() : SimpleThread("mmt_control"){
     running_ = false;
 }
-MmtControl::~MmtControl() {}
+MmtControl::~MmtControl() {
+    loop_ = false;
+    queue_.clear();
+    cixmls_.clear();
+    streams_.clear();
+}
 
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -139,17 +183,21 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         }
     }
 
-    // save information of current table
+    // save information of current tab of chrome
     if (msg.tabid > 0) {
         cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
             cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
+            // TODO ci xml for testing
+            cixml->fname = kMmtDefaultXml;
         }else {
             cixml = cixmls_[msg.tabid];
         }
-        cixml->job = msg.ptr;
+
+        // do it repeatly to avoid changes of UrlRequestMmtJob
+        cixml->job = msg.ptr; 
         cixml->postui = msg.sinfo.postui;
     }
 }
@@ -163,30 +211,22 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
-void GetJsonData(int tabid, std::string js, std::string& json) {
-    json += "{";
-    json += "\"tabid\" : " + Int2String(tabid);
-    json += ", ";
-    json += "\"js\" : \"" + js + "\"";
-    json += "}";
-}
 void MmtControl::CheckEvent() {
-    // TODO for testing
-    std::string xml = "mmt://localhost/tmp/ci.xml";
-
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
         cixmlptr_t cixml = iter->second;
         if (!cixml) continue;
         if (cixml->status == "end") continue;
+        if (cixml->fname.empty()) continue;
 
-        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        std::string xml_name = cixml->fname;
         std::string next_status = cixml->status;
         CiParserPtr parser = cixml->parser;
 
+        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
         if (cixml->status == "initing") {
             if (!cixml->parser) {
-                cixml->parser = new CiParser(xml);
+                cixml->parser = new CiParser(xml_name);
             }
             next_status = "loading";
             Wait(100);
@@ -202,7 +242,7 @@ void MmtControl::CheckEvent() {
                 std::string js;
                 long ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
-#if 0
+#ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
@@ -218,53 +258,36 @@ void MmtControl::CheckEvent() {
     }
 }
 
-/**
- * UnitTest for class CiParser
- */
-void TestXmlParser() {
-    std::string xml = "mmt://localhost/tmp/ci.xml";
-    CiParserPtr parser = new CiParser(xml);
-    parser->ParseXml();
-    parser->ParseHtmlTag();
-    std::string js;
-    parser->GetHtmlJS(0, js);
-    LOG(INFO) << __func__ << " js1: " << js;
-    parser->GetHtmlJS(1080, js);
-    LOG(INFO) << __func__ << " js2: " << js;
-    parser->GetHtmlJS(1086, js);
-    LOG(INFO) << __func__ << " js3: " << js;
-}
-
-/**
- * Thread Main Loop
- */
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
-    int ms = 100;
+    int ms = kMmtLoopInterval;
     while(loop_) {
+        // check ci event
         CheckEvent();
 
+        // get one msg
         ctrl_msg_t msg;
         if (!Pop(msg)) {
             Wait(ms);
             continue;
         }
 
+        // process msg
         std::string head = msg.head;
         if (head == "@ctrl") {
             SendToHost(msg.body, "127.0.0.1", 54321);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@open") {
             StreamOpen(msg);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@close") {
             StreamClose(msg);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@read") {
             //TODO: if io pending, should re-push this msg again.
             StreamRead(msg);
-            ms = 10;
+            ms = kMmtReadInterval;
         }
         Wait(ms);
     };
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index aa11a6c..67d5c87 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -23,21 +23,28 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
 
 
 /**
- * Stream IO callback function,
+ * Stream IO callback function, which is used to pass data to UrlRequestMmtJob.
  *  three parameters: (job object, stream_info_t, errno)
  */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+
+/**
+ * Post task over UI thread, which is used to execute JS scripts in UrlRequestMmtJob.
+ */
 typedef void (*postui_func_t) (job_refptr_t, const std::string, const std::string&);
 
 /**
  * Stream IO Information
  */
 struct stream_info_t {
-    net::IOBuffer*  buf;
-    int             size;
-    int             offset;
-    stream_func_t   func;
-    postui_func_t   postui;
+    stream_info_t();
+    ~stream_info_t();
+
+    net::IOBuffer*  buf;        // media buffer
+    int             size;       // data size
+    int             offset;     // data offset from the beginning
+    stream_func_t   func;       // stream io callback function
+    postui_func_t   postui;     // post task function
 };
 
 /**
@@ -48,24 +55,26 @@ struct ctrl_msg_t {
     ~ctrl_msg_t();
 
     std::string head;   //> msg tag: @open, @read, @close, @ctrl and etc.
-    std::string body;
+    std::string body;   //> msg body: only valid for @ctrl
+
     GURL url;           //> access url
     int tabid;          //> chrome's tab id
-    job_refptr_t ptr;   //> job object
-
-    stream_info_t sinfo;    //> valid for @open, @read and @close
+    job_refptr_t ptr;   //> job(UrlRequestMmtJob) object
+    stream_info_t sinfo;    //> only valid for @open, @read and @close
 };
 
 /**
- * Structure for CI XML to process ci. 
+ * Structure for CI XML. 
  */
 struct cixml_t : public base::RefCounted<cixml_t> {
 public:
     cixml_t();
-    std::string status;
-    CiParserPtr parser;
-    job_refptr_t job;
-    postui_func_t postui;
+
+    std::string fname;      //> xml file name
+    std::string status;     //> ci status: initing,loading,loaded
+    CiParserPtr parser;     //> xml parser for ci
+    job_refptr_t job;       //> UrlRequestMmtJob object
+    postui_func_t postui;   //> function for execute js script
 
 protected:
     friend class base::RefCounted<cixml_t>;
@@ -81,6 +90,10 @@ class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
     virtual ~MmtControl();
+
+    /**
+     * Thread Main Loop
+     */
     virtual void Run() override;
 
     void Reset();
@@ -100,10 +113,10 @@ protected:
 private:
     bool loop_;
     bool running_;
-    std::vector<ctrl_msg_t> queue_;
-    std::map<int, cixmlptr_t> cixmls_; //> (tabid => cixml_t)
-
     base::Lock lock_;
+
+    std::vector<ctrl_msg_t> queue_;     
+    std::map<int, cixmlptr_t> cixmls_;  //> key/value: tabid => cixml_t
     StreamPtrs_t streams_;
 };
 
@@ -115,11 +128,20 @@ namespace mmt {
 // Start control center
 void StartMmtCtrl();
 
-// for @ctrl
+/**
+ * param head: @ctrl, not be used now
+ */
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
-// for @close
+
+/**
+ * param head: @close
+ */
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
-// for @open and @read
+
+/**
+ * param head: @open or @read
+ * default return IO_PENDING(-1) which means open/read async
+ */
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
 
 } // namespace mmt
-- 
1.7.9.5


From 8c23ebfc55d3c588366d7d4c4c1251d87f5af439 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 06:50:19 -0800
Subject: [PATCH 70/92] [todo] refine for mmt_stream and add some support mp4
 image file

---
 net/mmt/mmt_stream.cc |   65 ++++++++++++++++++++++++++++++++++---------------
 net/mmt/mmt_stream.h  |   25 +++++++++++++------
 2 files changed, 64 insertions(+), 26 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 2d0440f..caaa964 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,24 +4,26 @@
 
 namespace mmt {
 
+static const char kMmtMediaAudio[] = "audio";
+static const char kMmtMediaVideo[] = "video";
+static const char kMmtMediaImage[] = "image";
+
+static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
+static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
+
+
 content_t::content_t() {
     process_id = 0;
     frame_id = 0;
     routing_id = 0;
     tab_id = 0;
     //tab_url = "";
-    
     head = "";
     body = "";
 }
 content_t::~content_t() {
 }
 
-} // namespace mmt
-
-
-namespace mmt {
-
 /**
  * For mpu's stream io
  */
@@ -46,6 +48,7 @@ static uint64_t mmtp_tell(stream_t *s) {
 static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
+
 stream_t* InitMpuStream(Stream* ptr) {
     stream_t* s = (stream_t*)malloc(sizeof(stream_t));
     s->opaque = (void*)ptr;
@@ -71,6 +74,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
     midx_.end = -1;
     midx_.cur = -1;
 }
+
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
 }
 
@@ -79,7 +83,7 @@ Stream::~Stream() {
 }
 
 bool Stream::ParseSequence(int& index) {
-    // if exists query, then should redirect to real file name
+    // if exists query in URL, then should redirect to real filename
     std::string query = url_.query();
     if (!query.empty()) { // media sequence
         std::string mtype = GetQueryValue(query, "type");
@@ -87,27 +91,34 @@ bool Stream::ParseSequence(int& index) {
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
         if (mtype.empty()) return false;
 
+        if (mtype == kMmtMediaImage) {
+            index = -2;
+            return true;
+        }
+
         // compute the sequence of media
         GetRangeValue(range, midx_.begin, midx_.end);
         index = midx_.begin;
         LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
         if (index < 0 || midx_.begin > midx_.end) return false;
-    }else {
+    }else { // may be one seperate file, not one media sequence
         index = -1;
     }
     return true;
 }
+
 bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
-    long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) { // for one single file
+    long lret = 1<<31;      // TODO: default 2GB size for media sequence
+    if (midx_.cur < 0) {  // return real size for single file
         lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
     return true;
 }
+
 void* Stream::Open(const char* filename, int mode) {
     if (file_) return (void *)file_;
 
@@ -117,17 +128,22 @@ void* Stream::Open(const char* filename, int mode) {
         return nullptr;
     }
 
-    // default file is html
+    // default for one seperate file
+    //  index >= 0: media sequence
+    //  index == -1: common file
+    //  index == -2: mp4 image file
     std::string fname = GURL2FilePath(url_);
-    if (index >= 0) {
+    if (index >= 0) { // for media sequence
         if (index < midx_.begin || index > midx_.end)
             return nullptr;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
-        if (mtype == "audio") {
-            fname = fname + "/audio/loveapartment_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == "video") {
-            fname = fname + "/video/loveapartment_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
+        if (mtype == kMmtMediaAudio) {
+            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype == kMmtMediaVideo) {
+            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype == kMmtMediaImage) {
+            // nothing to do
         }
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
@@ -145,18 +161,22 @@ void* Stream::Open(const char* filename, int mode) {
 
     if (index != -1 && index != midx_.begin) {
 #if 1
+        // TODO: process image of mp4 here
+        // check moof box and other
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
         mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
         LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
+
+        // get the pos of the 1st moof-box
         long offset = -1;
         if (box) offset = box->i_pos;
         MP4_BoxFree(s, root);
         free(s);
-        if (offset == -1) return nullptr;
         
         // seek to the 1st moof-box
+        if (offset == -1) return nullptr;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
@@ -172,36 +192,43 @@ void* Stream::Open(const char* filename, int mode) {
     midx_.cur = index;
     return (void *)file_;
 }
+
 int Stream::Read(void *buf, int size) {
     if (!Open(nullptr, 0)) return -2;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
         Close();
-        if (midx_.cur != -1) midx_.cur++; // goto next file
+        if (midx_.cur >= 0) midx_.cur++; // goto next file if it is media sequence
     }
     return iret; 
 }
+
 int Stream::Write(void *buf, int size) {
-    return -1;
+    return -1; // unsupported
 }
+
 int Stream::Peek(void *buf, int size) {
     long offset = ftell(file_);
     int iret = fread(buf, 1, size, file_);
     fseek(file_, offset, SEEK_SET);
     return iret;
 }
+
 uint64_t Stream::Seek(int64_t offset, int whence) {
     return fseek(file_, offset, whence);
 }
+
 uint64_t Stream::Tell() {
     return ftell(file_);
 }
+
 int Stream::Close() {
     if (file_) fclose(file_);
     file_ = nullptr;
     return 0;
 }
+
 void Stream::Uninit() {
     Close();
     midx_.begin = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 32712d3..65916b2 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -25,7 +25,7 @@ class IOBuffer;
 namespace mmt {
 
 /**
- * Collect the information of URLRequestJob
+ * To collect the information of URLRequestMmtJob
  */
 struct content_t {
     content_t();
@@ -37,8 +37,8 @@ struct content_t {
     int tab_id;     //> chrome's tab id
     GURL tab_url;   //> chrome's tab url
 
-    // for extra message
-    std::string head;
+    // for extra message (now for js script)
+    std::string head; //> tag: @js
     std::string body;
 };
 
@@ -52,14 +52,21 @@ struct triple_t {
     int end;
     int cur;
 };
+
+/**
+ * stream read offset/size
+ */
 struct offset_t {
     offset_t() : off(0), size(0) {}
     offset_t(long off, long size) : off(off), size(size) {}
 
-    long off;
-    long size;
+    long off;   //> offset of reading 
+    long size;  //> size of reading
 };
 
+/**
+ * Stream IO interfaces
+ */
 class IStream {
 public:
    virtual void*    Open(const char* filename, int mode) = 0;
@@ -88,6 +95,10 @@ public:
 
     explicit Stream(const GURL& url);
     explicit Stream(const std::string& szurl);
+
+    /**
+     * if success, set size with the data length
+     */
     bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
@@ -98,7 +109,7 @@ protected:
 
 private:
     GURL url_;
-    triple_t midx_; //> media index
+    triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
 
@@ -106,7 +117,7 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
+typedef std::map<std::string, StreamPtr> StreamPtrs_t;
 
 } // namespace mmt
 
-- 
1.7.9.5


From bf4c2d6a1827f9bcee13cb276e85a259658d02b5 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 07:08:34 -0800
Subject: [PATCH 71/92] [todo] refine file size with long to replace int

---
 net/mmt/mmt_control.h                  |    2 +-
 net/mmt/mmt_stream.cc                  |    6 ++++--
 net/url_request/url_request_mmt_job.cc |   22 +++++++++++-----------
 net/url_request/url_request_mmt_job.h  |    8 ++++----
 4 files changed, 20 insertions(+), 18 deletions(-)

diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 67d5c87..150f148 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -26,7 +26,7 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
  * Stream IO callback function, which is used to pass data to UrlRequestMmtJob.
  *  three parameters: (job object, stream_info_t, errno)
  */
-typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, long);
 
 /**
  * Post task over UI thread, which is used to execute JS scripts in UrlRequestMmtJob.
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index caaa964..75e90e5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,6 +4,8 @@
 
 namespace mmt {
 
+static const long kMmtMediaSize = 0x7fffffff;
+
 static const char kMmtMediaAudio[] = "audio";
 static const char kMmtMediaVideo[] = "video";
 static const char kMmtMediaImage[] = "image";
@@ -110,8 +112,8 @@ bool Stream::ParseSequence(int& index) {
 bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
-    long lret = 1<<31;      // TODO: default 2GB size for media sequence
-    if (midx_.cur < 0) {  // return real size for single file
+    long lret = kMmtMediaSize;  // TODO: default size for media sequence
+    if (midx_.cur < 0) {        // return real size for single file
         lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 230ecff..0ffc7bc 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -159,18 +159,18 @@ URLRequestMmtJob::~URLRequestMmtJob() {
   LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  LOG(INFO) << __func__ << " iret=" << iret;
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  LOG(INFO) << __func__ << " lret=" << lret;
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), lret));
   }
 }
 
-void URLRequestMmtJob::DidStart(int iret) {
+void URLRequestMmtJob::DidStart(long lret) {
   int result = OK;
-  if (iret <= 0) {
+  if (lret <= 0) {
     result = ERR_FAILED;
   }
 
@@ -183,7 +183,7 @@ void URLRequestMmtJob::DidStart(int iret) {
     return;
   }
 
-  read_info_.total_size = iret;
+  read_info_.total_size = lret;
   if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
@@ -204,20 +204,20 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  if (iret < 0) {
-    LOG(INFO) << __func__ << " iret=" << iret << 
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  if (lret < 0) {
+    LOG(INFO) << __func__ << " lret=" << lret << 
         " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
     return;
   }
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, lret));
   }
 }
 
-void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, long size) {
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index ece9f1e..f1f189c 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -65,11 +65,11 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     GURL url;
   };
 
-  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
-  void DidStart(int iret);
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidStart(long iret);
 
-  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
-  void DidRead(net::IOBuffer* iobuf, int size);
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidRead(net::IOBuffer* iobuf, long size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
-- 
1.7.9.5


From 91369cd3ad86e1bd74c0b60013457a2bbe55358f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 19:21:47 -0800
Subject: [PATCH 72/92] [todo] refine mmt_parse's docs

---
 net/mmt/mmt_control.cc |    5 ++-
 net/mmt/mmt_parser.cc  |   51 ++++++++++++++-----------
 net/mmt/mmt_parser.h   |   98 +++++++++++++++++++++++++++++++-----------------
 net/mmt/mmt_utils.cc   |   10 ++++-
 4 files changed, 104 insertions(+), 60 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 95d2e56..9500f2e 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -3,6 +3,7 @@
 
 namespace mmt {
 
+//#define USE_MMT_NATIVE_MESSAGE 1
 static const int kMmtLoopInterval = 100; // ms
 static const int kMmtReadInterval = 10; // ms
 static const char kMmtDefaultXml[] = "mmt://localhost/tmp/ci.xml";
@@ -62,7 +63,7 @@ void TestXmlParser() {
     std::string xml = kMmtDefaultXml;
     CiParserPtr parser = new CiParser(xml);
     parser->ParseXml();
-    parser->ParseHtmlTag();
+    parser->ParseHtml();
     std::string js;
     parser->GetHtmlJS(0, js);
     LOG(INFO) << __func__ << " js1: " << js;
@@ -233,7 +234,7 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
-                parser->ParseHtmlTag();
+                parser->ParseHtml();
             }
             next_status = "loaded";
             Wait(1000);
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index cd71f93..af65760 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -10,7 +10,7 @@ static const char kNoValue[] = "no-value";
 /**
  * String constants for ci xml node
  */
-//static const char kCI[]             = "mmtci:CI";
+static const char kCI[]             = "mmtci:CI";
 static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
@@ -114,7 +114,12 @@ long ParseTimeStr(std::string timestr) {
         return -1;
     }
 
-#if 1
+#ifdef USE_NTP_TIME
+    Time time;
+    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+        return 0;
+    ms = (long)base::Time::ToJsTime(); //milliseconds
+#else
     long sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
@@ -130,16 +135,10 @@ long ParseTimeStr(std::string timestr) {
         }
     }
     ms = sec * 1000;
-#else
-    Time time;
-    if(!base::Time::FromUTCString(timestr.c_str(), &time))
-        return 0;
-    ms = (long)base::Time::ToJsTime(); //milliseconds
 #endif
     return ms;
 }
 
-
 } // namespace mmt
 
 
@@ -159,9 +158,11 @@ node_t::~node_t() {
     parent = nullptr;
 }
 
-html_t::html_t() {
+html_t::html_t() : node(nullptr) {
 }
 html_t::~html_t() {
+    js.clear();
+    node = nullptr;
 }
 
 
@@ -170,6 +171,8 @@ CiParser::CiParser(const std::string& fname)
 }
 
 CiParser::~CiParser() {
+    root_ = nullptr;
+    cur_ = nullptr;
 }
 
 bool CiParser::ParseXml() {
@@ -199,18 +202,19 @@ bool CiParser::ParseXml() {
 
     return true;
 }
-void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
+
+static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     if (!node) return;
 
     std::string id;
-    if (node->name == kdivLocation)
+    if (node->name == kdivLocation)     // div
         id = node->attrs[krefDiv];
-    else if (node->name == kMediaSync)
+    else if (node->name == kMediaSync)  // <audio><video><image>
         id = node->attrs[krefId];
     if (id.empty()) return;
 
-    std::string js0, js1;       // for time
-    std::string js00, js11;     // for click event
+    std::string js0, js1;       // for time of begin and end
+    std::string js00, js11;     // for click event of begin and end
     js0 = js1 = SetJSBegin(id);
     js00 = js11 = SetJSBegin(id);
 
@@ -257,6 +261,7 @@ void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     html->js[EHtmlClickEnd] = js11;
     htmls[id] = html;
 }
+
 void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
     if (!event.is_event || (event.event != kevbegin && event.event != kevend)) 
         return;
@@ -265,21 +270,21 @@ void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
     event.time = -1;
     if (htmls_.find(event.id) != htmls_.end()) {
         htmlptr_t html = htmls_[event.id];
-        // only support 1 level
+        //TODO: only support 1 level's event
         if (event.event == kevbegin)
             event.time = html->node->time.begin.time;
         else
             event.time = html->node->time.end.time; 
     }
 }
-bool CiParser::ParseHtmlTag() {
+
+bool CiParser::ParseHtml() {
     nodeptr_t node = root_;
     if (!node) return false;
     htmls_.clear();
 
-    nodeptrs_t::iterator iter1;
-
     // init html js
+    nodeptrs_t::iterator iter1;
     for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
         nodeptr_t sub1 = *iter1;
         if (sub1->name == kview) {
@@ -300,11 +305,8 @@ bool CiParser::ParseHtmlTag() {
         }
     }
 
-
-    //
     // process html js
     htmlmap_t::iterator iter;
-
     // end for time
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
@@ -338,7 +340,7 @@ bool CiParser::ParseHtmlTag() {
         }
     }
 
-    // end for event click
+    // process end for event click
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         html->js[EHtmlClickBegin] += SetJSEnd();
@@ -384,9 +386,11 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     }
     return false;
 }
+
 bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
     return false;
 }
+
 bool CiParser::GetHtmlJS(long current, std::string& js) {
     js = "";
     if (htmls_.empty()) return false;
@@ -432,6 +436,9 @@ bool CiParser::AddNode(std::string name) {
     if (!root_)  {
         root_ = node;
         cur_ = root_;
+        if (name != kCI) {
+            LOG(INFO) << __func__ << " invalid root node=" << name;
+        }
         return true;
     }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 8eef4a8..eb7e1fc 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -12,30 +12,38 @@
 
 namespace mmt {
 
-struct node_t;
+struct node_t; // xml node
 typedef scoped_refptr<node_t> nodeptr_t;
-typedef std::map<std::string, std::string> attrs_t;
-typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
+typedef std::vector<nodeptr_t> nodeptrs_t;
+typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name => value
 
 
 /**
- * Structore for mmtci:begin and mmtci:end
+ * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
-    EHtmlBegin,
-    EHtmlEnd,
-    EHtmlClickBegin,
-    EHtmlClickEnd,
+    EHtmlBegin,         //> mmtci:begin
+    EHtmlEnd,           //> mmtci:end
+    EHtmlClickBegin,    //> mmtci:begin's .click
+    EHtmlClickEnd,      //> mmtci:end's .click
 };
 
+/**
+ * The value of mmtci:begin or mmtci:end
+ */
 struct event_t {
     event_t();
-    bool is_event;
-    int is_timeout;
-    std::string id;
-    std::string event;
-    long time;          // ms, valid if no id
+
+    bool is_event;      //> event or time
+    int is_timeout;     //> 0: not timeout,
+    std::string id;     //> event id
+    std::string event;  //> event type
+    long time;          //> ms, valid if id is empty
 };
+
+/**
+ * For node's time (begin/end)
+ */
 struct citime_t {
     event_t begin;
     event_t end;
@@ -43,38 +51,41 @@ struct citime_t {
 
 
 /**
- * Structure for xml node
+ * The structure for xml node
  */
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
 
-    std::string name;
-    attrs_t attrs;
-    citime_t time;      // for time range
+    std::string name;   //> node's name
+    attrs_t attrs;      //> node's attr
+    citime_t time;      //> for time range(begin/end)
 
-    nodeptrs_t nodes;   // sub-nodes
-    nodeptr_t parent;
+    nodeptrs_t nodes;   //> sub nodes
+    nodeptr_t parent;   //> parent node
 
 protected:
     friend class base::RefCounted<node_t>;
     virtual ~node_t();
 };
 
-typedef std::map<int, std::string> jsmap_t;  // k/v: EHtmlEvent => ..
+/**
+ * The xml node will be mapped to html's tag by [struct html_t].
+ */
+typedef std::map<int, std::string> jsmap_t; 
 struct html_t : public base::RefCounted<html_t>{
 public:
     explicit html_t();
-    std::string id;
-    jsmap_t js;
-    nodeptr_t node;
+    std::string id;     //> html tag id
+    jsmap_t js;         //> key/value: EHtmlEvent => js
+    nodeptr_t node;     //> xml node
 
 protected:
     friend class base::RefCounted<html_t>;
     virtual ~html_t();
 };
 typedef scoped_refptr<html_t> htmlptr_t;
-typedef std::map<std::string, htmlptr_t> htmlmap_t; // k/v: tag id => ..
+typedef std::map<std::string, htmlptr_t> htmlmap_t; // key/value: html tag id => html_t
 
 
 /** 
@@ -84,28 +95,47 @@ class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
 
+    /**
+     * To parse xml with libxml2 tools
+     */
     bool ParseXml();
-    bool ParseHtmlTag();
-    bool GetHtmlJS(long current, std::string& js);
 
-    void SetNodeTime(event_t& event, nodeptr_t node);
-    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
-    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
+    /**
+     * To parse html tags based on parsed xml nodes.
+     *  So it should be called after ParseXml().
+     */
+    bool ParseHtml();
+
+    /**
+     * To get current js to operate
+     *
+     * @param current[in]: current time(ms) (ntp or ntp diff)
+     * @param js[out]: returned js 
+     * @return true if success.
+     */
+    bool GetHtmlJS(long current, std::string& js);
 
+    /**
+     * To parse xml's node and its attr
+     */
     bool AddNode(std::string name);
     bool EndNode(std::string name);
     bool AddAttr(std::string name, std::string value);
+
+protected:
+    void SetNodeTime(event_t& event, nodeptr_t node);
+    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
     
 protected:
     friend class base::RefCounted<CiParser>;
     virtual ~CiParser();
 
 private:
-    std::string fname_;
-    nodeptr_t root_;
-    nodeptr_t cur_; // only for AddNode/AddAttr
-
-    htmlmap_t htmls_;
+    std::string fname_; //> xml file name
+    nodeptr_t root_;    //> xml's root node
+    nodeptr_t cur_;     //> only work for AddNode/AddAttr
+    htmlmap_t htmls_;   //> html tags
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 6ff147e..e0060be 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -4,6 +4,9 @@
 
 namespace mmt {
 
+//#define USE_NTP_TIME 1
+static const char kMmtNtpServer[] = "time.apple.com";
+
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
@@ -117,7 +120,7 @@ long GetNTPTime() {
 
     if (_lastntp == 0) {
         struct ntp_time_t ntp_time;
-        int iret = ntp_get_time("time.apple.com", &ntp_time);
+        int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
             _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
@@ -127,8 +130,11 @@ long GetNTPTime() {
     }
 
     long diff = GetLocalTime() - _last;
-    //long currentntp = _lastntp + diff;
+#ifdef USE_NTP_TIME
+    return _lastntp + diff;
+#else
     return diff;
+#endif
 }
 
 } // namespace mmt
-- 
1.7.9.5


From f1b826a0a86b8c56c90965378c1ed75a173edcb7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 19:22:17 -0800
Subject: [PATCH 73/92] [todo] add the process of time end

---
 net/mmt/mmt_parser.cc |   33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index af65760..ab5f853 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -387,7 +387,38 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
+bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
+    long curtime = -1;
+    if (!cnode) return false;
+
+    event_t end = cnode->time.end;
+    if (end.is_timeout > 0) return false;
+
+    if (end.event == kevclick) {
+        ev = EHtmlClickEnd;
+        cnode->time.end.is_timeout = 1;
+        return true;
+    }else {
+        ev = EHtmlEnd;
+        curtime = end.time;
+    }
+
+    // search cnode's parent
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.end.is_event) {
+            if (node->time.end.time >= 0 && node->time.end.time <= curtime)
+                curtime = node->time.end.time;
+        }
+    }while(true);
+
+    LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
+    if (curtime >= 0 || curtime >= current) {
+        cnode->time.end.is_timeout = 1;
+        return true;
+    }
     return false;
 }
 
-- 
1.7.9.5


From 04ab3c0c7c98d7e4220b71abdf6642595d4efec9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 20:26:50 -0800
Subject: [PATCH 74/92] [ok] support time end

---
 net/mmt/mmt_control.cc |    1 +
 net/mmt/mmt_parser.cc  |    2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 9500f2e..b01b93f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -249,6 +249,7 @@ void MmtControl::CheckEvent() {
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
 #else
+                    LOG(INFO) << __func__ << " js => " << js;
                     cixml->postui(cixml->job, "@js", js);
 #endif
                 }
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index ab5f853..7f1244c 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -415,7 +415,7 @@ bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
     }while(true);
 
     LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
-    if (curtime >= 0 || curtime >= current) {
+    if (curtime >= 0 && curtime <= current) {
         cnode->time.end.is_timeout = 1;
         return true;
     }
-- 
1.7.9.5


From 9ec5efc436baf3ad1cff9c5d5dbade8767244dca Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 21:14:30 -0800
Subject: [PATCH 75/92] [todo] refine for ntp time with int64

---
 net/mmt/mmt_control.cc  |    2 +-
 net/mmt/mmt_inc.h       |    4 ++--
 net/mmt/mmt_parser.cc   |   18 +++++++++---------
 net/mmt/mmt_parser.h    |    8 ++++----
 net/mmt/mmt_utils.cc    |   15 +++++++++------
 net/mmt/ntp/ntpclient.c |   32 ++++++++++++++++++--------------
 6 files changed, 43 insertions(+), 36 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index b01b93f..5eb3c1e 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -241,7 +241,7 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loaded") {
             if (parser && cixml->postui) {
                 std::string js;
-                long ntp = GetNTPTime();
+                int64 ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 9a5761a..f389b1d 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -75,8 +75,8 @@ int SendToHost(std::string msg, std::string szaddr, int port);
 /**
  * Get local/ntp time (ms)
  */
-long GetLocalTime();
-long GetNTPTime();
+int64 GetLocalTime();
+int64 GetNTPTime();
 
 }
 
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 7f1244c..1594ca5 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -108,8 +108,8 @@ inline std::string SetJSEnd() {
 /**
  * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
  */
-long ParseTimeStr(std::string timestr) {
-    long ms = 0;
+int64 ParseTimeStr(std::string timestr) {
+    int64 ms = 0;
     if (timestr == kevinf) {
         return -1;
     }
@@ -118,9 +118,9 @@ long ParseTimeStr(std::string timestr) {
     Time time;
     if(!base::Time::FromUTCString(timestr.c_str(), &time))
         return 0;
-    ms = (long)base::Time::ToJsTime(); //milliseconds
+    ms = (int64)time.ToJsTime(); //milliseconds
 #else
-    long sec = atoi(timestr.c_str());
+    int64 sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
     rpos = timestr.rfind(":");
@@ -352,8 +352,8 @@ bool CiParser::ParseHtml() {
 /**
  * To process both @begin and @end
  */
-bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
-    long curtime = -1;
+bool CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
     if (!cnode) return false;
 
     event_t begin = cnode->time.begin;
@@ -387,8 +387,8 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
-    long curtime = -1;
+bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
     if (!cnode) return false;
 
     event_t end = cnode->time.end;
@@ -422,7 +422,7 @@ bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::GetHtmlJS(long current, std::string& js) {
+bool CiParser::GetHtmlJS(int64 current, std::string& js) {
     js = "";
     if (htmls_.empty()) return false;
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index eb7e1fc..736806a 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -38,7 +38,7 @@ struct event_t {
     int is_timeout;     //> 0: not timeout,
     std::string id;     //> event id
     std::string event;  //> event type
-    long time;          //> ms, valid if id is empty
+    int64 time;          //> ms, valid if id is empty
 };
 
 /**
@@ -113,7 +113,7 @@ public:
      * @param js[out]: returned js 
      * @return true if success.
      */
-    bool GetHtmlJS(long current, std::string& js);
+    bool GetHtmlJS(int64 current, std::string& js);
 
     /**
      * To parse xml's node and its attr
@@ -124,8 +124,8 @@ public:
 
 protected:
     void SetNodeTime(event_t& event, nodeptr_t node);
-    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
-    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
+    bool ShouldBeginTime(int64 current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(int64 current, nodeptr_t node, int& ev);
     
 protected:
     friend class base::RefCounted<CiParser>;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index e0060be..2327548 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -107,29 +107,32 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
-long GetLocalTime() {
+int64 GetLocalTime() {
     struct timeval tv;
     memset(&tv, 0, sizeof(tv));
     gettimeofday(&tv, NULL);
     return tv.tv_sec*1000 + tv.tv_usec/1000;
 }
 
-long GetNTPTime() {
-    static long _lastntp = 0;   // ntp time
-    static long _last = 0;      // local tome
+int64 GetNTPTime() {
+    static int64 _lastntp = 0;   // ntp time
+    static int64 _last = 0;      // local tome
 
     if (_lastntp == 0) {
         struct ntp_time_t ntp_time;
+        memset(&ntp_time, 0, sizeof(ntp_time));
         int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
             _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
         else
             _lastntp = _last;
-        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last;
+        LOG(INFO) << __func__ 
+            << " day=" << ntp_time.day << " sec=" << ntp_time.sec
+            << " ntp=" << _lastntp << " local=" << _last;
     }
 
-    long diff = GetLocalTime() - _last;
+    int64 diff = GetLocalTime() - _last;
 #ifdef USE_NTP_TIME
     return _lastntp + diff;
 #else
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
index 293eca0..1bd5588 100644
--- a/net/mmt/ntp/ntpclient.c
+++ b/net/mmt/ntp/ntpclient.c
@@ -610,24 +610,21 @@ static void usage(char *argv0)
 #ifdef LIBNTP 
 int ntp_get_time(const char* host, struct ntp_time_t* ntp_time) {
     if (!host || !ntp_time) return -1;
-    int argc = 4;
-    char* argv[] = {
-        "ntp_get_time",
-        "-h time.apple.com",
-        "-i 1",
-        "-c 1"
-    };
+    int argc = 1;
+    char *argv[] = {"ntp_get_time"};
+
+	char *hostname=(char *)host;
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=1;
+	ntpc.cycle_time=1;
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
 #else
 int main(int argc, char *argv[]) {
     struct ntp_time_t* ntp_time = NULL;
-#endif
-	int usd;  /* socket */
-	int c;
-	/* These parameters are settable from the command line
-	   the initializations here provide default behavior */
-	short int udp_local_port=0;   /* default of 0 means kernel chooses */
 	char *hostname=NULL;          /* must be set */
-	int initial_freq;             /* initial freq value to use */
 	struct ntp_control ntpc;
 	ntpc.live=0;
 	ntpc.set_clock=0;
@@ -635,6 +632,13 @@ int main(int argc, char *argv[]) {
 	ntpc.cycle_time=600;          /* seconds */
 	ntpc.goodness=0;
 	ntpc.cross_check=1;
+#endif
+	int usd;  /* socket */
+	int c;
+	/* These parameters are settable from the command line
+	   the initializations here provide default behavior */
+	short int udp_local_port=0;   /* default of 0 means kernel chooses */
+	int initial_freq;             /* initial freq value to use */
 
 	for (;;) {
 		c = getopt( argc, argv, "c:" DEBUG_OPTION "f:g:h:i:lp:q:" REPLAY_OPTION "st");
-- 
1.7.9.5


From 5d4b2eb2b24c202e734901f3826df43013412b51 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 19:27:30 -0800
Subject: [PATCH 76/92] [todo] use ntp and adjust xml parser

---
 net/mmt/mmt_parser.cc   |   24 +++++++++++++-----------
 net/mmt/mmt_utils.cc    |   10 +++++-----
 net/mmt/ntp/ntpclient.c |    4 ++--
 net/mmt/ntp/ntpclient.h |    6 ++++--
 4 files changed, 24 insertions(+), 20 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 1594ca5..3b57285 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -5,25 +5,27 @@
 
 namespace mmt {
 
+#define USE_NTP_TIME 1
+
 static const char kNoValue[] = "no-value";
 
 /**
  * String constants for ci xml node
  */
-static const char kCI[]             = "mmtci:CI";
-static const char kview[]           = "mmtci:view";
-static const char kdivLocation[]    = "mmtci:divLocation";
-static const char kMediaSync[]      = "mmtci:MediaSync";
-static const char ksourceList[]     = "mmtci:sourceList";
+static const char kCI[]             = "CI";
+static const char kview[]           = "view";
+static const char kdivLocation[]    = "divLocation";
+static const char kMediaSync[]      = "MediaSync";
+static const char ksourceList[]     = "sourceList";
 
 /**
  * String constants for ci xml attr
  */
 static const char krefId[]      = "refId";
-static const char krefDiv[]     = "mmtci:refDiv";
-static const char kmediaSrc[]   = "mmtci:mediaSrc";
-static const char kbegin[]      = "mmtci:begin";
-static const char kend[]        = "mmtci:end";
+static const char krefDiv[]     = "refDiv";
+static const char kmediaSrc[]   = "mediaSrc";
+static const char kbegin[]      = "begin";
+static const char kend[]        = "end";
 static const char kstyle[]      = "style";
 
 /**
@@ -115,7 +117,7 @@ int64 ParseTimeStr(std::string timestr) {
     }
 
 #ifdef USE_NTP_TIME
-    Time time;
+    base::Time time;
     if(!base::Time::FromUTCString(timestr.c_str(), &time))
         return 0;
     ms = (int64)time.ToJsTime(); //milliseconds
@@ -462,7 +464,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
 }
 
 bool CiParser::AddNode(std::string name) {
-    //LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
     if (!root_)  {
         root_ = node;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 2327548..5952fab 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -4,7 +4,7 @@
 
 namespace mmt {
 
-//#define USE_NTP_TIME 1
+#define USE_NTP_TIME 1
 static const char kMmtNtpServer[] = "time.apple.com";
 
 void Wait(int ms) {
@@ -124,12 +124,12 @@ int64 GetNTPTime() {
         int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
-            _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
+            _lastntp = (ntp_time.coarse-JAN_1970_SEC)*1000 + ntp_time.fine/4294967;
         else
             _lastntp = _last;
-        LOG(INFO) << __func__ 
-            << " day=" << ntp_time.day << " sec=" << ntp_time.sec
-            << " ntp=" << _lastntp << " local=" << _last;
+        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last
+            << " iret=" << iret
+            << " coarse=" << ntp_time.coarse << " fine=" << ntp_time.fine;
     }
 
     int64 diff = GetLocalTime() - _last;
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
index 1bd5588..802d176 100644
--- a/net/mmt/ntp/ntpclient.c
+++ b/net/mmt/ntp/ntpclient.c
@@ -424,8 +424,8 @@ static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *
 	}
 
     if (ntp_time) {
-        ntp_time->day = arrival->coarse/86400;
-        ntp_time->sec = arrival->coarse%86400;
+        ntp_time->coarse = arrival->coarse;
+        ntp_time->fine = arrival->fine;
     }else {
 	    printf("%d %.5d.%.3d  %8.1f %8.1f  %8.1f %8.1f %9d\n",
 		    arrival->coarse/86400, arrival->coarse%86400,
diff --git a/net/mmt/ntp/ntpclient.h b/net/mmt/ntp/ntpclient.h
index c6aa46e..bb756dd 100644
--- a/net/mmt/ntp/ntpclient.h
+++ b/net/mmt/ntp/ntpclient.h
@@ -5,9 +5,11 @@
 extern "C" {
 #endif
 
+//#define JAN_1970_SEC        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define JAN_1970_SEC        2208988800
 struct ntp_time_t {
-    int day;
-    float sec;
+	unsigned int coarse;
+	unsigned int fine;
 };
 int ntp_get_time(const char* host, struct ntp_time_t* ntp_time);
 
-- 
1.7.9.5


From bea4edd2c03f654777965cf78412a9d7f9b111b8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 20:14:45 -0800
Subject: [PATCH 77/92] [todo] update libmpu to support mp4 image

---
 net/mmt/mpu/mp4.c          |  226 +++++++++++++++++++++++++++++++++++++++++---
 net/mmt/mpu/mp4.h          |   62 ++++++++++++
 net/mmt/mpu/stream.h       |    4 +-
 net/mmt/mpu/test_parser.cc |   19 ++--
 4 files changed, 290 insertions(+), 21 deletions(-)

diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index adf2898..ca562d1 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -460,6 +460,202 @@ static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
    MP4_READBOX_EXIT( 1 );
 }
 
+//Read infe box
+static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
+{
+	int i;
+	uint8_t *name,*type,*encoding;
+	uint64_t item_name_end_pos = -1;
+	uint64_t content_type_end_pos = -1;
+    MP4_READBOX_ENTER( mp4_box_data_infe_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_infe );
+
+    MP4_GET2BYTES( p_box->data.p_infe->item_ID );
+    MP4_GET2BYTES( p_box->data.p_infe->item_protection_index );
+
+    p_box->data.p_infe->item_name = NULL;
+
+    if( i_read > 0 )
+    {
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				item_name_end_pos = i;
+				break;
+			}
+		}
+        name = p_box->data.p_infe->item_name = malloc( item_name_end_pos + 1 );
+        if( unlikely( name == NULL )|| item_name_end_pos < 0)
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( name, p_peek, item_name_end_pos );
+        p_box->data.p_infe->item_name[item_name_end_pos] = '\0';
+
+		p_peek += item_name_end_pos;
+		i_read -= item_name_end_pos;
+
+		p_box->data.p_infe->content_type = NULL;
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				content_type_end_pos = i;
+				break;
+			}
+		}
+		type = p_box->data.p_infe->content_type = malloc( content_type_end_pos + 1 );
+        if( unlikely( type == NULL || item_name_end_pos < 0))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( type, p_peek, content_type_end_pos );
+        p_box->data.p_infe->content_type[content_type_end_pos] = '\0';
+
+		p_peek += content_type_end_pos;
+		i_read -= content_type_end_pos;
+
+		p_box->data.p_infe->content_encoding = NULL;
+		encoding = p_box->data.p_infe->content_encoding = malloc( i_read + 1 );
+        if( unlikely( encoding == NULL ))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( encoding, p_peek, i_read );
+        p_box->data.p_infe->content_encoding[i_read] = '\0';
+    }
+
+#ifdef MP4_VERBOSE
+         printf( "read box: \"infe\" item_name: \"%s\" content_type: \"%s\"",
+                   (char*)&p_box->data.p_infe->item_name,
+                   p_box->data.p_infe->content_type );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iinf box
+static int MP4_ReadBox_iinf( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_iinf_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_iinf );
+
+    MP4_GET2BYTES( p_box->data.p_iinf->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 6, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"iinf\" entry-count %d",
+                      p_box->data.p_iinf->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iloc box
+static int MP4_ReadBox_iloc( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   unsigned char offset_size_and_length_size = 0;
+   unsigned char base_offset_size_and_index_size_or_reserved = 0;
+   MP4_READBOX_ENTER( mp4_box_data_iloc_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_iloc);
+   MP4_GET1BYTE(offset_size_and_length_size);
+   p_box->data.p_iloc->offset_size=(offset_size_and_length_size>>4)&0x0f;
+   p_box->data.p_iloc->length_size=offset_size_and_length_size&0x0f;
+   MP4_GET1BYTE(base_offset_size_and_index_size_or_reserved);
+   p_box->data.p_iloc->base_offset_size=(base_offset_size_and_index_size_or_reserved>>4)&0x0f;
+   p_box->data.p_iloc->index_size_or_reserved=base_offset_size_and_index_size_or_reserved&0x0f;
+   MP4_GET2BYTES( p_box->data.p_iloc->item_count );
+   p_box->data.p_iloc->item_ID =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->data_reference_index =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->base_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_count =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->extent_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_length =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_iloc->item_ID == NULL
+      || p_box->data.p_iloc->data_reference_index == NULL
+      || p_box->data.p_iloc->base_offset == NULL 
+	  || p_box->data.p_iloc->extent_count == NULL
+	  || p_box->data.p_iloc->extent_offset == NULL
+	  || p_box->data.p_iloc->extent_length == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_iloc->item_count )&&( i_read >= 18 );i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_iloc->item_ID[i] );
+      MP4_GET2BYTES( p_box->data.p_iloc->data_reference_index[i] );
+      MP4_GET4BYTES( p_box->data.p_iloc->base_offset[i] );
+	  MP4_GET2BYTES( p_box->data.p_iloc->extent_count[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"iloc\" item-count %d",
+      p_box->data.p_iloc->item_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+//Read pitm box
+static int MP4_ReadBox_pitm( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_pitm_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_pitm );
+
+    MP4_GET2BYTES( p_box->data.p_pitm->item_ID );
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+static int MP4_ReadBox_idat( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_idat_t );
+
+    p_box->data.p_idat->data =
+      calloc( i_read, sizeof( uint8_t ) );
+	memcpy(  p_box->data.p_idat->data, p_peek, i_read);
+
+	if( unlikely( p_box->data.p_idat->data == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_iloc( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_iloc->item_ID );
+   FREENULL( p_box->data.p_iloc->data_reference_index );
+   FREENULL( p_box->data.p_iloc->base_offset );
+   FREENULL( p_box->data.p_iloc->extent_count );
+   FREENULL( p_box->data.p_iloc->extent_offset );
+   FREENULL( p_box->data.p_iloc->extent_length );
+}
+
+static void MP4_FreeBox_infe( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_infe->item_name );
+   FREENULL( p_box->data.p_infe->content_type );
+   FREENULL( p_box->data.p_infe->content_encoding );
+}
+
+static void MP4_FreeBox_idat( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_idat->data );
+}
 static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
 {
    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
@@ -3445,6 +3641,11 @@ static const struct
    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
 
+   { ATOM_pitm,    MP4_ReadBox_pitm,         MP4_FreeBox_Common},
+   { ATOM_iloc,    MP4_ReadBox_iloc,         MP4_FreeBox_iloc},
+   { ATOM_iinf,    MP4_ReadBox_iinf,         MP4_FreeBox_Common},
+   { ATOM_infe,    MP4_ReadBox_infe,         MP4_FreeBox_infe},
+   { ATOM_idat,    MP4_ReadBox_idat,         MP4_FreeBox_idat},
    /* Last entry */
    { 0,              MP4_ReadBox_default,      NULL }
 };
@@ -3525,7 +3726,8 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 			||cur->i_type==ATOM_udta||cur->i_type==ATOM_nmhd||cur->i_type==ATOM_hnti||cur->i_type==ATOM_rmra \
 			||cur->i_type==ATOM_rmda||cur->i_type==ATOM_tref||cur->i_type==ATOM_gmhd||cur->i_type==ATOM_wave \
 			||cur->i_type==ATOM_ilst||cur->i_type==ATOM_mvex||cur->i_type==ATOM_stsd||cur->i_type==ATOM_tref \
-			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root)
+			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root\
+			||cur->i_type==ATOM_meta||cur->i_type==ATOM_iinf)
         {
 			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
 			if(cur->i_type==i_type)
@@ -3549,17 +3751,17 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 				else if(cur->p_father->p_next)
 					cur = cur->p_father->p_next;
                 else if (cur->p_father->p_father) {
-				    if(cur->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next;
-				    else {
+	                mp4_box_t* parent = cur->p_father->p_father;
+                    cur = NULL;
+                    do {
+                        if (parent->p_next) {
+                            cur = parent->p_next;
+                            break;
+                        }
+                        parent = parent->p_father;
+                    }while(parent);
+
+				    if(!cur) {
 					    printf("Format not supported!\n");
 					    return NULL;
 				    }
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 8cff958..0aa7a96 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -233,6 +233,11 @@
 
 #define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
 
+#define ATOM_pitm MP4_FOURCC( 'p', 'i', 't', 'm' )
+#define ATOM_iloc MP4_FOURCC( 'i', 'l', 'o', 'c' )
+#define ATOM_iinf MP4_FOURCC( 'i', 'i', 'n', 'f' )
+#define ATOM_infe MP4_FOURCC( 'i', 'n', 'f', 'e' )
+#define ATOM_idat MP4_FOURCC( 'i', 'd', 'a', 't' )
 
 
 typedef struct uuid_s
@@ -263,6 +268,58 @@ typedef struct mp4_box_data_mmpu_s
    char *asset_id_value;
 
 } mp4_box_data_mmpu_t;
+typedef struct mp4_box_data_infe_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint16_t item_ID;
+	uint16_t item_protection_index;
+    char     *item_name;
+    char     *content_type;
+	char     *content_encoding;
+
+} mp4_box_data_infe_t;
+
+typedef struct mp4_box_data_iinf_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_iinf_t;
+
+typedef struct mp4_box_data_iloc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+	uint8_t  offset_size;
+	uint8_t  length_size;
+	uint8_t  base_offset_size;
+	uint8_t  index_size_or_reserved;
+    uint16_t item_count;
+
+    uint16_t *item_ID; /* theses are arrays */
+	uint16_t *data_reference_index;
+    uint32_t *base_offset;
+	uint16_t *extent_count;
+    uint32_t *extent_offset;
+	uint32_t *extent_length;
+
+} mp4_box_data_iloc_t;
+
+typedef struct mp4_box_data_pitm_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t item_ID;
+
+} mp4_box_data_pitm_t;
+
+typedef struct mp4_box_data_idat_s
+{
+    uint8_t  *data;
+
+} mp4_box_data_idat_t;
 
 typedef struct mp4_box_data_tfdt_s
 {
@@ -1182,6 +1239,11 @@ typedef union mp4_box_data_s
    mp4_box_data_chpl_t *p_chpl;
    mp4_box_data_tref_generic_t *p_tref_generic;
    mp4_box_data_name_t *p_name;
+   mp4_box_data_infe_t *p_infe;
+   mp4_box_data_iinf_t *p_iinf;
+   mp4_box_data_iloc_t *p_iloc;
+   mp4_box_data_pitm_t *p_pitm;
+   mp4_box_data_idat_t *p_idat;
    void *p_data;
 } mp4_box_data_t;
 
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index e528a9e..9815bb1 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -8,8 +8,8 @@ typedef unsigned char uint8_t;
 typedef short int16_t;
 typedef unsigned short uint16_t;
 typedef int int32_t;
-typedef unsigned uint32_t;
-typedef long int int64_t;
+typedef unsigned int uint32_t;
+//typedef long long int64_t;
 typedef unsigned long long uint64_t;
 //typedef unsigned long size_t;
 #endif
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 4263520..163ef33 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -9,13 +9,13 @@ mp4_box_t* print_traf(mp4_box_t* box) {
     do {
         box = MP4_BoxSearchBox(box, ATOM_traf);
         if (!box) break;
-        printf("traf: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("traf: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
 
         box = MP4_BoxSearchBox(box, ATOM_tfhd);
         if (!box) break;
         else {
-            printf("tfhd: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%u size=%u\n", 
+            printf("tfhd: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%llu size=%u\n", 
                 box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
                 box->data.p_tfhd->base_data_offset, box->data.p_tfhd->default_sample_size);
         }
@@ -23,7 +23,7 @@ mp4_box_t* print_traf(mp4_box_t* box) {
         box = MP4_BoxSearchBox(box, ATOM_trun);
         if (!box) break;
         else {
-            printf("trun: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("trun: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
             printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
                 box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
                 box->data.p_trun->data_offset);
@@ -55,22 +55,27 @@ int main(int argc, char* argv[])
     mp4_box_t* box = NULL;
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
     if (box) {
-        printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("ftyp: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
     }else {
         box = root;
     }
 
+    mp4_box_t* idat = MP4_BoxSearchBox(box, ATOM_idat); 
+    if (idat) {
+        printf("idat: %p pos: %ld size: %llu\n", idat, idat->i_pos, idat->i_size);
+    }
+
     do {
         box = MP4_BoxSearchBox(box, ATOM_moof);
         if (!box) break;
-        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("moof: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
 
         box = print_traf(box);
         box = print_traf(box);
 
         box = MP4_BoxSearchBox(box, ATOM_mdat);
         if (!box) break;
-        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("mdat: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
     }while(1);
 
     MP4_BoxFree(s, root);
-- 
1.7.9.5


From 40b6b70362c8392a4e5cb54edae63987feb38fd0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 21:35:52 -0800
Subject: [PATCH 78/92] [ok] support mp4 image <type=image>

---
 net/mmt/mmt_stream.cc |   22 +++++++++++++++++-----
 net/mmt/mmt_stream.h  |    1 +
 net/mmt/mpu/mp4.c     |    8 ++++----
 3 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 75e90e5..98b9dc1 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -92,6 +92,7 @@ bool Stream::ParseSequence(int& index) {
         std::string range = GetQueryValue(query, "sequence_num");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
         if (mtype.empty()) return false;
+        mtype_ = mtype;
 
         if (mtype == kMmtMediaImage) {
             index = -2;
@@ -168,17 +169,28 @@ void* Stream::Open(const char* filename, int mode) {
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
-        mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
-        LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
 
-        // get the pos of the 1st moof-box
         long offset = -1;
-        if (box) offset = box->i_pos;
+        mp4_box_t* box = nullptr;
+        if (mtype_ == kMmtMediaImage) {
+            box = MP4_BoxSearchBox(box0, ATOM_idat);
+            offset = 8;
+        }else {
+            box = MP4_BoxSearchBox(box0, ATOM_moof);
+            offset = 0;
+        }
+        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+
+        // get the pos of the 1st moof-box
+        long ipos = -1;
+        if (box) ipos = box->i_pos;
         MP4_BoxFree(s, root);
         free(s);
         
         // seek to the 1st moof-box
-        if (offset == -1) return nullptr;
+        if (ipos == -1) return nullptr;
+        offset += ipos;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 65916b2..d6fac18 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -109,6 +109,7 @@ protected:
 
 private:
     GURL url_;
+    std::string mtype_;
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index ca562d1..282d2c7 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -464,9 +464,9 @@ static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
 static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
 {
 	int i;
-	uint8_t *name,*type,*encoding;
-	uint64_t item_name_end_pos = -1;
-	uint64_t content_type_end_pos = -1;
+	char *name,*type,*encoding;
+	int64_t item_name_end_pos = -1;
+	int64_t content_type_end_pos = -1;
     MP4_READBOX_ENTER( mp4_box_data_infe_t );
 
     MP4_GETVERSIONFLAGS( p_box->data.p_infe );
@@ -486,7 +486,7 @@ static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
 				break;
 			}
 		}
-        name = p_box->data.p_infe->item_name = malloc( item_name_end_pos + 1 );
+        name = p_box->data.p_infe->item_name = (char *)malloc( item_name_end_pos + 1 );
         if( unlikely( name == NULL )|| item_name_end_pos < 0)
             MP4_READBOX_EXIT( 0 );
 
-- 
1.7.9.5


From 98b445a83076fb64e0b6954121066a99e3ccb915 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 22:37:54 -0800
Subject: [PATCH 79/92] [todo] add 1st version of mmtp to chrome

---
 net/mmt/mmtp/DList.c   |  276 +++++++++++
 net/mmt/mmtp/DList.h   |   84 ++++
 net/mmt/mmtp/Mlist.c   |  280 +++++++++++
 net/mmt/mmtp/Mlist.h   |   85 ++++
 net/mmt/mmtp/client.c  |  972 ++++++++++++++++++++++++++++++++++++
 net/mmt/mmtp/getfile.c |  274 ++++++++++
 net/mmt/mmtp/getfile.h |   22 +
 net/mmt/mmtp/ini.c     |  692 ++++++++++++++++++++++++++
 net/mmt/mmtp/ini.h     |  153 ++++++
 net/mmt/mmtp/mmt.c     | 1293 ++++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mmtp/mmt.h     |  464 +++++++++++++++++
 net/mmt/mmtp/mmtp.gyp  |   93 ++++
 net/mmt/mmtp/mmtp.h    |   64 +++
 net/mmt/mmtp/ringq.c   |  112 +++++
 net/mmt/mmtp/ringq.h   |   65 +++
 net/mmt/mmtp/send.c    |  199 ++++++++
 net/mmt/mmtp/send.h    |   32 ++
 net/mmt/mpu/mp4.h      |    1 +
 net/net.gyp            |    1 +
 19 files changed, 5162 insertions(+)
 create mode 100644 net/mmt/mmtp/DList.c
 create mode 100644 net/mmt/mmtp/DList.h
 create mode 100644 net/mmt/mmtp/Mlist.c
 create mode 100644 net/mmt/mmtp/Mlist.h
 create mode 100644 net/mmt/mmtp/client.c
 create mode 100644 net/mmt/mmtp/getfile.c
 create mode 100644 net/mmt/mmtp/getfile.h
 create mode 100644 net/mmt/mmtp/ini.c
 create mode 100644 net/mmt/mmtp/ini.h
 create mode 100644 net/mmt/mmtp/mmt.c
 create mode 100644 net/mmt/mmtp/mmt.h
 create mode 100644 net/mmt/mmtp/mmtp.gyp
 create mode 100644 net/mmt/mmtp/mmtp.h
 create mode 100644 net/mmt/mmtp/ringq.c
 create mode 100644 net/mmt/mmtp/ringq.h
 create mode 100644 net/mmt/mmtp/send.c
 create mode 100644 net/mmt/mmtp/send.h

diff --git a/net/mmt/mmtp/DList.c b/net/mmt/mmtp/DList.c
new file mode 100644
index 0000000..34fd494
--- /dev/null
+++ b/net/mmt/mmtp/DList.c
@@ -0,0 +1,276 @@
+#include"DList.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+Position MakeNode(const char* i)
+{
+	PNode p = NULL;
+	p = (PNode)malloc(sizeof(Node));
+	p->data=(unsigned char *)malloc(1500*sizeof(unsigned char));
+	memset((void*)p->data,0,1500);
+	if(p!=NULL)
+	{
+		//p->data = i;
+		memcpy((void*)p->data , &i[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void FreeNode(PNode p)
+{
+	 free(p);
+}
+/**/
+DList * InitList()
+{
+	DList *plist = (DList *)malloc(sizeof(DList));
+	PNode head = MakeNode("");
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void DestroyList(DList *plist)
+{
+	ClearList(plist);
+	free(GetHead(plist));
+	free(plist);
+}
+
+/**/
+int IsEmpty(DList *plist)
+{
+	if(GetSize(plist)==0&&GetTail(plist)==GetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void ClearList(DList *plist)
+{
+	PNode temp,p;
+	p = GetTail(plist);
+	while(!IsEmpty(plist))
+	{
+		temp = GetPrevious(p);
+		free(p->data);
+		FreeNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+Position GetHead(DList *plist)
+{
+	return plist->head;
+}
+
+/**/
+Position GetTail(DList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int GetSize(DList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+Position GetNext(Position p)
+{
+	return p->next;
+}
+
+/*p*/
+Position GetPrevious(Position p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode)
+{
+	Position head = GetHead(plist);
+
+	if(IsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+PNode DelFirst(DList *plist)
+{
+	Position head = GetHead(plist);
+
+	Position p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->data);
+
+	}
+	return p;
+}
+/*,,*/
+PNode DelFirst2(DList *plist)
+{
+	Position head = GetHead(plist);
+	Position p=head->next;
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* GetItem(Position p)
+{
+	return p->data;
+}
+
+/**/
+void SetItem(Position p,unsigned char* i)
+{
+	p->data = i;
+}
+
+/**/
+PNode Remove(DList *plist)
+{
+	Position p=NULL;
+	if(IsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = GetTail(plist);
+		free(p->data);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int RemovePnext(DList *plist,Position p)
+{
+	Position q=p->next;
+	if(IsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->data);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+PNode InsBefore(DList *plist,Position p,PNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == GetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+PNode LocatePos(DList *plist,int i)
+{
+	int cnt = 0;
+	Position p = GetHead(plist);
+	if(i>GetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)())
+{
+	Position p = GetHead(plist);
+	if(IsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->data);
+		}
+	}
+}
diff --git a/net/mmt/mmtp/DList.h b/net/mmt/mmtp/DList.h
new file mode 100644
index 0000000..1918862
--- /dev/null
+++ b/net/mmt/mmtp/DList.h
@@ -0,0 +1,84 @@
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+#ifndef NET_MMT_MMTP_DLIST_H_
+#define NET_MMT_MMTP_DLIST_H_
+
+#include <string.h>
+
+typedef struct Node * PNode;
+typedef PNode Position;
+/**/
+typedef struct Node
+{
+	unsigned char * data;		/**/
+	PNode previous; /**/
+	PNode next;		/**/
+}Node;
+/**/
+typedef struct
+{
+	PNode head;		/**/
+	PNode tail;		/**/
+	int size;
+}DList;
+
+/*i*/
+Position MakeNode(const char * i);
+
+/*p*/
+void FreeNode(PNode p);
+
+/**/
+DList* InitList();
+
+/**/
+void DestroyList(DList *plist);
+
+/**/
+void ClearList(DList *plist);
+
+/**/
+Position GetHead(DList *plist);
+
+/**/
+Position GetTail(DList *plist);
+
+/**/
+int GetSize(DList *plist);
+
+/*p*/
+Position GetNext(Position p);
+
+/*p*/
+Position GetPrevious(Position p);
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode);
+
+/**/
+PNode DelFirst(DList *plist);
+
+/**/
+unsigned char * GetItem(Position p);
+
+/**/
+void SetItem(Position p,unsigned char * i);
+
+/**/
+PNode Remove(DList *plist);
+
+/*P*/
+int RemovePnext(DList *plist,Position p);
+
+/*pS*/
+PNode InsBefore(DList *plist,Position p,PNode s);
+
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s);
+
+/*i*/
+PNode LocatePos(DList *plist,int i);
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)());
+
+#endif
diff --git a/net/mmt/mmtp/Mlist.c b/net/mmt/mmtp/Mlist.c
new file mode 100644
index 0000000..c8f0085
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.c
@@ -0,0 +1,280 @@
+#include "Mlist.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf)
+{
+	mPNode p = NULL;
+	p = (mPNode)malloc(sizeof(mNode));
+	p->mpu_buf=(mpu_buf_t*)malloc(1500*sizeof(unsigned char));
+	memset((void*)p->mpu_buf,0,1500);
+	if(p!=NULL)
+	{
+		//p->mpu_buf = i;
+		memcpy((void*)p->mpu_buf , &mpu_buf[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void mFreemNode(mPNode p)
+{
+	 free(p);
+}
+/**/
+MPUList * mInitList()
+{
+    mpu_buf_t tmpu;
+	MPUList *plist = (MPUList *)malloc(sizeof(MPUList));
+    memset(&tmpu, 0, sizeof(tmpu));
+	mPNode head = mMakeNode(&tmpu);
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void mDestroyList(MPUList *plist)
+{
+	mClearList(plist);
+	free(mGetHead(plist));
+	free(plist);
+}
+
+/**/
+int mIsEmpty(MPUList *plist)
+{
+	if(mGetSize(plist)==0&&mGetTail(plist)==mGetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void mClearList(MPUList *plist)
+{
+	mPNode temp,p;
+	p = mGetTail(plist);
+	while(!mIsEmpty(plist))
+	{
+		temp = mGetPrevious(p);
+		free(p->mpu_buf);
+		mFreemNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+mPosition mGetHead(MPUList *plist)
+{
+	return plist->head;
+}
+
+/**/
+mPosition mGetTail(MPUList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int mGetSize(MPUList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+mPosition mGetNext(mPosition p)
+{
+	return p->next;
+}
+
+/*p*/
+mPosition mGetPrevious(mPosition p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode pnode)
+{
+	mPosition head = mGetHead(plist);
+
+	if(mIsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+mPNode mDelFirst(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+
+	mPosition p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->mpu_buf);
+
+	}
+	return p;
+}
+/*,,*/
+mPNode mDelFirst2(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+	mPosition p=head->next;
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* mGetItem(mPosition p)
+{
+	return (unsigned char*)p->mpu_buf;
+}
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf)
+{
+	p->mpu_buf = mpu_buf;
+}
+
+/**/
+mPNode mRemove(MPUList *plist)
+{
+	mPosition p=NULL;
+	if(mIsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = mGetTail(plist);
+		free(p->mpu_buf);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p)
+{
+	mPosition q=p->next;
+	if(mIsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->mpu_buf);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == mGetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i)
+{
+	int cnt = 0;
+	mPosition p = mGetHead(plist);
+	if(i>mGetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)())
+{
+	mPosition p = mGetHead(plist);
+	if(mIsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->mpu_buf);
+		}
+	}
+}
+
+
diff --git a/net/mmt/mmtp/Mlist.h b/net/mmt/mmtp/Mlist.h
new file mode 100644
index 0000000..89d5028
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.h
@@ -0,0 +1,85 @@
+#ifndef NET_MMT_MMTP_MLIST_H_
+#define NET_MMT_MMTP_MLIST_H_
+
+#include "mmt.h"
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+
+typedef struct mNode * mPNode;
+typedef mPNode mPosition;
+/**/
+typedef struct mNode
+{
+	mpu_buf_t *mpu_buf;		/**/
+	mPNode previous; /**/
+	mPNode next;		/**/
+}mNode;
+/**/
+typedef struct
+{
+	mPNode head;		/**/
+	mPNode tail;		/**/
+	int size;
+}MPUList;
+
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf);
+
+/*p*/
+void mFreemNode(mPNode mp);
+
+/**/
+MPUList* mInitList();
+
+/**/
+void mDestroyList(MPUList *plist);
+
+/**/
+void mClearList(MPUList *plist);
+
+/**/
+mPosition mGetHead(MPUList *plist);
+
+/**/
+mPosition mGetTail(MPUList *plist);
+
+/**/
+int mGetSize(MPUList *plist);
+
+/*p*/
+mPosition mGetNext(mPosition p);
+
+/*p*/
+mPosition mGetPrevious(mPosition p);
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode mpnode);
+
+/**/
+mPNode mDelFirst(MPUList *plist);
+
+/**/
+unsigned char * mGetItem(mPosition p);
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf);
+
+/**/
+mPNode mRemove(MPUList *plist);
+
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p);
+
+/*pS*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode ms);
+
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode ms);
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i);
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)());
+
+#endif
+
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
new file mode 100644
index 0000000..895014e
--- /dev/null
+++ b/net/mmt/mmtp/client.c
@@ -0,0 +1,972 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#include<signal.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <sched.h>
+#define BACKLOG 2
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "send.h"
+#include "ringq.h"
+#include "DList.h"
+
+
+#define MCAST_PORT 6080
+#define MCAST_ADDR "224.1.1.101"
+
+
+
+#define BACKLOG 2
+
+extern void sig_proccess(int signo);
+extern void sig_pipe(int signo);
+
+void *producter_f (void *arg);					/**/
+void *mpu_consumer_f (void *arg);					/**/
+void *signal_consumer_f (void *arg);					/**/
+int signal_buffer_has_item=0;							/**/
+int mpu_buffer_has_item=0;							/**/
+pthread_mutex_t mpu_mutex;							/**/
+pthread_mutex_t signal_mutex;							/**/
+int running =1 ;								/**/
+
+static int s;
+
+void sig_proccess(int signo)
+{
+	printf("catch a exit signal\n");
+	close(s);
+	exit(0);
+}
+
+void  sig_pipe(int signo)
+{
+	printf("catch a SIGPIPE signal\n");
+	close(s);
+	exit(0);
+}
+
+
+#define BUFF_LEN 1500
+
+DList *signal_buff_list = NULL;
+DList *mpu_buff_list = NULL;
+
+#if 0
+int main(int argc, char *argv[])
+{
+
+	//init a double listmpu_buff_listst = InitList();
+	signal_buff_list=InitList();
+	mpu_buff_list=InitList();
+
+	pthread_t signal_consumer_t;						/**/
+	pthread_t mpu_consumer_t;						/**/
+	pthread_t producter_t;						/**/
+
+	pthread_mutex_init (&signal_mutex,NULL);			/**/
+	pthread_mutex_init (&mpu_mutex,NULL);			/**/
+
+	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
+	usleep(10);
+	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
+	usleep(10);
+	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
+	usleep(10);
+	//pthread_join(producter_t,&buffer_has_item);			/**/
+	while(1)
+		sleep(1);
+	pthread_mutex_destroy(&signal_mutex);				/**/
+	//udpserv_echo(ss,(struct sockaddr*)&local_addr);
+
+	/**/
+
+
+    return 0;
+}
+#endif
+
+void *producter_f (void *arg)					/**/
+{
+//
+	int ss;
+
+	struct sockaddr_in local_addr;
+	int err=-1;
+	pid_t pid;
+	//sigint
+	signal(SIGINT,sig_proccess);
+	signal(SIGPIPE,sig_pipe);
+
+	//s
+	ss=socket(AF_INET, SOCK_DGRAM,0);
+	if(ss<0)
+	{
+		printf("socket error\n");
+		return NULL;
+	}
+
+//	//
+//	bzero(&server_addr,sizeof(server_addr));
+//	//memset(&server_addr,0,sizeof(server_addr));
+//	server_addr.sin_family=AF_INET;
+//	//server_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+//	server_addr.sin_addr.s_addr=inet_addr(SERVER_ADDR);
+//	server_addr.sin_port =htons(SERVER_PORT);
+//	bzero(&(server_addr.sin_zero),8);
+
+	//
+	bzero(&local_addr,sizeof(local_addr));
+	//memset(&server_addr,0,sizeof(server_addr));
+	local_addr.sin_family=AF_INET;
+	//server_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+//	local_addr.sin_addr.s_addr=inet_addr(CLIENT_ADDR);
+	local_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+	local_addr.sin_port =htons(MCAST_PORT);
+	bzero(&(local_addr.sin_zero),8);
+
+
+	//
+	err=bind(ss,(struct sockaddr*)&local_addr,sizeof(struct sockaddr_in));
+	//printf("ready for listening");
+	if(err<0)
+	{
+		printf("bind error \n");
+		return  NULL;
+	}
+	printf("ready for listening\n");
+
+	//	//BLOADCASE
+	//    int ret;
+	//    int so_broadcast = 1 ;
+	//    ret = setsockopt(ss, SOL_SOCKET, SO_BROADCAST, &so_broadcast,sizeof(so_broadcast));
+	//	if(ret ==-1)
+	//	{
+	//		printf("setsockopt failed\n");
+	//		return -1;
+	//	}
+
+	/**/
+	int loop = 1 ;
+	err = setsockopt(ss, IPPROTO_IP, IP_MULTICAST_LOOP,&loop, sizeof(loop));
+	if(err ==-1)
+	{
+		printf("setsockopt failed:setsockopt():IP_MULTICAST_LOOP\n");
+		return NULL;
+	}
+
+	/**/
+	struct ip_mreq mreq;
+	mreq.imr_multiaddr.s_addr = inet_addr(MCAST_ADDR); /**/
+	mreq.imr_interface.s_addr = htonl(INADDR_ANY); /**/
+
+	/**/
+	err = setsockopt(ss, IPPROTO_IP, IP_ADD_MEMBERSHIP,&mreq, sizeof(mreq));
+	if (err < 0)
+	{
+		printf("setsockopt():IP_ADD_MEMBERSHIP");
+		return NULL;
+	}
+
+	int n;
+	char buff[BUFF_LEN];
+	socklen_t len;//x
+	PNode p = NULL;
+
+	int lastpacket,last_flag=1;
+
+	while(running)								/**/
+	{
+		len=sizeof(local_addr);
+		n=recvfrom(ss,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
+		if(n <=0)
+		{
+			perror("recv error");
+			return NULL;
+		}
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		read_mmtp_header(&mmt_header,buff);
+//		printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag!=0)
+		{
+			puts ("packet loss");
+//			exit (EXIT_FAILURE);
+		}
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag==0)
+		{
+			puts ("packet loss");
+			exit (EXIT_FAILURE);
+		}
+		lastpacket=mmt_header.packet_counter;
+		last_flag--;
+		if(mmt_header.type==2)
+		{
+			pthread_mutex_lock (&signal_mutex);			/**/
+			//5000
+			if(GetSize(signal_buff_list)==5000)
+			{
+				//
+				free(DelFirst(signal_buff_list));
+				signal_buffer_has_item--;						/**/
+				printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			}
+			p=GetTail(signal_buff_list);
+			InsAfter(signal_buff_list,p,MakeNode(buff));
+			p = p->next;
+//			printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+//			printf("%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(signal_buff_list));
+			signal_buffer_has_item++;						/**/
+//			printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&signal_mutex);			/**/
+
+		}
+
+		if(mmt_header.type==0)
+		{
+			pthread_mutex_lock (&mpu_mutex);			/**/
+			//5000
+			if(GetSize(mpu_buff_list)==5000)
+			{
+				//
+				free(DelFirst(mpu_buff_list));
+				mpu_buffer_has_item--;						/**/
+//				printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			}
+			p=GetTail(mpu_buff_list);
+			InsAfter(mpu_buff_list,p,MakeNode(buff));
+			p = p->next;
+			read_mmtp_header(&mmt_header,buff);
+
+			read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//			printf("recieve mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number);
+//			printf("mpu%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(mpu_buff_list));
+			mpu_buffer_has_item++;						/**/
+//			printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&mpu_mutex);			/**/
+
+
+		}
+
+//		if(buffer_has_item==100)
+//			pthread_exit((void *)3);
+	}
+
+	err = setsockopt(ss, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
+	close(ss);
+    return NULL;
+}
+
+void *signal_consumer_f(void *arg)						/**/
+{
+	PNode p = NULL;
+	unsigned char *signal_buf;
+	u_int32_t signal_seekpoint=0;
+	pa_message_t pa_message;
+	while(running)								/**/
+	{
+		pthread_mutex_lock(&signal_mutex);				/**/
+		while(GetSize(signal_buff_list)>1)
+		{
+			//signal
+			p=GetHead(signal_buff_list);
+			p=p->next;
+			unsigned char buff[BUFF_LEN];
+			memcpy(buff,p->data,BUFF_LEN);
+			mmt_packet_header_t mmt_header;
+			read_mmtp_header(&mmt_header,(const char*)buff);
+			if(mmt_header.type==2)
+			{
+				signal_header_t signal_header;
+				read_signal_header(&signal_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+				if(signal_header.f_i==0)
+				{
+						;
+				}
+				if(signal_header.f_i==1)
+				{
+					if(signal_header.H==0)
+					{
+						//need realize 32 bit signal head later on
+						read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+						signal_buf= (unsigned  char*) malloc((pa_message.length+PAh_BUFF_LEN)*sizeof( unsigned  char));
+						if(signal_buf==NULL)
+						{
+								puts ("Memory allocation failed.");
+								 exit (EXIT_FAILURE);
+						}
+//						printf("init mem\n");
+//						printf("pa_message.length%d\n",pa_message.length);
+						memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+						signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+					}
+					if(signal_header.H==1)
+					{
+						read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+						signal_buf= (unsigned  char*) malloc((pa_message.length)*sizeof( unsigned  char));
+						memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length2);
+						signal_seekpoint=signal_seekpoint+signal_header.MSG_length2;
+					}
+				}
+				if(signal_header.f_i==2)
+				{
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+					signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+				}
+				if(signal_header.f_i==3)
+				{
+//					printf("signal_header.f_i==3\n");
+//					printf("seekpoint%d\n",signal_seekpoint);
+//					printf("signal_header.MSG_length1%d\n",signal_header.MSG_length1);
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+					signal_seekpoint=0;
+					//if PA message
+					read_pa_message(&pa_message,(const char*)&signal_buf[0]);
+					//PA message
+
+//					printf("finished recive signal\n");
+
+					if(signal_buf != NULL)
+					{
+						free(signal_buf);
+						signal_buf=NULL;
+//						printf("free signal_buf\n");
+					}
+					//
+					free_pa_message(&pa_message);
+				}
+
+			}
+			//
+			free(DelFirst(signal_buff_list));
+			signal_buffer_has_item--;						/**/
+//			printf(":%d\n",signal_buffer_has_item);	/**/
+		}
+
+		pthread_mutex_unlock(&signal_mutex);			/**/
+		usleep(50);
+	}
+    return NULL;
+}
+
+void *mpu_consumer_f(void *arg)						/**/
+{
+	//init a  mpu_buf and a seekpoint
+//	unsigned char *mpu_buf;
+//	u_int32_t mpu_seekpoint=0;
+
+//	//init a  mpu_meta_buf and a seekpoint
+//	unsigned char *mpu_meta_buf;
+//	u_int32_t mpu_meta_seekpoint=0;
+//
+//	//init a  frag_meta_buf and a seekpoint
+//	unsigned char *frag_meta_buf;
+//	u_int32_t frag_meta_seekpoint=0;
+//
+//	//init a  *mfu_buf and a seekpoint
+//	//unsigned char *mfu_buf;
+//	u_int32_t mfu_seekpoint=0;
+//
+//	unsigned char *muli_buf;
+//	u_int32_t muli_seekpoint=0;
+
+
+	//init a ring queue
+	RINGQ rq, * p_queue;
+	int i,data;
+
+	p_queue = &rq;
+	ringq_init(p_queue);
+
+	//init a double list
+	DList *plist = NULL;
+	PNode p = NULL;
+	PNode q = NULL;
+
+	DList *mpu_consumer_list = NULL;
+	mpu_consumer_list=InitList();
+
+//mpu_buf_t,mpu,,,!!!!!!
+	mpu_buf_t *mpu_list;
+// init_mpu_list(&mpu_list);
+
+
+	mpu_buf_t mpu_buf;
+	init_mpu_buf(&mpu_buf);
+	int mpufilter=0;
+	while(running)								/**/
+	{
+		int mpu_consumer_couter=0;
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		mfu_time_packet_header_t mfu_time_header;
+		unsigned char buff[BUFF_LEN];
+		pthread_mutex_lock(&mpu_mutex);				/**/
+//		printf("1111mpu:%d\n",mpu_buffer_has_item); 	/**/
+		if(GetSize(mpu_buff_list)>0)
+		{
+			p=GetHead(mpu_buff_list);
+			p=p->next;
+			memcpy(buff,p->data,BUFF_LEN);
+			read_mmtp_header(&mmt_header,(const char*)buff);
+			read_mpu_header(&mpu_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+			read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+			InsFirst(mpu_consumer_list,MakeNode((const char*)buff));
+			free(DelFirst(mpu_buff_list));
+			if(mpu_header.FT==2) {};
+//			printf("consume 	mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d ,mfu_time_header.sample_number: %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number,mfu_time_header.sample_number);
+//			printf("consume		mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number);
+//			p=GetHead(mpu_buff_list);
+//			int counter=0;
+//			while(p->next != NULL)
+//			{
+////				printf("copy GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//				p=p->next;
+//				memcpy(buff,p->data,BUFF_LEN);
+//				read_mmtp_header(&mmt_header,buff);
+//				read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//				if(mmt_header.packet_id==1 )
+//				{
+//					counter++;
+//				}
+//
+//			}
+//			printf("debug packet_id counter:%d\n",counter);
+//			//MPU
+//			p=GetHead(mpu_buff_list);
+//
+//			while(p->next != NULL)
+//			{
+////				printf("copy GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//				p=p->next;
+//				memcpy(buff,p->data,BUFF_LEN);
+//				read_mmtp_header(&mmt_header,buff);
+//				read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//
+////				printf("debug packet_id: mmt_header.packet_id%d\n",mmt_header.packet_id);
+//				if(mmt_header.packet_id==1)
+//				{
+//					printf("debug packet_id: mmt_header.packet_counter%d mmt_header.packet_id%d\n",mmt_header.packet_counter,mmt_header.packet_id);
+//
+////					if(GetSize(mpu_consumer_list) == 0)
+////					{
+////						printf("GetSize(mpu_consumer_list) == 0\n");
+////						InsFirst(mpu_consumer_list,MakeNode(buff));
+////					}
+////					else
+////					{
+//
+//						InsAfter(mpu_consumer_list,GetTail(mpu_consumer_list),MakeNode(buff));
+////					}
+////					//
+////					//
+//					if(p->previous==GetHead(mpu_buff_list))
+//					{
+//						printf("1 FIRST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						q = p->next;
+////						printf("2 FIRST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						free(DelFirst(mpu_buff_list));
+//
+//						if(q != NULL)
+//						{
+//							p = q->previous;
+//						}
+//
+//					}
+//					else
+//					{
+//						if(p==GetTail(mpu_buff_list))//
+//						{
+//
+//							Remove(mpu_buff_list);
+//							p = GetTail(mpu_buff_list);
+//							printf("LAST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						}
+//						else//
+//						{
+//							q = p->next;
+//							RemovePnext(mpu_buff_list,p->previous);
+//							p = q->previous;
+//							if(p->next == NULL )
+//							{
+//								printf("p == NULL\n");
+//							}
+////							printf("MID GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						}
+//					}
+//					mpu_buffer_has_item--;						/**/
+//					mpu_consumer_couter++;
+////					p = GetTail(mpu_consumer_list);
+////					read_mmtp_header(&mmt_header,p->data);
+////					printf("mmt_header.packet_counter%d\n",mmt_header.packet_counter);
+//					if(p->next == NULL )
+//							{
+//								printf("p == NULL\n");
+//							}
+////					printf("mpu:%d\n",mpu_buffer_has_item);	/**/
+//
+//				}
+//			}
+//			printf(":%dmpu\n",mpu_consumer_couter);	/**/
+
+		}
+		pthread_mutex_unlock(&mpu_mutex);			/**/
+
+
+		while(GetSize(mpu_consumer_list)>0)
+		{
+//			printf("GetSize(mpu_consumer_list):%d\n",GetSize(mpu_consumer_list)); 	/**/
+			p=GetHead(mpu_consumer_list);
+			p=p->next;
+			memcpy(buff,p->data,BUFF_LEN);
+			read_mmtp_header(&mmt_header,(const char*)buff);
+//			printf("consumer mmt_header->packet_counter%d mmt_header.packet_id:%d\n",mmt_header.packet_counter,mmt_header.packet_id);
+			if(mmt_header.packet_id==1)
+			{
+				mpu_packet_header_t mpu_header;
+				read_mpu_header(&mpu_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+//				printf("mpu_header.MPU_sequence_number%d\n",mpu_header.MPU_sequence_number);//MPU_sequence_number
+				if(mpu_header.MPU_sequence_number!=1)
+				{
+		//			mpu metadata
+					if(mpu_header.FT==0)
+					{
+//						printf("mpu_header.FT==0\n");
+						if(mpu_header.f_i==0)
+						{
+							mpu_buf.packet_id=mmt_header.packet_id;
+							mpu_buf.MPU_sequence_number=mpu_header.MPU_sequence_number;
+							mpu_buf.mpu_metadata_buf.data = (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+							if(mpu_buf.mpu_metadata_buf.data==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+
+							memcpy(&mpu_buf.mpu_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+							mpu_buf.mpu_metadata_buf.length=mpu_header.length-6;
+							mpu_buf.mpu_metadata_buf.flag=1;
+							mpu_buf.mpu_metadata_buf.counter=1;
+						}
+						if(mpu_header.f_i==1)
+						{
+								;
+						}
+						if(mpu_header.f_i==2)
+						{
+								;
+						}
+						if(mpu_header.f_i==3)
+						{
+								;
+						}
+					}
+					//fragment metadata
+					if(mpu_header.FT==1&&mpu_buf.mpu_metadata_buf.flag==1)
+					{
+
+//						printf("mpu_header.FT==1\n");
+						if(mpu_header.f_i==0)
+						{
+//							printf("mpu_header.f_i==0\n");
+							mpu_buf.fragment_metadata_buf.data= (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+							if(mpu_buf.fragment_metadata_buf.data==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+							memcpy(&mpu_buf.fragment_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+							mpu_buf.fragment_metadata_buf.length=mpu_header.length-6;
+							mpu_buf.fragment_metadata_buf.flag=1;
+							mpu_buf.fragment_metadata_buf.counter=1;
+
+							//analysis fragmentdata,and decide recieve how many sample
+							mpu_buf.mfu_number=ntohl(*((u_int32_t*)&mpu_buf.fragment_metadata_buf.data[76]));;
+
+							mpu_buf.mfu= (mfu_buf_t *)malloc(sizeof(mfu_buf_t)*mpu_buf.mfu_number);
+							if(mpu_buf.mfu==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+							mpu_buf.mfu_sample= (mfu_sample_t *)malloc(sizeof(mfu_sample_t)*mpu_buf.mfu_number);
+							if(mpu_buf.mfu_sample==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+
+							//mfu
+							int i;
+							for(i=0;i<mpu_buf.mfu_number;i++)
+							{
+								mpu_buf.mfu[i].data= (unsigned  char*) malloc(1500000);
+								if(mpu_buf.mfu[i].data==NULL)
+								{
+									puts ("Memory allocation failed.");
+									exit (EXIT_FAILURE);
+								}
+								memset(mpu_buf.mfu[i].data,0,1500000);
+								mpu_buf.mfu[i].flag=0;
+								mpu_buf.mfu[i].length=0;
+								mpu_buf.mfu[i].number=0;
+								mpu_buf.mfu[i].counter=0;
+
+							}
+//							printf("hehe\n");
+//							muli_buf=(unsigned  char*) malloc((sample_number*34)*sizeof( unsigned  char));
+						}
+						if(mpu_header.f_i==1)
+						{
+							;
+						}
+						if(mpu_header.f_i==2)
+						{
+							;
+						}
+						if(mpu_header.f_i==3)
+						{
+							;
+						}
+
+					}
+		//			mfu_seekpoint=0;
+					//MFU
+
+					if(mpu_header.FT==2&&mpu_buf.mpu_metadata_buf.flag==1&&mpu_buf.fragment_metadata_buf.flag==1)
+					{
+//						printf("mpu_header.FT==2\n");
+						mfu_time_packet_header_t mfu_time_header;
+						read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+//						printf("process 		mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d ,mfu_time_header.sample_number: %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number,mfu_time_header.sample_number);
+//						if(recive_mfu==mfu_time_header.sample_number)
+//						{
+							if(mpu_header.f_i==0)
+							{
+
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_header.length-6-MFUh_t_BUFF_LEN;
+								mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+								(mpu_buf.mfu_counter)++;
+
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+								if(mfu_time_header.sample_number==0)
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+								}
+								else
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+								}
+//								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_seekpoint;
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+
+
+
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1)//LAST MFU
+								{
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+
+									printf("mpu_buf.MPU_sequence_length:%d\n",mpu_buf.MPU_sequence_length);
+
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+										mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+									}
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+									free_mpu_buf(&mpu_buf );
+									printf("finished recive a mpu \n");
+
+								}
+//								free(mfu_buf);
+//								if(ringq_poll(p_queue,&recive_mfu)>=0);
+//									printf("recive_mfu:%d\n",recive_mfu);
+//								mfu_seekpoint=0;
+							}
+							if(mpu_header.f_i==1)
+							{
+						//
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+//								printf("mpu_header.fragment_counter%d\n",mpu_header.fragment_counter);
+//								printf("size:%d\n",((mpu_header.fragment_counter)*1500)*sizeof( unsigned  char));
+	//							mfu_buf= (unsigned  char*) malloc((mpu_header.fragment_counter)*1500);
+
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+
+//								printf("expect mpu_header.fragment_counter%d\n",mpu_header.fragment_counter);
+							}
+							if(mpu_header.f_i==2)
+							{
+//								InsAfter(plist,p,MakeNode(buff));
+//								p = p->next;
+//								printf("size%d\n",mpu_header.fragment_counter);
+//								printf("size%d\n",GetSize(plist));
+
+
+//								printf("mpu_header.f_i==2\n");
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+							}
+							if(mpu_header.f_i==3)
+							{
+//								InsAfter(plist,p,MakeNode(buff));
+//								int j;
+//								Position p = GetHead(plist);
+//								p = p->next;
+//								for(j=0;j<GetSize(plist);j++)
+//								{
+//									read_mmtp_header(&mmt_header,p->data);
+//									printf("%dmmt_header->packet_counter%d\n",j,mmt_header.packet_counter);
+//									p = p->next;
+//
+//								}
+//								printf("size%d\n",GetSize(plist));
+//								printf("size%d\n",mpu_header.fragment_counter);
+//
+//								DestroyList(plist);
+
+
+//								printf("mpu_header.f_i==3\n");
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+								if (mpu_buf.mfu[mfu_time_header.sample_number].counter==mpu_header.fragment_counter)
+								{
+									mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+								}
+								(mpu_buf.mfu_counter)++;
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+//								printf("expect %d ,finished %d ,mfu_counter %d\n",mpu_header.fragment_counter,mpu_buf.mfu[mfu_time_header.sample_number].counter,mpu_buf.mfu_counter);
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+								if(mfu_time_header.sample_number==0)
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+								}
+								else
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+								}
+//								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_seekpoint;
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+
+//								printf("length:%d,offset:%d\n",mpu_buf.mfu_sample[mfu_time_header.sample_number].length,mpu_buf.mfu_sample[mfu_time_header.sample_number].offset);
+								//MPU
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter==mpu_buf.mfu_number)
+								{
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+										mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+									}
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									mpu_buf.flag=1 ;
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+
+									free_mpu_buf(&mpu_buf );
+									init_mpu_buf(&mpu_buf);
+									printf("finished recive a mpu \n");
+
+								}
+								//,,
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter!=mpu_buf.mfu_number)
+								{
+//									printf("mpu_buf.MPU_sequence_number%d\n",mpu_buf.MPU_sequence_number);
+//									printf("mpu_buf.mfu_counter%d, mpu_buf.mfu_number%d\n",mpu_buf.mfu_counter,mpu_buf.mfu_number);
+
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+//									printf("				mpu_buf.MPU_sequence_length:%d\n",mpu_buf.MPU_sequence_length);
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek+mpu_buf.mfu_sample[i].offset-8] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+									}
+									mpu_seek=mpu_seek+mpu_buf.mfu_sample[mpu_buf.mfu_number-1].offset-8+mpu_buf.mfu[mpu_buf.mfu_number-1].length;
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+
+									free_mpu_buf(&mpu_buf );
+									init_mpu_buf(&mpu_buf);
+									printf("finished recive a mpu \n");
+								}
+
+							}
+
+//						}//RECIVE MFU
+					}//MFU end
+
+				}//MPU END
+			}//packet END
+
+			//
+			free(DelFirst(mpu_consumer_list));
+		}//FILTER END
+
+	}//WHILE END
+    return NULL;
+}//FUCTION END
diff --git a/net/mmt/mmtp/getfile.c b/net/mmt/mmtp/getfile.c
new file mode 100644
index 0000000..4a63216
--- /dev/null
+++ b/net/mmt/mmtp/getfile.c
@@ -0,0 +1,274 @@
+#include"getfile.h"
+
+
+int cmp(char *p1,char *p2) /*  */
+{int i=0;
+while (*(p1+i)==*(p2+i))
+if (*(p1+i++)=='\0') return 0; /* *(p1+i)=='\0'i++ */
+return (*(p1+i)-*(p2+i));
+}
+
+void sort(char **fileNameList, int count) /**/
+{
+	char *temp;
+	int i,j;
+	for(i=0;i<count-1;i++)/*  */
+	for(j=i+1;j<count;j++)
+	if(cmp(fileNameList[i],fileNameList[j])>0)
+	{
+		temp=fileNameList[i];/*  */
+		fileNameList[i]=fileNameList[j];
+		fileNameList[j]=temp;
+	}
+}
+
+// author:wangchangshaui jlu
+//this function can get result in fileNameList
+int getFileNameArray(const char *path, u_int32_t* fileCount,char ***fileNameList)
+{
+    int count = 0;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if (((*fileNameList) = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return -1;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if (((*fileNameList)[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return -1;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset((*fileNameList)[i], 0, strlen(ent->d_name) + 1);
+            strcpy((*fileNameList)[i], ent->d_name);
+            printf("%d:%s\n", i, (*fileNameList)[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort((*fileNameList), count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,(*fileNameList)[i]);
+       }
+
+    return 1;
+}
+
+// author:wangchangshaui jlu
+//this function like getFileNameArray, you  can get result by return
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount)
+{
+    int count = 0;
+    char **fileNameList = NULL;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if ((fileNameList = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return NULL;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if ((fileNameList[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return NULL;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset(fileNameList[i], 0, strlen(ent->d_name) + 1);
+            strcpy(fileNameList[i], ent->d_name);
+            printf("%d:%s\n", i, fileNameList[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort(fileNameList, count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,fileNameList[i]);
+       }
+
+    return fileNameList;
+}
+
+void get_full_path(const char *path ,char * filename,char ** fullpath )
+{
+
+	char dir_buf[512];
+	memset(dir_buf, 0, 512);
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	*fullpath=dir_buf;
+	printf("fullpath%s\n",*fullpath);
+}
+
+char* get_full_path2(const char *path ,char * filename)
+{
+
+	static char dir_buf[512];
+	memset(dir_buf, 0, strlen(dir_buf));
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	//printf("fullpath%s\n",dir_buf);
+	return (char *)dir_buf;
+
+}
+
+int ReadFile(char * path, char ** fdata, u_int16_t *length)
+{
+    FILE * pfile;
+    char * data;
+
+    pfile = fopen(path, "rb");
+    if (pfile == NULL)
+    {
+        return -1;
+    }
+    fseek(pfile, 0, SEEK_END);
+    *length = ftell(pfile);
+    data = (char *)malloc((*length + 1) * sizeof(char));
+    rewind(pfile);
+    *length = fread(data, 1, *length, pfile);
+    data[*length] = '\0';
+    fclose(pfile);
+    *fdata=data;
+    return 1;
+}
+
+char* strcatex(char* str1, char* str2)
+{
+    char* buf = (char*) malloc(strlen(str1) + strlen(str2) + 1);
+    sprintf(buf, "%s", str1);
+    strcat(buf, str2);
+    return buf;
+}
diff --git a/net/mmt/mmtp/getfile.h b/net/mmt/mmtp/getfile.h
new file mode 100644
index 0000000..abcf152
--- /dev/null
+++ b/net/mmt/mmtp/getfile.h
@@ -0,0 +1,22 @@
+#ifndef NET_MMT_MMTP_GETFILE_H_
+#define NET_MMT_MMTP_GETFILE_H_
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+int getFileNameArray(const char *path, u_int32_t* fileCount,char * **fileNameList);
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount);
+void get_full_path(const char *path ,char * filename,char ** fullpath );
+char *get_full_path2(const char *path ,char * filename);
+//char * ReadFile(char * path, int *length);
+int ReadFile(char * path, char ** fdata,u_int16_t *length);
+char* strcatex(char* str1, char* str2);
+
+#endif
diff --git a/net/mmt/mmtp/ini.c b/net/mmt/mmtp/ini.c
new file mode 100644
index 0000000..798f069
--- /dev/null
+++ b/net/mmt/mmtp/ini.c
@@ -0,0 +1,692 @@
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+
+# undef  _GNU_SOURCE
+# define _GNU_SOURCE
+
+# include <stdio.h>
+# include <string.h>
+# include <stdlib.h>
+# include <stdbool.h>
+# include <ctype.h>
+# include <arpa/inet.h>
+# include <fcntl.h>
+#include <unistd.h>
+
+# include "ini.h"
+#define  MAX_PATH 260
+
+static bool is_comment(char **line)
+{
+    char *content = *line;
+    while (isspace(*content))
+        ++content;
+
+    if (*content == ';' || *content == '#' || *content == '\0')
+        return true;
+
+    char *end = content + strlen(content) - 1;
+    while (isspace(*end))
+        *end-- = '\0';
+
+    *line = content;
+
+    return false;
+}
+
+static ssize_t _getline(char **lineptr, size_t *n, FILE *stream)
+{
+    ssize_t len = getline(lineptr, n, stream);
+    if (len == -1)
+        return -1;
+
+    char  *_line = NULL;
+    size_t _n    = 0;
+
+    while (len >= 2 && (*lineptr)[len - 2] == '\\')
+    {
+        if (getline(&_line, &_n, stream) == -1)
+        {
+            free(_line);
+
+            return 0;
+        }
+
+        char *next_line = _line;
+        while (isspace(*next_line))
+            ++next_line;
+        ssize_t next_len = strlen(next_line);
+        ssize_t need_len = len - 1 + next_len + 1;
+
+        if (*n < need_len)
+        {
+            while (*n < need_len)
+                *n *= 2;
+
+            *lineptr = realloc(*lineptr, *n);
+            if (*lineptr == NULL)
+            {
+                free(_line);
+
+                return -1;
+            }
+        }
+
+        if (isspace((*lineptr)[len - 3]))
+            (*lineptr)[len - 2] = '\0';
+        else
+            (*lineptr)[len - 2] = ' ';
+        (*lineptr)[len - 1] = '\0';
+
+        strcat(*lineptr, next_line);
+        len = strlen(*lineptr);
+    }
+
+    if (_line)
+        free(_line);
+
+    return len;
+}
+
+void ini_free(ini_t *handler)
+{
+    struct ini_section *curr = handler;
+    struct ini_section *next = NULL;
+
+    while (curr)
+    {
+        next = curr->next;
+
+        struct ini_arg *arg_curr = curr->args;
+        struct ini_arg *arg_next = NULL;
+
+        while (arg_curr)
+        {
+            arg_next = arg_curr->next;
+
+            free(arg_curr->name);
+            free(arg_curr->value);
+            free(arg_curr);
+
+            arg_curr = arg_next;
+        }
+
+        free(curr->name);
+        free(curr);
+
+        curr = next;
+    }
+
+    return;
+}
+
+static void ini_print(ini_t *handler)
+{
+# ifdef DEBUG
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name == NULL)
+            continue;
+
+        printf("[%s]\n", curr->name);
+
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name == NULL || arg->value == NULL)
+                continue;
+
+            printf("    %-20s = %s\n", arg->name, arg->value);
+            arg = arg->next;
+        }
+
+        curr = curr->next;
+    }
+# endif
+
+    return;
+}
+
+static struct ini_section *create_section(struct ini_section *head, char *name)
+{
+    struct ini_section *p = calloc(1, sizeof(struct ini_section));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_section *find_section(struct ini_section *head, char *name)
+{
+    struct ini_section *curr = head;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(curr->name, name) == 0)
+            return curr;
+
+        curr = curr->next;
+    }
+
+    return NULL;
+}
+
+static struct ini_arg *create_arg(struct ini_section *head, char *name, char *value)
+{
+    struct ini_arg *p = calloc(1, sizeof(struct ini_arg));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->value = strdup(value)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_arg *find_arg(struct ini_section *curr, char *name)
+{
+    struct ini_arg *arg = curr->args;
+
+    while (arg)
+    {
+        if (arg->name && strcmp(arg->name, name) == 0)
+            return arg;
+
+        arg = arg->next;
+    }
+
+    return NULL;
+}
+
+ini_t *ini_load(char *path)
+{
+
+	char current_absolute_path[MAX_PATH];
+	memset(current_absolute_path,0,sizeof(current_absolute_path));
+	//
+	int cnt = readlink("/proc/self/exe", current_absolute_path, MAX_PATH);
+	if (cnt < 0 || cnt >= MAX_PATH)
+	{
+	    printf("***Error***\n");
+	    exit(-1);
+	}
+	//
+	int i;
+	for (i = cnt; i >=0; --i)
+	{
+	    if (current_absolute_path[i] == '/')
+	    {
+	        //current_absolute_path[i+1] = '\0';
+	    	memcpy(&current_absolute_path[i+1],path,(strlen(path)+1));
+	        break;
+	    }
+	    else
+	    	current_absolute_path[i] = '\0';
+
+	}
+
+    FILE *fp = fopen(current_absolute_path, "r");
+
+    if (fp == NULL)
+        return NULL;
+
+    struct ini_section *head = NULL;
+    struct ini_section *prev = NULL;
+    struct ini_section *curr = NULL;
+
+    struct ini_arg *arg_curr = NULL;
+    struct ini_arg *arg_prev = NULL;
+
+    char *line  = NULL;
+    size_t   n  = 0;
+    ssize_t len = 0;
+
+    while ((len = _getline(&line, &n, fp)) != -1)
+    {
+        char *s = line;
+        if (is_comment(&s))
+            continue;
+        len = strlen(s);
+
+        if (len >= 3 && s[0] == '[' && s[len - 1] == ']')
+        {
+            char *name = s + 1;
+            while (isspace(*name))
+                ++name;
+
+            char *name_end = s + len - 1;
+            *name_end-- = '\0';
+            while (isspace(*name_end))
+                *name_end-- = '\0';
+
+            if ((curr = find_section(head, name)) == NULL)
+            {
+                if ((curr = create_section(head, name)) == NULL)
+                {
+                    free(line);
+
+                    return NULL;
+                }
+
+                if (head == NULL)
+                    head = curr;
+                if (prev != NULL)
+                    prev->next = curr;
+
+                prev = curr;
+                arg_prev = NULL;
+            }
+            else
+            {
+                arg_prev = curr->args;
+                while (arg_prev->next != NULL)
+                    arg_prev = arg_prev->next;
+            }
+
+            continue;
+        }
+
+        char *delimiter = strchr(s, '=');
+        if (delimiter == NULL)
+            continue;
+        *delimiter = '\0';
+
+        char *name = s;
+        char *name_end = delimiter - 1;
+        while (isspace(*name_end))
+            *name_end-- = '\0';
+
+        char *value = delimiter + 1;
+        while (isspace(*value))
+            value++;
+
+        if (curr == NULL)
+        {
+            if ((curr = create_section(head, "global")) == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (head == NULL)
+                head = curr;
+            prev = curr;
+            arg_prev = NULL;
+        }
+
+        if ((arg_curr = find_arg(curr, name)) == NULL)
+        {
+            arg_curr = create_arg(head, name, value);
+            if (arg_curr == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (arg_prev)
+                arg_prev->next = arg_curr;
+            if (curr->args == NULL)
+                curr->args = arg_curr;
+
+            arg_prev = arg_curr;
+        }
+        else
+        {
+            char *old_value = arg_curr->value;
+
+            if ((arg_curr->value = strdup(value)) == NULL)
+            {
+                ini_free(head);
+
+                free(line);
+
+                return NULL;
+            }
+
+            free(old_value);
+        }
+    }
+
+    free(line);
+    fclose(fp);
+
+    if (head == NULL)
+    {
+        if ((head = calloc(1, sizeof(struct ini_section))) == NULL)
+            return NULL;
+    }
+
+    ini_print(head);
+
+    return head;
+}
+
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value)
+{
+    if (!handler || !name || !value)
+        return -1;
+
+    if (section == NULL || *section == 0)
+        section = "global";
+
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(section, curr->name) == 0)
+            break;
+
+        curr = curr->next;
+    }
+
+    if (curr)
+    {
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name && arg->value && strcmp(arg->name, name) == 0)
+            {
+                *value = strdup(arg->value);
+                if (*value == NULL)
+                    return -1;
+
+                return 0;
+            }
+
+            arg = arg->next;
+        }
+    }
+
+    if (default_value)
+    {
+        *value = strdup(default_value);
+        if (*value == NULL)
+            return -1;
+    }
+    else
+    {
+        *value = NULL;
+    }
+
+    return 1;
+}
+
+static char *sstrncpy(char *dest, const char *src, size_t n)
+{
+    if (n == 0)
+        return dest;
+
+    dest[0] = 0;
+
+    return strncat(dest, src, n - 1);
+}
+
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(value, 0, n);
+
+    if (s)
+    {
+        sstrncpy(value, s, n);
+        free(s);
+    }
+
+    return ret;
+}
+
+static int ini_read_num(ini_t *handler,
+        char *section, char *name, void *value, bool is_unsigned)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        if (is_unsigned)
+            *(unsigned long long int*)value = strtoull(s, NULL, 0);
+        else
+            *(long long int *)value = strtoll(s, NULL, 0);
+
+        free(s);
+    }
+
+    return ret;
+}
+
+# define INI_READ_SIGNED(type) do { \
+    long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, false); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+# define INI_READ_UNSIGNED(type) do { \
+    unsigned long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, true); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value)
+{
+    INI_READ_SIGNED(int);
+}
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value)
+{
+    INI_READ_UNSIGNED(unsigned);
+}
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value)
+{
+    INI_READ_SIGNED(int8_t);
+}
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value)
+{
+    INI_READ_UNSIGNED(uint8_t);
+}
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value)
+{
+    INI_READ_SIGNED(int16_t);
+}
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value)
+{
+    INI_READ_UNSIGNED(uint16_t);
+}
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value)
+{
+    INI_READ_SIGNED(int32_t);
+}
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value)
+{
+    INI_READ_UNSIGNED(uint32_t);
+}
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value)
+{
+    INI_READ_SIGNED(int64_t);
+}
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value)
+{
+    INI_READ_UNSIGNED(uint64_t);
+}
+
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtof(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtod(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(addr, 0, sizeof(struct sockaddr_in));
+
+    if (s)
+    {
+        char *ip = strtok(s, ": \t");
+        if (ip == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        char *port = strtok(NULL, ": \t");
+        if (port == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_family = AF_INET;
+        if (inet_aton(ip, &addr->sin_addr) == 0)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_port = htons((uint16_t)atoi(port));
+
+        free(s);
+    }
+
+    return ret;
+}
+
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        int i;
+        for (i = 0; s[i]; ++i)
+            s[i] = tolower(s[i]);
+
+        if (strcmp(s, "true") == 0)
+            *value = true;
+        else if (strcmp(s, "false") == 0)
+            *value = false;
+        else
+            *value = default_value;
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
diff --git a/net/mmt/mmtp/ini.h b/net/mmt/mmtp/ini.h
new file mode 100644
index 0000000..ab895e6
--- /dev/null
+++ b/net/mmt/mmtp/ini.h
@@ -0,0 +1,153 @@
+#ifndef NET_MMT_MMTP_INI_H_
+#define NET_MMT_MMTP_INI_H_
+
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+# include <stdint.h>
+# include <stdbool.h>
+# include <netinet/in.h>
+
+struct ini_arg
+{
+    char  *name;
+    char  *value;
+    struct ini_arg *next;
+};
+
+struct ini_section
+{
+    char  *name;
+    struct ini_arg *args;
+    struct ini_section *next;
+};
+
+typedef struct ini_section ini_t;
+
+/*
+ * Feature:
+ * 1: If a property name declared befor any section is declared, it
+ *    is in a "global" section. If the ini_read_* function argument
+ *    section is empty string or NULL, they will find the property
+ *    name in the "global" section.
+ *
+ * 2: There is no technical LIMIT on the length of section name or
+ *    property name or value, or the num of sections and properties,
+ *    the limit is the size of memory.
+ *
+ * 3: There is no special limit on the name of section and property.
+ *    Note that the surround whitespace of the name of section and
+ *    property and value is ignored, but they can contian whitespace.
+ *    Note that the name of section and property are case insensitivity.
+ *
+ * 4: Blank line is ignored.
+ *
+ * 5: Lines beginning with '#' or ';' are ignored and may be used to
+ *    provide comments.
+ *
+ * 6: The second occurrence of a property name in the same section
+ *    overwrite the previous one. The section occurrence of a section
+ *    is joined whih the previous one.
+ *
+ * 7: If a line end with '\', where a backslash followed immediately
+ *    by EOL (end-of-line) causes the line break to be ignored, and
+ *    the "logical line" to be continued on the next actual line from
+ *    the INI file. Example:
+ *        name = simple read only ini parser
+ *    is the same with:
+ *        name = simple \
+ *               read only \
+ *               ini parser
+ */
+
+/*
+ * Load a ini config file to memory, return NULL if fail.
+ */
+ini_t *ini_load(char *path);
+
+/*
+ * Return value:
+ * If the combination of section and name found in config file, return 0.
+ * Return 1 if not found, the *value will be the default_value.
+ *
+ * Fail return -1;
+ */
+
+/*
+ * Read string from ini config handler.
+ * The string is allocated using malloc, so, you need free it after use.
+ */ 
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value);
+
+/*
+ * Read string from ini config handler.
+ * If the real length of value is greater than or equal to n, n - 1
+ * characters and a null terminator will be copied to value, else
+ * the remainder of value pads with null bytes.
+ */
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value);
+
+/*
+ * Read int or unsigned int or stdint from ini config handler.
+ * Support octal or hexadecimal base ("0" or "0x"/"0X" respectively).
+ */
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value);
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value);
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value);
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value);
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value);
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value);
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value);
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value);
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value);
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value);
+
+/*
+ * Read float/double from ini config handler.
+ */
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value);
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value);
+
+/*
+ * Read a ipv4 addr such as: 127.0.0.1:8080 or 127.0.0.1 8080
+ */
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value);
+
+/*
+ * Read a bool from ini config handler. The value in the ini config file can be
+ * "true" or "false", the case are ignored.
+ */
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value);
+
+/* Free a ini config handler */
+void ini_free(ini_t *handler);
+
+#endif
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
new file mode 100644
index 0000000..e2a09ee
--- /dev/null
+++ b/net/mmt/mmtp/mmt.c
@@ -0,0 +1,1293 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#define BACKLOG 2
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "send.h"
+
+int get_send_timestamp()
+{
+	int MMT_timestamp;
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+
+	time_t timep;
+	struct tm *p;
+	time(&timep);
+	p = localtime(&timep);
+
+	MMT_timestamp=p->tm_hour*60*60*1000+p->tm_min*60*1000+p->tm_sec*1000+tv.tv_usec/1000;
+	return MMT_timestamp;
+}
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number)
+{
+	unsigned char *buff_tmp=(unsigned  char*) malloc(number*sizeof( unsigned   char));
+	memset(buff_tmp,0,number);
+	memcpy(&buff_tmp[0],srcbuff,number);
+	*dstbuff=buff_tmp;
+	return 0;
+
+}
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh)
+{
+//	mmt_packet_header_t mmt_header;
+
+//			mmt_header.version=0;
+//			mmt_header.packet_counter_flag=1;
+//			mmt_header.FEC_type=0;
+//			mmt_header.reserved_1=0;
+//			mmt_header.extension_flag=0;
+//			mmt_header.RAP_flag=0;
+//			mmt_header.reserved_2=0;
+//			mmt_header.type=2;
+//			mmt_header.packet_id=packet_id;
+//			mmt_header.timestamp=MMT_timestamp;
+//			mmt_header.packet_sequence_number=0;
+//			mmt_header.packet_counter=packet_counter;
+
+//16byte
+			memset(MMTPh,0,MMTPh_BUFF_LEN);
+			MMTPh[0]=(u_int8_t)mmt_header->version<<6
+					|(u_int8_t) mmt_header->packet_counter_flag<<5
+					|(u_int8_t) mmt_header->FEC_type<<3
+					|(u_int8_t) mmt_header->reserved_1<<2
+					|(u_int8_t) mmt_header->extension_flag<<1
+					|(u_int8_t) mmt_header->RAP_flag;
+			MMTPh[1]=(u_int8_t)mmt_header->reserved_2<<6
+					|(u_int8_t) mmt_header->type;
+			*((u_int16_t*)&MMTPh[2])=htons(mmt_header->packet_id);
+			*((u_int32_t*)&MMTPh[4])=htonl(mmt_header->present_time);
+			*((u_int32_t*)&MMTPh[8])=htonl(mmt_header->timestamp);
+			*((u_int32_t*)&MMTPh[12])=htonl(mmt_header->packet_sequence_number);
+			*((u_int32_t*)&MMTPh[16])=htonl(mmt_header->packet_counter);
+
+return 0;
+}
+
+int read_mmtp_header(mmt_packet_header_t *mmt_header, const char *MMTPh)
+{
+			mmt_header->version=(MMTPh[0]>>6)&0x03;
+			mmt_header->packet_counter_flag=(MMTPh[0]>>5)&0x01;
+			mmt_header->FEC_type=(MMTPh[0]>>3)&0x03;
+			mmt_header->reserved_1=(MMTPh[0]>>2)&0x01;
+			mmt_header->extension_flag=(MMTPh[0]>>1)&0x01;
+			mmt_header->RAP_flag=MMTPh[0]&0x01;
+			mmt_header->reserved_2=(MMTPh[1]>>6)&0x3F;
+			mmt_header->type=MMTPh[1]&0x03;
+			mmt_header->packet_id=ntohs(*((u_int16_t*)&MMTPh[2]));
+			mmt_header->present_time=ntohl(*((u_int32_t*)&MMTPh[4]));
+			mmt_header->timestamp=ntohl(*((u_int32_t*)&MMTPh[8]));
+			mmt_header->packet_sequence_number=ntohl(*((u_int32_t*)&MMTPh[12]));
+			mmt_header->packet_counter=ntohl(*((u_int32_t*)&MMTPh[16]));
+			return 0;
+}
+
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh)
+{
+			//8byte
+			memset(MPUh,0,MPUh_BUFF_LEN);
+
+//			mpu_header->length=0;
+//			mpu_header->FT=0;
+//			mpu_header->timed_Flag=0;
+//			mpu_header->f_i=0;
+//			mpu_header->aggregation_flag=0;
+//			mpu_header->fragment_counter=0;
+//			mpu_header->MPU_sequence_number=0;
+
+			*((u_int16_t*)&MPUh[0])=htons(mpu_header->length);
+			MPUh[2]=mpu_header->FT<<4
+					|(u_int8_t) mpu_header->timed_Flag<<3
+					|(u_int8_t) mpu_header->f_i<<1
+					|(u_int8_t) mpu_header->aggregation_flag;
+
+			MPUh[3]=(u_int8_t )mpu_header->fragment_counter;
+			*((u_int32_t*)&MPUh[4])=htonl(mpu_header->MPU_sequence_number);
+
+			return 0;
+}
+
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh)
+{
+	//8byte
+			mpu_header->length=ntohs(*((u_int16_t*)&MPUh[0]));
+			mpu_header->FT=(MPUh[2]>>4)&0x0F;
+			mpu_header->timed_Flag=(MPUh[2]>>3)&0x01;
+			mpu_header->f_i=(MPUh[2]>>1)&0x03;
+			mpu_header->aggregation_flag=(MPUh[2])&0x01;
+			mpu_header->fragment_counter=MPUh[3];
+			mpu_header->MPU_sequence_number=ntohl(*((u_int32_t*)&MPUh[4]));
+
+			return 0;
+}
+
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t)
+{
+	//14byte
+			memset(MFUh_t,0,MPUh_BUFF_LEN);
+
+	//		u_int32_t movie_fragment_sequence_number;
+	//			u_int32_t sample_number;
+	//			u_int32_t offset;
+	//			u_int8_t subsample_priority;
+	//			u_int8_t dependency_counter;
+//			mfu_time_header->movie_fragment_sequence_number=0;
+//			mfu_time_header->sample_number=0;
+//			mfu_time_header->offset=0;
+//			mfu_time_header->subsample_priority=0;
+//			mfu_time_header->dependency_counter=0;
+
+			*((u_int32_t*)&MFUh_t[0])=htonl(mfu_time_header->movie_fragment_sequence_number);
+			*((u_int32_t*)&MFUh_t[4])=htonl(mfu_time_header->sample_number);
+			*((u_int32_t*)&MFUh_t[8])=htonl(mfu_time_header->offset);
+			*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+			*((u_int8_t*)&MFUh_t[13])=(u_int8_t)mfu_time_header->dependency_counter;
+
+			return 0;
+}
+
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t)
+{
+			mfu_time_header->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&MFUh_t[0]));
+			mfu_time_header->sample_number=ntohl(*((u_int32_t*)&MFUh_t[4]));
+			mfu_time_header->offset=ntohl(*((u_int32_t*)&MFUh_t[8]));
+			mfu_time_header->subsample_priority=MFUh_t[12];
+			mfu_time_header->dependency_counter=MFUh_t[13];
+			return 0;
+}
+
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt)
+{
+	//4byte
+
+			memset(MFUh_nt,0,MFUh_nt_BUFF_LEN);
+
+			//u_int32_t Item_ID;
+			mfu_non_time_header->Item_ID=0;
+			*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header->Item_ID);
+
+			return 0;
+}
+
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt)
+{
+	//4byte
+			mfu_non_time_header->Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			return 0;
+}
+
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf)
+{
+	*((u_int32_t*)&mfu_sample_buf[0])=htonl(mfu_sample->sequence_number);
+	mfu_sample_buf[4]=mfu_sample->trackrefindex;
+	*((u_int32_t*)&mfu_sample_buf[5])=htonl(mfu_sample->movie_fragment_sequence_number);
+	*((u_int32_t*)&mfu_sample_buf[9])=htonl(mfu_sample->sample_number);
+	mfu_sample_buf[13]=mfu_sample->priority;
+	mfu_sample_buf[14]=mfu_sample->dependency_counter;
+	*((u_int32_t*)&mfu_sample_buf[15])=htonl(mfu_sample->offset);
+	*((u_int32_t*)&mfu_sample_buf[19])=htonl(mfu_sample->length);
+	*((u_int32_t*)&mfu_sample_buf[23])=htonl(mfu_sample->muli_length);
+	*((u_int32_t*)&mfu_sample_buf[27])=mfu_sample->muli_name;
+	*((u_int16_t*)&mfu_sample_buf[31])=htons(mfu_sample->muli_reserved1);
+	*((u_int8_t*)&mfu_sample_buf[33])=mfu_sample->muli_reserved2;
+			return 0;
+}
+
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf)
+{
+
+
+
+	mfu_sample->sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[0]));
+	mfu_sample->trackrefindex=mfu_sample_buf[4];
+	mfu_sample->sample_number=ntohl(*((u_int32_t*)&mfu_sample_buf[5]));
+	mfu_sample->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[9]));
+	mfu_sample->priority=mfu_sample_buf[13];
+	mfu_sample->dependency_counter=mfu_sample_buf[14];
+	mfu_sample->offset=ntohl(*((u_int32_t*)&mfu_sample_buf[15]));
+	mfu_sample->length=ntohl(*((u_int32_t*)&mfu_sample_buf[19]));
+	mfu_sample->muli_length=ntohl(*((u_int32_t*)&mfu_sample_buf[23]));
+	mfu_sample->muli_name=ntohl(*((u_int32_t*)&mfu_sample_buf[27]));
+	mfu_sample->muli_reserved1=ntohl(*((u_int16_t*)&mfu_sample_buf[31]));
+	mfu_sample->muli_reserved2=ntohl(*((u_int8_t*)&mfu_sample_buf[33]));
+			return 0;
+}
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh)
+{
+	//10 byte
+	*((u_int16_t*)&SMTh[0])=htons(smt_header->SPS);
+	*((u_int8_t*)&SMTh[2])=(u_int8_t)smt_header->SDC;
+	*((u_int16_t*)&SMTh[3])=htons(smt_header->LEN);
+	*((u_int16_t*)&SMTh[5])=htons(smt_header->TCH);
+	*((u_int16_t*)&SMTh[7])=htons(smt_header->RSV1);
+	*((u_int8_t*)&SMTh[9])=(u_int8_t)smt_header->RSV2;
+	return 0;
+
+}
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh)
+{
+	//10byte
+	smt_header->SPS=ntohs(*((u_int16_t*)&SMTh[0]));
+	smt_header->SPS=SMTh[2];
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[3]));
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[5]));
+	smt_header->RSV1=ntohs(*((u_int16_t*)&SMTh[7]));
+	smt_header->RSV2=SMTh[9];
+	return 0;
+
+}
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+	mp4_box_t *root = NULL;
+	mp4_box_t *moof = NULL;
+	stream_t* s = NULL;
+
+	s = create_file_stream();
+	if (stream_open(s, Fullpath, MODE_READ) == 0)
+	   return -1;
+
+	root = MP4_BoxGetRoot(s);
+	//
+	stream_seek(s, 0, 0);
+
+	mpu_metadata_t mpu_metadata;
+	fragment_metadata_t fragment_metadata;
+	mpu_metadata.start=0;
+	mpu_metadata.length=root->p_first->p_next->p_next->p_next->i_pos;
+	mpu_metadata.number=(mpu_metadata.length+MPU_BUFF_LEN-1)/(unsigned int)MPU_BUFF_LEN;
+
+	fragment_metadata.start=root->p_first->p_next->p_next->p_next->i_pos;
+	fragment_metadata.length=root->p_first->p_next->p_next->p_next->i_size+8;
+	fragment_metadata.number=(fragment_metadata.length+MPU_BUFF_LEN-1)/MPU_BUFF_LEN;
+
+	uint32_t mdat_start;
+	mdat_start=root->p_first->p_next->p_next->p_next->p_next->i_pos;
+
+	//send mpu_metadata
+	stream_seek(s, mpu_metadata.start, 0);
+	int counter;
+	for (counter=0;counter<mpu_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(mpu_metadata.number-1))
+		{
+			mpu_header.length=mpu_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=0;
+		mpu_header.timed_Flag=1;
+		if(mpu_metadata.number>1)
+		{	mpu_header.fragment_counter=mpu_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(mpu_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+		if(mpu_header.f_i==0 ||mpu_header.f_i==1 )
+		{
+			mmt_header.present_time=*MPU_present_time;
+		}
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+
+
+//		printf("send MPU_sequence_number %d mpu_metadata\n",MPU_sequence_number);
+
+	}
+	//send fragment_metadata
+	stream_seek(s, fragment_metadata.start, 0);
+	for (counter=0;counter<fragment_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(fragment_metadata.number-1))
+		{
+			mpu_header.length=fragment_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+					{
+						mpu_header.length=MPU_BUFF_LEN+6;
+					}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=1;
+		mpu_header.timed_Flag=1;
+		if(fragment_metadata.number>1)
+		{
+			mpu_header.fragment_counter=fragment_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(fragment_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+//		printf("send MPU_sequence_number %d fragment_metadata\n",MPU_sequence_number);
+
+	}
+	//send mfu
+
+	// first get sample number
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t samplenumber;
+	u_int32_t movie_fragment_sequence_number;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+
+
+	char mulibuff[34]={};
+	stream_seek(s, -34,2);
+	    int k;
+		k=stream_tell(s);
+	stream_read(s, mulibuff, 34);
+	sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+	trackrefindex=mulibuff[4];
+	movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+	samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+	priority=mulibuff[13];
+	dependency_counter=mulibuff[14];
+	//counter start from mdat (mdat position is 0)
+	offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+	length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+	int sample_total_number;
+	sample_total_number=samplenumber+1;
+
+	for (counter=0;counter<sample_total_number;counter++)
+	{
+		//get the sample
+		uint32_t mfu_time_offset=0;
+		stream_seek(s, -34*(sample_total_number-counter),2);
+		stream_read(s, mulibuff, 34);
+
+		sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+		trackrefindex=mulibuff[4];
+		movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+		samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+		priority=mulibuff[13];
+		dependency_counter=mulibuff[14];
+		//counter start from mdat (mdat position is 0)
+		offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+		length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+		stream_seek(s, offset+mdat_start, 0);
+
+		int sample_frag_number=0;
+		int sample_frag_counter=0;
+
+		sample_frag_number=(length+MFU_t_BUFF_LEN-1)/MFU_t_BUFF_LEN;
+
+		 for(sample_frag_counter=0;sample_frag_counter<sample_frag_number;sample_frag_counter++)
+		 {
+			 //8 byte
+			mpu_packet_header_t mpu_header;
+			unsigned char MPUh[MPUh_BUFF_LEN];
+
+			if(sample_frag_counter==(sample_frag_number-1))
+			{
+				mpu_header.length=length%MFU_t_BUFF_LEN+MFUh_t_BUFF_LEN+6;
+				if(length%MFU_t_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+			}
+			else
+			{
+				mpu_header.length=MPU_BUFF_LEN+6;
+			}
+
+			mpu_header.FT=2;
+			mpu_header.timed_Flag=1;
+			if(sample_frag_number>1)
+			{
+				mpu_header.fragment_counter=sample_frag_number;
+				if(sample_frag_counter==0)
+					mpu_header.f_i=1;
+				else if(sample_frag_counter==(sample_frag_number-1))
+				{
+					mpu_header.f_i=3;
+				}
+				else
+				{
+					mpu_header.f_i=2;
+				}
+			}
+			else
+			{
+				mpu_header.f_i=0;
+				mpu_header.fragment_counter=1;
+			}
+			mpu_header.aggregation_flag=0;
+			mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+			init_mpu_header(&mpu_header,MPUh);
+
+			//14byte
+			mfu_time_packet_header_t mfu_time_header;
+
+			unsigned char MFUh_t[MFUh_t_BUFF_LEN];
+
+			mfu_time_header.movie_fragment_sequence_number=movie_fragment_sequence_number;
+			mfu_time_header.sample_number=counter;
+			if(sample_frag_number==1)
+			{
+				mfu_time_header.offset=0;
+			}
+			else
+			{
+				mfu_time_header.offset=mfu_time_offset;
+				mfu_time_offset=mfu_time_offset+mpu_header.length-6-MFUh_t_BUFF_LEN;
+
+
+			}
+			mfu_time_header.subsample_priority=1;
+			mfu_time_header.dependency_counter=0;
+
+			init_mfu_time_header(&mfu_time_header,MFUh_t);
+
+	//
+	//		//4byte
+	//		mfu_non_time_packet_header_t mfu_non_time_header;
+	//		unsigned char MFUh_nt[MPUh_BUFF_LEN];
+	//
+	//
+	//		//u_int32_t Item_ID;
+	//		mfu_non_time_header.Item_ID=0;
+	//		*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header.Item_ID);
+	//
+	//		mfu_non_time_header.Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=0;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN],MFUh_t,MFUh_t_BUFF_LEN);
+//			int k;
+//			k=stream_tell(s);
+//			printf("stream_tell 1  %d ",k);
+			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN],mpu_header.length-6-MFUh_t_BUFF_LEN);
+//			k=stream_tell(s);
+//			printf("  %d ",k);
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+//			socklen_t len=sizeof(*to);
+//			sendto(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length,0,to,len);
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+			if(MPU_sequence_number==0 && counter ==0&& sample_frag_counter==86 )
+			{
+//				printf("breakpoint\n");
+			}
+//			printf("send MPU_sequence_number %d mfu counter%d  total sample %d +sample_frag_counter%d total sample_frag_number%d   fragment.length%d\n",MPU_sequence_number,counter,sample_total_number,sample_frag_counter,sample_frag_number,mpu_header.length-MFUh_t_BUFF_LEN);
+		 }
+//		 printf("finished send a sample total sample %d\n",sample_total_number);
+	  }
+	printf("finished send a mpu \n");
+
+
+   //ATOM BOX name like ATOM+Box_name,for example "ATOM_moof"
+   //moof=MP4_BoxSearchBox(root,ATOM_moof);
+   //MP4_BoxFree(s, moof);
+   //moof=NULL;
+   //int i;
+   //MP4_BoxSearchBox2(root,&moof,ATOM_moof);
+	//		   i=MP4_BoxSearchBox3(root,ATOM_moof);
+   free(moof);
+   MP4_BoxFree(s, root);
+
+   stream_close(s);
+   destory_file_stream(s);
+
+	 return 0;
+}
+
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+
+	mpu_packet_header_t mpu_header;
+	unsigned char MPUh[MPUh_BUFF_LEN];
+
+
+	mpu_header.length=6;
+	mpu_header.FT=3;
+	mpu_header.timed_Flag=0;
+
+	mpu_header.f_i=0;
+	mpu_header.fragment_counter=0;
+
+	mpu_header.aggregation_flag=0;
+	mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+	init_mpu_header(&mpu_header,MPUh);
+
+	//16byte
+	mmt_packet_header_t mmt_header;
+	unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+	mmt_header.version=0;
+	mmt_header.packet_counter_flag=1;
+	mmt_header.FEC_type=0;
+	mmt_header.reserved_1=0;
+	mmt_header.extension_flag=0;
+	mmt_header.RAP_flag=0;
+	mmt_header.reserved_2=0;
+	mmt_header.type=0;
+	mmt_header.packet_id=packet_id;
+	mmt_header.present_time=0;
+	mmt_header.timestamp=0;
+	mmt_header.packet_sequence_number=*packet_sequence_number;
+	mmt_header.packet_counter=(*packet_counter);
+
+	init_mmtp_header(&mmt_header,MMTPh);
+
+	char UDPbuff[UDP_BUFF_LEN]={};
+	memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+	memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+
+	send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+	if((*packet_counter)==maximum_value)
+		{
+			*packet_counter=0;
+		}
+	else
+		{
+		(*packet_counter)++;
+		}
+	if((*packet_sequence_number)==maximum_value)
+		{
+			*packet_sequence_number=0;
+		}
+	else
+		{
+		(*packet_sequence_number)++;
+		}
+ return 0;
+}
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh)
+{
+//	memset(PAh,0,PAh_BUFF_LEN );
+//7 byte
+	*((u_int16_t*)&PAh[0])=htons((u_int16_t)pa_header->message_id);
+	*((u_int8_t*)&PAh[2])=pa_header->version;
+	*((u_int32_t*)&PAh[3])=htonl(pa_header->length);
+	*((u_int8_t*)&PAh[7])=pa_header->number_of_tables;
+//	*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+    return 0;
+
+}
+int read_pa_message_header(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+
+    return 0;
+}
+
+int read_pa_message(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+	pa_message->table_header= (table_header_t *)malloc(sizeof(table_header_t )*pa_message->number_of_tables);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		read_table_header(&pa_message->table_header[i] ,&pa_message_buf[PAh_BUFF_LEN+sizeof(table_header_t )*i]);
+	}
+	//point to first table
+	int buff_seek=PAh_BUFF_LEN+sizeof(table_header_t )*pa_message->number_of_tables;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			read_pa_table(&pa_message->pa_table ,&pa_message_buf[buff_seek]);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			read_mp_table(&pa_message->mp_table ,&pa_message_buf[buff_seek]);
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			read_mpi_table(&pa_message->mpi_table,&pa_message_buf[buff_seek]);
+		}
+		//point to next table
+		buff_seek=buff_seek+table_header_LEN+pa_message->table_header[i].length;
+
+	}
+    return 0;
+}
+
+int free_pa_message(pa_message_t *pa_message)
+{
+	free(pa_message->table_header);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			free_pa_table(&pa_message->pa_table);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			free_mp_table(&pa_message->mp_table );
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			free_mpi_table(&pa_message->mpi_table);
+		}
+	}
+	return 0;
+}
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf)
+{
+	memset(table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&table_buf[0])=table_header->table_id;
+	*((u_int8_t*)&table_buf[1])=table_header->version;
+	*((u_int16_t*)&table_buf[2])=htons(table_header->length);
+    return 0;
+
+}
+
+int read_table_header(table_header_t *table_header ,const char *table_buf)
+{
+
+	table_header->table_id=*((u_int8_t*)&table_buf[0]);
+	table_header->version=*((u_int8_t*)&table_buf[1]);
+	table_header->length=ntohs(*((u_int16_t*)&table_buf[2]));
+	return 0;
+
+}
+
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf)
+{
+	memset(PA_table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&PA_table_buf[0])=pa_table->table_id;
+	*((u_int8_t*)&PA_table_buf[1])=pa_table->version;
+	*((u_int16_t*)&PA_table_buf[2])=htons(pa_table->length);
+
+    return 0;
+
+}
+
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf)
+{
+
+	pa_table->table_id=*((u_int8_t*)&PA_table_buf[0]);
+	pa_table->version=*((u_int8_t*)&PA_table_buf[1]);
+	pa_table->length=ntohs(*((u_int16_t*)&PA_table_buf[2]));
+	pa_table->pat_content=(unsigned  char*) malloc(pa_table->length*sizeof( unsigned  char));
+	memcpy(pa_table->pat_content,&PA_table_buf[4],pa_table->length);
+	//pa_table->pat_content=*((char *)&PA_table_buf[4]);
+    return 0;
+
+}
+int free_pa_table(pa_table_t *pa_table )
+{
+
+	free(pa_table->pat_content);
+    return 0;
+
+}
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf)
+{
+//	memset(mp_table_buf,0,1024);
+	unsigned char *mp_table_buf_tmp= (unsigned   char*) malloc((4+mp_table->length)*sizeof( unsigned   char));
+	if(mp_table_buf_tmp==NULL)
+		{
+			puts ("Memory allocation failed.");
+			 exit (EXIT_FAILURE);
+		}
+
+	*((u_int8_t*)&mp_table_buf_tmp[0])=mp_table->table_id;
+	*((u_int8_t*)&mp_table_buf_tmp[1])=mp_table->version;
+	*((u_int16_t*)&mp_table_buf_tmp[2])=htons(mp_table->length);
+
+	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->number_of_assets;
+//	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->MP_table_asset[0].Identifier_mapping.identifier_type;
+	u_int32_t  i,seekpoint=5;
+
+	for (i=0;i<mp_table->number_of_assets;i++)
+	{
+		memcpy(&mp_table_buf_tmp[seekpoint],"URL",strlen("URL"));
+		memcpy(&mp_table_buf_tmp[seekpoint+3],"\0",1);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+4])=mp_table->MP_table_asset[i].Identifier_mapping.URL_length;
+		memcpy(&mp_table_buf_tmp[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+		*((u_int32_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length])=htonl(mp_table->MP_table_asset[i].asset_type);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4])=mp_table->MP_table_asset[i].asset_clock_relation_flag;
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5])=mp_table->MP_table_asset[i].location_count;
+		*((u_int16_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6])=htons(mp_table->MP_table_asset[i].asset_descriptors_length);
+
+		memcpy(&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_byte,mp_table->MP_table_asset[i].asset_descriptors_length);
+	//	*((u_int8_t*)&mp_table_buf_tmp[3])=mp_table->Identifier_mapping->URL_length;
+		seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+	}
+	*mp_table_buf=mp_table_buf_tmp;
+ return 0;
+}
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf)
+{
+
+	mp_table->table_id=*((u_int8_t*)&mp_table_buf[0]);
+	mp_table->version=*((u_int8_t*)&mp_table_buf[1]);
+	mp_table->length=ntohs(*((u_int16_t*)&mp_table_buf[2]));
+	mp_table->number_of_assets=*((u_int8_t*)&mp_table_buf[4]);
+	mp_table->MP_table_asset= (MP_table_asset_t *)malloc(sizeof(MP_table_asset_t)*mp_table->number_of_assets);
+
+	u_int32_t  i,seekpoint=5;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			//memcpy(&mp_table_buf[seekpoint],"URL",strlen("URL"));
+			//memcpy(&mp_table_buf[seekpoint+3],"\0",1);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_length=*((u_int8_t*)&mp_table_buf[seekpoint+4]);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].Identifier_mapping.URL_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,&mp_table_buf[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+			mp_table->MP_table_asset[i].asset_type=ntohl(*((u_int32_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length]));
+			mp_table->MP_table_asset[i].asset_clock_relation_flag=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4]);
+			mp_table->MP_table_asset[i].location_count=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5]);
+			mp_table->MP_table_asset[i].asset_descriptors_length=ntohs(*((u_int16_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6]));
+			mp_table->MP_table_asset[i].asset_descriptors_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].asset_descriptors_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].asset_descriptors_byte,&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_length);
+		//	*((u_int8_t*)&mp_table_buf[3])=mp_table->Identifier_mapping->URL_length;
+			seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+
+		}
+
+
+return 0;
+}
+
+int free_mp_table(mp_table_t *mp_table )
+{
+	u_int32_t  i;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			free(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte);
+			free(mp_table->MP_table_asset[i].asset_descriptors_byte);
+		}
+	free(mp_table->MP_table_asset);
+	return 0;
+
+}
+
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf)
+{
+//	memset(mpi_table_buf1,0,1024);
+
+	unsigned char *mpi_table_buf_tmp= (unsigned   char*) malloc((4+mpi_table->length)*sizeof( unsigned   char));
+	 if(mpi_table_buf_tmp==NULL)
+	 		{
+	 			puts ("Memory allocation failed.");
+	 			 exit (EXIT_FAILURE);
+	 		}
+
+	*((u_int8_t*)&mpi_table_buf_tmp[0])=mpi_table->table_id;
+	*((u_int8_t*)&mpi_table_buf_tmp[1])=mpi_table->version;
+	*((u_int16_t*)&mpi_table_buf_tmp[2])=htons(mpi_table->length);
+
+	*((u_int16_t*)&mpi_table_buf_tmp[4])=htons(mpi_table->PI_mode);
+
+	u_int32_t  i,seekpoint=6;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint])=(u_int8_t)(i+1);
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint+1])=mpi_table->PI_content[i].PI_content_name_length;
+//		memcpy(&mpi_table_buf_tmp[seekpoint+1] , mpi_table->PI_content[i].PI_content_name_length , 1);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_byte , mpi_table->PI_content[i].PI_content_name_length);
+		*((u_int16_t*)&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length])=htons(mpi_table->PI_content[i].PI_content_length);
+//		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length] , mpi_table->PI_content[i].PI_content_length , 2);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_byte , mpi_table->PI_content[i].PI_content_length);
+		seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+	}
+//	printf("seekpoint%d\n",seekpoint);
+//	printf("seek%s\n",mpi_table_buf_tmp);
+//	printf("seek%c\n",mpi_table_buf_tmp[8]);
+
+
+
+//	pseudogram = malloc(psize);
+//	memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+//	memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+	*mpi_table_buf=mpi_table_buf_tmp;
+//	int j;
+//	for(j=0;j<mpi_table->length+4;j++)
+//		{
+//			printf("%c",*mpi_table_buf_tmp++);
+//		}
+//	printf("\n");
+ return 0;
+}
+
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
+{
+		mpi_table->table_id=*((u_int8_t*)&mpi_table_buf[0]);
+		mpi_table->version=*((u_int8_t*)&mpi_table_buf[1]);
+		mpi_table->length=htons(*((u_int16_t*)&mpi_table_buf[2]));
+
+		mpi_table->PI_mode=htons(*((u_int16_t*)&mpi_table_buf[4]));
+		//temp var
+		mpi_table->PI_content_count=2;
+		mpi_table->PI_content= (PI_content_t *)malloc(sizeof(PI_content_t )*mpi_table->PI_content_count);
+		u_int32_t  i,seekpoint=6;
+
+		for (i=0;i<mpi_table->PI_content_count;i++)
+		{
+			//*((u_int8_t*)&mpi_table_buf[seekpoint])=(u_int8_t)(i+1);
+			mpi_table->PI_content[i].PI_content_name_length=*((u_int8_t*)&mpi_table_buf[seekpoint+1]);
+			mpi_table->PI_content[i].PI_content_name_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_name_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_name_byte,0,(mpi_table->PI_content[i].PI_content_name_length+1));
+//			printf("mpi_table->PI_content[i].PI_content_name_length%d\n",mpi_table->PI_content[i].PI_content_name_length);
+			memcpy(mpi_table->PI_content[i].PI_content_name_byte , &mpi_table_buf[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_length);
+			mpi_table->PI_content[i].PI_content_length=htons(*((u_int16_t*)&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length]));
+			mpi_table->PI_content[i].PI_content_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_byte,0,(mpi_table->PI_content[i].PI_content_length+1));
+			memcpy( mpi_table->PI_content[i].PI_content_byte ,&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_length);
+			seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+
+
+			FILE *mpi;
+			if((mpi=fopen((char *)mpi_table->PI_content[i].PI_content_name_byte,"w+"))==NULL)
+					{
+						printf("not open");
+						exit(0);
+					}
+			fwrite(mpi_table->PI_content[i].PI_content_byte,mpi_table->PI_content[i].PI_content_length,1,mpi);
+			fclose(mpi);
+		}
+	 return 0;
+
+}
+
+int free_mpi_table(mpi_table_t *mpi_table)
+{
+	u_int32_t  i;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		free(mpi_table->PI_content[i].PI_content_name_byte);
+		free(mpi_table->PI_content[i].PI_content_byte);
+
+	}
+	free(mpi_table->PI_content);
+	return 0;
+}
+int init_signal_header(signal_header_t *signal_header,unsigned char *Signal_h)
+
+{
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->res<<2
+								|(u_int8_t) signal_header->H<<1
+								|(u_int8_t) signal_header->A;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+int read_signal_header(signal_header_t *signal_header,const char *Signal_h)
+
+{
+	signal_header->f_i=(Signal_h[0]>>6)&0x03;
+	signal_header->res=(Signal_h[0]>>2)&0x0f;
+	signal_header->H=(Signal_h[0]>>1)&0x01;
+	signal_header->A=(Signal_h[0])&0x01;
+	signal_header->frag_counter=Signal_h[1];
+	signal_header->MSG_length1=ntohs(*((u_int16_t*)&Signal_h[2]));
+
+
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->H<<2
+								|(u_int8_t) signal_header->A<<1;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id)
+{
+		int pa_sequence_number=(pa_header->length+4+MMTP_BUFF_LEN-1)/(unsigned int)MMTP_BUFF_LEN;;
+		int pa_length=pa_header->length+PAh_BUFF_LEN;
+		u_int32_t buf_seekpoint=0;
+
+		int counter;
+		for (counter=0;counter<pa_sequence_number;counter++)
+		{
+			signal_header_t signal_header;
+			if(counter==(pa_sequence_number-1))
+			{
+				signal_header.MSG_length1=pa_length%signal_BUFF_LEN;
+				//
+				if(pa_length%MMTP_BUFF_LEN==0)
+					{
+					signal_header.MSG_length1=signal_BUFF_LEN;
+					}
+			}
+			else
+			{
+				signal_header.MSG_length1=signal_BUFF_LEN;
+			}
+			signal_header.f_i=0;
+			signal_header.res=0;
+			signal_header.H=0;
+			signal_header.A=0;
+			signal_header.frag_counter=0;
+
+			if(pa_sequence_number>1)
+			{	signal_header.frag_counter=pa_sequence_number;
+				if(counter==0)
+					signal_header.f_i=1;
+				else if(counter==(pa_sequence_number-1))
+				{
+					signal_header.f_i=3;
+				}
+				else
+				{
+					signal_header.f_i=2;
+				}
+			}
+			else
+			{
+				signal_header.f_i=0;
+				signal_header.frag_counter=1;
+			}
+			signal_header.A=0;
+
+			unsigned char Signal_h[Signal_h_BUFF_LEN]={};
+			init_signal_header(&signal_header,Signal_h);
+
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=2;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			//diyige jia tou
+			if (signal_header.f_i==1)
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+			}
+			else
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+
+			}
+			buf_seekpoint=buf_seekpoint+signal_header.MSG_length1;
+//			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length);
+
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+Signal_h_BUFF_LEN+signal_header.MSG_length1,to);
+
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+		}
+		printf("finished send signal\n");
+return 0;
+
+}
+
+
+
+
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to)
+
+{
+
+	int n;
+	struct timeval udp_delay;
+	udp_delay.tv_sec = 0;
+	udp_delay.tv_usec = 50; // 50 us
+	select(0, NULL, NULL, NULL, &udp_delay);
+//	printf("tmp%s/n",*tmp[1]);
+	socklen_t len=sizeof(*to);
+	n=sendto(ss,UDPbuff,length,0,to,len);
+	if(n <=0)
+	{
+		perror("send error");
+		puts ("send error");
+		exit (EXIT_FAILURE);
+		return -1;
+	}
+
+//	send_raw_udp(UDPbuff,length);
+	return 0;
+}
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf )
+//{
+//	free(mfu_buf->data);
+//	return 0;
+//}
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf )
+{
+	free(mpu_metadata_buf.data);
+	return 0;
+}
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf )
+{
+	free(fragment_metadata_buf.data);
+	return 0;
+}
+int free_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	free_mpu_metadata_buf(mpu_buf->mpu_metadata_buf);
+	free_fragment_metadata_buf(mpu_buf->fragment_metadata_buf);
+	int i;
+	for(i=0;i<mpu_buf->mfu_number;i++)
+	{
+		free(mpu_buf->mfu[i].data);
+	}
+	free(mpu_buf->mfu);
+	free(mpu_buf->mfu_sample);
+	free(mpu_buf->MPU_sequence_data);
+	return 0;
+}
+int init_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	mpu_buf->packet_id=0;
+	mpu_buf->MPU_sequence_number=0;
+	mpu_buf->flag=0;
+	mpu_buf->mfu_number=0;
+	mpu_buf->mfu_counter=0;
+	mpu_buf->MPU_sequence_length=0;
+	return 0;
+}
diff --git a/net/mmt/mmtp/mmt.h b/net/mmt/mmtp/mmt.h
new file mode 100644
index 0000000..3ecd828
--- /dev/null
+++ b/net/mmt/mmtp/mmt.h
@@ -0,0 +1,464 @@
+#ifndef NET_MMT_MMTP_MMT_H_
+#define NET_MMT_MMTP_MMT_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "DList.h"
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+
+//#define eth_BUFF_LEN 1500
+//
+//#define IPh_BUFF_LEN 20
+//#define IP_BUFF_LEN 1480
+//
+//#define UDPh_BUFF_LEN 8
+//#define UDP_BUFF_LEN 1472
+//
+//#define MMTPh_BUFF_LEN 20
+//#define MMTP_BUFF_LEN 1452
+//
+//#define signalh_BUFF_LEN 4
+//#define signal_BUFF_LEN 1448
+//#define MPUh_BUFF_LEN 8
+//#define MPU_BUFF_LEN 1444
+//#define MFUh_t_BUFF_LEN 14
+//#define MFU_t_BUFF_LEN 1430
+//#define MFUh_nt_BUFF_LEN 4
+//#define MFU_nt_BUFF_LEN 1440
+//#define maximum_value 4294967295
+//#define SMTh_BUFF_LEN 10
+//
+//#define PAh_BUFF_LEN 7
+//#define PAth_BUFF_LEN 4
+//#define th_BUFF_LEN 4
+//#define Signal_h_BUFF_LEN 4
+//
+//#define table_header_LEN 4
+//#define PA_message_header_LEN 7
+
+#define eth_BUFF_LEN 1500
+
+#define IPh_BUFF_LEN 20
+#define IP_BUFF_LEN 1480
+
+#define UDPh_BUFF_LEN 8
+#define UDP_BUFF_LEN 1500
+
+#define MMTPh_BUFF_LEN 20
+#define MMTP_BUFF_LEN 1480
+
+#define signalh_BUFF_LEN 4
+#define signal_BUFF_LEN 1476
+#define MPUh_BUFF_LEN 8
+#define MPU_BUFF_LEN 1472
+#define MFUh_t_BUFF_LEN 14
+#define MFU_t_BUFF_LEN 1458
+#define MFUh_nt_BUFF_LEN 4
+#define MFU_nt_BUFF_LEN 1428
+#define maximum_value 4294967295
+#define SMTh_BUFF_LEN 10
+
+#define PAh_BUFF_LEN 8
+#define PAth_BUFF_LEN 4
+#define th_BUFF_LEN 4
+#define Signal_h_BUFF_LEN 4
+
+#define table_header_LEN 4
+
+
+typedef struct MMT_config //16Byte
+{
+	char *video_dir;
+	char **video_List;
+	//char **video_Fullpath;
+	int32_t video_id;
+	u_int32_t videoCount;
+
+	char *audio_dir;
+	char **audio_List;
+	//char **audio_Fullpath;
+	u_int32_t audioCount;
+	int32_t audio_id;
+
+	char *ci_dir;
+	int32_t ci_id;
+	char *to_addr;
+	int16_t to_port;
+
+//samsung
+	int32_t session_num;
+	char *mode;
+	int16_t listen_port;
+	char *multicast_ip;
+	int16_t multicast_port;
+	int32_t time_delay;
+	char *broadband_root;
+	char *broadcast_root;
+	int32_t fec ;
+	int32_t qos ;
+	char *log_path;
+	char *controller;
+	int32_t max_client_num;
+	char *res_map_file;
+	char *broadcast_default_ci;
+	char *broadcast_default_html;
+	int16_t multiview_port;
+
+}mmt_config_t;
+
+typedef struct MPU_metadata_s //Byte
+{
+	 u_int32_t start;
+	 u_int32_t length;
+	 u_int32_t number;
+}mpu_metadata_t;
+
+typedef struct Fragment_metadata_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}fragment_metadata_t;
+
+typedef struct MFU_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}mfu_t;
+
+typedef struct MMT_packet_header_s //16Byte
+{
+    u_int8_t version:2;
+    u_int8_t packet_counter_flag:1;
+    u_int8_t FEC_type:2;
+    u_int8_t reserved_1:1;
+    u_int8_t extension_flag:1;
+    u_int8_t RAP_flag:1;
+    u_int8_t reserved_2:2;
+    u_int8_t type:6;
+    u_int16_t packet_id;
+    u_int32_t present_time;
+    u_int32_t timestamp;
+    u_int32_t packet_sequence_number;
+    u_int32_t packet_counter;
+}mmt_packet_header_t,*pmmt_packet_header_t;
+
+typedef struct MMT_packet_header_extension_header_s//4Byte
+{
+	u_int16_t type;
+	u_int16_t length;
+    //no header extension
+    //no FEC
+}mmt_packet_header_extension_header_t,*pmmt_packet_header_extension_header_t;
+
+
+typedef struct MPU_packet_header_s //8Byte
+{
+
+	u_int16_t length;
+	u_int8_t FT:4;//mpu_fragment_type
+	u_int8_t timed_Flag:1;
+	u_int8_t f_i:2;//fragmentation_indicator
+	u_int8_t aggregation_flag:1;
+	u_int8_t fragment_counter;
+	u_int32_t MPU_sequence_number;
+    //no MFU
+    //for non-time
+
+}mpu_packet_header_t,*pmpu_packet_header_t;
+
+typedef struct MFU_time_packet_header_s //14Byte
+{
+	u_int32_t movie_fragment_sequence_number;
+	u_int32_t sample_number;
+	u_int32_t offset;
+	u_int8_t subsample_priority;
+	u_int8_t dependency_counter;
+    //for time
+}mfu_time_packet_header_t,*pmfu_time_packet_header_t;
+
+typedef struct MFU_non_time_packet_header_s //4Byte
+{
+	u_int32_t Item_ID;
+    //for time
+}mfu_non_time_packet_header_t,*pmfu_non_time_packet_header_t;
+
+typedef struct SMT_packet_header_s //4Byte
+{
+	u_int16_t SPS;
+	u_int8_t SDC;
+	u_int16_t LEN;
+	u_int16_t TCH;
+	u_int16_t RSV1;
+	u_int8_t RSV2;
+    //for time
+}smt_packet_header_t;
+
+typedef struct signal_header_s //4Byte
+{
+	u_int8_t f_i:2;
+	u_int8_t res:4;
+	u_int8_t H:1;
+	u_int8_t A:1;
+	u_int8_t frag_counter;
+	u_int16_t MSG_length1;
+	u_int32_t MSG_length2;
+
+    //for time
+}signal_header_t;
+
+typedef struct table_header_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+}table_header_t;
+
+
+typedef struct Identifier_mapping_s //4Byte
+{
+	u_int8_t identifier_type;
+	u_int8_t URL_length;
+	unsigned  char *URL_byte;
+
+
+}Identifier_mapping_t;
+
+typedef struct pa_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	unsigned char *pat_content;
+}pa_table_t;
+
+
+
+typedef struct MP_table_asset_s
+{
+	Identifier_mapping_t Identifier_mapping;
+	u_int32_t asset_type;
+	u_int8_t asset_clock_relation_flag;
+	u_int8_t location_count;
+	u_int16_t asset_descriptors_length;
+	unsigned char *asset_descriptors_byte;
+}MP_table_asset_t;
+
+typedef struct mp_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	u_int8_t number_of_assets;
+	MP_table_asset_t *MP_table_asset;
+}mp_table_t;
+
+
+typedef struct PI_content_s //4Byte
+{
+//	u_int8_t PI_content_type_length;
+//	char * PI_content_type_length_byte;
+	//yes
+	u_int8_t PI_content_name_length;
+	unsigned char * PI_content_name_byte;
+	//no use
+//	u_int8_t PI_content_descriptors_length;
+//	char * PI_content_descriptors_byte;
+	//yes
+	u_int16_t PI_content_length;
+	unsigned char * PI_content_byte;
+}PI_content_t,*pPI_content_t;
+
+typedef struct mpi_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	//bu dui
+//	u_int8_t PI_mode:2;
+	u_int16_t PI_mode;
+	//use wrong
+	u_int8_t PI_content_count;
+	PI_content_t *PI_content;
+}mpi_table_t;
+
+//client
+
+typedef struct pa_message_s //8Byte
+{
+	u_int16_t message_id;
+	u_int8_t version;
+	u_int32_t length;// new version
+	u_int8_t number_of_tables;
+	table_header_t *table_header;
+	pa_table_t pa_table ;
+	mp_table_t mp_table;
+	mpi_table_t mpi_table;
+}pa_message_t;
+
+typedef struct signal_buf_s //4Byte
+{
+
+	char * buf_pool;
+	char * block_fill_flag;
+	u_int32_t block_number;
+	u_int8_t buff_status; 
+	u_int16_t packet_id; 
+}signal_buf_t,*psignal_buf_t;
+
+typedef struct mfu_buf_s //30Byte
+{
+	unsigned  char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mfu_buf_t,*pmfu_buf_t;
+
+// first get sample number
+typedef struct mfu_sample_s //30Byte
+{
+u_int32_t sequence_number;
+u_int8_t trackrefindex;
+u_int32_t movie_fragment_sequence_number;
+u_int32_t sample_number;
+u_int8_t priority;
+u_int8_t dependency_counter;
+u_int32_t offset;
+u_int32_t length;
+u_int32_t muli_length;
+u_int32_t muli_name;
+u_int16_t muli_reserved1;
+u_int8_t muli_reserved2;
+
+}mfu_sample_t,*pmfu_sample_t;
+
+typedef struct mpu_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mpu_metadata_buf_t,*pmpu_metadata_buf_t;
+
+typedef struct fragment_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}fragment_metadata_buf_t,*pfragment_metadata_buf_t;
+
+typedef struct mpu_buf_s //
+{
+	u_int16_t packet_id; 
+	u_int32_t MPU_sequence_number; 
+
+	mpu_metadata_buf_t  mpu_metadata_buf;
+	fragment_metadata_buf_t fragment_metadata_buf;
+
+	u_int8_t flag ;
+	u_int32_t mfu_number;
+	u_int32_t mfu_counter;
+	mfu_buf_t *mfu;
+	mfu_sample_t *mfu_sample;
+	u_int32_t MPU_sequence_length;
+	unsigned char * MPU_sequence_data;
+}mpu_buf_t,*pmpu_buf_t;
+
+
+//typedef struct mpu_s //
+//{
+//
+//	char * buf_pool;
+//	char *buf_pool_end; // end of data buffer
+//	char * block_fill_flag;
+//	u_int32_t capacity;// maximum number of items in the buffer
+//	u_int32_t count;// number of items in the buffer
+//	u_int32_t block_size;// size of each item in the buffer
+//	u_int8_t buff_status;
+//	u_int16_t packet_id;
+//	u_int32_t MPU_sequence_number;
+//	DList *mpu_metadata;
+//	DList *fragmen_metadata;
+//	DList *mfu;
+//}mpu_t,*pmpu_t;
+
+
+
+int get_MMT_timestamp();
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh);
+int read_mmtp_header(mmt_packet_header_t *mmt_header,const char *MMTPh);
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh);
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh);
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t);
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t);
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt);
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt);
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf);
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf);
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh);
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh);
+
+int init_signal_header(signal_header_t *signal_header,unsigned char *signal_h);
+int read_signal_header(signal_header_t *signal_header,const char *signal_h);
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh);
+int read_pa_message_header(pa_message_t *pa_header,const char *PAh);
+int read_pa_message(pa_message_t *pa_header,const char *PAh);
+int free_pa_message(pa_message_t *pa_header);
+
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf);
+int read_table_header(table_header_t *table_header ,const char *table_buf);
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf);
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf);
+int free_pa_table(pa_table_t *pa_table);
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf);
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf);
+int free_mp_table(mp_table_t *mp_table );
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf);
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf);
+int free_mpi_table(mpi_table_t *mpi_table);
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id);
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number);
+
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf );
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf );
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf );
+int free_mpu_buf(mpu_buf_t *mpu_buf );
+int init_mpu_buf(mpu_buf_t *mpu_buf );
+
+#endif
diff --git a/net/mmt/mmtp/mmtp.gyp b/net/mmt/mmtp/mmtp.gyp
new file mode 100644
index 0000000..7c2bc3f
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.gyp
@@ -0,0 +1,93 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmmtp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mmtp',
+      'sources': [
+        'DList.c',
+        'Mlist.c',
+        'client.c',
+        'getfile.c',
+        'ini.c',
+        'mmt.c',
+        'ringq.c',  
+        'send.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
new file mode 100644
index 0000000..00c02cb
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.h
@@ -0,0 +1,64 @@
+#ifndef NET_MMT_MMTP_MMTP_H_
+#define NET_MMT_MMTP_MMTP_H_
+
+#include "mmt.h"
+
+#if 0
+//
+pthread_mutex_t mpu_mutex;							/**/
+pthread_mutex_t signal_mutex;						/**/
+pthread_mutex_t mpu_list_mutex;						/**/
+
+pthread_t signal_consumer_t;						/**/
+pthread_t mpu_consumer_t;						/**/
+pthread_t producter_t;						/**/
+
+DList *signal_buff_list;
+DList *mpu_buff_list;
+
+int signal_buffer_has_item=0;							/**/
+int mpu_buffer_has_item=0;							/**/
+
+//mpu_buf_t,mpu
+mpu_buf_t *mpu_list;
+
+//
+int mmt_socket;
+#endif
+
+//IP,,,
+int InitMMTP(char *listen_ip, int16_t listen_port);
+
+//MPU,packet_idmpu_sequence_number,packet_idasset
+//MPU,,
+int AddMpu(mpu_buf_t *mpu_list);
+
+//MPU
+int RefreshMpu(mpu_buf_t *mpu_list);
+
+//,IP,
+int UninitMMTP();
+
+
+typedef void (*message_callback_func_t)(pa_message_t *pa_message);
+//,,pa_message
+void SetMessageCallback(message_callback_func_t func,pa_message_t *pa_message);
+
+//
+void Message_func(pa_message_t *pa_message);
+
+
+typedef void (*mpu_callback_func_t)(mpu_buf_t *mpu_buf);
+//MPU,,MPU
+void SetCICallback(mpu_callback_func_t func,mpu_buf_t *mpu_buf);
+
+//
+void Mpu_func(mpu_buf_t *mpu_buf);
+
+//,,,
+int QueryMessageResource(char* mmt_url, char* ci_fname,  int size);
+
+//,MPU,,mpu_buf_t,mpu_list
+int QueryMPUResource(mpu_buf_t *mpu_list, u_int32_t sequence,  u_int32_t packet_id);
+
+#endif
diff --git a/net/mmt/mmtp/ringq.c b/net/mmt/mmtp/ringq.c
new file mode 100644
index 0000000..8eca6b2
--- /dev/null
+++ b/net/mmt/mmtp/ringq.c
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include "ringq.h"
+#include <stdlib.h>
+#include <string.h>
+
+int ringq_init(RINGQ * p_queue)
+{
+   p_queue->size = QUEUE_MAX ;
+   
+   p_queue->head = 0;
+   p_queue->tail = 0;
+   
+   p_queue->tag = 0;
+   
+   return 0;
+}
+
+int ringq_free(RINGQ * p_queue)
+{
+  return 0;
+}
+
+
+int ringq_push(RINGQ * p_queue,int data)
+{
+//  print_ringq(p_queue);
+  
+  if(ringq_is_full(p_queue))
+   {
+     
+     printf("ringq is full\n");
+     return -1;
+   }
+      
+   p_queue->space[p_queue->tail] = data;
+   
+   p_queue->tail = (p_queue->tail + 1) % p_queue->size ;
+   
+   /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 1;
+    }
+
+    return p_queue->tag ;  
+}
+
+int ringq_poll(RINGQ * p_queue,int * p_data)
+{
+//   print_ringq(p_queue);
+  if(ringq_is_empty(p_queue))
+   {
+      
+      printf("ringq is empty\n");
+     return -1;
+   }
+   
+   *p_data = p_queue->space[p_queue->head];
+   
+   p_queue->head = (p_queue->head + 1) % p_queue->size ;
+   
+    /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 0;
+    }    
+    return p_queue->tag ;
+}
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+
+
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz)
+{
+    cb->buffer = malloc(capacity * sz);
+    if(cb->buffer == NULL)
+        // handle error
+    cb->buffer_end = (char *)cb->buffer + capacity * sz;
+    cb->capacity = capacity;
+    cb->count = 0;
+    cb->sz = sz;
+    cb->head = cb->buffer;
+    cb->tail = cb->buffer;
+}
+
+void cb_free(circular_buffer *cb)
+{
+    free(cb->buffer);
+    // clear out other fields too, just to be safe
+}
+
+void cb_push_back(circular_buffer *cb, const void *item)
+{
+    if(cb->count == cb->capacity)
+        // handle error
+    memcpy(cb->head, item, cb->sz);
+    cb->head = (char*)cb->head + cb->sz;
+    if(cb->head == cb->buffer_end)
+        cb->head = cb->buffer;
+    cb->count++;
+}
+
+void cb_pop_front(circular_buffer *cb, void *item)
+{
+    if(cb->count == 0)
+        // handle error
+    memcpy(item, cb->tail, cb->sz);
+    cb->tail = (char*)cb->tail + cb->sz;
+    if(cb->tail == cb->buffer_end)
+        cb->tail = cb->buffer;
+    cb->count--;
+}
diff --git a/net/mmt/mmtp/ringq.h b/net/mmt/mmtp/ringq.h
new file mode 100644
index 0000000..f6241c9
--- /dev/null
+++ b/net/mmt/mmtp/ringq.h
@@ -0,0 +1,65 @@
+#ifndef NET_MMT_MMTP_RINGQ_H_
+#define NET_MMT_MMTP_RINGQ_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+#define QUEUE_MAX 1500
+/*
+
+http://blog.csdn.net/sking002007/article/details/6584590
+
+*/
+typedef struct ringq{
+   int head; /* */
+   int tail; /* */ 
+   int tag ; /* */
+    int size ; /*  */
+   int space[QUEUE_MAX]; /*  */
+}RINGQ;
+
+/* 
+  :
+     head == tail tag = 0  = 1 
+*/
+
+extern int ringq_init(RINGQ * p_queue);
+
+extern int ringq_free(RINGQ * p_queue);
+
+
+/*  */
+extern int ringq_push(RINGQ * p_queue,int data);
+
+/*  */
+extern int ringq_poll(RINGQ * p_queue,int *p_data);
+
+
+#define ringq_is_empty(q) ( (q->head == q->tail) && (q->tag == 0))
+
+#define ringq_is_full(q) ( (q->head == q->tail) && (q->tag == 1))
+
+#define print_ringq(q) printf("ring head %d,tail %d,tag %d\n", q->head,q->tail,q->tag);
+#ifdef __cplusplus
+}
+#endif 
+
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+typedef struct circular_buffer
+{
+    void *buffer;     // data buffer
+    void *buffer_end; // end of data buffer
+    size_t capacity;  // maximum number of items in the buffer
+    size_t count;     // number of items in the buffer
+    size_t sz;        // size of each item in the buffer
+    void *head;       // pointer to head
+    void *tail;       // pointer to tail
+} circular_buffer;
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz);
+void cb_free(circular_buffer *cb);
+void cb_push_back(circular_buffer *cb, const void *item);
+void cb_pop_front(circular_buffer *cb, void *item);
+
+#endif
diff --git a/net/mmt/mmtp/send.c b/net/mmt/mmtp/send.c
new file mode 100644
index 0000000..7a783d0
--- /dev/null
+++ b/net/mmt/mmtp/send.c
@@ -0,0 +1,199 @@
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+#include "send.h"
+#include <arpa/inet.h>
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "mmt.h"
+/*
+    Generic checksum calculation function
+*/
+unsigned short csum(unsigned short *ptr,int nbytes)
+{
+    register long sum;
+    unsigned short oddbyte;
+    register short answer;
+
+    sum=0;
+    while(nbytes>1) {
+        sum+=*ptr++;
+        nbytes-=2;
+    }
+    if(nbytes==1) {
+        oddbyte=0;
+        *((u_char*)&oddbyte)=*(u_char*)ptr;
+        sum+=oddbyte;
+    }
+
+    sum = (sum>>16)+(sum & 0xffff);
+    sum = sum + (sum>>16);
+    answer=(short)~sum;
+
+    return(answer);
+}
+
+int send_raw_udp(char *UDPbuff,int length)
+{
+    //Create a raw socket of type IPPROTO
+    int s = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
+
+    if(s == -1)
+    {
+        //socket creation failed, may be because of non-root privileges
+        perror("Failed to create raw socket");
+        exit(1);
+    }
+
+    //Datagram to represent the packet
+    char datagram[4096] , source_ip[32] , *data , *pseudogram;
+
+    //zero out the packet buffer
+    memset (datagram, 0, 4096);
+
+    //IP header
+    struct iphdr *iph = (struct iphdr *) datagram;
+
+    //UDP header
+    struct udphdr *udph = (struct udphdr *) (datagram + sizeof (struct ip));
+
+    struct sockaddr_in sin;
+    struct pseudo_header psh;
+
+    //Data part
+
+
+
+    memcpy(&datagram[sizeof(struct iphdr) + sizeof(struct udphdr)],UDPbuff,length);
+    data = &datagram[sizeof(struct iphdr) + sizeof(struct udphdr)];
+    //some address resolution
+    strcpy(source_ip , "172.16.7.44");
+
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons(80);
+    sin.sin_addr.s_addr = inet_addr ("224.1.1.100");
+
+    //Fill in the IP Header
+    iph->ihl = 5;
+    iph->version = 4;
+    iph->tos = 0;
+    iph->tot_len = sizeof (struct iphdr) + sizeof (struct udphdr) + length;
+    iph->id = htonl (54321); //Id of this packet
+    iph->frag_off = 0;
+    iph->ttl = 1;
+    iph->protocol = IPPROTO_UDP;
+    iph->check = 0;      //Set to 0 before calculating checksum
+    iph->saddr = inet_addr ( source_ip );    //Spoof the source ip address
+    iph->daddr = sin.sin_addr.s_addr;
+
+    //Ip checksum
+    iph->check = csum ((unsigned short *) datagram, sizeof (struct iphdr));
+
+    //UDP header
+    udph->source = htons (6666);
+    udph->dest = htons (6080);
+    udph->len = htons(8 + length); //tcp header size
+    udph->check = 0; //leave checksum 0 now, filled later by pseudo header
+
+    //Now the UDP checksum using the pseudo header
+    psh.source_address = inet_addr( source_ip );
+    psh.dest_address = sin.sin_addr.s_addr;
+    psh.placeholder = 0;
+    psh.protocol = IPPROTO_UDP;
+    psh.udp_length = htons(sizeof(struct udphdr) + length );
+
+    int psize = sizeof(struct pseudo_header) + sizeof(struct udphdr) + length;
+    pseudogram = malloc(psize);
+
+    memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+    memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+
+    udph->check = csum( (unsigned short*) pseudogram , psize);
+
+    //loop if you want to flood :)
+//     while (1)
+    {
+        //Send the packet
+        if (sendto (s, datagram, iph->tot_len ,  0, (struct sockaddr *) &sin, sizeof (sin)) < 0)
+        {
+            perror("sendto failed");
+        }
+        //Data send successfully
+        else
+        {
+            printf ("Packet Send. Length : %d \n" , iph->tot_len);
+            close(s);
+        }
+
+
+
+        smt_packet_header_t smt_header;
+        unsigned char SMTh[SMTh_BUFF_LEN];
+        smt_header.SPS=0X4D54;
+        smt_header.SDC=0X01;
+        smt_header.LEN=10+iph->tot_len;
+        smt_header.TCH=1;
+        smt_header.RSV1=0;
+        smt_header.RSV2=0;
+        init_smt_header(&smt_header,SMTh);
+
+        char smt_datagram[4096];
+        memcpy(&smt_datagram[10],datagram,iph->tot_len);
+        memcpy(&smt_datagram[0],SMTh,SMTh_BUFF_LEN);
+    	//
+    	int ss2;
+    	struct sockaddr_in sendto_addr;
+    	//
+    	ss2=socket(AF_INET, SOCK_DGRAM,0);
+    	if(ss2<0)
+    	{
+    		printf("socket error\n");
+    		return -1;
+    	}
+    	//
+    	bzero(&sendto_addr,sizeof(sendto_addr));
+    	sendto_addr.sin_family=AF_INET;
+//    	sendto_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+    	sendto_addr.sin_addr.s_addr=inet_addr("224.1.0.100");
+    	sendto_addr.sin_port =htons(6080);
+
+    	int addr_len =sizeof(struct sockaddr_in);
+
+//        send_udp2(ss,datagram,iph->tot_len,sendto_addr);
+//    	while(1){
+//    		int a =0;
+//    		printf("udp\n");
+//    		if(sendto(ss2,datagram,iph->tot_len,0,(struct sockaddr *)&sendto_addr,addr_len)<0)
+//
+//    			printf("send fail error\n");
+//    		}
+
+    	sendto(ss2,smt_datagram,smt_header.LEN,0,(struct sockaddr *)&sendto_addr,addr_len);
+        close(ss2);
+
+    }
+
+    return 0;
+}
+
+//Complete
diff --git a/net/mmt/mmtp/send.h b/net/mmt/mmtp/send.h
new file mode 100644
index 0000000..46c6b3b
--- /dev/null
+++ b/net/mmt/mmtp/send.h
@@ -0,0 +1,32 @@
+#ifndef NET_MMT_MMTP_SEND_H_
+#define NET_MMT_MMTP_SEND_H_
+
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+/*
+    96 bit (12 bytes) pseudo header needed for udp header checksum calculation
+*/
+struct pseudo_header
+{
+    u_int32_t source_address;
+    u_int32_t dest_address;
+    u_int8_t placeholder;
+    u_int8_t protocol;
+    u_int16_t udp_length;
+};
+
+unsigned short csum(unsigned short *ptr,int nbytes);
+int send_raw_udp(char *UDPbuff,int length);
+int send_udp2(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+#endif
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 0aa7a96..0f4624b 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -233,6 +233,7 @@
 
 #define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
 
+#define ATOM_muli MP4_FOURCC( 'm', 'u', 'l', 'i' )
 #define ATOM_pitm MP4_FOURCC( 'p', 'i', 't', 'm' )
 #define ATOM_iloc MP4_FOURCC( 'i', 'l', 'o', 'c' )
 #define ATOM_iinf MP4_FOURCC( 'i', 'i', 'n', 'f' )
diff --git a/net/net.gyp b/net/net.gyp
index 25d6654..0305738 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -102,6 +102,7 @@
         'net_derived_sources',
         'net_resources',
         '../net/mmt/mpu/mpu.gyp:libmpu',
+        '../net/mmt/mmtp/mmtp.gyp:libmmtp',
         '../net/mmt/ntp/ntp.gyp:libntp',
       ],
       'sources': [
-- 
1.7.9.5


From efb8b3a07c1046c3457025425ecbd11dbd27faa6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 18:27:35 +0800
Subject: [PATCH 80/92] [todo] add ci xml 's merge & update

---
 net/mmt/mmt_control.cc |   40 +++++++++++----
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_parser.cc  |  132 +++++++++++++++++++++++++++++++++++++++++++++++-
 net/mmt/mmt_parser.h   |   14 +++++
 4 files changed, 174 insertions(+), 13 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 5eb3c1e..0e48e2d 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -128,6 +128,7 @@ ctrl_msg_t::~ctrl_msg_t() {
 cixml_t::cixml_t() {
     fname = "";
     status = "initing";
+    timestamp = 0;
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
@@ -222,27 +223,44 @@ void MmtControl::CheckEvent() {
 
         std::string xml_name = cixml->fname;
         std::string next_status = cixml->status;
-        CiParserPtr parser = cixml->parser;
 
         //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
         if (cixml->status == "initing") {
-            if (!cixml->parser) {
-                cixml->parser = new CiParser(xml_name);
-            }
             next_status = "loading";
             Wait(100);
         }else if (cixml->status == "loading") {
-            if (parser) {
-                parser->ParseXml();
-                parser->ParseHtml();
-            }
             next_status = "loaded";
             Wait(1000);
         }else if (cixml->status == "loaded") {
-            if (parser && cixml->postui) {
+            if (!cixml->parser) { // first load
+                cixml->parser = new CiParser(xml_name);
+                if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
+                    cixml->parser = nullptr;
+                }
+            }
+
+            int64 ntp = GetNTPTime();
+            if (cixml->parser) {
+                // update ci xml
+                int64 timestamp = cixml->parser->GetTimestamp();
+                std::string version = cixml->parser->GetVersion();
+                if (cixml->timestamp != timestamp && timestamp > 0 && ntp >= timestamp) {
+                    CiParserPtr parser_new = new CiParser(xml_name);
+                    if(parser_new->ParseXml() && parser_new->ParseHtml()) {
+                        parser_new->MergeCI(cixml->parser.get());
+                        cixml->parser = parser_new;
+                        LOG(INFO) << __func__ << " update xml,"
+                            << " old timestamp=" << timestamp << " version=" << version
+                            << " new timestamp=" << cixml->parser->GetTimestamp()
+                            << " version=" << cixml->parser->GetVersion();
+                    }
+                    cixml->timestamp = timestamp;
+                }
+            }
+
+            if (cixml->parser && cixml->postui) {
                 std::string js;
-                int64 ntp = GetNTPTime();
-                if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
+                if(cixml->parser->GetHtmlJS(ntp, js) && !js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
                     GetJsonData(iter->first, js, json);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 150f148..178643b 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,6 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
+    int64 timestamp;        //> timestamp of parsed xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
     postui_func_t postui;   //> function for execute js script
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 3b57285..5379808 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -1,5 +1,6 @@
 #include "net/mmt/mmt_parser.h"
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
 
 #include "libxml/parser.h"
 
@@ -21,6 +22,8 @@ static const char ksourceList[]     = "sourceList";
 /**
  * String constants for ci xml attr
  */
+static const char kversion[]    = "version";
+static const char ktimestamp[]  = "timestamp";
 static const char krefId[]      = "refId";
 static const char krefDiv[]     = "refDiv";
 static const char kmediaSrc[]   = "mediaSrc";
@@ -118,7 +121,7 @@ int64 ParseTimeStr(std::string timestr) {
 
 #ifdef USE_NTP_TIME
     base::Time time;
-    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+    if(!base::Time::FromString(timestr.c_str(), &time))
         return 0;
     ms = (int64)time.ToJsTime(); //milliseconds
 #else
@@ -170,6 +173,7 @@ html_t::~html_t() {
 
 CiParser::CiParser(const std::string& fname) 
     : fname_(fname), root_(nullptr), cur_(nullptr) {
+    timestamp_ = 0;
 }
 
 CiParser::~CiParser() {
@@ -328,7 +332,6 @@ bool CiParser::ParseHtml() {
             }else if (begin.event == kevbegin || begin.event == kevend) {
                 SetNodeTime(node->time.begin, node);
             }
-
         }
 
         event_t end = node->time.end;
@@ -351,6 +354,123 @@ bool CiParser::ParseHtml() {
     return true;
 }
 
+// merge ev2 into ev1
+void MergeEvent(event_t& ev1, event_t& ev2) {
+    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << "time2="<<ev2.time;
+    if (ev1.is_event != ev2.is_event || ev1.id != ev2.id ||
+        ev1.event != ev2.event || ev1.time != ev2.time) { // update
+        ev1 = ev2;
+    }else {
+        ev1.is_timeout = ev2.is_timeout;
+    }
+}
+// merge attrs2 into attrs1
+void MergeAttrs(attrs_t& attrs1, attrs_t& attrs2) {
+    attrs_t::iterator iter1 = attrs1.begin();
+    for (; iter1 != attrs1.end(); iter1++) {
+        if (attrs2.find(iter1->first) == attrs2.end()) 
+            continue;
+        std::string value1 = iter1->second;
+        std::string value2 = attrs2[iter1->first];
+        if (value1 != value2) {
+            LOG(INFO) << __func__ << " key=" << iter1->first 
+                << " value1=" << value1 << " value2=" << value2;
+            attrs1[iter1->first] = value2;
+        } 
+    }
+}
+
+// merge node2 into node1
+bool MergeNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false; 
+
+    LOG(INFO) << __func__ << " update node name=" << node1->name;
+    MergeAttrs(node1->attrs, node2->attrs);
+    MergeEvent(node1->time.begin, node2->time.begin);
+    MergeEvent(node1->time.end, node2->time.end);
+    return 0;
+}
+
+/**
+ * Check similar node
+ */
+bool IsSameNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false;
+
+    std::string id1, refId1, refDiv1;
+    if (node1->attrs.find("id") != node1->attrs.end())
+        id1 = node1->attrs["id"];
+    if (node1->attrs.find(krefId) != node1->attrs.end())
+        refId1 = node1->attrs[krefId];
+    if (node1->attrs.find(krefDiv) != node1->attrs.end())
+        refDiv1 = node1->attrs[krefDiv];
+
+    std::string id2, refId2, refDiv2;
+    if (node2->attrs.find("id") != node2->attrs.end())
+        id2 = node2->attrs["id"];
+    if (node2->attrs.find(krefId) != node2->attrs.end())
+        refId2 = node2->attrs[krefId];
+    if (node2->attrs.find(krefDiv) != node2->attrs.end())
+        refDiv2 = node2->attrs[krefDiv];
+
+    if (id1 != id2 || refId1 != refId2 || refDiv1 != refDiv2) return false;
+    return true;
+}
+
+/**
+ * find node2 from node1's subnodes
+ */
+nodeptr_t FindSubNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return nullptr;
+
+    nodeptrs_t::iterator iter1;
+    for(iter1=node1->nodes.begin(); iter1 != node1->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2;
+            for(iter2=sub1->nodes.begin(); iter2 != sub1->nodes.end(); iter2++){
+                nodeptr_t sub2 = *iter2;
+                if (IsSameNode(sub2, node2)) {
+                    return sub2;
+                }
+            }
+        }
+
+        if (IsSameNode(sub1, node2)) {
+            return sub1;
+        }
+    }
+    return nullptr;
+}
+
+// merge old pasrer's CI into this new CI
+bool CiParser::MergeCI(CiParser* parser) {
+    if (!root_ || !parser || !parser->root_) return false;
+    nodeptr_t node = root_;
+    nodeptr_t oldnode = parser->root_;
+
+    nodeptrs_t::iterator iter1;
+    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2;
+            for(iter2=sub1->nodes.begin(); iter2 != sub1->nodes.end(); iter2++ ){
+                nodeptr_t sub2 = *iter2;
+                nodeptr_t sub3 = FindSubNode(oldnode, sub2);
+                MergeNode(sub2, sub3);
+            }
+        }else {
+            nodeptr_t sub2 = FindSubNode(oldnode, sub1);
+            MergeNode(sub1, sub2);  // merge old into new
+        }
+    }
+
+    return true;
+}
+
+
 /**
  * To process both @begin and @end
  */
@@ -531,6 +651,14 @@ bool CiParser::AddAttr(std::string name, std::string value) {
         ParseTimeEvent(value, cur_->time.begin);
     }else if (name == kend) {
         ParseTimeEvent(value, cur_->time.end);
+    }else if (cur_->name == kCI) {
+        if (name == kversion) {
+            version_ = value;
+            LOG(INFO) << __func__ << " xml version=" << version_;
+        }else if (name == ktimestamp) {
+            timestamp_ = ParseTimeStr(value);
+            LOG(INFO) << __func__ << " xml timestamp=" << timestamp_ << " local=" << GetLocalTime();
+        }
     }
 
     return true;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 736806a..ef97783 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -107,6 +107,11 @@ public:
     bool ParseHtml();
 
     /**
+     * To Merge another parser
+     */
+    bool MergeCI(CiParser* parser);
+
+    /**
      * To get current js to operate
      *
      * @param current[in]: current time(ms) (ntp or ntp diff)
@@ -116,6 +121,12 @@ public:
     bool GetHtmlJS(int64 current, std::string& js);
 
     /**
+     * Get Xml's timestamp and version.
+     */
+    int64 GetTimestamp() {return timestamp_;}
+    std::string GetVersion() {return version_;}
+
+    /**
      * To parse xml's node and its attr
      */
     bool AddNode(std::string name);
@@ -136,6 +147,9 @@ private:
     nodeptr_t root_;    //> xml's root node
     nodeptr_t cur_;     //> only work for AddNode/AddAttr
     htmlmap_t htmls_;   //> html tags
+
+    std::string version_;
+    int64 timestamp_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From 00e24513ee82db0ad196585a085f395d75f4f907 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 18:53:05 +0800
Subject: [PATCH 81/92] [todo] refine xml update interval; refine mmtp

---
 net/mmt/mmt_control.cc |   31 +++++++++++++++++++------------
 net/mmt/mmt_control.h  |    2 +-
 net/mmt/mmt_parser.cc  |   17 +++++++----------
 net/mmt/mmtp/Makefile  |   21 +++++++++++++++++++++
 net/mmt/mmtp/client.c  |    2 +-
 5 files changed, 49 insertions(+), 24 deletions(-)
 create mode 100644 net/mmt/mmtp/Makefile

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 0e48e2d..3050e34 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -128,7 +128,7 @@ ctrl_msg_t::~ctrl_msg_t() {
 cixml_t::cixml_t() {
     fname = "";
     status = "initing";
-    timestamp = 0;
+    update = 0;
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
@@ -236,26 +236,33 @@ void MmtControl::CheckEvent() {
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
                     cixml->parser = nullptr;
+                    cixml->update = 15;
                 }
             }
 
             int64 ntp = GetNTPTime();
-            if (cixml->parser) {
+            if (cixml->parser && (cixml->update--) <= 0) {
                 // update ci xml
                 int64 timestamp = cixml->parser->GetTimestamp();
                 std::string version = cixml->parser->GetVersion();
-                if (cixml->timestamp != timestamp && timestamp > 0 && ntp >= timestamp) {
-                    CiParserPtr parser_new = new CiParser(xml_name);
-                    if(parser_new->ParseXml() && parser_new->ParseHtml()) {
-                        parser_new->MergeCI(cixml->parser.get());
-                        cixml->parser = parser_new;
-                        LOG(INFO) << __func__ << " update xml,"
-                            << " old timestamp=" << timestamp << " version=" << version
-                            << " new timestamp=" << cixml->parser->GetTimestamp()
-                            << " version=" << cixml->parser->GetVersion();
+                CiParserPtr parser2 = new CiParser(xml_name);
+                if(parser2->ParseXml()) {
+                    int64 timestamp2 = parser2->GetTimestamp();
+                    std::string version2 = parser2->GetVersion();
+                    LOG(INFO) << __func__ << " to update xml, ntp=" << ntp
+                        << " old timestamp=" << timestamp << " version=" << version
+                        << " new timestamp=" << timestamp2 << " version=" << version2;
+
+                    if (ntp >= timestamp2 && timestamp < timestamp2) {
+                        if(parser2->ParseHtml()) {
+                            parser2->MergeCI(cixml->parser.get());
+                            cixml->parser = parser2;
+                            LOG(INFO) << __func__ << " to update xml, OK";
+                        }
                     }
-                    cixml->timestamp = timestamp;
+                    cixml->update = 15;
                 }
+                parser2 = nullptr;
             }
 
             if (cixml->parser && cixml->postui) {
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 178643b..f362e3c 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,7 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
-    int64 timestamp;        //> timestamp of parsed xml
+    int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
     postui_func_t postui;   //> function for execute js script
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 5379808..0ec5aff 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -356,12 +356,10 @@ bool CiParser::ParseHtml() {
 
 // merge ev2 into ev1
 void MergeEvent(event_t& ev1, event_t& ev2) {
-    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << "time2="<<ev2.time;
-    if (ev1.is_event != ev2.is_event || ev1.id != ev2.id ||
-        ev1.event != ev2.event || ev1.time != ev2.time) { // update
-        ev1 = ev2;
-    }else {
-        ev1.is_timeout = ev2.is_timeout;
+    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
+    if (ev1.is_event == ev2.is_event) {
+        if (!ev1.is_event) // digital time, set it with last timeout
+            ev1.is_timeout = ev2.is_timeout;
     }
 }
 // merge attrs2 into attrs1
@@ -386,7 +384,7 @@ bool MergeNode(nodeptr_t node1, nodeptr_t node2) {
     if (node1->name != node2->name) return false; 
 
     LOG(INFO) << __func__ << " update node name=" << node1->name;
-    MergeAttrs(node1->attrs, node2->attrs);
+    //MergeAttrs(node1->attrs, node2->attrs);
     MergeEvent(node1->time.begin, node2->time.begin);
     MergeEvent(node1->time.end, node2->time.end);
     return 0;
@@ -461,10 +459,9 @@ bool CiParser::MergeCI(CiParser* parser) {
                 nodeptr_t sub3 = FindSubNode(oldnode, sub2);
                 MergeNode(sub2, sub3);
             }
-        }else {
-            nodeptr_t sub2 = FindSubNode(oldnode, sub1);
-            MergeNode(sub1, sub2);  // merge old into new
         }
+        nodeptr_t sub2 = FindSubNode(oldnode, sub1);
+        MergeNode(sub1, sub2);  // merge old into new
     }
 
     return true;
diff --git a/net/mmt/mmtp/Makefile b/net/mmt/mmtp/Makefile
new file mode 100644
index 0000000..7655df9
--- /dev/null
+++ b/net/mmt/mmtp/Makefile
@@ -0,0 +1,21 @@
+TARGET = client
+OBJS = DList.o Mlist.o client.o getfile.o ini.o mmt.o ringq.o send.o ../mpu/stream.o ../mpu/mp4.o
+CFLAGS = -I../../../ -D_TEST
+LDFLAGS = -lm -lpthread
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 895014e..aa6fdfd 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -70,7 +70,7 @@ void  sig_pipe(int signo)
 DList *signal_buff_list = NULL;
 DList *mpu_buff_list = NULL;
 
-#if 0
+#ifdef _TEST
 int main(int argc, char *argv[])
 {
 
-- 
1.7.9.5


From 27a56d4b9fef0a095586f8a3f83e59a91efe493f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 21:59:33 +0800
Subject: [PATCH 82/92] [todo] add mmtp interface

---
 net/mmt/mmtp/client.c |  112 ++++++++++++++++++++++++++++++-------------------
 net/mmt/mmtp/mmtp.h   |   65 +++++-----------------------
 2 files changed, 79 insertions(+), 98 deletions(-)

diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index aa6fdfd..fde5a7d 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -27,6 +27,7 @@
 #include "send.h"
 #include "ringq.h"
 #include "DList.h"
+#include "mmtp.h"
 
 
 #define MCAST_PORT 6080
@@ -46,59 +47,42 @@ int signal_buffer_has_item=0;							/**/
 int mpu_buffer_has_item=0;							/**/
 pthread_mutex_t mpu_mutex;							/**/
 pthread_mutex_t signal_mutex;							/**/
-int running =1 ;								/**/
 
-static int s;
+static int g_running = 1;								/**/
+static int g_sock;
+static mmtp_func_t g_mmtp_func = NULL;
+
+DList *signal_buff_list = NULL;
+DList *mpu_buff_list = NULL;
+
+#define BUFF_LEN 1500
+#define CLOSESOCKET(fd) if(fd > 0){close(fd);fd=-1;}
+
 
 void sig_proccess(int signo)
 {
 	printf("catch a exit signal\n");
-	close(s);
+	CLOSESOCKET(g_sock);
 	exit(0);
 }
 
 void  sig_pipe(int signo)
 {
 	printf("catch a SIGPIPE signal\n");
-	close(s);
+	CLOSESOCKET(g_sock);
 	exit(0);
 }
 
 
-#define BUFF_LEN 1500
-
-DList *signal_buff_list = NULL;
-DList *mpu_buff_list = NULL;
-
 #ifdef _TEST
 int main(int argc, char *argv[])
 {
-
-	//init a double listmpu_buff_listst = InitList();
-	signal_buff_list=InitList();
-	mpu_buff_list=InitList();
-
-	pthread_t signal_consumer_t;						/**/
-	pthread_t mpu_consumer_t;						/**/
-	pthread_t producter_t;						/**/
-
-	pthread_mutex_init (&signal_mutex,NULL);			/**/
-	pthread_mutex_init (&mpu_mutex,NULL);			/**/
-
-	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
-	usleep(10);
-	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
-	usleep(10);
-	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
-	usleep(10);
-	//pthread_join(producter_t,&buffer_has_item);			/**/
+    init_mmtp();
+    start_mmtp();
 	while(1)
 		sleep(1);
-	pthread_mutex_destroy(&signal_mutex);				/**/
-	//udpserv_echo(ss,(struct sockaddr*)&local_addr);
-
-	/**/
-
+    stop_mmtp();
+    uninit_mmtp();
 
     return 0;
 }
@@ -192,15 +176,15 @@ void *producter_f (void *arg)					/**/
 	PNode p = NULL;
 
 	int lastpacket,last_flag=1;
-
-	while(running)								/**/
+    g_sock = ss;
+	while(g_running)								/**/
 	{
 		len=sizeof(local_addr);
-		n=recvfrom(ss,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
+		n=recvfrom(g_sock,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
 		if(n <=0)
 		{
 			perror("recv error");
-			return NULL;
+            break;
 		}
 		mmt_packet_header_t mmt_header;
 		mpu_packet_header_t mpu_header;
@@ -215,7 +199,8 @@ void *producter_f (void *arg)					/**/
 		if(mmt_header.packet_counter!=lastpacket+1 && last_flag==0)
 		{
 			puts ("packet loss");
-			exit (EXIT_FAILURE);
+			//exit (EXIT_FAILURE);
+            break;
 		}
 		lastpacket=mmt_header.packet_counter;
 		last_flag--;
@@ -273,8 +258,8 @@ void *producter_f (void *arg)					/**/
 //			pthread_exit((void *)3);
 	}
 
-	err = setsockopt(ss, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
-	close(ss);
+	err = setsockopt(g_sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
+	CLOSESOCKET(g_sock);
     return NULL;
 }
 
@@ -284,10 +269,10 @@ void *signal_consumer_f(void *arg)						/**/
 	unsigned char *signal_buf;
 	u_int32_t signal_seekpoint=0;
 	pa_message_t pa_message;
-	while(running)								/**/
+	while(g_running)								/**/
 	{
 		pthread_mutex_lock(&signal_mutex);				/**/
-		while(GetSize(signal_buff_list)>1)
+		while(g_running && GetSize(signal_buff_list)>1)
 		{
 			//signal
 			p=GetHead(signal_buff_list);
@@ -415,7 +400,7 @@ void *mpu_consumer_f(void *arg)						/**/
 	mpu_buf_t mpu_buf;
 	init_mpu_buf(&mpu_buf);
 	int mpufilter=0;
-	while(running)								/**/
+	while(g_running)								/**/
 	{
 		int mpu_consumer_couter=0;
 		mmt_packet_header_t mmt_header;
@@ -534,7 +519,7 @@ void *mpu_consumer_f(void *arg)						/**/
 		pthread_mutex_unlock(&mpu_mutex);			/**/
 
 
-		while(GetSize(mpu_consumer_list)>0)
+		while(g_running && GetSize(mpu_consumer_list)>0)
 		{
 //			printf("GetSize(mpu_consumer_list):%d\n",GetSize(mpu_consumer_list)); 	/**/
 			p=GetHead(mpu_consumer_list);
@@ -970,3 +955,42 @@ void *mpu_consumer_f(void *arg)						/**/
 	}//WHILE END
     return NULL;
 }//FUCTION END
+
+
+void init_mmtp() {
+	signal_buff_list=InitList();
+	mpu_buff_list=InitList();
+	pthread_mutex_init (&signal_mutex,NULL);
+	pthread_mutex_init (&mpu_mutex,NULL);
+}
+
+void start_mmtp() {
+    pthread_t signal_consumer_t;
+    pthread_t mpu_consumer_t;
+    pthread_t producter_t;
+
+    g_running = 1;
+	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
+	usleep(10);
+	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
+	usleep(10);
+	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
+	usleep(10);
+}
+
+void stop_mmtp() {
+    CLOSESOCKET(g_sock);
+    g_running = 0;
+}
+
+void uninit_mmtp() {
+	pthread_mutex_destroy(&signal_mutex);
+	pthread_mutex_destroy(&mpu_mutex);
+    DestroyList(signal_buff_list);
+    DestroyList(mpu_buff_list);
+}
+
+void set_mmtp_notifier(mmtp_func_t func) {
+    g_mmtp_func = func;
+}
+
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index 00c02cb..6d6db81 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -1,64 +1,21 @@
 #ifndef NET_MMT_MMTP_MMTP_H_
 #define NET_MMT_MMTP_MMTP_H_
 
-#include "mmt.h"
-
-#if 0
-//
-pthread_mutex_t mpu_mutex;							/**/
-pthread_mutex_t signal_mutex;						/**/
-pthread_mutex_t mpu_list_mutex;						/**/
-
-pthread_t signal_consumer_t;						/**/
-pthread_t mpu_consumer_t;						/**/
-pthread_t producter_t;						/**/
-
-DList *signal_buff_list;
-DList *mpu_buff_list;
-
-int signal_buffer_has_item=0;							/**/
-int mpu_buffer_has_item=0;							/**/
-
-//mpu_buf_t,mpu
-mpu_buf_t *mpu_list;
-
-//
-int mmt_socket;
+#ifdef __cplusplus
+extern "C" {
 #endif
 
-//IP,,,
-int InitMMTP(char *listen_ip, int16_t listen_port);
-
-//MPU,packet_idmpu_sequence_number,packet_idasset
-//MPU,,
-int AddMpu(mpu_buf_t *mpu_list);
-
-//MPU
-int RefreshMpu(mpu_buf_t *mpu_list);
+void init_mmtp();
+void start_mmtp();
+void stop_mmtp();
+void uninit_mmtp();
 
-//,IP,
-int UninitMMTP();
+typedef void (*mmtp_func_t) (const char* fname, const char* ftype);
+void set_mmtp_notifier(mmtp_func_t func);
 
+#ifdef __cplusplus
+}
+#endif
 
-typedef void (*message_callback_func_t)(pa_message_t *pa_message);
-//,,pa_message
-void SetMessageCallback(message_callback_func_t func,pa_message_t *pa_message);
-
-//
-void Message_func(pa_message_t *pa_message);
-
-
-typedef void (*mpu_callback_func_t)(mpu_buf_t *mpu_buf);
-//MPU,,MPU
-void SetCICallback(mpu_callback_func_t func,mpu_buf_t *mpu_buf);
-
-//
-void Mpu_func(mpu_buf_t *mpu_buf);
-
-//,,,
-int QueryMessageResource(char* mmt_url, char* ci_fname,  int size);
-
-//,MPU,,mpu_buf_t,mpu_list
-int QueryMPUResource(mpu_buf_t *mpu_list, u_int32_t sequence,  u_int32_t packet_id);
 
 #endif
-- 
1.7.9.5


From 9839efe80b7f0bb4a04b21eb03cc79536e6553f6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 22:40:05 +0800
Subject: [PATCH 83/92] [todo] refine mmtp interface

---
 net/mmt/mmtp/client.c |   32 ++++++++++++++++++++++++--------
 net/mmt/mmtp/mmt.c    |   10 +++++++++-
 net/mmt/mmtp/mmtp.h   |   13 +++++++++++--
 3 files changed, 44 insertions(+), 11 deletions(-)

diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index fde5a7d..0ad507d 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -48,9 +48,9 @@ int mpu_buffer_has_item=0;							/**/
 pthread_mutex_t mpu_mutex;							/**/
 pthread_mutex_t signal_mutex;							/**/
 
-static int g_running = 1;								/**/
-static int g_sock;
-static mmtp_func_t g_mmtp_func = NULL;
+int g_running = 1;								/**/
+int g_sock = -1;
+mmtp_callback_t g_mmtp_cb;
 
 DList *signal_buff_list = NULL;
 DList *mpu_buff_list = NULL;
@@ -732,7 +732,10 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									fclose(mpu);
 									free_mpu_buf(&mpu_buf );
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 
 								}
 //								free(mfu_buf);
@@ -881,7 +884,11 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 
 								}
 								//,,
@@ -937,7 +944,11 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 								}
 
 							}
@@ -962,6 +973,7 @@ void init_mmtp() {
 	mpu_buff_list=InitList();
 	pthread_mutex_init (&signal_mutex,NULL);
 	pthread_mutex_init (&mpu_mutex,NULL);
+    memset(&g_mmtp_cb, 0, sizeof(g_mmtp_cb));
 }
 
 void start_mmtp() {
@@ -978,6 +990,10 @@ void start_mmtp() {
 	usleep(10);
 }
 
+void open_mmtp(const char* url) {
+    // TODO
+}
+
 void stop_mmtp() {
     CLOSESOCKET(g_sock);
     g_running = 0;
@@ -990,7 +1006,7 @@ void uninit_mmtp() {
     DestroyList(mpu_buff_list);
 }
 
-void set_mmtp_notifier(mmtp_func_t func) {
-    g_mmtp_func = func;
+void set_mmtp_callback(mmtp_callback_t* mmtp_cb) {
+    g_mmtp_cb = *mmtp_cb;
 }
 
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
index e2a09ee..2188743 100644
--- a/net/mmt/mmtp/mmt.c
+++ b/net/mmt/mmtp/mmt.c
@@ -22,6 +22,9 @@
 #include "mmt.h"
 #include "getfile.h"
 #include "send.h"
+#include "mmtp.h"
+
+extern mmtp_callback_t g_mmtp_cb;
 
 int get_send_timestamp()
 {
@@ -1055,7 +1058,12 @@ int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
 					}
 			fwrite(mpi_table->PI_content[i].PI_content_byte,mpi_table->PI_content[i].PI_content_length,1,mpi);
 			fclose(mpi);
-		}
+
+			printf("finished recive a ci - %d - %s\n", i, (const char *)mpi_table->PI_content[i].PI_content_name_byte);
+            if (g_mmtp_cb.cifunc) {
+                g_mmtp_cb.cifunc(NULL, (const char *)mpi_table->PI_content[i].PI_content_name_byte, i);
+            }
+        }
 	 return 0;
 
 }
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index 6d6db81..dd2099c 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -7,11 +7,20 @@ extern "C" {
 
 void init_mmtp();
 void start_mmtp();
+void open_mmtp(const char* url);
 void stop_mmtp();
 void uninit_mmtp();
 
-typedef void (*mmtp_func_t) (const char* fname, const char* ftype);
-void set_mmtp_notifier(mmtp_func_t func);
+// for ci.xml and index.html
+typedef void (*mmtp_ci_func_t) (const char* url, const char* fname, int ftype);
+// for audio, video and image
+typedef void (*mmtp_mpu_func_t) (const char* url, const char* fname, int ftype);
+typedef struct mmtp_callback_t {
+    mmtp_ci_func_t cifunc;
+    mmtp_mpu_func_t mpufunc;
+}mmtp_callback_t;
+
+void set_mmtp_callback(mmtp_callback_t* mmtp_cb);
 
 #ifdef __cplusplus
 }
-- 
1.7.9.5


From 165ab5012a61fcac77f3f2e0fd500826757d462c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 23:32:17 +0800
Subject: [PATCH 84/92] [todo] support <sourceList> for all

---
 net/mmt/mmt_parser.cc |   23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 0ec5aff..f387cb5 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -233,23 +233,24 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     // set media src
     if (node->name == kMediaSync) {
         bool bfind = false;
-        // for <img>
-        if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
-            std::string src = node->attrs[kmediaSrc];
+        // for <img>, <audio> <video>
+        nodeptrs_t::iterator iter = node->nodes.begin();
+        for (; iter != node->nodes.end(); iter++) {
+            nodeptr_t sub = *iter;
+            if (sub->name != ksourceList) continue;
+            std::string src = sub->attrs[kmediaSrc];
             js0 += SetJSAttr(id, "src", src);
             js1 += SetJSAttr(id, "src", "");
             bfind = true;
-        }else {
-            // for <audio> <video>
-            nodeptrs_t::iterator iter = node->nodes.begin();
-            for (; iter != node->nodes.end(); iter++) {
-                nodeptr_t sub = *iter;
-                if (sub->name != ksourceList) continue;
-                std::string src = sub->attrs[kmediaSrc];
+            break;
+        }
+
+        if (!bfind) {
+            if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
+                std::string src = node->attrs[kmediaSrc];
                 js0 += SetJSAttr(id, "src", src);
                 js1 += SetJSAttr(id, "src", "");
                 bfind = true;
-                break;
             }
         }
 
-- 
1.7.9.5


From 3a8a3f39bb1309b5c7eced0c6ec089ae0f3bfe93 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 02:42:26 +0800
Subject: [PATCH 85/92] [todo] integrate mmtp into mmt_stream

---
 net/mmt/mmt_control.cc |   30 +++++-----
 net/mmt/mmt_stream.cc  |  153 ++++++++++++++++++++++++++++++++++++++++++++----
 net/mmt/mmt_stream.h   |   44 +++++++++++++-
 3 files changed, 201 insertions(+), 26 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 3050e34..bf58100 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -158,9 +158,14 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
     streams_[key] = stream;
-    stream->Prepare(&lsize);
-    if (msg.sinfo.func) {
-        msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+    if(stream->Prepare(&lsize) == -3) { // waiting
+        Push(msg);
+        Wait(100);
+        return;
+    }else {
+        if (msg.sinfo.func) {
+            msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+        }
     }
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
@@ -171,17 +176,14 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
-#if 0
-        LOG(INFO) << __func__ 
-            << " head=" << head 
-            << " iret=" << iret 
-            << " url=" << url
-            << " size=" << msg.sinfo.size 
-            << " offset=" << msg.sinfo.offset 
-            << " ptr=" << msg.ptr.get();
-#endif
-        if (msg.sinfo.func) {
-            msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+        if (iret == -3) { // waiting 
+            Push(msg);
+            Wait(100);
+            return;
+        }else {
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+            }
         }
     }
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 98b9dc1..925dea0 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,14 +1,20 @@
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_inc.h"
 #include "net/mmt/mpu/mp4.h"
+#include "net/mmt/mmtp/mmtp.h"
 
 namespace mmt {
 
+#define USE_MMTP 1
+
 static const long kMmtMediaSize = 0x7fffffff;
 
 static const char kMmtMediaAudio[] = "audio";
 static const char kMmtMediaVideo[] = "video";
 static const char kMmtMediaImage[] = "image";
+static const char kMmtMediaMmtp[] = "mmtp";
+static const char kMmtMediaHtml[] = "html";
+static const char kMmtMediaCI[] = "ci";
 
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
@@ -70,11 +76,127 @@ stream_t* InitMpuStream(Stream* ptr) {
 
 namespace mmt {
 
+static MmtpStream* g_mmtp = nullptr;
+
+void MmtpStart() {
+    if (!g_mmtp) {
+        g_mmtp = new MmtpStream;
+    }
+
+    if (g_mmtp) {
+        g_mmtp->StartMmtp();
+    }
+}
+void MmtpStop() {
+    if (g_mmtp) {
+        g_mmtp->StopMmtp();
+    }
+}
+bool MmtpPop(std::string key, mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        return g_mmtp->Pop(key, mmtp);
+    }
+    return false;
+}
+void MmtpPush(mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        g_mmtp->Push(mmtp);
+    }
+}
+
+void CIRecvCallback(const char* url, const char* fname, int ftype) {
+    base::FilePath fpath;
+    base::GetCurrentDirectory (&fpath);
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
+    // for test
+    static bool _had_html = false;
+    static bool _had_ci = false;
+    if (ftype == 0 && _had_html) return;
+    if (ftype == 1 && _had_ci) return;
+    _had_html = (ftype == 0);
+    _had_ci = (ftype == 1);
+
+    mmtp_info_t mmtp;
+    if (url) mmtp.url = url;
+    if (fname) mmtp.fname = fname;
+    mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
+    MmtpPush(mmtp);
+    LOG(INFO) << __func__ << " END";
+}
+
+void MPURecvCallback(const char* url, const char* fname, int ftype) {
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype;
+    mmtp_info_t mmtp;
+    if (url) mmtp.url = url;
+    if (fname) mmtp.fname = fname;
+    mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
+    MmtpPush(mmtp);
+    LOG(INFO) << __func__ << " END";
+}
+
+MmtpStream::MmtpStream(){
+    mmtprun_ = false;
+}
+MmtpStream::~MmtpStream(){
+}
+
+bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
+    if (mlist_.empty()) return false;
+
+    lock_.Acquire();
+    std::map<std::string, mmtp_infos_t>::iterator iter;
+    iter = mlist_.find(key);
+    if (iter == mlist_.end()) return false;
+
+    mmtp_infos_t& infos = iter->second;
+    if (infos.empty()) return false;
+
+    mmtp = infos.back();
+    infos.pop_back();
+    lock_.Release();
+    return true;
+}
+void MmtpStream::Push(const mmtp_info_t& mmtp) {
+    //TODO: should be url, but now testing
+    std::string key = mmtp.mtype;
+    std::map<std::string, mmtp_infos_t>::iterator iter;
+    lock_.Acquire();
+    iter = mlist_.find(key);
+    if (iter != mlist_.end()) {
+        mmtp_infos_t& infos = iter->second;
+        infos.insert(infos.begin(), mmtp);
+    }else {
+        mmtp_infos_t infos;
+        infos.push_back(mmtp);
+        mlist_[key] = infos;
+    }
+    lock_.Release();
+}
+void MmtpStream::StartMmtp() {
+    if (mmtprun_) return;
+    init_mmtp();
+    mmtp_callback_t cb;
+    cb.cifunc = CIRecvCallback;
+    cb.mpufunc = MPURecvCallback;
+    set_mmtp_callback(&cb);
+    start_mmtp();
+    mmtprun_ = true;
+}
+void MmtpStream::StopMmtp() {
+    if (!mmtprun_) return;
+    stop_mmtp();
+    uninit_mmtp();
+    mmtprun_ = false;
+}
+
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
     midx_.end = -1;
     midx_.cur = -1;
+    lasterr_ = 0;
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
@@ -104,14 +226,18 @@ bool Stream::ParseSequence(int& index) {
         index = midx_.begin;
         LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
         if (index < 0 || midx_.begin > midx_.end) return false;
+
+        if (mtype == kMmtMediaMmtp) { // for mmtp streaming
+            index = -3;
+        }
     }else { // may be one seperate file, not one media sequence
         index = -1;
     }
     return true;
 }
 
-bool Stream::Prepare(long *size) {
-    if (!Open(nullptr, 0)) return false;
+int Stream::Prepare(long *size) {
+    if (!Open(nullptr, 0)) return lasterr_;
 
     long lret = kMmtMediaSize;  // TODO: default size for media sequence
     if (midx_.cur < 0) {        // return real size for single file
@@ -119,12 +245,13 @@ bool Stream::Prepare(long *size) {
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
-    return true;
+    return 0;
 }
 
 void* Stream::Open(const char* filename, int mode) {
     if (file_) return (void *)file_;
 
+    lasterr_ = -2;
     int index = midx_.cur;
     if(index < 0 && !ParseSequence(index)) {
         LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
@@ -135,6 +262,7 @@ void* Stream::Open(const char* filename, int mode) {
     //  index >= 0: media sequence
     //  index == -1: common file
     //  index == -2: mp4 image file
+    //  index == -3: mmtp streaming receiver
     std::string fname = GURL2FilePath(url_);
     if (index >= 0) { // for media sequence
         if (index < midx_.begin || index > midx_.end)
@@ -145,9 +273,15 @@ void* Stream::Open(const char* filename, int mode) {
             fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == kMmtMediaVideo) {
             fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == kMmtMediaImage) {
-            // nothing to do
         }
+    } else if (index == -3) { // mmtp streaming
+        MmtpStart();
+        mmtp_info_t mmtp;
+        if(!MmtpPop(kMmtMediaHtml, mmtp)) {
+            lasterr_ = -3;
+            return nullptr;
+        }
+        fname = mmtp.fname;
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
@@ -162,8 +296,7 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != -1 && index != midx_.begin) {
-#if 1
+    if (index != -1 && index != midx_.begin && index != -3) {
         // TODO: process image of mp4 here
         // check moof box and other
         stream_t* s = InitMpuStream(this);
@@ -194,9 +327,6 @@ void* Stream::Open(const char* filename, int mode) {
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
-#else
-        offmap_[index] = offset_t(0, lret);
-#endif
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
@@ -204,11 +334,12 @@ void* Stream::Open(const char* filename, int mode) {
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
     midx_.cur = index;
+    lasterr_ = 0;
     return (void *)file_;
 }
 
 int Stream::Read(void *buf, int size) {
-    if (!Open(nullptr, 0)) return -2;
+    if (!Open(nullptr, 0)) return lasterr_;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d6fac18..f1ddab0 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -47,6 +47,47 @@ struct content_t {
 
 namespace mmt {
 
+/**
+ * Mmtp information
+ */
+struct mmtp_info_t {
+    std::string url;
+    std::string mtype; // "audio"/"video"/"image"/"ci"/"html" 
+    std::string fname;
+};
+typedef std::vector<mmtp_info_t> mmtp_infos_t;
+
+/**
+ * mmtp resource: audio/video/image/
+ */
+class MmtpStream {
+public:
+    MmtpStream();
+    virtual ~MmtpStream();
+
+    bool Pop(std::string key, mmtp_info_t& mmtp);
+    void Push(const mmtp_info_t& mmtp);
+    // for mmtp control
+    void StartMmtp();
+    void StopMmtp();
+
+private:
+    bool mmtprun_;
+    base::Lock lock_;
+    std::map<std::string, mmtp_infos_t> mlist_; // url => ..
+};
+typedef scoped_refptr<MmtpStream> MmtpStreamPtr;
+
+void MmtpStart();
+void MmtpStop();
+bool MmtpPop(std::string key, mmtp_info_t& mmtp);
+void MmtpPush(mmtp_info_t& mmtp);
+
+
+/**
+ * class for Control Center
+ */
+
 struct triple_t {
     int begin;
     int end;
@@ -99,7 +140,7 @@ public:
     /**
      * if success, set size with the data length
      */
-    bool Prepare(long* size);
+    int Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
 
@@ -113,6 +154,7 @@ private:
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
+    int lasterr_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
 };
-- 
1.7.9.5


From 1cfa68b51bcb7bb35833550ebaf231795a040fb2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 07:04:31 +0800
Subject: [PATCH 86/92] [todo] redo when ci begin/end changes

---
 net/mmt/mmt_parser.cc |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index f387cb5..cb77847 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -359,7 +359,10 @@ bool CiParser::ParseHtml() {
 void MergeEvent(event_t& ev1, event_t& ev2) {
     LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
     if (ev1.is_event == ev2.is_event) {
-        if (!ev1.is_event) // digital time, set it with last timeout
+        // if no changes, set with previous timeout
+        if (!ev1.is_event && ev1.time == ev2.time)
+            ev1.is_timeout = ev2.is_timeout;
+        else if (ev1.is_event && ev1.id == ev2.id && ev1.event == ev2.event)
             ev1.is_timeout = ev2.is_timeout;
     }
 }
-- 
1.7.9.5


From 701a7da1cad38cd242343b2c99126286276316a6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 07:50:36 +0800
Subject: [PATCH 87/92] [ok] (1) begin/end changes; (2)mp4 image

---
 net/mmt/mmt_control.cc |    5 +++++
 net/mmt/mmt_parser.cc  |    2 +-
 net/mmt/mmt_stream.cc  |    1 +
 3 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index bf58100..3ee8eb7 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -159,6 +159,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     StreamPtr stream = new Stream(msg.url);
     streams_[key] = stream;
     if(stream->Prepare(&lsize) == -3) { // waiting
+        LOG(INFO) << __func__ << " waiting...";
         Push(msg);
         Wait(100);
         return;
@@ -177,6 +178,7 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         StreamPtr stream = iter->second;
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
         if (iret == -3) { // waiting 
+            LOG(INFO) << __func__ << " waiting...";
             Push(msg);
             Wait(100);
             return;
@@ -237,6 +239,7 @@ void MmtControl::CheckEvent() {
             if (!cixml->parser) { // first load
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
+                    LOG(INFO) << __func__ << " fail to parse xml first";
                     cixml->parser = nullptr;
                     cixml->update = 15;
                 }
@@ -263,6 +266,8 @@ void MmtControl::CheckEvent() {
                         }
                     }
                     cixml->update = 15;
+                }else {
+                    LOG(INFO) << __func__ << " fail to parse xml";
                 }
                 parser2 = nullptr;
             }
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index cb77847..1d522e0 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -197,7 +197,7 @@ bool CiParser::ParseXml() {
     ctxt->_private = (void *)this;
 
     StreamPtr stream = new Stream(fname_);
-    if (!stream->Prepare(nullptr)) return false;
+    if (stream->Prepare(nullptr) != 0) return false;
 
     int num;
     char buffer[4096];
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 925dea0..373a103 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -249,6 +249,7 @@ int Stream::Prepare(long *size) {
 }
 
 void* Stream::Open(const char* filename, int mode) {
+    lasterr_ = 0;
     if (file_) return (void *)file_;
 
     lasterr_ = -2;
-- 
1.7.9.5


From c4da96f77dac24a7b24f5490052cb234a676f7f4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 09:09:12 +0800
Subject: [PATCH 88/92] [todo] support to get ci.xml from mmtp

---
 net/mmt/mmt_control.cc |   18 +++++++++++++++---
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_inc.h      |   12 ++++++++++++
 net/mmt/mmt_stream.cc  |   42 +++++++++++++++++++++---------------------
 net/mmt/mmt_stream.h   |    2 ++
 net/mmt/mmt_utils.cc   |   10 ++++++++++
 6 files changed, 61 insertions(+), 24 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 3ee8eb7..db509e4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -170,12 +170,14 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     }
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
+    std::string proto;
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
     StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
+        proto = stream->GetProto();
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
         if (iret == -3) { // waiting 
             LOG(INFO) << __func__ << " waiting...";
@@ -193,11 +195,14 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (msg.tabid > 0) {
         cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
-            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
+            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid << " proto=" << proto;
             cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
             // TODO ci xml for testing
-            cixml->fname = kMmtDefaultXml;
+            cixml->proto = proto;
+            cixml->fname = "";
+            if (proto != kMmtProtoMmtp)
+                cixml->fname = kMmtDefaultXml;
         }else {
             cixml = cixmls_[msg.tabid];
         }
@@ -223,6 +228,13 @@ void MmtControl::CheckEvent() {
         cixmlptr_t cixml = iter->second;
         if (!cixml) continue;
         if (cixml->status == "end") continue;
+        if (cixml->proto == kMmtProtoMmtp && cixml->fname.empty()) {
+            mmtp_info_t mmtp;
+            if(MmtpPop(kMmtMediaCI, mmtp)) {
+                cixml->fname = mmtp.fname;
+            }
+            LOG(INFO) << __func__ << " get xml file=" << cixml->fname;
+        }
         if (cixml->fname.empty()) continue;
 
         std::string xml_name = cixml->fname;
@@ -239,7 +251,7 @@ void MmtControl::CheckEvent() {
             if (!cixml->parser) { // first load
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
-                    LOG(INFO) << __func__ << " fail to parse xml first";
+                    LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
                     cixml->parser = nullptr;
                     cixml->update = 15;
                 }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f362e3c..029c6f8 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,6 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
+    std::string proto;      //> "local" or "mmtp"
     int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index f389b1d..a9cd73c 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -78,6 +78,18 @@ int SendToHost(std::string msg, std::string szaddr, int port);
 int64 GetLocalTime();
 int64 GetNTPTime();
 
+/**
+ * media/proto constants
+ */
+extern const char kMmtMediaAudio[];
+extern const char kMmtMediaVideo[];
+extern const char kMmtMediaImage[];
+extern const char kMmtMediaHtml[];
+extern const char kMmtMediaCI[];
+
+extern const char kMmtProtoMmtp[];
+extern const char kMmtProtoLocal[];
+
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 373a103..1675150 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -8,14 +8,6 @@ namespace mmt {
 #define USE_MMTP 1
 
 static const long kMmtMediaSize = 0x7fffffff;
-
-static const char kMmtMediaAudio[] = "audio";
-static const char kMmtMediaVideo[] = "video";
-static const char kMmtMediaImage[] = "image";
-static const char kMmtMediaMmtp[] = "mmtp";
-static const char kMmtMediaHtml[] = "html";
-static const char kMmtMediaCI[] = "ci";
-
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
 
@@ -119,17 +111,19 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
 
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = fname;
+    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
     mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
     MmtpPush(mmtp);
-    LOG(INFO) << __func__ << " END";
 }
 
 void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype;
+    base::FilePath fpath;
+    base::GetCurrentDirectory (&fpath);
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = fname;
+    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
     mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
     MmtpPush(mmtp);
     LOG(INFO) << __func__ << " END";
@@ -200,6 +194,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
+    proto_ = kMmtProtoLocal;
 }
 
 Stream::~Stream() {
@@ -212,22 +207,26 @@ bool Stream::ParseSequence(int& index) {
     if (!query.empty()) { // media sequence
         std::string mtype = GetQueryValue(query, "type");
         std::string range = GetQueryValue(query, "sequence_num");
-        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
-        if (mtype.empty()) return false;
-        mtype_ = mtype;
+        std::string proto = GetQueryValue(query, "proto");
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range << " proto=" << proto; 
+        if (mtype.empty() && proto.empty()) return false;
+        if (!proto.empty()) proto_ = proto;
 
+        mtype_ = mtype;
         if (mtype == kMmtMediaImage) {
             index = -2;
             return true;
         }
 
         // compute the sequence of media
-        GetRangeValue(range, midx_.begin, midx_.end);
-        index = midx_.begin;
-        LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
-        if (index < 0 || midx_.begin > midx_.end) return false;
+        {
+            GetRangeValue(range, midx_.begin, midx_.end);
+            index = midx_.begin;
+            LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
+            if (index < 0 || midx_.begin > midx_.end) return false;
+        }
 
-        if (mtype == kMmtMediaMmtp) { // for mmtp streaming
+        if (proto_ == kMmtProtoMmtp) { // for mmtp streaming
             index = -3;
         }
     }else { // may be one seperate file, not one media sequence
@@ -282,7 +281,8 @@ void* Stream::Open(const char* filename, int mode) {
             lasterr_ = -3;
             return nullptr;
         }
-        fname = mmtp.fname;
+        GURL url(mmtp.fname);
+        fname = GURL2FilePath(url);
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index f1ddab0..c6e5012 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -142,6 +142,7 @@ public:
      */
     int Prepare(long* size);
     bool ParseSequence(int& index);
+    std::string GetProto() { return proto_;}
     void Uninit();
 
 protected:
@@ -151,6 +152,7 @@ protected:
 private:
     GURL url_;
     std::string mtype_;
+    std::string proto_;
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 5952fab..915b66b 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -7,6 +7,16 @@ namespace mmt {
 #define USE_NTP_TIME 1
 static const char kMmtNtpServer[] = "time.apple.com";
 
+const char kMmtMediaAudio[] = "audio";
+const char kMmtMediaVideo[] = "video";
+const char kMmtMediaImage[] = "image";
+const char kMmtMediaHtml[] = "html";
+const char kMmtMediaCI[] = "ci";
+
+const char kMmtProtoMmtp[] = "mmtp";
+const char kMmtProtoLocal[] = "local";
+
+
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-- 
1.7.9.5


From 848600dd7a3d3598fb97853d9004fd7396225449 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 10:14:52 +0800
Subject: [PATCH 89/92] [todo] fix dead-lock for mmtp-stream

---
 net/mmt/mmt_stream.cc |   43 +++++++++++++++++++++++++++++--------------
 1 file changed, 29 insertions(+), 14 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1675150..50bcbac 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -2,6 +2,7 @@
 #include "net/mmt/mmt_inc.h"
 #include "net/mmt/mpu/mp4.h"
 #include "net/mmt/mmtp/mmtp.h"
+#include "net/mmt/mmt_control.h"
 
 namespace mmt {
 
@@ -99,7 +100,6 @@ void MmtpPush(mmtp_info_t& mmtp) {
 void CIRecvCallback(const char* url, const char* fname, int ftype) {
     base::FilePath fpath;
     base::GetCurrentDirectory (&fpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     // for test
     static bool _had_html = false;
@@ -109,6 +109,7 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
     _had_html = (ftype == 0);
     _had_ci = (ftype == 1);
 
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
     if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
@@ -138,18 +139,21 @@ MmtpStream::~MmtpStream(){
 bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
     if (mlist_.empty()) return false;
 
+    bool isok = false;
     lock_.Acquire();
-    std::map<std::string, mmtp_infos_t>::iterator iter;
-    iter = mlist_.find(key);
-    if (iter == mlist_.end()) return false;
-
-    mmtp_infos_t& infos = iter->second;
-    if (infos.empty()) return false;
+    do {
+        std::map<std::string, mmtp_infos_t>::iterator iter;
+        iter = mlist_.find(key);
+        if (iter == mlist_.end()) break;
+        mmtp_infos_t& infos = iter->second;
+        if (infos.empty()) break;
 
-    mmtp = infos.back();
-    infos.pop_back();
+        mmtp = infos.back();
+        infos.pop_back();
+        isok = true;
+    }while(false);
     lock_.Release();
-    return true;
+    return isok;
 }
 void MmtpStream::Push(const mmtp_info_t& mmtp) {
     //TODO: should be url, but now testing
@@ -240,7 +244,11 @@ int Stream::Prepare(long *size) {
 
     long lret = kMmtMediaSize;  // TODO: default size for media sequence
     if (midx_.cur < 0) {        // return real size for single file
-        lret = offmap_[midx_.cur].size; 
+        if (proto_ == kMmtProtoMmtp && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo)) {
+            // for mmtp sequence
+        }else {
+            lret = offmap_[midx_.cur].size; 
+        }
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -277,9 +285,16 @@ void* Stream::Open(const char* filename, int mode) {
     } else if (index == -3) { // mmtp streaming
         MmtpStart();
         mmtp_info_t mmtp;
-        if(!MmtpPop(kMmtMediaHtml, mmtp)) {
-            lasterr_ = -3;
-            return nullptr;
+        if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
+            if(!MmtpPop(mtype_, mmtp)) {
+                lasterr_ = -3;
+                return nullptr;
+            }
+        }else {
+            if(!MmtpPop(kMmtMediaHtml, mmtp)) {
+                lasterr_ = -3;
+                return nullptr;
+            }
         }
         GURL url(mmtp.fname);
         fname = GURL2FilePath(url);
-- 
1.7.9.5


From 48d5998bd17efcbee663c0a4a35b9c61623c189d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 10:25:05 +0800
Subject: [PATCH 90/92] [todo] support audio/video recever from mmtp

---
 net/mmt/mmt_stream.cc |   65 ++++++++++++++++++++++++++++---------------------
 net/mmt/mmt_stream.h  |    2 ++
 2 files changed, 39 insertions(+), 28 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 50bcbac..342afc8 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -199,6 +199,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
     proto_ = kMmtProtoLocal;
+    first_ = true;
 }
 
 Stream::~Stream() {
@@ -255,6 +256,37 @@ int Stream::Prepare(long *size) {
     return 0;
 }
 
+long Stream::ParseMpu() {
+    // TODO: process image of mp4 here
+    // check moof box and other
+    stream_t* s = InitMpuStream(this);
+    mp4_box_t* root = MP4_BoxGetRoot(s);
+    mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+
+    long offset = -1;
+    mp4_box_t* box = nullptr;
+    if (mtype_ == kMmtMediaImage) {
+        box = MP4_BoxSearchBox(box0, ATOM_idat);
+        offset = 8;
+    }else {
+        box = MP4_BoxSearchBox(box0, ATOM_moof);
+        offset = 0;
+    }
+    LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+        << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+
+    // get the pos of the 1st moof-box
+    long ipos = -1;
+    if (box) ipos = box->i_pos;
+    MP4_BoxFree(s, root);
+    free(s);
+
+    // seek to the 1st moof-box
+    if (ipos == -1) return -1;
+    offset += ipos;
+    return offset;
+}
+
 void* Stream::Open(const char* filename, int mode) {
     lasterr_ = 0;
     if (file_) return (void *)file_;
@@ -312,39 +344,16 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != -1 && index != midx_.begin && index != -3) {
-        // TODO: process image of mp4 here
-        // check moof box and other
-        stream_t* s = InitMpuStream(this);
-        mp4_box_t* root = MP4_BoxGetRoot(s);
-        mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
-
-        long offset = -1;
-        mp4_box_t* box = nullptr;
-        if (mtype_ == kMmtMediaImage) {
-            box = MP4_BoxSearchBox(box0, ATOM_idat);
-            offset = 8;
-        }else {
-            box = MP4_BoxSearchBox(box0, ATOM_moof);
-            offset = 0;
-        }
-        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
-            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
-
-        // get the pos of the 1st moof-box
-        long ipos = -1;
-        if (box) ipos = box->i_pos;
-        MP4_BoxFree(s, root);
-        free(s);
-        
-        // seek to the 1st moof-box
-        if (ipos == -1) return nullptr;
-        offset += ipos;
+    if ((index != -1 && index != midx_.begin && index != -3) || 
+        (index == -3 && !first_ && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo))) {
+        long offset = ParseMpu();
+        if (offset == -1) return nullptr;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
+        if (index == -3) first_ = false;
     }
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c6e5012..673eaf4 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -142,6 +142,7 @@ public:
      */
     int Prepare(long* size);
     bool ParseSequence(int& index);
+    long ParseMpu();
     std::string GetProto() { return proto_;}
     void Uninit();
 
@@ -157,6 +158,7 @@ private:
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
     int lasterr_;
+    bool first_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
 };
-- 
1.7.9.5


From de4383d58312f115a43b937fa14801b318cde6cb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 22:19:51 +0800
Subject: [PATCH 91/92] [ok] refine mmt_stream of local & mmtp

---
 net/mmt/mmt_control.cc |    4 +-
 net/mmt/mmt_inc.h      |    3 +
 net/mmt/mmt_stream.cc  |  190 ++++++++++++++++++++++++++----------------------
 net/mmt/mmt_stream.h   |   33 +++++++--
 net/mmt/mmt_utils.cc   |    3 +-
 5 files changed, 136 insertions(+), 97 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index db509e4..9d2c786 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -230,7 +230,9 @@ void MmtControl::CheckEvent() {
         if (cixml->status == "end") continue;
         if (cixml->proto == kMmtProtoMmtp && cixml->fname.empty()) {
             mmtp_info_t mmtp;
-            if(MmtpPop(kMmtMediaCI, mmtp)) {
+            mmtp.url = "";
+            mmtp.mtype = kMmtMediaCI;
+            if(MmtpPop(mmtp)) {
                 cixml->fname = mmtp.fname;
             }
             LOG(INFO) << __func__ << " get xml file=" << cixml->fname;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index a9cd73c..063660c 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -81,6 +81,8 @@ int64 GetNTPTime();
 /**
  * media/proto constants
  */
+extern const char kMmtNtpServer[];
+
 extern const char kMmtMediaAudio[];
 extern const char kMmtMediaVideo[];
 extern const char kMmtMediaImage[];
@@ -89,6 +91,7 @@ extern const char kMmtMediaCI[];
 
 extern const char kMmtProtoMmtp[];
 extern const char kMmtProtoLocal[];
+extern const char kMmtDefaultUrl[];
 
 }
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 342afc8..8e7b3c2 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,8 +6,6 @@
 
 namespace mmt {
 
-#define USE_MMTP 1
-
 static const long kMmtMediaSize = 0x7fffffff;
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
@@ -66,7 +64,6 @@ stream_t* InitMpuStream(Stream* ptr) {
 } // namespace mmt
 
 
-
 namespace mmt {
 
 static MmtpStream* g_mmtp = nullptr;
@@ -85,21 +82,25 @@ void MmtpStop() {
         g_mmtp->StopMmtp();
     }
 }
-bool MmtpPop(std::string key, mmtp_info_t& mmtp) {
+void MmtpOpen(const std::string url) {
     if (g_mmtp) {
-        return g_mmtp->Pop(key, mmtp);
+        g_mmtp->OpenMmtp(url);
+    }
+}
+bool MmtpPop(mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        return g_mmtp->Pop(mmtp);
     }
     return false;
 }
-void MmtpPush(mmtp_info_t& mmtp) {
+void MmtpPush(const mmtp_info_t& mmtp) {
     if (g_mmtp) {
         g_mmtp->Push(mmtp);
     }
 }
 
 void CIRecvCallback(const char* url, const char* fname, int ftype) {
-    base::FilePath fpath;
-    base::GetCurrentDirectory (&fpath);
+    if (!fname) return;
 
     // for test
     static bool _had_html = false;
@@ -109,68 +110,83 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
     _had_html = (ftype == 0);
     _had_ci = (ftype == 1);
 
+    base::FilePath cpath(fname);
+    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
     LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
+    mmtp.fname = kMmtDefaultUrl + fpath.value();
     mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
     MmtpPush(mmtp);
 }
 
 void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    base::FilePath fpath;
-    base::GetCurrentDirectory (&fpath);
+    if (!fname) return;
+    base::FilePath cpath(fname);
+    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
     LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
+    mmtp.fname = kMmtDefaultUrl + fpath.value();
     mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
     MmtpPush(mmtp);
-    LOG(INFO) << __func__ << " END";
 }
 
+mmtp_info_t::mmtp_info_t() {
+    index = -1;
+}
+
+mmtp_media_t::mmtp_media_t() {}
+mmtp_media_t::~mmtp_media_t() {}
+
 MmtpStream::MmtpStream(){
     mmtprun_ = false;
 }
 MmtpStream::~MmtpStream(){
 }
 
-bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
+bool MmtpStream::Pop(mmtp_info_t& mmtp) {
     if (mlist_.empty()) return false;
 
+    std::string key = mmtp.url + "@" + mmtp.mtype;
     bool isok = false;
+
     lock_.Acquire();
     do {
-        std::map<std::string, mmtp_infos_t>::iterator iter;
+        std::map<std::string, mmtp_media_ptr_t>::iterator iter;
         iter = mlist_.find(key);
         if (iter == mlist_.end()) break;
-        mmtp_infos_t& infos = iter->second;
-        if (infos.empty()) break;
 
-        mmtp = infos.back();
-        infos.pop_back();
+        mmtp_media_ptr_t media = iter->second;
+        if (media->flist.empty()) break;
+
+        mmtp = media->flist.back();
+        media->flist.pop_back();
         isok = true;
     }while(false);
     lock_.Release();
     return isok;
 }
+
 void MmtpStream::Push(const mmtp_info_t& mmtp) {
-    //TODO: should be url, but now testing
-    std::string key = mmtp.mtype;
-    std::map<std::string, mmtp_infos_t>::iterator iter;
+    std::string key = mmtp.url + "@" + mmtp.mtype;
+    std::map<std::string, mmtp_media_ptr_t>::iterator iter;
+
     lock_.Acquire();
     iter = mlist_.find(key);
     if (iter != mlist_.end()) {
-        mmtp_infos_t& infos = iter->second;
-        infos.insert(infos.begin(), mmtp);
+        mmtp_media_ptr_t media = iter->second;
+        media->flist.insert(media->flist.begin(), mmtp);
     }else {
-        mmtp_infos_t infos;
-        infos.push_back(mmtp);
-        mlist_[key] = infos;
+        mmtp_media_ptr_t media = new mmtp_media_t;;
+        media->flist.push_back(mmtp);
+        mlist_[key] = media;
     }
     lock_.Release();
 }
+
 void MmtpStream::StartMmtp() {
     if (mmtprun_) return;
     init_mmtp();
@@ -181,6 +197,11 @@ void MmtpStream::StartMmtp() {
     start_mmtp();
     mmtprun_ = true;
 }
+
+void MmtpStream::OpenMmtp(const std::string url) {
+    open_mmtp(url.c_str());
+}
+
 void MmtpStream::StopMmtp() {
     if (!mmtprun_) return;
     stop_mmtp();
@@ -188,22 +209,22 @@ void MmtpStream::StopMmtp() {
     mmtprun_ = false;
 }
 
+} // namespace mmt
+
+
+namespace mmt {
 
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
-    midx_.begin = -1;
-    midx_.end = -1;
-    midx_.cur = -1;
-    lasterr_ = 0;
+    ReInit();
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
-    proto_ = kMmtProtoLocal;
-    first_ = true;
+    ReInit();
 }
 
 Stream::~Stream() {
-    Uninit();
+    ReInit();
 }
 
 bool Stream::ParseSequence(int& index) {
@@ -215,25 +236,18 @@ bool Stream::ParseSequence(int& index) {
         std::string proto = GetQueryValue(query, "proto");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range << " proto=" << proto; 
         if (mtype.empty() && proto.empty()) return false;
-        if (!proto.empty()) proto_ = proto;
 
-        mtype_ = mtype;
-        if (mtype == kMmtMediaImage) {
-            index = -2;
-            return true;
-        }
+        if (proto == kMmtProtoMmtp) mtype_ = kMmtMediaHtml;  // default is html for mmtp
+        if (!proto.empty()) proto_ = proto;
+        if (!mtype.empty()) mtype_ = mtype;
 
-        // compute the sequence of media
-        {
+        // compute the sequence of media and get current index
+        if (!range.empty()) {
             GetRangeValue(range, midx_.begin, midx_.end);
             index = midx_.begin;
             LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
             if (index < 0 || midx_.begin > midx_.end) return false;
         }
-
-        if (proto_ == kMmtProtoMmtp) { // for mmtp streaming
-            index = -3;
-        }
     }else { // may be one seperate file, not one media sequence
         index = -1;
     }
@@ -243,13 +257,11 @@ bool Stream::ParseSequence(int& index) {
 int Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return lasterr_;
 
-    long lret = kMmtMediaSize;  // TODO: default size for media sequence
-    if (midx_.cur < 0) {        // return real size for single file
-        if (proto_ == kMmtProtoMmtp && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo)) {
-            // for mmtp sequence
-        }else {
-            lret = offmap_[midx_.cur].size; 
-        }
+    long lret = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
+        lret = kMmtMediaSize;
+    }else {
+        lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -298,38 +310,36 @@ void* Stream::Open(const char* filename, int mode) {
         return nullptr;
     }
 
-    // default for one seperate file
-    //  index >= 0: media sequence
-    //  index == -1: common file
-    //  index == -2: mp4 image file
-    //  index == -3: mmtp streaming receiver
-    std::string fname = GURL2FilePath(url_);
-    if (index >= 0) { // for media sequence
+    if (index >= 0) { // check index
         if (index < midx_.begin || index > midx_.end)
             return nullptr;
+    }
 
-        std::string mtype = GetQueryValue(url_.query(), "type");
-        if (mtype == kMmtMediaAudio) {
-            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == kMmtMediaVideo) {
-            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
-        }
-    } else if (index == -3) { // mmtp streaming
+    std::string fname;
+    if (proto_ == kMmtProtoMmtp) { // for mmt streaming
         MmtpStart();
+
         mmtp_info_t mmtp;
-        if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
-            if(!MmtpPop(mtype_, mmtp)) {
-                lasterr_ = -3;
-                return nullptr;
-            }
-        }else {
-            if(!MmtpPop(kMmtMediaHtml, mmtp)) {
-                lasterr_ = -3;
-                return nullptr;
-            }
+        mmtp.url = "";  // TODO: now do not support url in mmtp receiver.
+        mmtp.mtype = mtype_;
+        mmtp.index = index;
+        if(!MmtpPop(mmtp)) {
+            lasterr_ = -3;
+            return nullptr;
         }
         GURL url(mmtp.fname);
         fname = GURL2FilePath(url);
+    }else if (proto_ == kMmtProtoLocal) { // for local media
+        fname = GURL2FilePath(url_);
+        if (mtype_ == kMmtMediaAudio) { 
+            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype_ == kMmtMediaVideo) {
+            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype_ == kMmtMediaImage) { // not process
+        }
+    }else {
+        LOG(INFO) << __func__ << " invalid proto=" << proto_;
+        return nullptr;
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
@@ -344,17 +354,18 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if ((index != -1 && index != midx_.begin && index != -3) || 
-        (index == -3 && !first_ && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo))) {
-        long offset = ParseMpu();
-        if (offset == -1) return nullptr;
-        offmap_[index] = offset_t(offset, lret);
-        ierr = fseek(file_, offset, SEEK_SET);
-        if (ierr != 0) return nullptr; 
-    }else { // the 1st seq file or single file
-        offmap_[index] = offset_t(0, lret);
-        if (index == -3) first_ = false;
+    long offset = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo || mtype_ == kMmtMediaImage) {
+        if (mtype_ == kMmtMediaImage || !first_) {
+            offset = ParseMpu();
+            if (offset == -1) return nullptr;
+            ierr = fseek(file_, offset, SEEK_SET);
+            if (ierr != 0) return nullptr; 
+        }
     }
+    offmap_[index] = offset_t(offset, lret);
+    if(first_) first_ = false;
+
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
@@ -399,11 +410,14 @@ int Stream::Close() {
     return 0;
 }
 
-void Stream::Uninit() {
+void Stream::ReInit() {
     Close();
+    proto_ = kMmtProtoLocal;
     midx_.begin = -1;
     midx_.end = -1;
     midx_.cur = -1;
+    first_ = true;
+    lasterr_ = 0;
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 673eaf4..3c570ea 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -51,11 +51,21 @@ namespace mmt {
  * Mmtp information
  */
 struct mmtp_info_t {
+    mmtp_info_t();
     std::string url;
     std::string mtype; // "audio"/"video"/"image"/"ci"/"html" 
     std::string fname;
+    int index;
 };
-typedef std::vector<mmtp_info_t> mmtp_infos_t;
+struct mmtp_media_t : public base::RefCounted<mmtp_media_t>{
+    mmtp_media_t();
+    std::vector<mmtp_info_t> flist;
+
+protected:
+    friend class base::RefCounted<mmtp_media_t>;
+    virtual ~mmtp_media_t();
+};
+typedef scoped_refptr<mmtp_media_t> mmtp_media_ptr_t;
 
 /**
  * mmtp resource: audio/video/image/
@@ -65,23 +75,32 @@ public:
     MmtpStream();
     virtual ~MmtpStream();
 
-    bool Pop(std::string key, mmtp_info_t& mmtp);
+    /**
+     * @param mmtp: [in] should contain mtype and url, [out] return fname
+     */
+    bool Pop(mmtp_info_t& mmtp);
+
+    /**
+     * @param mmtp: [in] should contain mtype, url and fname
+     */
     void Push(const mmtp_info_t& mmtp);
+
     // for mmtp control
     void StartMmtp();
     void StopMmtp();
+    void OpenMmtp(const std::string url);
 
 private:
     bool mmtprun_;
     base::Lock lock_;
-    std::map<std::string, mmtp_infos_t> mlist_; // url => ..
+    std::map<std::string, mmtp_media_ptr_t> mlist_; // url@mtype => ..
 };
-typedef scoped_refptr<MmtpStream> MmtpStreamPtr;
 
 void MmtpStart();
 void MmtpStop();
-bool MmtpPop(std::string key, mmtp_info_t& mmtp);
-void MmtpPush(mmtp_info_t& mmtp);
+void MmtpOpen(const std::string url);
+bool MmtpPop(mmtp_info_t& mmtp);
+void MmtpPush(const mmtp_info_t& mmtp);
 
 
 /**
@@ -144,7 +163,7 @@ public:
     bool ParseSequence(int& index);
     long ParseMpu();
     std::string GetProto() { return proto_;}
-    void Uninit();
+    void ReInit();
 
 protected:
     friend class base::RefCounted<Stream>;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 915b66b..3189615 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -5,7 +5,7 @@
 namespace mmt {
 
 #define USE_NTP_TIME 1
-static const char kMmtNtpServer[] = "time.apple.com";
+const char kMmtNtpServer[] = "time.apple.com";
 
 const char kMmtMediaAudio[] = "audio";
 const char kMmtMediaVideo[] = "video";
@@ -15,6 +15,7 @@ const char kMmtMediaCI[] = "ci";
 
 const char kMmtProtoMmtp[] = "mmtp";
 const char kMmtProtoLocal[] = "local";
+const char kMmtDefaultUrl[] = "mmt://localhost";
 
 
 void Wait(int ms) {
-- 
1.7.9.5


From fe15a0adbdf4d58d213aca45965d45aecf20c34c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 23:10:43 +0800
Subject: [PATCH 92/92] [ok] refine mmtp's callback

---
 net/mmt/mmt_stream.cc |   77 ++++++++++++++++++++-----------------------------
 net/mmt/mmtp/client.c |   28 ++++++++++--------
 net/mmt/mmtp/mmt.c    |    6 +---
 net/mmt/mmtp/mmtp.h   |   38 +++++++++++++++++-------
 4 files changed, 76 insertions(+), 73 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 8e7b3c2..563a8c9 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -72,65 +72,53 @@ void MmtpStart() {
     if (!g_mmtp) {
         g_mmtp = new MmtpStream;
     }
-
-    if (g_mmtp) {
-        g_mmtp->StartMmtp();
-    }
+    g_mmtp->StartMmtp();
 }
 void MmtpStop() {
-    if (g_mmtp) {
-        g_mmtp->StopMmtp();
-    }
+    if (!g_mmtp) return;
+    g_mmtp->StopMmtp();
 }
 void MmtpOpen(const std::string url) {
-    if (g_mmtp) {
-        g_mmtp->OpenMmtp(url);
-    }
+    if (!g_mmtp) return;
+    g_mmtp->OpenMmtp(url);
 }
 bool MmtpPop(mmtp_info_t& mmtp) {
-    if (g_mmtp) {
-        return g_mmtp->Pop(mmtp);
-    }
-    return false;
+    if (!g_mmtp) return false;
+    return g_mmtp->Pop(mmtp);
 }
 void MmtpPush(const mmtp_info_t& mmtp) {
-    if (g_mmtp) {
-        g_mmtp->Push(mmtp);
-    }
+    if (!g_mmtp) return;
+    g_mmtp->Push(mmtp);
 }
 
-void CIRecvCallback(const char* url, const char* fname, int ftype) {
-    if (!fname) return;
+void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
+    if (!rinfo) return;
 
     // for test
-    static bool _had_html = false;
-    static bool _had_ci = false;
-    if (ftype == 0 && _had_html) return;
-    if (ftype == 1 && _had_ci) return;
-    _had_html = (ftype == 0);
-    _had_ci = (ftype == 1);
-
-    base::FilePath cpath(fname);
-    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
-
-    mmtp_info_t mmtp;
-    if (url) mmtp.url = url;
-    mmtp.fname = kMmtDefaultUrl + fpath.value();
-    mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
-    MmtpPush(mmtp);
-}
+    std::string mtype;
+    int ftype = rinfo->ftype;
+    if(rinfo->res & Res_Signal) {
+        static bool _had_html = false;
+        static bool _had_ci = false;
+        if (ftype == 0 && _had_html) return;
+        if (ftype == 1 && _had_ci) return;
+        _had_html = (ftype == 0);
+        _had_ci = (ftype == 1);
+        mtype = (ftype == 0) ? kMmtMediaHtml : kMmtMediaCI;
+    }else if (rinfo->res & Res_Media){
+        mtype = (ftype == 2) ? kMmtMediaVideo : kMmtMediaAudio;
+    }else {
+        return;
+    }
 
-void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    if (!fname) return;
-    base::FilePath cpath(fname);
+    base::FilePath cpath(rinfo->fname);
     base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+    LOG(INFO) << __func__ << " fname=" << rinfo->fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     mmtp_info_t mmtp;
-    if (url) mmtp.url = url;
+    mmtp.url = rinfo->url;
     mmtp.fname = kMmtDefaultUrl + fpath.value();
-    mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
+    mmtp.mtype = mtype;
     MmtpPush(mmtp);
 }
 
@@ -190,10 +178,7 @@ void MmtpStream::Push(const mmtp_info_t& mmtp) {
 void MmtpStream::StartMmtp() {
     if (mmtprun_) return;
     init_mmtp();
-    mmtp_callback_t cb;
-    cb.cifunc = CIRecvCallback;
-    cb.mpufunc = MPURecvCallback;
-    set_mmtp_callback(&cb);
+    set_mmtp_callback(MmtpRecvCallback);
     start_mmtp();
     mmtprun_ = true;
 }
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 0ad507d..99be27e 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -733,10 +733,8 @@ void *mpu_consumer_f(void *arg)						/**/
 									fclose(mpu);
 									free_mpu_buf(&mpu_buf );
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
 
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 								}
 //								free(mfu_buf);
 //								if(ringq_poll(p_queue,&recive_mfu)>=0);
@@ -886,9 +884,7 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 
 								}
 								//,,
@@ -946,9 +942,7 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 								}
 
 							}
@@ -973,7 +967,7 @@ void init_mmtp() {
 	mpu_buff_list=InitList();
 	pthread_mutex_init (&signal_mutex,NULL);
 	pthread_mutex_init (&mpu_mutex,NULL);
-    memset(&g_mmtp_cb, 0, sizeof(g_mmtp_cb));
+    g_mmtp_cb = NULL;
 }
 
 void start_mmtp() {
@@ -1006,7 +1000,17 @@ void uninit_mmtp() {
     DestroyList(mpu_buff_list);
 }
 
-void set_mmtp_callback(mmtp_callback_t* mmtp_cb) {
-    g_mmtp_cb = *mmtp_cb;
+void set_mmtp_callback(mmtp_callback_t cb) {
+    g_mmtp_cb = cb;
 }
 
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype) {
+    if (!g_mmtp_cb) return;
+    struct mmtp_rinfo_t rinfo;
+    memset(&rinfo, 0, sizeof(rinfo));
+    rinfo.res = res;
+    strncpy(rinfo.url, url, sizeof(rinfo.url));
+    strncpy(rinfo.fname, fname, sizeof(rinfo.fname));
+    rinfo.ftype = ftype;
+    g_mmtp_cb(&rinfo);
+}
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
index 2188743..bf813e1 100644
--- a/net/mmt/mmtp/mmt.c
+++ b/net/mmt/mmtp/mmt.c
@@ -24,8 +24,6 @@
 #include "send.h"
 #include "mmtp.h"
 
-extern mmtp_callback_t g_mmtp_cb;
-
 int get_send_timestamp()
 {
 	int MMT_timestamp;
@@ -1060,9 +1058,7 @@ int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
 			fclose(mpi);
 
 			printf("finished recive a ci - %d - %s\n", i, (const char *)mpi_table->PI_content[i].PI_content_name_byte);
-            if (g_mmtp_cb.cifunc) {
-                g_mmtp_cb.cifunc(NULL, (const char *)mpi_table->PI_content[i].PI_content_name_byte, i);
-            }
+            push_mmtp_rinfo(Res_Signal, "", (char *)mpi_table->PI_content[i].PI_content_name_byte, i);
         }
 	 return 0;
 
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index dd2099c..140fb3b 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -11,16 +11,34 @@ void open_mmtp(const char* url);
 void stop_mmtp();
 void uninit_mmtp();
 
-// for ci.xml and index.html
-typedef void (*mmtp_ci_func_t) (const char* url, const char* fname, int ftype);
-// for audio, video and image
-typedef void (*mmtp_mpu_func_t) (const char* url, const char* fname, int ftype);
-typedef struct mmtp_callback_t {
-    mmtp_ci_func_t cifunc;
-    mmtp_mpu_func_t mpufunc;
-}mmtp_callback_t;
-
-void set_mmtp_callback(mmtp_callback_t* mmtp_cb);
+enum mmtp_res_t {
+    Res_Unknown   = 0,
+    Res_CI        = 0x1,
+    Res_Html      = 0x2,
+    Res_Signal    = Res_CI + Res_Html,
+
+    Res_Video     = 0x4,
+    Res_Audio     = 0x8,
+    Res_Image     = 0x10,
+    Res_Media     = Res_Video + Res_Audio + Res_Image,
+};
+
+// info of recv data
+struct mmtp_rinfo_t {
+    int  res;      //> mmtp_res_t
+    char url[1024];
+    char fname[1024];
+    int  ftype;
+};
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype);
+
+/**
+ * for ci.xml and index.html
+ * for audio, video and image
+ */
+typedef void (*mmtp_callback_t) (struct mmtp_rinfo_t* rinfo);
+
+void set_mmtp_callback(mmtp_callback_t cb);
 
 #ifdef __cplusplus
 }
-- 
1.7.9.5

