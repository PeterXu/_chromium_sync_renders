diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..d76a909 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+          content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..e4ed0ad 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,9 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_CHROMEUI   = 1 << 4,
-    SCHEME_EXTENSION  = 1 << 5,
-    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 4,
+    SCHEME_CHROMEUI   = 1 << 5,
+    SCHEME_EXTENSION  = 1 << 6,
+    SCHEME_FILESYSTEM = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,15 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..1597f24 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,18 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'base/directory_lister.cc',
+            'base/directory_lister.h',
+            'url_request/url_request_file_dir_job.cc',
+            'url_request/url_request_file_dir_job.h',
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..ee879d2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1135,6 +1135,8 @@
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1178,6 +1180,8 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..86afe03
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request->url(), &file_path);
+
+  // Check file access permissions.
+  if (!network_delegate ||
+      !network_delegate->CanAccessFile(*request, file_path)) {
+    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
+  }
+
+  // We need to decide whether to create URLRequestMmtJob for file access or
+  // URLRequestFileDirJob for directory access. To avoid accessing the
+  // filesystem, we only look at the path string here.
+  // The code in the URLRequestMmtJob::Start() method discovers that a path,
+  // which doesn't end with a slash, should really be treated as a directory,
+  // and it then redirects to the URLRequestFileDirJob.
+  if (is_file &&
+      file_path.EndsWithSeparator() &&
+      file_path.IsAbsolute()) {
+    return new URLRequestFileDirJob(request, network_delegate, file_path);
+  }
+
+  // Use a regular file request job for all non-directories (including invalid
+  // file names).
+  return new URLRequestMmtJob(request, network_delegate, file_path,
+                               file_task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..28ca9b6
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
+// then all file requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..efb9e5c 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+    if (mmt_enabled_) {
+      job_factory->SetProtocolHandler(
+      "mmt",
+      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+    }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..2aff0dd 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -117,6 +117,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +209,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..c5b8f9c
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,326 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_mmt_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/files/file_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace net {
+
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequestMmtJob::URLRequestMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const base::FilePath& file_path,
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : URLRequestJob(request, network_delegate),
+      file_path_(file_path),
+      stream_(new FileStream(file_task_runner)),
+      file_task_runner_(file_task_runner),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void URLRequestMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  file_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequestMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+Filter* URLRequestMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
+
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
+  return false;
+}
+
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
+}
+
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
+}
+
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
+
+URLRequestMmtJob::~URLRequestMmtJob() {
+}
+
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
+}
+
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+
+  // We use URLRequestMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequestMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequestMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
+  }
+}
+
+void URLRequestMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
+
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..1ff88d2
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,110 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const base::FilePath& file_path,
+                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
+
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  HttpByteRange byte_range_;
+  int64 remaining_bytes_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
