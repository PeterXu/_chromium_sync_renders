From 9401570e18af49e61c3e7401cea75d30db89c06f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 03:45:47 -0800
Subject: [PATCH 001/128] a. fix revision of .DEPS.git; b. simulate mmt:// as
 file://

---
 .DEPS.git                                      |    2 +-
 build/common.gypi                              |    7 +
 components/cronet/tools/cr_cronet.py           |    2 +-
 net/BUILD.gn                                   |   17 ++
 net/url_request/mmt_protocol_handler.cc        |   57 +++++
 net/url_request/mmt_protocol_handler.h         |   44 ++++
 net/url_request/url_request_context_builder.cc |   15 ++
 net/url_request/url_request_context_builder.h  |   11 +
 net/url_request/url_request_mmt_job.cc         |  326 ++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h          |  110 ++++++++
 10 files changed, 589 insertions(+), 2 deletions(-)
 create mode 100644 net/url_request/mmt_protocol_handler.cc
 create mode 100644 net/url_request/mmt_protocol_handler.h
 create mode 100644 net/url_request/url_request_mmt_job.cc
 create mode 100644 net/url_request/url_request_mmt_job.h

diff --git a/.DEPS.git b/.DEPS.git
index f9e999d..e2c448e 100644
--- a/.DEPS.git
+++ b/.DEPS.git
@@ -7,7 +7,7 @@ vars = {
     'eyes-free':
          'http://eyes-free.googlecode.com/svn',
     'webkit_rev':
-         '@64a2283924686d78c39e67cbf6f64110e2093c61',
+         '@10657423ffbd4b9bdd360113f34d47b5cf94daa6',
     'blink':
          'http://src.chromium.org/blink',
     'skia':
diff --git a/build/common.gypi b/build/common.gypi
index 30239f1..4d0cefd 100644
--- a/build/common.gypi
+++ b/build/common.gypi
@@ -544,6 +544,9 @@
       # Enable FTP support by default.
       'disable_ftp_support%': 0,
 
+      # Enable MMT support by default.
+      'disable_mmt_support%': 0,
+
       # Use native android functions in place of ICU.  Not supported by most
       # components.
       'use_icu_alternatives_on_android%': 0,
@@ -1179,6 +1182,7 @@
     'enable_captive_portal_detection%': '<(enable_captive_portal_detection)',
     'disable_file_support%': '<(disable_file_support)',
     'disable_ftp_support%': '<(disable_ftp_support)',
+    'disable_mmt_support%': '<(disable_mmt_support)',
     'use_icu_alternatives_on_android%': '<(use_icu_alternatives_on_android)',
     'enable_task_manager%': '<(enable_task_manager)',
     'sas_dll_path%': '<(sas_dll_path)',
@@ -2955,6 +2959,9 @@
       ['disable_ftp_support==1', {
         'defines': ['DISABLE_FTP_SUPPORT=1'],
       }],
+      ['disable_mmt_support==1', {
+        'defines': ['DISABLE_MMT_SUPPORT=1'],
+      }],
       ['use_icu_alternatives_on_android==1', {
         'defines': ['USE_ICU_ALTERNATIVES_ON_ANDROID=1'],
       }],
diff --git a/components/cronet/tools/cr_cronet.py b/components/cronet/tools/cr_cronet.py
index bdc7312..161a15b 100755
--- a/components/cronet/tools/cr_cronet.py
+++ b/components/cronet/tools/cr_cronet.py
@@ -59,7 +59,7 @@ def main():
   print options
   print extra_options_list
   gyp_defines = 'GYP_DEFINES="OS=android enable_websockets=0 '+ \
-      'disable_file_support=1 disable_ftp_support=1 '+ \
+      'disable_file_support=1 disable_ftp_support=1 disable_mmt_support=1 '+ \
       'use_icu_alternatives_on_android=1" '
   out_dir = 'out/Debug'
   release_arg = ''
diff --git a/net/BUILD.gn b/net/BUILD.gn
index 602eae8..ffd9746 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -47,6 +47,7 @@ disable_ftp_support = is_ios
 declare_args() {
   # Disables support for file URLs.  File URL support requires use of icu.
   disable_file_support = false
+  disable_mmt_support = false
 }
 
 config("net_config") {
@@ -57,6 +58,9 @@ config("net_config") {
   if (disable_file_support) {
     defines += [ "DISABLE_FILE_SUPPORT" ]
   }
+  if (disable_mmt_support) {
+    defines += [ "DISABLE_MMT_SUPPORT" ]
+  }
 }
 
 # Disables Windows warning about size to int truncations.
@@ -137,6 +141,19 @@ component("net") {
     ]
   }
 
+  if (disable_mmt_support) {
+    sources -= [
+      "base/directory_lister.cc",
+      "base/directory_lister.h",
+      "url_request/url_request_file_dir_job.cc",
+      "url_request/url_request_file_dir_job.h",
+      "url_request/url_request_mmt_job.cc",
+      "url_request/url_request_mmt_job.h",
+      "url_request/mmt_protocol_handler.cc",
+      "url_request/mmt_protocol_handler.h",
+    ]
+  }
+
   if (disable_ftp_support) {
     sources -= [
       "ftp/ftp_auth_cache.cc",
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
new file mode 100644
index 0000000..3b62225
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/url_request/mmt_protocol_handler.h"
+
+#include "base/logging.h"
+#include "base/task_runner.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "net/url_request/url_request_mmt_job.h"
+
+namespace net {
+
+MmtProtocolHandler::MmtProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+MmtProtocolHandler::~MmtProtocolHandler() {}
+
+URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
+    URLRequest* request, NetworkDelegate* network_delegate) const {
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request->url(), &file_path);
+
+  // Check file access permissions.
+  if (!network_delegate ||
+      !network_delegate->CanAccessFile(*request, file_path)) {
+    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
+  }
+
+  // We need to decide whether to create URLRequestFileJob for file access or
+  // URLRequestFileDirJob for directory access. To avoid accessing the
+  // filesystem, we only look at the path string here.
+  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // which doesn't end with a slash, should really be treated as a directory,
+  // and it then redirects to the URLRequestFileDirJob.
+  if (is_file &&
+      file_path.EndsWithSeparator() &&
+      file_path.IsAbsolute()) {
+    return new URLRequestFileDirJob(request, network_delegate, file_path);
+  }
+
+  // Use a regular file request job for all non-directories (including invalid
+  // file names).
+  return new URLRequestFileJob(request, network_delegate, file_path,
+                               file_task_runner_);
+}
+
+bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace net
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
new file mode 100644
index 0000000..28ca9b6
--- /dev/null
+++ b/net/url_request/mmt_protocol_handler.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+#define NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+class GURL;
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+
+class NetworkDelegate;
+class URLRequestJob;
+
+// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
+// then all file requests will fail with ERR_ACCESS_DENIED.
+class NET_EXPORT MmtProtocolHandler :
+    public URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit MmtProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  ~MmtProtocolHandler() override;
+  URLRequestJob* MaybeCreateJob(
+      URLRequest* request,
+      NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+  DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_MMT_PROTOCOL_HANDLER_H_
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index c2e1135..efb9e5c 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -44,6 +44,10 @@
 #include "net/url_request/ftp_protocol_handler.h"
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+#include "net/url_request/mmt_protocol_handler.h"
+#endif
+
 namespace net {
 
 namespace {
@@ -208,6 +212,9 @@ URLRequestContextBuilder::URLRequestContextBuilder()
 #if !defined(DISABLE_FTP_SUPPORT)
       ftp_enabled_(false),
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+      mmt_enabled_(false),
+#endif
       http_cache_enabled_(true),
       throttling_enabled_(false),
       channel_id_enabled_(true) {
@@ -400,6 +407,14 @@ URLRequestContext* URLRequestContextBuilder::Build() {
   }
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+    if (mmt_enabled_) {
+      job_factory->SetProtocolHandler(
+      "mmt",
+      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+    }
+#endif
+
   storage->set_job_factory(job_factory);
 
   // TODO(willchan): Support sdch.
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index f26552a..2aff0dd 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -117,6 +117,13 @@ class NET_EXPORT URLRequestContextBuilder {
   }
 #endif
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Control support for mmt:// requests. By default it's disabled.
+  void set_mmt_enabled(bool enable) {
+    mmt_enabled_ = enable;
+  }
+#endif
+
   // TODO(mmenke):  Probably makes sense to get rid of this, and have consumers
   // set their own NetLog::Observers instead.
   void set_net_log(NetLog* net_log) {
@@ -202,6 +209,10 @@ class NET_EXPORT URLRequestContextBuilder {
   // Include support for ftp:// requests.
   bool ftp_enabled_;
 #endif
+#if !defined(DISABLE_MMT_SUPPORT)
+  // Include support for mmt:// requests.
+  bool mmt_enabled_;
+#endif
   bool http_cache_enabled_;
   bool throttling_enabled_;
   bool channel_id_enabled_;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
new file mode 100644
index 0000000..4443c1b
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.cc
@@ -0,0 +1,326 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// For loading files, we make use of overlapped i/o to ensure that reading from
+// the filesystem (e.g., a network filesystem) does not block the calling
+// thread.  An alternative approach would be to use a background thread or pool
+// of threads, but it seems better to leverage the operating system's ability
+// to do background file reads for us.
+//
+// Since overlapped reads require a 'static' buffer for the duration of the
+// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
+// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// attempts to read more from the file to fill its buffer.  If reading from the
+// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// signal from the OS that the overlapped read has completed.  It does so by
+// leveraging the MessageLoop::WatchObject API.
+
+#include "net/url_request/url_request_file_job.h"
+
+#include "base/bind.h"
+#include "base/compiler_specific.h"
+#include "base/files/file_util.h"
+#include "base/message_loop/message_loop.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "base/threading/thread_restrictions.h"
+#include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace net {
+
+URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequesetMmtJob::URLRequesetMmtJob(
+    URLRequest* request,
+    NetworkDelegate* network_delegate,
+    const base::FilePath& file_path,
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : URLRequestJob(request, network_delegate),
+      file_path_(file_path),
+      stream_(new FileStream(file_task_runner)),
+      file_task_runner_(file_task_runner),
+      remaining_bytes_(0),
+      weak_ptr_factory_(this) {}
+
+void URLRequesetMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  file_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequesetMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequesetMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
+}
+
+bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+Filter* URLRequesetMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
+
+bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
+  return false;
+}
+
+void URLRequesetMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
+}
+
+void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+}
+
+void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
+
+URLRequesetMmtJob::~URLRequesetMmtJob() {
+}
+
+void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
+}
+
+void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+
+  // We use URLRequesetMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequesetMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+
+  if (result != OK) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
+  }
+
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequesetMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
+  }
+}
+
+void URLRequesetMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
+
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
+
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
+
+  NotifyReadComplete(result);
+}
+
+}  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
new file mode 100644
index 0000000..1ff88d2
--- /dev/null
+++ b/net/url_request/url_request_mmt_job.h
@@ -0,0 +1,110 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+#define NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
+
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/base/net_export.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
+namespace net {
+
+class FileStream;
+
+// A request job that handles reading mmt URLs
+class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
+ public:
+  URLRequestMmtJob(URLRequest* request,
+                    NetworkDelegate* network_delegate,
+                    const base::FilePath& file_path,
+                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+
+  // URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
+
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
+
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  HttpByteRange byte_range_;
+  int64 remaining_bytes_;
+
+  base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
+};
+
+}  // namespace net
+
+#endif  // NET_URL_REQUEST_URL_REQUEST_MMT_JOB_H_
-- 
1.7.9.5


From 819ebb00f5f4b906fa46955091a2613e2f22f1be Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 24 Dec 2014 05:57:57 -0800
Subject: [PATCH 002/128] fix building error for mmt protocol

---
 net/BUILD.gn                            |    4 ---
 net/net.gyp                             |   12 +++++++
 net/net.gypi                            |    4 +++
 net/url_request/mmt_protocol_handler.cc |    6 ++--
 net/url_request/url_request_mmt_job.cc  |   60 +++++++++++++++----------------
 5 files changed, 49 insertions(+), 37 deletions(-)

diff --git a/net/BUILD.gn b/net/BUILD.gn
index ffd9746..a3d3a73 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -143,10 +143,6 @@ component("net") {
 
   if (disable_mmt_support) {
     sources -= [
-      "base/directory_lister.cc",
-      "base/directory_lister.h",
-      "url_request/url_request_file_dir_job.cc",
-      "url_request/url_request_file_dir_job.h",
       "url_request/url_request_mmt_job.cc",
       "url_request/url_request_mmt_job.h",
       "url_request/mmt_protocol_handler.cc",
diff --git a/net/net.gyp b/net/net.gyp
index 4d14b60..1597f24 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -180,6 +180,18 @@
             'url_request/file_protocol_handler.h',
           ],
         }],
+        ['disable_mmt_support==1', {
+          'sources!': [
+            'base/directory_lister.cc',
+            'base/directory_lister.h',
+            'url_request/url_request_file_dir_job.cc',
+            'url_request/url_request_file_dir_job.h',
+            'url_request/url_request_mmt_job.cc',
+            'url_request/url_request_mmt_job.h',
+            'url_request/mmt_protocol_handler.cc',
+            'url_request/mmt_protocol_handler.h',
+          ],
+        }],
         ['disable_ftp_support==1', {
           'sources/': [
             ['exclude', '^ftp/'],
diff --git a/net/net.gypi b/net/net.gypi
index 5ca70f7..ee879d2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1135,6 +1135,8 @@
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1178,6 +1180,8 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 3b62225..86afe03 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -32,10 +32,10 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
   }
 
-  // We need to decide whether to create URLRequestFileJob for file access or
+  // We need to decide whether to create URLRequestMmtJob for file access or
   // URLRequestFileDirJob for directory access. To avoid accessing the
   // filesystem, we only look at the path string here.
-  // The code in the URLRequestFileJob::Start() method discovers that a path,
+  // The code in the URLRequestMmtJob::Start() method discovers that a path,
   // which doesn't end with a slash, should really be treated as a directory,
   // and it then redirects to the URLRequestFileDirJob.
   if (is_file &&
@@ -46,7 +46,7 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
 
   // Use a regular file request job for all non-directories (including invalid
   // file names).
-  return new URLRequestFileJob(request, network_delegate, file_path,
+  return new URLRequestMmtJob(request, network_delegate, file_path,
                                file_task_runner_);
 }
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4443c1b..c5b8f9c 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -9,15 +9,15 @@
 // to do background file reads for us.
 //
 // Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequesetMmtJob keeps a buffer as a member var.  In
-// URLRequesetMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequesetMmtJob
+// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
+// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
+// the given buffer.  If there is no data to copy, the URLRequestMmtJob
 // attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequesetMmtJob waits for a
+// file does not complete synchronously, then the URLRequestMmtJob waits for a
 // signal from the OS that the overlapped read has completed.  It does so by
 // leveraging the MessageLoop::WatchObject API.
 
-#include "net/url_request/url_request_file_job.h"
+#include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
@@ -47,14 +47,14 @@
 
 namespace net {
 
-URLRequesetMmtJob::FileMetaInfo::FileMetaInfo()
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
     : file_size(0),
       mime_type_result(false),
       file_exists(false),
       is_directory(false) {
 }
 
-URLRequesetMmtJob::URLRequesetMmtJob(
+URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
     const base::FilePath& file_path,
@@ -66,25 +66,25 @@ URLRequesetMmtJob::URLRequesetMmtJob(
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
-void URLRequesetMmtJob::Start() {
+void URLRequestMmtJob::Start() {
   FileMetaInfo* meta_info = new FileMetaInfo();
   file_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequesetMmtJob::FetchMetaInfo, file_path_,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
                  base::Unretained(meta_info)),
-      base::Bind(&URLRequesetMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(meta_info)));
 }
 
-void URLRequesetMmtJob::Kill() {
+void URLRequestMmtJob::Kill() {
   stream_.reset();
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
 }
 
-bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
@@ -103,7 +103,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
 
   int rv = stream_->Read(dest,
                          dest_size,
-                         base::Bind(&URLRequesetMmtJob::DidRead,
+                         base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
   if (rv >= 0) {
@@ -123,7 +123,7 @@ bool URLRequesetMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   if (meta_info_.is_directory) {
     // This happens when we discovered the file is a directory, so needs a
@@ -160,13 +160,13 @@ bool URLRequesetMmtJob::IsRedirectResponse(GURL* location,
 #endif
 }
 
-Filter* URLRequesetMmtJob::SetupFilter() const {
+Filter* URLRequestMmtJob::SetupFilter() const {
   // Bug 9936 - .svgz files needs to be decompressed.
   return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
       ? Filter::GZipFactory() : NULL;
 }
 
-bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
+bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
   if (meta_info_.mime_type_result) {
     *mime_type = meta_info_.mime_type;
@@ -175,7 +175,7 @@ bool URLRequesetMmtJob::GetMimeType(std::string* mime_type) const {
   return false;
 }
 
-void URLRequesetMmtJob::SetExtraRequestHeaders(
+void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
@@ -196,16 +196,16 @@ void URLRequesetMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequesetMmtJob::OnSeekComplete(int64 result) {
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
 }
 
-void URLRequesetMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
 }
 
-URLRequesetMmtJob::~URLRequesetMmtJob() {
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                       FileMetaInfo* meta_info) {
   base::File::Info file_info;
   meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
@@ -219,10 +219,10 @@ void URLRequesetMmtJob::FetchMetaInfo(const base::FilePath& file_path,
                                                     &meta_info->mime_type);
 }
 
-void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
   meta_info_ = *meta_info;
 
-  // We use URLRequesetMmtJob to handle files as well as directories without
+  // We use URLRequestMmtJob to handle files as well as directories without
   // trailing slash.
   // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
   // we will append trailing slash and redirect to FileDirJob.
@@ -243,16 +243,16 @@ void URLRequesetMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
               base::File::FLAG_READ |
               base::File::FLAG_ASYNC;
   int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequesetMmtJob::DidOpen,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
                                     weak_ptr_factory_.GetWeakPtr()));
   if (rv != ERR_IO_PENDING)
     DidOpen(rv);
 }
 
-void URLRequesetMmtJob::DidOpen(int result) {
+void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequesetMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -273,11 +273,11 @@ void URLRequesetMmtJob::DidOpen(int result) {
     // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
     tracked_objects::ScopedTracker tracking_profile1(
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequesetMmtJob::DidOpen 1"));
+            "423948 URLRequestMmtJob::DidOpen 1"));
 
     int rv = stream_->Seek(base::File::FROM_BEGIN,
                            byte_range_.first_byte_position(),
-                           base::Bind(&URLRequesetMmtJob::DidSeek,
+                           base::Bind(&URLRequestMmtJob::DidSeek,
                                       weak_ptr_factory_.GetWeakPtr()));
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
@@ -292,7 +292,7 @@ void URLRequesetMmtJob::DidOpen(int result) {
   }
 }
 
-void URLRequesetMmtJob::DidSeek(int64 result) {
+void URLRequestMmtJob::DidSeek(int64 result) {
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -304,7 +304,7 @@ void URLRequesetMmtJob::DidSeek(int64 result) {
   NotifyHeadersComplete();
 }
 
-void URLRequesetMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
-- 
1.7.9.5


From 1f5976f34f579f4c08029b399da98dd8943d4a07 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 25 Dec 2014 20:59:17 -0800
Subject: [PATCH 003/128] register mmt:// into chromium

---
 .../api/web_navigation/frame_navigation_state.cc   |    1 +
 chrome/browser/history/in_memory_url_index.cc      |    1 +
 chrome/browser/prerender/prerender_util.cc         |    3 +++
 chrome/browser/profiles/profile_io_data.cc         |   14 ++++++++++++++
 .../supervised_user/supervised_user_url_filter.cc  |    1 +
 chrome/browser/ui/location_bar/origin_chip_info.cc |    1 +
 chrome/browser/web_applications/web_app.cc         |    1 +
 .../navigation_metrics/navigation_metrics.cc       |    2 ++
 content/browser/browser_url_handler_impl.cc        |    1 +
 .../browser/child_process_security_policy_impl.cc  |    1 +
 content/common/savable_url_schemes.cc              |    1 +
 .../browser/api/web_request/web_request_api.cc     |    2 +-
 .../api/web_request/web_request_permissions.cc     |    2 +-
 extensions/common/extension.cc                     |    3 ++-
 extensions/common/url_pattern.cc                   |    2 ++
 extensions/common/url_pattern.h                    |    7 ++++---
 extensions/common/user_script.cc                   |    3 ++-
 extensions/renderer/dispatcher.cc                  |    1 +
 url/url_constants.cc                               |    1 +
 url/url_constants.h                                |    1 +
 url/url_util.cc                                    |    3 ++-
 21 files changed, 44 insertions(+), 8 deletions(-)

diff --git a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
index 2cfa98f..48f7da9 100644
--- a/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
+++ b/chrome/browser/extensions/api/web_navigation/frame_navigation_state.cc
@@ -20,6 +20,7 @@ const char* const kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     url::kJavaScriptScheme,
     url::kDataScheme,
     url::kFileSystemScheme,
diff --git a/chrome/browser/history/in_memory_url_index.cc b/chrome/browser/history/in_memory_url_index.cc
index 74ad2a0..383dc7b 100644
--- a/chrome/browser/history/in_memory_url_index.cc
+++ b/chrome/browser/history/in_memory_url_index.cc
@@ -42,6 +42,7 @@ void InitializeSchemeWhitelist(std::set<std::string>* whitelist) {
   whitelist->insert(std::string(content::kChromeUIScheme));
   whitelist->insert(std::string(url::kFileScheme));
   whitelist->insert(std::string(url::kFtpScheme));
+  whitelist->insert(std::string(url::kMmtScheme));
   whitelist->insert(std::string(url::kHttpScheme));
   whitelist->insert(std::string(url::kHttpsScheme));
   whitelist->insert(std::string(url::kMailToScheme));
diff --git a/chrome/browser/prerender/prerender_util.cc b/chrome/browser/prerender/prerender_util.cc
index e7ae9d1..f1e2d30 100644
--- a/chrome/browser/prerender/prerender_util.cc
+++ b/chrome/browser/prerender/prerender_util.cc
@@ -77,6 +77,7 @@ enum PrerenderSchemeCancelReason {
   PRERENDER_SCHEME_CANCEL_REASON_FILESYSTEM,
   PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET,
   PRERENDER_SCHEME_CANCEL_REASON_FTP,
+  PRERENDER_SCHEME_CANCEL_REASON_MMT,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME,
   PRERENDER_SCHEME_CANCEL_REASON_CHROME_EXTENSION,
   PRERENDER_SCHEME_CANCEL_REASON_ABOUT,
@@ -258,6 +259,8 @@ void ReportUnsupportedPrerenderScheme(const GURL& url) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_WEBSOCKET);
   } else if (url.SchemeIs("ftp")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_FTP);
+  } else if (url.SchemeIs("mmt")) {
+    ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_MMT);
   } else if (url.SchemeIs("chrome")) {
     ReportPrerenderSchemeCancelReason(PRERENDER_SCHEME_CANCEL_REASON_CHROME);
   } else if (url.SchemeIs("chrome-extension")) {
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 50d7970..d76a909 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -81,6 +81,7 @@
 #include "net/url_request/data_protocol_handler.h"
 #include "net/url_request/file_protocol_handler.h"
 #include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/mmt_protocol_handler.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_file_job.h"
@@ -730,6 +731,9 @@ bool ProfileIOData::IsHandledProtocol(const std::string& scheme) {
 #if !defined(DISABLE_FTP_SUPPORT)
     url::kFtpScheme,
 #endif  // !defined(DISABLE_FTP_SUPPORT)
+#if !defined(DISABLE_MMT_SUPPORT)
+    url::kMmtScheme,
+#endif
     url::kBlobScheme,
     url::kFileSystemScheme,
     chrome::kChromeSearchScheme,
@@ -1212,6 +1216,16 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
       new net::FtpProtocolHandler(ftp_transaction_factory));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  bool mmt_protocol = job_factory->SetProtocolHandler(
+      url::kMmtScheme,
+      new net::MmtProtocolHandler(
+          content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+  DCHECK(mmt_protocol);
+#endif
+
 #if defined(DEBUG_DEVTOOLS)
   request_interceptors.push_back(new DebugDevToolsInterceptor);
 #endif
diff --git a/chrome/browser/supervised_user/supervised_user_url_filter.cc b/chrome/browser/supervised_user/supervised_user_url_filter.cc
index 0c78892..cef4318 100644
--- a/chrome/browser/supervised_user/supervised_user_url_filter.cc
+++ b/chrome/browser/supervised_user/supervised_user_url_filter.cc
@@ -49,6 +49,7 @@ const char* kFilteredSchemes[] = {
   "http",
   "https",
   "ftp",
+  "mmt",
   "gopher",
   "ws",
   "wss"
diff --git a/chrome/browser/ui/location_bar/origin_chip_info.cc b/chrome/browser/ui/location_bar/origin_chip_info.cc
index 633b13d2..09f23cd 100644
--- a/chrome/browser/ui/location_bar/origin_chip_info.cc
+++ b/chrome/browser/ui/location_bar/origin_chip_info.cc
@@ -242,6 +242,7 @@ base::string16 OriginChip::LabelFromURLForProfile(const GURL& provided_url,
       url.SchemeIs(content::kChromeDevToolsScheme) ||
       url.SchemeIs(url::kDataScheme) ||
       url.SchemeIs(url::kFileScheme) ||
+      url.SchemeIs(url::kMmtScheme) ||
       url.SchemeIs(url::kFileSystemScheme) ||
       url.SchemeIs(content::kGuestScheme) ||
       url.SchemeIs(url::kJavaScriptScheme) ||
diff --git a/chrome/browser/web_applications/web_app.cc b/chrome/browser/web_applications/web_app.cc
index ec13b37..56aec7a3 100644
--- a/chrome/browser/web_applications/web_app.cc
+++ b/chrome/browser/web_applications/web_app.cc
@@ -420,6 +420,7 @@ bool IsValidUrl(const GURL& url) {
       url::kFileScheme,
       url::kFileSystemScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
       url::kHttpScheme,
       url::kHttpsScheme,
       extensions::kExtensionScheme,
diff --git a/components/navigation_metrics/navigation_metrics.cc b/components/navigation_metrics/navigation_metrics.cc
index 1c3458a..d4c024e 100644
--- a/components/navigation_metrics/navigation_metrics.cc
+++ b/components/navigation_metrics/navigation_metrics.cc
@@ -15,6 +15,7 @@ enum Scheme {
   SCHEME_HTTPS,
   SCHEME_FILE,
   SCHEME_FTP,
+  SCHEME_MMT,
   SCHEME_DATA,
   SCHEME_JAVASCRIPT,
   SCHEME_ABOUT,
@@ -28,6 +29,7 @@ const char* const kSchemeNames[] = {
   url::kHttpsScheme,
   url::kFileScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   url::kDataScheme,
   url::kJavaScriptScheme,
   url::kAboutScheme,
diff --git a/content/browser/browser_url_handler_impl.cc b/content/browser/browser_url_handler_impl.cc
index 7ea7ff7..3070fc3 100644
--- a/content/browser/browser_url_handler_impl.cc
+++ b/content/browser/browser_url_handler_impl.cc
@@ -25,6 +25,7 @@ static bool HandleViewSource(GURL* url, BrowserContext* browser_context) {
         url::kHttpScheme,
         url::kHttpsScheme,
         url::kFtpScheme,
+        url::kMmtScheme,
         kChromeDevToolsScheme,
         kChromeUIScheme,
         url::kFileScheme,
diff --git a/content/browser/child_process_security_policy_impl.cc b/content/browser/child_process_security_policy_impl.cc
index 34caa5a..4775560 100644
--- a/content/browser/child_process_security_policy_impl.cc
+++ b/content/browser/child_process_security_policy_impl.cc
@@ -311,6 +311,7 @@ ChildProcessSecurityPolicyImpl::ChildProcessSecurityPolicyImpl() {
   RegisterWebSafeScheme(url::kHttpScheme);
   RegisterWebSafeScheme(url::kHttpsScheme);
   RegisterWebSafeScheme(url::kFtpScheme);
+  RegisterWebSafeScheme(url::kMmtScheme);
   RegisterWebSafeScheme(url::kDataScheme);
   RegisterWebSafeScheme("feed");
   RegisterWebSafeScheme(url::kBlobScheme);
diff --git a/content/common/savable_url_schemes.cc b/content/common/savable_url_schemes.cc
index c149aae..e46c3e7 100644
--- a/content/common/savable_url_schemes.cc
+++ b/content/common/savable_url_schemes.cc
@@ -18,6 +18,7 @@ const char* const kDefaultSavableSchemes[] = {
   url::kFileScheme,
   url::kFileSystemScheme,
   url::kFtpScheme,
+  url::kMmtScheme,
   kChromeDevToolsScheme,
   kChromeUIScheme,
   url::kDataScheme,
diff --git a/extensions/browser/api/web_request/web_request_api.cc b/extensions/browser/api/web_request/web_request_api.cc
index b04ee76..33828f0 100644
--- a/extensions/browser/api/web_request/web_request_api.cc
+++ b/extensions/browser/api/web_request/web_request_api.cc
@@ -559,7 +559,7 @@ bool ExtensionWebRequestEventRouter::RequestFilter::InitFromValue(
         std::string url;
         URLPattern pattern(
             URLPattern::SCHEME_HTTP | URLPattern::SCHEME_HTTPS |
-            URLPattern::SCHEME_FTP | URLPattern::SCHEME_FILE |
+            URLPattern::SCHEME_FTP | URLPattern::SCHEME_MMT | URLPattern::SCHEME_FILE |
             URLPattern::SCHEME_EXTENSION);
         if (!urls_value->GetString(i, &url) ||
             pattern.Parse(url) != URLPattern::PARSE_SUCCESS) {
diff --git a/extensions/browser/api/web_request/web_request_permissions.cc b/extensions/browser/api/web_request/web_request_permissions.cc
index 297fef5..5a9e8e1 100644
--- a/extensions/browser/api/web_request/web_request_permissions.cc
+++ b/extensions/browser/api/web_request/web_request_permissions.cc
@@ -68,7 +68,7 @@ bool IsSensitiveURL(const GURL& url) {
 // covered by CanExtensionAccessURL.
 bool HasWebRequestScheme(const GURL& url) {
   return (url.SchemeIs(url::kAboutScheme) || url.SchemeIs(url::kFileScheme) ||
-          url.SchemeIs(url::kFileSystemScheme) ||
+          url.SchemeIs(url::kFileSystemScheme) || url.SchemeIs(url::kMmtScheme) ||
           url.SchemeIs(url::kFtpScheme) || url.SchemeIs(url::kHttpScheme) ||
           url.SchemeIs(url::kHttpsScheme) ||
           url.SchemeIs(extensions::kExtensionScheme));
diff --git a/extensions/common/extension.cc b/extensions/common/extension.cc
index 88cc084..1d1089f 100644
--- a/extensions/common/extension.cc
+++ b/extensions/common/extension.cc
@@ -78,7 +78,8 @@ const int Extension::kValidHostPermissionSchemes = URLPattern::SCHEME_CHROMEUI |
                                                    URLPattern::SCHEME_HTTP |
                                                    URLPattern::SCHEME_HTTPS |
                                                    URLPattern::SCHEME_FILE |
-                                                   URLPattern::SCHEME_FTP;
+                                                   URLPattern::SCHEME_FTP |
+                                                   URLPattern::SCHEME_MMT;
 
 //
 // Extension
diff --git a/extensions/common/url_pattern.cc b/extensions/common/url_pattern.cc
index 71b522e..c628e24 100644
--- a/extensions/common/url_pattern.cc
+++ b/extensions/common/url_pattern.cc
@@ -28,6 +28,7 @@ const char* kValidSchemes[] = {
     url::kHttpsScheme,
     url::kFileScheme,
     url::kFtpScheme,
+    url::kMmtScheme,
     content::kChromeUIScheme,
     extensions::kExtensionScheme,
     url::kFileSystemScheme,
@@ -38,6 +39,7 @@ const int kValidSchemeMasks[] = {
   URLPattern::SCHEME_HTTPS,
   URLPattern::SCHEME_FILE,
   URLPattern::SCHEME_FTP,
+  URLPattern::SCHEME_MMT,
   URLPattern::SCHEME_CHROMEUI,
   URLPattern::SCHEME_EXTENSION,
   URLPattern::SCHEME_FILESYSTEM,
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index c58c3ef..e4ed0ad 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,9 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_CHROMEUI   = 1 << 4,
-    SCHEME_EXTENSION  = 1 << 5,
-    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 4,
+    SCHEME_CHROMEUI   = 1 << 5,
+    SCHEME_EXTENSION  = 1 << 6,
+    SCHEME_FILESYSTEM = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/extensions/common/user_script.cc b/extensions/common/user_script.cc
index a56cadb..132796a 100644
--- a/extensions/common/user_script.cc
+++ b/extensions/common/user_script.cc
@@ -37,7 +37,8 @@ enum {
                             URLPattern::SCHEME_HTTP |
                             URLPattern::SCHEME_HTTPS |
                             URLPattern::SCHEME_FILE |
-                            URLPattern::SCHEME_FTP
+                            URLPattern::SCHEME_FTP |
+                            URLPattern::SCHEME_MMT
 };
 
 // static
diff --git a/extensions/renderer/dispatcher.cc b/extensions/renderer/dispatcher.cc
index 7420c3b..ac56427 100644
--- a/extensions/renderer/dispatcher.cc
+++ b/extensions/renderer/dispatcher.cc
@@ -1049,6 +1049,7 @@ void Dispatcher::UpdateOriginPermissions(
       url::kFileScheme,
       content::kChromeUIScheme,
       url::kFtpScheme,
+      url::kMmtScheme,
   };
   for (size_t i = 0; i < arraysize(kSchemes); ++i) {
     const char* scheme = kSchemes[i];
diff --git a/url/url_constants.cc b/url/url_constants.cc
index 2dc1478..01e590c 100644
--- a/url/url_constants.cc
+++ b/url/url_constants.cc
@@ -15,6 +15,7 @@ const char kDataScheme[] = "data";
 const char kFileScheme[] = "file";
 const char kFileSystemScheme[] = "filesystem";
 const char kFtpScheme[] = "ftp";
+const char kMmtScheme[] = "mmt";
 const char kGopherScheme[] = "gopher";
 const char kHttpScheme[] = "http";
 const char kHttpsScheme[] = "https";
diff --git a/url/url_constants.h b/url/url_constants.h
index c48dafc..0da4846f0 100644
--- a/url/url_constants.h
+++ b/url/url_constants.h
@@ -19,6 +19,7 @@ URL_EXPORT extern const char kDataScheme[];
 URL_EXPORT extern const char kFileScheme[];
 URL_EXPORT extern const char kFileSystemScheme[];
 URL_EXPORT extern const char kFtpScheme[];
+URL_EXPORT extern const char kMmtScheme[];
 URL_EXPORT extern const char kGopherScheme[];
 URL_EXPORT extern const char kHttpScheme[];
 URL_EXPORT extern const char kHttpsScheme[];
diff --git a/url/url_util.cc b/url/url_util.cc
index 008a5e4..5df7e77 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -34,12 +34,13 @@ inline bool DoLowerCaseEqualsASCII(Iter a_begin, Iter a_end, const char* b) {
   return *b == 0;
 }
 
-const int kNumStandardURLSchemes = 8;
+const int kNumStandardURLSchemes = 9;
 const char* kStandardURLSchemes[kNumStandardURLSchemes] = {
   kHttpScheme,
   kHttpsScheme,
   kFileScheme,  // Yes, file urls can have a hostname!
   kFtpScheme,
+  kMmtScheme,
   kGopherScheme,
   kWsScheme,    // WebSocket.
   kWssScheme,   // WebSocket secure.
-- 
1.7.9.5


From b6a5c50865dee23020da0b887d3cd5da9d3f29da Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 31 Dec 2014 18:21:04 -0800
Subject: [PATCH 004/128] implement mmt protocol's framework

---
 chrome/browser/profiles/profile_io_data.cc     |    5 +-
 extensions/common/url_pattern.h                |    8 +-
 media/filters/ffmpeg_glue.cc                   |    2 +-
 net/mmt/mmt_information.h                      |   25 +++
 net/mmt/mmt_transaction.cc                     |   37 +++++
 net/mmt/mmt_transaction.h                      |   71 +++++++++
 net/mmt/mmt_transaction_factory.h              |   31 ++++
 net/mmt/mmt_transaction_impl.cc                |  195 ++++++++++++++++++++++++
 net/mmt/mmt_transaction_impl.h                 |   81 ++++++++++
 net/net.gyp                                    |    4 -
 net/net.gypi                                   |   10 +-
 net/url_request/mmt_protocol_handler.cc        |   34 +----
 net/url_request/mmt_protocol_handler.h         |   11 +-
 net/url_request/url_request_context_builder.cc |    2 +-
 net/url_request/url_request_mmt_job.cc         |  165 +++++---------------
 net/url_request/url_request_mmt_job.h          |   47 +-----
 16 files changed, 498 insertions(+), 230 deletions(-)
 create mode 100644 net/mmt/mmt_information.h
 create mode 100644 net/mmt/mmt_transaction.cc
 create mode 100644 net/mmt/mmt_transaction.h
 create mode 100644 net/mmt/mmt_transaction_factory.h
 create mode 100644 net/mmt/mmt_transaction_impl.cc
 create mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index d76a909..9d89cb3 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1219,10 +1219,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #if !defined(DISABLE_MMT_SUPPORT)
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(
-          content::BrowserThread::GetBlockingPool()->
-              GetTaskRunnerWithShutdownBehavior(
-                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
+      new net::MmtProtocolHandler());
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/extensions/common/url_pattern.h b/extensions/common/url_pattern.h
index e4ed0ad..565599e 100644
--- a/extensions/common/url_pattern.h
+++ b/extensions/common/url_pattern.h
@@ -50,10 +50,10 @@ class URLPattern {
     SCHEME_HTTPS      = 1 << 1,
     SCHEME_FILE       = 1 << 2,
     SCHEME_FTP        = 1 << 3,
-    SCHEME_MMT        = 1 << 4,
-    SCHEME_CHROMEUI   = 1 << 5,
-    SCHEME_EXTENSION  = 1 << 6,
-    SCHEME_FILESYSTEM = 1 << 7,
+    SCHEME_CHROMEUI   = 1 << 4,
+    SCHEME_EXTENSION  = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_MMT        = 1 << 7,
 
     // IMPORTANT!
     // SCHEME_ALL will match every scheme, including chrome://, chrome-
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index 20ebeaf..dabd7d5 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 32 * 1024 };
+enum { kBufferSize = 256 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
new file mode 100644
index 0000000..60ed7e4
--- /dev/null
+++ b/net/mmt/mmt_information.h
@@ -0,0 +1,25 @@
+// Copyright (c) 2010 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_INFORMATION_H_
+#define NET_MMT_MMT_INFORMATION_H_
+
+#include "url/gurl.h"
+
+namespace net {
+
+class MmtRequestInfo {
+ public:
+  // The requested URL.
+  GURL url;
+};
+
+class MmtResponseInfo {
+ public:
+
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
new file mode 100644
index 0000000..1f0e8c7
--- /dev/null
+++ b/net/mmt/mmt_transaction.cc
@@ -0,0 +1,37 @@
+// Copyright (c) 2008 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction.h"
+#include "net/mmt/mmt_transaction_impl.h"
+#include "net/mmt/mmt_transaction_factory.h"
+
+namespace net {
+
+class MmtTransactionFactoryImpl : public MmtTransactionFactory {
+public:
+  MmtTransactionFactoryImpl() : suspended_(false) {
+  }
+  virtual ~MmtTransactionFactoryImpl() override {
+  }
+
+  virtual MmtTransaction* CreateTransaction() override {
+    if (suspended_)
+      return NULL;
+
+    return new MmtTransactionImpl();
+  }
+
+  virtual void Suspend(bool suspend) override {
+    suspended_ = suspend;
+  }
+
+private:
+  bool suspended_;
+};
+
+MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
+  return new MmtTransactionFactoryImpl();
+}
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
new file mode 100644
index 0000000..d3c225d
--- /dev/null
+++ b/net/mmt/mmt_transaction.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_H_
+#define NET_MMT_MMT_TRANSACTION_H_
+
+#include "net/base/completion_callback.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_states.h"
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtResponseInfo;
+class MmtRequestInfo;
+class BoundNetLog;
+
+// Represents a single MMT transaction.
+class NET_EXPORT_PRIVATE MmtTransaction {
+ public:
+  // Stops any pending IO and destroys the transaction object.
+  virtual ~MmtTransaction() {}
+
+  // Starts the MMT transaction (i.e., sends the MMT request).
+  //
+  // Returns OK if the transaction could be started synchronously, which means
+  // that the request was served from the cache (only supported for directory
+  // listings).  ERR_IO_PENDING is returned to indicate that the
+  // CompletionCallback will be notified once response info is available or if
+  // an IO error occurs.  Any other return value indicates that the transaction
+  // could not be started.
+  //
+  // Regardless of the return value, the caller is expected to keep the
+  // request_info object alive until Destroy is called on the transaction.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  // Profiling information for the request is saved to |net_log| if non-NULL.
+  virtual int Start(const MmtRequestInfo* request_info,
+                    const CompletionCallback& callback,
+                    const BoundNetLog& net_log) = 0;
+
+  // Once response info is available for the transaction, response data may be
+  // read by calling this method.
+  //
+  // Response data is copied into the given buffer and the number of bytes
+  // copied is returned.  ERR_IO_PENDING is returned if response data is not
+  // yet available.  The CompletionCallback is notified when the data copy
+  // completes, and it is passed the number of bytes that were successfully
+  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
+  // the error.  Any other negative return value indicates that the transaction
+  // could not be read.
+  //
+  // NOTE: The transaction is not responsible for deleting the callback object.
+  //
+  virtual int Read(IOBuffer* buf,
+                   int buf_len,
+                   const CompletionCallback& callback) = 0;
+
+  // Returns the response info for this transaction or NULL if the response
+  // info is not available.
+  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
+
+  // Returns the load state for this transaction.
+  virtual LoadState GetLoadState() const = 0;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
new file mode 100644
index 0000000..b9b1e6a
--- /dev/null
+++ b/net/mmt/mmt_transaction_factory.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
+#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
+
+#include "net/base/net_export.h"
+
+namespace net {
+
+class MmtTransaction;
+
+// An interface to a class that can create MmtTransaction objects.
+class NET_EXPORT MmtTransactionFactory {
+ public:
+  virtual ~MmtTransactionFactory() {}
+
+  // Creates a MmtTransaction object.
+  virtual MmtTransaction* CreateTransaction() = 0;
+
+  // Suspends the creation of new transactions. If |suspend| is false, creation
+  // of new transactions is resumed.
+  virtual void Suspend(bool suspend) = 0;
+
+  static MmtTransactionFactory* CreateFactory();
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
new file mode 100644
index 0000000..2e512b5
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/mmt/mmt_transaction_impl.h"
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/compiler_specific.h"
+#include "base/metrics/histogram.h"
+#include "base/profiler/scoped_tracker.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "net/base/address_list.h"
+#include "net/base/connection_type_histograms.h"
+#include "net/base/escape.h"
+#include "net/base/net_errors.h"
+#include "net/base/net_log.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+
+//const int kMmtBufLen = 256*1024;
+
+namespace net {
+
+MmtTransactionImpl::MmtTransactionImpl() :
+      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
+                              base::Unretained(this))),
+      request_(NULL),
+      read_data_buf_len_(0),
+      next_state_(STATE_NONE)
+{}
+
+MmtTransactionImpl::~MmtTransactionImpl() {
+}
+
+int MmtTransactionImpl::Stop(int error) {
+  LOG(INFO) << "Stop";
+  next_state_ = STATE_STOP;
+  last_error_ = error;
+  return OK;
+}
+
+int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+  return ERR_NOT_IMPLEMENTED;
+}
+
+int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
+                                 const CompletionCallback& callback,
+                                 const BoundNetLog& net_log) {
+  LOG(INFO) << "Start, url=" << request_info->url;
+
+  net_log_ = net_log;
+  request_ = request_info;
+  next_state_ = STATE_CONNECT;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+
+  return OK;
+}
+
+int MmtTransactionImpl::Read(IOBuffer* buf,
+                                int buf_len,
+                                const CompletionCallback& callback) {
+  LOG(INFO) << "Read, buf_len=" << buf_len;
+  DCHECK(buf);
+  DCHECK_GT(buf_len, 0);
+
+  read_data_buf_ = buf;
+  read_data_buf_len_ = buf_len;
+
+  next_state_ = STATE_READ;
+  int rv = DoLoop(OK);
+  if (rv == ERR_IO_PENDING)
+    user_callback_ = callback;
+  return rv;
+}
+
+const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
+  LOG(INFO) << "GetResponseInfo";
+  return &response_;
+}
+
+LoadState MmtTransactionImpl::GetLoadState() const {
+  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
+  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
+  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  return LOAD_STATE_IDLE;
+}
+
+void MmtTransactionImpl::ResetStateForRestart() {
+  user_callback_.Reset();
+  response_ = MmtResponseInfo();
+  read_data_buf_ = NULL;
+  read_data_buf_len_ = 0;
+  last_error_ = OK;
+  next_state_ = STATE_NONE;
+}
+
+void MmtTransactionImpl::DoCallback(int rv) {
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
+
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
+}
+
+void MmtTransactionImpl::OnIOComplete(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION(
+          "436634 MmtTransactionImpl::OnIOComplete"));
+
+  int rv = DoLoop(result);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
+}
+
+int MmtTransactionImpl::DoLoop(int result) {
+  DCHECK(next_state_ != STATE_NONE);
+
+  int rv = result;
+  do {
+    State state = next_state_;
+    next_state_ = STATE_NONE;
+    switch (state) {
+      case STATE_STOP:
+        DCHECK(rv == OK);
+        rv = DoStop();
+        break;
+      case STATE_CONNECT:
+        DCHECK(rv == OK);
+        rv = DoConnect();
+        break;
+      case STATE_CONNECT_COMPLETE:
+        rv = DoConnectComplete(rv);
+        break;
+      case STATE_READ:
+        DCHECK(rv == OK);
+        rv = DoRead();
+        break;
+      case STATE_READ_COMPLETE:
+        rv = DoReadComplete(rv);
+        break;
+      default:
+        NOTREACHED() << "bad state";
+        rv = ERR_UNEXPECTED;
+        break;
+    }
+  } while (rv != ERR_IO_PENDING);
+  return rv;
+}
+
+
+// Data Connection
+
+int MmtTransactionImpl::DoStop() {
+  next_state_ = STATE_READ;
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnect() {
+  next_state_ = STATE_CONNECT_COMPLETE;
+  // TODO: open file/network and then call io_callback_
+  return OK;
+}
+
+int MmtTransactionImpl::DoConnectComplete(int result) {
+  if (result != OK)
+    return Stop(result);
+  return OK;
+}
+
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+
+  next_state_ = STATE_READ_COMPLETE;
+  read_data_buf_->data()[0] = 0;
+  //TODO: read data from network/file
+  return 0;
+}
+
+int MmtTransactionImpl::DoReadComplete(int result) {
+  return result;
+}
+
+
+}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
new file mode 100644
index 0000000..098ee53
--- /dev/null
+++ b/net/mmt/mmt_transaction_impl.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
+#define NET_MMT_MMT_TRANSACTION_IMPL_H_
+
+#include <string>
+#include <utility>
+
+#include "base/basictypes.h"
+#include "base/compiler_specific.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/scoped_ptr.h"
+#include "net/base/address_list.h"
+#include "net/base/auth.h"
+#include "net/base/net_log.h"
+#include "net/dns/host_resolver.h"
+#include "net/dns/single_request_host_resolver.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
+
+namespace net {
+
+class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
+ public:
+  MmtTransactionImpl();
+  virtual ~MmtTransactionImpl() override;
+
+  virtual int Stop(int error);
+  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
+
+  // MmtTransaction methods:
+  virtual int Start(const MmtRequestInfo* request_info,
+            const CompletionCallback& callback,
+            const BoundNetLog& net_log) override;
+  virtual int Read(IOBuffer* buf,
+           int buf_len,
+           const CompletionCallback& callback) override;
+  virtual const MmtResponseInfo* GetResponseInfo() const override;
+  virtual LoadState GetLoadState() const override;
+
+ private:
+  void ResetStateForRestart();
+  void DoCallback(int result);
+  void OnIOComplete(int result);
+  int DoLoop(int result);
+
+  int DoStop();
+  int DoConnect();
+  int DoConnectComplete(int result);
+  int DoRead();
+  int DoReadComplete(int result);
+
+  enum State {
+    STATE_STOP,
+    STATE_CONNECT,
+    STATE_CONNECT_COMPLETE,
+    STATE_READ,
+    STATE_READ_COMPLETE,
+    STATE_NONE
+  };
+
+private:
+  CompletionCallback io_callback_;
+  CompletionCallback user_callback_;
+
+  BoundNetLog net_log_;
+  const MmtRequestInfo* request_;
+  MmtResponseInfo response_;
+
+  scoped_refptr<IOBuffer> read_data_buf_;
+  int read_data_buf_len_;
+
+  int last_error_;
+  State next_state_;
+};
+
+}  // namespace net
+
+#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gyp b/net/net.gyp
index 1597f24..eb27320 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -182,10 +182,6 @@
         }],
         ['disable_mmt_support==1', {
           'sources!': [
-            'base/directory_lister.cc',
-            'base/directory_lister.h',
-            'url_request/url_request_file_dir_job.cc',
-            'url_request/url_request_file_dir_job.h',
             'url_request/url_request_mmt_job.cc',
             'url_request/url_request_mmt_job.h',
             'url_request/mmt_protocol_handler.cc',
diff --git a/net/net.gypi b/net/net.gypi
index ee879d2..0d6cbf7 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -1131,12 +1131,16 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
       'url_request/file_protocol_handler.h',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
       'url_request/fraudulent_certificate_reporter.h',
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
@@ -1180,8 +1184,6 @@
       'url_request/url_request_file_dir_job.h',
       'url_request/url_request_file_job.cc',
       'url_request/url_request_file_job.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/url_request_filter.cc',
       'url_request/url_request_filter.h',
       'url_request/url_request_ftp_job.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 86afe03..416660f 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,48 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
-#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "net/url_request/url_request_mmt_job.h"
+#include "url/gurl.h"
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
+MmtProtocolHandler::MmtProtocolHandler() {}
 
 MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request->url(), &file_path);
-
-  // Check file access permissions.
-  if (!network_delegate ||
-      !network_delegate->CanAccessFile(*request, file_path)) {
-    return new URLRequestErrorJob(request, network_delegate, ERR_ACCESS_DENIED);
-  }
-
-  // We need to decide whether to create URLRequestMmtJob for file access or
-  // URLRequestFileDirJob for directory access. To avoid accessing the
-  // filesystem, we only look at the path string here.
-  // The code in the URLRequestMmtJob::Start() method discovers that a path,
-  // which doesn't end with a slash, should really be treated as a directory,
-  // and it then redirects to the URLRequestFileDirJob.
-  if (is_file &&
-      file_path.EndsWithSeparator() &&
-      file_path.IsAbsolute()) {
-    return new URLRequestFileDirJob(request, network_delegate, file_path);
-  }
-
-  // Use a regular file request job for all non-directories (including invalid
-  // file names).
-  return new URLRequestMmtJob(request, network_delegate, file_path,
-                               file_task_runner_);
+  LOG(INFO) << "mmt url: " << request->url();
+  return new URLRequestMmtJob(request, network_delegate);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 28ca9b6..237c703 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,22 +12,16 @@
 
 class GURL;
 
-namespace base {
-class TaskRunner;
-}
-
 namespace net {
 
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for File jobs. If |network_delegate_| is NULL,
-// then all file requests will fail with ERR_ACCESS_DENIED.
+// Implements a ProtocolHandler for MMT jobs. 
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  explicit MmtProtocolHandler();
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +29,6 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index efb9e5c..1eda830 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -411,7 +411,7 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     if (mmt_enabled_) {
       job_factory->SetProtocolHandler(
       "mmt",
-      new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
+      new MmtProtocolHandler());
     }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c5b8f9c..b53b76e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -21,16 +21,12 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
-#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
@@ -38,47 +34,25 @@
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
-#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate,
-    const base::FilePath& file_path,
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    NetworkDelegate* network_delegate)
     : URLRequestJob(request, network_delegate),
-      file_path_(file_path),
-      stream_(new FileStream(file_task_runner)),
-      file_task_runner_(file_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {}
 
 void URLRequestMmtJob::Start() {
-  FileMetaInfo* meta_info = new FileMetaInfo();
-  file_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+  // TODO
+  LOG(INFO) << "Start";
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  // TODO
+  LOG(INFO) << "Kill";
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -87,6 +61,7 @@ void URLRequestMmtJob::Kill() {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int dest_size,
                                     int* bytes_read) {
+  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
   DCHECK_GE(remaining_bytes_, 0);
@@ -101,11 +76,13 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
+  int rv = 0;
+  // TODO
+  //int rv = StreamRead(dest,
+  //                    dest_size,
+  //                    base::Bind(&URLRequestMmtJob::DidRead,
+  //                               weak_ptr_factory_.GetWeakPtr(),
+  //                               make_scoped_refptr(dest)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -125,58 +102,27 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
+  // TODO
+  LOG(INFO) << "IsRedirectResponse";
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  // TODO
+  LOG(INFO) << "SetupFilter";
+  return NULL; 
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
+  // TODO
+  LOG(INFO) << "GetMimeType";
+  *mime_type = std::string("application/x-mmt");
+  return true;
 }
 
-void URLRequestMmtJob::SetExtraRequestHeaders(
-    const HttpRequestHeaders& headers) {
+void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
+  LOG(INFO) << "SetExtraRequestHeaders";
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -197,59 +143,18 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::OnSeekComplete(int64 result) {
+  LOG(INFO) << "OnSeekComplete";
 }
 
 void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+  LOG(INFO) << "OnReadComplete";
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
-}
-
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
-  }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
 void URLRequestMmtJob::DidOpen(int result) {
+  LOG(INFO) << "DidOpen";
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
@@ -259,7 +164,8 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  int total_size = 0;
+  if (!byte_range_.ComputeBounds(total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -275,10 +181,13 @@ void URLRequestMmtJob::DidOpen(int result) {
         FROM_HERE_WITH_EXPLICIT_FUNCTION(
             "423948 URLRequestMmtJob::DidOpen 1"));
 
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
+    int rv = 0; 
+    // TODO: seek to byte_range_.first_byte_position()
+    // int rv = StreamSeek(FROM_BEGIN,
+    //                     byte_range_.first_byte_position(),
+    //                     base::Bind(&URLRequestMmtJob::DidSeek,
+    //                                weak_ptr_factory_.GetWeakPtr()));
+    //  
     if (rv != ERR_IO_PENDING) {
       // stream_->Seek() failed, so pass an intentionally erroneous value
       // into DidSeek().
@@ -293,6 +202,7 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
+  LOG(INFO) << "DidSeek";
   OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
@@ -305,6 +215,7 @@ void URLRequestMmtJob::DidSeek(int64 result) {
 }
 
 void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  LOG(INFO) << "DidRead";
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 1ff88d2..b9e871f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,7 +8,6 @@
 #include <string>
 #include <vector>
 
-#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
@@ -16,24 +15,13 @@
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
-namespace base {
-class TaskRunner;
-}
-namespace file_util {
-struct FileInfo;
-}
-
 namespace net {
 
-class FileStream;
-
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate,
-                    const base::FilePath& file_path,
-                    const scoped_refptr<base::TaskRunner>& file_task_runner);
+                    NetworkDelegate* network_delegate);
 
   // URLRequestJob:
   void Start() override;
@@ -53,36 +41,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   int64 remaining_bytes() const { return remaining_bytes_; }
 
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
@@ -93,10 +52,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
 
-- 
1.7.9.5


From 31d7185f5b54cef7759d7a428bcc41f507c605aa Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 1 Jan 2015 00:11:27 -0800
Subject: [PATCH 005/128] write mmt module like ftp

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 +
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 +
 chrome/browser/profiles/profile_io_data.cc         |    6 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/mmt/mmt_information.h                          |    7 +
 net/mmt/mmt_transaction_impl.cc                    |   37 ++-
 net/net.gypi                                       |   12 +-
 net/url_request/mmt_protocol_handler.cc            |   13 +-
 net/url_request/mmt_protocol_handler.h             |    5 +-
 net/url_request/url_request_context_builder.cc     |   12 +-
 net/url_request/url_request_context_builder.h      |    2 +
 net/url_request/url_request_mmt_job.cc             |  255 ++++++++------------
 net/url_request/url_request_mmt_job.h              |   42 ++--
 15 files changed, 213 insertions(+), 216 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index 798bea3..d47b636 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,6 +261,11 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -270,7 +275,8 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -328,7 +334,8 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -368,7 +375,8 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get());
+                                            ftp_factory_.get(),
+                                            mmt_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index 900dbfc..fa54638 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,6 +21,7 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -146,6 +147,7 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 8b39439..4f21760 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,6 +54,7 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -581,6 +582,11 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
+#if !defined(DISABLE_MMT_SUPPORT)
+  mmt_factory_.reset(
+      net::MmtTransactionFactory::CreateFactory());
+#endif
+
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -597,7 +603,8 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -662,7 +669,8 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get());
+      ftp_factory_.get(),
+      mmt_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -749,7 +757,8 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get()));
+                              ftp_factory_.get(),
+                              mmt_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 383fc40..505da31 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,6 +34,7 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -229,6 +230,7 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
+  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 9d89cb3..2b8537b 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,7 +1162,8 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory,
+    net::MmtTransactionFactory* mmt_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1217,9 +1218,10 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
+  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler());
+      new net::MmtProtocolHandler(mmt_transaction_factory));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index 244107f..fcc9fef 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,6 +34,7 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
+#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -60,6 +61,7 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -358,7 +360,8 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory,
+      net::MmtTransactionFactory* mmt_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 60ed7e4..92d7e17 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -17,7 +17,14 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
+  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  }
 
+  // Expected content size, in bytes, as reported by SIZE command. Only valid
+  // for file downloads. -1 means unknown size.
+  int64 expected_content_size;
+
+  bool is_local;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index 2e512b5..aef7733 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -38,7 +38,7 @@ MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << "Stop";
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
@@ -51,14 +51,16 @@ int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callb
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                                  const CompletionCallback& callback,
                                  const BoundNetLog& net_log) {
-  LOG(INFO) << "Start, url=" << request_info->url;
+  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
 
   net_log_ = net_log;
   request_ = request_info;
   next_state_ = STATE_CONNECT;
+#if 0
   int rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
 
   return OK;
 }
@@ -66,7 +68,7 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
 int MmtTransactionImpl::Read(IOBuffer* buf,
                                 int buf_len,
                                 const CompletionCallback& callback) {
-  LOG(INFO) << "Read, buf_len=" << buf_len;
+  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
@@ -74,21 +76,32 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_len_ = buf_len;
 
   next_state_ = STATE_READ;
-  int rv = DoLoop(OK);
+  int rv = OK;
+#if 0
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
+#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << "GetResponseInfo";
+  LOG(INFO) << __FUNCTION__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << "GetLoadState, next_state_=" << next_state_;
-  // LOAD_STATE_RESOLVING_HOST, LOAD_STATE_CONNECTING, LOAD_STATE_READING_RESPONSE
-  // LOAD_STATE_SENDING_REQUEST, LOAD_STATE_IDLE
+  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  switch (next_state_) {
+    case STATE_NONE: 
+      return LOAD_STATE_IDLE;
+    case STATE_CONNECT:
+      return LOAD_STATE_CONNECTING; 
+    case STATE_READ:
+      return LOAD_STATE_READING_RESPONSE;
+    default: 
+      break;
+  }
   return LOAD_STATE_IDLE;
 }
 
@@ -112,6 +125,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -161,35 +175,40 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __FUNCTION__;
   next_state_ = STATE_CONNECT_COMPLETE;
   // TODO: open file/network and then call io_callback_
   return OK;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
+  LOG(INFO) << __FUNCTION__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
   //TODO: read data from network/file
+  // impement one callback to mmt receiver
   return 0;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
+  LOG(INFO) << __FUNCTION__;
   return result;
 }
 
-
 }  // namespace net
diff --git a/net/net.gypi b/net/net.gypi
index 0d6cbf7..0335fc6 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,8 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_transaction.cc',
+      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
@@ -1131,12 +1133,6 @@
       'udp/udp_socket_libevent.h',
       'udp/udp_socket_win.cc',
       'udp/udp_socket_win.h',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
-      'url_request/mmt_protocol_handler.cc',
-      'url_request/mmt_protocol_handler.h',
-      'url_request/url_request_mmt_job.cc',
-      'url_request/url_request_mmt_job.h',
       'url_request/data_protocol_handler.cc',
       'url_request/data_protocol_handler.h',
       'url_request/file_protocol_handler.cc',
@@ -1145,6 +1141,8 @@
       'url_request/ftp_protocol_handler.cc',
       'url_request/ftp_protocol_handler.h',
       'url_request/http_user_agent_settings.h',
+      'url_request/mmt_protocol_handler.cc',
+      'url_request/mmt_protocol_handler.h',
       'url_request/redirect_info.cc',
       'url_request/redirect_info.h',
       'url_request/sdch_dictionary_fetcher.cc',
@@ -1190,6 +1188,8 @@
       'url_request/url_request_ftp_job.h',
       'url_request/url_request_http_job.cc',
       'url_request/url_request_http_job.h',
+      'url_request/url_request_mmt_job.cc',
+      'url_request/url_request_mmt_job.h',
       'url_request/url_request_intercepting_job_factory.cc',
       'url_request/url_request_intercepting_job_factory.h',
       'url_request/url_request_interceptor.cc',
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 416660f..a671486 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,21 @@
 
 namespace net {
 
-MmtProtocolHandler::MmtProtocolHandler() {}
+MmtProtocolHandler::MmtProtocolHandler(
+    MmtTransactionFactory* mmt_transaction_factory)
+    : mmt_transaction_factory_(mmt_transaction_factory) {
+  DCHECK(mmt_transaction_factory_);
+}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
   LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request, network_delegate);
+  return new URLRequestMmtJob(request,
+                              network_delegate,
+                              mmt_transaction_factory_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 237c703..10bfe1d 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -14,6 +14,7 @@ class GURL;
 
 namespace net {
 
+class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
@@ -21,7 +22,7 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler();
+  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -29,6 +30,8 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
+  MmtTransactionFactory* mmt_transaction_factory_;
+
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 1eda830..dee151e 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,6 +18,7 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -408,11 +409,12 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-    if (mmt_enabled_) {
-      job_factory->SetProtocolHandler(
-      "mmt",
-      new MmtProtocolHandler());
-    }
+  if (mmt_enabled_) {
+    mmt_transaction_factory_.reset(
+        MmtTransactionFactory::CreateFactory());
+    job_factory->SetProtocolHandler("mmt",
+        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+  }
 #endif
 
   storage->set_job_factory(job_factory);
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index 2aff0dd..c2cec99 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -33,6 +33,7 @@
 namespace net {
 
 class FtpTransactionFactory;
+class MmtTransactionFactory;
 class HostMappingRules;
 class HttpAuthHandlerFactory;
 class ProxyConfigService;
@@ -226,6 +227,7 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
+  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b53b76e..6b14fdd 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,8 +31,15 @@
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
+#include "net/base/net_util.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
+#include "net/http/http_response_headers.h"
+#include "net/http/http_transaction_factory.h"
+#include "net/url_request/url_request.h"
+#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
 #include "url/gurl.h"
 
@@ -40,198 +47,126 @@ namespace net {
 
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
-    NetworkDelegate* network_delegate)
+    NetworkDelegate* network_delegate,
+    MmtTransactionFactory* mmt_transaction_factory)
     : URLRequestJob(request, network_delegate),
-      remaining_bytes_(0),
-      weak_ptr_factory_(this) {}
-
-void URLRequestMmtJob::Start() {
-  // TODO
-  LOG(INFO) << "Start";
-}
-
-void URLRequestMmtJob::Kill() {
-  // TODO
-  LOG(INFO) << "Kill";
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
+      read_in_progress_(false),
+      mmt_transaction_factory_(mmt_transaction_factory),
+      weak_ptr_factory_(this) {
+  DCHECK(mmt_transaction_factory);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
-                                    int dest_size,
-                                    int* bytes_read) {
-  LOG(INFO) << "ReadRawData, dest_size=" << dest_size << ", remaining_bytes_="<<remaining_bytes_;
-  DCHECK_NE(dest_size, 0);
-  DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size) {
-    *bytes_read = 0;
-    return true;
-  }
-
-  int rv = 0;
-  // TODO
-  //int rv = StreamRead(dest,
-  //                    dest_size,
-  //                    base::Bind(&URLRequestMmtJob::DidRead,
-  //                               weak_ptr_factory_.GetWeakPtr(),
-  //                               make_scoped_refptr(dest)));
-  if (rv >= 0) {
-    // Data is immediately available.
-    *bytes_read = rv;
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-    return true;
-  }
-
-  // Otherwise, a read error occured.  We may just need to wait...
-  if (rv == ERR_IO_PENDING) {
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
-  return false;
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  // TODO
-  LOG(INFO) << "IsRedirectResponse";
+#if 0
+bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
+  // Disallow all redirects.
   return false;
 }
-
-Filter* URLRequestMmtJob::SetupFilter() const {
-  // TODO
-  LOG(INFO) << "SetupFilter";
-  return NULL; 
-}
+#endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  DCHECK(request_);
-  // TODO
   LOG(INFO) << "GetMimeType";
-  *mime_type = std::string("application/x-mmt");
-  return true;
-}
-
-void URLRequestMmtJob::SetExtraRequestHeaders(const HttpRequestHeaders& headers) {
-  LOG(INFO) << "SetExtraRequestHeaders";
-  std::string range_header;
-  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
-    // We only care about "Range" header here.
-    std::vector<HttpByteRange> ranges;
-    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        // We don't support multiple range requests in one single URL request,
-        // because we need to do multipart encoding here.
-        // TODO(hclam): decide whether we want to support multiple range
-        // requests.
-        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-      }
-    }
+  DCHECK(request_);
+  if (mmt_transaction_->GetResponseInfo()->is_local) {
+    *mime_type = "text/vnd.chromium.local";
+    return true;
   }
+  return false;
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-  LOG(INFO) << "OnSeekComplete";
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << "Start";
+  DCHECK(!mmt_transaction_);
+  StartMmtTransaction();
 }
 
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-  LOG(INFO) << "OnReadComplete";
-}
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << "Kill";
+  if (mmt_transaction_)
+    mmt_transaction_.reset();
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
-void URLRequestMmtJob::DidOpen(int result) {
-  LOG(INFO) << "DidOpen";
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
-
-  if (result != OK) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-    return;
+int URLRequestMmtJob::StartMmtTransaction() {
+  // Create a transaction.
+  DCHECK(!mmt_transaction_);
+  mmt_request_info_.url = request_->url();
+  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+
+  // No matter what, we want to report our status as IO pending since we will
+  // be notifying our consumer asynchronously via OnStartCompleted.
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  int rv = ERR_FAILED;
+  if (mmt_transaction_) {
+    rv = mmt_transaction_->Start(
+        &mmt_request_info_,
+        base::Bind(&URLRequestMmtJob::OnStartCompleted,
+                   base::Unretained(this)),
+        request_->net_log());
+    if (rv == ERR_IO_PENDING)
+      return rv;
   }
+  return rv;
+}
 
-  int total_size = 0;
-  if (!byte_range_.ComputeBounds(total_size)) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
+void URLRequestMmtJob::OnStartCompleted(int result) {
+  // Clear the IO_PENDING status
+  SetStatus(URLRequestStatus());
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
-                     byte_range_.first_byte_position() + 1;
-  DCHECK_GE(remaining_bytes_, 0);
-
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = 0; 
-    // TODO: seek to byte_range_.first_byte_position()
-    // int rv = StreamSeek(FROM_BEGIN,
-    //                     byte_range_.first_byte_position(),
-    //                     base::Bind(&URLRequestMmtJob::DidSeek,
-    //                                weak_ptr_factory_.GetWeakPtr()));
-    //  
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
+  // Note that mmt_transaction_ may be NULL due to a creation failure.
+  if (mmt_transaction_) {
+    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+    // the content size information manually.
+    set_expected_content_size(
+        mmt_transaction_->GetResponseInfo()->expected_content_size);
   }
-}
 
-void URLRequestMmtJob::DidSeek(int64 result) {
-  LOG(INFO) << "DidSeek";
-  OnSeekComplete(result);
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
+  if (result == OK) {
+    NotifyHeadersComplete();
+  }else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
   }
-
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  LOG(INFO) << "DidRead";
-  if (result > 0) {
-    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  OnReadComplete(buf.get(), result);
-  buf = NULL;
-
+void URLRequestMmtJob::OnReadCompleted(int result) {
+  read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  } else {
+    // Clear the IO_PENDING status
+    SetStatus(URLRequestStatus());
+  }
+}
+
+bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
+                                    int buf_size,
+                                    int* bytes_read) {
+  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  DCHECK_NE(buf_size, 0);
+  DCHECK(bytes_read);
+  DCHECK(!read_in_progress_);
+
+  int rv = mmt_transaction_->Read(buf, buf_size,
+                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
+                                             base::Unretained(this)));
+  if (rv >= 0) {
+    *bytes_read = rv;
+    return true;
   }
 
-  NotifyReadComplete(result);
+  if (rv == ERR_IO_PENDING) {
+    read_in_progress_ = true;
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
+  return false;
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index b9e871f..cf3036e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -11,50 +11,46 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
+#include "net/mmt/mmt_information.h"
+#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
 namespace net {
 
+class NetworkDelegate;
+class MmtTransactionFactory;
+
 // A request job that handles reading mmt URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                    NetworkDelegate* network_delegate);
+                   NetworkDelegate* network_delegate,
+                   MmtTransactionFactory* mmt_transaction_factory);
+
+ protected:
+  ~URLRequestMmtJob() override;
 
-  // URLRequestJob:
+  // Overridden from URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
-
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
- protected:
-  ~URLRequestMmtJob() override;
-
-  int64 remaining_bytes() const { return remaining_bytes_; }
 
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
+  int StartMmtTransaction();
+  void OnStartCompleted(int result);
+  void OnReadCompleted(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+ private:
+  MmtRequestInfo mmt_request_info_;
+  scoped_ptr<MmtTransaction> mmt_transaction_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
+  bool read_in_progress_;
 
+  MmtTransactionFactory* mmt_transaction_factory_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From 98f736ef3da53d6612b334658ba702e4ee2fcd1f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 2 Jan 2015 21:03:24 -0800
Subject: [PATCH 006/128] to implement mmt with the support of local file

---
 .gitignore                             |    2 +
 net/mmt/mmt_transaction_impl.cc        |   86 +++++++++++++++++++++-----------
 net/mmt/mmt_transaction_impl.h         |    4 ++
 net/url_request/url_request_mmt_job.cc |   26 ++++++----
 4 files changed, 80 insertions(+), 38 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8fa6763..a0181c4 100644
--- a/.gitignore
+++ b/.gitignore
@@ -437,3 +437,5 @@ v8.log
 /win8/metro_driver/metro_driver_version_resources.xml
 /x86-generic_out/
 /xcodebuild
+.xtags
+diff.log
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index aef7733..d927ab4 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -14,6 +14,12 @@
 #include "base/strings/string_split.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/values.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
 #include "net/base/address_list.h"
 #include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
@@ -31,67 +37,66 @@ MmtTransactionImpl::MmtTransactionImpl() :
                               base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
-      next_state_(STATE_NONE)
-{}
+      next_state_(STATE_NONE) {
+}
 
 MmtTransactionImpl::~MmtTransactionImpl() {
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", error=" << error;
   next_state_ = STATE_STOP;
   last_error_ = error;
   return OK;
 }
 
-int MmtTransactionImpl::RestartIgnoringLastError(const CompletionCallback& callback) {
+int MmtTransactionImpl::RestartIgnoringLastError(
+    const CompletionCallback& callback) {
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                                 const CompletionCallback& callback,
-                                 const BoundNetLog& net_log) {
-  LOG(INFO) << __FUNCTION__ << ", url=" << request_info->url;
-
+                              const CompletionCallback& callback,
+                              const BoundNetLog& net_log) {
+  LOG(INFO) << __func__ << ", url=" << request_info->url;
   net_log_ = net_log;
   request_ = request_info;
+
+  int rv = OK;
   next_state_ = STATE_CONNECT;
-#if 0
-  int rv = DoLoop(OK);
+  rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
 
-  return OK;
+  return rv;
 }
 
+// @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
-                                int buf_len,
-                                const CompletionCallback& callback) {
-  LOG(INFO) << __FUNCTION__ << ", buf_len=" << buf_len;
+                             int buf_len,
+                             const CompletionCallback& callback) {
+  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
 
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
 
-  next_state_ = STATE_READ;
   int rv = OK;
-#if 0
+  next_state_ = STATE_READ;
   rv = DoLoop(OK);
   if (rv == ERR_IO_PENDING)
     user_callback_ = callback;
-#endif
   return rv;
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __FUNCTION__ << ", next_state_=" << next_state_;
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,7 +130,7 @@ void MmtTransactionImpl::DoCallback(int rv) {
 }
 
 void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
@@ -175,39 +180,62 @@ int MmtTransactionImpl::DoLoop(int result) {
 // Data Connection
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   next_state_ = STATE_READ;
   return OK;
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  LOG(INFO) << __func__ << ", is_file=" << is_file;
+  if (!is_file) {
+    return ERR_FAILED;
+  }
+
   next_state_ = STATE_CONNECT_COMPLETE;
-  // TODO: open file/network and then call io_callback_
-  return OK;
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path, flags, io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoConnectComplete(rv);
+  }
+  LOG(INFO) << __func__ << ", rv=" << rv;
+  return rv;
 }
 
 int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   if (result != OK)
     return Stop(result);
   return OK;
 }
 
 int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__;
   DCHECK(read_data_buf_.get());
   DCHECK_GT(read_data_buf_len_, 0);
 
   next_state_ = STATE_READ_COMPLETE;
   read_data_buf_->data()[0] = 0;
+
   //TODO: read data from network/file
   // impement one callback to mmt receiver
-  return 0;
+  int rv = stream_->Read(read_data_buf_.get(),
+                         read_data_buf_len_,
+                         io_callback_);
+  if (rv != ERR_IO_PENDING) {
+    DoReadComplete(rv);
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __FUNCTION__;
+  LOG(INFO) << __func__ << ", result=" << result;
   return result;
 }
 
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 098ee53..fc25de2 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -22,6 +22,8 @@
 
 namespace net {
 
+class FileStream;
+
 class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
  public:
   MmtTransactionImpl();
@@ -69,6 +71,8 @@ private:
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
 
+  scoped_ptr<FileStream> stream_;
+
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6b14fdd..0fdb5a9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,8 +67,8 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << "GetMimeType";
-  DCHECK(request_);
+  LOG(INFO) << __FUNCTION__;
+  DCHECK(!mmt_transaction_);
   if (mmt_transaction_->GetResponseInfo()->is_local) {
     *mime_type = "text/vnd.chromium.local";
     return true;
@@ -77,13 +77,12 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << "Start";
-  DCHECK(!mmt_transaction_);
+  LOG(INFO) << __FUNCTION__;
   StartMmtTransaction();
 }
 
 void URLRequestMmtJob::Kill() {
-  LOG(INFO) << "Kill";
+  LOG(INFO) << __FUNCTION__;
   if (mmt_transaction_)
     mmt_transaction_.reset();
 
@@ -92,8 +91,12 @@ void URLRequestMmtJob::Kill() {
 }
 
 int URLRequestMmtJob::StartMmtTransaction() {
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(!mmt_transaction_);
+
+  // Create a transaction.
+  DCHECK(request_);
+  DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
 
@@ -107,13 +110,15 @@ int URLRequestMmtJob::StartMmtTransaction() {
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-    if (rv == ERR_IO_PENDING)
-      return rv;
   }
+  
+  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
   return rv;
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
@@ -133,6 +138,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
+  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+
   read_in_progress_ = false;
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -147,7 +154,8 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << "ReadRawData, buf_size=" << buf_size;
+  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
+
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-- 
1.7.9.5


From 703dcc0d46897a4fce93a647879bc12bb546ec7e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 5 Jan 2015 07:06:50 -0800
Subject: [PATCH 007/128] done to support mmt local file

---
 net/mmt/mmt_information.h              |   15 ++-
 net/mmt/mmt_transaction.h              |    3 +
 net/mmt/mmt_transaction_impl.cc        |  224 ++++++++++++++++++--------------
 net/mmt/mmt_transaction_impl.h         |   17 +--
 net/url_request/url_request_mmt_job.cc |   80 ++++++------
 net/url_request/url_request_mmt_job.h  |    2 +-
 6 files changed, 189 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 92d7e17..3cf1f4d 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -6,6 +6,8 @@
 #define NET_MMT_MMT_INFORMATION_H_
 
 #include "url/gurl.h"
+#include "base/files/file_path.h"
+#include "net/http/http_byte_range.h"
 
 namespace net {
 
@@ -17,14 +19,17 @@ class MmtRequestInfo {
 
 class MmtResponseInfo {
  public:
-  MmtResponseInfo() : expected_content_size(-1), is_local(false) {
+  MmtResponseInfo() {
+    total_size = 0;
+    read_offset = 0;
+    expected_content_size = 0;
   }
 
-  // Expected content size, in bytes, as reported by SIZE command. Only valid
-  // for file downloads. -1 means unknown size.
+  int64 total_size;
+  int64 read_offset;
   int64 expected_content_size;
-
-  bool is_local;
+  HttpByteRange byte_range;
+  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index d3c225d..9e45cbf 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -15,6 +15,7 @@ namespace net {
 class MmtResponseInfo;
 class MmtRequestInfo;
 class BoundNetLog;
+class HttpByteRange;
 
 // Represents a single MMT transaction.
 class NET_EXPORT_PRIVATE MmtTransaction {
@@ -64,6 +65,8 @@ class NET_EXPORT_PRIVATE MmtTransaction {
 
   // Returns the load state for this transaction.
   virtual LoadState GetLoadState() const = 0;
+
+  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index d927ab4..a090386 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -16,78 +16,92 @@
 #include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "base/threading/thread.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/address_list.h"
-#include "net/base/connection_type_histograms.h"
 #include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
 #include "net/mmt/mmt_information.h"
 
-//const int kMmtBufLen = 256*1024;
 
 namespace net {
 
 MmtTransactionImpl::MmtTransactionImpl() :
-      io_callback_(base::Bind(&MmtTransactionImpl::OnIOComplete,
-                              base::Unretained(this))),
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
+  base::ThreadRestrictions::SetIOAllowed(true);
+  thread_.reset(new base::Thread("MMT Thread"));
+  thread_->StartWithOptions(
+      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
+  response_ = MmtResponseInfo();
+  stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
+  LOG(INFO) << __func__;
+  Stop(OK);
 }
 
 int MmtTransactionImpl::Stop(int error) {
   LOG(INFO) << __func__ << ", error=" << error;
-  next_state_ = STATE_STOP;
+
   last_error_ = error;
-  return OK;
+  next_state_ = STATE_STOP;
+  int rv = DoStop();
+  return rv;
 }
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
+  LOG(INFO) << __func__;
   return ERR_NOT_IMPLEMENTED;
 }
 
 int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
                               const CompletionCallback& callback,
                               const BoundNetLog& net_log) {
-  LOG(INFO) << __func__ << ", url=" << request_info->url;
-  net_log_ = net_log;
   request_ = request_info;
+  user_callback_ = callback;
+  net_log_ = net_log;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_CONNECT;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  int rv = DoConnect();
+  DoCallback(rv);
+  return true;
+#endif
 }
 
 // @return 0 if end, >0 if normal, < 0 if waiting or error
 int MmtTransactionImpl::Read(IOBuffer* buf,
                              int buf_len,
                              const CompletionCallback& callback) {
-  LOG(INFO) << __func__ << ", buf_len=" << buf_len;
   DCHECK(buf);
   DCHECK_GT(buf_len, 0);
-
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
+  user_callback_ = callback;
 
-  int rv = OK;
+#if 0
   next_state_ = STATE_READ;
-  rv = DoLoop(OK);
-  if (rv == ERR_IO_PENDING)
-    user_callback_ = callback;
-  return rv;
+  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOComplete,
+                   base::Unretained(this)));
+  return bpost ? OK : ERR_FAILED;
+#else
+  return DoRead();
+#endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
@@ -110,7 +124,15 @@ LoadState MmtTransactionImpl::GetLoadState() const {
   return LOAD_STATE_IDLE;
 }
 
+void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
+  LOG(INFO) << __func__ 
+    << " range[" << range.first_byte_position() 
+    << ", "  << range.last_byte_position() << "]";
+  response_.byte_range = range;
+}
+
 void MmtTransactionImpl::ResetStateForRestart() {
+  LOG(INFO) << __func__ ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -119,26 +141,76 @@ void MmtTransactionImpl::ResetStateForRestart() {
   next_state_ = STATE_NONE;
 }
 
-void MmtTransactionImpl::DoCallback(int rv) {
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
+int MmtTransactionImpl::DoStop() {
+  LOG(INFO) << __func__;
+  next_state_ = STATE_NONE;
+  if (stream_) {
+    fclose((FILE*)stream_);
+    stream_ = nullptr;
+  }
+  return OK;
+}
 
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
+int MmtTransactionImpl::DoConnect() {
+  LOG(INFO) << __func__ << ", url=" << request_->url;
+
+  // TODO: open file/network
+  base::FilePath file_path;
+  const bool is_file = FileURLToFilePath(request_->url, &file_path);
+  if (!is_file) {
+    LOG(ERROR) << __func__ << ", invalid file";
+    return ERR_FAILED;
+  }
+  response_.file_path = file_path;
+
+  int64 file_size = 0;
+  if(!base::GetFileSize(file_path, &file_size)) {
+    LOG(ERROR) << __func__ << ", invalid file size";
+    return ERR_FAILED;
+  }
+
+  response_.total_size = file_size;
+  HttpByteRange byte_range = response_.byte_range;
+  if (!byte_range.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+  }
+
+  if (byte_range.first_byte_position() >= 0) {
+    response_.read_offset = byte_range.first_byte_position();
+  }else {
+    response_.read_offset = 0;
+  }
+  response_.expected_content_size = response_.total_size - response_.read_offset;
+  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
+        << ", total_size=" << response_.total_size
+        << ", content_size=" << response_.expected_content_size;
+
+  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  if (!fp) {
+    LOG(ERROR) << __func__ << ", fail to open file";
+    return ERR_FAILED;
+  }
+  stream_ = (void*)fp;
+
+  return OK;
 }
 
-void MmtTransactionImpl::OnIOComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  // TODO(vadimt): Remove ScopedTracker below once crbug.com/436634 is fixed.
-  tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION(
-          "436634 MmtTransactionImpl::OnIOComplete"));
+int MmtTransactionImpl::DoRead() {
+  DCHECK(read_data_buf_.get());
+  DCHECK_GT(read_data_buf_len_, 0);
+  DCHECK(stream_);
+  read_data_buf_->data()[0] = 0;
 
-  int rv = DoLoop(result);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
+  FILE *fp = (FILE *)stream_;
+  int64 offset = response_.read_offset;
+  fseek(fp, offset, SEEK_SET);
+  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
+  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  if (rv > 0) {
+    response_.read_offset += rv;
+  }
+  return rv;
 }
 
 int MmtTransactionImpl::DoLoop(int result) {
@@ -157,86 +229,38 @@ int MmtTransactionImpl::DoLoop(int result) {
         DCHECK(rv == OK);
         rv = DoConnect();
         break;
-      case STATE_CONNECT_COMPLETE:
-        rv = DoConnectComplete(rv);
-        break;
       case STATE_READ:
         DCHECK(rv == OK);
         rv = DoRead();
         break;
-      case STATE_READ_COMPLETE:
-        rv = DoReadComplete(rv);
-        break;
       default:
         NOTREACHED() << "bad state";
         rv = ERR_UNEXPECTED;
         break;
     }
-  } while (rv != ERR_IO_PENDING);
+  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
   return rv;
 }
 
-
-// Data Connection
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
-  next_state_ = STATE_READ;
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
-
-  // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  LOG(INFO) << __func__ << ", is_file=" << is_file;
-  if (!is_file) {
-    return ERR_FAILED;
-  }
-
-  next_state_ = STATE_CONNECT_COMPLETE;
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path, flags, io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoConnectComplete(rv);
-  }
+void MmtTransactionImpl::DoCallback(int rv) {
   LOG(INFO) << __func__ << ", rv=" << rv;
-  return rv;
-}
+  DCHECK(rv != ERR_IO_PENDING);
+  DCHECK(!user_callback_.is_null());
 
-int MmtTransactionImpl::DoConnectComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  if (result != OK)
-    return Stop(result);
-  return OK;
+  // Since Run may result in Read being called, clear callback_ up front.
+  CompletionCallback c = user_callback_;
+  user_callback_.Reset();
+  c.Run(rv);
 }
 
-int MmtTransactionImpl::DoRead() {
-  LOG(INFO) << __func__;
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-
-  next_state_ = STATE_READ_COMPLETE;
-  read_data_buf_->data()[0] = 0;
-
-  //TODO: read data from network/file
-  // impement one callback to mmt receiver
-  int rv = stream_->Read(read_data_buf_.get(),
-                         read_data_buf_len_,
-                         io_callback_);
-  if (rv != ERR_IO_PENDING) {
-    DoReadComplete(rv);
-  }
-  return rv;
+void MmtTransactionImpl::OnIOPrepare() {
 }
 
-int MmtTransactionImpl::DoReadComplete(int result) {
-  LOG(INFO) << __func__ << ", result=" << result;
-  return result;
+void MmtTransactionImpl::OnIOComplete() {
+  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  int rv = DoLoop(OK);
+  if (rv != ERR_IO_PENDING)
+    DoCallback(rv);
 }
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index fc25de2..1f98423 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,6 +20,10 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
+namespace base {
+class Thread;
+}
+
 namespace net {
 
 class FileStream;
@@ -41,25 +45,22 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
            const CompletionCallback& callback) override;
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
+  virtual void SetRequestHeaders(HttpByteRange &range) override;
 
  private:
   void ResetStateForRestart();
+  void OnIOPrepare();
+  void OnIOComplete();
   void DoCallback(int result);
-  void OnIOComplete(int result);
   int DoLoop(int result);
-
   int DoStop();
   int DoConnect();
-  int DoConnectComplete(int result);
   int DoRead();
-  int DoReadComplete(int result);
 
   enum State {
     STATE_STOP,
     STATE_CONNECT,
-    STATE_CONNECT_COMPLETE,
     STATE_READ,
-    STATE_READ_COMPLETE,
     STATE_NONE
   };
 
@@ -70,9 +71,9 @@ private:
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
+  scoped_ptr<base::Thread> thread_;
 
-  scoped_ptr<FileStream> stream_;
-
+  void* stream_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0fdb5a9..051fcba 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -67,31 +67,33 @@ bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
 #endif
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(!mmt_transaction_);
-  if (mmt_transaction_->GetResponseInfo()->is_local) {
-    *mime_type = "text/vnd.chromium.local";
-    return true;
-  }
   return false;
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  StartMmtTransaction();
-}
-
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  if (mmt_transaction_)
-    mmt_transaction_.reset();
-
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::SetExtraRequestHeaders(
+    const HttpRequestHeaders& headers) {
+  LOG(INFO) << __func__;
+  std::string range_header;
+  if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
+    // We only care about "Range" header here.
+    std::vector<HttpByteRange> ranges;
+    if (HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        // We don't support multiple range requests in one single URL request,
+        // because we need to do multipart encoding here.
+        // TODO(hclam): decide whether we want to support multiple range
+        // requests.
+        NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                    ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      }
+    }
+  }
 }
 
-int URLRequestMmtJob::StartMmtTransaction() {
-  LOG(INFO) << __FUNCTION__;
+void URLRequestMmtJob::Start() {
+  LOG(INFO) << __func__;
   DCHECK(!mmt_transaction_);
 
   // Create a transaction.
@@ -99,36 +101,38 @@ int URLRequestMmtJob::StartMmtTransaction() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  int rv = ERR_FAILED;
-  if (mmt_transaction_) {
-    rv = mmt_transaction_->Start(
+  mmt_transaction_->Start(
         &mmt_request_info_,
         base::Bind(&URLRequestMmtJob::OnStartCompleted,
                    base::Unretained(this)),
         request_->net_log());
-  }
-  
-  LOG(INFO) << __FUNCTION__ << ", rv=" << rv;
-  return rv;
+}
+
+void URLRequestMmtJob::Kill() {
+  LOG(INFO) << __FUNCTION__;
+  mmt_transaction_.reset();
+
+  URLRequestJob::Kill();
+  weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  DCHECK(mmt_transaction_);
+
+  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
-  // Note that mmt_transaction_ may be NULL due to a creation failure.
-  if (mmt_transaction_) {
-    // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-    // the content size information manually.
-    set_expected_content_size(
-        mmt_transaction_->GetResponseInfo()->expected_content_size);
-  }
+  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
+  // the content size information manually.
+  set_expected_content_size(content_size);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -141,7 +145,7 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
   LOG(INFO) << __FUNCTION__ << ", result=" << result;
 
   read_in_progress_ = false;
-  if (result == 0) {
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -149,16 +153,16 @@ void URLRequestMmtJob::OnReadCompleted(int result) {
     // Clear the IO_PENDING status
     SetStatus(URLRequestStatus());
   }
+  NotifyReadComplete(result);
 }
 
 bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
                                     int buf_size,
                                     int* bytes_read) {
-  LOG(INFO) << __FUNCTION__ << ", buf_size=" << buf_size;
-
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
+  DCHECK(mmt_transaction_);
 
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cf3036e..6630861 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -37,9 +37,9 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
-  int StartMmtTransaction();
   void OnStartCompleted(int result);
   void OnReadCompleted(int result);
 
-- 
1.7.9.5


From c104100b2c0308afa500558d75b42b8a9bf488ac Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 05:58:52 -0800
Subject: [PATCH 008/128] TODO: support async io

---
 chrome/browser/profiles/profile_io_data.cc     |    6 +-
 net/mmt/mmt_information.h                      |    4 +-
 net/mmt/mmt_transaction.h                      |    6 ++
 net/mmt/mmt_transaction_impl.cc                |  122 ++++++++++++------------
 net/mmt/mmt_transaction_impl.h                 |    9 +-
 net/url_request/mmt_protocol_handler.cc        |    9 +-
 net/url_request/mmt_protocol_handler.h         |    9 +-
 net/url_request/url_request_context_builder.cc |    3 +-
 net/url_request/url_request_mmt_job.cc         |   12 ++-
 net/url_request/url_request_mmt_job.h          |    5 +-
 10 files changed, 110 insertions(+), 75 deletions(-)

diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 2b8537b..7cb34a4 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1221,7 +1221,11 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
   DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
-      new net::MmtProtocolHandler(mmt_transaction_factory));
+      new net::MmtProtocolHandler(
+            mmt_transaction_factory,
+            content::BrowserThread::GetBlockingPool()->
+              GetTaskRunnerWithShutdownBehavior(
+                  base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
   DCHECK(mmt_protocol);
 #endif
 
diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
index 3cf1f4d..514a185 100644
--- a/net/mmt/mmt_information.h
+++ b/net/mmt/mmt_information.h
@@ -22,14 +22,14 @@ class MmtResponseInfo {
   MmtResponseInfo() {
     total_size = 0;
     read_offset = 0;
+    remaining_bytes = 0;
     expected_content_size = 0;
   }
 
   int64 total_size;
   int64 read_offset;
+  int64 remaining_bytes;
   int64 expected_content_size;
-  HttpByteRange byte_range;
-  base::FilePath file_path;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
index 9e45cbf..05a07fd 100644
--- a/net/mmt/mmt_transaction.h
+++ b/net/mmt/mmt_transaction.h
@@ -10,6 +10,11 @@
 #include "net/base/load_states.h"
 #include "net/base/net_export.h"
 
+
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtResponseInfo;
@@ -67,6 +72,7 @@ class NET_EXPORT_PRIVATE MmtTransaction {
   virtual LoadState GetLoadState() const = 0;
 
   virtual void SetRequestHeaders(HttpByteRange &range) = 0;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
 };
 
 }  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
index a090386..ee2274c 100644
--- a/net/mmt/mmt_transaction_impl.cc
+++ b/net/mmt/mmt_transaction_impl.cc
@@ -6,23 +6,15 @@
 
 #include "base/bind.h"
 #include "base/bind_helpers.h"
-#include "base/compiler_specific.h"
-#include "base/metrics/histogram.h"
-#include "base/profiler/scoped_tracker.h"
-#include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/values.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/thread_task_runner_handle.h"
-#include "base/threading/thread.h"
+#include "base/threading/thread_restrictions.h"
 #include "net/base/file_stream.h"
 #include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
-#include "net/base/escape.h"
 #include "net/base/net_errors.h"
 #include "net/base/net_log.h"
 #include "net/base/net_util.h"
@@ -31,25 +23,26 @@
 
 namespace net {
 
+#ifndef TAG
+#define TAG "["<<__func__<<" thiz="<<this<<"]"
+#endif
+
 MmtTransactionImpl::MmtTransactionImpl() :
       request_(NULL),
       read_data_buf_len_(0),
       next_state_(STATE_NONE) {
   base::ThreadRestrictions::SetIOAllowed(true);
-  thread_.reset(new base::Thread("MMT Thread"));
-  thread_->StartWithOptions(
-      base::Thread::Options(base::MessageLoop::TYPE_DEFAULT, 0));
   response_ = MmtResponseInfo();
   stream_ = nullptr;
 }
 
 MmtTransactionImpl::~MmtTransactionImpl() {
-  LOG(INFO) << __func__;
   Stop(OK);
+  LOG(INFO) << TAG;
 }
 
 int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << __func__ << ", error=" << error;
+  LOG(INFO) << TAG << ", error=" << error;
 
   last_error_ = error;
   next_state_ = STATE_STOP;
@@ -59,7 +52,7 @@ int MmtTransactionImpl::Stop(int error) {
 
 int MmtTransactionImpl::RestartIgnoringLastError(
     const CompletionCallback& callback) {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return ERR_NOT_IMPLEMENTED;
 }
 
@@ -69,13 +62,15 @@ int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
   request_ = request_info;
   user_callback_ = callback;
   net_log_ = net_log;
-
-#if 0
   next_state_ = STATE_CONNECT;
-  bool bpost = thread_->message_loop_proxy()->PostTaskAndReply(FROM_HERE, 
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
         base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Owned(this)));
-  return bpost ? OK : ERR_FAILED;
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   int rv = DoConnect();
   DoCallback(rv);
@@ -92,25 +87,33 @@ int MmtTransactionImpl::Read(IOBuffer* buf,
   read_data_buf_ = buf;
   read_data_buf_len_ = buf_len;
   user_callback_ = callback;
-
-#if 0
   next_state_ = STATE_READ;
-  bool bpost = thread_->message_loop_proxy()->PostTask(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOComplete,
-                   base::Unretained(this)));
-  return bpost ? OK : ERR_FAILED;
+
+  if (response_.remaining_bytes < buf_len)
+    buf_len = static_cast<int>(response_.remaining_bytes);
+    
+  if (buf_len <= 0)
+    return 0;
+
+#if 1
+  DCHECK(task_runner_);
+  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
+        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
+        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
+  LOG(INFO) << TAG << ", bpost=" << bpost;
+  return bpost ? ERR_IO_PENDING : ERR_FAILED;
 #else
   return DoRead();
 #endif
 }
 
 const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   return &response_;
 }
 
 LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   switch (next_state_) {
     case STATE_NONE: 
       return LOAD_STATE_IDLE;
@@ -125,14 +128,18 @@ LoadState MmtTransactionImpl::GetLoadState() const {
 }
 
 void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << __func__ 
+  LOG(INFO) << TAG 
     << " range[" << range.first_byte_position() 
     << ", "  << range.last_byte_position() << "]";
-  response_.byte_range = range;
+  byte_range_ = range;
+}
+
+void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
+  task_runner_ = runner;
 }
 
 void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << __func__ ;
+  LOG(INFO) << TAG ;
   user_callback_.Reset();
   response_ = MmtResponseInfo();
   read_data_buf_ = NULL;
@@ -142,7 +149,7 @@ void MmtTransactionImpl::ResetStateForRestart() {
 }
 
 int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << __func__;
+  LOG(INFO) << TAG;
   next_state_ = STATE_NONE;
   if (stream_) {
     fclose((FILE*)stream_);
@@ -152,46 +159,42 @@ int MmtTransactionImpl::DoStop() {
 }
 
 int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << __func__ << ", url=" << request_->url;
+  LOG(INFO) << TAG << ", url=" << request_->url;
 
   // TODO: open file/network
-  base::FilePath file_path;
-  const bool is_file = FileURLToFilePath(request_->url, &file_path);
-  if (!is_file) {
-    LOG(ERROR) << __func__ << ", invalid file";
+  if(!FileURLToFilePath(request_->url, &file_path_)) {
+    LOG(ERROR) << TAG << ", invalid file";
     return ERR_FAILED;
   }
-  response_.file_path = file_path;
 
-  int64 file_size = 0;
-  if(!base::GetFileSize(file_path, &file_size)) {
-    LOG(ERROR) << __func__ << ", invalid file size";
+  response_.total_size = 0;
+  if(!base::GetFileSize(file_path_, &response_.total_size)) {
+    LOG(ERROR) << TAG << ", invalid file size";
     return ERR_FAILED;
   }
 
-  response_.total_size = file_size;
-  HttpByteRange byte_range = response_.byte_range;
-  if (!byte_range.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << __func__ << ", total_size=" << response_.total_size;
+  if (!byte_range_.ComputeBounds(response_.total_size)) {
+    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
     return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
   }
 
-  if (byte_range.first_byte_position() >= 0) {
-    response_.read_offset = byte_range.first_byte_position();
-  }else {
-    response_.read_offset = 0;
-  }
-  response_.expected_content_size = response_.total_size - response_.read_offset;
-  LOG(INFO) << __func__ << ", read_offset=" << response_.read_offset
-        << ", total_size=" << response_.total_size
-        << ", content_size=" << response_.expected_content_size;
+  response_.read_offset = byte_range_.first_byte_position();
+  response_.remaining_bytes = byte_range_.last_byte_position() -
+    byte_range_.first_byte_position() + 1;
+  DCHECK_GE(response_.remaining_bytes, 0);
+
+  LOG(INFO) << TAG 
+    << ", total_size=" << response_.total_size
+    << ", read_offset=" << response_.read_offset
+    << ", content_size=" << response_.expected_content_size;
 
-  FILE *fp = base::OpenFile(response_.file_path, "rb");
+  FILE *fp = base::OpenFile(file_path_, "rb");
   if (!fp) {
-    LOG(ERROR) << __func__ << ", fail to open file";
+    LOG(ERROR) << TAG << ", fail to open file";
     return ERR_FAILED;
   }
   stream_ = (void*)fp;
+  response_.expected_content_size = response_.remaining_bytes;
 
   return OK;
 }
@@ -206,9 +209,10 @@ int MmtTransactionImpl::DoRead() {
   int64 offset = response_.read_offset;
   fseek(fp, offset, SEEK_SET);
   int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << __func__ << ", offset=" << offset << ", rv=" << rv;
+  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
   if (rv > 0) {
     response_.read_offset += rv;
+    response_.remaining_bytes -= rv;
   }
   return rv;
 }
@@ -243,7 +247,7 @@ int MmtTransactionImpl::DoLoop(int result) {
 }
 
 void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << __func__ << ", rv=" << rv;
+  LOG(INFO) << TAG << ", rv=" << rv;
   DCHECK(rv != ERR_IO_PENDING);
   DCHECK(!user_callback_.is_null());
 
@@ -257,7 +261,7 @@ void MmtTransactionImpl::OnIOPrepare() {
 }
 
 void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << __func__ << ", next_state_=" << next_state_;
+  LOG(INFO) << TAG << ", next_state_=" << next_state_;
   int rv = DoLoop(OK);
   if (rv != ERR_IO_PENDING)
     DoCallback(rv);
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
index 1f98423..adbe735 100644
--- a/net/mmt/mmt_transaction_impl.h
+++ b/net/mmt/mmt_transaction_impl.h
@@ -20,9 +20,6 @@
 #include "net/mmt/mmt_information.h"
 #include "net/mmt/mmt_transaction.h"
 
-namespace base {
-class Thread;
-}
 
 namespace net {
 
@@ -46,6 +43,7 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   virtual const MmtResponseInfo* GetResponseInfo() const override;
   virtual LoadState GetLoadState() const override;
   virtual void SetRequestHeaders(HttpByteRange &range) override;
+  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
 
  private:
   void ResetStateForRestart();
@@ -65,15 +63,16 @@ class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
   };
 
 private:
-  CompletionCallback io_callback_;
   CompletionCallback user_callback_;
+  scoped_refptr<base::TaskRunner> task_runner_;
 
   BoundNetLog net_log_;
   const MmtRequestInfo* request_;
   MmtResponseInfo response_;
-  scoped_ptr<base::Thread> thread_;
+  HttpByteRange byte_range_;
 
   void* stream_;
+  base::FilePath file_path_;
   scoped_refptr<IOBuffer> read_data_buf_;
   int read_data_buf_len_;
 
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index a671486..be497ff 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -15,8 +15,10 @@
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory)
-    : mmt_transaction_factory_(mmt_transaction_factory) {
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner) {
   DCHECK(mmt_transaction_factory_);
 }
 
@@ -28,7 +30,8 @@ URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
   LOG(INFO) << "mmt url: " << request->url();
   return new URLRequestMmtJob(request,
                               network_delegate,
-                              mmt_transaction_factory_);
+                              mmt_transaction_factory_,
+                              task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 10bfe1d..185ac8f 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -12,6 +12,10 @@
 
 class GURL;
 
+namespace base {
+class TaskRunner;
+}
+
 namespace net {
 
 class MmtTransactionFactory;
@@ -22,7 +26,9 @@ class URLRequestJob;
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
-  explicit MmtProtocolHandler(MmtTransactionFactory* mmt_transaction_factory);
+  explicit MmtProtocolHandler(
+      MmtTransactionFactory* mmt_transaction_factory,
+      const scoped_refptr<base::TaskRunner>& task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -31,6 +37,7 @@ class NET_EXPORT MmtProtocolHandler :
 
  private:
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index dee151e..4e5018f 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -413,7 +413,8 @@ URLRequestContext* URLRequestContextBuilder::Build() {
     mmt_transaction_factory_.reset(
         MmtTransactionFactory::CreateFactory());
     job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get()));
+        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
+                               context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 051fcba..2806657 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -48,10 +48,12 @@ namespace net {
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory)
+    MmtTransactionFactory* mmt_transaction_factory,
+    const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
       mmt_transaction_factory_(mmt_transaction_factory),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   DCHECK(mmt_transaction_factory);
 }
@@ -72,7 +74,6 @@ bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
     const HttpRequestHeaders& headers) {
-  LOG(INFO) << __func__;
   std::string range_header;
   if (headers.GetHeader(HttpRequestHeaders::kRange, &range_header)) {
     // We only care about "Range" header here.
@@ -101,6 +102,7 @@ void URLRequestMmtJob::Start() {
   DCHECK(mmt_transaction_factory_);
   mmt_request_info_.url = request_->url();
   mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
+  mmt_transaction_->SetTaskRunner(task_runner_);
   mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
@@ -167,6 +169,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   int rv = mmt_transaction_->Read(buf, buf_size,
                                   base::Bind(&URLRequestMmtJob::OnReadCompleted,
                                              base::Unretained(this)));
+  LOG(INFO) << __func__ << ", rv=" << rv;
   if (rv >= 0) {
     *bytes_read = rv;
     return true;
@@ -181,4 +184,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   return false;
 }
 
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  return false;
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6630861..7defe8f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -27,7 +27,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
                    NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory);
+                   MmtTransactionFactory* mmt_transaction_factory,
+                   const scoped_refptr<base::TaskRunner> task_runner);
 
  protected:
   ~URLRequestMmtJob() override;
@@ -36,6 +37,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
@@ -51,6 +53,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool read_in_progress_;
 
   MmtTransactionFactory* mmt_transaction_factory_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From a4756644ac026b657ab354dd256b0fba042e58a9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:10:33 -0800
Subject: [PATCH 009/128] remove seperate mmt

---
 net/mmt/mmt_information.h              |   37 -----
 net/mmt/mmt_transaction.cc             |   37 -----
 net/mmt/mmt_transaction.h              |   80 ----------
 net/mmt/mmt_transaction_factory.h      |   31 ----
 net/mmt/mmt_transaction_impl.cc        |  270 --------------------------------
 net/mmt/mmt_transaction_impl.h         |   85 ----------
 net/net.gypi                           |    2 -
 net/url_request/url_request_mmt_job.cc |   81 +++++-----
 net/url_request/url_request_mmt_job.h  |   12 +-
 9 files changed, 51 insertions(+), 584 deletions(-)
 delete mode 100644 net/mmt/mmt_information.h
 delete mode 100644 net/mmt/mmt_transaction.cc
 delete mode 100644 net/mmt/mmt_transaction.h
 delete mode 100644 net/mmt/mmt_transaction_factory.h
 delete mode 100644 net/mmt/mmt_transaction_impl.cc
 delete mode 100644 net/mmt/mmt_transaction_impl.h

diff --git a/net/mmt/mmt_information.h b/net/mmt/mmt_information.h
deleted file mode 100644
index 514a185..0000000
--- a/net/mmt/mmt_information.h
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2010 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_INFORMATION_H_
-#define NET_MMT_MMT_INFORMATION_H_
-
-#include "url/gurl.h"
-#include "base/files/file_path.h"
-#include "net/http/http_byte_range.h"
-
-namespace net {
-
-class MmtRequestInfo {
- public:
-  // The requested URL.
-  GURL url;
-};
-
-class MmtResponseInfo {
- public:
-  MmtResponseInfo() {
-    total_size = 0;
-    read_offset = 0;
-    remaining_bytes = 0;
-    expected_content_size = 0;
-  }
-
-  int64 total_size;
-  int64 read_offset;
-  int64 remaining_bytes;
-  int64 expected_content_size;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_INFORMATION_H_
diff --git a/net/mmt/mmt_transaction.cc b/net/mmt/mmt_transaction.cc
deleted file mode 100644
index 1f0e8c7..0000000
--- a/net/mmt/mmt_transaction.cc
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright (c) 2008 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction.h"
-#include "net/mmt/mmt_transaction_impl.h"
-#include "net/mmt/mmt_transaction_factory.h"
-
-namespace net {
-
-class MmtTransactionFactoryImpl : public MmtTransactionFactory {
-public:
-  MmtTransactionFactoryImpl() : suspended_(false) {
-  }
-  virtual ~MmtTransactionFactoryImpl() override {
-  }
-
-  virtual MmtTransaction* CreateTransaction() override {
-    if (suspended_)
-      return NULL;
-
-    return new MmtTransactionImpl();
-  }
-
-  virtual void Suspend(bool suspend) override {
-    suspended_ = suspend;
-  }
-
-private:
-  bool suspended_;
-};
-
-MmtTransactionFactory* MmtTransactionFactory::CreateFactory() {
-  return new MmtTransactionFactoryImpl();
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction.h b/net/mmt/mmt_transaction.h
deleted file mode 100644
index 05a07fd..0000000
--- a/net/mmt/mmt_transaction.h
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_H_
-#define NET_MMT_MMT_TRANSACTION_H_
-
-#include "net/base/completion_callback.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_states.h"
-#include "net/base/net_export.h"
-
-
-namespace base {
-class TaskRunner;
-}
-
-namespace net {
-
-class MmtResponseInfo;
-class MmtRequestInfo;
-class BoundNetLog;
-class HttpByteRange;
-
-// Represents a single MMT transaction.
-class NET_EXPORT_PRIVATE MmtTransaction {
- public:
-  // Stops any pending IO and destroys the transaction object.
-  virtual ~MmtTransaction() {}
-
-  // Starts the MMT transaction (i.e., sends the MMT request).
-  //
-  // Returns OK if the transaction could be started synchronously, which means
-  // that the request was served from the cache (only supported for directory
-  // listings).  ERR_IO_PENDING is returned to indicate that the
-  // CompletionCallback will be notified once response info is available or if
-  // an IO error occurs.  Any other return value indicates that the transaction
-  // could not be started.
-  //
-  // Regardless of the return value, the caller is expected to keep the
-  // request_info object alive until Destroy is called on the transaction.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  // Profiling information for the request is saved to |net_log| if non-NULL.
-  virtual int Start(const MmtRequestInfo* request_info,
-                    const CompletionCallback& callback,
-                    const BoundNetLog& net_log) = 0;
-
-  // Once response info is available for the transaction, response data may be
-  // read by calling this method.
-  //
-  // Response data is copied into the given buffer and the number of bytes
-  // copied is returned.  ERR_IO_PENDING is returned if response data is not
-  // yet available.  The CompletionCallback is notified when the data copy
-  // completes, and it is passed the number of bytes that were successfully
-  // copied.  Or, if a read error occurs, the CompletionCallback is notified of
-  // the error.  Any other negative return value indicates that the transaction
-  // could not be read.
-  //
-  // NOTE: The transaction is not responsible for deleting the callback object.
-  //
-  virtual int Read(IOBuffer* buf,
-                   int buf_len,
-                   const CompletionCallback& callback) = 0;
-
-  // Returns the response info for this transaction or NULL if the response
-  // info is not available.
-  virtual const MmtResponseInfo* GetResponseInfo() const = 0;
-
-  // Returns the load state for this transaction.
-  virtual LoadState GetLoadState() const = 0;
-
-  virtual void SetRequestHeaders(HttpByteRange &range) = 0;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) = 0;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_H_
diff --git a/net/mmt/mmt_transaction_factory.h b/net/mmt/mmt_transaction_factory.h
deleted file mode 100644
index b9b1e6a..0000000
--- a/net/mmt/mmt_transaction_factory.h
+++ /dev/null
@@ -1,31 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_FACTORY_H_
-#define NET_MMT_MMT_TRANSACTION_FACTORY_H_
-
-#include "net/base/net_export.h"
-
-namespace net {
-
-class MmtTransaction;
-
-// An interface to a class that can create MmtTransaction objects.
-class NET_EXPORT MmtTransactionFactory {
- public:
-  virtual ~MmtTransactionFactory() {}
-
-  // Creates a MmtTransaction object.
-  virtual MmtTransaction* CreateTransaction() = 0;
-
-  // Suspends the creation of new transactions. If |suspend| is false, creation
-  // of new transactions is resumed.
-  virtual void Suspend(bool suspend) = 0;
-
-  static MmtTransactionFactory* CreateFactory();
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_FACTORY_H_
diff --git a/net/mmt/mmt_transaction_impl.cc b/net/mmt/mmt_transaction_impl.cc
deleted file mode 100644
index ee2274c..0000000
--- a/net/mmt/mmt_transaction_impl.cc
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "net/mmt/mmt_transaction_impl.h"
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/strings/string_util.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/thread_task_runner_handle.h"
-#include "base/threading/thread_restrictions.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
-#include "net/base/net_log.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-
-
-namespace net {
-
-#ifndef TAG
-#define TAG "["<<__func__<<" thiz="<<this<<"]"
-#endif
-
-MmtTransactionImpl::MmtTransactionImpl() :
-      request_(NULL),
-      read_data_buf_len_(0),
-      next_state_(STATE_NONE) {
-  base::ThreadRestrictions::SetIOAllowed(true);
-  response_ = MmtResponseInfo();
-  stream_ = nullptr;
-}
-
-MmtTransactionImpl::~MmtTransactionImpl() {
-  Stop(OK);
-  LOG(INFO) << TAG;
-}
-
-int MmtTransactionImpl::Stop(int error) {
-  LOG(INFO) << TAG << ", error=" << error;
-
-  last_error_ = error;
-  next_state_ = STATE_STOP;
-  int rv = DoStop();
-  return rv;
-}
-
-int MmtTransactionImpl::RestartIgnoringLastError(
-    const CompletionCallback& callback) {
-  LOG(INFO) << TAG;
-  return ERR_NOT_IMPLEMENTED;
-}
-
-int MmtTransactionImpl::Start(const MmtRequestInfo* request_info,
-                              const CompletionCallback& callback,
-                              const BoundNetLog& net_log) {
-  request_ = request_info;
-  user_callback_ = callback;
-  net_log_ = net_log;
-  next_state_ = STATE_CONNECT;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  int rv = DoConnect();
-  DoCallback(rv);
-  return true;
-#endif
-}
-
-// @return 0 if end, >0 if normal, < 0 if waiting or error
-int MmtTransactionImpl::Read(IOBuffer* buf,
-                             int buf_len,
-                             const CompletionCallback& callback) {
-  DCHECK(buf);
-  DCHECK_GT(buf_len, 0);
-  read_data_buf_ = buf;
-  read_data_buf_len_ = buf_len;
-  user_callback_ = callback;
-  next_state_ = STATE_READ;
-
-  if (response_.remaining_bytes < buf_len)
-    buf_len = static_cast<int>(response_.remaining_bytes);
-    
-  if (buf_len <= 0)
-    return 0;
-
-#if 1
-  DCHECK(task_runner_);
-  bool bpost = task_runner_->PostTaskAndReply(FROM_HERE, 
-        base::Bind(&MmtTransactionImpl::OnIOPrepare, base::Unretained(this)),
-        base::Bind(&MmtTransactionImpl::OnIOComplete, base::Unretained(this)));
-  LOG(INFO) << TAG << ", bpost=" << bpost;
-  return bpost ? ERR_IO_PENDING : ERR_FAILED;
-#else
-  return DoRead();
-#endif
-}
-
-const MmtResponseInfo* MmtTransactionImpl::GetResponseInfo() const {
-  LOG(INFO) << TAG;
-  return &response_;
-}
-
-LoadState MmtTransactionImpl::GetLoadState() const {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  switch (next_state_) {
-    case STATE_NONE: 
-      return LOAD_STATE_IDLE;
-    case STATE_CONNECT:
-      return LOAD_STATE_CONNECTING; 
-    case STATE_READ:
-      return LOAD_STATE_READING_RESPONSE;
-    default: 
-      break;
-  }
-  return LOAD_STATE_IDLE;
-}
-
-void MmtTransactionImpl::SetRequestHeaders(HttpByteRange &range) {
-  LOG(INFO) << TAG 
-    << " range[" << range.first_byte_position() 
-    << ", "  << range.last_byte_position() << "]";
-  byte_range_ = range;
-}
-
-void MmtTransactionImpl::SetTaskRunner(scoped_refptr<base::TaskRunner> runner) {
-  task_runner_ = runner;
-}
-
-void MmtTransactionImpl::ResetStateForRestart() {
-  LOG(INFO) << TAG ;
-  user_callback_.Reset();
-  response_ = MmtResponseInfo();
-  read_data_buf_ = NULL;
-  read_data_buf_len_ = 0;
-  last_error_ = OK;
-  next_state_ = STATE_NONE;
-}
-
-int MmtTransactionImpl::DoStop() {
-  LOG(INFO) << TAG;
-  next_state_ = STATE_NONE;
-  if (stream_) {
-    fclose((FILE*)stream_);
-    stream_ = nullptr;
-  }
-  return OK;
-}
-
-int MmtTransactionImpl::DoConnect() {
-  LOG(INFO) << TAG << ", url=" << request_->url;
-
-  // TODO: open file/network
-  if(!FileURLToFilePath(request_->url, &file_path_)) {
-    LOG(ERROR) << TAG << ", invalid file";
-    return ERR_FAILED;
-  }
-
-  response_.total_size = 0;
-  if(!base::GetFileSize(file_path_, &response_.total_size)) {
-    LOG(ERROR) << TAG << ", invalid file size";
-    return ERR_FAILED;
-  }
-
-  if (!byte_range_.ComputeBounds(response_.total_size)) {
-    LOG(ERROR) << TAG << ", total_size=" << response_.total_size;
-    return ERR_REQUEST_RANGE_NOT_SATISFIABLE;
-  }
-
-  response_.read_offset = byte_range_.first_byte_position();
-  response_.remaining_bytes = byte_range_.last_byte_position() -
-    byte_range_.first_byte_position() + 1;
-  DCHECK_GE(response_.remaining_bytes, 0);
-
-  LOG(INFO) << TAG 
-    << ", total_size=" << response_.total_size
-    << ", read_offset=" << response_.read_offset
-    << ", content_size=" << response_.expected_content_size;
-
-  FILE *fp = base::OpenFile(file_path_, "rb");
-  if (!fp) {
-    LOG(ERROR) << TAG << ", fail to open file";
-    return ERR_FAILED;
-  }
-  stream_ = (void*)fp;
-  response_.expected_content_size = response_.remaining_bytes;
-
-  return OK;
-}
-
-int MmtTransactionImpl::DoRead() {
-  DCHECK(read_data_buf_.get());
-  DCHECK_GT(read_data_buf_len_, 0);
-  DCHECK(stream_);
-  read_data_buf_->data()[0] = 0;
-
-  FILE *fp = (FILE *)stream_;
-  int64 offset = response_.read_offset;
-  fseek(fp, offset, SEEK_SET);
-  int rv = fread(read_data_buf_.get()->data(), 1, read_data_buf_len_, fp);
-  LOG(INFO) << TAG << ", offset=" << offset << ", rv=" << rv;
-  if (rv > 0) {
-    response_.read_offset += rv;
-    response_.remaining_bytes -= rv;
-  }
-  return rv;
-}
-
-int MmtTransactionImpl::DoLoop(int result) {
-  DCHECK(next_state_ != STATE_NONE);
-
-  int rv = result;
-  do {
-    State state = next_state_;
-    next_state_ = STATE_NONE;
-    switch (state) {
-      case STATE_STOP:
-        DCHECK(rv == OK);
-        rv = DoStop();
-        break;
-      case STATE_CONNECT:
-        DCHECK(rv == OK);
-        rv = DoConnect();
-        break;
-      case STATE_READ:
-        DCHECK(rv == OK);
-        rv = DoRead();
-        break;
-      default:
-        NOTREACHED() << "bad state";
-        rv = ERR_UNEXPECTED;
-        break;
-    }
-  } while (rv != ERR_IO_PENDING && next_state_ != STATE_NONE);
-  return rv;
-}
-
-void MmtTransactionImpl::DoCallback(int rv) {
-  LOG(INFO) << TAG << ", rv=" << rv;
-  DCHECK(rv != ERR_IO_PENDING);
-  DCHECK(!user_callback_.is_null());
-
-  // Since Run may result in Read being called, clear callback_ up front.
-  CompletionCallback c = user_callback_;
-  user_callback_.Reset();
-  c.Run(rv);
-}
-
-void MmtTransactionImpl::OnIOPrepare() {
-}
-
-void MmtTransactionImpl::OnIOComplete() {
-  LOG(INFO) << TAG << ", next_state_=" << next_state_;
-  int rv = DoLoop(OK);
-  if (rv != ERR_IO_PENDING)
-    DoCallback(rv);
-}
-
-}  // namespace net
diff --git a/net/mmt/mmt_transaction_impl.h b/net/mmt/mmt_transaction_impl.h
deleted file mode 100644
index adbe735..0000000
--- a/net/mmt/mmt_transaction_impl.h
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef NET_MMT_MMT_TRANSACTION_IMPL_H_
-#define NET_MMT_MMT_TRANSACTION_IMPL_H_
-
-#include <string>
-#include <utility>
-
-#include "base/basictypes.h"
-#include "base/compiler_specific.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/scoped_ptr.h"
-#include "net/base/address_list.h"
-#include "net/base/auth.h"
-#include "net/base/net_log.h"
-#include "net/dns/host_resolver.h"
-#include "net/dns/single_request_host_resolver.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
-
-
-namespace net {
-
-class FileStream;
-
-class NET_EXPORT_PRIVATE MmtTransactionImpl : public MmtTransaction {
- public:
-  MmtTransactionImpl();
-  virtual ~MmtTransactionImpl() override;
-
-  virtual int Stop(int error);
-  virtual int RestartIgnoringLastError(const CompletionCallback& callback);
-
-  // MmtTransaction methods:
-  virtual int Start(const MmtRequestInfo* request_info,
-            const CompletionCallback& callback,
-            const BoundNetLog& net_log) override;
-  virtual int Read(IOBuffer* buf,
-           int buf_len,
-           const CompletionCallback& callback) override;
-  virtual const MmtResponseInfo* GetResponseInfo() const override;
-  virtual LoadState GetLoadState() const override;
-  virtual void SetRequestHeaders(HttpByteRange &range) override;
-  virtual void SetTaskRunner(scoped_refptr<base::TaskRunner> runner) override;
-
- private:
-  void ResetStateForRestart();
-  void OnIOPrepare();
-  void OnIOComplete();
-  void DoCallback(int result);
-  int DoLoop(int result);
-  int DoStop();
-  int DoConnect();
-  int DoRead();
-
-  enum State {
-    STATE_STOP,
-    STATE_CONNECT,
-    STATE_READ,
-    STATE_NONE
-  };
-
-private:
-  CompletionCallback user_callback_;
-  scoped_refptr<base::TaskRunner> task_runner_;
-
-  BoundNetLog net_log_;
-  const MmtRequestInfo* request_;
-  MmtResponseInfo response_;
-  HttpByteRange byte_range_;
-
-  void* stream_;
-  base::FilePath file_path_;
-  scoped_refptr<IOBuffer> read_data_buf_;
-  int read_data_buf_len_;
-
-  int last_error_;
-  State next_state_;
-};
-
-}  // namespace net
-
-#endif  // NET_MMT_MMT_TRANSACTION_IMPL_H_
diff --git a/net/net.gypi b/net/net.gypi
index 0335fc6..ad08a23 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,8 +700,6 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
-      'mmt/mmt_transaction.cc',
-      'mmt/mmt_transaction_impl.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2806657..bd64769 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,10 +52,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner> task_runner)
     : URLRequestJob(request, network_delegate),
       read_in_progress_(false),
-      mmt_transaction_factory_(mmt_transaction_factory),
+      total_bytes_(0),
+      read_offset_(0),
+      remaining_bytes_(0),
       task_runner_(task_runner),
       weak_ptr_factory_(this) {
-  DCHECK(mmt_transaction_factory);
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
@@ -94,47 +95,39 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 void URLRequestMmtJob::Start() {
-  LOG(INFO) << __func__;
-  DCHECK(!mmt_transaction_);
-
-  // Create a transaction.
+  LOG(INFO) << __FUNCTION__;
   DCHECK(request_);
-  DCHECK(mmt_transaction_factory_);
-  mmt_request_info_.url = request_->url();
-  mmt_transaction_.reset(mmt_transaction_factory_->CreateTransaction());
-  mmt_transaction_->SetTaskRunner(task_runner_);
-  mmt_transaction_->SetRequestHeaders(byte_range_);
 
   // No matter what, we want to report our status as IO pending since we will
   // be notifying our consumer asynchronously via OnStartCompleted.
   SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  mmt_transaction_->Start(
-        &mmt_request_info_,
-        base::Bind(&URLRequestMmtJob::OnStartCompleted,
-                   base::Unretained(this)),
-        request_->net_log());
+
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoStart, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidStart, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
 }
 
 void URLRequestMmtJob::Kill() {
   LOG(INFO) << __FUNCTION__;
-  mmt_transaction_.reset();
-
   URLRequestJob::Kill();
   weak_ptr_factory_.InvalidateWeakPtrs();
 }
 
 void URLRequestMmtJob::OnStartCompleted(int result) {
-  DCHECK(mmt_transaction_);
-
-  int64 content_size = mmt_transaction_->GetResponseInfo()->expected_content_size;
-  LOG(INFO) << __FUNCTION__ << ", result=" << result << ", content_size=" << content_size;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   // Clear the IO_PENDING status
   SetStatus(URLRequestStatus());
 
   // MMT obviously doesn't have HTTP Content-Length header. We have to pass
   // the content size information manually.
-  set_expected_content_size(content_size);
+  set_expected_content_size(remaining_bytes_);
 
   if (result == OK) {
     NotifyHeadersComplete();
@@ -144,7 +137,8 @@ void URLRequestMmtJob::OnStartCompleted(int result) {
 }
 
 void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result;
+  LOG(INFO) << __FUNCTION__ << ", result=" << result 
+    << ", remaining_bytes_=" << remaining_bytes_;
 
   read_in_progress_ = false;
   if (result == OK) {
@@ -164,23 +158,25 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
   DCHECK_NE(buf_size, 0);
   DCHECK(bytes_read);
   DCHECK(!read_in_progress_);
-  DCHECK(mmt_transaction_);
-
-  int rv = mmt_transaction_->Read(buf, buf_size,
-                                  base::Bind(&URLRequestMmtJob::OnReadCompleted,
-                                             base::Unretained(this)));
-  LOG(INFO) << __func__ << ", rv=" << rv;
-  if (rv >= 0) {
-    *bytes_read = rv;
+
+  if (remaining_bytes_ < buf_len)
+    buf_len = static_cast<int>(remaining_bytes_);
+
+  if (buf_len == 0) {
+    *bytes_read = 0;
     return true;
   }
 
-  if (rv == ERR_IO_PENDING) {
-    read_in_progress_ = true;
-    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  } else {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
-  }
+  int *pret = new int;
+  task_runner_->PostTaskAndReply(
+        FROM_HERE, 
+        base::Bind(&URLRequestMmtJob::DoRead, 
+                   base::Unretained(pret)),
+        base::Bind(&URLRequestMmtJob::DidRead, 
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(pret)));
+  read_in_progress_ = true;
+  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
   return false;
 }
 
@@ -189,4 +185,13 @@ bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
   return false;
 }
 
+void URLRequestMmtJob::DoStart(int* result) {
+}
+void URLRequestMmtJob::DidStart(const int* result) {
+}
+void URLRequestMmtJob::DoRead(int* result) {
+}
+void URLRequestMmtJob::DidRead(const int* result) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 7defe8f..d00ca95 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -42,17 +42,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
  private:
+  void DoStart(int* result);
+  void DidStart(const int* result);
   void OnStartCompleted(int result);
+
+  void DoRead(int* result);
+  void DidRead(const int* result);
   void OnReadCompleted(int result);
 
  private:
-  MmtRequestInfo mmt_request_info_;
-  scoped_ptr<MmtTransaction> mmt_transaction_;
-
   HttpByteRange byte_range_;
   bool read_in_progress_;
+  int64 total_bytes_;
+  int64 read_offset_;
+  int64 remaining_bytes_;
 
-  MmtTransactionFactory* mmt_transaction_factory_;
   const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9140756855d7ba36e0346996e9ac7f1ce82667de Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:32:07 -0800
Subject: [PATCH 010/128] add mmt local support

---
 .../profiles/off_the_record_profile_io_data.cc     |   14 +-
 .../profiles/off_the_record_profile_io_data.h      |    2 -
 chrome/browser/profiles/profile_impl_io_data.cc    |   15 +-
 chrome/browser/profiles/profile_impl_io_data.h     |    2 -
 chrome/browser/profiles/profile_io_data.cc         |    5 +-
 chrome/browser/profiles/profile_io_data.h          |    5 +-
 net/url_request/mmt_protocol_handler.cc            |   20 +-
 net/url_request/mmt_protocol_handler.h             |   11 +-
 net/url_request/url_request_context_builder.cc     |    9 +-
 net/url_request/url_request_context_builder.h      |    1 -
 net/url_request/url_request_mmt_job.cc             |  327 +++++++++++++-------
 net/url_request/url_request_mmt_job.h              |   87 ++++--
 12 files changed, 304 insertions(+), 194 deletions(-)

diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.cc b/chrome/browser/profiles/off_the_record_profile_io_data.cc
index d47b636..798bea3 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.cc
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.cc
@@ -261,11 +261,6 @@ void OffTheRecordProfileIOData::InitializeInternal(
       new net::FtpNetworkLayer(main_context->host_resolver()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
 
@@ -275,8 +270,7 @@ void OffTheRecordProfileIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
   // Setup SDCH for this profile.
@@ -334,8 +328,7 @@ void OffTheRecordProfileIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -375,8 +368,7 @@ net::URLRequestContext* OffTheRecordProfileIOData::InitializeAppRequestContext(
                                             request_interceptors.Pass(),
                                             protocol_handler_interceptor.Pass(),
                                             main_context->network_delegate(),
-                                            ftp_factory_.get(),
-                                            mmt_factory_.get());
+                                            ftp_factory_.get());
   context->SetJobFactory(top_job_factory.Pass());
   return context;
 }
diff --git a/chrome/browser/profiles/off_the_record_profile_io_data.h b/chrome/browser/profiles/off_the_record_profile_io_data.h
index fa54638..900dbfc 100644
--- a/chrome/browser/profiles/off_the_record_profile_io_data.h
+++ b/chrome/browser/profiles/off_the_record_profile_io_data.h
@@ -21,7 +21,6 @@ class Profile;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpTransactionFactory;
 class SdchManager;
 class URLRequestContext;
@@ -147,7 +146,6 @@ class OffTheRecordProfileIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   mutable scoped_ptr<net::URLRequestJobFactory> main_job_factory_;
   mutable scoped_ptr<net::URLRequestJobFactory> extensions_job_factory_;
diff --git a/chrome/browser/profiles/profile_impl_io_data.cc b/chrome/browser/profiles/profile_impl_io_data.cc
index 4f21760..8b39439 100644
--- a/chrome/browser/profiles/profile_impl_io_data.cc
+++ b/chrome/browser/profiles/profile_impl_io_data.cc
@@ -54,7 +54,6 @@
 #include "net/base/cache_type.h"
 #include "net/base/sdch_manager.h"
 #include "net/ftp/ftp_network_layer.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/http/http_cache.h"
 #include "net/http/http_server_properties_manager.h"
 #include "net/ssl/channel_id_service.h"
@@ -582,11 +581,6 @@ void ProfileImplIOData::InitializeInternal(
       new net::FtpNetworkLayer(io_thread_globals->host_resolver.get()));
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
-#if !defined(DISABLE_MMT_SUPPORT)
-  mmt_factory_.reset(
-      net::MmtTransactionFactory::CreateFactory());
-#endif
-
   scoped_ptr<net::URLRequestJobFactoryImpl> main_job_factory(
       new net::URLRequestJobFactoryImpl());
   InstallProtocolHandlers(main_job_factory.get(), protocol_handlers);
@@ -603,8 +597,7 @@ void ProfileImplIOData::InitializeInternal(
       request_interceptors.Pass(),
       profile_params->protocol_handler_interceptor.Pass(),
       main_context->network_delegate(),
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   main_context->set_job_factory(main_job_factory_.get());
 
 #if defined(ENABLE_EXTENSIONS)
@@ -669,8 +662,7 @@ void ProfileImplIOData::
       content::URLRequestInterceptorScopedVector(),
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>(),
       NULL,
-      ftp_factory_.get(),
-      mmt_factory_.get());
+      ftp_factory_.get());
   extensions_context->set_job_factory(extensions_job_factory_.get());
 }
 
@@ -757,8 +749,7 @@ net::URLRequestContext* ProfileImplIOData::InitializeAppRequestContext(
                               request_interceptors.Pass(),
                               protocol_handler_interceptor.Pass(),
                               main_context->network_delegate(),
-                              ftp_factory_.get(),
-                              mmt_factory_.get()));
+                              ftp_factory_.get()));
   context->SetJobFactory(top_job_factory.Pass());
 
   return context;
diff --git a/chrome/browser/profiles/profile_impl_io_data.h b/chrome/browser/profiles/profile_impl_io_data.h
index 505da31..383fc40 100644
--- a/chrome/browser/profiles/profile_impl_io_data.h
+++ b/chrome/browser/profiles/profile_impl_io_data.h
@@ -34,7 +34,6 @@ class DomainReliabilityMonitor;
 
 namespace net {
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpServerPropertiesManager;
 class HttpTransactionFactory;
@@ -230,7 +229,6 @@ class ProfileImplIOData : public ProfileIOData {
 
   mutable scoped_ptr<net::HttpTransactionFactory> main_http_factory_;
   mutable scoped_ptr<net::FtpTransactionFactory> ftp_factory_;
-  mutable scoped_ptr<net::MmtTransactionFactory> mmt_factory_;
 
   // Same as |ProfileIOData::http_server_properties_|, owned there to maintain
   // destruction ordering.
diff --git a/chrome/browser/profiles/profile_io_data.cc b/chrome/browser/profiles/profile_io_data.cc
index 7cb34a4..fee77fb 100644
--- a/chrome/browser/profiles/profile_io_data.cc
+++ b/chrome/browser/profiles/profile_io_data.cc
@@ -1162,8 +1162,7 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
     scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
         protocol_handler_interceptor,
     net::NetworkDelegate* network_delegate,
-    net::FtpTransactionFactory* ftp_transaction_factory,
-    net::MmtTransactionFactory* mmt_transaction_factory) const {
+    net::FtpTransactionFactory* ftp_transaction_factory) const {
   // NOTE(willchan): Keep these protocol handlers in sync with
   // ProfileIOData::IsHandledProtocol().
   bool set_protocol = job_factory->SetProtocolHandler(
@@ -1218,11 +1217,9 @@ scoped_ptr<net::URLRequestJobFactory> ProfileIOData::SetUpJobFactoryDefaults(
 #endif  // !defined(DISABLE_FTP_SUPPORT)
 
 #if !defined(DISABLE_MMT_SUPPORT)
-  DCHECK(mmt_transaction_factory);
   bool mmt_protocol = job_factory->SetProtocolHandler(
       url::kMmtScheme,
       new net::MmtProtocolHandler(
-            mmt_transaction_factory,
             content::BrowserThread::GetBlockingPool()->
               GetTaskRunnerWithShutdownBehavior(
                   base::SequencedWorkerPool::SKIP_ON_SHUTDOWN)));
diff --git a/chrome/browser/profiles/profile_io_data.h b/chrome/browser/profiles/profile_io_data.h
index fcc9fef..244107f 100644
--- a/chrome/browser/profiles/profile_io_data.h
+++ b/chrome/browser/profiles/profile_io_data.h
@@ -34,7 +34,6 @@
 #include "net/http/http_network_session.h"
 #include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_job_factory.h"
-#include "net/mmt/mmt_transaction_factory.h"
 
 class ChromeHttpUserAgentSettings;
 class ChromeNetworkDelegate;
@@ -61,7 +60,6 @@ class ChannelIDService;
 class CookieStore;
 class FraudulentCertificateReporter;
 class FtpTransactionFactory;
-class MmtTransactionFactory;
 class HttpServerProperties;
 class HttpTransactionFactory;
 class ProxyConfigService;
@@ -360,8 +358,7 @@ class ProfileIOData {
       scoped_ptr<ProtocolHandlerRegistry::JobInterceptorFactory>
           protocol_handler_interceptor,
       net::NetworkDelegate* network_delegate,
-      net::FtpTransactionFactory* ftp_transaction_factory,
-      net::MmtTransactionFactory* mmt_transaction_factory) const;
+      net::FtpTransactionFactory* ftp_transaction_factory) const;
 
   // Called when the profile is destroyed.
   void ShutdownOnUIThread(
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index be497ff..19a5fbb 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -6,32 +6,22 @@
 
 #include "base/logging.h"
 #include "base/task_runner.h"
+#include "net/base/filename_util.h"
 #include "net/base/net_errors.h"
 #include "net/url_request/url_request.h"
-#include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_mmt_job.h"
-#include "url/gurl.h"
 
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner>& task_runner)
-    : mmt_transaction_factory_(mmt_transaction_factory),
-      task_runner_(task_runner) {
-  DCHECK(mmt_transaction_factory_);
-}
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    : mmt_task_runner_(mmt_task_runner) {}
 
-MmtProtocolHandler::~MmtProtocolHandler() {
-}
+MmtProtocolHandler::~MmtProtocolHandler() {}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  LOG(INFO) << "mmt url: " << request->url();
-  return new URLRequestMmtJob(request,
-                              network_delegate,
-                              mmt_transaction_factory_,
-                              task_runner_);
+  return new URLRequestMmtJob(request, network_delegate, mmt_task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index 185ac8f..a823916 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -18,17 +18,16 @@ class TaskRunner;
 
 namespace net {
 
-class MmtTransactionFactory;
 class NetworkDelegate;
 class URLRequestJob;
 
-// Implements a ProtocolHandler for MMT jobs. 
+// Implements a ProtocolHandler for Mmt jobs. If |network_delegate_| is NULL,
+// then all mmt requests will fail with ERR_ACCESS_DENIED.
 class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
   explicit MmtProtocolHandler(
-      MmtTransactionFactory* mmt_transaction_factory,
-      const scoped_refptr<base::TaskRunner>& task_runner);
+      const scoped_refptr<base::TaskRunner>& mmt_task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -36,9 +35,7 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  MmtTransactionFactory* mmt_transaction_factory_;
-  const scoped_refptr<base::TaskRunner> task_runner_;
-
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_context_builder.cc b/net/url_request/url_request_context_builder.cc
index 4e5018f..cbdf642 100644
--- a/net/url_request/url_request_context_builder.cc
+++ b/net/url_request/url_request_context_builder.cc
@@ -18,7 +18,6 @@
 #include "net/cert/cert_verifier.h"
 #include "net/cookies/cookie_monster.h"
 #include "net/dns/host_resolver.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/ftp/ftp_network_layer.h"
 #include "net/http/http_auth_handler_factory.h"
 #include "net/http/http_cache.h"
@@ -410,11 +409,9 @@ URLRequestContext* URLRequestContextBuilder::Build() {
 
 #if !defined(DISABLE_MMT_SUPPORT)
   if (mmt_enabled_) {
-    mmt_transaction_factory_.reset(
-        MmtTransactionFactory::CreateFactory());
-    job_factory->SetProtocolHandler("mmt",
-        new MmtProtocolHandler(mmt_transaction_factory_.get(), 
-                               context->GetFileThread()->message_loop_proxy()));
+    job_factory->SetProtocolHandler(
+        "mmt",
+        new MmtProtocolHandler(context->GetFileThread()->message_loop_proxy()));
   }
 #endif
 
diff --git a/net/url_request/url_request_context_builder.h b/net/url_request/url_request_context_builder.h
index c2cec99..bb4d30a 100644
--- a/net/url_request/url_request_context_builder.h
+++ b/net/url_request/url_request_context_builder.h
@@ -227,7 +227,6 @@ class NET_EXPORT URLRequestContextBuilder {
   scoped_ptr<ProxyService> proxy_service_;
   scoped_ptr<NetworkDelegate> network_delegate_;
   scoped_ptr<FtpTransactionFactory> ftp_transaction_factory_;
-  scoped_ptr<MmtTransactionFactory> mmt_transaction_factory_;
   std::vector<SchemeFactory> extra_http_auth_handlers_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestContextBuilder);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index bd64769..9d157d9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -2,74 +2,160 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// For loading files, we make use of overlapped i/o to ensure that reading from
-// the filesystem (e.g., a network filesystem) does not block the calling
-// thread.  An alternative approach would be to use a background thread or pool
-// of threads, but it seems better to leverage the operating system's ability
-// to do background file reads for us.
-//
-// Since overlapped reads require a 'static' buffer for the duration of the
-// asynchronous read, the URLRequestMmtJob keeps a buffer as a member var.  In
-// URLRequestMmtJob::Read, data is simply copied from the object's buffer into
-// the given buffer.  If there is no data to copy, the URLRequestMmtJob
-// attempts to read more from the file to fill its buffer.  If reading from the
-// file does not complete synchronously, then the URLRequestMmtJob waits for a
-// signal from the OS that the overlapped read has completed.  It does so by
-// leveraging the MessageLoop::WatchObject API.
-
 #include "net/url_request/url_request_mmt_job.h"
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
+#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
+#include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
 #include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
-#include "net/base/net_util.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction_factory.h"
 #include "net/filter/filter.h"
 #include "net/http/http_util.h"
-#include "net/http/http_response_headers.h"
-#include "net/http/http_transaction_factory.h"
-#include "net/url_request/url_request.h"
-#include "net/url_request/url_request_context.h"
 #include "net/url_request/url_request_error_job.h"
+#include "net/url_request/url_request_file_dir_job.h"
 #include "url/gurl.h"
 
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
 namespace net {
 
+URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    MmtTransactionFactory* mmt_transaction_factory,
-    const scoped_refptr<base::TaskRunner> task_runner)
+    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      read_in_progress_(false),
-      total_bytes_(0),
-      read_offset_(0),
+      stream_(new FileStream(mmt_task_runner)),
+      mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
-      task_runner_(task_runner),
       weak_ptr_factory_(this) {
 }
 
-URLRequestMmtJob::~URLRequestMmtJob() {
+void URLRequestMmtJob::Start() {
+  FileMetaInfo* meta_info = new FileMetaInfo();
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
+                 base::Unretained(meta_info)),
+      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(meta_info)));
+}
+
+void URLRequestMmtJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
 }
 
-#if 0
-bool URLRequestMmtJob::IsSafeRedirect(const GURL& location) {
-  // Disallow all redirects.
+bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
+                                    int dest_size,
+                                    int* bytes_read) {
+  DCHECK_NE(dest_size, 0);
+  DCHECK(bytes_read);
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size) {
+    *bytes_read = 0;
+    return true;
+  }
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestMmtJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    // Data is immediately available.
+    *bytes_read = rv;
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+    return true;
+  }
+
+  // Otherwise, a read error occured.  We may just need to wait...
+  if (rv == ERR_IO_PENDING) {
+    SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+  } else {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, rv));
+  }
   return false;
 }
+
+bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (meta_info_.is_directory) {
+    // This happens when we discovered the file is a directory, so needs a
+    // slash at the end of the path.
+    std::string new_path = request_->url().path();
+    new_path.push_back('/');
+    GURL::Replacements replacements;
+    replacements.SetPathStr(new_path);
+
+    *location = request_->url().ReplaceComponents(replacements);
+    *http_status_code = 301;  // simulate a permanent redirect
+    return true;
+  }
+
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
 #endif
+}
+
+Filter* URLRequestMmtJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? Filter::GZipFactory() : NULL;
+}
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
+  DCHECK(request_);
+  if (meta_info_.mime_type_result) {
+    *mime_type = meta_info_.mime_type;
+    return true;
+  }
   return false;
 }
 
@@ -94,104 +180,131 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::Start() {
-  LOG(INFO) << __FUNCTION__;
-  DCHECK(request_);
+void URLRequestMmtJob::OnSeekComplete(int64 result) {
+}
 
-  // No matter what, we want to report our status as IO pending since we will
-  // be notifying our consumer asynchronously via OnStartCompleted.
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
+void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
+}
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoStart, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidStart, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
+URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::Kill() {
-  LOG(INFO) << __FUNCTION__;
-  URLRequestJob::Kill();
-  weak_ptr_factory_.InvalidateWeakPtrs();
+void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
+                                                    &meta_info->mime_type);
 }
 
-void URLRequestMmtJob::OnStartCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
 
-  // Clear the IO_PENDING status
-  SetStatus(URLRequestStatus());
+  // We use URLRequestMmtJob to handle files as well as directories without
+  // trailing slash.
+  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
+  // we will append trailing slash and redirect to FileDirJob.
+  // A special case is "\" on Windows. We should resolve as invalid.
+  // However, Windows resolves "\" to "C:\", thus reports it as existent.
+  // So what happens is we append it with trailing slash and redirect it to
+  // FileDirJob where it is resolved as invalid.
+  if (!meta_info_.file_exists) {
+    DidOpen(ERR_FILE_NOT_FOUND);
+    return;
+  }
+  if (meta_info_.is_directory) {
+    DidOpen(OK);
+    return;
+  }
 
-  // MMT obviously doesn't have HTTP Content-Length header. We have to pass
-  // the content size information manually.
-  set_expected_content_size(remaining_bytes_);
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestMmtJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestMmtJob::DidOpen(int result) {
+  // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+  tracked_objects::ScopedTracker tracking_profile(
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
 
-  if (result == OK) {
-    NotifyHeadersComplete();
-  }else {
+  if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+    return;
   }
-}
 
-void URLRequestMmtJob::OnReadCompleted(int result) {
-  LOG(INFO) << __FUNCTION__ << ", result=" << result 
-    << ", remaining_bytes_=" << remaining_bytes_;
+  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+               ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  read_in_progress_ = false;
-  if (result == OK) {
-    NotifyDone(URLRequestStatus());
-  } else if (result < 0) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  remaining_bytes_ = byte_range_.last_byte_position() -
+                     byte_range_.first_byte_position() + 1;
+  DCHECK_GE(remaining_bytes_, 0);
+
+  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
+    tracked_objects::ScopedTracker tracking_profile1(
+        FROM_HERE_WITH_EXPLICIT_FUNCTION(
+            "423948 URLRequestMmtJob::DidOpen 1"));
+
+    int rv = stream_->Seek(base::File::FROM_BEGIN,
+                           byte_range_.first_byte_position(),
+                           base::Bind(&URLRequestMmtJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
   } else {
-    // Clear the IO_PENDING status
-    SetStatus(URLRequestStatus());
+    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+    // the value that would mean seek success. This way we skip the code
+    // handling seek failure.
+    DidSeek(byte_range_.first_byte_position());
   }
-  NotifyReadComplete(result);
 }
 
-bool URLRequestMmtJob::ReadRawData(IOBuffer* buf,
-                                    int buf_size,
-                                    int* bytes_read) {
-  DCHECK_NE(buf_size, 0);
-  DCHECK(bytes_read);
-  DCHECK(!read_in_progress_);
+void URLRequestMmtJob::DidSeek(int64 result) {
+  OnSeekComplete(result);
+  if (result != byte_range_.first_byte_position()) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
+                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+    return;
+  }
 
-  if (remaining_bytes_ < buf_len)
-    buf_len = static_cast<int>(remaining_bytes_);
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
 
-  if (buf_len == 0) {
-    *bytes_read = 0;
-    return true;
+void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result > 0) {
+    SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
   }
 
-  int *pret = new int;
-  task_runner_->PostTaskAndReply(
-        FROM_HERE, 
-        base::Bind(&URLRequestMmtJob::DoRead, 
-                   base::Unretained(pret)),
-        base::Bind(&URLRequestMmtJob::DidRead, 
-                   weak_ptr_factory_.GetWeakPtr(),
-                   base::Owned(pret)));
-  read_in_progress_ = true;
-  SetStatus(URLRequestStatus(URLRequestStatus::IO_PENDING, 0));
-  return false;
-}
+  OnReadComplete(buf.get(), result);
+  buf = NULL;
 
-bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  return false;
-}
+  if (result == 0) {
+    NotifyDone(URLRequestStatus());
+  } else if (result < 0) {
+    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
+  }
 
-void URLRequestMmtJob::DoStart(int* result) {
-}
-void URLRequestMmtJob::DidStart(const int* result) {
-}
-void URLRequestMmtJob::DoRead(int* result) {
-}
-void URLRequestMmtJob::DidRead(const int* result) {
+  NotifyReadComplete(result);
 }
 
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index d00ca95..5e93f97 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -8,56 +8,97 @@
 #include <string>
 #include <vector>
 
+#include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "net/base/net_export.h"
-#include "net/mmt/mmt_information.h"
-#include "net/mmt/mmt_transaction.h"
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
 
+namespace base {
+class TaskRunner;
+}
+namespace file_util {
+struct FileInfo;
+}
+
 namespace net {
 
-class NetworkDelegate;
-class MmtTransactionFactory;
+class FileStream;
 
-// A request job that handles reading mmt URLs
+// A request job that handles reading file URLs
 class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  public:
   URLRequestMmtJob(URLRequest* request,
-                   NetworkDelegate* network_delegate,
-                   MmtTransactionFactory* mmt_transaction_factory,
-                   const scoped_refptr<base::TaskRunner> task_runner);
+                    NetworkDelegate* network_delegate,
+                    const scoped_refptr<base::TaskRunner>& mmt_task_runner);
 
- protected:
-  ~URLRequestMmtJob() override;
-
-  // Overridden from URLRequestJob:
+  // URLRequestJob:
   void Start() override;
   void Kill() override;
   bool ReadRawData(IOBuffer* buf, int buf_size, int* bytes_read) override;
   bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  Filter* SetupFilter() const override;
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
- private:
-  void DoStart(int* result);
-  void DidStart(const int* result);
-  void OnStartCompleted(int result);
+  // An interface for subclasses who wish to monitor read operations.
+  virtual void OnSeekComplete(int64 result);
+  virtual void OnReadComplete(net::IOBuffer* buf, int result);
+
+ protected:
+  ~URLRequestMmtJob() override;
+
+  int64 remaining_bytes() const { return remaining_bytes_; }
 
-  void DoRead(int* result);
-  void DidRead(const int* result);
-  void OnReadCompleted(int result);
+  // The OS-specific full path name of the file
+  base::FilePath file_path_;
 
  private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestMmtJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64 file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64 result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  scoped_ptr<FileStream> stream_;
+  FileMetaInfo meta_info_;
+  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+
   HttpByteRange byte_range_;
-  bool read_in_progress_;
-  int64 total_bytes_;
-  int64 read_offset_;
   int64 remaining_bytes_;
 
-  const scoped_refptr<base::TaskRunner> task_runner_;
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
   DISALLOW_COPY_AND_ASSIGN(URLRequestMmtJob);
-- 
1.7.9.5


From c9c8fc65c620b3909a80f0434818bef397a90dfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 07:41:00 -0800
Subject: [PATCH 011/128] OK for mmt local file

---
 net/url_request/url_request_mmt_job.cc |   50 ++------------------------------
 net/url_request/url_request_mmt_job.h  |    4 ---
 2 files changed, 2 insertions(+), 52 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 9d157d9..3e01eca 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
+  FileURLToFilePath(request_->url(), &file_path_);
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -109,53 +110,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
-  if (meta_info_.is_directory) {
-    // This happens when we discovered the file is a directory, so needs a
-    // slash at the end of the path.
-    std::string new_path = request_->url().path();
-    new_path.push_back('/');
-    GURL::Replacements replacements;
-    replacements.SetPathStr(new_path);
-
-    *location = request_->url().ReplaceComponents(replacements);
-    *http_status_code = 301;  // simulate a permanent redirect
-    return true;
-  }
-
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
   return false;
-#endif
 }
 
 Filter* URLRequestMmtJob::SetupFilter() const {
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-      ? Filter::GZipFactory() : NULL;
+  return NULL;
 }
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
   return false;
 }
 
@@ -180,12 +143,6 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
   }
 }
 
-void URLRequestMmtJob::OnSeekComplete(int64 result) {
-}
-
-void URLRequestMmtJob::OnReadComplete(net::IOBuffer* buf, int result) {
-}
-
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
@@ -277,7 +234,6 @@ void URLRequestMmtJob::DidOpen(int result) {
 }
 
 void URLRequestMmtJob::DidSeek(int64 result) {
-  OnSeekComplete(result);
   if (result != byte_range_.first_byte_position()) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                                 ERR_REQUEST_RANGE_NOT_SATISFIABLE));
@@ -294,8 +250,6 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
     remaining_bytes_ -= result;
     DCHECK_GE(remaining_bytes_, 0);
   }
-
-  OnReadComplete(buf.get(), result);
   buf = NULL;
 
   if (result == 0) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 5e93f97..046bffe 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -43,10 +43,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   bool GetMimeType(std::string* mime_type) const override;
   void SetExtraRequestHeaders(const HttpRequestHeaders& headers) override;
 
-  // An interface for subclasses who wish to monitor read operations.
-  virtual void OnSeekComplete(int64 result);
-  virtual void OnReadComplete(net::IOBuffer* buf, int result);
-
  protected:
   ~URLRequestMmtJob() override;
 
-- 
1.7.9.5


From 9db8aa65f97993cd6e1022f01c3fd934b87c398c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 09:07:06 -0800
Subject: [PATCH 012/128] save 1

---
 net/url_request/url_request_mmt_job.cc |   41 ++++++++++++++++++++++++++++++++
 net/url_request/url_request_mmt_job.h  |   11 +++++++++
 2 files changed, 52 insertions(+)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3e01eca..0eb13a1 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -39,6 +39,13 @@ URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
       is_directory(false) {
 }
 
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
+    : read_offset(0),
+      remaining_bytes(0),
+      dest(nullptr),
+      dest_size(0) {
+}
+
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
@@ -52,6 +59,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
+  read_info_.file_path = file_path_;
   FileMetaInfo* meta_info = new FileMetaInfo();
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -86,15 +94,32 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
+#if 0
   int rv = stream_->Read(dest,
                          dest_size,
                          base::Bind(&URLRequestMmtJob::DidRead,
                                     weak_ptr_factory_.GetWeakPtr(),
                                     make_scoped_refptr(dest)));
+#endif
+  int rv = ERR_IO_PENDING;
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  read_info->file_path = read_info_.file_path;
+  read_info->read_offset = read_info_.read_offset;
+  read_info->dest = dest;
+  read_info->dest_size = dest_size;
+  mmt_task_runner_->PostTaskAndReply(
+      FROM_HERE,
+      base::Bind(&URLRequestMmtJob::DoRead, 
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidRead2,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
     remaining_bytes_ -= rv;
+    read_info_.remaining_bytes -= rv;
+    read_info_.read_offset += rv;
     DCHECK_GE(remaining_bytes_, 0);
     return true;
   }
@@ -108,6 +133,18 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
+  DidRead(read_info->dest, read_info->dest_size);
+}
+
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -208,6 +245,8 @@ void URLRequestMmtJob::DidOpen(int result) {
 
   remaining_bytes_ = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
+  read_info_.remaining_bytes = remaining_bytes_;
+  read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
   if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
@@ -248,6 +287,8 @@ void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     remaining_bytes_ -= result;
+    read_info_.remaining_bytes -= result;
+    read_info_.read_offset += result;
     DCHECK_GE(remaining_bytes_, 0);
   }
   buf = NULL;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 046bffe..82cc67f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -86,6 +86,16 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidSeek(int64 result);
 
   // Callback after data is asynchronously read from the file into |buf|.
+  struct ReadMetaInfo {
+    ReadMetaInfo();
+    int64 read_offset;
+    int64 remaining_bytes;
+    IOBuffer* dest;
+    int32 dest_size;
+    base::FilePath file_path;
+  };
+  static void DoRead(ReadMetaInfo* read_info);
+  void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
   scoped_ptr<FileStream> stream_;
@@ -94,6 +104,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
   HttpByteRange byte_range_;
   int64 remaining_bytes_;
+  ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 476f6960e893cb2485861d2c4e9b23a314653228 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 22:53:52 -0800
Subject: [PATCH 013/128] [ok] for async read

---
 net/url_request/url_request_mmt_job.cc |  117 +++++++-------------------------
 net/url_request/url_request_mmt_job.h  |   37 ++--------
 2 files changed, 29 insertions(+), 125 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0eb13a1..c0c35e2 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -32,15 +32,12 @@
 
 namespace net {
 
-URLRequestMmtJob::FileMetaInfo::FileMetaInfo()
-    : file_size(0),
-      mime_type_result(false),
-      file_exists(false),
-      is_directory(false) {
-}
-
+// TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : read_offset(0),
+    : is_started(false),
+      handle(nullptr),
+      total_size(0),
+      read_offset(0),
       remaining_bytes(0),
       dest(nullptr),
       dest_size(0) {
@@ -51,7 +48,6 @@ URLRequestMmtJob::URLRequestMmtJob(
     NetworkDelegate* network_delegate,
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
-      stream_(new FileStream(mmt_task_runner)),
       mmt_task_runner_(mmt_task_runner),
       remaining_bytes_(0),
       weak_ptr_factory_(this) {
@@ -60,18 +56,20 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   FileURLToFilePath(request_->url(), &file_path_);
   read_info_.file_path = file_path_;
-  FileMetaInfo* meta_info = new FileMetaInfo();
+  ReadMetaInfo* read_info = new ReadMetaInfo;
+  *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
-      base::Bind(&URLRequestMmtJob::FetchMetaInfo, file_path_,
-                 base::Unretained(meta_info)),
-      base::Bind(&URLRequestMmtJob::DidFetchMetaInfo,
+      base::Bind(&URLRequestMmtJob::DoStart,
+                 base::Unretained(read_info)),
+      base::Bind(&URLRequestMmtJob::DidStart,
                  weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(meta_info)));
+                 base::Owned(read_info)));
 }
 
 void URLRequestMmtJob::Kill() {
-  stream_.reset();
+  if (read_info_.handle) fclose((FILE*)read_info_.handle);
+  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -94,17 +92,9 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-#if 0
-  int rv = stream_->Read(dest,
-                         dest_size,
-                         base::Bind(&URLRequestMmtJob::DidRead,
-                                    weak_ptr_factory_.GetWeakPtr(),
-                                    make_scoped_refptr(dest)));
-#endif
   int rv = ERR_IO_PENDING;
   ReadMetaInfo* read_info = new ReadMetaInfo;
-  read_info->file_path = read_info_.file_path;
-  read_info->read_offset = read_info_.read_offset;
+  *read_info = read_info_;
   read_info->dest = dest;
   read_info->dest_size = dest_size;
   mmt_task_runner_->PostTaskAndReply(
@@ -134,7 +124,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = base::OpenFile(read_info->file_path, "rb");
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
   if (fp) {
     fseek(fp, read_info->read_offset, SEEK_SET);
     read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
@@ -183,48 +173,19 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      FileMetaInfo* meta_info) {
-  base::File::Info file_info;
-  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-  if (meta_info->file_exists) {
-    meta_info->file_size = file_info.size;
-    meta_info->is_directory = file_info.is_directory;
-  }
-  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
-  // done in WorkerPool.
-  meta_info->mime_type_result = GetMimeTypeFromFile(file_path,
-                                                    &meta_info->mime_type);
+void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
+  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
-void URLRequestMmtJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-
-  // We use URLRequestMmtJob to handle files as well as directories without
-  // trailing slash.
-  // If a directory does not exist, we return ERR_FILE_NOT_FOUND. Otherwise,
-  // we will append trailing slash and redirect to FileDirJob.
-  // A special case is "\" on Windows. We should resolve as invalid.
-  // However, Windows resolves "\" to "C:\", thus reports it as existent.
-  // So what happens is we append it with trailing slash and redirect it to
-  // FileDirJob where it is resolved as invalid.
-  if (!meta_info_.file_exists) {
+void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  read_info_ = *read_info;
+
+  if (!read_info_.is_started) {
     DidOpen(ERR_FILE_NOT_FOUND);
     return;
   }
-  if (meta_info_.is_directory) {
-    DidOpen(OK);
-    return;
-  }
-
-  int flags = base::File::FLAG_OPEN |
-              base::File::FLAG_READ |
-              base::File::FLAG_ASYNC;
-  int rv = stream_->Open(file_path_, flags,
-                         base::Bind(&URLRequestMmtJob::DidOpen,
-                                    weak_ptr_factory_.GetWeakPtr()));
-  if (rv != ERR_IO_PENDING)
-    DidOpen(rv);
+  DidOpen(OK);
 }
 
 void URLRequestMmtJob::DidOpen(int result) {
@@ -237,7 +198,7 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+  if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
     return;
@@ -249,36 +210,6 @@ void URLRequestMmtJob::DidOpen(int result) {
   read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(remaining_bytes_, 0);
 
-  if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
-    // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
-    tracked_objects::ScopedTracker tracking_profile1(
-        FROM_HERE_WITH_EXPLICIT_FUNCTION(
-            "423948 URLRequestMmtJob::DidOpen 1"));
-
-    int rv = stream_->Seek(base::File::FROM_BEGIN,
-                           byte_range_.first_byte_position(),
-                           base::Bind(&URLRequestMmtJob::DidSeek,
-                                      weak_ptr_factory_.GetWeakPtr()));
-    if (rv != ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(byte_range_.first_byte_position());
-  }
-}
-
-void URLRequestMmtJob::DidSeek(int64 result) {
-  if (result != byte_range_.first_byte_position()) {
-    NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
-                                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-
   set_expected_content_size(remaining_bytes_);
   NotifyHeadersComplete();
 }
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 82cc67f..50cf98f 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -52,54 +52,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   base::FilePath file_path_;
 
  private:
-  // Meta information about the file. It's used as a member in the
-  // URLRequestMmtJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    FileMetaInfo();
-
-    // Size of the file.
-    int64 file_size;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result;
-    // Flag showing whether the file exists.
-    bool file_exists;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory;
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
   // Callback after opening file on a background thread.
   void DidOpen(int result);
 
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64 result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
+    bool is_started;
+    void* handle;
+    int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+  static void DoStart(ReadMetaInfo* read_info);
+  void DidStart(ReadMetaInfo* read_info);
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead2(ReadMetaInfo* read_info);
   void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
 
-  scoped_ptr<FileStream> stream_;
-  FileMetaInfo meta_info_;
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-- 
1.7.9.5


From c998a008a6dd587dac8c808247690530213e3a95 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 6 Jan 2015 23:08:50 -0800
Subject: [PATCH 014/128] [ok] refine base on 476f696

---
 net/url_request/url_request_mmt_job.cc |   69 +++++++++++++-------------------
 net/url_request/url_request_mmt_job.h  |   17 +++-----
 2 files changed, 32 insertions(+), 54 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index c0c35e2..2537c62 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -35,7 +35,6 @@ namespace net {
 // TODO implement ReadMetaInfo as one scope refptr
 URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
     : is_started(false),
-      handle(nullptr),
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -49,13 +48,11 @@ URLRequestMmtJob::URLRequestMmtJob(
     const scoped_refptr<base::TaskRunner>& mmt_task_runner)
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
-      remaining_bytes_(0),
       weak_ptr_factory_(this) {
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &file_path_);
-  read_info_.file_path = file_path_;
+  FileURLToFilePath(request_->url(), &read_info_.file_path);
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -68,8 +65,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  if (read_info_.handle) fclose((FILE*)read_info_.handle);
-  read_info_.handle = NULL;
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -80,12 +75,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
                                     int* bytes_read) {
   DCHECK_NE(dest_size, 0);
   DCHECK(bytes_read);
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
+  if (read_info_.remaining_bytes < dest_size)
+    dest_size = static_cast<int>(read_info_.remaining_bytes);
 
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // If we should copy zero bytes because |remaining_bytes| is zero, short
   // circuit here.
   if (!dest_size) {
     *bytes_read = 0;
@@ -101,16 +96,15 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoRead, 
                  base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead2,
+      base::Bind(&URLRequestMmtJob::DidRead,
                  weak_ptr_factory_.GetWeakPtr(),
                  base::Owned(read_info)));
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
-    remaining_bytes_ -= rv;
     read_info_.remaining_bytes -= rv;
     read_info_.read_offset += rv;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
     return true;
   }
 
@@ -123,18 +117,6 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   return false;
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
-  }
-}
-void URLRequestMmtJob::DidRead2(ReadMetaInfo* read_info) {
-  DidRead(read_info->dest, read_info->dest_size);
-}
-
 bool URLRequestMmtJob::IsRedirectResponse(GURL* location,
                                            int* http_status_code) {
   return false;
@@ -146,7 +128,8 @@ Filter* URLRequestMmtJob::SetupFilter() const {
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  return false;
+  *mime_type = std::string("text/html");
+  return true;
 }
 
 void URLRequestMmtJob::SetExtraRequestHeaders(
@@ -175,23 +158,18 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
   read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
-  //read_info->handle = (void *)base::OpenFile(read_info->file_path, "rb");
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+  int result = OK;
   read_info_ = *read_info;
-
   if (!read_info_.is_started) {
-    DidOpen(ERR_FILE_NOT_FOUND);
-    return;
+    result = ERR_FAILED;
   }
-  DidOpen(OK);
-}
 
-void URLRequestMmtJob::DidOpen(int result) {
   // TODO(vadimt): Remove ScopedTracker below once crbug.com/423948 is fixed.
   tracked_objects::ScopedTracker tracking_profile(
-      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidOpen"));
+      FROM_HERE_WITH_EXPLICIT_FUNCTION("423948 URLRequestMmtJob::DidStart"));
 
   if (result != OK) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
@@ -204,25 +182,32 @@ void URLRequestMmtJob::DidOpen(int result) {
     return;
   }
 
-  remaining_bytes_ = byte_range_.last_byte_position() -
+  read_info_.remaining_bytes = byte_range_.last_byte_position() -
                      byte_range_.first_byte_position() + 1;
-  read_info_.remaining_bytes = remaining_bytes_;
   read_info_.read_offset = byte_range_.first_byte_position();
-  DCHECK_GE(remaining_bytes_, 0);
+  DCHECK_GE(read_info_.remaining_bytes, 0);
 
-  set_expected_content_size(remaining_bytes_);
+  set_expected_content_size(read_info_.remaining_bytes);
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
+  if (fp) {
+    fseek(fp, read_info->read_offset, SEEK_SET);
+    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
+    fclose(fp);
+  }
+}
+
+void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
+  int result = read_info->dest_size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-    remaining_bytes_ -= result;
     read_info_.remaining_bytes -= result;
     read_info_.read_offset += result;
-    DCHECK_GE(remaining_bytes_, 0);
+    DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  buf = NULL;
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 50cf98f..15e7600 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -46,37 +46,30 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
  protected:
   ~URLRequestMmtJob() override;
 
-  int64 remaining_bytes() const { return remaining_bytes_; }
-
-  // The OS-specific full path name of the file
-  base::FilePath file_path_;
-
  private:
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
-
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
     bool is_started;
-    void* handle;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
+
     IOBuffer* dest;
     int32 dest_size;
     base::FilePath file_path;
   };
+
   static void DoStart(ReadMetaInfo* read_info);
   void DidStart(ReadMetaInfo* read_info);
+
   static void DoRead(ReadMetaInfo* read_info);
-  void DidRead2(ReadMetaInfo* read_info);
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+  void DidRead(ReadMetaInfo* read_info);
 
+ private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
-  int64 remaining_bytes_;
   ReadMetaInfo read_info_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
-- 
1.7.9.5


From 3301a59dd29064a4c664bb210f1250b7d43bb2b9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:10:18 -0800
Subject: [PATCH 015/128] prepare to use mmt stream

---
 net/url_request/url_request_mmt_job.cc |   20 +++++++++++++-------
 net/url_request/url_request_mmt_job.h  |    3 ++-
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 2537c62..59ce61d 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -52,7 +53,9 @@ URLRequestMmtJob::URLRequestMmtJob(
 }
 
 void URLRequestMmtJob::Start() {
-  FileURLToFilePath(request_->url(), &read_info_.file_path);
+  base::FilePath file_path;
+  FileURLToFilePath(request_->url(), &file_path);
+  read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
   mmt_task_runner_->PostTaskAndReply(
@@ -157,7 +160,8 @@ URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
 void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(read_info->file_path, &read_info->total_size);
+  read_info->is_started = base::GetFileSize(
+    base::FilePath(read_info->uri), &read_info->total_size);
 }
 
 void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
@@ -192,12 +196,14 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  FILE *fp = (FILE *)base::OpenFile(read_info->file_path, "rb");
-  if (fp) {
-    fseek(fp, read_info->read_offset, SEEK_SET);
-    read_info->dest_size = fread(read_info->dest->data(), 1, read_info->dest_size, fp);
-    fclose(fp);
+#if 0
+  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
+  if (stream) {
+    read_info->dest_size = stream->Read(read_info->dest->data(), 
+                                      read_info->dest_size, 
+                                      read_info->read_offset);
   }
+#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 15e7600..227cf51 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,6 +7,7 @@
 
 #include <string>
 #include <vector>
+#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
@@ -57,7 +58,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    base::FilePath file_path;
+    std::string uri;
   };
 
   static void DoStart(ReadMetaInfo* read_info);
-- 
1.7.9.5


From 5419132e1312ea615b586cd218280c46b53869fe Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:41:53 -0800
Subject: [PATCH 016/128] add net/mmt module

---
 net/mmt/mmt_stream.cc                 |   40 ++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                  |   51 +++++++++++++++++++++++++++++++++
 net/net.gypi                          |    1 +
 net/url_request/url_request_mmt_job.h |    1 -
 4 files changed, 92 insertions(+), 1 deletion(-)
 create mode 100644 net/mmt/mmt_stream.cc
 create mode 100644 net/mmt/mmt_stream.h

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
new file mode 100644
index 0000000..28c19d8
--- /dev/null
+++ b/net/mmt/mmt_stream.cc
@@ -0,0 +1,40 @@
+#include "net/mmt/mmt_stream.h"
+
+namespace mmt {
+
+Stream::Stream(const std::string &uri) 
+    : uri_(uri), file_(nullptr) { 
+}
+
+Stream::~Stream() {
+}
+
+std::string Stream::getUri() {
+  return uri_;
+}
+
+int Stream::Read(char *buf, int size, int offset) {
+  return 0; 
+}
+
+StreamPool* StreamPool::ginst_ = nullptr;
+
+StreamPool::StreamPool() {
+}
+StreamPool::~StreamPool() {
+}
+
+StreamPtr StreamPool::getStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter == streams_.end()) {
+        return nullptr;
+    }
+    return iter->second;
+}
+
+StreamPtr StreamPool::addStream(std::string &uri) {
+    StreamPtr stream = getStream(uri);
+    return stream;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
new file mode 100644
index 0000000..d4761cf
--- /dev/null
+++ b/net/mmt/mmt_stream.h
@@ -0,0 +1,51 @@
+#ifndef NET_MMT_MMT_STREAM_H_
+#define NET_MMT_MMT_STREAM_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+
+namespace mmt {
+
+class Stream : public base::RefCounted<Stream> {
+public:
+    friend class StreamPool;
+    Stream(const std::string &uri);
+    std::string getUri();
+    int Read(char *buf, int size, int offset);
+
+protected:
+    virtual ~Stream();
+
+private:
+    std::string uri_;
+    FILE *file_;
+};
+
+//typedef scoped_refptr<Stream> StreamPtr;
+typedef Stream* StreamPtr;
+typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::map<std::string, StreamPtr>  streams_t;
+
+class StreamPool {
+public:
+    StreamPool();
+    ~StreamPool();
+
+    StreamPtr getStream(std::string &uri);
+    StreamPtr addStream(std::string &uri);
+    static StreamPool *inst();
+
+protected:
+    static StreamPool *ginst_; 
+
+private:
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+#endif
diff --git a/net/net.gypi b/net/net.gypi
index ad08a23..cc6c1b2 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,6 +700,7 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
+      'mmt/mmt_stream.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 227cf51..3488cee 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -7,7 +7,6 @@
 
 #include <string>
 #include <vector>
-#include <map>
 
 #include "base/files/file_path.h"
 #include "base/memory/ref_counted.h"
-- 
1.7.9.5


From f35f026c2661c87da64c55512453e856b79a57ba Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 05:58:49 -0800
Subject: [PATCH 017/128] fix for compile

---
 net/mmt/mmt_stream.cc                  |   40 ++++++++++++++++++++++++++++++--
 net/mmt/mmt_stream.h                   |   14 +++++++----
 net/url_request/url_request_mmt_job.cc |    8 +++----
 3 files changed, 52 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 28c19d8..66e074f 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -7,16 +7,34 @@ Stream::Stream(const std::string &uri)
 }
 
 Stream::~Stream() {
+    Uninit();
 }
 
 std::string Stream::getUri() {
-  return uri_;
+    return uri_;
+}
+
+bool Stream::Init() {
+    if (file_) return true;
+    file_ = fopen(uri_.c_str(), "rb");
+    if (file_) return true;
+    return true;
 }
 
 int Stream::Read(char *buf, int size, int offset) {
-  return 0; 
+    if (!Init()) return -1;
+    fseek(file_, offset, SEEK_SET);
+    int iret = fread(buf, 1, size, file_);
+    return iret; 
+}
+
+void Stream::Uninit() {
+    LOG(INFO) << "Stream::Uninit";
+    if (file_) fclose(file_);
+    file_ = nullptr;
 }
 
+
 StreamPool* StreamPool::ginst_ = nullptr;
 
 StreamPool::StreamPool() {
@@ -34,7 +52,25 @@ StreamPtr StreamPool::getStream(std::string &uri) {
 
 StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
+    if (!stream.get()) {
+        stream = new Stream(uri);
+        streams_.insert(pair_t(uri, stream));
+    }
     return stream;
 }
 
+void StreamPool::delStream(std::string &uri) {
+    streams_t::iterator iter = streams_.find(uri);
+    if (iter != streams_.end()) {
+        streams_.erase(iter);
+    }
+}
+ 
+StreamPool *StreamPool::inst() {
+    if (!ginst_) {
+        ginst_ = new StreamPool;
+    }
+    return ginst_;
+}
+
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d4761cf..b8ba20b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -5,6 +5,7 @@
 #include <string>
 #include <vector>
 
+#include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 
@@ -12,21 +13,24 @@ namespace mmt {
 
 class Stream : public base::RefCounted<Stream> {
 public:
-    friend class StreamPool;
-    Stream(const std::string &uri);
+    explicit Stream(const std::string &uri);
     std::string getUri();
+    bool Init();
     int Read(char *buf, int size, int offset);
+    void Uninit();
 
 protected:
+    friend class base::RefCounted<Stream>;
     virtual ~Stream();
 
 private:
     std::string uri_;
     FILE *file_;
+
+    DISALLOW_COPY_AND_ASSIGN(Stream);
 };
 
-//typedef scoped_refptr<Stream> StreamPtr;
-typedef Stream* StreamPtr;
+typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
@@ -37,6 +41,8 @@ public:
 
     StreamPtr getStream(std::string &uri);
     StreamPtr addStream(std::string &uri);
+    void delStream(std::string &uri);
+
     static StreamPool *inst();
 
 protected:
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 59ce61d..05611a0 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -30,6 +30,7 @@
 #include "base/win/shortcut.h"
 #endif
 
+#include "net/mmt/mmt_stream.h"
 
 namespace net {
 
@@ -68,6 +69,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -196,14 +198,12 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-#if 0
-  MmtStreamPtr stream = MmtStreamPool::addStream(read_info->uri);
-  if (stream) {
+  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
+  if (stream.get()) {
     read_info->dest_size = stream->Read(read_info->dest->data(), 
                                       read_info->dest_size, 
                                       read_info->read_offset);
   }
-#endif
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-- 
1.7.9.5


From 1e6109a0a81a10ae15836801f854c4991dac4ec7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 7 Jan 2015 06:51:25 -0800
Subject: [PATCH 018/128] [ok] add lock to proctection

---
 net/mmt/mmt_stream.cc |   20 +++++++++++++++++++-
 net/mmt/mmt_stream.h  |    3 +++
 2 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 66e074f..5a75700 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,6 +4,7 @@ namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
+    LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
 }
 
 Stream::~Stream() {
@@ -18,6 +19,14 @@ bool Stream::Init() {
     if (file_) return true;
     file_ = fopen(uri_.c_str(), "rb");
     if (file_) return true;
+    return false;
+}
+
+bool Stream::Prepare(int64 *size) {
+    if (!Init()) return false;
+    fseek(file_, 0L, SEEK_END);
+    int64 lret = ftell(file_);
+    *size = lret;
     return true;
 }
 
@@ -29,7 +38,7 @@ int Stream::Read(char *buf, int size, int offset) {
 }
 
 void Stream::Uninit() {
-    LOG(INFO) << "Stream::Uninit";
+    LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     if (file_) fclose(file_);
     file_ = nullptr;
 }
@@ -43,10 +52,13 @@ StreamPool::~StreamPool() {
 }
 
 StreamPtr StreamPool::getStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter == streams_.end()) {
+        lock_.Release();
         return nullptr;
     }
+    lock_.Release();
     return iter->second;
 }
 
@@ -54,16 +66,22 @@ StreamPtr StreamPool::addStream(std::string &uri) {
     StreamPtr stream = getStream(uri);
     if (!stream.get()) {
         stream = new Stream(uri);
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
+        lock_.Acquire();
         streams_.insert(pair_t(uri, stream));
+        lock_.Release();
+        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
     }
     return stream;
 }
 
 void StreamPool::delStream(std::string &uri) {
+    lock_.Acquire();
     streams_t::iterator iter = streams_.find(uri);
     if (iter != streams_.end()) {
         streams_.erase(iter);
     }
+    lock_.Release();
 }
  
 StreamPool *StreamPool::inst() {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b8ba20b..0d5e6eb 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -8,6 +8,7 @@
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
+#include "base/synchronization/lock.h"
 
 namespace mmt {
 
@@ -16,6 +17,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
+    bool Prepare(int64 *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
@@ -50,6 +52,7 @@ protected:
 
 private:
     streams_t streams_;
+    base::Lock lock_;
 };
 
 } // namespace mmt
-- 
1.7.9.5


From c50f50a14b7cab3b699306a95c39c0ae505a4d35 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 12 Jan 2015 06:55:46 -0800
Subject: [PATCH 019/128] how to get web_contents from internal

---
 net/mmt/mmt_stream.cc                  |   96 ++++++++++++++++++++++++++++++++
 net/mmt/mmt_stream.h                   |   13 +++++
 net/net.gyp                            |    4 ++
 net/url_request/url_request_mmt_job.cc |   11 ++++
 net/url_request/url_request_mmt_job.h  |    5 ++
 5 files changed, 129 insertions(+)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5a75700..e0dac96 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,7 +1,103 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/resource_context.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/common/content_client.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+
+using namespace content;
+
 namespace mmt {
 
+#if 0
+    //content::ResourceContext* rcontext = rinfo->GetContext();
+    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
+    //content::RenderThread::Get()->Send(message);
+    //ContentClient* client = GetContentClient();
+    //ContentBrowserClient* browser = client->browser();
+#endif
+
+bool GetRequestID(const net::URLRequest* request, Content* content) {
+    LOG(INFO) << __func__;
+    if (!content) return false;
+
+    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
+    }
+
+    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    if (is_ok) {
+        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
+            << ", render_frame_id: " << content->frame_id;
+    }
+
+    return is_ok;
+}
+
+static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
+    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
+    if (rfh) {
+        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+    }
+    return rfh;
+}
+
+#if 0
+static RenderView* Get_RenderView(int routing_id) {
+    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    if (rv) {
+        blink::WebView* web_view = rv->GetWebView();
+        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
+    }
+    return rv;
+}
+#endif
+
+static void Post_Fullscreen(int process_id, int frame_id) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    if (rfh) {
+        rfh = nullptr;
+    }
+}
+
+void PostTask(int msg_type, const Content* content) {
+    if (content) {
+        Post_Fullscreen(content->process_id, content->frame_id);
+    }
+}
+
+#if 0
+void Run_Javascript(const string js) {
+    // => RenderFrame
+    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        //content::ResourceContext* rcontext = rinfo->GetContext();
+        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
+            << ", frame id: " << rinfo->GetRenderFrameID();
+        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
+            js,
+            rinfo->GetRouteID(), 
+            false);
+        content::RenderThread::Get()->Send(message);
+    }
+}
+#endif
+
+
+///======================
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0d5e6eb..0ba5b97 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,8 +10,21 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+namespace net {
+class URLRequest;
+}
+
 namespace mmt {
 
+struct Content {
+    int process_id;
+    int frame_id;
+    int routing_id;
+};
+
+bool GetRequestID(const net::URLRequest* request, Content* content);
+void PostTask(int msg_type, const Content* content);
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/net.gyp b/net/net.gyp
index eb27320..242582f 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -101,6 +101,10 @@
         '<@(net_nacl_common_sources)',
         '<@(net_non_nacl_sources)',
       ],
+      'include_dirs': [
+         '../skia/config',
+         '../third_party/skia/include/core',
+      ],
       'defines': [
         'NET_IMPLEMENTATION',
       ],
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 05611a0..3437a6e 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,6 +31,7 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
+#include "content/public/browser/browser_thread.h"
 
 namespace net {
 
@@ -51,6 +52,8 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::GetRequestID(request_, &content_);
+  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -59,6 +62,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
       base::Bind(&URLRequestMmtJob::DoStart,
@@ -224,4 +228,11 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+}
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 3488cee..468db82 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,6 +15,7 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+#include "net/mmt/mmt_stream.h"
 
 namespace base {
 class TaskRunner;
@@ -66,11 +67,15 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
 
+  static void DoTest(void* ptr);
+  void DidTest(void* ptr);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
+  mmt::Content content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 491388d5953265f11bd2504c64cdb7e29f7cf986 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 06:16:27 -0800
Subject: [PATCH 020/128] try on for web_contents

---
 net/mmt/mmt_stream.cc                  |  118 +++++++++++++++++++++++++++++---
 net/mmt/mmt_stream.h                   |   10 +++
 net/url_request/url_request_mmt_job.cc |    3 +
 3 files changed, 121 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e0dac96..7572ae2 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,17 +1,24 @@
 #include "net/mmt/mmt_stream.h"
 
+#include "content/public/browser/browser_thread.h"
 #include "content/public/browser/resource_request_info.h"
 #include "content/public/browser/resource_context.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/web_contents.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
+#include "content/public/browser/render_view_host.h"
+
 #include "content/public/common/content_client.h"
-#include "content/public/browser/browser_thread.h"
 #include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
 
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
+
 using namespace content;
 
 namespace mmt {
@@ -41,6 +48,13 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
             << ", render_frame_id: " << content->frame_id;
     }
 
+    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
+        << ", frame id=" << rinfo->GetRenderFrameID()
+        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
+        << ", is main frame=" << rinfo->IsMainFrame()
+        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
+        << "";
+
     return is_ok;
 }
 
@@ -48,14 +62,17 @@ static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
     if (rfh) {
         WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents;
+        RenderViewHost* rvh = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
+        contents = nullptr;
+        rvh = nullptr;
     }
     return rfh;
 }
 
 #if 0
 static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderView::FromRoutingID(routing_id);
+    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
     if (rv) {
         blink::WebView* web_view = rv->GetWebView();
         LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
@@ -64,17 +81,93 @@ static RenderView* Get_RenderView(int routing_id) {
 }
 #endif
 
-static void Post_Fullscreen(int process_id, int frame_id) {
+void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(process_id, frame_id);
+    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
+    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
+    LOG(INFO) << __func__ << " rfh=" << rfh;
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+
+    if (rfh) {
+        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
+        content::WebUI* webui = web_contents->GetWebUI();
+        LOG(INFO) << __func__ << " webui=" << webui;
+
+        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view1=" << render_view1;
+        if (render_view1) {
+            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
+            LOG(INFO) << __func__ << " view1=" << view1;
+        }
+
+        WebContentsDelegate* delegate = web_contents->GetDelegate();
+        LOG(INFO) << __func__ << " delegate=" << delegate;
+
+        RenderFrameHost* main_frame = web_contents->GetMainFrame();
+        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
+        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
+        RenderViewHost* main_view = main_frame->GetRenderViewHost();
+        LOG(INFO) << __func__ << " main_view=" << main_view;
+        if (main_view) {
+            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
+            LOG(INFO) << __func__ << " view=" << view;
+        }
+
+        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
+        LOG(INFO) << __func__ << " browser_context=" << browser_context;
+
+        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
+        LOG(INFO) << __func__ << " render_view2=" << render_view2;
+        if (render_view2) {
+            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
+            LOG(INFO) << __func__ << " view2=" << view2;
+        }
+
+        GURL url = web_contents->GetURL();
+        LOG(INFO) << __func__ << " url=" << url;
+
+        js = "console.log(document.getElementById(\"Video1\"));";
+        LOG(INFO) << __func__ << " js=" << js;
+        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+
+        std::string css = "<style>"
+            "body{"
+                "font-family: Verdana, Cursor;"
+                "font-size: 10px;"
+                "font-weight: bold;"
+            "}"
+            "</style>";
+        web_contents->InsertCSS(css);
+
+        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
+        //web_contents->ViewSource();
+        LOG(INFO) << __func__ << " END";
+    }
+}
+
+void Do_Fullscreen(const Content* content) {
+    LOG(INFO) << __func__;
+    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     if (rfh) {
         rfh = nullptr;
     }
 }
 
 void PostTask(int msg_type, const Content* content) {
-    if (content) {
-        Post_Fullscreen(content->process_id, content->frame_id);
+    switch(msg_type) {
+    case Msg_RunJavaScript:
+        static bool _brun = false;
+        if (content && !_brun) {
+            _brun = true;
+            Do_JavaScript(content, content->data);
+        }
+        break;
     }
 }
 
@@ -95,8 +188,13 @@ void Run_Javascript(const string js) {
 }
 #endif
 
+} // namespace mmt
 
-///======================
+
+///===============================
+/// for class Stream and StreamPool
+
+namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 0ba5b97..2c937d3 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,15 +16,25 @@ class URLRequest;
 
 namespace mmt {
 
+enum {
+    Msg_RunJavaScript,
+};
+
 struct Content {
     int process_id;
     int frame_id;
     int routing_id;
+    std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
 
+} // namespace mmt
+
+
+namespace mmt {
+
 class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const std::string &uri);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 3437a6e..cdbd903 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
   DoTest((void*)&content_);
 }
 
@@ -62,6 +63,7 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
+  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -232,6 +234,7 @@ void URLRequestMmtJob::DoTest(void* ptr) {
     content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
                           base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 }
+
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
-- 
1.7.9.5


From d39bf190e6c5de4cf2f7fefb2fdb796c47dc228a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 14 Jan 2015 16:48:22 -0800
Subject: [PATCH 021/128] add extension of cimsg

---
 .../docs/examples/api/cimsg/background.js          |   87 ++++++++++++
 .../docs/examples/api/cimsg/install_host.sh        |   40 ++++++
 .../docs/examples/api/cimsg/manifest.json          |   24 ++++
 .../docs/examples/api/cimsg/native-messaging-cimsg |  142 ++++++++++++++++++++
 .../examples/api/cimsg/org.chromium.cimsg.json     |   13 ++
 5 files changed, 306 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/background.js
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/manifest.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
 create mode 100644 chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
new file mode 100644
index 0000000..11a23b8
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -0,0 +1,87 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+var port = null;
+var tabid = -1;
+
+var getKeys = function(obj){
+  var keys = [];
+  for(var key in obj){
+    keys.push(key);
+  }
+  return keys;
+}
+
+function parseJSON(data) {
+  return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function("return " + data))(); 
+}
+
+function logMsg(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript({
+        code: js
+    });
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS({
+        code: css
+    });
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cimsg";
+  port = chrome.runtime.connectNative(hostName);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+
+/// events
+chrome.tabs.onCreated.addListener(function(tab) {
+});
+chrome.tabs.onActivated.addListener(function(info) {
+  //chrome.tabs.executeScript({file: "ci.js"});
+});
+chrome.browserAction.onClicked.addListener(function(tab) {
+  chrome.tabs.executeScript({
+    code: 'document.body.style.backgroundColor="red"'
+  });
+});
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
+    tabid = tab.id;
+    connect();
+  }
+});
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
new file mode 100755
index 0000000..da7105e
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cimsg
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cimsg
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
new file mode 100644
index 0000000..fea9000
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
@@ -0,0 +1,24 @@
+{
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
+    "name": "org.chromium.cimsg",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium native messaging for ci",
+    "permissions": [
+        "tabs",
+        "nativeMessaging",
+        "activeTab",
+        "notifications",
+        "http://*/",
+        "https://*/",
+        "file://*/",
+        "mmt://*/"
+    ],
+   "browser_action": {
+        "default_title": "Make this page red"
+    },
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    }
+}
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
new file mode 100755
index 0000000..b321a25
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -0,0 +1,142 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  try:
+    jdata = JSONDecoder().decode(message);
+    if not jdata: return
+  except:
+    return
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  sys.stdout.flush()
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.bind((host, port))
+  while True:
+    try:
+      msg, addr = sock.recvfrom(65536)
+      send_message(msg.strip())
+    except: 
+      break
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  pass
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
new file mode 100644
index 0000000..2118005
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cimsg",
+  "description": "Chromium Native Messaging For CI",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
-- 
1.7.9.5


From e604015ed16aaabe322aa0ca2ac86e07e4ca9e34 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 00:18:10 -0800
Subject: [PATCH 022/128] refine cimsg extension

---
 .../docs/examples/api/cimsg/background.js          |    1 -
 .../docs/examples/api/cimsg/native-messaging-cimsg |   31 +++++---
 net/mmt/mmt_stream.cc                              |   83 ++++++++------------
 net/mmt/mmt_stream.h                               |    1 +
 net/url_request/url_request_mmt_job.cc             |    9 +--
 5 files changed, 56 insertions(+), 69 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
index 11a23b8..daf7dd5 100644
--- a/chrome/common/extensions/docs/examples/api/cimsg/background.js
+++ b/chrome/common/extensions/docs/examples/api/cimsg/background.js
@@ -79,7 +79,6 @@ chrome.browserAction.onClicked.addListener(function(tab) {
 });
 chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
   if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
-    //logMsg("onUpdated tid=" + tid + " tab.id="+ tab.id + " uri=" + tab.url);
     tabid = tab.id;
     connect();
   }
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
index b321a25..05279a2 100755
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -10,6 +10,8 @@ import struct
 import sys
 import threading
 import Queue
+
+import time
 import socket
 from json import JSONDecoder
 
@@ -23,29 +25,36 @@ except ImportError:
 # Helper function that sends a message to the webapp.
 def send_message(message):
   # message must be JSON string
-  try:
-    jdata = JSONDecoder().decode(message);
-    if not jdata: return
-  except:
-    return
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
   # Write message size.
   sys.stdout.write(struct.pack('I', len(message)))
   # Write the message itself.
   sys.stdout.write(message)
-  sys.stdout.flush()
+  try:
+    sys.stdout.flush()
+  except: return
 
 # Thread that reads messages from control point
 def read_ctrl_func():
   host = "localhost"
   port = 54321
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   sock.bind((host, port))
   while True:
-    try:
-      msg, addr = sock.recvfrom(65536)
-      send_message(msg.strip())
-    except: 
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
       break
+    send_message(msg)
+  sock.close()
 
 # Thread that reads messages from the webapp.
 def read_thread_func(queue):
@@ -115,7 +124,7 @@ def Daemon():
   rthread.daemon = True
   rthread.start()
   read_ctrl_func()
-  pass
+  sys.exit(0)
 
 def Main():
   if not Tkinter:
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7572ae2..996b6a0 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -17,19 +17,41 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/threading/thread_restrictions.h"
+#include "net/udp/udp_socket.h"
+#include "net/base/io_buffer.h"
+#include "base/memory/ref_counted.h"
 
 
 using namespace content;
 
 namespace mmt {
 
-#if 0
-    //content::ResourceContext* rcontext = rinfo->GetContext();
-    //IPC::Message* message = new ViewHostMsg_ToggleFullscreen(rinfo->GetRouteID(), true);
-    //content::RenderThread::Get()->Send(message);
-    //ContentClient* client = GetContentClient();
-    //ContentBrowserClient* browser = client->browser();
-#endif
+void PostCtrl(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+}
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
@@ -58,32 +80,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-static RenderFrameHost* Get_RenderFrameHost(int process_id, int frame_id) {
-    RenderFrameHost* rfh = RenderFrameHost::FromID(process_id, frame_id);
-    if (rfh) {
-        WebContents* contents = WebContents::FromRenderFrameHost(rfh);
-        RenderViewHost* rvh = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " rfh=" << rfh << ", contents=" << contents << ", rvh=" << rvh;
-        contents = nullptr;
-        rvh = nullptr;
-    }
-    return rfh;
-}
-
-#if 0
-static RenderView* Get_RenderView(int routing_id) {
-    RenderView* rv = RenderViewHost::FromRoutingID(routing_id);
-    if (rv) {
-        blink::WebView* web_view = rv->GetWebView();
-        LOG(INFO) << __func__ << " rv=" << rv << ", web_view=" << web_view;
-    }
-    return rv;
-}
-#endif
-
 void Do_JavaScript(const Content* content, std::string js) {
     LOG(INFO) << __func__;
-    //RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
@@ -153,12 +151,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
 void Do_Fullscreen(const Content* content) {
     LOG(INFO) << __func__;
-    RenderFrameHost* rfh = Get_RenderFrameHost(content->process_id, content->frame_id);
-    if (rfh) {
-        rfh = nullptr;
-    }
 }
 
+//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
 void PostTask(int msg_type, const Content* content) {
     switch(msg_type) {
     case Msg_RunJavaScript:
@@ -171,23 +167,6 @@ void PostTask(int msg_type, const Content* content) {
     }
 }
 
-#if 0
-void Run_Javascript(const string js) {
-    // => RenderFrame
-    const content::ResourceRequestInfo* rinfo = content::ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        //content::ResourceContext* rcontext = rinfo->GetContext();
-        LOG(INFO) << __func__ << "routing ID: " << rinfo->GetRouteID()
-            << ", frame id: " << rinfo->GetRenderFrameID();
-        IPC::Message* message = new FrameMsg_JavaScriptExecuteRequest(
-            js,
-            rinfo->GetRouteID(), 
-            false);
-        content::RenderThread::Get()->Send(message);
-    }
-}
-#endif
-
 } // namespace mmt
 
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 2c937d3..4abe1d2 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -29,6 +29,7 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
+void PostCtrl(std::string msg);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index cdbd903..0a54267 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,8 +53,6 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
-  content_.data = "e = document.getElementById(\"Video1\"); alert(e);";
-  DoTest((void*)&content_);
 }
 
 void URLRequestMmtJob::Start() {
@@ -63,7 +61,6 @@ void URLRequestMmtJob::Start() {
   read_info_.uri = file_path.value();
   ReadMetaInfo* read_info = new ReadMetaInfo;
   *read_info = read_info_;
-  DoTest((void*)&content_);
 
   mmt_task_runner_->PostTaskAndReply(
       FROM_HERE,
@@ -228,11 +225,13 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
+
+  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
+  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
+    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From 94263660d2c90151eaf57ed68df115e6c73acc62 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 05:50:16 -0800
Subject: [PATCH 023/128] add ctrl center

---
 net/mmt/mmt_stream.cc                  |   87 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |    5 +-
 net/url_request/url_request_mmt_job.cc |    3 --
 3 files changed, 89 insertions(+), 6 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 996b6a0..7f7b98a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -16,16 +16,98 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
-#include "base/threading/thread_restrictions.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+
+#include "base/threading/thread_restrictions.h"
 #include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
 
 
 using namespace content;
 
 namespace mmt {
 
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        std::string head;
+        std::string body;
+    };
+
+    CtrlCenter() : SimpleThread("ctrlcenter"){}
+    virtual ~CtrlCenter() {}
+
+    virtual void Run() override {
+        running_ = true;
+        while(loop_) {
+            Message msg;
+            if (!Pop(msg)) {
+                Wait(500);
+                continue;
+            }
+
+            if (msg.head == "@ctrl") {
+                PostCtrl(msg.body);
+            }else if (msg.head == "@uri") {
+                std::string uri = msg.body;
+                StreamPtr stream = new Stream(uri);
+                streams_.insert(pair_t(uri, stream));
+            }
+            Wait(100);
+        };
+        running_ = false;
+    }
+
+    void Wait(int ms) {
+        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    }
+    void Reset() {
+        loop_ = true;
+    }
+    bool IsRunning() {
+        return running_;
+    }
+
+    bool Pop(Message &msg) {
+        if (queue_.empty())
+            return false;
+        lock_.Acquire();
+        msg = queue_.back();
+        queue_.pop_back();
+        lock_.Release();
+        return true;
+    }
+
+    void Push(Message &msg) {
+        lock_.Acquire();
+        queue_.insert(queue_.begin(), msg);
+        lock_.Release();
+    }
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+static CtrlCenter *gCenter = nullptr;
+
+void StartCtrlCenter() {
+    if (!gCenter) {
+        gCenter = new CtrlCenter;
+    }
+    if (gCenter->IsRunning()) {
+        return;
+    }
+    gCenter->Reset();
+    gCenter->Start();
+}
+
 void PostCtrl(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
@@ -37,6 +119,7 @@ void PostCtrl(std::string msg) {
     std::string szaddr = "127.0.0.1";
     net::IPAddressNumber ipnum;
     if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
         LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
         return;
     }
@@ -45,12 +128,14 @@ void PostCtrl(std::string msg) {
     struct sockaddr addr;
     socklen_t addrlen;
     if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
         LOG(INFO) << __func__ << " ToSockAddr failed";
         return;
     }
 
     int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
     LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
 }
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 4abe1d2..c574235 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -16,6 +16,9 @@ class URLRequest;
 
 namespace mmt {
 
+void StartCtrlCenter();
+void PostCtrl(std::string msg);
+
 enum {
     Msg_RunJavaScript,
 };
@@ -29,8 +32,6 @@ struct Content {
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
 void PostTask(int msg_type, const Content* content);
-void PostCtrl(std::string msg);
-
 } // namespace mmt
 
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0a54267..62e2a0b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -225,9 +225,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
   }
 
   NotifyReadComplete(result);
-
-  std::string szjs = "{\"js\":\"document.body.style.backgroundColor='red';\"";
-  DoTest((void *)szjs.c_str());
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-- 
1.7.9.5


From 9dc889f35c23920985fccce016609b431856b6ad Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 06:53:00 -0800
Subject: [PATCH 024/128] refine ctrl center 1

---
 net/mmt/mmt_stream.cc                  |  282 ++++++++++----------------------
 net/mmt/mmt_stream.h                   |   64 +++++---
 net/url_request/url_request_mmt_job.cc |   10 +-
 3 files changed, 135 insertions(+), 221 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 7f7b98a..6aa5855 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -12,6 +12,7 @@
 #include "content/public/renderer/render_thread.h"
 #include "content/public/renderer/render_frame.h"
 #include "content/public/renderer/render_view.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
@@ -19,84 +20,18 @@
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
 
-#include "base/threading/thread_restrictions.h"
-#include "base/memory/ref_counted.h"
-#include "base/threading/simple_thread.h"
-#include "base/synchronization/lock.h"
-#include "base/threading/platform_thread.h"
-#include "base/time/time.h"
-
 
 using namespace content;
 
 namespace mmt {
 
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        std::string head;
-        std::string body;
-    };
-
-    CtrlCenter() : SimpleThread("ctrlcenter"){}
-    virtual ~CtrlCenter() {}
-
-    virtual void Run() override {
-        running_ = true;
-        while(loop_) {
-            Message msg;
-            if (!Pop(msg)) {
-                Wait(500);
-                continue;
-            }
-
-            if (msg.head == "@ctrl") {
-                PostCtrl(msg.body);
-            }else if (msg.head == "@uri") {
-                std::string uri = msg.body;
-                StreamPtr stream = new Stream(uri);
-                streams_.insert(pair_t(uri, stream));
-            }
-            Wait(100);
-        };
-        running_ = false;
-    }
-
-    void Wait(int ms) {
-        base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
-    }
-    void Reset() {
-        loop_ = true;
-    }
-    bool IsRunning() {
-        return running_;
-    }
-
-    bool Pop(Message &msg) {
-        if (queue_.empty())
-            return false;
-        lock_.Acquire();
-        msg = queue_.back();
-        queue_.pop_back();
-        lock_.Release();
-        return true;
-    }
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+}
+void PostNativeMsg(std::string msg);
 
-    void Push(Message &msg) {
-        lock_.Acquire();
-        queue_.insert(queue_.begin(), msg);
-        lock_.Release();
-    }
 
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
 static CtrlCenter *gCenter = nullptr;
-
 void StartCtrlCenter() {
     if (!gCenter) {
         gCenter = new CtrlCenter;
@@ -108,7 +43,77 @@ void StartCtrlCenter() {
     gCenter->Start();
 }
 
-void PostCtrl(std::string msg) {
+void PostCtrlMsg(CtrlCenter::Message &msg) {
+    if (!gCenter) return;
+    gCenter->Push(msg);
+}
+
+CtrlCenter::Message::Message() {}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::~CtrlCenter() {}
+
+void CtrlCenter::Run() {
+    running_ = true;
+    while(loop_) {
+        Message msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        if (msg.head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (msg.head == "@open") {
+            std::string uri = msg.uri;
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(pair_t(uri, stream));
+            int64 size;
+            stream->Prepare(&size);
+            if (msg.func1) {
+                msg.func1(msg.thiz, size);
+            }
+        }else if (msg.head == "@read") {
+            std::string uri = msg.uri;
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                char* buf = new char[msg.size];
+                int iret = stream->Read(buf, msg.size, msg.offset);
+                if (iret > 0 && msg.func2) {
+                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                }
+                delete buf;
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+}
+
+void CtrlCenter::Reset() {
+    loop_ = true;
+}
+bool CtrlCenter::IsRunning() {
+    return running_;
+}
+
+bool CtrlCenter::Pop(Message &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void CtrlCenter::Push(Message &msg) {
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+void PostNativeMsg(std::string msg) {
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if(sock <= 0) {
         LOG(INFO) << __func__ << " Open failed sock=" << sock;
@@ -138,6 +143,11 @@ void PostCtrl(std::string msg) {
     close(sock);
 }
 
+} // namespace mmt
+
+
+namespace mmt {
+
 bool GetRequestID(const net::URLRequest* request, Content* content) {
     LOG(INFO) << __func__;
     if (!content) return false;
@@ -165,10 +175,8 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void Do_JavaScript(const Content* content, std::string js) {
-    LOG(INFO) << __func__;
+void GetRenderFrameInfo(Content* content) {
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
@@ -176,79 +184,10 @@ void Do_JavaScript(const Content* content, std::string js) {
 
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        content::WebUI* webui = web_contents->GetWebUI();
-        LOG(INFO) << __func__ << " webui=" << webui;
-
-        RenderViewHost* render_view1 = rfh->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view1=" << render_view1;
-        if (render_view1) {
-            RenderView* view1 = RenderView::FromRoutingID(render_view1->GetRoutingID());
-            LOG(INFO) << __func__ << " view1=" << view1;
-        }
-
-        WebContentsDelegate* delegate = web_contents->GetDelegate();
-        LOG(INFO) << __func__ << " delegate=" << delegate;
-
-        RenderFrameHost* main_frame = web_contents->GetMainFrame();
-        RenderFrameHost* focused_frame = web_contents->GetFocusedFrame();
-        LOG(INFO) << __func__ << " main_frame=" << main_frame << " focused_frame=" << focused_frame;
-        RenderViewHost* main_view = main_frame->GetRenderViewHost();
-        LOG(INFO) << __func__ << " main_view=" << main_view;
-        if (main_view) {
-            RenderView* view = RenderView::FromRoutingID(main_view->GetRoutingID());
-            LOG(INFO) << __func__ << " view=" << view;
-        }
-
-        content::BrowserContext* browser_context = web_contents->GetBrowserContext();
-        LOG(INFO) << __func__ << " browser_context=" << browser_context;
-
-        RenderViewHost* render_view2 = web_contents->GetRenderViewHost();
-        LOG(INFO) << __func__ << " render_view2=" << render_view2;
-        if (render_view2) {
-            RenderView* view2 = RenderView::FromRoutingID(render_view2->GetRoutingID());
-            LOG(INFO) << __func__ << " view2=" << view2;
+        if (web_contents) {
+            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+            content->url = web_contents->GetURL();
         }
-
-        GURL url = web_contents->GetURL();
-        LOG(INFO) << __func__ << " url=" << url;
-
-        js = "console.log(document.getElementById(\"Video1\"));";
-        LOG(INFO) << __func__ << " js=" << js;
-        main_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        focused_frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-
-        std::string css = "<style>"
-            "body{"
-                "font-family: Verdana, Cursor;"
-                "font-size: 10px;"
-                "font-weight: bold;"
-            "}"
-            "</style>";
-        web_contents->InsertCSS(css);
-
-        //frame->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //rfh->ExecuteJavaScript(base::ASCIIToUTF16(js.c_str()));
-        //web_contents->ViewSource();
-        LOG(INFO) << __func__ << " END";
-    }
-}
-
-void Do_Fullscreen(const Content* content) {
-    LOG(INFO) << __func__;
-}
-
-//content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-//                          base::Bind(&mmt::PostTask, 0, (mmt::Content *)ptr));
-void PostTask(int msg_type, const Content* content) {
-    switch(msg_type) {
-    case Msg_RunJavaScript:
-        static bool _brun = false;
-        if (content && !_brun) {
-            _brun = true;
-            Do_JavaScript(content, content->data);
-        }
-        break;
     }
 }
 
@@ -260,6 +199,9 @@ void PostTask(int msg_type, const Content* content) {
 
 namespace mmt {
 
+Content::Content() {
+}
+
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -301,52 +243,4 @@ void Stream::Uninit() {
     file_ = nullptr;
 }
 
-
-StreamPool* StreamPool::ginst_ = nullptr;
-
-StreamPool::StreamPool() {
-}
-StreamPool::~StreamPool() {
-}
-
-StreamPtr StreamPool::getStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter == streams_.end()) {
-        lock_.Release();
-        return nullptr;
-    }
-    lock_.Release();
-    return iter->second;
-}
-
-StreamPtr StreamPool::addStream(std::string &uri) {
-    StreamPtr stream = getStream(uri);
-    if (!stream.get()) {
-        stream = new Stream(uri);
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef1=" << stream->HasOneRef();
-        lock_.Acquire();
-        streams_.insert(pair_t(uri, stream));
-        lock_.Release();
-        LOG(INFO) << "StreamPool::addStream" << ", OneRef2=" << stream->HasOneRef();
-    }
-    return stream;
-}
-
-void StreamPool::delStream(std::string &uri) {
-    lock_.Acquire();
-    streams_t::iterator iter = streams_.find(uri);
-    if (iter != streams_.end()) {
-        streams_.erase(iter);
-    }
-    lock_.Release();
-}
- 
-StreamPool *StreamPool::inst() {
-    if (!ginst_) {
-        ginst_ = new StreamPool;
-    }
-    return ginst_;
-}
-
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c574235..f01bf95 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -10,28 +10,33 @@
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
+#include "base/threading/thread_restrictions.h"
+#include "base/memory/ref_counted.h"
+#include "base/threading/simple_thread.h"
+#include "base/synchronization/lock.h"
+#include "base/threading/platform_thread.h"
+#include "base/time/time.h"
+
+#include "url/gurl.h"
+
 namespace net {
 class URLRequest;
 }
 
 namespace mmt {
 
-void StartCtrlCenter();
-void PostCtrl(std::string msg);
-
-enum {
-    Msg_RunJavaScript,
-};
-
 struct Content {
+    Content();
     int process_id;
     int frame_id;
     int routing_id;
+    int tab_id;
+    GURL url;
     std::string data;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void PostTask(int msg_type, const Content* content);
+void GetRenderFrameInfo(Content* content);
 } // namespace mmt
 
 
@@ -61,25 +66,46 @@ typedef scoped_refptr<Stream> StreamPtr;
 typedef std::pair<std::string, StreamPtr> pair_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
-class StreamPool {
-public:
-    StreamPool();
-    ~StreamPool();
+} // namespace mmt
 
-    StreamPtr getStream(std::string &uri);
-    StreamPtr addStream(std::string &uri);
-    void delStream(std::string &uri);
 
-    static StreamPool *inst();
 
-protected:
-    static StreamPool *ginst_; 
+namespace mmt {
+
+class CtrlCenter : public base::SimpleThread {
+public:
+    struct Message {
+        Message();
+        std::string head;
+        std::string body;
+        std::string uri;
+        int   size;
+        int   offset;
+        void* thiz;
+        void (*func1)(void*, int);
+        void (*func2)(void*, unsigned char*, int);
+    };
+
+    CtrlCenter();
+    virtual ~CtrlCenter();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(Message &msg);
+    void Push(Message &msg);
 
 private:
-    streams_t streams_;
+    bool loop_;
+    bool running_;
+    std::vector<Message> queue_;
     base::Lock lock_;
+    streams_t streams_;
 };
 
+void StartCtrlCenter();
+void PostCtrlMsg(CtrlCenter::Message &msg);
+
 } // namespace mmt
 
 #endif
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 62e2a0b..484e885 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -53,6 +53,8 @@ URLRequestMmtJob::URLRequestMmtJob(
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
   mmt::GetRequestID(request_, &content_);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
@@ -72,7 +74,6 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::StreamPool::inst()->delStream(read_info_.uri);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -201,12 +202,6 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
-  mmt::StreamPtr stream = mmt::StreamPool::inst()->addStream(read_info->uri);
-  if (stream.get()) {
-    read_info->dest_size = stream->Read(read_info->dest->data(), 
-                                      read_info->dest_size, 
-                                      read_info->read_offset);
-  }
 }
 
 void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
@@ -228,7 +223,6 @@ void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
-    mmt::PostCtrl((char *)ptr);
 }
 
 void URLRequestMmtJob::DidTest(void* ptr) {
-- 
1.7.9.5


From f49992582f0ff00df30003dc978cd37e78f3eb9c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 08:24:21 -0800
Subject: [PATCH 025/128] refine ctrl center 2 [thread]

---
 net/mmt/mmt_stream.cc                  |   56 ++++++++++++++++++++++++--------
 net/mmt/mmt_stream.h                   |   16 ++++++---
 net/url_request/url_request_mmt_job.cc |   29 ++++++-----------
 net/url_request/url_request_mmt_job.h  |    4 +--
 4 files changed, 66 insertions(+), 39 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6aa5855..59be61b 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -19,6 +19,7 @@
 #include "base/files/file_util.h"
 #include "net/udp/udp_socket.h"
 #include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
 
 
 using namespace content;
@@ -26,7 +27,7 @@ using namespace content;
 namespace mmt {
 
 void Wait(int ms) {
-    base::PlatformThread::Sleep(base::TimeDelta::FromMillisecondsD(ms));
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
 void PostNativeMsg(std::string msg);
 
@@ -41,6 +42,7 @@ void StartCtrlCenter() {
     }
     gCenter->Reset();
     gCenter->Start();
+    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
 }
 
 void PostCtrlMsg(CtrlCenter::Message &msg) {
@@ -48,11 +50,33 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+
+#if 1
+    base::FilePath file_path;
+    net::FileURLToFilePath(gurl, &file_path);
+    msg.url = file_path.value();
+#else
+    std::ostringstream sstr;
+    sstr << gurl;
+    msg.url = sstr.str();
+#endif
+
+    PostCtrlMsg(msg);
+}
+
 CtrlCenter::Message::Message() {}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){}
+CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
+    running_ = false;
+}
 CtrlCenter::~CtrlCenter() {}
 
 void CtrlCenter::Run() {
+    LOG(INFO) << __func__ << " begin";
     running_ = true;
     while(loop_) {
         Message msg;
@@ -60,27 +84,28 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
+        LOG(INFO) << __func__ << " head=" << msg.head;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
-            std::string uri = msg.uri;
-            StreamPtr stream = new Stream(uri);
-            streams_.insert(pair_t(uri, stream));
-            int64 size;
+            std::string url = msg.url;
+            StreamPtr stream = new Stream(url);
+            streams_.insert(pair_t(url, stream));
+            int64 size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
-                msg.func1(msg.thiz, size);
+                msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@read") {
-            std::string uri = msg.uri;
-            streams_t::iterator iter = streams_.find(uri);
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 char* buf = new char[msg.size];
                 int iret = stream->Read(buf, msg.size, msg.offset);
-                if (iret > 0 && msg.func2) {
-                    msg.func2(msg.thiz, (unsigned char*)buf, iret);
+                if (msg.func2) {
+                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
                 }
                 delete buf;
             }
@@ -88,6 +113,7 @@ void CtrlCenter::Run() {
         Wait(100);
     };
     running_ = false;
+    LOG(INFO) << __func__ << " end";
 }
 
 void CtrlCenter::Reset() {
@@ -108,6 +134,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
+    LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -149,7 +176,6 @@ void PostNativeMsg(std::string msg) {
 namespace mmt {
 
 bool GetRequestID(const net::URLRequest* request, Content* content) {
-    LOG(INFO) << __func__;
     if (!content) return false;
 
     const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
@@ -186,7 +212,11 @@ void GetRenderFrameInfo(Content* content) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
             content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            content->url = web_contents->GetURL();
+            std::ostringstream sstr;
+            sstr << web_contents->GetURL();
+            content->tab_url = sstr.str();
+            LOG(INFO) << __func__ << " tab id=" << content->tab_id
+                << ", tab url=" << content->tab_url;
         }
     }
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index f01bf95..fc9fa5c 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -4,6 +4,7 @@
 #include <map>
 #include <string>
 #include <vector>
+#include <sstream>
 
 #include "base/logging.h"
 #include "base/memory/ref_counted.h"
@@ -31,7 +32,7 @@ struct Content {
     int frame_id;
     int routing_id;
     int tab_id;
-    GURL url;
+    std::string tab_url;
     std::string data;
 };
 
@@ -72,18 +73,22 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 
 namespace mmt {
 
+typedef void (*func1_t)(void*, int);
+typedef void (*func2_t)(void*, unsigned char*, int);
+
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
         std::string head;
         std::string body;
-        std::string uri;
+        std::string url;
+        int   tab_id;
         int   size;
         int   offset;
-        void* thiz;
-        void (*func1)(void*, int);
-        void (*func2)(void*, unsigned char*, int);
+        func1_t func1;
+        func2_t func2;
+        void* ptr;
     };
 
     CtrlCenter();
@@ -105,6 +110,7 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 484e885..5694a52 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -52,25 +52,14 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&mmt::GetRenderFrameInfo, &content_));
 }
 
 void URLRequestMmtJob::Start() {
-  base::FilePath file_path;
-  FileURLToFilePath(request_->url(), &file_path);
-  read_info_.uri = file_path.value();
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoStart,
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidStart,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -165,15 +154,16 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(ReadMetaInfo* read_info) {
-  read_info->is_started = base::GetFileSize(
-    base::FilePath(read_info->uri), &read_info->total_size);
+void URLRequestMmtJob::DoStart(void* thiz, int iret) {
+    LOG(INFO) << __func__ << " iret=" << iret;
+    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
+    if (job)
+        job->DidStart(iret);
 }
 
-void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
+void URLRequestMmtJob::DidStart(int iret) {
   int result = OK;
-  read_info_ = *read_info;
-  if (!read_info_.is_started) {
+  if (iret <= 0) {
     result = ERR_FAILED;
   }
 
@@ -186,6 +176,7 @@ void URLRequestMmtJob::DidStart(ReadMetaInfo* read_info) {
     return;
   }
 
+  read_info_.total_size = iret;
   if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 468db82..eaf4cb7 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -61,8 +61,8 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(ReadMetaInfo* read_info);
-  void DidStart(ReadMetaInfo* read_info);
+  static void DoStart(void *thiz, int iret);
+  void DidStart(int iret);
 
   static void DoRead(ReadMetaInfo* read_info);
   void DidRead(ReadMetaInfo* read_info);
-- 
1.7.9.5


From c27370eb2691b633941da8f62d7f13384a62baa0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 15 Jan 2015 10:03:03 -0800
Subject: [PATCH 026/128] refine ctrl center 3

---
 net/mmt/mmt_stream.cc                  |   65 +++++++++++++++++++++++++-------
 net/mmt/mmt_stream.h                   |    9 ++++-
 net/url_request/url_request_mmt_job.cc |   42 ++++++++++-----------
 net/url_request/url_request_mmt_job.h  |    7 ++--
 4 files changed, 82 insertions(+), 41 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 59be61b..9aee8d5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -50,26 +50,57 @@ void PostCtrlMsg(CtrlCenter::Message &msg) {
     gCenter->Push(msg);
 }
 
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-
+std::string GURL2string(GURL& gurl) {
+    std::string url;
 #if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    msg.url = file_path.value();
+    url = file_path.value();
 #else
     std::ostringstream sstr;
     sstr << gurl;
-    msg.url = sstr.str();
+    url = sstr.str();
 #endif
+    return url;
+}
 
+void PostCtrlTask(std::string head, GURL gurl) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.func1 = func1;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+void PostCtrlTask(std::string head, GURL gurl, 
+    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.buf = iobuf;
+    msg.size = size;
+    msg.offset = offset;
+    msg.func2 = func2;
+    msg.ptr= ptr;
+    msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
 
-CtrlCenter::Message::Message() {}
+CtrlCenter::Message::Message() {
+    tab_id = -1;
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func1 = nullptr;
+    func2 = nullptr;
+    ptr = nullptr;
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -84,7 +115,7 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head;
+        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
@@ -97,17 +128,23 @@ void CtrlCenter::Run() {
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
+        }else if (msg.head == "@close") {
+            std::string url = msg.url;
+            streams_t::iterator iter = streams_.find(url);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                stream->Uninit();
+                streams_.erase(iter);
+            }
         }else if (msg.head == "@read") {
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                char* buf = new char[msg.size];
-                int iret = stream->Read(buf, msg.size, msg.offset);
+                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
                 if (msg.func2) {
-                    msg.func2(msg.ptr, (unsigned char*)buf, iret);
+                    msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
-                delete buf;
             }
         }
         Wait(100);
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index fc9fa5c..5e52510 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -22,6 +22,7 @@
 
 namespace net {
 class URLRequest;
+class IOBuffer;
 }
 
 namespace mmt {
@@ -74,7 +75,7 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, unsigned char*, int);
+typedef void (*func2_t)(void*, void*, int);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -84,6 +85,8 @@ public:
         std::string body;
         std::string url;
         int   tab_id;
+
+        net::IOBuffer* buf;
         int   size;
         int   offset;
         func1_t func1;
@@ -110,7 +113,9 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
-void PostCtrlTask(std::string head, GURL url, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl);
+void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 5694a52..eb5177b 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -36,8 +36,7 @@
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
-URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo()
-    : is_started(false),
+URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
       total_size(0),
       read_offset(0),
       remaining_bytes(0),
@@ -63,6 +62,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
+  mmt::PostCtrlTask("@close", request_->url());
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -86,17 +86,8 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  ReadMetaInfo* read_info = new ReadMetaInfo;
-  *read_info = read_info_;
-  read_info->dest = dest;
-  read_info->dest_size = dest_size;
-  mmt_task_runner_->PostTaskAndReply(
-      FROM_HERE,
-      base::Bind(&URLRequestMmtJob::DoRead, 
-                 base::Unretained(read_info)),
-      base::Bind(&URLRequestMmtJob::DidRead,
-                 weak_ptr_factory_.GetWeakPtr(),
-                 base::Owned(read_info)));
+  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
+    &URLRequestMmtJob::DoRead, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -154,11 +145,13 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 URLRequestMmtJob::~URLRequestMmtJob() {
 }
 
-void URLRequestMmtJob::DoStart(void* thiz, int iret) {
-    LOG(INFO) << __func__ << " iret=" << iret;
-    URLRequestMmtJob* job = (URLRequestMmtJob *)thiz;
-    if (job)
-        job->DidStart(iret);
+void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
+  }
 }
 
 void URLRequestMmtJob::DidStart(int iret) {
@@ -192,11 +185,18 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(ReadMetaInfo *read_info) {
+void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+  }
 }
 
-void URLRequestMmtJob::DidRead(ReadMetaInfo* read_info) {
-  int result = read_info->dest_size;
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+  LOG(INFO) << __func__ << " data size=" << size;
+  int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
     read_info_.remaining_bytes -= result;
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index eaf4cb7..093763e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -51,7 +51,6 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   // Callback after data is asynchronously read from the file into |buf|.
   struct ReadMetaInfo {
     ReadMetaInfo();
-    bool is_started;
     int64 total_size;
     int64 read_offset;
     int64 remaining_bytes;
@@ -61,11 +60,11 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void *thiz, int iret);
+  static void DoStart(void* ptr, int iret);
   void DidStart(int iret);
 
-  static void DoRead(ReadMetaInfo* read_info);
-  void DidRead(ReadMetaInfo* read_info);
+  static void DoRead(void* ptr, void* data, int size);
+  void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
-- 
1.7.9.5


From 520ecb646b1cc59e1cc4c058f2b7907919084c4a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:28 -0800
Subject: [PATCH 027/128] enhance log for ctrl

---
 net/mmt/mmt_stream.cc                  |   16 ++++++++++------
 net/mmt/mmt_stream.h                   |    2 +-
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 12 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 9aee8d5..780490a 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -115,25 +115,26 @@ void CtrlCenter::Run() {
             Wait(500);
             continue;
         }
-        LOG(INFO) << __func__ << " head=" << msg.head << " offset=" << msg.offset;
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (msg.head == "@open") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             StreamPtr stream = new Stream(url);
             streams_.insert(pair_t(url, stream));
-            int64 size = -1;
+            long size = -1;
             stream->Prepare(&size);
             if (msg.func1) {
                 msg.func1(msg.ptr, size);
             }
         }else if (msg.head == "@close") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                stream->Uninit();
+                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -142,6 +143,9 @@ void CtrlCenter::Run() {
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
+                LOG(INFO) << __func__ << " head=" << msg.head 
+                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
+                    << " size=" << msg.size << " ptr=" << msg.ptr;
                 if (msg.func2) {
                     msg.func2(msg.ptr, (void*)msg.buf, iret);
                 }
@@ -171,7 +175,7 @@ bool CtrlCenter::Pop(Message &msg) {
 }
 
 void CtrlCenter::Push(Message &msg) {
-    LOG(INFO) << __func__;
+    //LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
@@ -289,10 +293,10 @@ bool Stream::Init() {
     return false;
 }
 
-bool Stream::Prepare(int64 *size) {
+bool Stream::Prepare(long *size) {
     if (!Init()) return false;
     fseek(file_, 0L, SEEK_END);
-    int64 lret = ftell(file_);
+    long lret = ftell(file_);
     *size = lret;
     return true;
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 5e52510..bfb6711 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -49,7 +49,7 @@ public:
     explicit Stream(const std::string &uri);
     std::string getUri();
     bool Init();
-    bool Prepare(int64 *size);
+    bool Prepare(long *size);
     int Read(char *buf, int size, int offset);
     void Uninit();
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index eb5177b..493c6bb 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -51,6 +51,7 @@ URLRequestMmtJob::URLRequestMmtJob(
     : URLRequestJob(request, network_delegate),
       mmt_task_runner_(mmt_task_runner),
       weak_ptr_factory_(this) {
+  LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-- 
1.7.9.5


From da105b21fbc0786947a0d42355247ef1caa21577 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 19:28:54 -0800
Subject: [PATCH 028/128] add cictrl module

---
 .../docs/examples/api/cictrl/background.js         |   15 +++++++++
 .../docs/examples/api/cictrl/content_scripts.js    |   33 ++++++++++++++++++++
 .../docs/examples/api/cictrl/manifest.json         |   24 ++++++++++++++
 3 files changed, 72 insertions(+)
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/background.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/manifest.json

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
new file mode 100644
index 0000000..e6b3978
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -0,0 +1,15 @@
+
+function log(msg) {
+  //alert(msg);
+  console.log(msg);
+}
+
+chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
+    log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
+    if (request.greeting == "hello" && sender.tab) {
+        sendResponse({farewell: "goodbye"});
+        chrome.tabs.executeScript(sender.tab.id, {
+            code: 'document.body.style.backgroundColor="red"'
+        });
+    }
+});
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
new file mode 100644
index 0000000..a73420c
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -0,0 +1,33 @@
+// detect the changes of storage and apply them into current page
+
+function log(msg) {
+    //alert(msg);
+    console.log(msg);
+}
+
+// for chrome.storage.local
+chrome.storage.onChanged.addListener(function(changes, namespace) {
+    if (namespace != "local") {
+        log("donot process the namespace = " + namespace);
+        return;
+    }
+
+    for (key in changes) {
+        var storageChange = changes[key];
+        log('Storage key "%s" in namespace "%s" changed. ' +
+            'Old value was "%s", new value is "%s".',
+            key,
+            namespace,
+            storageChange.oldValue,
+            storageChange.newValue);
+    }
+});
+
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
+// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+window.onload = function() {
+    log("window.onload");
+    chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
+        log(response.farewell);
+    });
+};
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
new file mode 100644
index 0000000..e955013
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -0,0 +1,24 @@
+{
+    "name" : "org.chromium.cictrl",
+    "version": "1.0",
+    "manifest_version": 2,
+    "description": "chromium ci control",
+    "permissions": [
+        "file://*/*",
+        "http://*/*",
+        "mmt://*/*",
+        "tabs", 
+        "storage"
+    ],
+    "background": {
+        "scripts": ["background.js"],
+        "persistent": false
+    },
+    "content_scripts": [
+        {
+            "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
+            "run_at" : "document_end",
+            "js" : ["content_scripts.js"]
+        }
+    ]
+}
-- 
1.7.9.5


From d687ea44a680a4e9f951f085fb9b4522d30ac902 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 17 Jan 2015 23:34:23 -0800
Subject: [PATCH 029/128] try chrome.storage module

---
 net/mmt/mmt_stream.cc                  |   66 +++++++++++++++++++++++++++++++-
 net/mmt/mmt_stream.h                   |   30 ++++++++++++++-
 net/url_request/url_request_mmt_job.cc |   38 +++++++++++++++++-
 net/url_request/url_request_mmt_job.h  |    4 ++
 4 files changed, 133 insertions(+), 5 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 780490a..1861832 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -21,6 +21,14 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 
 using namespace content;
 
@@ -91,6 +99,18 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
+// for @store
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+    CtrlCenter::Message msg;
+    msg.head = head;
+    msg.key = key;
+    msg.value = value;
+    msg.func3 = func3;
+    msg.ptr = ptr;
+    msg.url = GURL2string(gurl);
+    PostCtrlMsg(msg);
+}
+
 
 CtrlCenter::Message::Message() {
     tab_id = -1;
@@ -101,6 +121,8 @@ CtrlCenter::Message::Message() {
     func2 = nullptr;
     ptr = nullptr;
 }
+CtrlCenter::Message::~Message() {
+}
 CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
     running_ = false;
 }
@@ -118,6 +140,12 @@ void CtrlCenter::Run() {
 
         if (msg.head == "@ctrl") {
             PostNativeMsg(msg.body);
+        }else if (msg.head == "@test") {
+            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
+            Wait(5000);
+            if (msg.func3) {
+                msg.func3(msg.ptr, msg.key, msg.value);
+            }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             std::string url = msg.url;
@@ -134,7 +162,6 @@ void CtrlCenter::Run() {
             streams_t::iterator iter = streams_.find(url);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
-                //stream->Uninit();
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
@@ -242,13 +269,43 @@ bool GetRequestID(const net::URLRequest* request, Content* content) {
     return is_ok;
 }
 
-void GetRenderFrameInfo(Content* content) {
+void GetExtension(Content* content, BrowserContext* context) {
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    LOG(INFO) << __func__ << " frontend=" << frontend;
+    if (!frontend) {
+        return;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    LOG(INFO) << __func__ << " registry=" << registry;
+    if (registry) {
+        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+            LOG(INFO) << __func__ << " name=" << extension->name()
+                << " id=" << extension->id();
+            if (extension->name() == "org.chromium.cictrl") {
+                frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, content->storage_callback);
+                break;
+            }
+        }
+    }
+}
+
+
+void GetRenderFrameInfo(Content* content, bool has_storage) {
+    LOG(INFO) << __func__ << " begin";
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    LOG(INFO) << __func__ << " get rfh";
     RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
     if (rfh && rfh->GetParent()) {
         LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
         rfh = rfh->GetParent();
     }
 
+    LOG(INFO) << __func__ << " rfh=" << rfh;
     if (rfh) {
         WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
         if (web_contents) {
@@ -258,6 +315,9 @@ void GetRenderFrameInfo(Content* content) {
             content->tab_url = sstr.str();
             LOG(INFO) << __func__ << " tab id=" << content->tab_id
                 << ", tab url=" << content->tab_url;
+            if (has_storage) {
+                GetExtension(content, web_contents->GetBrowserContext());
+            }
         }
     }
 }
@@ -272,6 +332,8 @@ namespace mmt {
 
 Content::Content() {
 }
+Content::~Content() {
+}
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index bfb6711..60e7979 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,6 +20,16 @@
 
 #include "url/gurl.h"
 
+#include "extensions/browser/api/storage/value_store_cache.h"
+
+class ValueStore;
+
+namespace extensions {
+class Extension;
+class StorageFrontend;
+class ValueStoreCache;
+}
+
 namespace net {
 class URLRequest;
 class IOBuffer;
@@ -29,16 +39,18 @@ namespace mmt {
 
 struct Content {
     Content();
+    ~Content();
+
     int process_id;
     int frame_id;
     int routing_id;
     int tab_id;
     std::string tab_url;
-    std::string data;
+    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
 bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content);
+void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -76,16 +88,25 @@ namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
+typedef void (*func3_t)(void*, std::string, std::string);
 
 class CtrlCenter : public base::SimpleThread {
 public:
     struct Message {
         Message();
+        ~Message();
+
         std::string head;
         std::string body;
         std::string url;
         int   tab_id;
+        
+        // for storage
+        std::string key;
+        std::string value;
+        func3_t func3;
 
+        // for stream I/O
         net::IOBuffer* buf;
         int   size;
         int   offset;
@@ -113,9 +134,14 @@ private:
 
 void StartCtrlCenter();
 void PostCtrlMsg(CtrlCenter::Message &msg);
+
 void PostCtrlTask(std::string head, GURL gurl);
+// for @open
 void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
+// for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 493c6bb..4a8f832 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -33,6 +33,14 @@
 #include "net/mmt/mmt_stream.h"
 #include "content/public/browser/browser_thread.h"
 
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+
 namespace net {
 
 // TODO implement ReadMetaInfo as one scope refptr
@@ -54,8 +62,9 @@ URLRequestMmtJob::URLRequestMmtJob(
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
   mmt::GetRequestID(request_, &content_);
+  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_));
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -204,6 +213,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
+  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
+  //  &URLRequestMmtJob::DoStore, (void*)this);
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -214,6 +227,29 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+  }
+}
+void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
+    LOG(INFO) << __func__ << " set value";
+    std::string szkey = "xyz";
+    std::string szvalue = "test yzxu 123";
+    scoped_ptr<base::Value> value;
+    value.reset(new base::StringValue(szvalue));
+    storage->Set(ValueStore::DEFAULTS, szkey, *value);
+}
+void URLRequestMmtJob::DidStore() {
+  LOG(INFO) << __func__;
+  GetRenderFrameInfo(&content_);
+  //content_.frontend->RunWithStorage(content_.extension, 
+  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+}
+
 void URLRequestMmtJob::DoTest(void* ptr) {
 }
 
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 093763e..cfc23a1 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -69,6 +69,10 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
+  static void StorageCallback(ValueStore* storage);
+  static void DoStore(void* ptr, std::string key, std::string value);
+  void DidStore();
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
-- 
1.7.9.5


From 044d7229a379aa7a199cc5a089e9b13f9aac9bfb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 00:51:36 -0800
Subject: [PATCH 030/128] testing failed for chrome.storage

---
 net/mmt/mmt_stream.cc                  |  115 ++---------------------------
 net/mmt/mmt_stream.h                   |   32 ++++----
 net/url_request/url_request_mmt_job.cc |  127 +++++++++++++++++++++++++-------
 net/url_request/url_request_mmt_job.h  |   11 ++-
 4 files changed, 133 insertions(+), 152 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1861832..8bedeaf 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,19 +1,5 @@
 #include "net/mmt/mmt_stream.h"
 
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/resource_context.h"
-#include "content/public/browser/content_browser_client.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/render_view_host.h"
-
-#include "content/public/common/content_client.h"
-#include "content/public/renderer/render_thread.h"
-#include "content/public/renderer/render_frame.h"
-#include "content/public/renderer/render_view.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -21,15 +7,6 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-
-
 using namespace content;
 
 namespace mmt {
@@ -99,12 +76,14 @@ void PostCtrlTask(std::string head, GURL gurl,
     msg.url = GURL2string(gurl);
     PostCtrlMsg(msg);
 }
-// for @store
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr) {
+// for @storage
+void PostCtrlTask(std::string head, GURL gurl, 
+    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
     CtrlCenter::Message msg;
     msg.head = head;
     msg.key = key;
     msg.value = value;
+    msg.content = *content;
     msg.func3 = func3;
     msg.ptr = ptr;
     msg.url = GURL2string(gurl);
@@ -144,7 +123,7 @@ void CtrlCenter::Run() {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
             Wait(5000);
             if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value);
+                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
             }
         }else if (msg.head == "@open") {
             LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
@@ -241,90 +220,6 @@ void PostNativeMsg(std::string msg) {
 } // namespace mmt
 
 
-namespace mmt {
-
-bool GetRequestID(const net::URLRequest* request, Content* content) {
-    if (!content) return false;
-
-    const ResourceRequestInfo* rinfo = ResourceRequestInfo::ForRequest(request);
-    if (rinfo) {
-        content->routing_id = rinfo->GetRouteID();
-        LOG(INFO) << __func__ << " routing ID: " << rinfo->GetRouteID();
-    }
-
-    bool is_ok = ResourceRequestInfo::GetRenderFrameForRequest(request, 
-            &content->process_id, &content->frame_id);
-    if (is_ok) {
-        LOG(INFO) << __func__ << " render_process_id: " << content->process_id
-            << ", render_frame_id: " << content->frame_id;
-    }
-
-    LOG(INFO) << __func__ << " resource type=" << rinfo->GetResourceType()
-        << ", frame id=" << rinfo->GetRenderFrameID()
-        << ", parent frame id=" << rinfo->GetParentRenderFrameID()
-        << ", is main frame=" << rinfo->IsMainFrame()
-        << ", parent is main frame=" << rinfo->ParentIsMainFrame()
-        << "";
-
-    return is_ok;
-}
-
-void GetExtension(Content* content, BrowserContext* context) {
-    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
-    LOG(INFO) << __func__ << " frontend=" << frontend;
-    if (!frontend) {
-        return;
-    }
-
-    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
-    LOG(INFO) << __func__ << " registry=" << registry;
-    if (registry) {
-        const extensions::ExtensionSet& extensions = registry->enabled_extensions();
-        for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
-            LOG(INFO) << __func__ << " name=" << extension->name()
-                << " id=" << extension->id();
-            if (extension->name() == "org.chromium.cictrl") {
-                frontend->RunWithStorage(extension, 
-                    extensions::settings_namespace::LOCAL, content->storage_callback);
-                break;
-            }
-        }
-    }
-}
-
-
-void GetRenderFrameInfo(Content* content, bool has_storage) {
-    LOG(INFO) << __func__ << " begin";
-    content->tab_id = -1;
-    content->tab_url = "";
-
-    LOG(INFO) << __func__ << " get rfh";
-    RenderFrameHost* rfh = RenderFrameHost::FromID(content->process_id, content->frame_id);
-    if (rfh && rfh->GetParent()) {
-        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
-        rfh = rfh->GetParent();
-    }
-
-    LOG(INFO) << __func__ << " rfh=" << rfh;
-    if (rfh) {
-        WebContents* web_contents = WebContents::FromRenderFrameHost(rfh);
-        if (web_contents) {
-            content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-            std::ostringstream sstr;
-            sstr << web_contents->GetURL();
-            content->tab_url = sstr.str();
-            LOG(INFO) << __func__ << " tab id=" << content->tab_id
-                << ", tab url=" << content->tab_url;
-            if (has_storage) {
-                GetExtension(content, web_contents->GetBrowserContext());
-            }
-        }
-    }
-}
-
-} // namespace mmt
-
-
 ///===============================
 /// for class Stream and StreamPool
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 60e7979..c725f0d 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -20,15 +20,22 @@
 
 #include "url/gurl.h"
 
-#include "extensions/browser/api/storage/value_store_cache.h"
+#include "base/values.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/extension.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
 
-class ValueStore;
-
-namespace extensions {
-class Extension;
-class StorageFrontend;
-class ValueStoreCache;
-}
 
 namespace net {
 class URLRequest;
@@ -46,11 +53,8 @@ struct Content {
     int routing_id;
     int tab_id;
     std::string tab_url;
-    extensions::ValueStoreCache::StorageCallback storage_callback;
 };
 
-bool GetRequestID(const net::URLRequest* request, Content* content);
-void GetRenderFrameInfo(Content* content, bool has_storage=false);
 } // namespace mmt
 
 
@@ -83,12 +87,11 @@ typedef std::map<std::string, StreamPtr>  streams_t;
 } // namespace mmt
 
 
-
 namespace mmt {
 
 typedef void (*func1_t)(void*, int);
 typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string);
+typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
 
 class CtrlCenter : public base::SimpleThread {
 public:
@@ -104,6 +107,7 @@ public:
         // for storage
         std::string key;
         std::string value;
+        mmt::Content content;
         func3_t func3;
 
         // for stream I/O
@@ -141,7 +145,7 @@ void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
 // for @read
 void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
 // for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, func3_t func3, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
 
 } // namespace mmt
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4a8f832..6f79339 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -31,15 +31,6 @@
 #endif
 
 #include "net/mmt/mmt_stream.h"
-#include "content/public/browser/browser_thread.h"
-
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
 
 namespace net {
 
@@ -61,10 +52,9 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartCtrlCenter();
-  mmt::GetRequestID(request_, &content_);
-  content_.storage_callback = base::Bind(&URLRequestMmtJob::StorageCallback);
+  GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, false));
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
@@ -213,10 +203,10 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  //mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", 
-  //  &URLRequestMmtJob::DoStore, (void*)this);
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&mmt::GetRenderFrameInfo, &content_, true));
+  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
+    &URLRequestMmtJob::DoStore, (void*)this);
+  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -227,14 +217,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-  }
-}
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -243,11 +225,23 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
+void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
+  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
+  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  if (thiz) {
+    thiz->kvstoring_.first = key;
+    thiz->kvstoring_.second = value;
+    mmt::Content* pcontent = new mmt::Content;
+    *pcontent = *content;
+    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
+    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
+  }
+}
 void URLRequestMmtJob::DidStore() {
   LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_);
-  //content_.frontend->RunWithStorage(content_.extension, 
-  //    extensions::settings_namespace::LOCAL, base::Bind(&LocalStorageCallback));
+  GetRenderFrameInfo(&content_, true);
 }
 
 void URLRequestMmtJob::DoTest(void* ptr) {
@@ -256,4 +250,83 @@ void URLRequestMmtJob::DoTest(void* ptr) {
 void URLRequestMmtJob::DidTest(void* ptr) {
 }
 
+bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+    if (!content) return false;
+    const content::ResourceRequestInfo* rinfo = 
+        content::ResourceRequestInfo::ForRequest(request);
+    if (rinfo) {
+        content->routing_id = rinfo->GetRouteID();
+    }
+
+    bool is_ok = content::ResourceRequestInfo::GetRenderFrameForRequest(request, 
+            &content->process_id, &content->frame_id);
+    LOG(INFO) << __func__ 
+        << ", render_process_id: " << content->process_id
+        << ", render_frame_id: " << content->frame_id
+        << ", routing ID: " << content->routing_id;
+    return is_ok;
+}
+
+bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+    if (!content) return false;
+    extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
+    if (!frontend) {
+        LOG(INFO) << __func__ << " frontend is nullptr";
+        return false;
+    }
+
+    extensions::ExtensionRegistry* registry = extensions::ExtensionRegistry::Get(context);
+    if (!registry) {
+        LOG(INFO) << __func__ << " registry is nullptr";
+        return false;
+    }
+
+    const extensions::ExtensionSet& extensions = registry->enabled_extensions();
+    for (const scoped_refptr<const extensions::Extension>& extension : extensions) {
+        if (extension->name() == "org.chromium.cictrl") {
+            LOG(INFO) << __func__ 
+                << " extension name=" << extension->name()
+                << " extension id=" << extension->id();
+            frontend->RunWithStorage(extension, 
+                    extensions::settings_namespace::LOCAL, base::Bind(&URLRequestMmtJob::StorageCallback));
+            break;
+        }
+    }
+    return true;
+}
+
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+    if (!content) return;
+    content->tab_id = -1;
+    content->tab_url = "";
+
+    content::RenderFrameHost* rfh = 
+        content::RenderFrameHost::FromID(content->process_id, content->frame_id);
+    if (rfh && rfh->GetParent()) {
+        LOG(INFO) << __func__ << " goto RenderFrameHost's parent";
+        rfh = rfh->GetParent();
+    }
+    if (!rfh) {
+        LOG(INFO) << __func__ << " rfh is nullptr";
+        return;
+    }
+
+    content::WebContents* web_contents = 
+        content::WebContents::FromRenderFrameHost(rfh);
+    if (!web_contents) {
+        LOG(INFO) << __func__ << " web_contents is nullptr";
+        return;
+    }
+    content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
+    std::ostringstream sstr;
+    sstr << web_contents->GetURL();
+    content->tab_url = sstr.str();
+    LOG(INFO) << __func__ 
+        << " tab id=" << content->tab_id
+        << ", tab url=" << content->tab_url;
+    if (has_storage) {
+        GetExtension(content, web_contents->GetBrowserContext());
+    }
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index cfc23a1..6d3e3da 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -23,6 +23,9 @@ class TaskRunner;
 namespace file_util {
 struct FileInfo;
 }
+namespace content {
+class BrowserContext;
+}
 
 namespace net {
 
@@ -70,15 +73,21 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   void DidTest(void* ptr);
 
   static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value);
+  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
   void DidStore();
 
+  // get info for render
+  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
+  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+
  private:
   const scoped_refptr<base::TaskRunner> mmt_task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
   mmt::Content content_;
+  std::pair<std::string, std::string> kvstoring_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 9c7e96016284709461f6c4fbff887242724cfff8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 01:45:22 -0800
Subject: [PATCH 031/128] refine for native messaging

---
 net/mmt/mmt_control.cc                 |  189 +++++++++++++++++++++++++++
 net/mmt/mmt_control.h                  |   71 ++++++++++
 net/mmt/mmt_inc.h                      |   40 ++++++
 net/mmt/mmt_stream.cc                  |  222 ++------------------------------
 net/mmt/mmt_stream.h                   |   89 +------------
 net/net.gypi                           |    1 +
 net/url_request/url_request_mmt_job.cc |   77 +++++------
 net/url_request/url_request_mmt_job.h  |   22 ++--
 8 files changed, 358 insertions(+), 353 deletions(-)
 create mode 100644 net/mmt/mmt_control.cc
 create mode 100644 net/mmt/mmt_control.h
 create mode 100644 net/mmt/mmt_inc.h

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
new file mode 100644
index 0000000..cd6274c
--- /dev/null
+++ b/net/mmt/mmt_control.cc
@@ -0,0 +1,189 @@
+#include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+static MmtControl *g_ctrl = nullptr;
+
+void StartMmtCtrl() {
+    if (!g_ctrl) {
+        g_ctrl = new MmtControl;
+    }
+    if (g_ctrl->IsRunning()) {
+        return;
+    }
+    g_ctrl->Reset();
+    g_ctrl->Start();
+    LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
+}
+
+void PostCtrlMsg(ctrl_msg_t &msg) {
+    if (!g_ctrl) return;
+    g_ctrl->Push(msg);
+}
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.body = body;
+    msg.tabid = tabid;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.sinfo = sinfo;
+    msg.ptr= ptr;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
+
+} // namespace mmt
+
+
+/// for class MmtControl
+namespace mmt {
+
+ctrl_msg_t::ctrl_msg_t() {
+    head = "";
+    body = "";
+    uri = "";
+    tabid = -1;
+    ptr = nullptr;
+
+    sinfo.buf = nullptr;
+    sinfo.size = 0;
+    sinfo.offset = 0;
+    sinfo.func = nullptr;
+}
+ctrl_msg_t::~ctrl_msg_t() {
+}
+
+MmtControl::MmtControl() : SimpleThread("mmt_control"){
+    running_ = false;
+}
+MmtControl::~MmtControl() {}
+
+void MmtControl::Run() {
+    LOG(INFO) << __func__ << " begin";
+    running_ = true;
+    while(loop_) {
+        ctrl_msg_t msg;
+        if (!Pop(msg)) {
+            Wait(500);
+            continue;
+        }
+
+        std::string head = msg.head;
+        std::string uri = msg.uri;
+        LOG(INFO) << __func__ << " head=" << head << " uri=" << uri;
+
+        if (head == "@ctrl") {
+            PostNativeMsg(msg.body);
+        }else if (head == "@test") {
+            //..
+        }else if (msg.head == "@open") {
+            StreamPtr stream = new Stream(uri);
+            streams_.insert(stream_t(uri, stream));
+            long lsize = -1;
+            stream->Prepare(&lsize);
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+            }
+        }else if (msg.head == "@close") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                streams_.erase(iter);
+            }
+        }else if (msg.head == "@read") {
+            streams_t::iterator iter = streams_.find(uri);
+            if (iter != streams_.end()) {
+                StreamPtr stream = iter->second;
+                int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+                LOG(INFO) << __func__ 
+                    << " head=" << head 
+                    << " iret=" << iret 
+                    << " uri=" << uri
+                    << " size=" << msg.sinfo.size 
+                    << " offset=" << msg.sinfo.offset 
+                    << " ptr=" << msg.ptr;
+                if (msg.sinfo.func) {
+                    msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+                }
+            }
+        }
+        Wait(100);
+    };
+    running_ = false;
+    LOG(INFO) << __func__ << " end";
+}
+
+void MmtControl::Reset() {
+    loop_ = true;
+}
+bool MmtControl::IsRunning() {
+    return running_;
+}
+
+bool MmtControl::Pop(ctrl_msg_t &msg) {
+    if (queue_.empty())
+        return false;
+    lock_.Acquire();
+    msg = queue_.back();
+    queue_.pop_back();
+    lock_.Release();
+    return true;
+}
+
+void MmtControl::Push(ctrl_msg_t &msg) {
+    //LOG(INFO) << __func__;
+    lock_.Acquire();
+    queue_.insert(queue_.begin(), msg);
+    lock_.Release();
+}
+
+
+void PostNativeMsg(std::string msg) {
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return;
+    }
+    
+    int port = 54321;
+    std::string szaddr = "127.0.0.1";
+    net::IPAddressNumber ipnum;
+    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+        return;
+    }
+
+    net::IPEndPoint ip(ipnum, port);
+    struct sockaddr addr;
+    socklen_t addrlen;
+    if(!ip.ToSockAddr(&addr, &addrlen)) {
+        close(sock);
+        LOG(INFO) << __func__ << " ToSockAddr failed";
+        return;
+    }
+
+    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    close(sock);
+}
+
+} // namespace mmt
+
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
new file mode 100644
index 0000000..f02c47c
--- /dev/null
+++ b/net/mmt/mmt_control.h
@@ -0,0 +1,71 @@
+#ifndef NET_MMT_MMT_CONTROL_H_
+#define NET_MMT_MMT_CONTROL_H_
+
+#include <string>
+#include "net/mmt/mmt_stream.h"
+
+namespace net {
+class IOBuffer;
+}
+
+namespace mmt {
+
+struct stream_info_t;
+// (ptr, stream_info_t, errno)
+typedef void (*stream_func_t)(void*, stream_info_t&, int);
+struct stream_info_t {
+    net::IOBuffer*  buf;
+    int             size;
+    int             offset;
+    stream_func_t   func;
+};
+
+struct ctrl_msg_t {
+    ctrl_msg_t();
+    ~ctrl_msg_t();
+
+    std::string head;
+    std::string body;
+    std::string uri;
+    int   tabid;
+    void* ptr;
+
+    stream_info_t sinfo;
+};
+
+class MmtControl : public base::SimpleThread {
+public:
+    MmtControl();
+    virtual ~MmtControl();
+    virtual void Run() override;
+
+    void Reset();
+    bool IsRunning();
+    bool Pop(ctrl_msg_t& msg);
+    void Push(ctrl_msg_t& msg);
+
+private:
+    bool loop_;
+    bool running_;
+    std::vector<ctrl_msg_t> queue_;
+    base::Lock lock_;
+    streams_t streams_;
+};
+
+} // namespace mmt
+
+
+namespace mmt {
+
+void StartMmtCtrl();
+void PostNativeMsg(std::string msg);
+
+// for @close
+void PostCtrlTask(std::string head, GURL gurl);
+// for @ctrl
+void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
+// for @open and @read
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+} // namespace mmt
+
+#endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
new file mode 100644
index 0000000..f5ba4f7
--- /dev/null
+++ b/net/mmt/mmt_inc.h
@@ -0,0 +1,40 @@
+#ifndef NET_MMT_MMT_INC_H_
+#define NET_MMT_MMT_INC_H_
+
+#include <string>
+#include <sstream>
+
+#include "base/values.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+
+#include "net/base/file_stream.h"
+#include "net/base/io_buffer.h"
+#include "net/base/filename_util.h"
+#include "net/udp/udp_socket.h"
+
+#include "extensions/common/extension.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/api/storage/settings_namespace.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+#include "extensions/browser/value_store/value_store.h"
+#include "extensions/browser/api/storage/storage_frontend.h"
+
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+
+#include "chrome/browser/extensions/extension_tab_util.h"
+#include "url/gurl.h"
+
+namespace mmt{
+void Wait(int ms);
+std::string GURL2FilePath(GURL& gurl);
+std::string GURL2String(GURL& gurl);
+}
+
+#endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 8bedeaf..6e5be76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,235 +1,34 @@
 #include "net/mmt/mmt_stream.h"
-
-#include "base/strings/utf_string_conversions.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "net/udp/udp_socket.h"
-#include "net/base/io_buffer.h"
-#include "net/base/filename_util.h"
-
-using namespace content;
+#include "net/mmt/mmt_inc.h"
 
 namespace mmt {
 
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-void PostNativeMsg(std::string msg);
-
-
-static CtrlCenter *gCenter = nullptr;
-void StartCtrlCenter() {
-    if (!gCenter) {
-        gCenter = new CtrlCenter;
-    }
-    if (gCenter->IsRunning()) {
-        return;
-    }
-    gCenter->Reset();
-    gCenter->Start();
-    LOG(INFO) << __func__ << " started=" << gCenter->HasBeenStarted();
-}
-
-void PostCtrlMsg(CtrlCenter::Message &msg) {
-    if (!gCenter) return;
-    gCenter->Push(msg);
-}
-
-std::string GURL2string(GURL& gurl) {
+std::string GURL2FilePath(GURL& gurl) {
     std::string url;
-#if 1
     base::FilePath file_path;
     net::FileURLToFilePath(gurl, &file_path);
-    url = file_path.value();
-#else
+    return file_path.value();
+}
+std::string GURL2String(GURL& gurl) {
     std::ostringstream sstr;
     sstr << gurl;
-    url = sstr.str();
-#endif
-    return url;
-}
-
-void PostCtrlTask(std::string head, GURL gurl) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.func1 = func1;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-void PostCtrlTask(std::string head, GURL gurl, 
-    net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.buf = iobuf;
-    msg.size = size;
-    msg.offset = offset;
-    msg.func2 = func2;
-    msg.ptr= ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, 
-    std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr) {
-    CtrlCenter::Message msg;
-    msg.head = head;
-    msg.key = key;
-    msg.value = value;
-    msg.content = *content;
-    msg.func3 = func3;
-    msg.ptr = ptr;
-    msg.url = GURL2string(gurl);
-    PostCtrlMsg(msg);
-}
-
-
-CtrlCenter::Message::Message() {
-    tab_id = -1;
-    buf = nullptr;
-    size = 0;
-    offset = 0;
-    func1 = nullptr;
-    func2 = nullptr;
-    ptr = nullptr;
-}
-CtrlCenter::Message::~Message() {
-}
-CtrlCenter::CtrlCenter() : SimpleThread("ctrlcenter"){
-    running_ = false;
-}
-CtrlCenter::~CtrlCenter() {}
-
-void CtrlCenter::Run() {
-    LOG(INFO) << __func__ << " begin";
-    running_ = true;
-    while(loop_) {
-        Message msg;
-        if (!Pop(msg)) {
-            Wait(500);
-            continue;
-        }
-
-        if (msg.head == "@ctrl") {
-            PostNativeMsg(msg.body);
-        }else if (msg.head == "@test") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            Wait(5000);
-            if (msg.func3) {
-                msg.func3(msg.ptr, msg.key, msg.value, &msg.content);
-            }
-        }else if (msg.head == "@open") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            StreamPtr stream = new Stream(url);
-            streams_.insert(pair_t(url, stream));
-            long size = -1;
-            stream->Prepare(&size);
-            if (msg.func1) {
-                msg.func1(msg.ptr, size);
-            }
-        }else if (msg.head == "@close") {
-            LOG(INFO) << __func__ << " head=" << msg.head << " url=" << msg.url;
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                streams_.erase(iter);
-            }
-        }else if (msg.head == "@read") {
-            std::string url = msg.url;
-            streams_t::iterator iter = streams_.find(url);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                int iret = stream->Read(msg.buf->data(), msg.size, msg.offset);
-                LOG(INFO) << __func__ << " head=" << msg.head 
-                    << " offset=" << msg.offset << " iret=" << iret << " url=" << msg.url
-                    << " size=" << msg.size << " ptr=" << msg.ptr;
-                if (msg.func2) {
-                    msg.func2(msg.ptr, (void*)msg.buf, iret);
-                }
-            }
-        }
-        Wait(100);
-    };
-    running_ = false;
-    LOG(INFO) << __func__ << " end";
+    return sstr.str();
 }
 
-void CtrlCenter::Reset() {
-    loop_ = true;
+content_t::content_t() {
 }
-bool CtrlCenter::IsRunning() {
-    return running_;
-}
-
-bool CtrlCenter::Pop(Message &msg) {
-    if (queue_.empty())
-        return false;
-    lock_.Acquire();
-    msg = queue_.back();
-    queue_.pop_back();
-    lock_.Release();
-    return true;
-}
-
-void CtrlCenter::Push(Message &msg) {
-    //LOG(INFO) << __func__;
-    lock_.Acquire();
-    queue_.insert(queue_.begin(), msg);
-    lock_.Release();
-}
-
-void PostNativeMsg(std::string msg) {
-    int sock = socket(AF_INET, SOCK_DGRAM, 0);
-    if(sock <= 0) {
-        LOG(INFO) << __func__ << " Open failed sock=" << sock;
-        return;
-    }
-    
-    int port = 54321;
-    std::string szaddr = "127.0.0.1";
-    net::IPAddressNumber ipnum;
-    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
-        return;
-    }
-
-    net::IPEndPoint ip(ipnum, port);
-    struct sockaddr addr;
-    socklen_t addrlen;
-    if(!ip.ToSockAddr(&addr, &addrlen)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ToSockAddr failed";
-        return;
-    }
-
-    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
-    LOG(INFO) << __func__ << " sendto iret=" << iret;
-    close(sock);
+content_t::~content_t() {
 }
 
 } // namespace mmt
 
 
-///===============================
 /// for class Stream and StreamPool
-
 namespace mmt {
 
-Content::Content() {
-}
-Content::~Content() {
-}
-
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
     LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
@@ -260,8 +59,11 @@ bool Stream::Prepare(long *size) {
 
 int Stream::Read(char *buf, int size, int offset) {
     if (!Init()) return -1;
-    fseek(file_, offset, SEEK_SET);
+    int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
+    if (iret <= 0) {
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+    }
     return iret; 
 }
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c725f0d..b4d11b9 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -17,36 +17,19 @@
 #include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
 #include "base/time/time.h"
-
 #include "url/gurl.h"
 
-#include "base/values.h"
-#include "extensions/browser/extension_system.h"
-#include "extensions/browser/extension_registry.h"
-#include "extensions/common/extension.h"
-#include "extensions/browser/api/storage/settings_namespace.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "extensions/browser/value_store/value_store.h"
-#include "extensions/browser/api/storage/storage_frontend.h"
-#include "chrome/browser/extensions/extension_tab_util.h"
-
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/resource_request_info.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-
 
+class ValueStore;
 namespace net {
-class URLRequest;
 class IOBuffer;
 }
 
 namespace mmt {
 
-struct Content {
-    Content();
-    ~Content();
+struct content_t {
+    content_t();
+    ~content_t();
 
     int process_id;
     int frame_id;
@@ -81,72 +64,10 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> pair_t;
+typedef std::pair<std::string, StreamPtr> stream_t;
 typedef std::map<std::string, StreamPtr>  streams_t;
 
 } // namespace mmt
 
 
-namespace mmt {
-
-typedef void (*func1_t)(void*, int);
-typedef void (*func2_t)(void*, void*, int);
-typedef void (*func3_t)(void*, std::string, std::string, mmt::Content*);
-
-class CtrlCenter : public base::SimpleThread {
-public:
-    struct Message {
-        Message();
-        ~Message();
-
-        std::string head;
-        std::string body;
-        std::string url;
-        int   tab_id;
-        
-        // for storage
-        std::string key;
-        std::string value;
-        mmt::Content content;
-        func3_t func3;
-
-        // for stream I/O
-        net::IOBuffer* buf;
-        int   size;
-        int   offset;
-        func1_t func1;
-        func2_t func2;
-        void* ptr;
-    };
-
-    CtrlCenter();
-    virtual ~CtrlCenter();
-    virtual void Run() override;
-
-    void Reset();
-    bool IsRunning();
-    bool Pop(Message &msg);
-    void Push(Message &msg);
-
-private:
-    bool loop_;
-    bool running_;
-    std::vector<Message> queue_;
-    base::Lock lock_;
-    streams_t streams_;
-};
-
-void StartCtrlCenter();
-void PostCtrlMsg(CtrlCenter::Message &msg);
-
-void PostCtrlTask(std::string head, GURL gurl);
-// for @open
-void PostCtrlTask(std::string head, GURL gurl, func1_t func1, void* ptr);
-// for @read
-void PostCtrlTask(std::string head, GURL gurl, net::IOBuffer* iobuf, int size, int offset, func2_t func2, void* ptr);
-// for @storage
-void PostCtrlTask(std::string head, GURL gurl, std::string key, std::string value, mmt::Content* content, func3_t func3, void* ptr);
-
-} // namespace mmt
-
 #endif
diff --git a/net/net.gypi b/net/net.gypi
index cc6c1b2..99959ba 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -701,6 +701,7 @@
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
       'mmt/mmt_stream.cc',
+      'mmt/mmt_control.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6f79339..b985b58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -6,7 +6,6 @@
 
 #include "base/bind.h"
 #include "base/compiler_specific.h"
-#include "base/files/file_util.h"
 #include "base/message_loop/message_loop.h"
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
@@ -14,9 +13,6 @@
 #include "base/task_runner.h"
 #include "base/threading/thread_restrictions.h"
 #include "build/build_config.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
 #include "net/base/load_flags.h"
 #include "net/base/mime_util.h"
 #include "net/base/net_errors.h"
@@ -24,13 +20,12 @@
 #include "net/http/http_util.h"
 #include "net/url_request/url_request_error_job.h"
 #include "net/url_request/url_request_file_dir_job.h"
-#include "url/gurl.h"
 
 #if defined(OS_WIN)
 #include "base/win/shortcut.h"
 #endif
 
-#include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
 
 namespace net {
 
@@ -46,19 +41,21 @@ URLRequestMmtJob::ReadMetaInfo::ReadMetaInfo() :
 URLRequestMmtJob::URLRequestMmtJob(
     URLRequest* request,
     NetworkDelegate* network_delegate,
-    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
+    const scoped_refptr<base::TaskRunner>& task_runner)
     : URLRequestJob(request, network_delegate),
-      mmt_task_runner_(mmt_task_runner),
+      task_runner_(task_runner),
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::StartCtrlCenter();
+  mmt::StartMmtCtrl();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
 }
 
 void URLRequestMmtJob::Start() {
-  mmt::PostCtrlTask("@open", request_->url(), &URLRequestMmtJob::DoStart, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.func = &URLRequestMmtJob::DoStart;
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -86,8 +83,12 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   }
 
   int rv = ERR_IO_PENDING;
-  mmt::PostCtrlTask("@read", request_->url(), dest, dest_size, read_info_.read_offset,
-    &URLRequestMmtJob::DoRead, (void *)this);
+  mmt::stream_info_t sinfo;
+  sinfo.buf = dest;
+  sinfo.size = dest_size;
+  sinfo.offset = read_info_.read_offset;
+  sinfo.func = &URLRequestMmtJob::DoRead;
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -143,9 +144,10 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, int iret) {
+void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
@@ -185,12 +187,13 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, void* data, int size) {
-  LOG(INFO) << __func__ << " data size=" << size;
+void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+  LOG(INFO) << __func__ << " iret=" << iret << 
+    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
   URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, size));
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
   }
 }
 
@@ -203,10 +206,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     read_info_.read_offset += result;
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
-  mmt::PostCtrlTask("@test", request_->url(), "xyz", "xyz@uskee.org", &content_,
-    &URLRequestMmtJob::DoStore, (void*)this);
-  //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-  //      base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, true));
 
   if (result == 0) {
     NotifyDone(URLRequestStatus());
@@ -217,6 +216,14 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
   NotifyReadComplete(result);
 }
 
+void URLRequestMmtJob::DoTest(void* ptr) {
+}
+
+void URLRequestMmtJob::DidTest(void* ptr) {
+}
+
+
+/// for storage testing
 void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     LOG(INFO) << __func__ << " set value";
     std::string szkey = "xyz";
@@ -225,32 +232,8 @@ void URLRequestMmtJob::StorageCallback(ValueStore* storage) {
     value.reset(new base::StringValue(szvalue));
     storage->Set(ValueStore::DEFAULTS, szkey, *value);
 }
-void URLRequestMmtJob::DoStore(void* ptr, std::string key, std::string value, mmt::Content* content) {
-  LOG(INFO) << __func__ << " key=" << key << " value=" << value;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
-  if (thiz) {
-    thiz->kvstoring_.first = key;
-    thiz->kvstoring_.second = value;
-    mmt::Content* pcontent = new mmt::Content;
-    *pcontent = *content;
-    //content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-    //    base::Bind(&URLRequestMmtJob::DidStore, thiz->weak_ptr_factory_.GetWeakPtr()));
-    content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, pcontent, true));
-  }
-}
-void URLRequestMmtJob::DidStore() {
-  LOG(INFO) << __func__;
-  GetRenderFrameInfo(&content_, true);
-}
-
-void URLRequestMmtJob::DoTest(void* ptr) {
-}
-
-void URLRequestMmtJob::DidTest(void* ptr) {
-}
 
-bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* request) {
+bool URLRequestMmtJob::GetRequestID(mmt::content_t* content, const URLRequest* request) {
     if (!content) return false;
     const content::ResourceRequestInfo* rinfo = 
         content::ResourceRequestInfo::ForRequest(request);
@@ -267,7 +250,7 @@ bool URLRequestMmtJob::GetRequestID(mmt::Content* content, const URLRequest* req
     return is_ok;
 }
 
-bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserContext* context) {
+bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserContext* context) {
     if (!content) return false;
     extensions::StorageFrontend* frontend = extensions::StorageFrontend::Get(context);
     if (!frontend) {
@@ -295,7 +278,7 @@ bool URLRequestMmtJob::GetExtension(mmt::Content* content, content::BrowserConte
     return true;
 }
 
-void URLRequestMmtJob::GetRenderFrameInfo(mmt::Content* content, bool has_storage) {
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
     if (!content) return;
     content->tab_id = -1;
     content->tab_url = "";
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 6d3e3da..25ee072 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -15,7 +15,9 @@
 #include "net/http/http_byte_range.h"
 #include "net/url_request/url_request.h"
 #include "net/url_request/url_request_job.h"
+
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_control.h"
 
 namespace base {
 class TaskRunner;
@@ -63,31 +65,27 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     std::string uri;
   };
 
-  static void DoStart(void* ptr, int iret);
+  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, void* data, int size);
+  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
 
-  static void StorageCallback(ValueStore* storage);
-  static void DoStore(void* ptr, std::string key, std::string value, mmt::Content* content);
-  void DidStore();
-
   // get info for render
-  static bool GetRequestID(mmt::Content* content, const URLRequest* request);
-  static bool GetExtension(mmt::Content* content, content::BrowserContext* context);
-  static void GetRenderFrameInfo(mmt::Content* content, bool has_storage);
+  static void StorageCallback(ValueStore* storage);
+  static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
+  static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
+  static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
 
  private:
-  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
 
   HttpByteRange byte_range_;
   ReadMetaInfo read_info_;
-  mmt::Content content_;
-  std::pair<std::string, std::string> kvstoring_;
+  mmt::content_t content_;
 
   base::WeakPtrFactory<URLRequestMmtJob> weak_ptr_factory_;
 
-- 
1.7.9.5


From 3e265c6c92f0a6ce0b9006f8fa1bed688c8072c9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 02:41:17 -0800
Subject: [PATCH 032/128] refine cictrl to support native msg

---
 .../docs/examples/api/cictrl/background.js         |   60 +++++++-
 .../docs/examples/api/cictrl/content_scripts.js    |   16 +--
 .../docs/examples/api/cictrl/manifest.json         |    6 +-
 .../docs/examples/api/cictrl/res/install_host.sh   |   40 ++++++
 .../api/cictrl/res/native-messaging-cictrl         |  151 ++++++++++++++++++++
 .../api/cictrl/res/org.chromium.cictrl.json        |   13 ++
 .../docs/examples/api/cictrl/res/uninstall_host.sh |   25 ++++
 7 files changed, 297 insertions(+), 14 deletions(-)
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
 create mode 100644 chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
 create mode 100755 chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/background.js b/chrome/common/extensions/docs/examples/api/cictrl/background.js
index e6b3978..7f2c324 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/background.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/background.js
@@ -1,15 +1,69 @@
+var port = null;
 
 function log(msg) {
+  msg = "[CI] " + msg;
   //alert(msg);
   console.log(msg);
 }
 
+function sendNativeMessage(message) {
+  if (port == null) return;
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+  port.postMessage(message);
+}
+function onNativeMessage(message) {
+  if(typeof(message) != "object") {
+    logMsg(typeof(message) + " is not a json object");
+    return;
+  }
+
+  tabid = message["tabid"];
+  if (tabid == undefined) {
+    logMsg("no valid tabid");
+    return;
+  }
+
+  js = message["js"];
+  if (js != undefined) {
+    chrome.tabs.executeScript(tabid, {code: js});
+  }
+
+  css = message["css"];
+  if (css != undefined) {
+    chrome.tabs.insertCSS(tabid, {code: css});
+  }
+}
+
+function onDisconnected() {
+  port = null;
+}
+
+function connect() {
+  var hostName = "org.chromium.cictrl";
+  port = chrome.runtime.connectNative(hostName);
+  log("port=" + port);
+  if (port != null) {
+    port.onMessage.addListener(onNativeMessage);
+    port.onDisconnect.addListener(onDisconnected);
+  }
+}
+
+// listen tab event
+chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
+  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
+    log("tabs complete id=" + tab.id);
+  }
+});
+
+// listen message
 chrome.runtime.onMessage.addListener(function(request, sender, sendResponse) {
     log(sender.tab ? "from a content script:" + sender.tab.url + " id=" + sender.tab.id : "from the extension");
     if (request.greeting == "hello" && sender.tab) {
+        log("recv msg from tabs id=" + sender.tab.id);
+        connect();
         sendResponse({farewell: "goodbye"});
-        chrome.tabs.executeScript(sender.tab.id, {
-            code: 'document.body.style.backgroundColor="red"'
-        });
     }
 });
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
index a73420c..745d2ff 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -1,12 +1,12 @@
-// detect the changes of storage and apply them into current page
-
 function log(msg) {
     //alert(msg);
     console.log(msg);
 }
 
 // for chrome.storage.local
+// chrome.storage.StorageArea.get()/set()/remove()/clear()
 chrome.storage.onChanged.addListener(function(changes, namespace) {
+    log("storage.onChanged");
     if (namespace != "local") {
         log("donot process the namespace = " + namespace);
         return;
@@ -14,17 +14,13 @@ chrome.storage.onChanged.addListener(function(changes, namespace) {
 
     for (key in changes) {
         var storageChange = changes[key];
-        log('Storage key "%s" in namespace "%s" changed. ' +
-            'Old value was "%s", new value is "%s".',
-            key,
-            namespace,
-            storageChange.oldValue,
-            storageChange.newValue);
+        log("Storage key " + key + " in namespace " + namespace + " changed. " +
+            "Old value was " + storageChange.oldValue + ", new value is " + storageChange.newValue);
     }
 });
 
-// chrome.storage.StorageArea.get()/set()/remove()/clear()
-// document.readyState == "loading/interactive/complete"; it can ensure this script to be ran after window.onload
+// document.readyState == "loading/interactive/complete"; 
+// it can ensure this script to be ran after window.onload
 window.onload = function() {
     log("window.onload");
     chrome.runtime.sendMessage({greeting: "hello"}, function(response) {
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
index e955013..e86769b 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -1,12 +1,16 @@
 {
+    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
     "name" : "org.chromium.cictrl",
     "version": "1.0",
     "manifest_version": 2,
     "description": "chromium ci control",
     "permissions": [
+        "mmt://*/*",
         "file://*/*",
         "http://*/*",
-        "mmt://*/*",
+        "https://*/",
+        "nativeMessaging",
+        "notifications",
         "tabs", 
         "storage"
     ],
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
new file mode 100755
index 0000000..85f19b0
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/install_host.sh
@@ -0,0 +1,40 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+DIR="$( cd "$( dirname "$0" )" && pwd )"
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+
+# Create directory to store native messaging host.
+mkdir -p $TARGET_DIR
+
+# Copy native messaging host manifest.
+cp $DIR/$HOST_NAME.json $TARGET_DIR
+
+# Update host path in the manifest.
+HOST_PATH=$DIR/native-messaging-cictrl
+ESCAPED_HOST_PATH=${HOST_PATH////\\/}
+sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
+
+# Set permissions for the manifest so that all users can read it.
+chmod o+r $TARGET_DIR/$HOST_NAME.json
+
+echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
new file mode 100755
index 0000000..05279a2
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -0,0 +1,151 @@
+#!/usr/bin/env python
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+# A simple native messaging host. Shows a Tkinter dialog with incoming messages
+# that also allows to send message back to the webapp.
+
+import struct
+import sys
+import threading
+import Queue
+
+import time
+import socket
+from json import JSONDecoder
+
+gDaemon = True
+try:
+  import Tkinter
+  import tkMessageBox
+except ImportError:
+  Tkinter = None
+
+# Helper function that sends a message to the webapp.
+def send_message(message):
+  # message must be JSON string
+  if len(message) < 16: return
+  jdata = JSONDecoder().decode(message)
+  if not jdata: return
+
+  # Write message size.
+  sys.stdout.write(struct.pack('I', len(message)))
+  # Write the message itself.
+  sys.stdout.write(message)
+  try:
+    sys.stdout.flush()
+  except: return
+
+# Thread that reads messages from control point
+def read_ctrl_func():
+  host = "localhost"
+  port = 54321
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.sendto("@quit", (host,port))
+  sock.close()
+  time.sleep(3)
+  
+  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
+  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+  sock.bind((host, port))
+  while True:
+    msg, addr = sock.recvfrom(65536)
+    if msg[:5] == "@quit":
+      break
+    send_message(msg)
+  sock.close()
+
+# Thread that reads messages from the webapp.
+def read_thread_func(queue):
+  while True:
+    # Read the message length (first 4 bytes).
+    text_length_bytes = sys.stdin.read(4)
+    if len(text_length_bytes) == 0:
+      if queue: queue.put(None)
+      sys.exit(0)
+
+    # Unpack message length as 4 byte integer.
+    text_length = struct.unpack('i', text_length_bytes)[0]
+    # Read the text (JSON object) of the message.
+    text = sys.stdin.read(text_length).decode('utf-8')
+    if queue: queue.put(text)
+
+if Tkinter:
+  class NativeMessagingWindow(Tkinter.Frame):
+    def __init__(self, queue):
+      self.queue = queue
+
+      Tkinter.Frame.__init__(self)
+      self.pack()
+
+      self.text = Tkinter.Text(self)
+      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
+      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
+
+      self.messageContent = Tkinter.StringVar()
+      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
+      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
+
+      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
+      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
+
+      self.after(100, self.processMessages)
+
+    def processMessages(self):
+      while not self.queue.empty():
+        message = self.queue.get_nowait()
+        if message == None:
+          self.quit()
+          return
+        self.log("Received %s" % message)
+
+      self.after(100, self.processMessages)
+
+    def onSend(self):
+      #text = '{"text": "' + self.messageContent.get() + '"}'
+      text = self.messageContent.get()
+      self.log('Sending %s' % text)
+      try:
+        send_message(text)
+      except IOError:
+        tkMessageBox.showinfo('Native Messaging Example',
+                              'Failed to send message.')
+        sys.exit(1)
+
+    def log(self, message):
+      self.text.config(state=Tkinter.NORMAL)
+      self.text.insert(Tkinter.END, message + "\n")
+      self.text.config(state=Tkinter.DISABLED)
+
+def Daemon():
+  queue = Queue.Queue()
+  rthread = threading.Thread(target=read_thread_func, args=(queue,))
+  rthread.daemon = True
+  rthread.start()
+  read_ctrl_func()
+  sys.exit(0)
+
+def Main():
+  if not Tkinter:
+    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
+                 'mode. Please consider installing Tkinter."')
+    read_thread_func(None)
+    sys.exit(0)
+
+  queue = Queue.Queue()
+  main_window = NativeMessagingWindow(queue)
+  main_window.master.title('Native Messaging Example')
+
+  thread = threading.Thread(target=read_thread_func, args=(queue,))
+  thread.daemon = True
+  thread.start()
+
+  main_window.mainloop()
+  sys.exit(0)
+
+
+if __name__ == '__main__':
+  if gDaemon:   Daemon()
+  else:         Main()
+
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
new file mode 100644
index 0000000..26aaa64
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/org.chromium.cictrl.json
@@ -0,0 +1,13 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+{
+  "name": "org.chromium.cictrl",
+  "description": "Chromium Native Messaging For CI Control",
+  "path": "HOST_PATH",
+  "type": "stdio",
+  "allowed_origins": [
+    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
+  ]
+}
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
new file mode 100755
index 0000000..52f9909
--- /dev/null
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+# Copyright 2013 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+set -e
+
+if [ $(uname -s) == 'Darwin' ]; then
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/Library/Google/Chromium/NativeMessagingHosts"
+  else
+    TARGET_DIR=\
+        "$HOME/Library/Application Support/Chromoium/NativeMessagingHosts"
+  fi
+else
+  if [ "$(whoami)" == "root" ]; then
+    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
+  else
+    TARGET_DIR='$HOME/.config/chromium/NativeMessagingHosts'
+  fi
+fi
+
+HOST_NAME=org.chromium.cictrl
+rm $TARGET_DIR/org.chromium.cictrl.json
+echo Native messaging host $HOST_NAME has been uninstalled.
-- 
1.7.9.5


From 4150cc290d8ebe02dba5b62153cefac877814b7a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 03:06:43 -0800
Subject: [PATCH 033/128] try to fix mmt_stream read error

---
 net/mmt/mmt_control.cc                 |    2 +-
 net/mmt/mmt_stream.cc                  |    9 ++++++---
 net/url_request/url_request_mmt_job.cc |    1 +
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index cd6274c..f7eba41 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -124,7 +124,7 @@ void MmtControl::Run() {
                 }
             }
         }
-        Wait(100);
+        Wait(10);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6e5be76..1674c20 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -51,9 +51,11 @@ bool Stream::Init() {
 
 bool Stream::Prepare(long *size) {
     if (!Init()) return false;
-    fseek(file_, 0L, SEEK_END);
+    int ierr = fseek(file_, 0L, SEEK_END);
     long lret = ftell(file_);
-    *size = lret;
+    if (size)
+        *size = lret;
+    LOG(INFO) << __func__ << " ierr=" << ierr << " lret=" << lret;
     return true;
 }
 
@@ -62,7 +64,8 @@ int Stream::Read(char *buf, int size, int offset) {
     int ierr = fseek(file_, offset, SEEK_SET);
     int iret = fread(buf, 1, size, file_);
     if (iret <= 0) {
-        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret;
+        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret 
+            << " size=" << size << " offset=" << offset;
     }
     return iret; 
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index b985b58..85bbe58 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -145,6 +145,7 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 
 URLRequestMmtJob::~URLRequestMmtJob() {
   LOG(INFO) << __func__ << " thiz=" << this;
+  mmt::PostCtrlTask("@close", request_->url());
 }
 
 void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
-- 
1.7.9.5


From 22e6e75525838282b935c22dd7b98433b7706ce4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 04:59:30 -0800
Subject: [PATCH 034/128] fix read error

---
 net/mmt/mmt_control.cc                 |    6 +++---
 net/mmt/mmt_control.h                  |    9 ++++++---
 net/mmt/mmt_inc.h                      |    1 +
 net/url_request/url_request_mmt_job.cc |   16 +++++++++-------
 net/url_request/url_request_mmt_job.h  |    6 +++---
 5 files changed, 22 insertions(+), 16 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index f7eba41..516dee8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -40,11 +40,11 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     PostCtrlMsg(msg);
 }
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr) {
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.sinfo = sinfo;
-    msg.ptr= ptr;
+    msg.ptr = ptr;
     msg.uri = GURL2FilePath(gurl);
     PostCtrlMsg(msg);
 }
@@ -118,7 +118,7 @@ void MmtControl::Run() {
                     << " uri=" << uri
                     << " size=" << msg.sinfo.size 
                     << " offset=" << msg.sinfo.offset 
-                    << " ptr=" << msg.ptr;
+                    << " ptr=" << msg.ptr.get();
                 if (msg.sinfo.func) {
                     msg.sinfo.func(msg.ptr, msg.sinfo, iret);
                 }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f02c47c..635328e 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -6,13 +6,16 @@
 
 namespace net {
 class IOBuffer;
+class URLRequestJob;
 }
 
 namespace mmt {
 
 struct stream_info_t;
+typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
+
 // (ptr, stream_info_t, errno)
-typedef void (*stream_func_t)(void*, stream_info_t&, int);
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
 struct stream_info_t {
     net::IOBuffer*  buf;
     int             size;
@@ -28,7 +31,7 @@ struct ctrl_msg_t {
     std::string body;
     std::string uri;
     int   tabid;
-    void* ptr;
+    job_refptr_t ptr;
 
     stream_info_t sinfo;
 };
@@ -65,7 +68,7 @@ void PostCtrlTask(std::string head, GURL gurl);
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, void* ptr);
+void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index f5ba4f7..6bec3f4 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -13,6 +13,7 @@
 #include "net/base/io_buffer.h"
 #include "net/base/filename_util.h"
 #include "net/udp/udp_socket.h"
+#include "net/url_request/url_request_job.h"
 
 #include "extensions/common/extension.h"
 #include "extensions/browser/extension_system.h"
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 85bbe58..a3d4b6f 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -47,6 +47,7 @@ URLRequestMmtJob::URLRequestMmtJob(
       weak_ptr_factory_(this) {
   LOG(INFO) << __func__ << " thiz=" << this;
   mmt::StartMmtCtrl();
+  read_info_.url = request_->url();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
         base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
@@ -55,7 +56,7 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   mmt::stream_info_t sinfo;
   sinfo.func = &URLRequestMmtJob::DoStart;
-  mmt::PostCtrlTask("@open", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, this);
 }
 
 void URLRequestMmtJob::Kill() {
@@ -88,7 +89,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
-  mmt::PostCtrlTask("@read", request_->url(), sinfo, (void *)this);
+  mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -144,13 +145,14 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
+  LOG(INFO) << __func__ << " begin thiz=" << this;
+  mmt::PostCtrlTask("@close", read_info_.url);
   LOG(INFO) << __func__ << " thiz=" << this;
-  mmt::PostCtrlTask("@close", request_->url());
 }
 
-void URLRequestMmtJob::DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
@@ -188,10 +190,10 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret) {
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
-  URLRequestMmtJob* thiz = (URLRequestMmtJob *)ptr;
+  scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
         base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index 25ee072..dd34d13 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -62,13 +62,13 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
 
     IOBuffer* dest;
     int32 dest_size;
-    std::string uri;
+    GURL url;
   };
 
-  static void DoStart(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidStart(int iret);
 
-  static void DoRead(void* ptr, mmt::stream_info_t& sinfo, int iret);
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
   void DidRead(net::IOBuffer* iobuf, int size);
 
   static void DoTest(void* ptr);
-- 
1.7.9.5


From 0dfe33f0e0532f705868d1d620b3c01031c05115 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 23:48:36 -0800
Subject: [PATCH 035/128] refine url_request and mmt

---
 net/mmt/mmt_control.cc                  |   41 ++++++++++++++++++++++---------
 net/mmt/mmt_control.h                   |    4 +--
 net/url_request/mmt_protocol_handler.cc |   10 +++++---
 net/url_request/mmt_protocol_handler.h  |    4 +--
 net/url_request/url_request_mmt_job.cc  |    4 +--
 5 files changed, 40 insertions(+), 23 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 516dee8..464548f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -22,13 +22,6 @@ void PostCtrlMsg(ctrl_msg_t &msg) {
     g_ctrl->Push(msg);
 }
 
-// for @close
-void PostCtrlTask(std::string head, GURL gurl) {
-    ctrl_msg_t msg;
-    msg.head = head;
-    msg.uri = GURL2FilePath(gurl);
-    PostCtrlMsg(msg);
-}
 
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
@@ -39,6 +32,14 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.uri = GURL2FilePath(gurl);
     PostCtrlMsg(msg);
 }
+// for @close
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
+    ctrl_msg_t msg;
+    msg.head = head;
+    msg.ptr = refptr;
+    msg.uri = GURL2FilePath(gurl);
+    PostCtrlMsg(msg);
+}
 // for @open and @read
 void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
@@ -70,6 +71,14 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
+static std::string mmtjob_key(std::string name, void* ptr) {
+    std::stringstream sstr;
+    sstr << name << "@" << ptr;
+    std::string key;
+    sstr >> key;
+    return key;
+}
+
 MmtControl::MmtControl() : SimpleThread("mmt_control"){
     running_ = false;
 }
@@ -81,34 +90,42 @@ void MmtControl::Run() {
     while(loop_) {
         ctrl_msg_t msg;
         if (!Pop(msg)) {
-            Wait(500);
+            Wait(100);
             continue;
         }
 
         std::string head = msg.head;
         std::string uri = msg.uri;
-        LOG(INFO) << __func__ << " head=" << head << " uri=" << uri;
 
         if (head == "@ctrl") {
             PostNativeMsg(msg.body);
         }else if (head == "@test") {
             //..
         }else if (msg.head == "@open") {
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
             StreamPtr stream = new Stream(uri);
-            streams_.insert(stream_t(uri, stream));
+            streams_.insert(stream_t(key, stream));
             long lsize = -1;
             stream->Prepare(&lsize);
             if (msg.sinfo.func) {
                 msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
             }
         }else if (msg.head == "@close") {
-            streams_t::iterator iter = streams_.find(uri);
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
+            streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 streams_.erase(iter);
             }
         }else if (msg.head == "@read") {
-            streams_t::iterator iter = streams_.find(uri);
+            std::string key = mmtjob_key(uri, msg.ptr.get());
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+
+            streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 635328e..00a88ef 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -63,10 +63,10 @@ namespace mmt {
 void StartMmtCtrl();
 void PostNativeMsg(std::string msg);
 
-// for @close
-void PostCtrlTask(std::string head, GURL gurl);
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
+// for @close
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
 // for @open and @read
 void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
diff --git a/net/url_request/mmt_protocol_handler.cc b/net/url_request/mmt_protocol_handler.cc
index 19a5fbb..69f64f4 100644
--- a/net/url_request/mmt_protocol_handler.cc
+++ b/net/url_request/mmt_protocol_handler.cc
@@ -14,14 +14,16 @@
 namespace net {
 
 MmtProtocolHandler::MmtProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& mmt_task_runner)
-    : mmt_task_runner_(mmt_task_runner) {}
+    const scoped_refptr<base::TaskRunner>& task_runner)
+    : task_runner_(task_runner) {}
 
-MmtProtocolHandler::~MmtProtocolHandler() {}
+MmtProtocolHandler::~MmtProtocolHandler() {
+  LOG(INFO) << __func__;
+}
 
 URLRequestJob* MmtProtocolHandler::MaybeCreateJob(
     URLRequest* request, NetworkDelegate* network_delegate) const {
-  return new URLRequestMmtJob(request, network_delegate, mmt_task_runner_);
+  return new URLRequestMmtJob(request, network_delegate, task_runner_);
 }
 
 bool MmtProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
diff --git a/net/url_request/mmt_protocol_handler.h b/net/url_request/mmt_protocol_handler.h
index a823916..9ad37af 100644
--- a/net/url_request/mmt_protocol_handler.h
+++ b/net/url_request/mmt_protocol_handler.h
@@ -27,7 +27,7 @@ class NET_EXPORT MmtProtocolHandler :
     public URLRequestJobFactory::ProtocolHandler {
  public:
   explicit MmtProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& mmt_task_runner);
+      const scoped_refptr<base::TaskRunner>& task_runner);
   ~MmtProtocolHandler() override;
   URLRequestJob* MaybeCreateJob(
       URLRequest* request,
@@ -35,7 +35,7 @@ class NET_EXPORT MmtProtocolHandler :
   bool IsSafeRedirectTarget(const GURL& location) const override;
 
  private:
-  const scoped_refptr<base::TaskRunner> mmt_task_runner_;
+  const scoped_refptr<base::TaskRunner> task_runner_;
   DISALLOW_COPY_AND_ASSIGN(MmtProtocolHandler);
 };
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index a3d4b6f..e920fed 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -60,7 +60,7 @@ void URLRequestMmtJob::Start() {
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::PostCtrlTask("@close", request_->url());
+  mmt::PostCtrlTask("@close", request_->url(), this);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -145,8 +145,6 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
 }
 
 URLRequestMmtJob::~URLRequestMmtJob() {
-  LOG(INFO) << __func__ << " begin thiz=" << this;
-  mmt::PostCtrlTask("@close", read_info_.url);
   LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-- 
1.7.9.5


From dc08539e5fcd696ddd757887c73b67b556b9cfc1 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 18 Jan 2015 23:57:56 -0800
Subject: [PATCH 036/128] [ok] fixed read crash

---
 net/url_request/url_request_job.cc |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/net/url_request/url_request_job.cc b/net/url_request/url_request_job.cc
index 2deb0f5..e740b25 100644
--- a/net/url_request/url_request_job.cc
+++ b/net/url_request/url_request_job.cc
@@ -49,8 +49,10 @@ URLRequestJob::URLRequestJob(URLRequest* request,
       network_delegate_(network_delegate),
       weak_factory_(this) {
   base::PowerMonitor* power_monitor = base::PowerMonitor::Get();
-  if (power_monitor)
+  if (power_monitor) {
+    power_monitor->RemoveObserver(this);
     power_monitor->AddObserver(this);
+  }
 }
 
 void URLRequestJob::SetUpload(UploadDataStream* upload) {
-- 
1.7.9.5


From 4179176ababfe8153b923c206d74b12b3c7f13ce Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 00:28:51 -0800
Subject: [PATCH 037/128] [ok] refine for mmt play

---
 net/mmt/mmt_control.cc                 |   15 ++++++++++-----
 net/mmt/mmt_stream.cc                  |    4 ++--
 net/url_request/url_request_mmt_job.cc |    4 ++++
 3 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 464548f..80259f8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -87,10 +87,11 @@ MmtControl::~MmtControl() {}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
+    int ms = 100;
     while(loop_) {
         ctrl_msg_t msg;
         if (!Pop(msg)) {
-            Wait(100);
+            Wait(ms);
             continue;
         }
 
@@ -103,7 +104,7 @@ void MmtControl::Run() {
             //..
         }else if (msg.head == "@open") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             StreamPtr stream = new Stream(uri);
             streams_.insert(stream_t(key, stream));
@@ -112,23 +113,26 @@ void MmtControl::Run() {
             if (msg.sinfo.func) {
                 msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
             }
+            ms = 100;
         }else if (msg.head == "@close") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 streams_.erase(iter);
             }
+            ms = 100;
         }else if (msg.head == "@read") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
                 StreamPtr stream = iter->second;
                 int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+#if 0
                 LOG(INFO) << __func__ 
                     << " head=" << head 
                     << " iret=" << iret 
@@ -136,12 +140,13 @@ void MmtControl::Run() {
                     << " size=" << msg.sinfo.size 
                     << " offset=" << msg.sinfo.offset 
                     << " ptr=" << msg.ptr.get();
+#endif
                 if (msg.sinfo.func) {
                     msg.sinfo.func(msg.ptr, msg.sinfo, iret);
                 }
             }
+            ms = 10;
         }
-        Wait(10);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1674c20..524e8c5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -31,7 +31,7 @@ namespace mmt {
 
 Stream::Stream(const std::string &uri) 
     : uri_(uri), file_(nullptr) { 
-    LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
+    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
 }
 
 Stream::~Stream() {
@@ -71,7 +71,7 @@ int Stream::Read(char *buf, int size, int offset) {
 }
 
 void Stream::Uninit() {
-    LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
+    //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     if (file_) fclose(file_);
     file_ = nullptr;
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index e920fed..9222356 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -189,8 +189,10 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
+#if 0
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
+#endif
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -199,7 +201,9 @@ void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo,
 }
 
 void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+#if 0
   LOG(INFO) << __func__ << " data size=" << size;
+#endif
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
-- 
1.7.9.5


From bb985498de4cf9bc385c865e13faffb04e349d4c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 04:49:13 -0800
Subject: [PATCH 038/128] refine ctrl

---
 net/mmt/mmt_control.cc                 |    5 +++--
 net/mmt/mmt_stream.cc                  |    5 +++++
 net/url_request/url_request_mmt_job.cc |    2 --
 3 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 80259f8..77c6e9b 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -104,7 +104,7 @@ void MmtControl::Run() {
             //..
         }else if (msg.head == "@open") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             StreamPtr stream = new Stream(uri);
             streams_.insert(stream_t(key, stream));
@@ -116,7 +116,7 @@ void MmtControl::Run() {
             ms = 100;
         }else if (msg.head == "@close") {
             std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
+            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
 
             streams_t::iterator iter = streams_.find(key);
             if (iter != streams_.end()) {
@@ -147,6 +147,7 @@ void MmtControl::Run() {
             }
             ms = 10;
         }
+        Wait(ms);
     };
     running_ = false;
     LOG(INFO) << __func__ << " end";
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 524e8c5..e3387c1 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -19,6 +19,11 @@ std::string GURL2String(GURL& gurl) {
 }
 
 content_t::content_t() {
+    process_id = 0;
+    frame_id = 0;
+    routing_id = 0;
+    tab_id = 0;
+    tab_url = "";
 }
 content_t::~content_t() {
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 9222356..4254650 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -189,10 +189,8 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-#if 0
   LOG(INFO) << __func__ << " iret=" << iret << 
     " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
-#endif
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-- 
1.7.9.5


From 5e93f5396d4ae5e24402ec5bbc28befc0e65701f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 06:25:26 -0800
Subject: [PATCH 039/128] refine ctrl 2

---
 net/mmt/mmt_control.cc |  103 ++++++++++++++++++++++++++----------------------
 net/mmt/mmt_control.h  |   10 ++++-
 net/mmt/mmt_inc.h      |    2 -
 net/mmt/mmt_stream.cc  |   11 ------
 4 files changed, 63 insertions(+), 63 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 77c6e9b..468ff55 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -29,7 +29,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.head = head;
     msg.body = body;
     msg.tabid = tabid;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @close
@@ -37,7 +37,7 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.ptr = refptr;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @open and @read
@@ -46,7 +46,7 @@ void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_
     msg.head = head;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
-    msg.uri = GURL2FilePath(gurl);
+    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 
@@ -59,7 +59,6 @@ namespace mmt {
 ctrl_msg_t::ctrl_msg_t() {
     head = "";
     body = "";
-    uri = "";
     tabid = -1;
     ptr = nullptr;
 
@@ -71,7 +70,8 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
-static std::string mmtjob_key(std::string name, void* ptr) {
+static std::string mmtjob_key(GURL url, void* ptr) {
+    std::string name = url.spec();
     std::stringstream sstr;
     sstr << name << "@" << ptr;
     std::string key;
@@ -84,6 +84,52 @@ MmtControl::MmtControl() : SimpleThread("mmt_control"){
 }
 MmtControl::~MmtControl() {}
 
+// for I/O stream
+void MmtControl::StreamOpen(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    // TODO: for local file testing
+    long lsize = -1;
+    StreamPtr stream = new Stream(msg.url.spec());
+    streams_.insert(stream_t(key, stream));
+    stream->Prepare(&lsize);
+    if (msg.sinfo.func) {
+        msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+    }
+}
+void MmtControl::StreamRead(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    streams_t::iterator iter = streams_.find(key);
+    if (iter != streams_.end()) {
+        StreamPtr stream = iter->second;
+        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+#if 0
+        LOG(INFO) << __func__ 
+            << " head=" << head 
+            << " iret=" << iret 
+            << " url=" << url
+            << " size=" << msg.sinfo.size 
+            << " offset=" << msg.sinfo.offset 
+            << " ptr=" << msg.ptr.get();
+#endif
+        if (msg.sinfo.func) {
+            msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+        }
+    }
+}
+void MmtControl::StreamClose(ctrl_msg_t msg) {
+    std::string key = mmtjob_key(msg.url, msg.ptr.get());
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+
+    streams_t::iterator iter = streams_.find(key);
+    if (iter != streams_.end()) {
+        StreamPtr stream = iter->second;
+        streams_.erase(iter);
+    }
+}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
@@ -96,55 +142,17 @@ void MmtControl::Run() {
         }
 
         std::string head = msg.head;
-        std::string uri = msg.uri;
-
         if (head == "@ctrl") {
             PostNativeMsg(msg.body);
-        }else if (head == "@test") {
-            //..
+            ms = 100;
         }else if (msg.head == "@open") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            StreamPtr stream = new Stream(uri);
-            streams_.insert(stream_t(key, stream));
-            long lsize = -1;
-            stream->Prepare(&lsize);
-            if (msg.sinfo.func) {
-                msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
-            }
+            StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            streams_t::iterator iter = streams_.find(key);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                streams_.erase(iter);
-            }
+            StreamClose(msg);
             ms = 100;
         }else if (msg.head == "@read") {
-            std::string key = mmtjob_key(uri, msg.ptr.get());
-            //LOG(INFO) << __func__ << " head=" << head << " key=" << key;
-
-            streams_t::iterator iter = streams_.find(key);
-            if (iter != streams_.end()) {
-                StreamPtr stream = iter->second;
-                int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
-#if 0
-                LOG(INFO) << __func__ 
-                    << " head=" << head 
-                    << " iret=" << iret 
-                    << " uri=" << uri
-                    << " size=" << msg.sinfo.size 
-                    << " offset=" << msg.sinfo.offset 
-                    << " ptr=" << msg.ptr.get();
-#endif
-                if (msg.sinfo.func) {
-                    msg.sinfo.func(msg.ptr, msg.sinfo, iret);
-                }
-            }
+            StreamRead(msg);
             ms = 10;
         }
         Wait(ms);
@@ -171,7 +179,6 @@ bool MmtControl::Pop(ctrl_msg_t &msg) {
 }
 
 void MmtControl::Push(ctrl_msg_t &msg) {
-    //LOG(INFO) << __func__;
     lock_.Acquire();
     queue_.insert(queue_.begin(), msg);
     lock_.Release();
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 00a88ef..da9ee23 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -29,8 +29,8 @@ struct ctrl_msg_t {
 
     std::string head;
     std::string body;
-    std::string uri;
-    int   tabid;
+    GURL url;
+    int tabid;
     job_refptr_t ptr;
 
     stream_info_t sinfo;
@@ -47,6 +47,12 @@ public:
     bool Pop(ctrl_msg_t& msg);
     void Push(ctrl_msg_t& msg);
 
+protected:
+    // operations for I/O stream
+    void StreamOpen(ctrl_msg_t msg);
+    void StreamRead(ctrl_msg_t msg);
+    void StreamClose(ctrl_msg_t msg);
+
 private:
     bool loop_;
     bool running_;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 6bec3f4..e87612a 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -34,8 +34,6 @@
 
 namespace mmt{
 void Wait(int ms);
-std::string GURL2FilePath(GURL& gurl);
-std::string GURL2String(GURL& gurl);
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e3387c1..2004741 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,17 +6,6 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-std::string GURL2FilePath(GURL& gurl) {
-    std::string url;
-    base::FilePath file_path;
-    net::FileURLToFilePath(gurl, &file_path);
-    return file_path.value();
-}
-std::string GURL2String(GURL& gurl) {
-    std::ostringstream sstr;
-    sstr << gurl;
-    return sstr.str();
-}
 
 content_t::content_t() {
     process_id = 0;
-- 
1.7.9.5


From dbf1a55b79e846e7b2631e77fb507a14a33920b4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 19 Jan 2015 22:24:40 -0800
Subject: [PATCH 040/128] todo: for sequence

---
 net/mmt/mmt_control.cc |    2 +-
 net/mmt/mmt_inc.h      |    2 +
 net/mmt/mmt_stream.cc  |  194 +++++++++++++++++++++++++++++++++++++++++++-----
 net/mmt/mmt_stream.h   |   20 ++++-
 4 files changed, 196 insertions(+), 22 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 468ff55..a66abf6 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -91,7 +91,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
 
     // TODO: for local file testing
     long lsize = -1;
-    StreamPtr stream = new Stream(msg.url.spec());
+    StreamPtr stream = new Stream(msg.url);
     streams_.insert(stream_t(key, stream));
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index e87612a..ebe8715 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -3,6 +3,7 @@
 
 #include <string>
 #include <sstream>
+#include <iomanip>
 
 #include "base/values.h"
 #include "base/strings/utf_string_conversions.h"
@@ -34,6 +35,7 @@
 
 namespace mmt{
 void Wait(int ms);
+std::string GURL2FilePath(GURL gurl);
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 2004741..5c93597 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,6 +6,61 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
+std::string Int2String(int value, int width=0) {
+    std::string szval;
+    std::stringstream sstr;
+    if (width == 0)
+        sstr << value;
+    else
+        sstr << std::setfill('0') << std::setw(width)<< value;
+    sstr >> szval;
+    return szval;
+}
+int String2Int(std::string value) {
+    int ival = -1;
+    std::stringstream sstr;
+    sstr << value;
+    sstr >> ival;
+    return ival;
+}
+std::string GURL2FilePath(GURL gurl) {
+    std::string szpath;
+    base::FilePath file_path;
+    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
+    if (is_file) {
+        szpath = file_path.value();
+    }
+    return szpath;
+}
+std::string GetQueryValue(std::string query, std::string key) {
+    std::string value;
+    std::string::size_type begin, end;
+
+    key += "=";
+    begin = query.find(key);
+    if (begin != std::string::npos) {
+        begin += key.size();
+        end = query.find("=", begin);
+        if (end == std::string::npos)
+            end = query.size();
+        value = query.substr(begin, end-begin);
+    }
+    return value;
+}
+bool GetRangeValue(std::string range, int &lval, int &rval) {
+    bool bok = false;
+    std::string lstr = "0";
+    std::string rstr = "9999999";
+    int begin = range.find("-");
+    if (begin >= 0) {
+        lstr = range.substr(0, begin);
+        rstr = range.substr(begin+1, range.size()-begin);
+        bok = true;
+    }
+    lval = String2Int(lstr);
+    rval = String2Int(rstr);
+    return bok;
+}
 
 content_t::content_t() {
     process_id = 0;
@@ -23,51 +78,154 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
-Stream::Stream(const std::string &uri) 
-    : uri_(uri), file_(nullptr) { 
-    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", uri=" << uri_;
+Stream::Stream(const GURL &url) 
+    : url_(url), file_(nullptr) { 
+    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
+    midx_.begin = -1;
+    midx_.end = -1;
+    midx_.cur = -1;
 }
 
 Stream::~Stream() {
     Uninit();
 }
 
-std::string Stream::getUri() {
-    return uri_;
+GURL Stream::getUrl() {
+    return url_;
 }
 
 bool Stream::Init() {
     if (file_) return true;
-    file_ = fopen(uri_.c_str(), "rb");
-    if (file_) return true;
-    return false;
-}
 
+    // default file if it is html
+    std::string fname = GURL2FilePath(url_);
+
+    if (midx_.cur == -1) {
+        // if exists query, then should redirect to real file name
+        std::string query = url_.query();
+        if (!query.empty()) { // media sequence
+            std::string mtype = GetQueryValue(query, "type");
+            if (mtype.empty()) return false;
+
+            // compute the sequence of media
+            if (midx_.begin < 0 || midx_.end < 0) {
+                std::string range = GetQueryValue(query, "sequence_num");
+                GetRangeValue(range, midx_.begin, midx_.end);
+            }
+
+            // choose the current sequence
+            midx_.cur = midx_.begin;
+        }
+    }
+
+    if (midx_.cur >= 0) {
+        if (midx_.cur < midx_.begin || midx_.cur > midx_.end)
+            return false;
+
+        std::string mtype = GetQueryValue(url_.query(), "type");
+        if (mtype == "audio") {
+            fname = fname + "/Channel1_Audio1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+        }else if (mtype == "video") {
+            fname = fname + "/Channel1_Video1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+        }
+    }
+    file_ = fopen(fname.c_str(), "rb");
+    offmap_[midx_.cur] = offset_t();
+    
+    // compute the file size and its current offset
+    int ierr = fseek(file_, 0L, SEEK_END);
+    offmap_[midx_.cur].size = ftell(file_);
+    offmap_[midx_.cur].off = 0;
+    if (midx_.cur > midx_.begin) { // media sequence
+        offmap_[midx_.cur].off = offmap_[midx_.cur-1].off + offmap_[midx_.cur-1].size;
+    }
+    ierr = fseek(file_, 0L, SEEK_SET);
+
+    return (file_ != nullptr);
+}
 bool Stream::Prepare(long *size) {
     if (!Init()) return false;
-    int ierr = fseek(file_, 0L, SEEK_END);
-    long lret = ftell(file_);
-    if (size)
-        *size = lret;
-    LOG(INFO) << __func__ << " ierr=" << ierr << " lret=" << lret;
+    long lret = 1<<30; // default 1GB
+    if (midx_.cur == -1) {
+        lret = offmap_[midx_.cur].size;
+    }
+    if (size)   *size = lret;
+    LOG(INFO) << __func__ << " lret=" << lret;
     return true;
 }
+long Stream::Seek(int offset, int whence) {
+    if (!Init()) return -1;
 
+    long lret = -1;
+    if (midx_.cur == -1) { // for html file
+        int ierr = fseek(file_, offset, whence);
+        if (ierr == 0) {
+            lret = ftell(file_);
+        }
+    }else { // for media sequence
+        int idx = -1;
+        int off = -1;
+        if (offset < offmap_[midx_.cur].off) { // backward
+            Close();
+            for (int k=midx_.cur; k >= midx_.begin; k--) {
+                off = offset - offmap_[k].off;
+                if (off > 0) {
+                    idx = k;
+                    break;
+                }
+            }
+        }else if (offset >= offmap_[midx_.cur].off + offmap_[midx_.cur].size) { //forward
+            for(int k=midx_.cur+1; k <= midx_.end; k++) {
+                Close();
+                if(!Init()) return -1;
+                off = offmap_[k].off + offmap_[k].size - offset;
+                if (off > 0) {
+                    idx = k;
+                    break;
+                }
+            }
+        }else {
+            idx = midx_.cur;
+            off = offset - offmap_[midx_.cur].off;
+        }
+
+        if (idx == -1) return -1;
+        midx_.cur = idx;
+        if (!Init()) return -1;
+        int ierr = fseek(file_, off, whence);
+        if (ierr != 0) return -1;
+        lret = ftell(file_);
+    }
+    return lret;
+}
 int Stream::Read(char *buf, int size, int offset) {
     if (!Init()) return -1;
-    int ierr = fseek(file_, offset, SEEK_SET);
+
+    long lret = Seek(offset, SEEK_SET);
+    if (lret < 0) return -1;
+
     int iret = fread(buf, 1, size, file_);
     if (iret <= 0) {
-        LOG(INFO) << __func__ << " ierr=" << ierr << " iret=" << iret 
+        LOG(INFO) << __func__ << " iret=" << iret 
             << " size=" << size << " offset=" << offset;
+    }else if (iret < size) {
+        lret = Seek(offset+iret, SEEK_SET);
+        if (lret < 0) return iret;
+        iret += fread(buf, 1, size - iret, file_);
     }
     return iret; 
 }
+void Stream::Close() {
+    if (file_) fclose(file_);
+    file_ = nullptr;
+}
 
 void Stream::Uninit() {
     //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
-    if (file_) fclose(file_);
-    file_ = nullptr;
+    Close();
+    midx_.begin = -1;
+    midx_.end = -1;
+    midx_.cur = -1;
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b4d11b9..189916b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -43,13 +43,25 @@ struct content_t {
 
 namespace mmt {
 
+struct triple_t {
+    int begin;
+    int end;
+    int cur;
+};
+struct offset_t {
+    offset_t() : off(0), size(0) {}
+    long off;
+    long size;
+};
 class Stream : public base::RefCounted<Stream> {
 public:
-    explicit Stream(const std::string &uri);
-    std::string getUri();
+    explicit Stream(const GURL &url);
+    GURL getUrl();
     bool Init();
     bool Prepare(long *size);
+    long Seek(int offset, int whence);
     int Read(char *buf, int size, int offset);
+    void Close();
     void Uninit();
 
 protected:
@@ -57,7 +69,9 @@ protected:
     virtual ~Stream();
 
 private:
-    std::string uri_;
+    GURL url_;
+    triple_t midx_;
+    std::map<int, offset_t> offmap_;
     FILE *file_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
-- 
1.7.9.5


From 883e9107151456f6fc8d2507ed7802be333870fc Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 20 Jan 2015 18:28:31 -0800
Subject: [PATCH 041/128] todo: refine for sequence

---
 net/mmt/mmt_control.cc                 |    3 +-
 net/mmt/mmt_control.h                  |    2 +-
 net/mmt/mmt_stream.cc                  |  123 ++++++++++++++++++--------------
 net/mmt/mmt_stream.h                   |    3 +-
 net/url_request/url_request_mmt_job.cc |   24 +++++--
 5 files changed, 93 insertions(+), 62 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index a66abf6..28d1ff4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -41,13 +41,14 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
     PostCtrlMsg(msg);
 }
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
     msg.url = gurl;
     PostCtrlMsg(msg);
+    return -1; // IO_PENDING
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index da9ee23..df79ea1 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -74,7 +74,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @close
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
 // for @open and @read
-void PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5c93597..c3e89a6 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -40,7 +40,7 @@ std::string GetQueryValue(std::string query, std::string key) {
     begin = query.find(key);
     if (begin != std::string::npos) {
         begin += key.size();
-        end = query.find("=", begin);
+        end = query.find("&", begin);
         if (end == std::string::npos)
             end = query.size();
         value = query.substr(begin, end-begin);
@@ -54,7 +54,9 @@ bool GetRangeValue(std::string range, int &lval, int &rval) {
     int begin = range.find("-");
     if (begin >= 0) {
         lstr = range.substr(0, begin);
+        if (lstr.empty()) lstr = "-1";
         rstr = range.substr(begin+1, range.size()-begin);
+        if (rstr.empty()) rstr = "9999999";
         bok = true;
     }
     lval = String2Int(lstr);
@@ -94,58 +96,71 @@ GURL Stream::getUrl() {
     return url_;
 }
 
-bool Stream::Init() {
-    if (file_) return true;
-
-    // default file if it is html
-    std::string fname = GURL2FilePath(url_);
+bool Stream::ParseSequence(int& index) {
+    // if exists query, then should redirect to real file name
+    std::string query = url_.query();
+    if (!query.empty()) { // media sequence
+        std::string mtype = GetQueryValue(query, "type");
+        std::string range = GetQueryValue(query, "sequence_num");
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
+        if (mtype.empty()) return false;
+
+        // compute the sequence of media
+        GetRangeValue(range, midx_.begin, midx_.end);
+        index = midx_.begin;
+        LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
+        if (index < 0 || midx_.begin > midx_.end) return false;
+    }else {
+        index = -1;
+    }
+    return true;
+}
 
-    if (midx_.cur == -1) {
-        // if exists query, then should redirect to real file name
-        std::string query = url_.query();
-        if (!query.empty()) { // media sequence
-            std::string mtype = GetQueryValue(query, "type");
-            if (mtype.empty()) return false;
-
-            // compute the sequence of media
-            if (midx_.begin < 0 || midx_.end < 0) {
-                std::string range = GetQueryValue(query, "sequence_num");
-                GetRangeValue(range, midx_.begin, midx_.end);
-            }
+bool Stream::Init(int index) {
+    if (file_) return true;
 
-            // choose the current sequence
-            midx_.cur = midx_.begin;
-        }
+    if(index < 0 && !ParseSequence(index)) {
+        LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
+        return false;
     }
 
-    if (midx_.cur >= 0) {
-        if (midx_.cur < midx_.begin || midx_.cur > midx_.end)
+    // default file is html
+    std::string fname = GURL2FilePath(url_);
+    if (index >= 0) {
+        if (index < midx_.begin || index > midx_.end)
             return false;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
-            fname = fname + "/Channel1_Audio1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+            fname = fname + "/audio/Channel1_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == "video") {
-            fname = fname + "/Channel1_Video1_MPU_" + Int2String(midx_.cur, 4) + ".mp4"; 
+            fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
+    LOG(INFO) << __func__ << " fname=" << fname;
+
+    // open and get file size
     file_ = fopen(fname.c_str(), "rb");
-    offmap_[midx_.cur] = offset_t();
-    
-    // compute the file size and its current offset
+    if (!file_) return false;
     int ierr = fseek(file_, 0L, SEEK_END);
-    offmap_[midx_.cur].size = ftell(file_);
-    offmap_[midx_.cur].off = 0;
-    if (midx_.cur > midx_.begin) { // media sequence
-        offmap_[midx_.cur].off = offmap_[midx_.cur-1].off + offmap_[midx_.cur-1].size;
-    }
+    long lret = ftell(file_);
     ierr = fseek(file_, 0L, SEEK_SET);
 
-    return (file_ != nullptr);
+    offmap_[index] = offset_t();
+    offmap_[index].off = 0;
+    offmap_[index].size = lret;
+    if (index > midx_.begin) { // media sequence
+        offmap_[index].off = offmap_[index-1].off + offmap_[index-1].size;
+    }
+    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+
+    midx_.cur = index;
+    return true;
 }
 bool Stream::Prepare(long *size) {
-    if (!Init()) return false;
+    if (!Init(midx_.cur)) return false;
     long lret = 1<<30; // default 1GB
+    //lret = 1029855;
     if (midx_.cur == -1) {
         lret = offmap_[midx_.cur].size;
     }
@@ -154,10 +169,11 @@ bool Stream::Prepare(long *size) {
     return true;
 }
 long Stream::Seek(int offset, int whence) {
-    if (!Init()) return -1;
+    if (!Init(midx_.cur)) return -1;
 
     long lret = -1;
-    if (midx_.cur == -1) { // for html file
+    int cur = midx_.cur;
+    if (cur == -1) { // for html file
         int ierr = fseek(file_, offset, whence);
         if (ierr == 0) {
             lret = ftell(file_);
@@ -165,19 +181,19 @@ long Stream::Seek(int offset, int whence) {
     }else { // for media sequence
         int idx = -1;
         int off = -1;
-        if (offset < offmap_[midx_.cur].off) { // backward
+        if (offset < offmap_[cur].off) { // backward
             Close();
-            for (int k=midx_.cur; k >= midx_.begin; k--) {
+            for (int k=cur; k >= midx_.begin; k--) {
                 off = offset - offmap_[k].off;
                 if (off > 0) {
                     idx = k;
                     break;
                 }
             }
-        }else if (offset >= offmap_[midx_.cur].off + offmap_[midx_.cur].size) { //forward
-            for(int k=midx_.cur+1; k <= midx_.end; k++) {
+        }else if (offset >= offmap_[cur].off + offmap_[cur].size) { //forward
+            for(int k=cur+1; k <= midx_.end; k++) {
                 Close();
-                if(!Init()) return -1;
+                if(!Init(k)) break;
                 off = offmap_[k].off + offmap_[k].size - offset;
                 if (off > 0) {
                     idx = k;
@@ -185,21 +201,22 @@ long Stream::Seek(int offset, int whence) {
                 }
             }
         }else {
-            idx = midx_.cur;
-            off = offset - offmap_[midx_.cur].off;
+            idx = cur;
+            off = offset - offmap_[cur].off;
         }
+        LOG(INFO) << __func__ << " cur=" << cur << " next=" << idx << " relative off=" << off;
 
         if (idx == -1) return -1;
-        midx_.cur = idx;
-        if (!Init()) return -1;
+        if (!Init(idx)) return -1;
         int ierr = fseek(file_, off, whence);
-        if (ierr != 0) return -1;
-        lret = ftell(file_);
+        if (ierr == 0)
+            lret = ftell(file_);
     }
+    LOG(INFO) << __func__ << " lret=" << lret << " offset=" << offset;
     return lret;
 }
 int Stream::Read(char *buf, int size, int offset) {
-    if (!Init()) return -1;
+    if (!Init(midx_.cur)) return -1;
 
     long lret = Seek(offset, SEEK_SET);
     if (lret < 0) return -1;
@@ -209,9 +226,11 @@ int Stream::Read(char *buf, int size, int offset) {
         LOG(INFO) << __func__ << " iret=" << iret 
             << " size=" << size << " offset=" << offset;
     }else if (iret < size) {
-        lret = Seek(offset+iret, SEEK_SET);
-        if (lret < 0) return iret;
-        iret += fread(buf, 1, size - iret, file_);
+        //lret = Seek(offset+iret, SEEK_SET);
+        //if (lret < 0) return iret;
+        //iret += fread(buf+iret, 1, size-iret, file_);
+        Close();
+        midx_.cur++;
     }
     return iret; 
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 189916b..066d257 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -57,7 +57,8 @@ class Stream : public base::RefCounted<Stream> {
 public:
     explicit Stream(const GURL &url);
     GURL getUrl();
-    bool Init();
+    bool ParseSequence(int& index);
+    bool Init(int index);
     bool Prepare(long *size);
     long Seek(int offset, int whence);
     int Read(char *buf, int size, int offset);
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4254650..77084d7 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -83,13 +83,14 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
     return true;
   }
 
-  int rv = ERR_IO_PENDING;
   mmt::stream_info_t sinfo;
   sinfo.buf = dest;
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
-  mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
+
+  // return ERR_IO_PENDING if aysnc read
+  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
@@ -140,6 +141,9 @@ void URLRequestMmtJob::SetExtraRequestHeaders(
         NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                                     ERR_REQUEST_RANGE_NOT_SATISFIABLE));
       }
+      LOG(INFO) << __func__ << " ranges.size=" << ranges.size()
+        << " first=" << byte_range_.first_byte_position()
+        << " last=" << byte_range_.last_byte_position();
     }
   }
 }
@@ -184,13 +188,18 @@ void URLRequestMmtJob::DidStart(int iret) {
   read_info_.read_offset = byte_range_.first_byte_position();
   DCHECK_GE(read_info_.remaining_bytes, 0);
 
+  LOG(INFO) << __func__ 
+    << " remaining_bytes=" << read_info_.remaining_bytes
+    << " first=" << byte_range_.first_byte_position()
+    << " last=" << byte_range_.last_byte_position();
+
   set_expected_content_size(read_info_.remaining_bytes);
   NotifyHeadersComplete();
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
   LOG(INFO) << __func__ << " iret=" << iret << 
-    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=0x" << ptr;
+    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -199,9 +208,6 @@ void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo,
 }
 
 void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
-#if 0
-  LOG(INFO) << __func__ << " data size=" << size;
-#endif
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
@@ -210,7 +216,11 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
 
-  if (result == 0) {
+  // fix error
+  if (result == -1)
+    result = OK;
+
+  if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED, result));
-- 
1.7.9.5


From 44a47ddd15273071675737687556dd2c4ae7e633 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 21 Jan 2015 05:46:10 -0800
Subject: [PATCH 042/128] todo: enable streaming for mmt

---
 .../docs/examples/api/cimsg/native-messaging-cimsg |    5 ++++-
 content/browser/loader/async_resource_handler.cc   |    5 ++++-
 media/blink/buffered_data_source.cc                |    3 ++-
 media/blink/buffered_data_source.h                 |    2 +-
 media/blink/buffered_resource_loader.cc            |    9 ++++++++-
 media/filters/ffmpeg_glue.cc                       |    2 +-
 net/mmt/mmt_stream.cc                              |    1 -
 net/url_request/url_request_mmt_job.cc             |    8 +++++++-
 8 files changed, 27 insertions(+), 8 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
index 05279a2..2b31c6b 100755
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
@@ -26,7 +26,10 @@ except ImportError:
 def send_message(message):
   # message must be JSON string
   if len(message) < 16: return
-  jdata = JSONDecoder().decode(message)
+  try:
+    jdata = JSONDecoder().decode(message)
+  except:
+    jdata = None
   if not jdata: return
 
   # Write message size.
diff --git a/content/browser/loader/async_resource_handler.cc b/content/browser/loader/async_resource_handler.cc
index 51b0a744..241384d 100644
--- a/content/browser/loader/async_resource_handler.cc
+++ b/content/browser/loader/async_resource_handler.cc
@@ -39,7 +39,7 @@ namespace {
 
 static int kBufferSize = 1024 * 512;
 static int kMinAllocationSize = 1024 * 4;
-static int kMaxAllocationSize = 1024 * 32;
+static int kMaxAllocationSize = 1024 * 128;
 
 void GetNumericArg(const std::string& name, int* result) {
   const std::string& value =
@@ -57,6 +57,9 @@ void InitializeResourceBufferConstants() {
   GetNumericArg("resource-buffer-size", &kBufferSize);
   GetNumericArg("resource-buffer-min-allocation-size", &kMinAllocationSize);
   GetNumericArg("resource-buffer-max-allocation-size", &kMaxAllocationSize);
+  LOG(INFO) << __func__ << " kBufferSize=" << kBufferSize
+    << " kMinAllocationSize=" << kMinAllocationSize
+    << " kMaxAllocationSize" << kMaxAllocationSize;
 }
 
 int CalcUsedPercentage(int bytes_read, int buffer_size) {
diff --git a/media/blink/buffered_data_source.cc b/media/blink/buffered_data_source.cc
index e3e12e0..af69dc2 100644
--- a/media/blink/buffered_data_source.cc
+++ b/media/blink/buffered_data_source.cc
@@ -18,7 +18,7 @@ namespace {
 // BufferedDataSource has an intermediate buffer, this value governs the initial
 // size of that buffer. It is set to 32KB because this is a typical read size
 // of FFmpeg.
-const int kInitialReadBufferSize = 32768;
+const int kInitialReadBufferSize = 32768 * 4;
 
 // Number of cache misses or read failures we allow for a single Read() before
 // signaling an error.
@@ -264,6 +264,7 @@ bool BufferedDataSource::GetSize(int64* size_out) {
 }
 
 bool BufferedDataSource::IsStreaming() {
+  LOG(INFO) << __func__ << " streaming_=" << streaming_;
   return streaming_;
 }
 
diff --git a/media/blink/buffered_data_source.h b/media/blink/buffered_data_source.h
index b047c19..0b08887 100644
--- a/media/blink/buffered_data_source.h
+++ b/media/blink/buffered_data_source.h
@@ -105,7 +105,7 @@ class MEDIA_EXPORT BufferedDataSource : public DataSource {
   void MediaIsPaused();
 
   // Returns true if the resource is local.
-  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS(); }
+  bool assume_fully_buffered() { return !url_.SchemeIsHTTPOrHTTPS() && !url_.SchemeIs(url::kMmtScheme); }
 
   // DataSource implementation.
   // Called from demuxer thread.
diff --git a/media/blink/buffered_resource_loader.cc b/media/blink/buffered_resource_loader.cc
index d88266d..a3afd89 100644
--- a/media/blink/buffered_resource_loader.cc
+++ b/media/blink/buffered_resource_loader.cc
@@ -320,6 +320,7 @@ int64 BufferedResourceLoader::instance_size() {
 }
 
 bool BufferedResourceLoader::range_supported() {
+  LOG(INFO) << "BufferedResourceLoader::range_supported() = " << range_supported_;
   return range_supported_;
 }
 
@@ -426,7 +427,13 @@ void BufferedResourceLoader::didReceiveResponse(
         return;
       }
     }
-
+  } else if (url_.SchemeIs(url::kMmtScheme)){
+    instance_size_ = content_length_;
+    LOG(INFO) << "BufferedResourceLoader::didReceiveResponse" 
+        << " content_length_=" << content_length_
+        << " first_byte_position_=" << first_byte_position_
+        << " last_byte_position_=" << last_byte_position_
+        << " instance_size_=" << instance_size_; 
   } else {
     CHECK_EQ(instance_size_, kPositionNotSpecified);
     if (content_length_ != kPositionNotSpecified) {
diff --git a/media/filters/ffmpeg_glue.cc b/media/filters/ffmpeg_glue.cc
index dabd7d5..6c77ba4 100644
--- a/media/filters/ffmpeg_glue.cc
+++ b/media/filters/ffmpeg_glue.cc
@@ -17,7 +17,7 @@ namespace media {
 // TODO(dalecurtis): Experiment with this buffer size and measure impact on
 // performance.  Currently we want to use 32kb to preserve existing behavior
 // with the previous URLProtocol based approach.
-enum { kBufferSize = 256 * 1024 };
+enum { kBufferSize = 128 * 1024 };
 
 static int AVIOReadOperation(void* opaque, uint8_t* buf, int buf_size) {
   FFmpegURLProtocol* protocol = reinterpret_cast<FFmpegURLProtocol*>(opaque);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index c3e89a6..f473d76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -160,7 +160,6 @@ bool Stream::Init(int index) {
 bool Stream::Prepare(long *size) {
     if (!Init(midx_.cur)) return false;
     long lret = 1<<30; // default 1GB
-    //lret = 1029855;
     if (midx_.cur == -1) {
         lret = offmap_[midx_.cur].size;
     }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 77084d7..6cdffa9 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -120,7 +120,13 @@ Filter* URLRequestMmtJob::SetupFilter() const {
 
 bool URLRequestMmtJob::GetMimeType(std::string* mime_type) const {
   DCHECK(request_);
-  *mime_type = std::string("text/html");
+  std::string spec = request_->url().spec();
+  if (spec.find("type=video") != std::string::npos)
+    *mime_type = std::string("video/mp4");
+  else if (spec.find("type=audio") != std::string::npos)
+    *mime_type = std::string("audio/mp4");
+  else
+    *mime_type = std::string("text/html");
   return true;
 }
 
-- 
1.7.9.5


From 963527b8e7ee0abbab12d33d29ebe6efd2d9bc41 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 22 Jan 2015 22:11:28 -0800
Subject: [PATCH 043/128] Add mpu module into chrome

---
 net/mmt/mpu/Makefile       |   21 +
 net/mmt/mpu/mp4.c          | 3945 ++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mpu/mp4.h          | 1218 ++++++++++++++
 net/mmt/mpu/mpu.gyp        |   85 +
 net/mmt/mpu/stream.c       |  390 +++++
 net/mmt/mpu/stream.h       |  143 ++
 net/mmt/mpu/test_parser.cc |   40 +
 7 files changed, 5842 insertions(+)
 create mode 100644 net/mmt/mpu/Makefile
 create mode 100644 net/mmt/mpu/mp4.c
 create mode 100644 net/mmt/mpu/mp4.h
 create mode 100644 net/mmt/mpu/mpu.gyp
 create mode 100644 net/mmt/mpu/stream.c
 create mode 100644 net/mmt/mpu/stream.h
 create mode 100644 net/mmt/mpu/test_parser.cc

diff --git a/net/mmt/mpu/Makefile b/net/mmt/mpu/Makefile
new file mode 100644
index 0000000..021f39c
--- /dev/null
+++ b/net/mmt/mpu/Makefile
@@ -0,0 +1,21 @@
+TARGET = parser
+OBJS = stream.o mp4.o test_parser.o
+CFLAGS = -I../../../
+LDFLAGS = -lm
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
new file mode 100644
index 0000000..9e64657
--- /dev/null
+++ b/net/mmt/mpu/mp4.c
@@ -0,0 +1,3945 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include <math.h>
+#include <stdarg.h>
+#include "net/mmt/mpu/mp4.h"
+
+void *debug_malloc(size_t size, const char *file, int line, const char *func)
+{
+    void *p;
+    p = malloc(size);
+    printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
+            file, line, func, size, (unsigned long)p);
+    return p;
+}
+
+void *debug_free(char *p)
+{
+    if(NULL!=(p))
+    {
+        free(p) ;
+        p = NULL;
+    }
+}
+
+
+#define msg_Dbg(x) do {} while (0)
+#define msg_Warn(x) do {} while (0)
+#define msg_Err(x) do {} while (0)
+
+#ifndef M_PI
+#define M_PI       3.14159265358979323846
+#endif
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+#define FREENULL(a) do { free( a ); a = NULL; } while(0)
+
+#define MP4_GETX_PRIVATE(dst, code, size) do { \
+    if( (i_read) >= (size) ) { dst = (code); p_peek += (size); } \
+    else { dst = 0; }   \
+    i_read -= (size);   \
+} while(0)
+
+static uint32_t mp4_box_headersize( mp4_box_t *p_box )
+{
+    return 8
+        + ( p_box->i_shortsize == 1 ? 8 : 0 )
+        + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
+}
+
+static uint32_t Get24bBE( const uint8_t *p )
+{
+    return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
+}
+
+#define MP4_GET1BYTE( dst )  MP4_GETX_PRIVATE( dst, *p_peek, 1 )
+#define MP4_GET2BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE16(*(uint16_t*)p_peek), 2 )
+#define MP4_GET3BYTES( dst ) MP4_GETX_PRIVATE( dst, Get24bBE(p_peek), 3 )
+#define MP4_GET4BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE32(*(uint32_t*)p_peek), 4 )
+#define MP4_GET8BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE64(*(uint64_t*)p_peek), 8 )
+#define MP4_GETFOURCC( dst ) MP4_GETX_PRIVATE( dst, \
+        MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
+
+#define MP4_GETVERSIONFLAGS( p_void ) \
+    MP4_GET1BYTE( p_void->version ); \
+MP4_GET3BYTES( p_void->flags )
+
+#define MP4_GETSTRINGZ( p_str )         \
+    if( (i_read > 0) && (p_peek[0]) )   \
+{       \
+    const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
+    p_str = malloc( __i_copy__+1 );               \
+    if( p_str ) \
+    { \
+        memcpy( p_str, p_peek, __i_copy__ ); \
+        p_str[__i_copy__] = 0; \
+    } \
+    p_peek += __i_copy__ + 1;   \
+    i_read -= __i_copy__ + 1;   \
+}       \
+else    \
+{       \
+    p_str = NULL; \
+}
+
+#define MP4_READBOX_ENTER( mp4_box_data_TYPE_t ) \
+    int64_t  i_read = p_box->i_size; \
+uint8_t *p_peek, *p_buff; \
+int i_actually_read; \
+if( !( p_peek = p_buff = malloc( i_read ) ) ) \
+{ \
+    return( 0 ); \
+} \
+i_actually_read = stream_read( p_stream, p_peek, i_read ); \
+if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
+{ \
+    free( p_buff ); \
+    return( 0 ); \
+} \
+p_peek += mp4_box_headersize( p_box ); \
+i_read -= mp4_box_headersize( p_box ); \
+if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
+{ \
+    free( p_buff ); \
+    return( 0 ); \
+}
+
+#define MP4_READBOX_EXIT( i_code ) \
+    do \
+{ \
+    free( p_buff ); \
+    if( i_read < 0 ) \
+    printf( "Not enough data" ); \
+    return( i_code ); \
+} while (0)
+
+
+/* Some assumptions:
+ * The input method HAS to be seekable
+ */
+
+/* This macro is used when we want to printf the box type
+ * APPLE annotation box is :
+ *  either 0xA9 + 24-bit ASCII text string (and 0xA9 isn't printable)
+ *  either 32-bit ASCII text string
+ */
+#define MP4_BOX_TYPE_ASCII() ( ((char*)&p_box->i_type)[0] != (char)0xA9 )
+
+
+static void CreateUUID( uuid_t *p_uuid, uint32_t i_fourcc )
+{
+    /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
+    /* FIXME implement this */
+    (void)p_uuid;
+    (void)i_fourcc;
+}
+
+static int drms_init( void *_p_drms, uint32_t i_type,
+        uint8_t *p_info, uint32_t i_len )
+{
+    return 1;
+}
+
+static void GetUUID( uuid_t *p_uuid, const uint8_t *p_buff )
+{
+    memcpy( p_uuid, p_buff, 16 );
+}
+
+/* convert 16.16 fixed point to floating point */
+static double conv_fx( int32_t fx ) {
+    double fp = fx;
+    fp /= 65536.0;
+    return fp;
+}
+
+/* some functions for mp4 encoding of variables */
+#ifdef MP4_VERBOSE
+static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
+{
+    int i_day;
+    int i_hour;
+    int i_min;
+    int i_sec;
+
+    /* date begin at 1 jan 1904 */
+    i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
+
+    i_day = i_date / ( 60*60*24);
+    i_hour = ( i_date /( 60*60 ) ) % 60;
+    i_min  = ( i_date / 60 ) % 60;
+    i_sec =  i_date % 60;
+    sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
+}
+#endif
+
+/*****************************************************************************
+ * MP4_ReadBoxCommon : Load only common parameters for all boxes
+ *****************************************************************************
+ * p_box need to be an already allocated mp4_box_t, and all data
+ *  will only be peek not read
+ *
+ * RETURN : 0 if it fail, 1 otherwise
+ *****************************************************************************/
+int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int      i_read;
+    const uint8_t *p_buff = malloc(32);
+    const uint8_t *p_peek = p_buff;
+
+    if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+    {
+        free(p_buff);
+        return 0;
+    }
+
+    p_box->i_pos = stream_tell( p_stream );
+
+    p_box->data.p_data = NULL;
+    p_box->p_father = NULL;
+    p_box->p_first  = NULL;
+    p_box->p_last  = NULL;
+    p_box->p_next   = NULL;
+
+    MP4_GET4BYTES( p_box->i_shortsize );
+    MP4_GETFOURCC( p_box->i_type );
+
+    /* Now special case */
+
+    if( p_box->i_shortsize == 1 )
+    {
+        /* get the true size on 64 bits */
+        MP4_GET8BYTES( p_box->i_size );
+    }
+    else
+    {
+        p_box->i_size = p_box->i_shortsize;
+        /* XXX size of 0 means that the box extends to end of file */
+    }
+
+    if( p_box->i_type == ATOM_uuid )
+    {
+        /* get extented type on 16 bytes */
+        GetUUID( &p_box->i_uuid, p_peek );
+        p_peek += 16; i_read -= 16;
+    }
+    else
+    {
+        CreateUUID( &p_box->i_uuid, p_box->i_type );
+    }
+
+    free(p_buff);
+
+    // #ifdef MP4_VERBOSE
+    //    if( p_box->i_size )
+    //    {
+    //       if MP4_BOX_TYPE_ASCII()
+    //           printf( "found Box: %4.4s size %"PRId64,
+    //          (char*)&p_box->i_type, p_box->i_size );
+    //       else
+    //           printf( "found Box: c%3.3s size %"PRId64,
+    //          (char*)&p_box->i_type+1, p_box->i_size );
+    //    }
+    // #endif
+
+    return 1;
+}
+
+/*****************************************************************************
+ * MP4_NextBox : Go to the next box
+ *****************************************************************************
+ * if p_box == NULL, go to the next box in which we are( at the begining ).
+ *****************************************************************************/
+static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t box;
+
+    if( !p_box )
+    {
+        MP4_ReadBoxCommon( p_stream, &box );
+        p_box = &box;
+    }
+
+    if( !p_box->i_size )
+    {
+        return 2; /* Box with infinite size */
+    }
+
+    if( p_box->p_father )
+    {
+        const int64_t i_box_end = p_box->i_size + p_box->i_pos;
+        const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
+
+        /* check if it's within p-father */
+        if( i_box_end >= i_father_end )
+        {
+            if( i_box_end > i_father_end )
+                printf(  "out of bound child" );
+            return 0; /* out of bound */
+        }
+    }
+
+    if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
+    {
+        return 0;
+    }
+
+    return 1;
+}
+
+/*****************************************************************************
+ * For all known box a loader is given,
+ *  XXX: all common struct have to be already read by MP4_ReadBoxCommon
+ *       after called one of theses functions, file position is unknown
+ *       you need to call MP4_GotoBox to go where you want
+ *****************************************************************************/
+static int MP4_ReadBoxContainerRaw( stream_t *p_stream, mp4_box_t *p_container )
+{
+    mp4_box_t *p_box;
+
+    if( stream_tell( p_stream ) + 8 >
+            (int64_t)(p_container->i_pos + p_container->i_size) )
+    {
+        /* there is no box to load */
+        return 0;
+    }
+
+    do
+    {
+        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
+
+        /* chain this box with the father and the other at same level */
+        if( !p_container->p_first ) p_container->p_first = p_box;
+        else p_container->p_last->p_next = p_box;
+        p_container->p_last = p_box;
+
+    } while( MP4_NextBox( p_stream, p_box ) == 1 );
+
+    return 1;
+}
+
+static int MP4_ReadBoxContainer( stream_t *p_stream, mp4_box_t *p_container )
+{
+    if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
+    {
+        /* container is empty, 8 stand for the first header in this box */
+        return 1;
+    }
+
+    /* enter box */
+    stream_seek( p_stream, p_container->i_pos +
+            mp4_box_headersize( p_container ), SEEK_SET );
+
+    return MP4_ReadBoxContainerRaw( p_stream, p_container );
+}
+
+static void MP4_FreeBox_Common( mp4_box_t *p_box )
+{
+    /* Up to now do nothing */
+    (void)p_box;
+}
+
+static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
+{
+    /* XXX sometime moov is hiden in a free box */
+    if( p_box->p_father &&
+            p_box->p_father->i_type == ATOM_root &&
+            p_box->i_type == ATOM_free )
+    {
+        const uint8_t *p_buff = malloc(44);
+        const uint8_t *p_peek = p_buff;
+        int     i_read;
+        uint32_t i_fcc;
+
+        i_read  = stream_peek( p_stream, p_peek, 44 );
+
+        p_peek += mp4_box_headersize( p_box ) + 4;
+        i_read -= mp4_box_headersize( p_box ) + 4;
+
+        if( i_read >= 8 )
+        {
+            i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
+
+            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
+            {
+                printf( "detected moov hidden in a free box ..." );
+
+                p_box->i_type = ATOM_foov;
+                free(p_buff);
+                return MP4_ReadBoxContainer( p_stream, p_box );
+            }
+        }
+        free(p_buff);
+    }
+
+    /* Nothing to do */
+    // #ifdef MP4_VERBOSE
+    //    if MP4_BOX_TYPE_ASCII()
+    //        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
+    //    else
+    //        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
+    // #endif
+
+    return 1;
+}
+
+#   define likely(p)   (!!(p))
+#   define unlikely(p) (!!(p))
+
+static int MP4_ReadBox_ftyp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
+
+    MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
+    MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
+
+    if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
+    {
+        unsigned int i = 0;
+        uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
+            calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
+
+        if( unlikely( tab == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+
+        for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
+        {
+            MP4_GETFOURCC( tab[i] );
+        }
+    }
+    else
+    {
+        p_box->data.p_ftyp->compatible_brands = NULL;
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_ftyp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_ftyp->compatible_brands );
+}
+
+static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int mmpu_buf;
+    int i;
+    MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
+    MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
+    MP4_GET1BYTE(mmpu_buf);
+    p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
+    p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
+    MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
+    MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
+    MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
+    p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
+    for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
+    {
+
+        MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
+    }
+
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
+
+    if( p_box->data.p_tfdt->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+
+    }
+
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_mmpu( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_mmpu->asset_id_value );
+}
+
+
+static int MP4_ReadBox_mvhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_mvhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mvhd );
+
+    if( p_box->data.p_mvhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mvhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mvhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mvhd->duration );
+    }
+    MP4_GET4BYTES( p_box->data.p_mvhd->rate );
+    MP4_GET2BYTES( p_box->data.p_mvhd->volume );
+    MP4_GET2BYTES( p_box->data.p_mvhd->reserved1 );
+
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->reserved2[i] );
+    }
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->matrix[i] );
+    }
+    for( i = 0; i < 6; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_mvhd->predefined[i] );
+    }
+
+    MP4_GET4BYTES( p_box->data.p_mvhd->next_track_id );
+
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time,
+            p_box->data.p_mvhd->modification_time );
+    if( p_box->data.p_mvhd->rate )
+    {
+        MP4_ConvertDate2Str( s_duration,
+                p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
+    }
+    else
+    {
+        s_duration[0] = 0;
+    }
+    printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
+            s_creation_time,
+            s_modification_time,
+            (uint32_t)p_box->data.p_mvhd->timescale,
+            s_duration,
+            (float)p_box->data.p_mvhd->rate / (1<<16 ),
+            (float)p_box->data.p_mvhd->volume / 256 ,
+            (uint32_t)p_box->data.p_mvhd->next_track_id );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mfhd_t );
+
+    MP4_GET4BYTES( p_box->data.p_mfhd->sequence_number );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"mfhd\" sequence number %d",
+            p_box->data.p_mfhd->sequence_number );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_tfhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfhd );
+
+    MP4_GET4BYTES( p_box->data.p_tfhd->track_ID );
+
+    if( p_box->data.p_tfhd->version == 0 )
+    {
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_BASE_DATA_OFFSET )
+            MP4_GET8BYTES( p_box->data.p_tfhd->base_data_offset );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            MP4_GET4BYTES( p_box->data.p_tfhd->sample_description_index );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_duration );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_size );
+        if( p_box->data.p_tfhd->flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_box->data.p_tfhd->default_sample_flags );
+
+#ifdef MP4_VERBOSE
+        char psz_base[128] = "\0";
+        char psz_desc[128] = "\0";
+        char psz_dura[128] = "\0";
+        char psz_size[128] = "\0";
+        char psz_flag[128] = "\0";
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_BASE_DATA_OFFSET )
+            snprintf(psz_base, sizeof(psz_base), "base offset %"PRId64, p_box->data.p_tfhd->base_data_offset);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_SAMPLE_DESC_INDEX )
+            snprintf(psz_desc, sizeof(psz_desc), "sample description index %d", p_box->data.p_tfhd->sample_description_index);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_DURATION )
+            snprintf(psz_dura, sizeof(psz_dura), "sample duration %d", p_box->data.p_tfhd->default_sample_duration);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_SIZE )
+            snprintf(psz_size, sizeof(psz_size), "sample size %d", p_box->data.p_tfhd->default_sample_size);
+        if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
+            snprintf(psz_flag, sizeof(psz_flag), "sample flags 0x%x", p_box->data.p_tfhd->default_sample_flags);
+
+        printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
+                p_box->data.p_tfhd->i_version,
+                p_box->data.p_tfhd->i_flags,
+                p_box->data.p_tfhd->track_ID,
+                psz_base, psz_desc, psz_dura, psz_size, psz_flag );
+#endif
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_trun_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_trun );
+
+    MP4_GET4BYTES( p_box->data.p_trun->sample_count );
+
+    if( p_box->data.p_trun->flags & MP4_TRUN_DATA_OFFSET )
+        MP4_GET4BYTES( p_box->data.p_trun->data_offset );
+    if( p_box->data.p_trun->flags & MP4_TRUN_FIRST_FLAGS )
+        MP4_GET4BYTES( p_box->data.p_trun->first_sample_flags );
+
+    p_box->data.p_trun->samples =
+        calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
+    if ( p_box->data.p_trun->samples == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_DURATION )
+            MP4_GET4BYTES( p_sample->duration );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_SIZE )
+            MP4_GET4BYTES( p_sample->size );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_FLAGS )
+            MP4_GET4BYTES( p_sample->flags );
+        if( p_box->data.p_trun->flags & MP4_TRUN_SAMPLE_TIME_OFFSET )
+            MP4_GET4BYTES( p_sample->composition_time_offset );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
+            p_box->data.p_trun->version,
+            p_box->data.p_trun->flags,
+            p_box->data.p_trun->sample_count );
+
+    for( unsigned int i = 0; i<p_box->data.p_trun->sample_count; i++ )
+    {
+        mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
+        printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
+                i, p_sample->i_flags, p_sample->duration,
+                p_sample->i_size, p_sample->composition_time_offset );
+    }
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_trun( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_trun->samples );
+}
+
+
+static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
+{
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    double rotation;    //angle in degrees to be rotated clockwise
+    double scale[2];    // scale factor; sx = scale[0] , sy = scale[1]
+    double translate[2];// amount to translate; tx = translate[0] , ty = translate[1]
+    int *matrix = NULL;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_tkhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_tkhd );
+
+    if( p_box->data.p_tkhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET8BYTES( p_box->data.p_tkhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_tkhd->track_id );
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved );
+        MP4_GET4BYTES( p_box->data.p_tkhd->duration );
+    }
+
+    for( i = 0; i < 2; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->reserved2[i] );
+    }
+    MP4_GET2BYTES( p_box->data.p_tkhd->layer );
+    MP4_GET2BYTES( p_box->data.p_tkhd->predefined );
+    MP4_GET2BYTES( p_box->data.p_tkhd->volume );
+    MP4_GET2BYTES( p_box->data.p_tkhd->reserved3 );
+
+    for( i = 0; i < 9; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tkhd->matrix[i] );
+    }
+    MP4_GET4BYTES( p_box->data.p_tkhd->width );
+    MP4_GET4BYTES( p_box->data.p_tkhd->height );
+
+
+    matrix = p_box->data.p_tkhd->matrix;
+
+    translate[0] = conv_fx(matrix[6]);
+    translate[1] = conv_fx(matrix[7]);
+
+    scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +
+            conv_fx(matrix[3]) * conv_fx(matrix[3]));
+    scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +
+            conv_fx(matrix[4]) * conv_fx(matrix[4]));
+
+    rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;
+
+    if (rotation < 0)
+        rotation += 360.;
+
+#ifdef MP4_VERBOSE
+    MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
+    MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->modification_time );
+    MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->duration );
+
+    printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
+            "Matrix: %i %i %i %i %i %i %i %i %i",
+            s_creation_time,
+            s_modification_time,
+            s_duration,
+            p_box->data.p_tkhd->track_ID,
+            p_box->data.p_tkhd->layer,
+            (float)p_box->data.p_tkhd->volume / 256 ,
+            rotation,
+            scale[0],
+            scale[1],
+            translate[0],
+            translate[1],
+            (float)p_box->data.p_tkhd->width / 65536,
+            (float)p_box->data.p_tkhd->height / 65536,
+            p_box->data.p_tkhd->matrix[0],
+            p_box->data.p_tkhd->matrix[1],
+            p_box->data.p_tkhd->matrix[2],
+            p_box->data.p_tkhd->matrix[3],
+            p_box->data.p_tkhd->matrix[4],
+            p_box->data.p_tkhd->matrix[5],
+            p_box->data.p_tkhd->matrix[6],
+            p_box->data.p_tkhd->matrix[7],
+            p_box->data.p_tkhd->matrix[8] );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hint( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_hint_t );
+
+    MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint16_t i_language;
+    unsigned int i = 0;
+#ifdef MP4_VERBOSE
+    char s_creation_time[128];
+    char s_modification_time[128];
+    char s_duration[128];
+#endif
+    MP4_READBOX_ENTER( mp4_box_data_mdhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mdhd );
+
+    if( p_box->data.p_mdhd->version )
+    {
+        MP4_GET8BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET8BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET8BYTES( p_box->data.p_mdhd->duration );
+    }
+    else
+    {
+        MP4_GET4BYTES( p_box->data.p_mdhd->creation_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->modification_time );
+        MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
+        MP4_GET4BYTES( p_box->data.p_mdhd->duration );
+    }
+    p_box->data.p_mdhd->language_code = i_language = SwapBE16( p_peek );
+    for( i = 0; i < 3; i++ )
+    {
+        p_box->data.p_mdhd->language[i] =
+            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_mdhd->predefined );
+
+    // #ifdef MP4_VERBOSE
+    //     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
+    //     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
+    //     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
+    //      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
+    //                   s_creation_time,
+    //                   s_modification_time,
+    //                   (uint32_t)p_box->data.p_mdhd->timescale,
+    //                   s_duration,
+    //                   p_box->data.p_mdhd->language[0],
+    //                   p_box->data.p_mdhd->language[1],
+    //                   p_box->data.p_mdhd->language[2] );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hdlr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_hdlr_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hdlr );
+
+    MP4_GETFOURCC( p_box->data.p_hdlr->predefined );
+    MP4_GETFOURCC( p_box->data.p_hdlr->handler_type );
+
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( i_reserved );
+    p_box->data.p_hdlr->psz_name = NULL;
+
+    if( i_read > 0 )
+    {
+        uint8_t *psz = p_box->data.p_hdlr->psz_name = malloc( i_read + 1 );
+        if( unlikely( psz == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        if( p_box->data.p_hdlr->predefined == MP4_FOURCC( 'm', 'h', 'l', 'r' ) )
+        {
+            uint8_t i_len;
+            int i_copy;
+
+            MP4_GET1BYTE( i_len );
+            i_copy = min( i_read, i_len );
+
+            memcpy( psz, p_peek, i_copy );
+            p_box->data.p_hdlr->psz_name[i_copy] = '\0';
+        }
+        else
+        {
+            memcpy( psz, p_peek, i_read );
+            p_box->data.p_hdlr->psz_name[i_read] = '\0';
+        }
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
+            (char*)&p_box->data.p_hdlr->handler_type,
+            p_box->data.p_hdlr->psz_name );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_hdlr( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_hdlr->psz_name );
+}
+
+static int MP4_ReadBox_vmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
+
+    MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
+    for( i = 0; i < 3; i++ )
+    {
+        MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
+            p_box->data.p_vmhd->i_graphics_mode,
+            p_box->data.p_vmhd->i_opcolor[0],
+            p_box->data.p_vmhd->i_opcolor[1],
+            p_box->data.p_vmhd->i_opcolor[2] );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_smhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_smhd );
+
+
+
+    MP4_GET2BYTES( p_box->data.p_smhd->balance );
+
+    MP4_GET2BYTES( p_box->data.p_smhd->reserved );
+
+    // #ifdef MP4_VERBOSE
+    //      printf( "read box: \"smhd\" balance %f",
+    //                       (float)p_box->data.p_smhd->balance / 256 );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_hmhd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_hmhd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_hmhd );
+
+    MP4_GET2BYTES( p_box->data.p_hmhd->max_PDU_size );
+    MP4_GET2BYTES( p_box->data.p_hmhd->avg_PDU_size );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->max_bitrate );
+    MP4_GET4BYTES( p_box->data.p_hmhd->avg_bitrate );
+
+    MP4_GET4BYTES( p_box->data.p_hmhd->reserved );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
+            p_box->data.p_hmhd->max_PDU_size,
+            p_box->data.p_hmhd->avg_PDU_size,
+            p_box->data.p_hmhd->max_bitrate,
+            p_box->data.p_hmhd->avg_bitrate );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_url( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_url_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_url );
+    MP4_GETSTRINGZ( p_box->data.p_url->psz_location );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"url\" url: %s",
+            p_box->data.p_url->psz_location );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_url( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_url->psz_location );
+}
+
+static int MP4_ReadBox_urn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_urn_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_urn );
+
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_name );
+    MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"urn\" name %s location %s",
+            p_box->data.p_urn->psz_name,
+            p_box->data.p_urn->psz_location );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_urn( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_urn->psz_name );
+    FREENULL( p_box->data.p_urn->psz_location );
+}
+
+
+static int MP4_ReadBox_dref( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_dref_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_dref );
+
+    MP4_GET4BYTES( p_box->data.p_dref->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"dref\" entry-count %d",
+            p_box->data.p_dref->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stts->sample_count );
+    FREENULL( p_box->data.p_stts->sample_delta );
+}
+
+static int MP4_ReadBox_stts( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_stts_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stts );
+    MP4_GET4BYTES( p_box->data.p_stts->entry_count );
+
+    p_box->data.p_stts->sample_count =
+        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stts->sample_delta =
+        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+    if( p_box->data.p_stts->sample_count == NULL
+            || p_box->data.p_stts->sample_delta == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
+        MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stts\" entry-count %d",
+            p_box->data.p_stts->entry_count );
+
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static void MP4_FreeBox_ctts( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_ctts->sample_count );
+    FREENULL( p_box->data.p_ctts->sample_offset );
+}
+
+static int MP4_ReadBox_ctts( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_ctts_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
+
+    MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
+
+    p_box->data.p_ctts->sample_count =
+        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+    p_box->data.p_ctts->sample_offset =
+        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+    if( ( p_box->data.p_ctts->sample_count == NULL )
+            || ( p_box->data.p_ctts->sample_offset == NULL ) )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
+        MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"ctts\" entry-count %d",
+            p_box->data.p_ctts->entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadLengthDescriptor( uint8_t **pp_peek, int64_t  *i_read )
+{
+    unsigned int i_b;
+    unsigned int i_len = 0;
+    do
+    {
+        i_b = **pp_peek;
+
+        (*pp_peek)++;
+        (*i_read)--;
+        i_len = ( i_len << 7 ) + ( i_b&0x7f );
+    } while( i_b&0x80 );
+    return( i_len );
+}
+
+
+static void MP4_FreeBox_esds( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_esds->es_descriptor.psz_URL );
+    if( p_box->data.p_esds->es_descriptor.decConfigDescr )
+    {
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr->decoder_specific_info );
+        FREENULL( p_box->data.p_esds->es_descriptor.decConfigDescr );
+    }
+}
+
+static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
+{
+#define es_descriptor p_box->data.p_esds->es_descriptor
+    unsigned int i_len;
+    unsigned int i_flags;
+    unsigned int i_type;
+
+    MP4_READBOX_ENTER( mp4_box_data_esds_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_esds );
+
+
+    MP4_GET1BYTE( i_type );
+    if( i_type == 0x03 ) /* MP4ESDescrTag */
+    {
+        i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+        printf( "found esds MPEG4ESDescr (%dBytes)",
+                i_len );
+#endif
+
+        MP4_GET2BYTES( es_descriptor.ES_ID );
+        MP4_GET1BYTE( i_flags );
+        es_descriptor.b_stream_dependence = ( (i_flags&0x80) != 0);
+        es_descriptor.b_url = ( (i_flags&0x40) != 0);
+        es_descriptor.b_OCRstream = ( (i_flags&0x20) != 0);
+
+        es_descriptor.stream_priority = i_flags&0x1f;
+        if( es_descriptor.b_stream_dependence )
+        {
+            MP4_GET2BYTES( es_descriptor.depend_on_ES_ID );
+        }
+        if( es_descriptor.b_url )
+        {
+            unsigned int i_len;
+
+            MP4_GET1BYTE( i_len );
+            es_descriptor.psz_URL = malloc( i_len + 1 );
+            if( es_descriptor.psz_URL )
+            {
+                memcpy( es_descriptor.psz_URL, p_peek, i_len );
+                es_descriptor.psz_URL[i_len] = 0;
+            }
+            p_peek += i_len;
+            i_read -= i_len;
+        }
+        else
+        {
+            es_descriptor.psz_URL = NULL;
+        }
+        if( es_descriptor.b_OCRstream )
+        {
+            MP4_GET2BYTES( es_descriptor.OCR_ES_ID );
+        }
+        MP4_GET1BYTE( i_type ); /* get next type */
+    }
+
+    if( i_type != 0x04)/* MP4DecConfigDescrTag */
+    {
+        es_descriptor.decConfigDescr = NULL;
+        MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+    printf( "found esds MP4DecConfigDescr (%dBytes)",
+            i_len );
+#endif
+
+    es_descriptor.decConfigDescr =
+        calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
+    if( unlikely( es_descriptor.decConfigDescr == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET1BYTE( es_descriptor.decConfigDescr->objectTypeIndication );
+    MP4_GET1BYTE( i_flags );
+    es_descriptor.decConfigDescr->streamType = i_flags >> 2;
+    es_descriptor.decConfigDescr->b_upStream = ( i_flags >> 1 )&0x01;
+    MP4_GET3BYTES( es_descriptor.decConfigDescr->buffer_sizeDB );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->max_bitrate );
+    MP4_GET4BYTES( es_descriptor.decConfigDescr->avg_bitrate );
+    MP4_GET1BYTE( i_type );
+    if( i_type !=  0x05 )/* MP4DecSpecificDescrTag */
+    {
+        es_descriptor.decConfigDescr->decoder_specific_info_len = 0;
+        es_descriptor.decConfigDescr->decoder_specific_info  = NULL;
+        MP4_READBOX_EXIT( 1 );
+    }
+
+    i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
+
+#ifdef MP4_VERBOSE
+    printf( "found esds MP4DecSpecificDescr (%dBytes)",
+            i_len );
+#endif
+    if( i_len > i_read )
+        MP4_READBOX_EXIT( 0 );
+
+    es_descriptor.decConfigDescr->decoder_specific_info_len = i_len;
+    es_descriptor.decConfigDescr->decoder_specific_info = malloc( i_len );
+    if( unlikely( es_descriptor.decConfigDescr->decoder_specific_info == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    memcpy( es_descriptor.decConfigDescr->decoder_specific_info,
+            p_peek, i_len );
+
+    MP4_READBOX_EXIT( 1 );
+#undef es_descriptor
+}
+
+static void MP4_FreeBox_avcC( mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC = p_box->data.p_avcC;
+    int i;
+
+    if( p_avcC->avcC > 0 ) FREENULL( p_avcC->p_avcC );
+
+    if( p_avcC->p_sps )
+    {
+        for( i = 0; i < p_avcC->sps; i++ )
+            FREENULL( p_avcC->p_sps[i] );
+    }
+    if( p_avcC->p_pps )
+    {
+        for( i = 0; i < p_avcC->pps; i++ )
+            FREENULL( p_avcC->p_pps[i] );
+    }
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->p_sps );
+    if( p_avcC->sps > 0 ) FREENULL( p_avcC->sps_length );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->p_pps );
+    if( p_avcC->pps > 0 ) FREENULL( p_avcC->pps_length );
+}
+
+static int MP4_ReadBox_avcC( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_avcC_t *p_avcC;
+    int i;
+
+    MP4_READBOX_ENTER( mp4_box_data_avcC_t );
+    p_avcC = p_box->data.p_avcC;
+
+    p_avcC->avcC = i_read;
+    if( p_avcC->avcC > 0 )
+    {
+        uint8_t * p = p_avcC->p_avcC = malloc( p_avcC->avcC );
+        if( p )
+            memcpy( p, p_peek, i_read );
+    }
+
+    MP4_GET1BYTE( p_avcC->version );
+    MP4_GET1BYTE( p_avcC->profile );
+    MP4_GET1BYTE( p_avcC->profile_compatibility );
+    MP4_GET1BYTE( p_avcC->level );
+    MP4_GET1BYTE( p_avcC->reserved1 );
+    p_avcC->length_size = (p_avcC->reserved1&0x03) + 1;
+    p_avcC->reserved1 >>= 2;
+
+    MP4_GET1BYTE( p_avcC->reserved2 );
+    p_avcC->sps = p_avcC->reserved2&0x1f;
+    p_avcC->reserved2 >>= 5;
+
+    if( p_avcC->sps > 0 )
+    {
+        p_avcC->sps_length = calloc( p_avcC->sps, sizeof( uint16_t ) );
+        p_avcC->p_sps = calloc( p_avcC->sps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->sps_length || !p_avcC->p_sps )
+            goto error;
+
+        for( i = 0; i < p_avcC->sps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->sps_length[i] );
+            p_avcC->p_sps[i] = malloc( p_avcC->sps_length[i] );
+            if( p_avcC->p_sps[i] )
+                memcpy( p_avcC->p_sps[i], p_peek, p_avcC->sps_length[i] );
+
+            p_peek += p_avcC->sps_length[i];
+            i_read -= p_avcC->sps_length[i];
+        }
+    }
+
+    MP4_GET1BYTE( p_avcC->pps );
+    if( p_avcC->pps > 0 )
+    {
+        p_avcC->pps_length = calloc( p_avcC->pps, sizeof( uint16_t ) );
+        p_avcC->p_pps = calloc( p_avcC->pps, sizeof( uint8_t* ) );
+
+        if( !p_avcC->pps_length || !p_avcC->p_pps )
+            goto error;
+
+        for( i = 0; i < p_avcC->pps; i++ )
+        {
+            MP4_GET2BYTES( p_avcC->pps_length[i] );
+            p_avcC->p_pps[i] = malloc( p_avcC->pps_length[i] );
+            if( p_avcC->p_pps[i] )
+                memcpy( p_avcC->p_pps[i], p_peek, p_avcC->pps_length[i] );
+
+            p_peek += p_avcC->pps_length[i];
+            i_read -= p_avcC->pps_length[i];
+        }
+    }
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
+    //              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
+    //              p_avcC->i_length_size,
+    //              p_avcC->i_sps, p_avcC->i_pps );
+    //     for( i = 0; i < p_avcC->i_sps; i++ )
+    //     {
+    //          printf( "         - sps[%d] length=%d",
+    //                  i, p_avcC->i_sps_length[i] );
+    //     }
+    //     for( i = 0; i < p_avcC->i_pps; i++ )
+    //     {
+    //          printf( "         - pps[%d] length=%d",
+    //                  i, p_avcC->i_pps_length[i] );
+    //     }
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+
+error:
+    MP4_READBOX_EXIT( 0 );
+}
+
+static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_dac3_t *p_dac3;
+    unsigned i_header;
+
+    MP4_READBOX_ENTER( mp4_box_data_dac3_t );
+
+    p_dac3 = p_box->data.p_dac3;
+
+    MP4_GET3BYTES( i_header );
+
+    p_dac3->fscod = ( i_header >> 22 ) & 0x03;
+    p_dac3->bsid  = ( i_header >> 17 ) & 0x01f;
+    p_dac3->bsmod = ( i_header >> 14 ) & 0x07;
+    p_dac3->acmod = ( i_header >> 11 ) & 0x07;
+    p_dac3->lfeon = ( i_header >> 10 ) & 0x01;
+    p_dac3->bitrate_code = ( i_header >> 5) & 0x1f;
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
+            p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_enda( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_enda_t *p_enda;
+    MP4_READBOX_ENTER( mp4_box_data_enda_t );
+
+    p_enda = p_box->data.p_enda;
+
+    MP4_GET2BYTES( p_enda->little_endian );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_gnre( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_gnre_t *p_gnre;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_gnre_t );
+
+    p_gnre = p_box->data.p_gnre;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 10 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET2BYTES( p_gnre->genre );
+    if( p_gnre->genre == 0 )
+        MP4_READBOX_EXIT( 0 );
+#ifdef MP4_VERBOSE
+    printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_trkn_t *p_trkn;
+    uint32_t i_data_len;
+    uint32_t i_data_tag;
+    uint32_t i_version;
+    uint32_t i_reserved;
+
+    MP4_READBOX_ENTER( mp4_box_data_trkn_t );
+
+    p_trkn = p_box->data.p_trkn;
+
+    MP4_GET4BYTES( i_data_len );
+    MP4_GETFOURCC( i_data_tag );
+    if( i_data_len < 12 || i_data_tag != ATOM_data )
+        MP4_READBOX_EXIT( 0 );
+
+    MP4_GET4BYTES( i_version );
+    MP4_GET4BYTES( i_reserved );
+    MP4_GET4BYTES( p_trkn->track_number );
+
+    // #ifdef MP4_VERBOSE
+    //      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
+    // #endif
+
+    if( i_data_len > 15 )
+    {
+        MP4_GET4BYTES( p_trkn->track_total );
+
+        // #ifdef MP4_VERBOSE
+        //         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
+        // #endif
+
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
+    p_box->data.p_sample_soun->qt_description = NULL;
+
+    /* Sanity check needed because the "wave" box does also contain an
+     * "mp4a" box that we don't understand. */
+    if( i_read < 28 )
+    {
+        i_read -= 30;
+        MP4_READBOX_EXIT( 1 );
+    }
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
+
+    /*
+     * XXX hack -> produce a copy of the nearly complete chunk
+     */
+    p_box->data.p_sample_soun->qt_description = 0;
+    p_box->data.p_sample_soun->p_qt_description = NULL;
+    if( i_read > 0 )
+    {
+        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
+        if( p_box->data.p_sample_soun->p_qt_description )
+        {
+            p_box->data.p_sample_soun->qt_description = i_read;
+            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
+        }
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
+    MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
+
+    MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
+    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
+
+    if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
+    {
+        /* SoundDescriptionV1 */
+        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
+        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
+
+#ifdef MP4_VERBOSE
+        printf(
+                "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
+                "bytes/frame=%d bytes/sample=%d",
+                p_box->data.p_sample_soun->i_sample_per_packet,
+                p_box->data.p_sample_soun->i_bytes_per_packet,
+                p_box->data.p_sample_soun->i_bytes_per_frame,
+                p_box->data.p_sample_soun->i_bytes_per_sample );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 44, SEEK_SET );
+    }
+    else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
+    {
+        /* SoundDescriptionV2 */
+        double f_sample_rate;
+        int64_t dummy;
+        uint32_t i_channel;
+
+        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+        MP4_GET8BYTES( dummy );
+        memcpy( &f_sample_rate, &dummy, 8 );
+
+        printf( "read box: %f Hz", f_sample_rate );
+        p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
+        p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
+
+        MP4_GET4BYTES( i_channel );
+        p_box->data.p_sample_soun->channelcount = i_channel;
+
+#ifdef MP4_VERBOSE
+        printf( "read box: \"soun\" V2" );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
+    }
+    else
+    {
+        p_box->data.p_sample_soun->sample_per_packet = 0;
+        p_box->data.p_sample_soun->bytes_per_packet = 0;
+        p_box->data.p_sample_soun->bytes_per_frame = 0;
+        p_box->data.p_sample_soun->bytes_per_sample = 0;
+
+#ifdef MP4_VERBOSE
+        printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
+                i_read );
+#endif
+        stream_seek( p_stream, p_box->i_pos +
+                mp4_box_headersize( p_box ) + 28, SEEK_SET );
+    }
+
+    if( p_box->i_type == ATOM_drms )
+    {
+        assert(0);
+        //         char *home = config_GetUserDir( VLC_HOME_DIR );
+        //         if( home != NULL )
+        //         {
+        //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
+        //             if( p_box->data.p_sample_soun->p_drms == NULL )
+        //                 msg_Err( p_stream, "drms_alloc() failed" );
+        //         }
+    }
+
+    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
+    {
+        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
+        p_box->data.p_sample_soun->channelcount = 1;
+    }
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"soun\" in stsd channel %d "
+            "sample size %d sample rate %f",
+            p_box->data.p_sample_soun->channelcount,
+            p_box->data.p_sample_soun->samplesize,
+            (float)p_box->data.p_sample_soun->sampleratehi +
+            (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+/*****************************************************************************
+ * aes_s: AES keys structure
+ *****************************************************************************
+ * This structure stores a set of keys usable for encryption and decryption
+ * with the AES/Rijndael algorithm.
+ *****************************************************************************/
+#define AES_KEY_COUNT 10
+#define PATH_MAX 260
+struct aes_s
+{
+    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+};
+
+/*****************************************************************************
+ * drms_s: DRMS structure
+ *****************************************************************************
+ * This structure stores the static information needed to decrypt DRMS data.
+ *****************************************************************************/
+struct drms_s
+{
+    uint32_t i_user;
+    uint32_t i_key;
+    uint8_t  p_iviv[ 16 ];
+    uint8_t *p_name;
+
+    uint32_t p_key[ 4 ];
+    struct aes_s aes;
+
+    char     psz_homedir[ PATH_MAX ];
+};
+
+/*****************************************************************************
+ * drms_free: free a previously allocated DRMS structure
+ *****************************************************************************/
+void drms_free( void *_p_drms )
+{
+    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+
+    //free( (void *)p_drms->p_name );
+    free( p_drms->p_name );
+    free( p_drms );
+}
+
+
+static void MP4_FreeBox_sample_soun( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_soun->p_qt_description );
+
+    if( p_box->i_type == ATOM_drms )
+    {
+        if( p_box->data.p_sample_soun->drms )
+        {
+            drms_free( p_box->data.p_sample_soun->drms );
+        }
+    }
+}
+
+
+int MP4_ReadBox_sample_vide( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
+
+    /*
+     * XXX hack -> produce a copy of the nearly complete chunk
+     */
+    if( i_read > 0 )
+    {
+        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
+        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
+            MP4_READBOX_EXIT( 0 );
+        p_box->data.p_sample_vide->qt_image_description = i_read;
+        memcpy( p_box->data.p_sample_vide->p_qt_image_description,
+                p_peek, i_read );
+    }
+    else
+    {
+        p_box->data.p_sample_vide->qt_image_description = 0;
+        p_box->data.p_sample_vide->p_qt_image_description = NULL;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->width );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->height );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
+    MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
+
+    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
+
+    memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
+    p_peek += 32; i_read -= 32;
+
+    MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
+    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
+
+    if( p_box->i_type == ATOM_drmi )
+    {
+        assert(0);
+        //         char *home = config_GetUserDir( VLC_HOME_DIR );
+        //         if( home != NULL )
+        //         {
+        //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
+        //             if( p_box->data.p_sample_vide->p_drms == NULL )
+        //                 msg_Err( p_stream, "drms_alloc() failed" );
+        //         }
+    }
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"vide\" in stsd %dx%d depth %d",
+            p_box->data.p_sample_vide->width,
+            p_box->data.p_sample_vide->height,
+            p_box->data.p_sample_vide->depth );
+
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+void MP4_FreeBox_sample_vide( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
+
+    if( p_box->i_type == ATOM_drmi )
+    {
+        if( p_box->data.p_sample_vide->drms )
+        {
+            drms_free( p_box->data.p_sample_vide->drms );
+        }
+    }
+}
+
+
+int MP4_ReadBox_sample_mmth( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    unsigned int  mmth_buf;
+    int j;
+    MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
+
+    for( i = 0; i < 6 ; i++ )
+    {
+        MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
+
+
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
+    MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
+    MP4_GET1BYTE(mmth_buf);
+    p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
+    p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
+    p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
+
+    /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
+      MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
+      p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
+      for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
+      {
+
+      MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
+      }*/
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_sample_mp4s( stream_t *p_stream, mp4_box_t *p_box )
+{
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+    return 1;
+}
+
+static int MP4_ReadBox_sample_text( stream_t *p_stream, mp4_box_t *p_box )
+{
+    int32_t t;
+
+    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+    MP4_GET4BYTES( t );
+    switch( t )
+    {
+        /* FIXME search right signification */
+        case 1: // Center
+            p_box->data.p_sample_text->justification_horizontal = 1;
+            p_box->data.p_sample_text->justification_vertical = 1;
+            break;
+        case -1:    // Flush Right
+            p_box->data.p_sample_text->justification_horizontal = -1;
+            p_box->data.p_sample_text->justification_vertical = -1;
+            break;
+        case -2:    // Flush p_first
+            p_box->data.p_sample_text->justification_horizontal = 0;
+            p_box->data.p_sample_text->justification_vertical = 0;
+            break;
+        case 0: // Flush Default
+        default:
+            p_box->data.p_sample_text->justification_horizontal = 1;
+            p_box->data.p_sample_text->justification_vertical = -1;
+            break;
+    }
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
+    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
+    p_box->data.p_sample_text->background_color[3] = 0;
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"text\" in stsd text" );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
+
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
+    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
+
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"tx3g\" in stsd text" );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+#if 0
+/* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */
+static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sample_text->psz_text_name );
+}
+#endif
+
+
+static int MP4_ReadBox_stsd( stream_t *p_stream, mp4_box_t *p_box )
+{
+
+    MP4_READBOX_ENTER( mp4_box_data_stsd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
+
+    MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsd\" entry-count %d",
+            p_box->data.p_stsd->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stsz( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsz_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
+
+    MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
+    MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
+
+    if( p_box->data.p_stsz->sample_size == 0 )
+    {
+        p_box->data.p_stsz->entry_size =
+            calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
+        if( unlikely( !p_box->data.p_stsz->entry_size ) )
+            MP4_READBOX_EXIT( 0 );
+
+        for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
+        {
+            MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
+        }
+    }
+    else
+        p_box->data.p_stsz->entry_size = NULL;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsz\" sample-size %d sample-count %d",
+            p_box->data.p_stsz->sample_size,
+            p_box->data.p_stsz->sample_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stsz( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsz->entry_size );
+}
+
+static void MP4_FreeBox_stsc( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsc->first_chunk );
+    FREENULL( p_box->data.p_stsc->samples_per_chunk );
+    FREENULL( p_box->data.p_stsc->sample_description_index );
+}
+
+static int MP4_ReadBox_stsc( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsc_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
+
+    MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
+
+    p_box->data.p_stsc->first_chunk =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsc->samples_per_chunk =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsc->sample_description_index =
+        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+    if( unlikely( p_box->data.p_stsc->first_chunk == NULL
+                || p_box->data.p_stsc->samples_per_chunk == NULL
+                || p_box->data.p_stsc->sample_description_index == NULL ) )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
+        MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
+        MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsc\" entry-count %d",
+            p_box->data.p_stsc->entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_stco_co64( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_co64_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
+
+    MP4_GET4BYTES( p_box->data.p_co64->entry_count );
+
+    p_box->data.p_co64->chunk_offset =
+        calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
+    if( p_box->data.p_co64->chunk_offset == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
+    {
+        if( p_box->i_type == ATOM_stco )
+        {
+            if( i_read < 4 )
+            {
+                break;
+            }
+            MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
+        }
+        else
+        {
+            if( i_read < 8 )
+            {
+                break;
+            }
+            MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
+        }
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"co64\" entry-count %d",
+            p_box->data.p_co64->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stco_co64( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_co64->chunk_offset );
+}
+
+static int MP4_ReadBox_stss( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stss_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stss );
+
+    MP4_GET4BYTES( p_box->data.p_stss->entry_count );
+
+    p_box->data.p_stss->sample_number =
+        calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
+    if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
+    {
+
+        MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
+        /* XXX in libmp4 sample begin at 0 */
+        p_box->data.p_stss->sample_number[i]--;
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stss\" entry-count %d",
+            p_box->data.p_stss->i_entry_count );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stss( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stss->sample_number );
+}
+
+static void MP4_FreeBox_stsh( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stsh->shadowed_sample_number );
+    FREENULL( p_box->data.p_stsh->sync_sample_number );
+}
+
+static int MP4_ReadBox_stsh( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stsh_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
+
+
+    MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
+
+    p_box->data.p_stsh->shadowed_sample_number =
+        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+    p_box->data.p_stsh->sync_sample_number =
+        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+
+    if( p_box->data.p_stsh->shadowed_sample_number == NULL
+            || p_box->data.p_stsh->sync_sample_number == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
+        MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stsh\" entry-count %d",
+            p_box->data.p_stsh->i_entry_count );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+
+static int MP4_ReadBox_stdp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_stdp_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
+
+    p_box->data.p_stdp->priority =
+        calloc( i_read / 2, sizeof(uint16_t) );
+
+    if( unlikely( !p_box->data.p_stdp->priority ) )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < i_read / 2 ; i++ )
+    {
+        MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+            i_read / 2 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_stdp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_stdp->priority );
+}
+
+static void MP4_FreeBox_padb( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_padb->reserved1 );
+    FREENULL( p_box->data.p_padb->pad2 );
+    FREENULL( p_box->data.p_padb->reserved2 );
+    FREENULL( p_box->data.p_padb->pad1 );
+}
+
+static int MP4_ReadBox_padb( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t count;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_padb_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_padb );
+
+    MP4_GET4BYTES( p_box->data.p_padb->sample_count );
+    count = (p_box->data.p_padb->sample_count + 1) / 2;
+
+    p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
+    p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
+    if( p_box->data.p_padb->reserved1 == NULL
+            || p_box->data.p_padb->pad2 == NULL
+            || p_box->data.p_padb->reserved2 == NULL
+            || p_box->data.p_padb->pad1 == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+    for( i = 0; i < i_read / 2 ; i++ )
+    {
+        if( i >= count )
+        {
+            MP4_READBOX_EXIT( 0 );
+        }
+        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
+        p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
+        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
+        p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
+
+        p_peek += 1; i_read -= 1;
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"stdp\" entry-count %"PRId64,
+            i_read / 2 );
+
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_elst( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_elst->segment_duration );
+    FREENULL( p_box->data.p_elst->media_time );
+    FREENULL( p_box->data.p_elst->media_rate_integer );
+    FREENULL( p_box->data.p_elst->media_rate_fraction );
+}
+
+static int MP4_ReadBox_elst( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_elst_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_elst );
+
+
+    MP4_GET4BYTES( p_box->data.p_elst->entry_count );
+
+    p_box->data.p_elst->segment_duration =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+    p_box->data.p_elst->media_time =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+    p_box->data.p_elst->media_rate_integer =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+    p_box->data.p_elst->media_rate_fraction =
+        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+    if( p_box->data.p_elst->segment_duration == NULL
+            || p_box->data.p_elst->media_time == NULL
+            || p_box->data.p_elst->media_rate_integer == NULL
+            || p_box->data.p_elst->media_rate_fraction == NULL )
+    {
+        MP4_READBOX_EXIT( 0 );
+    }
+
+
+    for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
+    {
+        if( p_box->data.p_elst->version == 1 )
+        {
+
+            MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
+
+            MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
+        }
+        else
+        {
+
+            MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
+
+            MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
+            p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
+        }
+
+        MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
+        MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"elst\" entry-count %lu",
+            (unsigned long)p_box->data.p_elst->entry_count );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i_language;
+    unsigned int i = 0;
+
+    MP4_READBOX_ENTER( mp4_box_data_cprt_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
+
+    i_language = SwapBE16( p_peek );
+    for( i = 0; i < 3; i++ )
+    {
+        p_box->data.p_cprt->language[i] =
+            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+    }
+    p_peek += 2; i_read -= 2;
+    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cprt\" language %c%c%c notice %s",
+            p_box->data.p_cprt->language[0],
+            p_box->data.p_cprt->language[1],
+            p_box->data.p_cprt->language[2],
+            p_box->data.p_cprt->psz_notice );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_cprt( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_cprt->psz_notice );
+}
+
+
+static int MP4_ReadBox_dcom( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_dcom_t );
+
+    MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"dcom\" compression algorithm : %4.4s",
+            (char*)&p_box->data.p_dcom->algorithm );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_cmvd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
+
+    MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
+
+    p_box->data.p_cmvd->compressed_size = i_read;
+
+    if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
+        MP4_READBOX_EXIT( 0 );
+
+    /* now copy compressed data */
+    memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
+
+    p_box->data.p_cmvd->b_compressed = 1;
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmvd\" compressed data size %d",
+            p_box->data.p_cmvd->compressed_size );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_cmvd( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_cmvd->data );
+}
+
+
+static int MP4_ReadBox_cmov( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t *p_dcom;
+    mp4_box_t *p_cmvd;
+
+#ifdef HAVE_ZLIB_H
+    stream_t *p_stream_memory;
+    z_stream z_data;
+    uint8_t *p_data;
+    int i_result;
+#endif
+
+    if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
+        return 0;
+
+    if( !p_box->p_father ||
+            ( p_box->p_father->i_type != ATOM_moov &&
+              p_box->p_father->i_type != ATOM_foov ) )
+    {
+        printf( "Read box: \"cmov\" box alone" );
+        return 1;
+    }
+
+    if( !MP4_ReadBoxContainer( p_stream, p_box ) )
+    {
+        return 0;
+    }
+
+    if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
+            ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
+            p_cmvd->data.p_cmvd->data == NULL )
+    {
+        printf( "read box: \"cmov\" incomplete" );
+        return 0;
+    }
+
+    if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
+    {
+        printf( "read box: \"cmov\" compression algorithm : %4.4s "
+                "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
+        return 0;
+    }
+
+#ifndef HAVE_ZLIB_H
+    printf(  "read box: \"cmov\" zlib unsupported" );
+    return 0;
+#else
+
+    /* decompress data */
+    /* allocate a new buffer */
+    if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
+        return 0;
+    /* init default structures */
+    z_data.next_in   = p_cmvd->data.p_cmvd->data;
+    z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
+    z_data.next_out  = p_data;
+    z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
+    z_data.zalloc    = (alloc_func)Z_NULL;
+    z_data.zfree     = (free_func)Z_NULL;
+    z_data.opaque    = (voidpf)Z_NULL;
+
+    /* init zlib */
+    if( inflateInit( &z_data ) != Z_OK )
+    {
+        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+        free( p_data );
+        return 0;
+    }
+
+    /* uncompress */
+    i_result = inflate( &z_data, Z_NO_FLUSH );
+    if( i_result != Z_OK && i_result != Z_STREAM_END )
+    {
+        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+        free( p_data );
+        return 0;
+    }
+
+    if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
+    {
+        printf( "read box: \"cmov\" uncompressing data size "
+                "mismatch" );
+    }
+    p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
+
+    /* close zlib */
+    if( inflateEnd( &z_data ) != Z_OK )
+    {
+        printf( "read box: \"cmov\" error while uncompressing "
+                "data (ignored)" );
+    }
+
+    free( p_cmvd->data.p_cmvd->p_data );
+    p_cmvd->data.p_cmvd->data = p_data;
+    p_cmvd->data.p_cmvd->b_compressed = 0;
+
+    printf( "read box: \"cmov\" box successfully uncompressed" );
+
+    /* now create a memory stream */
+    p_stream_memory =
+        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
+                p_cmvd->data.p_cmvd->uncompressed_size, true );
+
+    /* and read uncompressd moov */
+    p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
+
+    stream_Delete( p_stream_memory );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"cmov\" compressed movie header completed");
+#endif
+
+    return p_box->data.p_cmov->moov ? 1 : 0;
+#endif /* HAVE_ZLIB_H */
+}
+
+static int MP4_ReadBox_rdrf( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_len;
+    unsigned i = 0;
+    MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
+    MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
+    MP4_GET4BYTES( i_len );
+    i_len++;
+
+    if( i_len > 0 )
+    {
+        p_box->data.p_rdrf->psz_ref = malloc( i_len );
+        if( p_box->data.p_rdrf->psz_ref == NULL )
+            MP4_READBOX_EXIT( 0 );
+        i_len--;
+
+        for( i = 0; i < i_len; i++ )
+        {
+            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
+        }
+        p_box->data.p_rdrf->psz_ref[i_len] = '\0';
+    }
+    else
+    {
+        p_box->data.p_rdrf->psz_ref = NULL;
+    }
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rdrf\" type:%4.4s ref %s",
+            (char*)&p_box->data.p_rdrf->ref_type,
+            p_box->data.p_rdrf->psz_ref );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_rdrf( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_rdrf->psz_ref );
+}
+
+
+static int MP4_ReadBox_rmdr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
+
+    MP4_GET4BYTES( p_box->data.p_rmdr->rate );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmdr\" rate:%d",
+            p_box->data.p_rmdr->rate );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmqu( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
+
+    MP4_GET4BYTES( p_box->data.p_rmqu->quality );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmqu\" quality:%d",
+            p_box->data.p_rmqu->quality );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_rmvc( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
+
+    MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
+    MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
+    MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
+    MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
+            (char*)&p_box->data.p_rmvc->gestaltType,
+            p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
+            p_box->data.p_rmvc->checkType );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_frma( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_frma_t );
+
+    MP4_GETFOURCC( p_box->data.p_frma->type );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"frma\" i_type:%4.4s",
+            (char *)&p_box->data.p_frma->i_type );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_skcr( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_skcr_t );
+
+    MP4_GET4BYTES( p_box->data.p_skcr->init );
+    MP4_GET4BYTES( p_box->data.p_skcr->encr );
+    MP4_GET4BYTES( p_box->data.p_skcr->decr );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"skcr\" i_init:%d i_encr:%d i_decr:%d",
+            p_box->data.p_skcr->init,
+            p_box->data.p_skcr->encr,
+            p_box->data.p_skcr->decr );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_drms( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_t *p_drms_box = p_box;
+    void *p_drms = NULL;
+
+    MP4_READBOX_ENTER( uint8_t );
+
+    do
+    {
+        p_drms_box = p_drms_box->p_father;
+    } while( p_drms_box && p_drms_box->i_type != ATOM_drms
+            && p_drms_box->i_type != ATOM_drmi );
+
+    if( p_drms_box && p_drms_box->i_type == ATOM_drms )
+        p_drms = p_drms_box->data.p_sample_soun->drms;
+    else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
+        p_drms = p_drms_box->data.p_sample_vide->drms;
+
+    if( p_drms_box && p_drms )
+    {
+        int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
+        if( i_ret )
+        {
+            assert(0);
+            //             const char *psz_error;
+            // 
+            //             switch( i_ret )
+            //             {
+            //                 case -1: psz_error = "unimplemented"; break;
+            //                 case -2: psz_error = "invalid argument"; break;
+            //                 case -3: psz_error = "could not get system key"; break;
+            //                 case -4: psz_error = "could not get SCI data"; break;
+            //                 case -5: psz_error = "no user key found in SCI data"; break;
+            //                 case -6: psz_error = "invalid user key"; break;
+            //                 default: psz_error = "unknown error"; break;
+            //             }
+            //             if MP4_BOX_TYPE_ASCII()
+            //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
+            //                         (char *)&p_box->i_type, psz_error );
+            //             else
+            //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
+            //                         (char *)&p_box->i_type+1, psz_error );
+            // 
+            //             drms_free( p_drms );
+            // 
+            //             if( p_drms_box->i_type == ATOM_drms )
+            //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
+            //             else if( p_drms_box->i_type == ATOM_drmi )
+            //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
+        }
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_name( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_name_t );
+
+    p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
+    if( p_box->data.p_name->psz_text == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
+    p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"name\" text=`%s'",
+            p_box->data.p_name->psz_text );
+#endif
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_name( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_name->psz_text );
+}
+
+static int MP4_ReadBox_0xa9xxx( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint16_t i16;
+
+    MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
+
+    p_box->data.p_0xa9xxx->psz_text = NULL;
+
+    MP4_GET2BYTES( i16 );
+
+    if( i16 > 0 )
+    {
+        int i_length = i16;
+
+        MP4_GET2BYTES( i16 );
+        if( i_length >= i_read ) i_length = i_read + 1;
+
+        p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
+        if( p_box->data.p_0xa9xxx->psz_text == NULL )
+            MP4_READBOX_EXIT( 0 );
+
+        i_length--;
+        memcpy( p_box->data.p_0xa9xxx->psz_text,
+                p_peek, i_length );
+        p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
+
+#ifdef MP4_VERBOSE
+        printf(
+                "read box: \"c%3.3s\" text=`%s'",
+                ((char*)&p_box->i_type + 1),
+                p_box->data.p_0xa9xxx->psz_text );
+#endif
+    }
+    else
+    {
+        uint32_t i_data_len;
+        uint32_t i_data_tag;
+        /* try iTune/Quicktime format, rewind to start */
+        p_peek -= 2; i_read += 2;
+        // we are expecting a 'data' box
+
+        MP4_GET4BYTES( i_data_len );
+        if( i_data_len > i_read ) i_data_len = i_read;
+        MP4_GETFOURCC( i_data_tag );
+        if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
+        {
+            /* data box contains a version/flags field */
+            uint32_t i_version;
+            uint32_t i_reserved;
+            MP4_GET4BYTES( i_version );
+            MP4_GET4BYTES( i_reserved );
+            // version should be 0, flags should be 1 for text, 0 for data
+            if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
+            {
+                // the rest is the text
+                i_data_len -= 12;
+                p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
+                if( p_box->data.p_0xa9xxx->psz_text == NULL )
+                    MP4_READBOX_EXIT( 0 );
+
+                memcpy( p_box->data.p_0xa9xxx->psz_text,
+                        p_peek, i_data_len );
+                p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
+#ifdef MP4_VERBOSE
+                printf(
+                        "read box: \"c%3.3s\" text=`%s'",
+                        ((char*)&p_box->i_type+1),
+                        p_box->data.p_0xa9xxx->psz_text );
+#endif
+            }
+            else
+            {
+                // TODO: handle data values for ID3 tag values, track num or cover art,etc...
+            }
+        }
+    }
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_0xa9xxx( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_0xa9xxx->psz_text );
+}
+
+/* Chapter support */
+static void MP4_FreeBox_chpl( mp4_box_t *p_box )
+{
+    mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
+    unsigned int i;
+    for(  i = 0; i < p_chpl->chapter; i++ )
+        free( p_chpl->p_chapter[i].psz_name );
+}
+
+static int MP4_ReadBox_chpl( stream_t *p_stream, mp4_box_t *p_box )
+{
+    mp4_box_data_chpl_t *p_chpl;
+    uint32_t i_dummy;
+    int i;
+    MP4_READBOX_ENTER( mp4_box_data_chpl_t );
+
+    p_chpl = p_box->data.p_chpl;
+
+    MP4_GETVERSIONFLAGS( p_chpl );
+
+    MP4_GET4BYTES( i_dummy );
+
+    MP4_GET1BYTE( p_chpl->chapter );
+
+    for( i = 0; i < p_chpl->chapter; i++ )
+    {
+        uint64_t i_start;
+        uint8_t i_len;
+        int i_copy;
+        MP4_GET8BYTES( i_start );
+        MP4_GET1BYTE( i_len );
+
+        p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
+        if( !p_chpl->p_chapter[i].psz_name )
+            MP4_READBOX_EXIT( 0 );
+
+        i_copy = min( i_len, i_read );
+        if( i_copy > 0 )
+            memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
+        p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
+        p_chpl->p_chapter[i].start = i_start;
+
+        p_peek += i_copy;
+        i_read -= i_copy;
+    }
+    /* Bubble sort by increasing start date */
+    do
+    {
+        for( i = 0; i < p_chpl->chapter - 1; i++ )
+        {
+            if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
+            {
+                char *psz = p_chpl->p_chapter[i+1].psz_name;
+                int64_t i64 = p_chpl->p_chapter[i+1].start;
+
+                p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
+                p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
+
+                p_chpl->p_chapter[i].psz_name = psz;
+                p_chpl->p_chapter[i].start = i64;
+
+                i = -1;
+                break;
+            }
+        }
+    } while( i == -1 );
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chpl\" %d chapters",
+            p_chpl->chapter );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tref_generic( stream_t *p_stream, mp4_box_t *p_box )
+{
+    unsigned int i;
+    MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
+
+    p_box->data.p_tref_generic->track_ID = NULL;
+    p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
+    if( p_box->data.p_tref_generic->entry_count > 0 )
+        p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
+    if( p_box->data.p_tref_generic->track_ID == NULL )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
+    {
+        MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
+    }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"chap\" %d references",
+            p_box->data.p_tref_generic->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_tref_generic( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_tref_generic->track_ID );
+}
+
+static int MP4_ReadBox_meta( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint8_t meta_data[8];
+    int i_actually_read;
+
+    // skip over box header
+    i_actually_read = stream_read( p_stream, meta_data, 8 );
+    if( i_actually_read < 8 )
+        return 0;
+
+    /* meta content starts with a 4 byte version/flags value (should be 0) */
+    i_actually_read = stream_read( p_stream, meta_data, 4 );
+    if( i_actually_read < 4 )
+        return 0;
+
+    /* then it behaves like a container */
+    return MP4_ReadBoxContainerRaw( p_stream, p_box );
+}
+
+static int MP4_ReadBox_iods( stream_t *p_stream, mp4_box_t *p_box )
+{
+    char i_unused;
+
+    MP4_READBOX_ENTER( mp4_box_data_iods_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_iods );
+
+    MP4_GET1BYTE( i_unused ); /* tag */
+    MP4_GET1BYTE( i_unused ); /* length */
+
+    MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
+                                                               are used for other flags */
+    MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
+    MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
+            "visual: %i, graphics: %i",
+            p_box->data.p_iods->object_descriptor >> 6,
+            p_box->data.p_iods->OD_profile_level,
+            p_box->data.p_iods->scene_profile_level,
+            p_box->data.p_iods->audio_profile_level,
+            p_box->data.p_iods->visual_profile_level,
+            p_box->data.p_iods->graphics_profile_level );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_pasp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_pasp_t );
+
+    MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
+    MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"paps\" %dx%d",
+            p_box->data.p_pasp->horizontal_spacing,
+            p_box->data.p_pasp->vertical_spacing);
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_mehd( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mehd_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
+    if( p_box->data.p_mehd->version == 1 )
+        MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
+    else /* version == 0 */
+        MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
+
+#ifdef MP4_VERBOSE
+    printf(
+            "read box: \"mehd\" frag dur. %"PRIu64"",
+            p_box->data.p_mehd->fragment_duration );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_trex( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_trex_t );
+    MP4_GETVERSIONFLAGS( p_box->data.p_trex );
+
+    MP4_GET4BYTES( p_box->data.p_trex->track_ID );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
+    MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
+
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"trex\" trackID: %"PRIu32"",
+    //              p_box->data.p_trex->track_ID );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_sdtp( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_sample_count;
+    uint32_t i;
+    mp4_box_data_sdtp_t *p_sdtp = NULL;
+    MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
+    p_sdtp = p_box->data.p_sdtp;
+    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
+    i_sample_count = i_read;
+
+    p_sdtp->sample_table = calloc( i_sample_count, 1 );
+
+    if( !p_sdtp->sample_table )
+        MP4_READBOX_EXIT( 0 );
+
+    for( i = 0; i < i_sample_count; i++ )
+        MP4_GET1BYTE( p_sdtp->sample_table[i] );
+
+    // #ifdef MP4_VERBOSE
+    //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
+    //      printf(
+    //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
+    //                  p_sdtp->sample_table[0],
+    //                  p_sdtp->sample_table[1],
+    //                  p_sdtp->sample_table[2],
+    //                  p_sdtp->sample_table[3] );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static void MP4_FreeBox_sdtp( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_sdtp->sample_table );
+}
+
+static int MP4_ReadBox_mfro( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_mfro_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
+    MP4_GET4BYTES( p_box->data.p_mfro->size );
+
+    // #ifdef MP4_VERBOSE
+    //      printf(
+    //              "read box: \"mfro\" size: %"PRIu32"",
+    //              p_box->data.p_mfro->i_size);
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+
+static int MP4_ReadBox_tfra( stream_t *p_stream, mp4_box_t *p_box )
+{
+    uint32_t i_number_of_entries;
+    mp4_box_data_tfra_t *p_tfra;
+    uint32_t i_lengths;
+    size_t size;
+    uint32_t i;
+    MP4_READBOX_ENTER( mp4_box_data_tfra_t );
+    p_tfra = p_box->data.p_tfra;
+    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
+
+    MP4_GET4BYTES( p_tfra->track_ID );
+    i_lengths = 0;
+    MP4_GET4BYTES( i_lengths );
+    MP4_GET4BYTES( p_tfra->number_of_entries );
+    i_number_of_entries = p_tfra->number_of_entries;
+    p_tfra->length_size_of_traf_num = i_lengths >> 4;
+    p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
+    p_tfra->length_size_of_sample_num = i_lengths & 0x03;
+
+    size = 4 + 4*p_tfra->version; /* size in {4, 8} */
+    p_tfra->time = calloc( i_number_of_entries, size );
+    p_tfra->moof_offset = calloc( i_number_of_entries, size );
+
+    size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
+    p_tfra->traf_number = calloc( i_number_of_entries, size );
+    size = 1 + p_tfra->length_size_of_trun_num;
+    p_tfra->trun_number = calloc( i_number_of_entries, size );
+    size = 1 + p_tfra->length_size_of_sample_num;
+    p_tfra->sample_number = calloc( i_number_of_entries, size );
+
+    if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
+            || !p_tfra->trun_number || !p_tfra->sample_number )
+        goto error;
+
+    for( i = 0; i < i_number_of_entries; i++ )
+    {
+        if( p_tfra->version == 1 )
+        {
+            MP4_GET8BYTES( p_tfra->time[i*2] );
+            MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
+        }
+        else
+        {
+            MP4_GET4BYTES( p_tfra->time[i] );
+            MP4_GET4BYTES( p_tfra->moof_offset[i] );
+        }
+        switch (p_tfra->length_size_of_traf_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->traf_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->traf_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->traf_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->traf_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+
+        switch (p_tfra->length_size_of_trun_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->trun_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->trun_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->trun_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->trun_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+
+        switch (p_tfra->length_size_of_sample_num)
+        {
+            case 0:
+                MP4_GET1BYTE( p_tfra->sample_number[i] );
+                break;
+            case 1:
+                MP4_GET2BYTES( p_tfra->sample_number[i*2] );
+                break;
+            case 2:
+                MP4_GET3BYTES( p_tfra->sample_number[i*3] );
+                break;
+            case 3:
+                MP4_GET4BYTES( p_tfra->sample_number[i*4] );
+                break;
+            default:
+                goto error;
+        }
+    }
+
+    // #ifdef MP4_VERBOSE
+    //     if( p_tfra->version == 0 )
+    //     {
+    //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
+    //                          p_tfra->time[0], p_tfra->moof_offset[0] );
+    // 
+    //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
+    //                          p_tfra->time[1], p_tfra->moof_offset[1] );
+    //     }
+    //     else
+    //     {
+    //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
+    //                 ((uint64_t *)(p_tfra->time))[0],
+    //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
+    // 
+    //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
+    //                 ((uint64_t *)(p_tfra->time))[1],
+    //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
+    //     }
+    // 
+    //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
+    //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
+    // #endif
+
+    MP4_READBOX_EXIT( 1 );
+error:
+    MP4_READBOX_EXIT( 0 );
+}
+
+static void MP4_FreeBox_tfra( mp4_box_t *p_box )
+{
+    FREENULL( p_box->data.p_tfra->time );
+    FREENULL( p_box->data.p_tfra->moof_offset );
+    FREENULL( p_box->data.p_tfra->traf_number );
+    FREENULL( p_box->data.p_tfra->trun_number );
+    FREENULL( p_box->data.p_tfra->sample_number );
+}
+
+
+/* For generic */
+static int MP4_ReadBox_default( stream_t *p_stream, mp4_box_t *p_box )
+{
+    if( !p_box->p_father )
+    {
+        goto unknown;
+    }
+    if( p_box->p_father->i_type == ATOM_stsd )
+    {
+        mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
+        mp4_box_t *p_hdlr;
+
+        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
+                (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
+        {
+            goto unknown;
+        }
+        switch( p_hdlr->data.p_hdlr->handler_type )
+        {
+            case ATOM_soun:
+                return MP4_ReadBox_sample_soun( p_stream, p_box );
+            case ATOM_vide:
+                return MP4_ReadBox_sample_vide( p_stream, p_box );
+            case ATOM_text:
+                return MP4_ReadBox_sample_text( p_stream, p_box );
+            case ATOM_mmth:
+                return MP4_ReadBox_sample_mmth( p_stream, p_box );
+            case ATOM_tx3g:
+            case ATOM_sbtl:
+                return MP4_ReadBox_sample_tx3g( p_stream, p_box );
+            default:
+                printf(
+                        "unknown handler type in stsd (incompletely loaded1)" );
+                return 1;
+        }
+    }
+
+unknown:
+    if MP4_BOX_TYPE_ASCII()
+        printf(
+                "unknown box type %4.4s (incompletely loaded2)",
+                (char*)&p_box->i_type );
+    else
+        printf(
+                "unknown box type c%3.3s (incompletely loaded3)",
+                (char*)&p_box->i_type+1 );
+
+    return 1;
+}
+
+static const struct
+{
+    uint32_t i_type;
+    int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
+    void (*MP4_FreeBox_function )( mp4_box_t *p_box );
+} MP4_Box_Function [] =
+{
+    /* Containers */
+    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+
+    /* specific box */
+    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
+    { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
+    { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
+    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
+    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
+    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
+    { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
+    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
+    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
+    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
+    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
+    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
+    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
+    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
+    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
+    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
+    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
+    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
+    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
+    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
+    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
+    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
+    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
+    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
+    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
+    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
+    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
+    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
+    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
+    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
+    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
+    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
+    { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
+    { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
+    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
+    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
+
+    /* Nothing to do with this box */
+    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+
+    /* for codecs */
+    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+
+    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
+    { ATOM_mjht,    MP4_ReadBox_default,      NULL },
+
+    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
+
+    /* XXX there is 2 box where we could find this entry stbl and tref*/
+    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
+    { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
+
+    /* found in tref box */
+    { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
+    { ATOM_ipir,    MP4_ReadBox_default,      NULL },
+    { ATOM_mpod,    MP4_ReadBox_default,      NULL },
+    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
+
+    /* found in hnti */
+    { ATOM_rtp,     MP4_ReadBox_default,      NULL },
+
+    /* found in rmra */
+    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
+    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
+    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
+    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
+
+    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
+    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
+
+    /* found in udta */
+    { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+    { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+
+    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
+
+    /* iTunes/Quicktime meta info */
+    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
+    { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
+
+    /* found in smoothstreaming */
+    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
+    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
+    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
+    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
+    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
+    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
+    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
+    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
+
+    /* Last entry */
+    { 0,              MP4_ReadBox_default,      NULL }
+};
+
+
+//get full struct of the mp4,main function
+mp4_box_t *MP4_BoxGetRoot(stream_t * s)
+{
+    mp4_box_t *p_root;
+    stream_t *p_stream;
+    int i_result;
+
+    p_root = malloc( sizeof( mp4_box_t ) );
+    if( p_root == NULL )
+        return NULL;
+
+    p_root->i_pos = 0;
+    p_root->i_type = ATOM_root;
+    p_root->i_shortsize = 1;
+
+    stream_seek(s, 0, SEEK_END);
+    p_root->i_size = stream_tell(s);
+    stream_seek(s, 0, SEEK_SET);
+
+    CreateUUID( &p_root->i_uuid, p_root->i_type );
+
+    //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
+    p_root->data.p_data = NULL;
+    p_root->p_father    = NULL;
+    p_root->p_first     = NULL;
+    p_root->p_last      = NULL;
+    p_root->p_next      = NULL;
+
+    p_stream = s;
+
+    i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
+
+    if( i_result )
+    {
+        mp4_box_t *p_moov;
+        mp4_box_t *p_cmov;
+
+        /* check if there is a cmov, if so replace
+           compressed moov by  uncompressed one */
+        if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
+                    ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
+                ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
+                  ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
+        {
+            /* rename the compressed moov as a box to skip */
+            p_moov->i_type = ATOM_skip;
+
+            /* get uncompressed p_moov */
+            p_moov = p_cmov->data.p_cmov->moov;
+            p_cmov->data.p_cmov->moov = NULL;
+
+            /* make p_root father of this new moov */
+            p_moov->p_father = p_root;
+
+            /* insert this new moov box as first child of p_root */
+            p_moov->p_next = p_root->p_first;
+            p_root->p_first = p_moov;
+        }
+    }
+
+    return p_root;
+}
+
+//after  get full struct of the mp4,you can use this function to get the special box
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
+{
+    //mp4_box_t *cur = p_head, *prev = NULL;
+    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+                return(cur); /**/
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    return(cur); /**/
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    return(cur); /**/
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+    return(NULL);
+}
+
+void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type)
+{
+    mp4_box_t *cur = p_head, *prev = NULL;
+    //mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    //mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+
+                //*search_box=cur;
+                free(cur);
+                free(prev);
+                break;
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    //*search_box=cur;
+                    free(cur);
+                    free(prev);
+                    break;
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    //*search_box=cur;
+                    free(cur);
+                    free(prev);
+                    break;
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+
+}
+
+//after  get full struct of the mp4,you can use this function to get the special box
+int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type)
+{
+    //mp4_box_t *cur = p_head, *prev = NULL;
+    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    cur = p_head;
+    prev = NULL;
+
+    while (cur != NULL)
+    {
+        if (cur->p_first == NULL)          // 1.
+        {
+            if(cur->i_type == i_type)
+            {
+                printf("1\n");
+                //return(1); /**/
+                //					return(cur); /**/
+            }
+            cur = cur->p_next;
+        }
+        else
+        {
+            // find predecessor
+            prev = cur->p_first;
+            while (prev->p_next != NULL && prev->p_next != cur)
+                prev = prev->p_next;
+
+            if (prev->p_next == NULL)   // 2.a)
+            {
+                prev->p_next = cur;
+                if(cur->i_type == i_type)
+                {
+                    printf("2\n");
+                    //              		return(2); /**/
+                    //						return(cur); /**/
+                }
+                cur = cur->p_first;
+            }
+            else                       // 2.b)
+            {
+                prev->p_next = NULL;
+                if(cur->i_type == i_type)
+                {
+                    printf("3\n");
+                    //              	return(3); /**/
+                    //						return(cur); /**/
+                }
+                cur = cur->p_next;
+            }
+        }
+    }
+    printf("aa0\n");
+    //    return(0);
+}
+/*****************************************************************************
+ * MP4_ReadBox : parse the actual box and the children
+ *  XXX : Do not go to the next box
+ *****************************************************************************/
+static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
+{
+    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+    unsigned int i_index;
+
+    if( p_box == NULL )
+        return NULL;
+
+    if( !MP4_ReadBoxCommon( p_stream, p_box ) )
+    {
+        printf( "cannot read one box" );
+        free( p_box );
+        return NULL;
+    }
+    if( !p_box->i_size )
+    {
+        printf( "found an empty box (null size)" );
+        free( p_box );
+        return NULL;
+    }
+    p_box->p_father = p_father;
+
+    /* Now search function to call */
+    for( i_index = 0; ; i_index++ )
+    {
+        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+                ( MP4_Box_Function[i_index].i_type == 0 ) )
+        {
+            break;
+        }
+    }
+
+    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
+    {
+        MP4_BoxFree( p_stream, p_box );
+        return NULL;
+    }
+
+    return p_box;
+}
+
+void MP4_BoxFree( stream_t *s, mp4_box_t *p_box )
+{
+    unsigned int i_index;
+    mp4_box_t    *p_child;
+
+    if( !p_box )
+        return; /* hehe */
+
+    for( p_child = p_box->p_first; p_child != NULL; )
+    {
+        mp4_box_t *p_next;
+
+        p_next = p_child->p_next;
+        MP4_BoxFree( s, p_child );
+        p_child = p_next;
+    }
+
+    /* Now search function to call */
+    if( p_box->data.p_data )
+    {
+        for( i_index = 0; ; i_index++ )
+        {
+            if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+                    ( MP4_Box_Function[i_index].i_type == 0 ) )
+            {
+                break;
+            }
+        }
+        if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
+        {
+            /* Should not happen */
+            if MP4_BOX_TYPE_ASCII()
+                printf(
+                        "cannot free box %4.4s, type unknown",
+                        (char*)&p_box->i_type );
+            else
+                printf(
+                        "cannot free box c%3.3s, type unknown",
+                        (char*)&p_box->i_type+1 );
+        }
+        else
+        {
+            MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
+        }
+        free( p_box->data.p_data );
+    }
+    free( p_box );
+}
+
+/*****************************************************************************
+ *****************************************************************************
+ **
+ **  High level methods to acces an MP4 file
+ **
+ *****************************************************************************
+ *****************************************************************************/
+static void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )
+{
+    size_t i_len ;
+    if( !*ppsz_path[0] )
+    {
+        *ppsz_token = NULL;
+        *pi_number = 0;
+        return;
+    }
+    i_len = strcspn( *ppsz_path, "/[" );
+    if( !i_len && **ppsz_path == '/' )
+    {
+        i_len = 1;
+    }
+    *ppsz_token = malloc( i_len + 1 );
+
+    memcpy( *ppsz_token, *ppsz_path, i_len );
+
+    (*ppsz_token)[i_len] = '\0';
+
+    *ppsz_path += i_len;
+
+    if( **ppsz_path == '[' )
+    {
+        (*ppsz_path)++;
+        *pi_number = strtol( *ppsz_path, NULL, 10 );
+        while( **ppsz_path && **ppsz_path != ']' )
+        {
+            (*ppsz_path)++;
+        }
+        if( **ppsz_path == ']' )
+        {
+            (*ppsz_path)++;
+        }
+    }
+    else
+    {
+        *pi_number = 0;
+    }
+    while( **ppsz_path == '/' )
+    {
+        (*ppsz_path)++;
+    }
+}
+
+static void MP4_BoxGet_Internal(mp4_box_t **pp_result,
+        mp4_box_t *p_box, const char *psz_fmt, va_list args)
+{
+    char *psz_dup;
+    char *psz_path = malloc(4096);
+    char *psz_token;
+
+    if( !p_box )
+    {
+        *pp_result = NULL;
+        return;
+    }
+
+    if( vsprintf( psz_path, psz_fmt, args ) == -1 )
+        psz_path = NULL;
+
+    if( !psz_path || !psz_path[0] )
+    {
+        free( psz_path );
+        *pp_result = NULL;
+        return;
+    }
+
+    //    fprintf( stderr, "path:'%s'\n", psz_path );
+    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
+    for( ; ; )
+    {
+        int i_number;
+
+        get_token( &psz_path, &psz_token, &i_number );
+        //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
+        //                 psz_path,psz_token,i_number );
+        if( !psz_token )
+        {
+            free( psz_dup );
+            *pp_result = p_box;
+            return;
+        }
+        else
+            if( !strcmp( psz_token, "/" ) )
+            {
+                /* Find root box */
+                while( p_box && p_box->i_type != ATOM_root )
+                {
+                    p_box = p_box->p_father;
+                }
+                if( !p_box )
+                {
+                    goto error_box;
+                }
+            }
+            else
+                if( !strcmp( psz_token, "." ) )
+                {
+                    /* Do nothing */
+                }
+                else
+                    if( !strcmp( psz_token, ".." ) )
+                    {
+                        p_box = p_box->p_father;
+                        if( !p_box )
+                        {
+                            goto error_box;
+                        }
+                    }
+                    else
+                        if( strlen( psz_token ) == 4 )
+                        {
+                            uint32_t i_fourcc;
+                            i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
+                                    psz_token[2], psz_token[3] );
+                            p_box = p_box->p_first;
+                            for( ; ; )
+                            {
+                                if( !p_box )
+                                {
+                                    goto error_box;
+                                }
+                                if( p_box->i_type == i_fourcc )
+                                {
+                                    if( !i_number )
+                                    {
+                                        break;
+                                    }
+                                    i_number--;
+                                }
+                                p_box = p_box->p_next;
+                            }
+                        }
+                        else
+                            if( *psz_token == '\0' )
+                            {
+                                p_box = p_box->p_first;
+                                for( ; ; )
+                                {
+                                    if( !p_box )
+                                    {
+                                        goto error_box;
+                                    }
+                                    if( !i_number )
+                                    {
+                                        break;
+                                    }
+                                    i_number--;
+                                    p_box = p_box->p_next;
+                                }
+                            }
+                            else
+                            {
+                                //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
+                                goto error_box;
+                            }
+
+        FREENULL( psz_token );
+    }
+
+    return;
+
+error_box:
+    free( psz_token );
+    free( psz_dup );
+    *pp_result = NULL;
+    return;
+}
+
+mp4_box_t * MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...)
+{
+    va_list args;
+    mp4_box_t *p_result;
+
+    va_start( args, psz_fmt );
+    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
+    va_end( args );
+
+    return( p_result );
+}
+
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
new file mode 100644
index 0000000..1d045dd
--- /dev/null
+++ b/net/mmt/mpu/mp4.h
@@ -0,0 +1,1218 @@
+#ifndef NET_MMT_MPU_MP4_H_
+#define NET_MMT_MPU_MP4_H_
+
+#include "net/mmt/mpu/stream.h"
+
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_tfdt MP4_FOURCC( 't', 'f', 'd', 't' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_foov MP4_FOURCC( 'f', 'o', 'o', 'v' )
+#define ATOM_cmov MP4_FOURCC( 'c', 'm', 'o', 'v' )
+#define ATOM_dcom MP4_FOURCC( 'd', 'c', 'o', 'm' )
+#define ATOM_cmvd MP4_FOURCC( 'c', 'm', 'v', 'd' )
+
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+#define ATOM_skip MP4_FOURCC( 's', 'k', 'i', 'p' )
+#define ATOM_free MP4_FOURCC( 'f', 'r', 'e', 'e' )
+#define ATOM_udta MP4_FOURCC( 'u', 'd', 't', 'a' )
+#define ATOM_wide MP4_FOURCC( 'w', 'i', 'd', 'e' )
+
+#define ATOM_data MP4_FOURCC( 'd', 'a', 't', 'a' )
+
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mvhd MP4_FOURCC( 'm', 'v', 'h', 'd' )
+#define ATOM_tkhd MP4_FOURCC( 't', 'k', 'h', 'd' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_tref MP4_FOURCC( 't', 'r', 'e', 'f' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_mdhd MP4_FOURCC( 'm', 'd', 'h', 'd' )
+#define ATOM_hdlr MP4_FOURCC( 'h', 'd', 'l', 'r' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_vmhd MP4_FOURCC( 'v', 'm', 'h', 'd' )
+#define ATOM_smhd MP4_FOURCC( 's', 'm', 'h', 'd' )
+#define ATOM_hmhd MP4_FOURCC( 'h', 'm', 'h', 'd' )
+#define ATOM_dinf MP4_FOURCC( 'd', 'i', 'n', 'f' )
+#define ATOM_url  MP4_FOURCC( 'u', 'r', 'l', ' ' )
+#define ATOM_urn  MP4_FOURCC( 'u', 'r', 'n', ' ' )
+#define ATOM_dref MP4_FOURCC( 'd', 'r', 'e', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stts MP4_FOURCC( 's', 't', 't', 's' )
+#define ATOM_ctts MP4_FOURCC( 'c', 't', 't', 's' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_stsz MP4_FOURCC( 's', 't', 's', 'z' )
+#define ATOM_stz2 MP4_FOURCC( 's', 't', 'z', '2' )
+#define ATOM_stsc MP4_FOURCC( 's', 't', 's', 'c' )
+#define ATOM_stco MP4_FOURCC( 's', 't', 'c', 'o' )
+#define ATOM_co64 MP4_FOURCC( 'c', 'o', '6', '4' )
+#define ATOM_stss MP4_FOURCC( 's', 't', 's', 's' )
+#define ATOM_stsh MP4_FOURCC( 's', 't', 's', 'h' )
+#define ATOM_stdp MP4_FOURCC( 's', 't', 'd', 'p' )
+#define ATOM_padb MP4_FOURCC( 'p', 'a', 'd', 'b' )
+#define ATOM_edts MP4_FOURCC( 'e', 'd', 't', 's' )
+#define ATOM_elst MP4_FOURCC( 'e', 'l', 's', 't' )
+#define ATOM_mvex MP4_FOURCC( 'm', 'v', 'e', 'x' )
+#define ATOM_sdtp MP4_FOURCC( 's', 'd', 't', 'p' )
+#define ATOM_trex MP4_FOURCC( 't', 'r', 'e', 'x' )
+#define ATOM_mehd MP4_FOURCC( 'm', 'e', 'h', 'd' )
+#define ATOM_mfhd MP4_FOURCC( 'm', 'f', 'h', 'd' )
+#define ATOM_traf MP4_FOURCC( 't', 'r', 'a', 'f' )
+#define ATOM_tfhd MP4_FOURCC( 't', 'f', 'h', 'd' )
+#define ATOM_trun MP4_FOURCC( 't', 'r', 'u', 'n' )
+#define ATOM_cprt MP4_FOURCC( 'c', 'p', 'r', 't' )
+#define ATOM_iods MP4_FOURCC( 'i', 'o', 'd', 's' )
+#define ATOM_pasp MP4_FOURCC( 'p', 'a', 's', 'p' )
+#define ATOM_mfra MP4_FOURCC( 'm', 'f', 'r', 'a' )
+#define ATOM_mfro MP4_FOURCC( 'm', 'f', 'r', 'o' )
+#define ATOM_tfra MP4_FOURCC( 't', 'f', 'r', 'a' )
+
+#define ATOM_nmhd MP4_FOURCC( 'n', 'm', 'h', 'd' )
+#define ATOM_mp2v MP4_FOURCC( 'm', 'p', '2', 'v' )
+#define ATOM_mp4v MP4_FOURCC( 'm', 'p', '4', 'v' )
+#define ATOM_mp4a MP4_FOURCC( 'm', 'p', '4', 'a' )
+#define ATOM_mp4s MP4_FOURCC( 'm', 'p', '4', 's' )
+#define ATOM_vide MP4_FOURCC( 'v', 'i', 'd', 'e' )
+#define ATOM_soun MP4_FOURCC( 's', 'o', 'u', 'n' )
+#define ATOM_mmth MP4_FOURCC( 'm', 'm', 't', 'h' )
+#define ATOM_hint MP4_FOURCC( 'h', 'i', 'n', 't' )
+#define ATOM_hdv2 MP4_FOURCC( 'h', 'd', 'v', '2' )
+
+#define ATOM_dpnd MP4_FOURCC( 'd', 'p', 'n', 'd' )
+#define ATOM_ipir MP4_FOURCC( 'i', 'p', 'i', 'r' )
+#define ATOM_mpod MP4_FOURCC( 'm', 'p', 'o', 'd' )
+#define ATOM_hnti MP4_FOURCC( 'h', 'n', 't', 'i' )
+#define ATOM_rtp  MP4_FOURCC( 'r', 't', 'p', ' ' )
+
+#define ATOM_isom MP4_FOURCC( 'i', 's', 'o', 'm' )
+#define ATOM_3gp4 MP4_FOURCC( '3', 'g', 'p', '4' )
+#define ATOM_esds MP4_FOURCC( 'e', 's', 'd', 's' )
+
+#define ATOM__mp3 MP4_FOURCC( '.', 'm', 'p', '3' )
+#define ATOM_ms02 MP4_FOURCC( 'm', 's', 0x0, 0x02 )
+#define ATOM_ms11 MP4_FOURCC( 'm', 's', 0x0, 0x11 )
+#define ATOM_ms55 MP4_FOURCC( 'm', 's', 0x0, 0x55 )
+#define ATOM_twos MP4_FOURCC( 't', 'w', 'o', 's' )
+#define ATOM_sowt MP4_FOURCC( 's', 'o', 'w', 't' )
+#define ATOM_QDMC MP4_FOURCC( 'Q', 'D', 'M', 'C' )
+#define ATOM_QDM2 MP4_FOURCC( 'Q', 'D', 'M', '2' )
+#define ATOM_ima4 MP4_FOURCC( 'i', 'm', 'a', '4' )
+#define ATOM_IMA4 MP4_FOURCC( 'I', 'M', 'A', '4' )
+#define ATOM_dvi  MP4_FOURCC( 'd', 'v', 'i', ' ' )
+#define ATOM_MAC3 MP4_FOURCC( 'M', 'A', 'C', '3' )
+#define ATOM_MAC6 MP4_FOURCC( 'M', 'A', 'C', '6' )
+#define ATOM_alaw MP4_FOURCC( 'a', 'l', 'a', 'w' )
+#define ATOM_ulaw MP4_FOURCC( 'u', 'l', 'a', 'w' )
+#define ATOM_Qclp MP4_FOURCC( 'Q', 'c', 'l', 'p' )
+#define ATOM_samr MP4_FOURCC( 's', 'a', 'm', 'r' )
+#define ATOM_sawb MP4_FOURCC( 's', 'a', 'w', 'b' )
+#define ATOM_OggS MP4_FOURCC( 'O', 'g', 'g', 'S' )
+#define ATOM_alac MP4_FOURCC( 'a', 'l', 'a', 'c' )
+#define ATOM_dac3 MP4_FOURCC( 'd', 'a', 'c', '3' )
+#define ATOM_dec3 MP4_FOURCC( 'd', 'e', 'c', '3' )
+#define ATOM_enda MP4_FOURCC( 'e', 'n', 'd', 'a' )
+#define ATOM_gnre MP4_FOURCC( 'g', 'n', 'r', 'e' )
+#define ATOM_trkn MP4_FOURCC( 't', 'r', 'k', 'n' )
+
+#define ATOM_zlib MP4_FOURCC( 'z', 'l', 'i', 'b' )
+#define ATOM_SVQ1 MP4_FOURCC( 'S', 'V', 'Q', '1' )
+#define ATOM_SVQ3 MP4_FOURCC( 'S', 'V', 'Q', '3' )
+#define ATOM_ZyGo MP4_FOURCC( 'Z', 'y', 'G', 'o' )
+#define ATOM_3IV1 MP4_FOURCC( '3', 'I', 'V', '1' )
+#define ATOM_3iv1 MP4_FOURCC( '3', 'i', 'v', '1' )
+#define ATOM_3IV2 MP4_FOURCC( '3', 'I', 'V', '2' )
+#define ATOM_3iv2 MP4_FOURCC( '3', 'i', 'v', '2' )
+#define ATOM_3IVD MP4_FOURCC( '3', 'I', 'V', 'D' )
+#define ATOM_3ivd MP4_FOURCC( '3', 'i', 'v', 'd' )
+#define ATOM_3VID MP4_FOURCC( '3', 'V', 'I', 'D' )
+#define ATOM_3vid MP4_FOURCC( '3', 'v', 'i', 'd' )
+#define ATOM_h263 MP4_FOURCC( 'h', '2', '6', '3' )
+#define ATOM_s263 MP4_FOURCC( 's', '2', '6', '3' )
+#define ATOM_DIVX MP4_FOURCC( 'D', 'I', 'V', 'X' )
+#define ATOM_XVID MP4_FOURCC( 'X', 'V', 'I', 'D' )
+#define ATOM_cvid MP4_FOURCC( 'c', 'v', 'i', 'd' )
+#define ATOM_mjpa MP4_FOURCC( 'm', 'j', 'p', 'a' )
+#define ATOM_mjpb MP4_FOURCC( 'm', 'j', 'q', 't' )
+#define ATOM_mjqt MP4_FOURCC( 'm', 'j', 'h', 't' )
+#define ATOM_mjht MP4_FOURCC( 'm', 'j', 'p', 'b' )
+#define ATOM_VP31 MP4_FOURCC( 'V', 'P', '3', '1' )
+#define ATOM_vp31 MP4_FOURCC( 'v', 'p', '3', '1' )
+#define ATOM_h264 MP4_FOURCC( 'h', '2', '6', '4' )
+#define ATOM_qdrw MP4_FOURCC( 'q', 'd', 'r', 'w' )
+
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+#define ATOM_m4ds MP4_FOURCC( 'm', '4', 'd', 's' )
+
+#define ATOM_dvc  MP4_FOURCC( 'd', 'v', 'c', ' ' )
+#define ATOM_dvp  MP4_FOURCC( 'd', 'v', 'p', ' ' )
+#define ATOM_dv5n MP4_FOURCC( 'd', 'v', '5', 'n' )
+#define ATOM_dv5p MP4_FOURCC( 'd', 'v', '5', 'p' )
+#define ATOM_raw  MP4_FOURCC( 'r', 'a', 'w', ' ' )
+
+#define ATOM_jpeg MP4_FOURCC( 'j', 'p', 'e', 'g' )
+
+#define ATOM_yv12 MP4_FOURCC( 'y', 'v', '1', '2' )
+#define ATOM_yuv2 MP4_FOURCC( 'y', 'u', 'v', '2' )
+
+#define ATOM_rmra MP4_FOURCC( 'r', 'm', 'r', 'a' )
+#define ATOM_rmda MP4_FOURCC( 'r', 'm', 'd', 'a' )
+#define ATOM_rdrf MP4_FOURCC( 'r', 'd', 'r', 'f' )
+#define ATOM_rmdr MP4_FOURCC( 'r', 'm', 'd', 'r' )
+#define ATOM_rmvc MP4_FOURCC( 'r', 'm', 'v', 'c' )
+#define ATOM_rmcd MP4_FOURCC( 'r', 'm', 'c', 'd' )
+#define ATOM_rmqu MP4_FOURCC( 'r', 'm', 'q', 'u' )
+#define ATOM_alis MP4_FOURCC( 'a', 'l', 'i', 's' )
+
+#define ATOM_gmhd MP4_FOURCC( 'g', 'm', 'h', 'd' )
+#define ATOM_wave MP4_FOURCC( 'w', 'a', 'v', 'e' )
+
+#define ATOM_drms MP4_FOURCC( 'd', 'r', 'm', 's' )
+#define ATOM_sinf MP4_FOURCC( 's', 'i', 'n', 'f' )
+#define ATOM_schi MP4_FOURCC( 's', 'c', 'h', 'i' )
+#define ATOM_user MP4_FOURCC( 'u', 's', 'e', 'r' )
+#define ATOM_key  MP4_FOURCC( 'k', 'e', 'y', ' ' )
+#define ATOM_iviv MP4_FOURCC( 'i', 'v', 'i', 'v' )
+#define ATOM_name MP4_FOURCC( 'n', 'a', 'm', 'e' )
+#define ATOM_priv MP4_FOURCC( 'p', 'r', 'i', 'v' )
+#define ATOM_drmi MP4_FOURCC( 'd', 'r', 'm', 'i' )
+#define ATOM_frma MP4_FOURCC( 'f', 'r', 'm', 'a' )
+#define ATOM_skcr MP4_FOURCC( 's', 'k', 'c', 'r' )
+
+#define ATOM_text MP4_FOURCC( 't', 'e', 'x', 't' )
+#define ATOM_tx3g MP4_FOURCC( 't', 'x', '3', 'g' )
+#define ATOM_subp MP4_FOURCC( 's', 'u', 'b', 'p' )
+#define ATOM_sbtl MP4_FOURCC( 's', 'b', 't', 'l' )
+
+#define ATOM_0xa9nam MP4_FOURCC( 0xa9, 'n', 'a', 'm' )
+#define ATOM_0xa9aut MP4_FOURCC( 0xa9, 'a', 'u', 't' )
+#define ATOM_0xa9cpy MP4_FOURCC( 0xa9, 'c', 'p', 'y' )
+#define ATOM_0xa9inf MP4_FOURCC( 0xa9, 'i', 'n', 'f' )
+#define ATOM_0xa9ART MP4_FOURCC( 0xa9, 'A', 'R', 'T' )
+#define ATOM_0xa9des MP4_FOURCC( 0xa9, 'd', 'e', 's' )
+#define ATOM_0xa9dir MP4_FOURCC( 0xa9, 'd', 'i', 'r' )
+#define ATOM_0xa9cmt MP4_FOURCC( 0xa9, 'c', 'm', 't' )
+#define ATOM_0xa9req MP4_FOURCC( 0xa9, 'r', 'e', 'q' )
+#define ATOM_0xa9day MP4_FOURCC( 0xa9, 'd', 'a', 'y' )
+#define ATOM_0xa9fmt MP4_FOURCC( 0xa9, 'f', 'm', 't' )
+#define ATOM_0xa9prd MP4_FOURCC( 0xa9, 'p', 'r', 'd' )
+#define ATOM_0xa9prf MP4_FOURCC( 0xa9, 'p', 'r', 'f' )
+#define ATOM_0xa9src MP4_FOURCC( 0xa9, 's', 'r', 'c' )
+#define ATOM_0xa9alb MP4_FOURCC( 0xa9, 'a', 'l', 'b' )
+#define ATOM_0xa9dis MP4_FOURCC( 0xa9, 'd', 'i', 's' )
+#define ATOM_0xa9enc MP4_FOURCC( 0xa9, 'e', 'n', 'c' )
+#define ATOM_0xa9trk MP4_FOURCC( 0xa9, 't', 'r', 'k' )
+#define ATOM_0xa9url MP4_FOURCC( 0xa9, 'u', 'r', 'l' )
+#define ATOM_0xa9dsa MP4_FOURCC( 0xa9, 'd', 's', 'a' )
+#define ATOM_0xa9hst MP4_FOURCC( 0xa9, 'h', 's', 't' )
+#define ATOM_0xa9ope MP4_FOURCC( 0xa9, 'o', 'p', 'e' )
+#define ATOM_0xa9wrt MP4_FOURCC( 0xa9, 'w', 'r', 't' )
+#define ATOM_0xa9com MP4_FOURCC( 0xa9, 'c', 'o', 'm' )
+#define ATOM_0xa9gen MP4_FOURCC( 0xa9, 'g', 'e', 'n' )
+#define ATOM_0xa9too MP4_FOURCC( 0xa9, 't', 'o', 'o' )
+#define ATOM_0xa9wrn MP4_FOURCC( 0xa9, 'w', 'r', 'n' )
+#define ATOM_0xa9swr MP4_FOURCC( 0xa9, 's', 'w', 'r' )
+#define ATOM_0xa9mak MP4_FOURCC( 0xa9, 'm', 'a', 'k' )
+#define ATOM_0xa9mod MP4_FOURCC( 0xa9, 'm', 'o', 'd' )
+#define ATOM_0xa9PRD MP4_FOURCC( 0xa9, 'P', 'R', 'D' )
+#define ATOM_0xa9grp MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_0xa9lyr MP4_FOURCC( 0xa9, 'g', 'r', 'p' )
+#define ATOM_chpl MP4_FOURCC( 'c', 'h', 'p', 'l' )
+#define ATOM_WLOC MP4_FOURCC( 'W', 'L', 'O', 'C' )
+
+#define ATOM_meta MP4_FOURCC( 'm', 'e', 't', 'a' )
+#define ATOM_ilst MP4_FOURCC( 'i', 'l', 's', 't' )
+
+#define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
+
+
+
+typedef struct uuid_s
+{
+   uint8_t b[16];
+} uuid_t;
+
+/* specific structure for all boxes */
+typedef struct mp4_box_data_ftyp_s
+{
+   uint32_t major_brand;
+   uint32_t minor_version;
+
+   uint32_t compatible_brands_count;
+   uint32_t *compatible_brands;
+
+} mp4_box_data_ftyp_t;
+
+typedef struct mp4_box_data_mmpu_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint8_t  is_complete;
+	uint8_t  reserved;
+   uint32_t mpu_sequence_number;
+   uint32_t asset_id_scheme;
+   uint32_t asset_id_length;
+   char *asset_id_value;
+
+} mp4_box_data_mmpu_t;
+
+typedef struct mp4_box_data_tfdt_s
+{
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+
+} mp4_box_data_tfdt_t;
+
+typedef struct mp4_box_data_mvhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+
+} mp4_box_data_mvhd_t;
+
+#define MP4_TRACK_ENABLED    0x000001
+#define MP4_TRACK_IN_MOVIE   0x000002
+#define MP4_TRACK_IN_PREVIEW 0x000004
+
+typedef struct mp4_box_data_tkhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t track_id;
+   uint32_t reserved;
+   uint64_t duration;
+
+   uint32_t reserved2[2];
+   int16_t  layer;
+   int16_t  predefined;
+
+   int16_t  volume;
+   uint16_t reserved3;
+   int32_t  matrix[9];
+   int32_t  width;
+   int32_t  height;
+
+} mp4_box_data_tkhd_t;
+
+typedef struct mp4_box_data_hint_s
+{
+
+	uint32_t track_IDs;
+
+} mp4_box_data_hint_t;
+
+typedef struct mp4_box_data_mdhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   /* one bit for pad */
+   uint16_t language_code;
+   /* unsigned int(5)[3] language difference with 0x60*/
+   unsigned char language[3];
+   uint16_t predefined;
+
+} mp4_box_data_mdhd_t;
+
+typedef struct mp4_box_data_hdlr_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t predefined;
+    uint32_t handler_type; /* "vide" "soun" "hint" "odsm" "crsm" "sdsm" "m7sm" "ocsm" "ipsm" "mjsm" */
+
+    unsigned char *psz_name; /* in UTF-8 */
+
+} mp4_box_data_hdlr_t;
+
+typedef struct mp4_box_data_vmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  graphics_mode;
+   int16_t  opcolor[3];
+
+} mp4_box_data_vmhd_t;
+
+typedef struct mp4_box_data_smhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   int16_t  balance;
+   int16_t  reserved;
+
+} mp4_box_data_smhd_t;
+
+typedef struct mp4_box_data_hmhd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t max_PDU_size;
+   uint16_t avg_PDU_size;
+   uint32_t max_bitrate;
+   uint32_t avg_bitrate;
+   uint32_t reserved;
+
+} mp4_box_data_hmhd_t;
+
+typedef struct mp4_box_data_url_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   char *psz_location;
+
+} mp4_box_data_url_t;
+
+typedef struct mp4_box_data_urn_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    char *psz_name;
+    char *psz_location;
+
+} mp4_box_data_urn_t;
+
+typedef struct mp4_box_data_dref_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_dref_t;
+
+typedef struct mp4_box_data_stts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_delta;
+
+} mp4_box_data_stts_t;
+
+typedef struct mp4_box_data_ctts_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_count; /* these are array */
+    int32_t  *sample_offset;
+
+} mp4_box_data_ctts_t;
+
+
+typedef struct mp4_box_data_sample_soun_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    //uint32_t reserved2[2];
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint16_t channelcount;
+    uint16_t samplesize;
+    uint16_t predefined;
+    uint16_t reserved3;
+    uint16_t sampleratehi; /* timescale of track */
+    uint16_t sampleratelo;
+
+    /* for version 1 (reserved1[0] == 1) */
+    uint32_t sample_per_packet;
+    uint32_t bytes_per_packet;
+    uint32_t bytes_per_frame;
+    uint32_t bytes_per_sample;
+
+    /* XXX hack */
+    int     qt_description;
+    uint8_t *p_qt_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_soun_t;
+
+typedef struct mp4_box_data_sample_vide_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t qt_version;
+    uint16_t qt_revision_level;
+    uint32_t qt_vendor;
+
+    uint32_t qt_temporal_quality;
+    uint32_t qt_spatial_quality;
+
+    int16_t  width;
+    int16_t  height;
+
+    uint32_t horizresolution;
+    uint32_t vertresolution;
+
+    uint32_t qt_data_size;
+    uint16_t qt_frame_count;
+
+    uint8_t  compressorname[32];
+    int16_t  depth;
+
+    int16_t  qt_color_table;
+
+    /* XXX hack ImageDescription */
+    int     qt_image_description;
+    uint8_t *p_qt_image_description;
+
+    void    *drms;
+
+} mp4_box_data_sample_vide_t;
+
+typedef struct mp4_box_data_sample_mmth_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint16_t hinttrackversion;
+    uint16_t highestcompatibleversion;
+    uint16_t packet_id;
+    uint8_t has_mfus_flag;
+    uint8_t is_timed;
+    uint8_t reserved;
+    /*uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;*/
+
+} mp4_box_data_sample_mmth_t;
+
+typedef struct mp4_box_data_mmthsample_s
+{
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t moviefragmentsequencenumber;
+	uint32_t samplenumber;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+	uint16_t item_ID;
+
+} mp4_box_data_mmthsample_t;
+
+typedef struct mp4_box_data_muli_s
+{
+	uint8_t multilayer_flag:1;
+	uint8_t reserved0:7;
+	uint8_t dependency_id:3;
+	uint8_t depth_flag:1;
+	uint8_t reserved1:4;
+	uint8_t temporal_id:3;
+	uint8_t reserved2:1;
+	uint8_t quality_id:4;
+	uint8_t priority_id:6;
+	uint16_t view_id:10;
+
+	uint8_t layer_id:6;
+	//uint8_t temporal_id:3;
+	uint8_t reserved3:7;
+
+} mp4_box_data_muli_t;
+
+
+
+#define MP4_TEXT_DISPLAY_FLAG_DONT_DISPLAY       (1<<0)
+#define MP4_TEXT_DISPLAY_FLAG_AUTO_SCALE         (1<<1)
+#define MP4_TEXT_DISPLAY_FLAG_CLIP_TO_TEXT_BOX   (1<<2)
+#define MP4_TEXT_DISPLAY_FLAG_USE_MOVIE_BG_COLOR (1<<3)
+#define MP4_TEXT_DISPLAY_FLAG_SHRINK_TEXT_BOX_TO_FIT (1<<4)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_IN          (1<<5)
+#define MP4_TEXT_DISPLAY_FLAG_SCROLL_OUT         (1<<6)
+#define MP4_TEXT_DISPLAY_FLAG_HORIZONTAL_SCROLL  (1<<7)
+#define MP4_TEXT_DISPLAY_FLAG_REVERSE_SCROLL     (1<<8)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_SCROLL  (1<<9)
+#define MP4_TEXT_DISPLAY_FLAG_FLOW_HORIZONTAL    (1<<10)
+#define MP4_TEXT_DISPLAY_FLAG_CONTINUOUS_KARAOKE (1<<11)
+#define MP4_TEXT_DISPLAY_FLAG_DROP_SHADOW        (1<<12)
+#define MP4_TEXT_DISPLAY_FLAG_ANTI_ALIAS         (1<<13)
+#define MP4_TEXT_DISPLAY_FLAG_KEYED_TEXT         (1<<14)
+#define MP4_TEXT_DISPLAY_FLAG_INVERSE_HILITE     (1<<15)
+#define MP4_TEXT_DISPLAY_FLAG_COLOR_HILITE       (1<<16)
+#define MP4_TEXT_DISPLAY_FLAG_WRITE_VERTICALLY   (1<<17)
+
+typedef struct
+{
+    uint32_t reserved1;
+    uint16_t reserved2;
+
+    uint16_t data_reference_index;
+
+    uint32_t display_flags;   // TextDescription and Tx3gDescription
+
+    int8_t justification_horizontal; // left(0), centered(1), right(-1)
+    int8_t justification_vertical;   // top(0), centered(1), bottom(-1)
+
+    uint16_t background_color[4];
+
+    uint16_t text_box_top;
+    uint16_t text_box_left;
+    uint16_t text_box_bottom;
+    uint16_t text_box_right;
+
+    // TODO to complete
+} mp4_box_data_sample_text_t;
+
+typedef struct mp4_box_data_sample_hint_s
+{
+    uint8_t  reserved1[6];
+    uint16_t data_reference_index;
+
+    uint8_t *data;
+
+} mp4_box_data_sample_hint_t;
+
+typedef struct mp4_box_data_moviehintinformation_rtp_s
+{
+    uint32_t description_format;
+    unsigned char *psz_text;
+
+} mp4_box_data_moviehintinformation_rtp_t;
+
+
+
+typedef struct mp4_box_data_stsd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    /* it contains SampleEntry handled as if it was Box */
+
+} mp4_box_data_stsd_t;
+
+
+typedef struct mp4_box_data_stsz_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array , empty if sample_size != 0 */
+
+} mp4_box_data_stsz_t;
+
+typedef struct mp4_box_data_stz2_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_size; /* 24 bits */
+    uint8_t  field_size;
+    uint32_t sample_count;
+
+    uint32_t *entry_size; /* array: unsigned int(field_size) entry_size */
+
+} mp4_box_data_stz2_t;
+
+typedef struct mp4_box_data_stsc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *first_chunk; /* theses are arrays */
+    uint32_t *samples_per_chunk;
+    uint32_t *sample_description_index;
+
+} mp4_box_data_stsc_t;
+
+
+typedef struct mp4_box_data_co64_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *chunk_offset;
+
+} mp4_box_data_co64_t;
+
+
+typedef struct mp4_box_data_stss_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *sample_number;
+
+} mp4_box_data_stss_t;
+
+typedef struct mp4_box_data_stsh_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint32_t *shadowed_sample_number;
+    uint32_t *sync_sample_number;
+
+} mp4_box_data_stsh_t;
+
+typedef struct mp4_box_data_stdp_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint16_t *priority;
+
+} mp4_box_data_stdp_t;
+
+typedef struct mp4_box_data_padb_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t sample_count;
+
+    uint16_t *reserved1;   /* 1bit  */
+    uint16_t *pad2;        /* 3bits */
+    uint16_t *reserved2;   /* 1bit  */
+    uint16_t *pad1;        /* 3bits */
+
+
+} mp4_box_data_padb_t;
+
+
+typedef struct mp4_box_data_elst_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t entry_count;
+
+    uint64_t *segment_duration;
+    int64_t  *media_time;
+    uint16_t *media_rate_integer;
+    uint16_t *media_rate_fraction;
+
+
+} mp4_box_data_elst_t;
+
+typedef struct mp4_box_data_cprt_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    /* 1 pad bit */
+    unsigned char language[3];
+
+    char *psz_notice;
+} mp4_box_data_cprt_t;
+
+
+/* DecoderConfigDescriptor */
+typedef struct mp4_descriptor_decoder_config_s
+{
+    uint8_t objectTypeIndication;
+    uint8_t streamType;
+    int     b_upStream;
+    int     buffer_sizeDB;
+    int     max_bitrate;
+    int     avg_bitrate;
+
+    int     decoder_specific_info_len;
+    uint8_t *decoder_specific_info;
+    /* some other stuff */
+
+} mp4_descriptor_decoder_config_t;
+
+typedef struct mp4_descriptor_SL_config_s
+{
+
+    int dummy; /* ANSI C forbids empty structures */
+
+} mp4_descriptor_SL_config_t;
+
+
+typedef struct mp4_descriptor_ES_s
+{
+    uint16_t ES_ID;
+    int      b_stream_dependence;
+    int      b_url;
+    int      b_OCRstream;
+    int      stream_priority;
+
+    int      depend_on_ES_ID; /* if b_stream_dependence set */
+
+    unsigned char *psz_URL;
+
+    uint16_t OCR_ES_ID;       /* if b_OCRstream */
+    mp4_descriptor_decoder_config_t *decConfigDescr;
+
+    mp4_descriptor_SL_config_t *slConfigDescr;
+
+    /* some other stuff ... */
+
+} mp4_descriptor_ES_t;
+
+/* ES descriptor */
+typedef struct mp4_box_data_esds_s
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    mp4_descriptor_ES_t es_descriptor;
+
+} mp4_box_data_esds_t;
+
+
+typedef struct mp4_box_data_dcom_s
+{
+    uint32_t algorithm; /* fourcc */
+
+} mp4_box_data_dcom_t;
+
+typedef struct mp4_box_data_cmvd_s
+{
+    uint32_t uncompressed_size;
+    uint32_t compressed_size;
+
+    int     b_compressed; /* Set to 1 if compressed data, 0 if uncompressed */
+    uint8_t *data;
+
+} mp4_box_data_cmvd_t;
+
+typedef struct mp4_box_data_cmov_s
+{
+    struct mp4_box_s *moov; /* uncompressed moov */
+
+} mp4_box_data_cmov_t;
+
+typedef struct
+{
+    uint32_t type;
+} mp4_box_data_frma_t;
+
+typedef struct
+{
+    uint32_t init;
+    uint32_t encr;
+    uint32_t decr;
+} mp4_box_data_skcr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t ref_type;
+    char     *psz_ref;
+
+} mp4_box_data_rdrf_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t rate;
+
+} mp4_box_data_rmdr_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+    uint32_t gestaltType;
+    uint32_t val1;
+    uint32_t val2;
+    uint16_t checkType;   /* 0: val1 is version min
+                               1: gestalt value & val2 == val1 */
+
+} mp4_box_data_rmvc_t;
+
+typedef struct
+{
+    uint8_t  version;
+    uint32_t flags;
+
+
+} mp4_box_data_rmcd_t;
+
+typedef struct
+{
+    uint32_t quality;
+
+} mp4_box_data_rmqu_t;
+
+typedef struct mp4_box_data_mfhd_s
+{
+    uint32_t sequence_number;
+
+    uint8_t *vendor_extension;
+
+} mp4_box_data_mfhd_t;
+
+#define MP4_TFHD_BASE_DATA_OFFSET     (1LL<<0)
+#define MP4_TFHD_SAMPLE_DESC_INDEX    (1LL<<1)
+#define MP4_TFHD_DFLT_SAMPLE_DURATION (1LL<<3)
+#define MP4_TFHD_DFLT_SAMPLE_SIZE     (1LL<<4)
+#define MP4_TFHD_DFLT_SAMPLE_FLAGS    (1LL<<5)
+typedef struct mp4_box_data_tfhd_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t track_ID;
+
+    /* optional fields */
+    uint64_t base_data_offset;
+    uint32_t sample_description_index;
+    uint32_t default_sample_duration;
+    uint32_t default_sample_size;
+    uint32_t default_sample_flags;
+
+} mp4_box_data_tfhd_t;
+
+#define MP4_TRUN_DATA_OFFSET         (1<<0)
+#define MP4_TRUN_FIRST_FLAGS         (1<<2)
+#define MP4_TRUN_SAMPLE_DURATION     (1<<8)
+#define MP4_TRUN_SAMPLE_SIZE         (1<<9)
+#define MP4_TRUN_SAMPLE_FLAGS        (1<<10)
+#define MP4_TRUN_SAMPLE_TIME_OFFSET  (1<<11)
+typedef struct mp4_descriptor_trun_sample_t
+{
+    uint32_t duration;
+    uint32_t size;
+    uint32_t flags;
+    uint32_t composition_time_offset;
+} mp4_descriptor_trun_sample_t;
+
+typedef struct mp4_box_data_trun_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint32_t sample_count;
+
+    /* optional fields */
+    uint32_t data_offset;
+    uint32_t first_sample_flags;
+
+    mp4_descriptor_trun_sample_t *samples;
+
+} mp4_box_data_trun_t;
+
+
+
+typedef struct mp4_box_data_0xa9xxx_s
+{
+   char *psz_text;
+
+} mp4_box_data_0xa9xxx_t;
+
+typedef struct mp4_box_data_name_s
+{
+   char *psz_text;
+
+} mp4_box_data_name_t;
+
+typedef struct mp4_box_data_tref_generic_s
+{
+   uint32_t entry_count;
+   uint32_t *track_ID;
+
+} mp4_box_data_tref_generic_t;
+
+typedef struct mp4_box_data_chpl_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t chapter;
+   struct
+   {
+      char    *psz_name;
+      int64_t  start;
+   } p_chapter[256];
+} mp4_box_data_chpl_t;
+
+typedef struct mp4_box_data_avcC_s
+{
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+
+} mp4_box_data_avcC_t;
+
+typedef struct mp4_box_data_dac3_s
+{
+   uint8_t fscod;
+   uint8_t bsid;
+   uint8_t bsmod;
+   uint8_t acmod;
+   uint8_t lfeon;
+   uint8_t bitrate_code;
+
+} mp4_box_data_dac3_t;
+
+typedef struct mp4_box_data_enda_s
+{
+   uint16_t little_endian;
+
+} mp4_box_data_enda_t;
+
+typedef struct mp4_box_data_gnre_s
+{
+   uint16_t genre;
+
+} mp4_box_data_gnre_t;
+
+typedef struct mp4_box_data_trkn_s
+{
+   uint32_t track_number;
+   uint32_t track_total;
+
+} mp4_box_data_trkn_t;
+
+typedef struct mp4_box_data_iods_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint16_t object_descriptor;
+   uint8_t OD_profile_level;
+   uint8_t scene_profile_level;
+   uint8_t audio_profile_level;
+   uint8_t visual_profile_level;
+   uint8_t graphics_profile_level;
+
+} mp4_box_data_iods_t;
+
+typedef struct mp4_box_data_pasp_s
+{
+   uint32_t horizontal_spacing;
+   uint32_t vertical_spacing;
+} mp4_box_data_pasp_t;
+
+typedef struct mp4_box_data_mehd_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t fragment_duration;
+} mp4_box_data_mehd_t;
+
+typedef struct mp4_box_data_trex_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t default_sample_description_index;
+   uint32_t default_sample_duration;
+   uint32_t default_sample_size;
+   uint32_t default_sample_flags;
+} mp4_box_data_trex_t;
+
+typedef struct mp4_box_data_sdtp_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint8_t *sample_table;
+} mp4_box_data_sdtp_t;
+
+typedef struct mp4_box_data_mfro_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t size;
+} mp4_box_data_mfro_t;
+
+typedef struct mp4_box_data_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} mp4_box_data_tfra_t;
+
+typedef union mp4_box_data_s
+{
+   mp4_box_data_ftyp_t *p_ftyp;
+   mp4_box_data_mmpu_t *p_mmpu;
+   mp4_box_data_tfdt_t *p_tfdt;
+   mp4_box_data_mvhd_t *p_mvhd;
+   mp4_box_data_mfhd_t *p_mfhd;
+   mp4_box_data_tfhd_t *p_tfhd;
+   mp4_box_data_trun_t *p_trun;
+   mp4_box_data_tkhd_t *p_tkhd;
+   mp4_box_data_hint_t *p_hint;
+   mp4_box_data_mdhd_t *p_mdhd;
+   mp4_box_data_hdlr_t *p_hdlr;
+   mp4_box_data_vmhd_t *p_vmhd;
+   mp4_box_data_smhd_t *p_smhd;
+   mp4_box_data_hmhd_t *p_hmhd;
+   mp4_box_data_url_t  *p_url;
+   mp4_box_data_urn_t  *p_urn;
+   mp4_box_data_dref_t *p_dref;
+   mp4_box_data_stts_t *p_stts;
+   mp4_box_data_ctts_t *p_ctts;
+   mp4_box_data_stsd_t *p_stsd;
+   mp4_box_data_sample_vide_t *p_sample_vide;
+   mp4_box_data_sample_soun_t *p_sample_soun;
+   mp4_box_data_sample_text_t *p_sample_text;
+   mp4_box_data_sample_hint_t *p_sample_hint;
+   mp4_box_data_sample_mmth_t *p_sample_mmth;
+
+   mp4_box_data_esds_t *p_esds;
+   mp4_box_data_avcC_t *p_avcC;
+   mp4_box_data_dac3_t *p_dac3;
+   mp4_box_data_enda_t *p_enda;
+   mp4_box_data_gnre_t *p_gnre;
+   mp4_box_data_trkn_t *p_trkn;
+   mp4_box_data_iods_t *p_iods;
+   mp4_box_data_pasp_t *p_pasp;
+   mp4_box_data_trex_t *p_trex;
+   mp4_box_data_mehd_t *p_mehd;
+   mp4_box_data_sdtp_t *p_sdtp;
+
+   mp4_box_data_tfra_t *p_tfra;
+   mp4_box_data_mfro_t *p_mfro;
+
+   mp4_box_data_stsz_t *p_stsz;
+   mp4_box_data_stz2_t *p_stz2;
+   mp4_box_data_stsc_t *p_stsc;
+   mp4_box_data_co64_t *p_co64;
+   mp4_box_data_stss_t *p_stss;
+   mp4_box_data_stsh_t *p_stsh;
+   mp4_box_data_stdp_t *p_stdp;
+   mp4_box_data_padb_t *p_padb;
+   mp4_box_data_elst_t *p_elst;
+   mp4_box_data_cprt_t *p_cprt;
+
+   mp4_box_data_dcom_t *p_dcom;
+   mp4_box_data_cmvd_t *p_cmvd;
+   mp4_box_data_cmov_t *p_cmov;
+
+   mp4_box_data_moviehintinformation_rtp_t p_moviehintinformation_rtp;
+
+   mp4_box_data_frma_t *p_frma;
+   mp4_box_data_skcr_t *p_skcr;
+
+   mp4_box_data_rdrf_t *p_rdrf;
+   mp4_box_data_rmdr_t *p_rmdr;
+   mp4_box_data_rmqu_t *p_rmqu;
+   mp4_box_data_rmvc_t *p_rmvc;
+
+   mp4_box_data_0xa9xxx_t *p_0xa9xxx;
+   mp4_box_data_chpl_t *p_chpl;
+   mp4_box_data_tref_generic_t *p_tref_generic;
+   mp4_box_data_name_t *p_name;
+   void *p_data;
+} mp4_box_data_t;
+
+typedef struct mp4_box_s
+{
+   int64_t i_pos;
+   uint32_t i_type;
+   uint32_t i_shortsize;
+   uuid_t i_uuid;
+   uint64_t i_size;
+   mp4_box_data_t data;
+   struct mp4_box_s* p_father;
+   struct mp4_box_s* p_first;
+   struct mp4_box_s* p_last;
+   struct mp4_box_s* p_next;
+} mp4_box_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+mp4_box_t *MP4_BoxGetRoot(stream_t * s);
+void MP4_BoxFree(stream_t * s, mp4_box_t *box);
+static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
+mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
+mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
+void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type);
+int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // NET_MMT_MPU_MP4_H_
diff --git a/net/mmt/mpu/mpu.gyp b/net/mmt/mpu/mpu.gyp
new file mode 100644
index 0000000..8f5acf2
--- /dev/null
+++ b/net/mmt/mpu/mpu.gyp
@@ -0,0 +1,85 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmpu',
+      'type': '<(component)',
+      'product_name': 'libmpu',  # Don't conflict with OpenSSL's libssl
+      'sources': [
+        'stream.c',
+        'mp4.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
new file mode 100644
index 0000000..f512657
--- /dev/null
+++ b/net/mmt/mpu/stream.c
@@ -0,0 +1,390 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <memory.h>
+#include <assert.h>
+#include "net/mmt/mpu/stream.h"
+
+#define max(a,b) a>b?a:b
+#define min(a,b) a>b?b:a
+
+void* file_open(stream_t *stream_s, const char* filename, int mode)
+{
+   FILE* file = NULL;
+   const char* mode_fopen = NULL;
+   if ((mode & MODE_READWRITEFILTER) == MODE_READ)
+      mode_fopen = "rb";
+   else
+      if (mode & MODE_EXISTING)
+         mode_fopen = "r+b";
+      else
+         if (mode & MODE_CREATE)
+            mode_fopen = "wb";
+   if ((filename != NULL) && (mode_fopen != NULL))
+      file = fopen(filename, mode_fopen);
+   stream_s->opaque = (void*)file;
+
+   return file;
+}
+
+int file_read(stream_t *stream_s, void* buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fread(buf, 1, size, file);
+}
+
+int file_write(stream_t *stream_s, void *buf, int size)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fwrite(buf, 1, size, file);
+}
+
+int file_peek(stream_t *stream_s, void* buf, int size)
+{
+   uint32_t offset = file_tell(stream_s);
+   int ret = file_read(stream_s, buf, size);
+   file_seek(stream_s, offset, SEEK_SET);
+   return ret;
+}
+
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fseek(file, offset, whence);
+}
+
+uint64_t file_tell(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return ftell(file);
+}
+
+int file_close(stream_t *stream_s)
+{
+   FILE* file = (FILE*)stream_s->opaque;
+   return fclose(file);
+}
+
+stream_t* create_file_stream()
+{
+   stream_t* s = malloc(sizeof(stream_t));
+   s->open = file_open;
+   s->read = file_read;
+   s->write = file_write;
+   s->peek = file_peek;
+   s->seek = file_seek;
+   s->tell = file_tell;
+   s->close = file_close;
+   return s;
+}
+
+void destory_file_stream(stream_t* stream_s)
+{
+   free(stream_s);
+}
+
+stream_t* create_buf_file_stream()
+{
+   buf_stream_t* s = malloc(sizeof(buf_stream_t));
+   stream_t* file_s = create_file_stream();
+   s->s = *file_s;
+   destory_file_stream(file_s);
+   s->s.read = buf_file_read;
+   s->s.write = buf_file_write;
+   s->s.peek = buf_file_peek;
+   s->s.seek = buf_file_seek;
+   s->s.close = buf_file_close;
+   s->read_buf_s.buf = malloc(READ_BUFFER_SIZE);
+   s->read_buf_s.bufsize = -1;
+   s->read_buf_s.offset = 0;
+   s->write_buf_s.buf = malloc(WRITE_BUFFER_SIZE);
+   s->write_buf_s.bufsize = 0;
+   s->write_buf_s.offset = 0;
+   s->offset = 0;
+   return (stream_t*)s;
+}
+
+void destory_buf_file_stream(stream_t* stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   free(s->read_buf_s.buf);
+   free(s->write_buf_s.buf);
+   free(stream_s);
+}
+
+int buf_file_read(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int length = 0, remainder = 0, position = 0;
+
+   while (size > 0)
+   {
+      int read_bytes = 0;
+      if (s->read_buf_s.offset > s->offset || 
+         s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset ||
+         s->read_buf_s.bufsize == -1)
+      {
+         int read_bytes, ret;
+         // offset, .
+         ret = file_seek(stream_s, s->offset, SEEK_SET);
+         if (ret != 0)
+         {
+            assert(0);
+            return ret;       // ERROR!!!
+         }
+         read_bytes = file_read(stream_s, s->read_buf_s.buf, READ_BUFFER_SIZE);
+         if (read_bytes < 0)
+            return read_bytes; // ERROR!!!
+         if (read_bytes == 0)
+            return length;
+         if (s->read_buf_s.bufsize == -1)
+            s->read_buf_s.offset = s->offset;
+         else
+            s->read_buf_s.offset += s->read_buf_s.bufsize;
+         s->read_buf_s.bufsize = read_bytes;
+      }
+
+      position = s->offset - s->read_buf_s.offset;
+      remainder = s->read_buf_s.bufsize - position;
+      read_bytes = min(size, remainder);
+
+      memcpy((char*)buf + length, 
+         (char*)s->read_buf_s.buf + position, read_bytes);
+
+      length += read_bytes;
+      position += read_bytes;
+      size -= read_bytes;
+      remainder -= read_bytes;
+      s->offset += read_bytes;
+   }
+
+   return length;
+}
+
+int buf_file_write(stream_t *stream_s, void *buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.offset + s->write_buf_s.bufsize == s->offset &&
+      s->write_buf_s.bufsize + size < WRITE_BUFFER_SIZE)
+   {
+      memcpy((char*)s->write_buf_s.buf + s->write_buf_s.bufsize, buf, size);
+      s->write_buf_s.bufsize += size;
+      s->offset += size;
+      return size;
+   }
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   if (size > WRITE_BUFFER_SIZE)
+   {
+      int ret = file_seek(stream_s, s->offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != size)
+      {
+         int n = file_write(stream_s, (char*)buf + write_bytes, size - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->offset += size;
+      return write_bytes;
+   }
+   else
+   {
+      memcpy(s->write_buf_s.buf, buf, size);
+      s->write_buf_s.offset = s->offset;
+      s->offset += size;
+      s->write_buf_s.bufsize = size;
+      return size;
+   }
+}
+
+int buf_file_peek(stream_t *stream_s, void* buf, int size)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int ret = 0;
+   int len = 0;
+
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   len = file_read(stream_s, buf, size);
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+
+   return len;
+}
+
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   uint64_t ret = 0;
+   ret = file_seek(stream_s, s->offset, SEEK_SET);
+   if (ret != 0)
+      return ret;
+   ret = file_seek(stream_s, offset, whence);
+   if (ret != 0)
+      return ret;
+   s->offset = file_tell(stream_s);
+   if (s->read_buf_s.offset > s->offset || 
+      s->read_buf_s.offset + s->read_buf_s.bufsize <= s->offset)
+      s->read_buf_s.bufsize = -1;
+   else
+      s->read_buf_s.offset = s->offset;
+   return ret;
+}
+
+int buf_file_close(stream_t *stream_s)
+{
+   buf_stream_t* s = (buf_stream_t*)stream_s;
+   int write_bytes = 0;
+
+   if (s->write_buf_s.bufsize != 0)
+   {
+      int ret = file_seek(stream_s, s->write_buf_s.offset, SEEK_SET);
+      if (ret != 0)
+         return ret;
+      write_bytes = 0;
+      while (write_bytes != s->write_buf_s.bufsize)
+      {
+         int n = file_write(stream_s, (char*)s->write_buf_s.buf + write_bytes, 
+            s->write_buf_s.bufsize - write_bytes);
+         if (n < 0)
+            return n;
+         write_bytes += n;
+      }
+      s->write_buf_s.bufsize = 0;
+   }
+
+   return file_close(stream_s);
+}
+
+
+
+uint16_t Swap16(uint16_t x)
+{
+   return ((x<<8)|(x>>8));
+}
+
+uint32_t Swap32(uint32_t x)
+{
+   return((x<<24)|((x<<8)&0x00FF0000)|((x>>8)&0x0000FF00)|(x>>24));
+}
+
+uint64_t Swap64(uint64_t x)
+{
+   uint32_t hi, lo;
+
+   /* Separate into high and low 32-bit values and swap them */
+   lo = (uint32_t)(x & 0xFFFFFFFF);
+   x >>= 32;
+   hi = (uint32_t)(x & 0xFFFFFFFF);
+   x = Swap32(lo);
+   x <<= 32;
+   x |= Swap32(hi);
+   return(x);
+}
+
+uint16_t read_le16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE16(value));
+}
+
+uint16_t read_be16(stream_t *src)
+{
+   uint16_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE16(value));
+}
+
+uint32_t read_le32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE32(value));
+}
+
+uint32_t read_be32(stream_t *src)
+{
+   uint32_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE32(value));
+}
+
+uint64_t read_le64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapLE64(value));
+}
+
+uint64_t read_be64(stream_t *src)
+{
+   uint64_t value;
+
+   stream_read(src, &value, sizeof(value));
+   return(SwapBE64(value));
+}
+
+int write_le16(stream_t *dst, uint16_t value)
+{
+   value = SwapLE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be16(stream_t *dst, uint16_t value)
+{
+   value = SwapBE16(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le32(stream_t *dst, uint32_t value)
+{
+   value = SwapLE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be32(stream_t *dst, uint32_t value)
+{
+   value = SwapBE32(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_le64(stream_t *dst, uint64_t value)
+{
+   value = SwapLE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
+
+int write_be64(stream_t *dst, uint64_t value)
+{
+   value = SwapBE64(value);
+   return(stream_write(dst, &value, sizeof(value)));
+}
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
new file mode 100644
index 0000000..34e8feb
--- /dev/null
+++ b/net/mmt/mpu/stream.h
@@ -0,0 +1,143 @@
+#ifndef NET_MMT_MPU_STREAM_H_
+#define NET_MMT_MPU_STREAM_H_
+
+#include <stdint.h>
+
+#ifndef _STDINT_H
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+typedef int int32_t;
+typedef unsigned uint32_t;
+//typedef long long int64_t;
+typedef unsigned long long uint64_t;
+//typedef unsigned long size_t;
+#endif
+
+#define MODE_READ             (1)
+#define MODE_WRITE            (2)
+#define MODE_READWRITEFILTER  (3)
+#define MODE_EXISTING         (4)
+#define MODE_CREATE           (8)
+
+typedef struct stream {
+   void* (*open)(struct stream *stream_s, const char* filename, int mode);
+   int (*read)(struct stream *stream_s, void* buf, int size);
+   int (*write)(struct stream *stream_s, void *buf, int size);
+   int (*peek)(struct stream *stream_s, void* buf, int size);
+   uint64_t (*seek)(struct stream *stream_s, int64_t offset, int whence);
+   uint64_t (*tell)(struct stream *stream_s);
+   int (*close)(struct stream *stream_s);
+   void* opaque;
+} stream_t;
+
+#define stream_open(s, filename, mode) ((stream_t*)s)->open(((stream_t*)s), filename, mode)
+#define stream_read(s, buf, size) ((stream_t*)s)->read(((stream_t*)s), buf, size)
+#define stream_write(s, buf, size) ((stream_t*)s)->write(((stream_t*)s), buf, size)
+#define stream_peek(s, buf, size) ((stream_t*)s)->peek(((stream_t*)s), buf, size)
+#define stream_seek(s, offset, whence) ((stream_t*)s)->seek(((stream_t*)s), offset, whence)
+#define stream_tell(s) ((stream_t*)s)->tell(((stream_t*)s))
+#define stream_close(s) ((stream_t*)s)->close(((stream_t*)s))
+
+void* file_open(stream_t *stream_s, const char* filename, int mode);
+int file_read(stream_t *stream_s, void* buf, int size);
+int file_write(stream_t *stream_s, void *buf, int size);
+int file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence);
+uint64_t file_tell(stream_t *stream_s);
+int file_close(stream_t *stream_s);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+stream_t* create_file_stream();
+void destory_file_stream(stream_t* stream_s);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#define READ_BUFFER_SIZE   10485760
+#define WRITE_BUFFER_SIZE  10485760
+
+typedef struct buf_stream {
+   stream_t s;
+
+   struct read_buf {
+      void* buf;        
+      int64_t bufsize; 
+      int64_t offset; 
+   } read_buf_s;
+
+   struct write_buf {
+      void* buf;     
+      int64_t bufsize;
+      int64_t offset;
+   } write_buf_s;
+
+   uint64_t offset; 
+
+} buf_stream_t;
+
+int buf_file_read(stream_t *stream_s, void* buf, int size);
+int buf_file_write(stream_t *stream_s, void *buf, int size);
+int buf_file_peek(stream_t *stream_s, void* buf, int size);
+uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence);
+int buf_file_close(stream_t *stream_s);
+
+stream_t* create_buf_file_stream();
+void destory_buf_file_stream(stream_t* stream_s);
+
+#define LIL_ENDIAN_INTERNAL	1234
+#define BIG_ENDIAN_INTERNAL	4321
+
+#ifndef BYTEORDER
+#if defined(__hppa__) || \
+   defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \
+   (defined(__MIPS__) && defined(__MISPEB__)) || \
+   defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
+   defined(__sparc__)
+#define BYTEORDER	BIG_ENDIAN_INTERNAL
+#else
+#define BYTEORDER	LIL_ENDIAN_INTERNAL
+#endif
+#endif /* !BYTEORDER */
+
+uint16_t Swap16(uint16_t x);
+uint32_t Swap32(uint32_t x);
+uint64_t Swap64(uint64_t x);
+
+#if BYTEORDER == LIL_ENDIAN
+#define SwapLE16(X)	(X)
+#define SwapLE32(X)	(X)
+#define SwapLE64(X)	(X)
+#define SwapBE16(X)	Swap16(X)
+#define SwapBE32(X)	Swap32(X)
+#define SwapBE64(X)	Swap64(X)
+#else
+#define SwapLE16(X)	Swap16(X)
+#define SwapLE32(X)	Swap32(X)
+#define SwapLE64(X)	Swap64(X)
+#define SwapBE16(X)	(X)
+#define SwapBE32(X)	(X)
+#define SwapBE64(X)	(X)
+#endif
+
+uint16_t read_le16(stream_t *src);
+uint16_t read_be16(stream_t *src);
+uint32_t read_le32(stream_t *src);
+uint32_t read_be32(stream_t *src);
+uint64_t read_le64(stream_t *src);
+uint64_t read_be64(stream_t *src);
+
+int write_le16(stream_t *dst, uint16_t value);
+int write_be16(stream_t *dst, uint16_t value);
+int write_le32(stream_t *dst, uint32_t value);
+int write_be32(stream_t *dst, uint32_t value);
+int write_le64(stream_t *dst, uint64_t value);
+int write_be64(stream_t *dst, uint64_t value);
+
+#endif // NET_MMT_MPU_STREAM_H_
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
new file mode 100644
index 0000000..8c7ae7e
--- /dev/null
+++ b/net/mmt/mpu/test_parser.cc
@@ -0,0 +1,40 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "stream.h"
+#include "mp4.h"
+
+int main(int argc, char* argv[])
+{
+    if (argc != 2) {
+        printf("usage: %s mp4file\n", argv[0]);
+        exit(1);
+    }
+
+    mp4_box_t *root = NULL;
+    stream_t* s = NULL;
+
+    s = create_file_stream();
+    if (stream_open(s, argv[1], MODE_READ) == 0)
+        return -1;
+
+    root = MP4_BoxGetRoot(s);
+    if (!root) return -1;
+    printf("root: %p itype=%u ftyp=%u moof=%u\n", root, root->i_type,
+        ATOM_ftyp, ATOM_moof);
+
+    mp4_box_t* box = NULL;
+    box = MP4_BoxSearchBox(root, ATOM_ftyp);
+    printf("ftyp: %p\n", box);
+
+    box = MP4_BoxSearchBox(root, ATOM_moof);
+    printf("moof: %p\n", box);
+
+    MP4_BoxFree(s, root);
+
+    stream_close(s);
+    destory_file_stream(s);
+
+    return 0;
+}
+
-- 
1.7.9.5


From 6fd9a1a6b18bcae1c43d561c2b4968f4996b03c2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 17:39:48 -0800
Subject: [PATCH 044/128] add custom mp4atom

---
 net/mmt/mpu/mp4atom.h |  154 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 154 insertions(+)
 create mode 100644 net/mmt/mpu/mp4atom.h

diff --git a/net/mmt/mpu/mp4atom.h b/net/mmt/mpu/mp4atom.h
new file mode 100644
index 0000000..52e68ce
--- /dev/null
+++ b/net/mmt/mpu/mp4atom.h
@@ -0,0 +1,154 @@
+#ifndef NET_MMT_MPU_MP4ATOM_H_
+#define NET_MMT_MPU_MP4ATOM_H_
+
+#include <stdint.h>
+
+typedef struct uuid_s{
+    uint8_t b[16];
+} uuid_t;
+
+#define MP4_FOURCC( a, b, c, d ) \
+    (((uint32_t)a) | (((uint32_t)b)<<8) | (((uint32_t)c)<<16) | (((uint32_t)d)<<24))
+
+
+#define ATOM_root MP4_FOURCC( 'r', 'o', 'o', 't' )
+
+#define ATOM_ftyp MP4_FOURCC( 'f', 't', 'y', 'p' )
+#define ATOM_uuid MP4_FOURCC( 'u', 'u', 'i', 'd' )
+#define ATOM_mmpu MP4_FOURCC( 'm', 'm', 'p', 'u' )
+#define ATOM_moov MP4_FOURCC( 'm', 'o', 'o', 'v' )
+#define ATOM_moof MP4_FOURCC( 'm', 'o', 'o', 'f' )
+#define ATOM_mdat MP4_FOURCC( 'm', 'd', 'a', 't' )
+
+// pps/sps: moov -> trak -> mdia -> minf -> stbl -> stsd -> avcl -> avcC
+#define ATOM_trak MP4_FOURCC( 't', 'r', 'a', 'k' )
+#define ATOM_mdia MP4_FOURCC( 'm', 'd', 'i', 'a' )
+#define ATOM_minf MP4_FOURCC( 'm', 'i', 'n', 'f' )
+#define ATOM_stbl MP4_FOURCC( 's', 't', 'b', 'l' )
+#define ATOM_stsd MP4_FOURCC( 's', 't', 's', 'd' )
+#define ATOM_avc1 MP4_FOURCC( 'a', 'v', 'c', '1' )
+#define ATOM_avcC MP4_FOURCC( 'a', 'v', 'c', 'C' )
+
+// moof
+
+
+typedef struct atom_ftyp_s {
+    uint32_t major_brand;
+    uint32_t minor_version;
+    uint32_t compatible_brands_count;
+    uint32_t *compatible_brands;
+} atom_ftyp_t;
+
+typedef struct atom_mmpu_s {
+    uint8_t  version;
+    uint32_t flags;
+    uint8_t  is_complete;
+    uint8_t  reserved;
+    uint32_t mpu_sequence_number;
+    uint32_t asset_id_scheme;
+    uint32_t asset_id_length;
+    char *asset_id_value;
+} atom_mmpu_t;
+
+typedef struct atom_tfdt_s {
+	uint8_t  version;
+	uint32_t flags;
+    uint64_t baseMediaDecodeTime;
+} atom_tfdt_t;
+
+typedef struct atom_mvhd_s {
+   uint8_t  version;
+   uint32_t flags;
+
+   uint64_t creation_time;
+   uint64_t modification_time;
+   uint32_t timescale;
+   uint64_t duration;
+
+   int32_t  rate;
+   int16_t  volume;
+   int16_t  reserved1;
+   uint32_t reserved2[2];
+   int32_t  matrix[9];
+   uint32_t predefined[6];
+   uint32_t next_track_id;
+} atom_mvhd_t;
+
+typedef struct atom_mfhd_s {
+    uint32_t sequence_number;
+    uint8_t *vendor_extension;
+} atom_mfhd_t;
+
+typedef struct atom_tfra_s
+{
+   uint8_t  version;
+   uint32_t flags;
+
+   uint32_t track_ID;
+   uint32_t number_of_entries;
+
+   uint8_t length_size_of_traf_num;
+   uint8_t length_size_of_trun_num;
+   uint8_t length_size_of_sample_num;
+
+   uint32_t *time;
+   uint32_t *moof_offset;
+   uint8_t *traf_number;
+   uint8_t *trun_number;
+   uint8_t *sample_number;
+} atom_tfra_t;
+
+typedef struct atom_avcC_s {
+   uint8_t version;
+   uint8_t profile;
+   uint8_t profile_compatibility;
+   uint8_t level;
+
+   uint8_t reserved1;     /* 6 bits */
+   uint8_t length_size;
+
+   uint8_t reserved2;    /* 3 bits */
+   uint8_t  sps;
+   uint16_t *sps_length;
+   uint8_t  **p_sps;
+
+   uint8_t  pps;
+   uint16_t *pps_length;
+   uint8_t  **p_pps;
+
+   /* XXX: Hack raw avcC atom payload */
+   int     avcC;
+   uint8_t *p_avcC;
+} atom_avcC_t;
+
+
+// common atoms
+//  a) ftyp
+//  b) avcC in moov/trak/mdia/minf/stbl/stsd/avcl
+//  c) mdat
+// common containers: 
+//  a) moov/trak/mdia/minf/stbl/stsd/avcl
+//  b) moof/
+
+// for some atom containers
+typedef unsigned char* data_t;
+typedef struct atom_info_s {
+    int     pos;
+    int     type;
+    uuid_t  uuid;
+    char    name[5]; // box name: 4chars + '\0'
+    int     size;
+    data_t  data;
+}atom_info_t;
+
+typedef struct mp4_root_s {
+    atom_info_t ftyp; // required
+    atom_info_t mmpu; // required
+    atom_info_t moov; // required
+    atom_info_t moof; // the first moof
+    atom_info_t mdat;
+    int     size;
+    data_t  data;
+}mp4_root_t;
+
+#endif // NET_MMT_MPU_MP4ATOM_H_
-- 
1.7.9.5


From 8ee07403a94e37d41daab9bf7e66828c512d93f8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 17:44:21 -0800
Subject: [PATCH 045/128] update with new version of mpuparser

---
 net/mmt/mpu/Makefile       |    4 +-
 net/mmt/mpu/mp4.c          | 4508 ++++++++++++++++++++++----------------------
 net/mmt/mpu/mp4.h          |    5 +-
 net/mmt/mpu/stream.c       |    2 +-
 net/mmt/mpu/stream.h       |   41 +-
 net/mmt/mpu/test_parser.cc |   20 +-
 6 files changed, 2256 insertions(+), 2324 deletions(-)

diff --git a/net/mmt/mpu/Makefile b/net/mmt/mpu/Makefile
index 021f39c..cfb990c 100644
--- a/net/mmt/mpu/Makefile
+++ b/net/mmt/mpu/Makefile
@@ -9,10 +9,10 @@ $(TARGET): $(OBJS)
 	$(CC) -o $@ $(OBJS) $(LDFLAGS)
 
 %.o:%.c
-	$(CC) $(CFLAGS) -o $@ -c $<
+	$(CC) -g $(CFLAGS) -o $@ -c $<
 
 %.o:%.cc
-	$(CC) $(CFLAGS) -o $@ -c $<
+	$(CC) -g $(CFLAGS) -o $@ -c $<
 	
 clean:
 	@rm -f $(OBJS)
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index 9e64657..bc6af51 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -1,4 +1,4 @@
-#include <stdio.h>
+#include <stdio.h>
 #include <stdlib.h>
 #include <memory.h>
 #include <assert.h>
@@ -8,22 +8,37 @@
 
 void *debug_malloc(size_t size, const char *file, int line, const char *func)
 {
-    void *p;
-    p = malloc(size);
-    printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
+        void *p;
+
+        p = malloc(size);
+        printf("%s:%d:%s:malloc(%ld): p=0x%lx\n",
             file, line, func, size, (unsigned long)p);
-    return p;
+        return p;
 }
 
+//#define malloc(s) debug_malloc(s, __FILE__, __LINE__, __func__)
 void *debug_free(char *p)
 {
-    if(NULL!=(p))
-    {
-        free(p) ;
-        p = NULL;
-    }
+        //printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,  __func__, (unsigned long)p);
+            if(NULL!=(p))
+            {
+            	free(p) ;
+                p = NULL;
+            }
+
 }
 
+//#define free(p)  do {                                                                                   \
+//        printf("%s:%d:%s:free(0x%lx)\n", __FILE__, __LINE__,            \
+//            __func__, (unsigned long)p);                                                       \
+//        if (p) {                                                                                                     \
+//          free(p);                                                                                                 \
+//          p = NULL;                                                                                           \
+//       }                                                                                                               \
+//} while (0)
+
+//#define free(p) debug_free(p)
+
 
 #define msg_Dbg(x) do {} while (0)
 #define msg_Warn(x) do {} while (0)
@@ -40,18 +55,18 @@ void *debug_free(char *p)
     if( (i_read) >= (size) ) { dst = (code); p_peek += (size); } \
     else { dst = 0; }   \
     i_read -= (size);   \
-} while(0)
+  } while(0)
 
 static uint32_t mp4_box_headersize( mp4_box_t *p_box )
 {
-    return 8
-        + ( p_box->i_shortsize == 1 ? 8 : 0 )
-        + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
+   return 8
+      + ( p_box->i_shortsize == 1 ? 8 : 0 )
+      + ( p_box->i_type == ATOM_uuid ? 16 : 0 );
 }
 
 static uint32_t Get24bBE( const uint8_t *p )
 {
-    return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
+   return( ( p[0] <<16 ) + ( p[1] <<8 ) + p[2] );
 }
 
 #define MP4_GET1BYTE( dst )  MP4_GETX_PRIVATE( dst, *p_peek, 1 )
@@ -60,60 +75,60 @@ static uint32_t Get24bBE( const uint8_t *p )
 #define MP4_GET4BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE32(*(uint32_t*)p_peek), 4 )
 #define MP4_GET8BYTES( dst ) MP4_GETX_PRIVATE( dst, SwapBE64(*(uint64_t*)p_peek), 8 )
 #define MP4_GETFOURCC( dst ) MP4_GETX_PRIVATE( dst, \
-        MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
+                MP4_FOURCC(p_peek[0],p_peek[1],p_peek[2],p_peek[3]), 4)
 
 #define MP4_GETVERSIONFLAGS( p_void ) \
     MP4_GET1BYTE( p_void->version ); \
-MP4_GET3BYTES( p_void->flags )
+    MP4_GET3BYTES( p_void->flags )
 
 #define MP4_GETSTRINGZ( p_str )         \
     if( (i_read > 0) && (p_peek[0]) )   \
-{       \
-    const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
-    p_str = malloc( __i_copy__+1 );               \
-    if( p_str ) \
-    { \
-        memcpy( p_str, p_peek, __i_copy__ ); \
-        p_str[__i_copy__] = 0; \
-    } \
-    p_peek += __i_copy__ + 1;   \
-    i_read -= __i_copy__ + 1;   \
-}       \
-else    \
-{       \
-    p_str = NULL; \
-}
+    {       \
+        const int __i_copy__ = strnlen( (char*)p_peek, i_read-1 );  \
+        p_str = malloc( __i_copy__+1 );               \
+        if( p_str ) \
+        { \
+             memcpy( p_str, p_peek, __i_copy__ ); \
+             p_str[__i_copy__] = 0; \
+        } \
+        p_peek += __i_copy__ + 1;   \
+        i_read -= __i_copy__ + 1;   \
+    }       \
+    else    \
+    {       \
+        p_str = NULL; \
+    }
 
 #define MP4_READBOX_ENTER( mp4_box_data_TYPE_t ) \
     int64_t  i_read = p_box->i_size; \
-uint8_t *p_peek, *p_buff; \
-int i_actually_read; \
-if( !( p_peek = p_buff = malloc( i_read ) ) ) \
-{ \
-    return( 0 ); \
-} \
-i_actually_read = stream_read( p_stream, p_peek, i_read ); \
-if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
-{ \
-    free( p_buff ); \
-    return( 0 ); \
-} \
-p_peek += mp4_box_headersize( p_box ); \
-i_read -= mp4_box_headersize( p_box ); \
-if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
-{ \
-    free( p_buff ); \
-    return( 0 ); \
-}
+    uint8_t *p_peek, *p_buff; \
+    int i_actually_read; \
+    if( !( p_peek = p_buff = malloc( i_read ) ) ) \
+    { \
+        return( 0 ); \
+    } \
+    i_actually_read = stream_read( p_stream, p_peek, i_read ); \
+    if( i_actually_read < 0 || (int64_t)i_actually_read < i_read )\
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    } \
+    p_peek += mp4_box_headersize( p_box ); \
+    i_read -= mp4_box_headersize( p_box ); \
+    if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
+    { \
+        free( p_buff ); \
+        return( 0 ); \
+    }
 
 #define MP4_READBOX_EXIT( i_code ) \
     do \
-{ \
-    free( p_buff ); \
-    if( i_read < 0 ) \
-    printf( "Not enough data" ); \
-    return( i_code ); \
-} while (0)
+    { \
+        free( p_buff ); \
+        if( i_read < 0 ) \
+            printf( "Not enough data" ); \
+        return( i_code ); \
+    } while (0)
 
 
 /* Some assumptions:
@@ -130,47 +145,47 @@ if( !( p_box->data.p_data = calloc( 1, sizeof( mp4_box_data_TYPE_t ) ) ) ) \
 
 static void CreateUUID( uuid_t *p_uuid, uint32_t i_fourcc )
 {
-    /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
-    /* FIXME implement this */
-    (void)p_uuid;
-    (void)i_fourcc;
+   /* made by 0xXXXXXXXX-0011-0010-8000-00aa00389b71 where XXXXXXXX is the fourcc */
+   /* FIXME implement this */
+   (void)p_uuid;
+   (void)i_fourcc;
 }
 
 static int drms_init( void *_p_drms, uint32_t i_type,
-        uint8_t *p_info, uint32_t i_len )
+              uint8_t *p_info, uint32_t i_len )
 {
-    return 1;
+   return 1;
 }
 
 static void GetUUID( uuid_t *p_uuid, const uint8_t *p_buff )
 {
-    memcpy( p_uuid, p_buff, 16 );
+   memcpy( p_uuid, p_buff, 16 );
 }
 
 /* convert 16.16 fixed point to floating point */
 static double conv_fx( int32_t fx ) {
-    double fp = fx;
-    fp /= 65536.0;
-    return fp;
+   double fp = fx;
+   fp /= 65536.0;
+   return fp;
 }
 
 /* some functions for mp4 encoding of variables */
 #ifdef MP4_VERBOSE
 static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
 {
-    int i_day;
-    int i_hour;
-    int i_min;
-    int i_sec;
+   int i_day;
+   int i_hour;
+   int i_min;
+   int i_sec;
 
-    /* date begin at 1 jan 1904 */
-    i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
+   /* date begin at 1 jan 1904 */
+   i_date += ((INT64_C(1904) * 365) + 17) * 24 * 60 * 60;
 
-    i_day = i_date / ( 60*60*24);
-    i_hour = ( i_date /( 60*60 ) ) % 60;
-    i_min  = ( i_date / 60 ) % 60;
-    i_sec =  i_date % 60;
-    sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
+   i_day = i_date / ( 60*60*24);
+   i_hour = ( i_date /( 60*60 ) ) % 60;
+   i_min  = ( i_date / 60 ) % 60;
+   i_sec =  i_date % 60;
+   sprintf( psz, "%dd-%2.2dh:%2.2dm:%2.2ds", i_day, i_hour, i_min, i_sec );
 }
 #endif
 
@@ -184,66 +199,66 @@ static void MP4_ConvertDate2Str( char *psz, uint64_t i_date )
  *****************************************************************************/
 int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
 {
-    int      i_read;
-    const uint8_t *p_buff = malloc(32);
-    const uint8_t *p_peek = p_buff;
-
-    if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
-    {
-        free(p_buff);
-        return 0;
-    }
-
-    p_box->i_pos = stream_tell( p_stream );
-
-    p_box->data.p_data = NULL;
-    p_box->p_father = NULL;
-    p_box->p_first  = NULL;
-    p_box->p_last  = NULL;
-    p_box->p_next   = NULL;
-
-    MP4_GET4BYTES( p_box->i_shortsize );
-    MP4_GETFOURCC( p_box->i_type );
-
-    /* Now special case */
-
-    if( p_box->i_shortsize == 1 )
-    {
-        /* get the true size on 64 bits */
-        MP4_GET8BYTES( p_box->i_size );
-    }
-    else
-    {
-        p_box->i_size = p_box->i_shortsize;
-        /* XXX size of 0 means that the box extends to end of file */
-    }
-
-    if( p_box->i_type == ATOM_uuid )
-    {
-        /* get extented type on 16 bytes */
-        GetUUID( &p_box->i_uuid, p_peek );
-        p_peek += 16; i_read -= 16;
-    }
-    else
-    {
-        CreateUUID( &p_box->i_uuid, p_box->i_type );
-    }
-
-    free(p_buff);
-
-    // #ifdef MP4_VERBOSE
-    //    if( p_box->i_size )
-    //    {
-    //       if MP4_BOX_TYPE_ASCII()
-    //           printf( "found Box: %4.4s size %"PRId64,
-    //          (char*)&p_box->i_type, p_box->i_size );
-    //       else
-    //           printf( "found Box: c%3.3s size %"PRId64,
-    //          (char*)&p_box->i_type+1, p_box->i_size );
-    //    }
-    // #endif
-
-    return 1;
+   int      i_read;
+   const uint8_t *p_buff = malloc(32);
+   const uint8_t *p_peek = p_buff;
+
+   if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+   {
+      free(p_buff);
+      return 0;
+   }
+
+   p_box->i_pos = stream_tell( p_stream );
+
+   p_box->data.p_data = NULL;
+   p_box->p_father = NULL;
+   p_box->p_first  = NULL;
+   p_box->p_last  = NULL;
+   p_box->p_next   = NULL;
+
+   MP4_GET4BYTES( p_box->i_shortsize );
+   MP4_GETFOURCC( p_box->i_type );
+
+   /* Now special case */
+
+   if( p_box->i_shortsize == 1 )
+   {
+      /* get the true size on 64 bits */
+      MP4_GET8BYTES( p_box->i_size );
+   }
+   else
+   {
+      p_box->i_size = p_box->i_shortsize;
+      /* XXX size of 0 means that the box extends to end of file */
+   }
+
+   if( p_box->i_type == ATOM_uuid )
+   {
+      /* get extented type on 16 bytes */
+      GetUUID( &p_box->i_uuid, p_peek );
+      p_peek += 16; i_read -= 16;
+   }
+   else
+   {
+      CreateUUID( &p_box->i_uuid, p_box->i_type );
+   }
+
+   free(p_buff);
+
+// #ifdef MP4_VERBOSE
+//    if( p_box->i_size )
+//    {
+//       if MP4_BOX_TYPE_ASCII()
+//           printf( "found Box: %4.4s size %"PRId64,
+//          (char*)&p_box->i_type, p_box->i_size );
+//       else
+//           printf( "found Box: c%3.3s size %"PRId64,
+//          (char*)&p_box->i_type+1, p_box->i_size );
+//    }
+// #endif
+
+   return 1;
 }
 
 /*****************************************************************************
@@ -253,39 +268,39 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
  *****************************************************************************/
 static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t box;
+   mp4_box_t box;
 
-    if( !p_box )
-    {
-        MP4_ReadBoxCommon( p_stream, &box );
-        p_box = &box;
-    }
+   if( !p_box )
+   {
+      MP4_ReadBoxCommon( p_stream, &box );
+      p_box = &box;
+   }
 
-    if( !p_box->i_size )
-    {
-        return 2; /* Box with infinite size */
-    }
+   if( !p_box->i_size )
+   {
+      return 2; /* Box with infinite size */
+   }
 
-    if( p_box->p_father )
-    {
-        const int64_t i_box_end = p_box->i_size + p_box->i_pos;
-        const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
+   if( p_box->p_father )
+   {
+      const int64_t i_box_end = p_box->i_size + p_box->i_pos;
+      const int64_t i_father_end = p_box->p_father->i_size + p_box->p_father->i_pos;
 
-        /* check if it's within p-father */
-        if( i_box_end >= i_father_end )
-        {
-            if( i_box_end > i_father_end )
-                printf(  "out of bound child" );
-            return 0; /* out of bound */
-        }
-    }
+      /* check if it's within p-father */
+      if( i_box_end >= i_father_end )
+      {
+         if( i_box_end > i_father_end )
+        	 printf(  "out of bound child" );
+         return 0; /* out of bound */
+      }
+   }
 
-    if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
-    {
-        return 0;
-    }
+   if (stream_seek( p_stream, p_box->i_size + p_box->i_pos, SEEK_SET ))
+   {
+      return 0;
+   }
 
-    return 1;
+   return 1;
 }
 
 /*****************************************************************************
@@ -296,92 +311,92 @@ static int MP4_NextBox( stream_t *p_stream, mp4_box_t *p_box )
  *****************************************************************************/
 static int MP4_ReadBoxContainerRaw( stream_t *p_stream, mp4_box_t *p_container )
 {
-    mp4_box_t *p_box;
+   mp4_box_t *p_box;
 
-    if( stream_tell( p_stream ) + 8 >
-            (int64_t)(p_container->i_pos + p_container->i_size) )
-    {
-        /* there is no box to load */
-        return 0;
-    }
+   if( stream_tell( p_stream ) + 8 >
+      (int64_t)(p_container->i_pos + p_container->i_size) )
+   {
+      /* there is no box to load */
+      return 0;
+   }
 
-    do
-    {
-        if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
+   do
+   {
+      if( ( p_box = MP4_ReadBox( p_stream, p_container ) ) == NULL ) break;
 
-        /* chain this box with the father and the other at same level */
-        if( !p_container->p_first ) p_container->p_first = p_box;
-        else p_container->p_last->p_next = p_box;
-        p_container->p_last = p_box;
+      /* chain this box with the father and the other at same level */
+      if( !p_container->p_first ) p_container->p_first = p_box;
+      else p_container->p_last->p_next = p_box;
+      p_container->p_last = p_box;
 
-    } while( MP4_NextBox( p_stream, p_box ) == 1 );
+   } while( MP4_NextBox( p_stream, p_box ) == 1 );
 
-    return 1;
+   return 1;
 }
 
 static int MP4_ReadBoxContainer( stream_t *p_stream, mp4_box_t *p_container )
 {
-    if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
-    {
-        /* container is empty, 8 stand for the first header in this box */
-        return 1;
-    }
-
-    /* enter box */
-    stream_seek( p_stream, p_container->i_pos +
-            mp4_box_headersize( p_container ), SEEK_SET );
+   if( p_container->i_size <= (size_t)mp4_box_headersize(p_container ) + 8 )
+   {
+      /* container is empty, 8 stand for the first header in this box */
+      return 1;
+   }
 
-    return MP4_ReadBoxContainerRaw( p_stream, p_container );
+   /* enter box */
+   stream_seek( p_stream, p_container->i_pos +
+      mp4_box_headersize( p_container ), SEEK_SET );
+ 
+   return MP4_ReadBoxContainerRaw( p_stream, p_container );
 }
 
 static void MP4_FreeBox_Common( mp4_box_t *p_box )
 {
-    /* Up to now do nothing */
-    (void)p_box;
+   /* Up to now do nothing */
+   (void)p_box;
 }
 
 static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
 {
-    /* XXX sometime moov is hiden in a free box */
-    if( p_box->p_father &&
-            p_box->p_father->i_type == ATOM_root &&
-            p_box->i_type == ATOM_free )
-    {
-        const uint8_t *p_buff = malloc(44);
-        const uint8_t *p_peek = p_buff;
-        int     i_read;
-        uint32_t i_fcc;
+   /* XXX sometime moov is hiden in a free box */
+   if( p_box->p_father &&
+      p_box->p_father->i_type == ATOM_root &&
+      p_box->i_type == ATOM_free )
+   {
+      const uint8_t *p_buff = malloc(44);
+      const uint8_t *p_peek = p_buff;
+      int     i_read;
+      uint32_t i_fcc;
 
-        i_read  = stream_peek( p_stream, p_peek, 44 );
+      i_read  = stream_peek( p_stream, p_peek, 44 );
 
-        p_peek += mp4_box_headersize( p_box ) + 4;
-        i_read -= mp4_box_headersize( p_box ) + 4;
+      p_peek += mp4_box_headersize( p_box ) + 4;
+      i_read -= mp4_box_headersize( p_box ) + 4;
 
-        if( i_read >= 8 )
-        {
-            i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
+      if( i_read >= 8 )
+      {
+         i_fcc = MP4_FOURCC( p_peek[0], p_peek[1], p_peek[2], p_peek[3] );
 
-            if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
-            {
-                printf( "detected moov hidden in a free box ..." );
+         if( i_fcc == ATOM_cmov || i_fcc == ATOM_mvhd )
+         {
+            printf( "detected moov hidden in a free box ..." );
 
-                p_box->i_type = ATOM_foov;
-                free(p_buff);
-                return MP4_ReadBoxContainer( p_stream, p_box );
-            }
-        }
-        free(p_buff);
-    }
+            p_box->i_type = ATOM_foov;
+            free(p_buff);
+            return MP4_ReadBoxContainer( p_stream, p_box );
+         }
+      }
+      free(p_buff);
+   }
 
-    /* Nothing to do */
-    // #ifdef MP4_VERBOSE
-    //    if MP4_BOX_TYPE_ASCII()
-    //        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
-    //    else
-    //        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
-    // #endif
+   /* Nothing to do */
+// #ifdef MP4_VERBOSE
+//    if MP4_BOX_TYPE_ASCII()
+//        printf( "skip box: \"%4.4s\"", (char*)&p_box->i_type );
+//    else
+//        printf( "skip box: \"c%3.3s\"", (char*)&p_box->i_type+1 );
+// #endif
 
-    return 1;
+   return 1;
 }
 
 #   define likely(p)   (!!(p))
@@ -389,86 +404,86 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_ftyp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
+   MP4_READBOX_ENTER( mp4_box_data_ftyp_t );
 
-    MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
-    MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
+   MP4_GETFOURCC( p_box->data.p_ftyp->major_brand );
+   MP4_GET4BYTES( p_box->data.p_ftyp->minor_version );
 
-    if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
-    {
-        unsigned int i = 0;
-        uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
-            calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
+   if( ( p_box->data.p_ftyp->compatible_brands_count = i_read / 4 ) )
+   {
+      unsigned int i = 0;
+      uint32_t *tab = p_box->data.p_ftyp->compatible_brands =
+         calloc( p_box->data.p_ftyp->compatible_brands_count, sizeof(uint32_t));
 
-        if( unlikely( tab == NULL ) )
-            MP4_READBOX_EXIT( 0 );
+      if( unlikely( tab == NULL ) )
+         MP4_READBOX_EXIT( 0 );
 
-        for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
-        {
-            MP4_GETFOURCC( tab[i] );
-        }
-    }
-    else
-    {
-        p_box->data.p_ftyp->compatible_brands = NULL;
-    }
+      for( i = 0; i < p_box->data.p_ftyp->compatible_brands_count; i++ )
+      {
+         MP4_GETFOURCC( tab[i] );
+      }
+   }
+   else
+   {
+      p_box->data.p_ftyp->compatible_brands = NULL;
+   }
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_ftyp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_ftyp->compatible_brands );
+   FREENULL( p_box->data.p_ftyp->compatible_brands );
 }
 
 static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int mmpu_buf;
-    int i;
-    MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
-    MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
-    MP4_GET1BYTE(mmpu_buf);
-    p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
-    p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
-    MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
-    MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
-    MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
-    p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
-    for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
-    {
+   unsigned int mmpu_buf;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_mmpu_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_mmpu);
+   MP4_GET1BYTE(mmpu_buf);
+   p_box->data.p_mmpu->is_complete=(mmpu_buf>>7)&0x01;
+   p_box->data.p_mmpu->reserved=mmpu_buf&0x7F;
+   MP4_GET4BYTES( p_box->data.p_mmpu->mpu_sequence_number );
+   MP4_GETFOURCC( p_box->data.p_mmpu->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_mmpu->asset_id_length );
+   p_box->data.p_mmpu->asset_id_value=(char *)malloc(p_box->data.p_mmpu->asset_id_length);
+   for (i=0;i<p_box->data.p_mmpu->asset_id_length;i++)
+   {
 
-        MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
-    }
+	   MP4_GET1BYTE( p_box->data.p_mmpu->asset_id_value[i] );
+   }
 
 
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
+   MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfdt );
 
-    if( p_box->data.p_tfdt->version )
-    {
-        MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+       if( p_box->data.p_tfdt->version )
+       {
+           MP4_GET8BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
 
-    }
-    else
-    {
-        MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
+       }
+       else
+       {
+           MP4_GET4BYTES( p_box->data.p_tfdt->baseMediaDecodeTime );
 
-    }
+       }
 
 
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_mmpu( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_mmpu->asset_id_value );
+   FREENULL( p_box->data.p_mmpu->asset_id_value );
 }
 
 
@@ -522,24 +537,24 @@ static int MP4_ReadBox_mvhd(  stream_t *p_stream, mp4_box_t *p_box )
 #ifdef MP4_VERBOSE
     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mvhd->creation_time );
     MP4_ConvertDate2Str( s_modification_time,
-            p_box->data.p_mvhd->modification_time );
+                         p_box->data.p_mvhd->modification_time );
     if( p_box->data.p_mvhd->rate )
     {
         MP4_ConvertDate2Str( s_duration,
-                p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
+                 p_box->data.p_mvhd->duration / p_box->data.p_mvhd->rate );
     }
     else
     {
         s_duration[0] = 0;
     }
-    printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
-            s_creation_time,
-            s_modification_time,
-            (uint32_t)p_box->data.p_mvhd->timescale,
-            s_duration,
-            (float)p_box->data.p_mvhd->rate / (1<<16 ),
-            (float)p_box->data.p_mvhd->volume / 256 ,
-            (uint32_t)p_box->data.p_mvhd->next_track_id );
+     printf( "read box: \"mvhd\" creation %s modification %s time scale %d duration %s rate %f volume %f next track id %d",
+                  s_creation_time,
+                  s_modification_time,
+                  (uint32_t)p_box->data.p_mvhd->timescale,
+                  s_duration,
+                  (float)p_box->data.p_mvhd->rate / (1<<16 ),
+                  (float)p_box->data.p_mvhd->volume / 256 ,
+                  (uint32_t)p_box->data.p_mvhd->next_track_id );
 #endif
     MP4_READBOX_EXIT( 1 );
 }
@@ -551,8 +566,8 @@ static int MP4_ReadBox_mfhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_mfhd->sequence_number );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"mfhd\" sequence number %d",
-            p_box->data.p_mfhd->sequence_number );
+     printf( "read box: \"mfhd\" sequence number %d",
+                  p_box->data.p_mfhd->sequence_number );
 #endif
     MP4_READBOX_EXIT( 1 );
 }
@@ -595,11 +610,11 @@ static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
         if( p_box->data.p_tfhd->i_flags & MP4_TFHD_DFLT_SAMPLE_FLAGS )
             snprintf(psz_flag, sizeof(psz_flag), "sample flags 0x%x", p_box->data.p_tfhd->default_sample_flags);
 
-        printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
-                p_box->data.p_tfhd->i_version,
-                p_box->data.p_tfhd->i_flags,
-                p_box->data.p_tfhd->track_ID,
-                psz_base, psz_desc, psz_dura, psz_size, psz_flag );
+         printf( "read box: \"tfhd\" version %d flags 0x%x track ID %d %s %s %s %s %s",
+                    p_box->data.p_tfhd->i_version,
+                    p_box->data.p_tfhd->i_flags,
+                    p_box->data.p_tfhd->track_ID,
+                    psz_base, psz_desc, psz_dura, psz_size, psz_flag );
 #endif
     }
 
@@ -608,7 +623,7 @@ static int MP4_ReadBox_tfhd(  stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
+   unsigned int i;
     MP4_READBOX_ENTER( mp4_box_data_trun_t );
 
     MP4_GETVERSIONFLAGS( p_box->data.p_trun );
@@ -621,7 +636,7 @@ static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
         MP4_GET4BYTES( p_box->data.p_trun->first_sample_flags );
 
     p_box->data.p_trun->samples =
-        calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
+      calloc( p_box->data.p_trun->sample_count, sizeof(mp4_descriptor_trun_sample_t) );
     if ( p_box->data.p_trun->samples == NULL )
         MP4_READBOX_EXIT( 0 );
 
@@ -639,17 +654,17 @@ static int MP4_ReadBox_trun(  stream_t *p_stream, mp4_box_t *p_box )
     }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
-            p_box->data.p_trun->version,
-            p_box->data.p_trun->flags,
-            p_box->data.p_trun->sample_count );
+     printf( "read box: \"trun\" version %d flags 0x%x sample count %d",
+                  p_box->data.p_trun->version,
+                  p_box->data.p_trun->flags,
+                  p_box->data.p_trun->sample_count );
 
     for( unsigned int i = 0; i<p_box->data.p_trun->sample_count; i++ )
     {
         mp4_descriptor_trun_sample_t *p_sample = &p_box->data.p_trun->samples[i];
-        printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
-                i, p_sample->i_flags, p_sample->duration,
-                p_sample->i_size, p_sample->composition_time_offset );
+         printf( "read box: \"trun\" sample %4.4d flags 0x%x duration %d size %d composition time offset %d",
+                        i, p_sample->i_flags, p_sample->duration,
+                        p_sample->i_size, p_sample->composition_time_offset );
     }
 #endif
 
@@ -712,19 +727,19 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_tkhd->width );
     MP4_GET4BYTES( p_box->data.p_tkhd->height );
 
-
+    
     matrix = p_box->data.p_tkhd->matrix;
-
+    
     translate[0] = conv_fx(matrix[6]);
     translate[1] = conv_fx(matrix[7]);
-
+    
     scale[0] = sqrt(conv_fx(matrix[0]) * conv_fx(matrix[0]) +
-            conv_fx(matrix[3]) * conv_fx(matrix[3]));
+                    conv_fx(matrix[3]) * conv_fx(matrix[3]));
     scale[1] = sqrt(conv_fx(matrix[1]) * conv_fx(matrix[1]) +
-            conv_fx(matrix[4]) * conv_fx(matrix[4]));
-
+                    conv_fx(matrix[4]) * conv_fx(matrix[4]));
+    
     rotation = atan2(conv_fx(matrix[1]) / scale[1], conv_fx(matrix[0]) / scale[0]) * 180 / M_PI;
-
+    
     if (rotation < 0)
         rotation += 360.;
 
@@ -733,30 +748,30 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mvhd->modification_time );
     MP4_ConvertDate2Str( s_duration, p_box->data.p_mvhd->duration );
 
-    printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
+     printf( "read box: \"tkhd\" creation %s modification %s duration %s track ID %d layer %d volume %f rotation %f scaleX %f scaleY %f translateX %f translateY %f width %f height %f. "
             "Matrix: %i %i %i %i %i %i %i %i %i",
-            s_creation_time,
-            s_modification_time,
-            s_duration,
-            p_box->data.p_tkhd->track_ID,
-            p_box->data.p_tkhd->layer,
-            (float)p_box->data.p_tkhd->volume / 256 ,
-            rotation,
-            scale[0],
-            scale[1],
-            translate[0],
-            translate[1],
-            (float)p_box->data.p_tkhd->width / 65536,
-            (float)p_box->data.p_tkhd->height / 65536,
-            p_box->data.p_tkhd->matrix[0],
-            p_box->data.p_tkhd->matrix[1],
-            p_box->data.p_tkhd->matrix[2],
-            p_box->data.p_tkhd->matrix[3],
-            p_box->data.p_tkhd->matrix[4],
-            p_box->data.p_tkhd->matrix[5],
-            p_box->data.p_tkhd->matrix[6],
-            p_box->data.p_tkhd->matrix[7],
-            p_box->data.p_tkhd->matrix[8] );
+                  s_creation_time,
+                  s_modification_time,
+                  s_duration,
+                  p_box->data.p_tkhd->track_ID,
+                  p_box->data.p_tkhd->layer,
+                  (float)p_box->data.p_tkhd->volume / 256 ,
+                  rotation,
+                  scale[0],
+                  scale[1],
+                  translate[0],
+                  translate[1],
+                  (float)p_box->data.p_tkhd->width / 65536,
+                  (float)p_box->data.p_tkhd->height / 65536,
+                  p_box->data.p_tkhd->matrix[0],
+                  p_box->data.p_tkhd->matrix[1],
+                  p_box->data.p_tkhd->matrix[2],
+                  p_box->data.p_tkhd->matrix[3],
+                  p_box->data.p_tkhd->matrix[4],
+                  p_box->data.p_tkhd->matrix[5],
+                  p_box->data.p_tkhd->matrix[6],
+                  p_box->data.p_tkhd->matrix[7],
+                  p_box->data.p_tkhd->matrix[8] );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -765,11 +780,11 @@ static int MP4_ReadBox_tkhd(  stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_hint( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_hint_t );
+   MP4_READBOX_ENTER( mp4_box_data_hint_t );
 
-    MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
+   MP4_GET4BYTES( p_box->data.p_hint->track_IDs );
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -804,24 +819,24 @@ static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
     for( i = 0; i < 3; i++ )
     {
         p_box->data.p_mdhd->language[i] =
-            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+                    ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
     }
 
     MP4_GET2BYTES( p_box->data.p_mdhd->predefined );
 
-    // #ifdef MP4_VERBOSE
-    //     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
-    //     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
-    //     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
-    //      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
-    //                   s_creation_time,
-    //                   s_modification_time,
-    //                   (uint32_t)p_box->data.p_mdhd->timescale,
-    //                   s_duration,
-    //                   p_box->data.p_mdhd->language[0],
-    //                   p_box->data.p_mdhd->language[1],
-    //                   p_box->data.p_mdhd->language[2] );
-    // #endif
+// #ifdef MP4_VERBOSE
+//     MP4_ConvertDate2Str( s_creation_time, p_box->data.p_mdhd->creation_time );
+//     MP4_ConvertDate2Str( s_modification_time, p_box->data.p_mdhd->modification_time );
+//     MP4_ConvertDate2Str( s_duration, p_box->data.p_mdhd->duration );
+//      printf( "read box: \"mdhd\" creation %s modification %s time scale %d duration %s language %c%c%c",
+//                   s_creation_time,
+//                   s_modification_time,
+//                   (uint32_t)p_box->data.p_mdhd->timescale,
+//                   s_duration,
+//                   p_box->data.p_mdhd->language[0],
+//                   p_box->data.p_mdhd->language[1],
+//                   p_box->data.p_mdhd->language[2] );
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 }
@@ -869,9 +884,9 @@ static int MP4_ReadBox_hdlr( stream_t *p_stream, mp4_box_t *p_box )
     }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
-            (char*)&p_box->data.p_hdlr->handler_type,
-            p_box->data.p_hdlr->psz_name );
+         printf( "read box: \"hdlr\" handler type: \"%4.4s\" name: \"%s\"",
+                   (char*)&p_box->data.p_hdlr->handler_type,
+                   p_box->data.p_hdlr->psz_name );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -884,25 +899,25 @@ static void MP4_FreeBox_hdlr( mp4_box_t *p_box )
 
 static int MP4_ReadBox_vmhd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_vmhd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
+   MP4_GETVERSIONFLAGS( p_box->data.p_vmhd );
 
-    MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
-    for( i = 0; i < 3; i++ )
-    {
-        MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
-    }
+   MP4_GET2BYTES( p_box->data.p_vmhd->graphics_mode );
+   for( i = 0; i < 3; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_vmhd->opcolor[i] );
+   }
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
-            p_box->data.p_vmhd->i_graphics_mode,
-            p_box->data.p_vmhd->i_opcolor[0],
-            p_box->data.p_vmhd->i_opcolor[1],
-            p_box->data.p_vmhd->i_opcolor[2] );
+     printf( "read box: \"vmhd\" graphics-mode %d opcolor (%d, %d, %d)",
+                      p_box->data.p_vmhd->i_graphics_mode,
+                      p_box->data.p_vmhd->i_opcolor[0],
+                      p_box->data.p_vmhd->i_opcolor[1],
+                      p_box->data.p_vmhd->i_opcolor[2] );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
@@ -917,10 +932,10 @@ static int MP4_ReadBox_smhd( stream_t *p_stream, mp4_box_t *p_box )
 
     MP4_GET2BYTES( p_box->data.p_smhd->reserved );
 
-    // #ifdef MP4_VERBOSE
-    //      printf( "read box: \"smhd\" balance %f",
-    //                       (float)p_box->data.p_smhd->balance / 256 );
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"smhd\" balance %f",
+//                       (float)p_box->data.p_smhd->balance / 256 );
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 }
@@ -941,11 +956,11 @@ static int MP4_ReadBox_hmhd( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( p_box->data.p_hmhd->reserved );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
-            p_box->data.p_hmhd->max_PDU_size,
-            p_box->data.p_hmhd->avg_PDU_size,
-            p_box->data.p_hmhd->max_bitrate,
-            p_box->data.p_hmhd->avg_bitrate );
+     printf( "read box: \"hmhd\" maxPDU-size %d avgPDU-size %d max-bitrate %d avg-bitrate %d",
+                      p_box->data.p_hmhd->max_PDU_size,
+                      p_box->data.p_hmhd->avg_PDU_size,
+                      p_box->data.p_hmhd->max_bitrate,
+                      p_box->data.p_hmhd->avg_bitrate );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -959,8 +974,8 @@ static int MP4_ReadBox_url( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GETSTRINGZ( p_box->data.p_url->psz_location );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"url\" url: %s",
-            p_box->data.p_url->psz_location );
+     printf( "read box: \"url\" url: %s",
+                       p_box->data.p_url->psz_location );
 
 #endif
     MP4_READBOX_EXIT( 1 );
@@ -982,9 +997,9 @@ static int MP4_ReadBox_urn( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GETSTRINGZ( p_box->data.p_urn->psz_location );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"urn\" name %s location %s",
-            p_box->data.p_urn->psz_name,
-            p_box->data.p_urn->psz_location );
+     printf( "read box: \"urn\" name %s location %s",
+                      p_box->data.p_urn->psz_name,
+                      p_box->data.p_urn->psz_location );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1008,8 +1023,8 @@ static int MP4_ReadBox_dref( stream_t *p_stream, mp4_box_t *p_box )
     MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
-    printf( "read box: \"dref\" entry-count %d",
-            p_box->data.p_dref->entry_count );
+     printf( "read box: \"dref\" entry-count %d",
+                      p_box->data.p_dref->entry_count );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1023,35 +1038,35 @@ static void MP4_FreeBox_stts( mp4_box_t *p_box )
 
 static int MP4_ReadBox_stts( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
-    MP4_READBOX_ENTER( mp4_box_data_stts_t );
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_stts_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stts );
-    MP4_GET4BYTES( p_box->data.p_stts->entry_count );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stts );
+   MP4_GET4BYTES( p_box->data.p_stts->entry_count );
 
-    p_box->data.p_stts->sample_count =
-        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stts->sample_delta =
-        calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
-    if( p_box->data.p_stts->sample_count == NULL
-            || p_box->data.p_stts->sample_delta == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_stts->sample_count =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stts->sample_delta =
+      calloc( p_box->data.p_stts->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_stts->sample_count == NULL
+      || p_box->data.p_stts->sample_delta == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
-        MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
-    }
+   for( i = 0; (i < p_box->data.p_stts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_stts->sample_delta[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stts\" entry-count %d",
-            p_box->data.p_stts->entry_count );
+      p_box->data.p_stts->entry_count );
 
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1063,35 +1078,35 @@ static void MP4_FreeBox_ctts( mp4_box_t *p_box )
 
 static int MP4_ReadBox_ctts( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_ctts_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_ctts_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
+   MP4_GETVERSIONFLAGS( p_box->data.p_ctts );
 
-    MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
+   MP4_GET4BYTES( p_box->data.p_ctts->entry_count );
 
-    p_box->data.p_ctts->sample_count =
-        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
-    p_box->data.p_ctts->sample_offset =
-        calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
-    if( ( p_box->data.p_ctts->sample_count == NULL )
-            || ( p_box->data.p_ctts->sample_offset == NULL ) )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_ctts->sample_count =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   p_box->data.p_ctts->sample_offset =
+      calloc( p_box->data.p_ctts->entry_count, sizeof(uint32_t) );
+   if( ( p_box->data.p_ctts->sample_count == NULL )
+      || ( p_box->data.p_ctts->sample_offset == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
-        MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
-    }
+   for( i = 0; (i < p_box->data.p_ctts->entry_count )&&( i_read >=8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_count[i] );
+      MP4_GET4BYTES( p_box->data.p_ctts->sample_offset[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"ctts\" entry-count %d",
-            p_box->data.p_ctts->entry_count );
+      p_box->data.p_ctts->entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1139,8 +1154,8 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
         i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-        printf( "found esds MPEG4ESDescr (%dBytes)",
-                i_len );
+         printf( "found esds MPEG4ESDescr (%dBytes)",
+                 i_len );
 #endif
 
         MP4_GET2BYTES( es_descriptor.ES_ID );
@@ -1181,19 +1196,19 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
 
     if( i_type != 0x04)/* MP4DecConfigDescrTag */
     {
-        es_descriptor.decConfigDescr = NULL;
-        MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
+         es_descriptor.decConfigDescr = NULL;
+         MP4_READBOX_EXIT( 1 ); /* rest isn't interesting up to now */
     }
 
     i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-    printf( "found esds MP4DecConfigDescr (%dBytes)",
-            i_len );
+         printf( "found esds MP4DecConfigDescr (%dBytes)",
+                 i_len );
 #endif
 
     es_descriptor.decConfigDescr =
-        calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
+            calloc( 1, sizeof( mp4_descriptor_decoder_config_t ));
     if( unlikely( es_descriptor.decConfigDescr == NULL ) )
         MP4_READBOX_EXIT( 0 );
 
@@ -1215,8 +1230,8 @@ static int MP4_ReadBox_esds( stream_t *p_stream, mp4_box_t *p_box )
     i_len = MP4_ReadLengthDescriptor( &p_peek, &i_read );
 
 #ifdef MP4_VERBOSE
-    printf( "found esds MP4DecSpecificDescr (%dBytes)",
-            i_len );
+         printf( "found esds MP4DecSpecificDescr (%dBytes)",
+                 i_len );
 #endif
     if( i_len > i_read )
         MP4_READBOX_EXIT( 0 );
@@ -1324,23 +1339,23 @@ static int MP4_ReadBox_avcC( stream_t *p_stream, mp4_box_t *p_box )
             i_read -= p_avcC->pps_length[i];
         }
     }
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
-    //              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
-    //              p_avcC->i_length_size,
-    //              p_avcC->i_sps, p_avcC->i_pps );
-    //     for( i = 0; i < p_avcC->i_sps; i++ )
-    //     {
-    //          printf( "         - sps[%d] length=%d",
-    //                  i, p_avcC->i_sps_length[i] );
-    //     }
-    //     for( i = 0; i < p_avcC->i_pps; i++ )
-    //     {
-    //          printf( "         - pps[%d] length=%d",
-    //                  i, p_avcC->i_pps_length[i] );
-    //     }
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf(
+//              "read box: \"avcC\" version=%d profile=0x%x level=0x%x length size=%d sps=%d pps=%d",
+//              p_avcC->i_version, p_avcC->i_profile, p_avcC->i_level,
+//              p_avcC->i_length_size,
+//              p_avcC->i_sps, p_avcC->i_pps );
+//     for( i = 0; i < p_avcC->i_sps; i++ )
+//     {
+//          printf( "         - sps[%d] length=%d",
+//                  i, p_avcC->i_sps_length[i] );
+//     }
+//     for( i = 0; i < p_avcC->i_pps; i++ )
+//     {
+//          printf( "         - pps[%d] length=%d",
+//                  i, p_avcC->i_pps_length[i] );
+//     }
+// #endif
 
     MP4_READBOX_EXIT( 1 );
 
@@ -1356,7 +1371,7 @@ static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
     MP4_READBOX_ENTER( mp4_box_data_dac3_t );
 
     p_dac3 = p_box->data.p_dac3;
-
+    
     MP4_GET3BYTES( i_header );
 
     p_dac3->fscod = ( i_header >> 22 ) & 0x03;
@@ -1367,9 +1382,9 @@ static int MP4_ReadBox_dac3( stream_t *p_stream, mp4_box_t *p_box )
     p_dac3->bitrate_code = ( i_header >> 5) & 0x1f;
 
 #ifdef MP4_VERBOSE
-    printf(
-            "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
-            p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
+     printf(
+             "read box: \"dac3\" fscod=0x%x bsid=0x%x bsmod=0x%x acmod=0x%x lfeon=0x%x bitrate_code=0x%x",
+             p_dac3->i_fscod, p_dac3->i_bsid, p_dac3->i_bsmod, p_dac3->i_acmod, p_dac3->i_lfeon, p_dac3->i_bitrate_code );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1385,8 +1400,8 @@ static int MP4_ReadBox_enda( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET2BYTES( p_enda->little_endian );
 
 #ifdef MP4_VERBOSE
-    printf(
-            "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
+     printf(
+             "read box: \"enda\" little_endian=%d", p_enda->i_little_endian );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1415,7 +1430,7 @@ static int MP4_ReadBox_gnre( stream_t *p_stream, mp4_box_t *p_box )
     if( p_gnre->genre == 0 )
         MP4_READBOX_EXIT( 0 );
 #ifdef MP4_VERBOSE
-    printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
+     printf( "read box: \"gnre\" genre=%i", p_gnre->i_genre );
 #endif
 
     MP4_READBOX_EXIT( 1 );
@@ -1442,17 +1457,17 @@ static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
     MP4_GET4BYTES( i_reserved );
     MP4_GET4BYTES( p_trkn->track_number );
 
-    // #ifdef MP4_VERBOSE
-    //      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
-    // #endif
+// #ifdef MP4_VERBOSE
+//      printf( "read box: \"trkn\" number=%i", p_trkn->track_number );
+// #endif
 
     if( i_data_len > 15 )
     {
-        MP4_GET4BYTES( p_trkn->track_total );
+       MP4_GET4BYTES( p_trkn->track_total );
 
-        // #ifdef MP4_VERBOSE
-        //         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
-        // #endif
+// #ifdef MP4_VERBOSE
+//         printf( "read box: \"trkn\" total=%i", p_trkn->track_total );
+// #endif
 
     }
 
@@ -1462,420 +1477,420 @@ static int MP4_ReadBox_trkn( stream_t *p_stream, mp4_box_t *p_box )
 
 static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
-    p_box->data.p_sample_soun->qt_description = NULL;
-
-    /* Sanity check needed because the "wave" box does also contain an
-     * "mp4a" box that we don't understand. */
-    if( i_read < 28 )
-    {
-        i_read -= 30;
-        MP4_READBOX_EXIT( 1 );
-    }
-
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
-
-    /*
-     * XXX hack -> produce a copy of the nearly complete chunk
-     */
-    p_box->data.p_sample_soun->qt_description = 0;
-    p_box->data.p_sample_soun->p_qt_description = NULL;
-    if( i_read > 0 )
-    {
-        p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
-        if( p_box->data.p_sample_soun->p_qt_description )
-        {
-            p_box->data.p_sample_soun->qt_description = i_read;
-            memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
-        }
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
-    MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
-
-    MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
-    MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
-
-    if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
-    {
-        /* SoundDescriptionV1 */
-        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
-        MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
+   p_box->data.p_sample_soun->qt_description = NULL;
+
+   /* Sanity check needed because the "wave" box does also contain an
+   * "mp4a" box that we don't understand. */
+   if( i_read < 28 )
+   {
+      i_read -= 30;
+      MP4_READBOX_EXIT( 1 );
+   }
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_soun->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   p_box->data.p_sample_soun->qt_description = 0;
+   p_box->data.p_sample_soun->p_qt_description = NULL;
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_soun->p_qt_description = malloc( i_read );
+      if( p_box->data.p_sample_soun->p_qt_description )
+      {
+         p_box->data.p_sample_soun->qt_description = i_read;
+         memcpy( p_box->data.p_sample_soun->p_qt_description, p_peek, i_read );
+      }
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_soun->qt_vendor );
+
+   MP4_GET2BYTES( p_box->data.p_sample_soun->channelcount );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->samplesize );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->predefined );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->reserved3 );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratehi );
+   MP4_GET2BYTES( p_box->data.p_sample_soun->sampleratelo );
+
+   if( p_box->data.p_sample_soun->qt_version == 1 && i_read >= 16 )
+   {
+      /* SoundDescriptionV1 */
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_packet );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_frame );
+      MP4_GET4BYTES( p_box->data.p_sample_soun->bytes_per_sample );
 
 #ifdef MP4_VERBOSE
-        printf(
-                "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
-                "bytes/frame=%d bytes/sample=%d",
-                p_box->data.p_sample_soun->i_sample_per_packet,
-                p_box->data.p_sample_soun->i_bytes_per_packet,
-                p_box->data.p_sample_soun->i_bytes_per_frame,
-                p_box->data.p_sample_soun->i_bytes_per_sample );
+       printf(
+         "read box: \"soun\" qt3+ sample/packet=%d bytes/packet=%d "
+         "bytes/frame=%d bytes/sample=%d",
+         p_box->data.p_sample_soun->i_sample_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_packet,
+         p_box->data.p_sample_soun->i_bytes_per_frame,
+         p_box->data.p_sample_soun->i_bytes_per_sample );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 44, SEEK_SET );
-    }
-    else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
-    {
-        /* SoundDescriptionV2 */
-        double f_sample_rate;
-        int64_t dummy;
-        uint32_t i_channel;
-
-        MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
-        MP4_GET8BYTES( dummy );
-        memcpy( &f_sample_rate, &dummy, 8 );
-
-        printf( "read box: %f Hz", f_sample_rate );
-        p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
-        p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
-
-        MP4_GET4BYTES( i_channel );
-        p_box->data.p_sample_soun->channelcount = i_channel;
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 44, SEEK_SET );
+   }
+   else if( p_box->data.p_sample_soun->qt_version == 2 && i_read >= 36 )
+   {
+      /* SoundDescriptionV2 */
+      double f_sample_rate;
+      int64_t dummy;
+      uint32_t i_channel;
+
+      MP4_GET4BYTES( p_box->data.p_sample_soun->sample_per_packet );
+      MP4_GET8BYTES( dummy );
+      memcpy( &f_sample_rate, &dummy, 8 );
+
+       printf( "read box: %f Hz", f_sample_rate );
+      p_box->data.p_sample_soun->sampleratehi = (int)f_sample_rate % 65536;
+      p_box->data.p_sample_soun->sampleratelo = f_sample_rate / 65536;
+
+      MP4_GET4BYTES( i_channel );
+      p_box->data.p_sample_soun->channelcount = i_channel;
 
 #ifdef MP4_VERBOSE
-        printf( "read box: \"soun\" V2" );
+       printf( "read box: \"soun\" V2" );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
-    }
-    else
-    {
-        p_box->data.p_sample_soun->sample_per_packet = 0;
-        p_box->data.p_sample_soun->bytes_per_packet = 0;
-        p_box->data.p_sample_soun->bytes_per_frame = 0;
-        p_box->data.p_sample_soun->bytes_per_sample = 0;
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28 + 36, SEEK_SET );
+   }
+   else
+   {
+      p_box->data.p_sample_soun->sample_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_packet = 0;
+      p_box->data.p_sample_soun->bytes_per_frame = 0;
+      p_box->data.p_sample_soun->bytes_per_sample = 0;
 
 #ifdef MP4_VERBOSE
-        printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
-                i_read );
+       printf( "read box: \"soun\" mp4 or qt1/2 (rest=%"PRId64")",
+         i_read );
 #endif
-        stream_seek( p_stream, p_box->i_pos +
-                mp4_box_headersize( p_box ) + 28, SEEK_SET );
-    }
-
-    if( p_box->i_type == ATOM_drms )
-    {
-        assert(0);
-        //         char *home = config_GetUserDir( VLC_HOME_DIR );
-        //         if( home != NULL )
-        //         {
-        //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
-        //             if( p_box->data.p_sample_soun->p_drms == NULL )
-        //                 msg_Err( p_stream, "drms_alloc() failed" );
-        //         }
-    }
-
-    if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
-    {
-        /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
-        p_box->data.p_sample_soun->channelcount = 1;
-    }
-
-    MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
+      stream_seek( p_stream, p_box->i_pos +
+         mp4_box_headersize( p_box ) + 28, SEEK_SET );
+   }
+
+   if( p_box->i_type == ATOM_drms )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_soun->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_soun->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   if( p_box->i_type == ATOM_samr || p_box->i_type == ATOM_sawb )
+   {
+      /* Ignore channelcount for AMR (3gpp AMRSpecificBox) */
+      p_box->data.p_sample_soun->channelcount = 1;
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box ); /* esds/wave/... */
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"soun\" in stsd channel %d "
-            "sample size %d sample rate %f",
-            p_box->data.p_sample_soun->channelcount,
-            p_box->data.p_sample_soun->samplesize,
-            (float)p_box->data.p_sample_soun->sampleratehi +
-            (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
+      "sample size %d sample rate %f",
+      p_box->data.p_sample_soun->channelcount,
+      p_box->data.p_sample_soun->samplesize,
+      (float)p_box->data.p_sample_soun->sampleratehi +
+      (float)p_box->data.p_sample_soun->sampleratelo / 65536 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 /*****************************************************************************
- * aes_s: AES keys structure
- *****************************************************************************
- * This structure stores a set of keys usable for encryption and decryption
- * with the AES/Rijndael algorithm.
- *****************************************************************************/
+* aes_s: AES keys structure
+*****************************************************************************
+* This structure stores a set of keys usable for encryption and decryption
+* with the AES/Rijndael algorithm.
+*****************************************************************************/
 #define AES_KEY_COUNT 10
 #define PATH_MAX 260
 struct aes_s
 {
-    uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
-    uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+   uint32_t pp_enc_keys[ AES_KEY_COUNT + 1 ][ 4 ];
+   uint32_t pp_dec_keys[ AES_KEY_COUNT + 1 ][ 4 ];
 };
 
 /*****************************************************************************
- * drms_s: DRMS structure
- *****************************************************************************
- * This structure stores the static information needed to decrypt DRMS data.
- *****************************************************************************/
+* drms_s: DRMS structure
+*****************************************************************************
+* This structure stores the static information needed to decrypt DRMS data.
+*****************************************************************************/
 struct drms_s
 {
-    uint32_t i_user;
-    uint32_t i_key;
-    uint8_t  p_iviv[ 16 ];
-    uint8_t *p_name;
+   uint32_t i_user;
+   uint32_t i_key;
+   uint8_t  p_iviv[ 16 ];
+   uint8_t *p_name;
 
-    uint32_t p_key[ 4 ];
-    struct aes_s aes;
+   uint32_t p_key[ 4 ];
+   struct aes_s aes;
 
-    char     psz_homedir[ PATH_MAX ];
+   char     psz_homedir[ PATH_MAX ];
 };
 
 /*****************************************************************************
- * drms_free: free a previously allocated DRMS structure
- *****************************************************************************/
+* drms_free: free a previously allocated DRMS structure
+*****************************************************************************/
 void drms_free( void *_p_drms )
 {
-    struct drms_s *p_drms = (struct drms_s *)_p_drms;
+   struct drms_s *p_drms = (struct drms_s *)_p_drms;
 
-    //free( (void *)p_drms->p_name );
-    free( p_drms->p_name );
-    free( p_drms );
+   //free( (void *)p_drms->p_name );
+   free( p_drms->p_name );
+   free( p_drms );
 }
 
 
 static void MP4_FreeBox_sample_soun( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_soun->p_qt_description );
+   FREENULL( p_box->data.p_sample_soun->p_qt_description );
 
-    if( p_box->i_type == ATOM_drms )
-    {
-        if( p_box->data.p_sample_soun->drms )
-        {
-            drms_free( p_box->data.p_sample_soun->drms );
-        }
-    }
+   if( p_box->i_type == ATOM_drms )
+   {
+      if( p_box->data.p_sample_soun->drms )
+      {
+         drms_free( p_box->data.p_sample_soun->drms );
+      }
+   }
 }
 
 
 int MP4_ReadBox_sample_vide( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
-
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
-
-    /*
-     * XXX hack -> produce a copy of the nearly complete chunk
-     */
-    if( i_read > 0 )
-    {
-        p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
-        if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
-            MP4_READBOX_EXIT( 0 );
-        p_box->data.p_sample_vide->qt_image_description = i_read;
-        memcpy( p_box->data.p_sample_vide->p_qt_image_description,
-                p_peek, i_read );
-    }
-    else
-    {
-        p_box->data.p_sample_vide->qt_image_description = 0;
-        p_box->data.p_sample_vide->p_qt_image_description = NULL;
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->width );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->height );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
-    MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
-
-    MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
-
-    memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
-    p_peek += 32; i_read -= 32;
-
-    MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
-    MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
-
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
-
-    if( p_box->i_type == ATOM_drmi )
-    {
-        assert(0);
-        //         char *home = config_GetUserDir( VLC_HOME_DIR );
-        //         if( home != NULL )
-        //         {
-        //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
-        //             if( p_box->data.p_sample_vide->p_drms == NULL )
-        //                 msg_Err( p_stream, "drms_alloc() failed" );
-        //         }
-    }
-
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_sample_vide_t );
+
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_vide->reserved1[i] );
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->data_reference_index );
+
+   /*
+   * XXX hack -> produce a copy of the nearly complete chunk
+   */
+   if( i_read > 0 )
+   {
+      p_box->data.p_sample_vide->p_qt_image_description = malloc( i_read );
+      if( unlikely( p_box->data.p_sample_vide->p_qt_image_description == NULL ) )
+         MP4_READBOX_EXIT( 0 );
+      p_box->data.p_sample_vide->qt_image_description = i_read;
+      memcpy( p_box->data.p_sample_vide->p_qt_image_description,
+         p_peek, i_read );
+   }
+   else
+   {
+      p_box->data.p_sample_vide->qt_image_description = 0;
+      p_box->data.p_sample_vide->p_qt_image_description = NULL;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_version );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_revision_level );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_vendor );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_temporal_quality );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_spatial_quality );
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->width );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->height );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->horizresolution );
+   MP4_GET4BYTES( p_box->data.p_sample_vide->vertresolution );
+
+   MP4_GET4BYTES( p_box->data.p_sample_vide->qt_data_size );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_frame_count );
+
+   memcpy( &p_box->data.p_sample_vide->compressorname, p_peek, 32 );
+   p_peek += 32; i_read -= 32;
+
+   MP4_GET2BYTES( p_box->data.p_sample_vide->depth );
+   MP4_GET2BYTES( p_box->data.p_sample_vide->qt_color_table );
+
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 78, SEEK_SET );
+
+   if( p_box->i_type == ATOM_drmi )
+   {
+      assert(0);
+      //         char *home = config_GetUserDir( VLC_HOME_DIR );
+      //         if( home != NULL )
+      //         {
+      //             p_box->data.p_sample_vide->p_drms = drms_alloc( home );
+      //             if( p_box->data.p_sample_vide->p_drms == NULL )
+      //                 msg_Err( p_stream, "drms_alloc() failed" );
+      //         }
+   }
+
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"vide\" in stsd %dx%d depth %d",
-            p_box->data.p_sample_vide->width,
-            p_box->data.p_sample_vide->height,
-            p_box->data.p_sample_vide->depth );
+      p_box->data.p_sample_vide->width,
+      p_box->data.p_sample_vide->height,
+      p_box->data.p_sample_vide->depth );
 
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 void MP4_FreeBox_sample_vide( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
+   FREENULL( p_box->data.p_sample_vide->p_qt_image_description );
 
-    if( p_box->i_type == ATOM_drmi )
-    {
-        if( p_box->data.p_sample_vide->drms )
-        {
-            drms_free( p_box->data.p_sample_vide->drms );
-        }
-    }
+   if( p_box->i_type == ATOM_drmi )
+   {
+      if( p_box->data.p_sample_vide->drms )
+      {
+         drms_free( p_box->data.p_sample_vide->drms );
+      }
+   }
 }
 
 
 int MP4_ReadBox_sample_mmth( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    unsigned int  mmth_buf;
-    int j;
-    MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
+   unsigned int i = 0;
+   unsigned int  mmth_buf;
+   int j;
+   MP4_READBOX_ENTER( mp4_box_data_sample_mmth_t );
 
-    for( i = 0; i < 6 ; i++ )
-    {
-        MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
-    }
+   for( i = 0; i < 6 ; i++ )
+   {
+      MP4_GET1BYTE( p_box->data.p_sample_mmth->reserved1[i] );
+   }
 
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->data_reference_index );
 
 
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
-    MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
-    MP4_GET1BYTE(mmth_buf);
-    p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
-    p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
-    p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->hinttrackversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->highestcompatibleversion );
+   MP4_GET2BYTES( p_box->data.p_sample_mmth->packet_id );
+   MP4_GET1BYTE(mmth_buf);
+   p_box->data.p_sample_mmth->has_mfus_flag=(mmth_buf>>7)&0x01;
+   p_box->data.p_sample_mmth->is_timed=(mmth_buf>>6)&0x01;
+   p_box->data.p_sample_mmth->reserved=mmth_buf&0x3F;
 
-    /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
-      MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
-      p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
-      for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
-      {
+   /*MP4_GETFOURCC( p_box->data.p_sample_mmth->asset_id_scheme );
+   MP4_GET4BYTES( p_box->data.p_sample_mmth->asset_id_length );
+   p_box->data.p_sample_mmth->asset_id_value=(char *)malloc(p_box->data.p_sample_mmth->asset_id_length);
+   for (j=0;j<p_box->data.p_sample_mmth->asset_id_length;j++)
+	  {
 
-      MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
-      }*/
+	   MP4_GET1BYTE( p_box->data.p_sample_mmth->asset_id_value[j] );
+	  }*/
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_sample_mp4s( stream_t *p_stream, mp4_box_t *p_box )
 {
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
-    return 1;
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
+   return 1;
 }
 
 static int MP4_ReadBox_sample_text( stream_t *p_stream, mp4_box_t *p_box )
 {
-    int32_t t;
-
-    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
-
-    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
-    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
-
-    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
-
-    MP4_GET4BYTES( t );
-    switch( t )
-    {
-        /* FIXME search right signification */
-        case 1: // Center
-            p_box->data.p_sample_text->justification_horizontal = 1;
-            p_box->data.p_sample_text->justification_vertical = 1;
-            break;
-        case -1:    // Flush Right
-            p_box->data.p_sample_text->justification_horizontal = -1;
-            p_box->data.p_sample_text->justification_vertical = -1;
-            break;
-        case -2:    // Flush p_first
-            p_box->data.p_sample_text->justification_horizontal = 0;
-            p_box->data.p_sample_text->justification_vertical = 0;
-            break;
-        case 0: // Flush Default
-        default:
-            p_box->data.p_sample_text->justification_horizontal = 1;
-            p_box->data.p_sample_text->justification_vertical = -1;
-            break;
-    }
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
-    MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
-    p_box->data.p_sample_text->background_color[3] = 0;
-
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+   int32_t t;
+
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+
+   MP4_GET4BYTES( t );
+   switch( t )
+   {
+      /* FIXME search right signification */
+   case 1: // Center
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = 1;
+      break;
+   case -1:    // Flush Right
+      p_box->data.p_sample_text->justification_horizontal = -1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   case -2:    // Flush p_first
+      p_box->data.p_sample_text->justification_horizontal = 0;
+      p_box->data.p_sample_text->justification_vertical = 0;
+      break;
+   case 0: // Flush Default
+   default:
+      p_box->data.p_sample_text->justification_horizontal = 1;
+      p_box->data.p_sample_text->justification_vertical = -1;
+      break;
+   }
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET2BYTES( p_box->data.p_sample_text->background_color[2] );
+   p_box->data.p_sample_text->background_color[3] = 0;
+
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"text\" in stsd text" );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
+   MP4_READBOX_ENTER( mp4_box_data_sample_text_t );
 
-    MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
-    MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
+   MP4_GET4BYTES( p_box->data.p_sample_text->reserved1 );
+   MP4_GET2BYTES( p_box->data.p_sample_text->reserved2 );
 
-    MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
+   MP4_GET2BYTES( p_box->data.p_sample_text->data_reference_index );
 
-    MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
+   MP4_GET4BYTES( p_box->data.p_sample_text->display_flags );
 
-    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_horizontal );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->justification_vertical );
 
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
-    MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[0] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[1] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[2] );
+   MP4_GET1BYTE ( p_box->data.p_sample_text->background_color[3] );
 
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
-    MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_top );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_left );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_bottom );
+   MP4_GET2BYTES( p_box->data.p_sample_text->text_box_right );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"tx3g\" in stsd text" );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
@@ -1883,7 +1898,7 @@ static int MP4_ReadBox_sample_tx3g( stream_t *p_stream, mp4_box_t *p_box )
 /* We can't easily call it, and anyway ~ 20 bytes lost isn't a real problem */
 static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sample_text->psz_text_name );
+   FREENULL( p_box->data.p_sample_text->psz_text_name );
 }
 #endif
 
@@ -1891,2055 +1906,1952 @@ static void MP4_FreeBox_sample_text( mp4_box_t *p_box )
 static int MP4_ReadBox_stsd( stream_t *p_stream, mp4_box_t *p_box )
 {
 
-    MP4_READBOX_ENTER( mp4_box_data_stsd_t );
+   MP4_READBOX_ENTER( mp4_box_data_stsd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsd );
 
-    MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stsd->entry_count );
 
-    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
+   stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 8, SEEK_SET );
 
-    MP4_ReadBoxContainerRaw( p_stream, p_box );
+   MP4_ReadBoxContainerRaw( p_stream, p_box );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsd\" entry-count %d",
-            p_box->data.p_stsd->entry_count );
+      p_box->data.p_stsd->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_stsz( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsz_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsz_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsz );
 
-    MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
-    MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_size );
+   MP4_GET4BYTES( p_box->data.p_stsz->sample_count );
 
-    if( p_box->data.p_stsz->sample_size == 0 )
-    {
-        p_box->data.p_stsz->entry_size =
-            calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
-        if( unlikely( !p_box->data.p_stsz->entry_size ) )
-            MP4_READBOX_EXIT( 0 );
+   if( p_box->data.p_stsz->sample_size == 0 )
+   {
+      p_box->data.p_stsz->entry_size =
+         calloc( p_box->data.p_stsz->sample_count, sizeof(uint32_t) );
+      if( unlikely( !p_box->data.p_stsz->entry_size ) )
+         MP4_READBOX_EXIT( 0 );
 
-        for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
-        {
-            MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
-        }
-    }
-    else
-        p_box->data.p_stsz->entry_size = NULL;
+      for( i = 0; (i<p_box->data.p_stsz->sample_count)&&(i_read >= 4 ); i++ )
+      {
+         MP4_GET4BYTES( p_box->data.p_stsz->entry_size[i] );
+      }
+   }
+   else
+      p_box->data.p_stsz->entry_size = NULL;
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsz\" sample-size %d sample-count %d",
-            p_box->data.p_stsz->sample_size,
-            p_box->data.p_stsz->sample_count );
+      p_box->data.p_stsz->sample_size,
+      p_box->data.p_stsz->sample_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stsz( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsz->entry_size );
+   FREENULL( p_box->data.p_stsz->entry_size );
 }
 
 static void MP4_FreeBox_stsc( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsc->first_chunk );
-    FREENULL( p_box->data.p_stsc->samples_per_chunk );
-    FREENULL( p_box->data.p_stsc->sample_description_index );
+   FREENULL( p_box->data.p_stsc->first_chunk );
+   FREENULL( p_box->data.p_stsc->samples_per_chunk );
+   FREENULL( p_box->data.p_stsc->sample_description_index );
 }
 
 static int MP4_ReadBox_stsc( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsc_t );
-
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
-
-    MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
-
-    p_box->data.p_stsc->first_chunk =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsc->samples_per_chunk =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsc->sample_description_index =
-        calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
-    if( unlikely( p_box->data.p_stsc->first_chunk == NULL
-                || p_box->data.p_stsc->samples_per_chunk == NULL
-                || p_box->data.p_stsc->sample_description_index == NULL ) )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
-
-    for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
-        MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
-        MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
-    }
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsc_t );
+
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsc );
+
+   MP4_GET4BYTES( p_box->data.p_stsc->entry_count );
+
+   p_box->data.p_stsc->first_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->samples_per_chunk =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsc->sample_description_index =
+      calloc( p_box->data.p_stsc->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stsc->first_chunk == NULL
+      || p_box->data.p_stsc->samples_per_chunk == NULL
+      || p_box->data.p_stsc->sample_description_index == NULL ) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_stsc->entry_count )&&( i_read >= 12 );i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsc->first_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->samples_per_chunk[i] );
+      MP4_GET4BYTES( p_box->data.p_stsc->sample_description_index[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsc\" entry-count %d",
-            p_box->data.p_stsc->entry_count );
+      p_box->data.p_stsc->entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_stco_co64( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_co64_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_co64_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
+   MP4_GETVERSIONFLAGS( p_box->data.p_co64 );
 
-    MP4_GET4BYTES( p_box->data.p_co64->entry_count );
+   MP4_GET4BYTES( p_box->data.p_co64->entry_count );
 
-    p_box->data.p_co64->chunk_offset =
-        calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
-    if( p_box->data.p_co64->chunk_offset == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_co64->chunk_offset =
+      calloc( p_box->data.p_co64->entry_count, sizeof(uint64_t) );
+   if( p_box->data.p_co64->chunk_offset == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
-    {
-        if( p_box->i_type == ATOM_stco )
-        {
-            if( i_read < 4 )
-            {
-                break;
-            }
-            MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
-        }
-        else
-        {
-            if( i_read < 8 )
-            {
-                break;
-            }
-            MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
-        }
-    }
+   for( i = 0; i < p_box->data.p_co64->entry_count; i++ )
+   {
+      if( p_box->i_type == ATOM_stco )
+      {
+         if( i_read < 4 )
+         {
+            break;
+         }
+         MP4_GET4BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+      else
+      {
+         if( i_read < 8 )
+         {
+            break;
+         }
+         MP4_GET8BYTES( p_box->data.p_co64->chunk_offset[i] );
+      }
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"co64\" entry-count %d",
-            p_box->data.p_co64->entry_count );
+      p_box->data.p_co64->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stco_co64( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_co64->chunk_offset );
+   FREENULL( p_box->data.p_co64->chunk_offset );
 }
 
 static int MP4_ReadBox_stss( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stss_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stss_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stss );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stss );
 
-    MP4_GET4BYTES( p_box->data.p_stss->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stss->entry_count );
 
-    p_box->data.p_stss->sample_number =
-        calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
-    if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_stss->sample_number =
+      calloc( p_box->data.p_stss->entry_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_stss->sample_number == NULL ) )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
-    {
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 4 ); i++ )
+   {
 
-        MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
-        /* XXX in libmp4 sample begin at 0 */
-        p_box->data.p_stss->sample_number[i]--;
-    }
+      MP4_GET4BYTES( p_box->data.p_stss->sample_number[i] );
+      /* XXX in libmp4 sample begin at 0 */
+      p_box->data.p_stss->sample_number[i]--;
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stss\" entry-count %d",
-            p_box->data.p_stss->i_entry_count );
+      p_box->data.p_stss->i_entry_count );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stss( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stss->sample_number );
+   FREENULL( p_box->data.p_stss->sample_number );
 }
 
 static void MP4_FreeBox_stsh( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stsh->shadowed_sample_number );
-    FREENULL( p_box->data.p_stsh->sync_sample_number );
+   FREENULL( p_box->data.p_stsh->shadowed_sample_number );
+   FREENULL( p_box->data.p_stsh->sync_sample_number );
 }
 
 static int MP4_ReadBox_stsh( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stsh_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stsh_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stsh );
 
 
-    MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
+   MP4_GET4BYTES( p_box->data.p_stsh->entry_count );
 
-    p_box->data.p_stsh->shadowed_sample_number =
-        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
-    p_box->data.p_stsh->sync_sample_number =
-        calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsh->shadowed_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
+   p_box->data.p_stsh->sync_sample_number =
+      calloc( p_box->data.p_stsh->entry_count, sizeof(uint32_t) );
 
-    if( p_box->data.p_stsh->shadowed_sample_number == NULL
-            || p_box->data.p_stsh->sync_sample_number == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   if( p_box->data.p_stsh->shadowed_sample_number == NULL
+      || p_box->data.p_stsh->sync_sample_number == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
-        MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
-    }
+   for( i = 0; (i < p_box->data.p_stss->entry_count )&&( i_read >= 8 ); i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_stsh->shadowed_sample_number[i] );
+      MP4_GET4BYTES( p_box->data.p_stsh->sync_sample_number[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stsh\" entry-count %d",
-            p_box->data.p_stsh->i_entry_count );
+      p_box->data.p_stsh->i_entry_count );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 
 static int MP4_ReadBox_stdp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_stdp_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_stdp_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
+   MP4_GETVERSIONFLAGS( p_box->data.p_stdp );
 
-    p_box->data.p_stdp->priority =
-        calloc( i_read / 2, sizeof(uint16_t) );
+   p_box->data.p_stdp->priority =
+      calloc( i_read / 2, sizeof(uint16_t) );
 
-    if( unlikely( !p_box->data.p_stdp->priority ) )
-        MP4_READBOX_EXIT( 0 );
+   if( unlikely( !p_box->data.p_stdp->priority ) )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < i_read / 2 ; i++ )
-    {
-        MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
-    }
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_stdp->priority[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stdp\" entry-count %"PRId64,
-            i_read / 2 );
+      i_read / 2 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_stdp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_stdp->priority );
+   FREENULL( p_box->data.p_stdp->priority );
 }
 
 static void MP4_FreeBox_padb( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_padb->reserved1 );
-    FREENULL( p_box->data.p_padb->pad2 );
-    FREENULL( p_box->data.p_padb->reserved2 );
-    FREENULL( p_box->data.p_padb->pad1 );
+   FREENULL( p_box->data.p_padb->reserved1 );
+   FREENULL( p_box->data.p_padb->pad2 );
+   FREENULL( p_box->data.p_padb->reserved2 );
+   FREENULL( p_box->data.p_padb->pad1 );
 }
 
 static int MP4_ReadBox_padb( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t count;
-    unsigned int i = 0;
+   uint32_t count;
+   unsigned int i = 0;
 
-    MP4_READBOX_ENTER( mp4_box_data_padb_t );
+   MP4_READBOX_ENTER( mp4_box_data_padb_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_padb );
+   MP4_GETVERSIONFLAGS( p_box->data.p_padb );
 
-    MP4_GET4BYTES( p_box->data.p_padb->sample_count );
-    count = (p_box->data.p_padb->sample_count + 1) / 2;
+   MP4_GET4BYTES( p_box->data.p_padb->sample_count );
+   count = (p_box->data.p_padb->sample_count + 1) / 2;
 
-    p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
-    p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
-    if( p_box->data.p_padb->reserved1 == NULL
-            || p_box->data.p_padb->pad2 == NULL
-            || p_box->data.p_padb->reserved2 == NULL
-            || p_box->data.p_padb->pad1 == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_padb->reserved1 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->reserved2 = calloc( count, sizeof(uint16_t) );
+   p_box->data.p_padb->pad1 = calloc( count, sizeof(uint16_t) );
+   if( p_box->data.p_padb->reserved1 == NULL
+      || p_box->data.p_padb->pad2 == NULL
+      || p_box->data.p_padb->reserved2 == NULL
+      || p_box->data.p_padb->pad1 == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
-    for( i = 0; i < i_read / 2 ; i++ )
-    {
-        if( i >= count )
-        {
-            MP4_READBOX_EXIT( 0 );
-        }
-        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
-        p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
-        p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
-        p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
+   for( i = 0; i < i_read / 2 ; i++ )
+   {
+      if( i >= count )
+      {
+         MP4_READBOX_EXIT( 0 );
+      }
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 7 )&0x01;
+      p_box->data.p_padb->pad2[i] = ( (*p_peek) >> 4 )&0x07;
+      p_box->data.p_padb->reserved1[i] = ( (*p_peek) >> 3 )&0x01;
+      p_box->data.p_padb->pad1[i] = ( (*p_peek) )&0x07;
 
-        p_peek += 1; i_read -= 1;
-    }
+      p_peek += 1; i_read -= 1;
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"stdp\" entry-count %"PRId64,
-            i_read / 2 );
+      i_read / 2 );
 
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_elst( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_elst->segment_duration );
-    FREENULL( p_box->data.p_elst->media_time );
-    FREENULL( p_box->data.p_elst->media_rate_integer );
-    FREENULL( p_box->data.p_elst->media_rate_fraction );
+   FREENULL( p_box->data.p_elst->segment_duration );
+   FREENULL( p_box->data.p_elst->media_time );
+   FREENULL( p_box->data.p_elst->media_rate_integer );
+   FREENULL( p_box->data.p_elst->media_rate_fraction );
 }
 
 static int MP4_ReadBox_elst( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_elst_t );
+   unsigned int i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_elst_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_elst );
+   MP4_GETVERSIONFLAGS( p_box->data.p_elst );
 
 
-    MP4_GET4BYTES( p_box->data.p_elst->entry_count );
+   MP4_GET4BYTES( p_box->data.p_elst->entry_count );
 
-    p_box->data.p_elst->segment_duration =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
-    p_box->data.p_elst->media_time =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
-    p_box->data.p_elst->media_rate_integer =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
-    p_box->data.p_elst->media_rate_fraction =
-        calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
-    if( p_box->data.p_elst->segment_duration == NULL
-            || p_box->data.p_elst->media_time == NULL
-            || p_box->data.p_elst->media_rate_integer == NULL
-            || p_box->data.p_elst->media_rate_fraction == NULL )
-    {
-        MP4_READBOX_EXIT( 0 );
-    }
+   p_box->data.p_elst->segment_duration =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_time =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint64_t) );
+   p_box->data.p_elst->media_rate_integer =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   p_box->data.p_elst->media_rate_fraction =
+      calloc( p_box->data.p_elst->entry_count, sizeof(uint16_t) );
+   if( p_box->data.p_elst->segment_duration == NULL
+      || p_box->data.p_elst->media_time == NULL
+      || p_box->data.p_elst->media_rate_integer == NULL
+      || p_box->data.p_elst->media_rate_fraction == NULL )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
 
 
-    for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
-    {
-        if( p_box->data.p_elst->version == 1 )
-        {
+   for( i = 0; i < p_box->data.p_elst->entry_count; i++ )
+   {
+      if( p_box->data.p_elst->version == 1 )
+      {
 
-            MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
+         MP4_GET8BYTES( p_box->data.p_elst->segment_duration[i] );
 
-            MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
-        }
-        else
-        {
+         MP4_GET8BYTES( p_box->data.p_elst->media_time[i] );
+      }
+      else
+      {
 
-            MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
+         MP4_GET4BYTES( p_box->data.p_elst->segment_duration[i] );
 
-            MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
-            p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
-        }
+         MP4_GET4BYTES( p_box->data.p_elst->media_time[i] );
+         p_box->data.p_elst->media_time[i] = (int32_t)p_box->data.p_elst->media_time[i];
+      }
 
-        MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
-        MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
-    }
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_integer[i] );
+      MP4_GET2BYTES( p_box->data.p_elst->media_rate_fraction[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"elst\" entry-count %lu",
-            (unsigned long)p_box->data.p_elst->entry_count );
+      (unsigned long)p_box->data.p_elst->entry_count );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i_language;
-    unsigned int i = 0;
+   unsigned int i_language;
+   unsigned int i = 0;
 
-    MP4_READBOX_ENTER( mp4_box_data_cprt_t );
+   MP4_READBOX_ENTER( mp4_box_data_cprt_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
+   MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
 
-    i_language = SwapBE16( p_peek );
-    for( i = 0; i < 3; i++ )
-    {
-        p_box->data.p_cprt->language[i] =
-            ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
-    }
-    p_peek += 2; i_read -= 2;
-    MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
+   i_language = SwapBE16( p_peek );
+   for( i = 0; i < 3; i++ )
+   {
+      p_box->data.p_cprt->language[i] =
+         ( ( i_language >> ( (2-i)*5 ) )&0x1f ) + 0x60;
+   }
+   p_peek += 2; i_read -= 2;
+   MP4_GETSTRINGZ( p_box->data.p_cprt->psz_notice );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cprt\" language %c%c%c notice %s",
-            p_box->data.p_cprt->language[0],
-            p_box->data.p_cprt->language[1],
-            p_box->data.p_cprt->language[2],
-            p_box->data.p_cprt->psz_notice );
+      p_box->data.p_cprt->language[0],
+      p_box->data.p_cprt->language[1],
+      p_box->data.p_cprt->language[2],
+      p_box->data.p_cprt->psz_notice );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_cprt( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_cprt->psz_notice );
+   FREENULL( p_box->data.p_cprt->psz_notice );
 }
 
 
 static int MP4_ReadBox_dcom( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_dcom_t );
+   MP4_READBOX_ENTER( mp4_box_data_dcom_t );
 
-    MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
+   MP4_GETFOURCC( p_box->data.p_dcom->algorithm );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"dcom\" compression algorithm : %4.4s",
-            (char*)&p_box->data.p_dcom->algorithm );
+      "read box: \"dcom\" compression algorithm : %4.4s",
+      (char*)&p_box->data.p_dcom->algorithm );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_cmvd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
+   MP4_READBOX_ENTER( mp4_box_data_cmvd_t );
 
-    MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
+   MP4_GET4BYTES( p_box->data.p_cmvd->uncompressed_size );
 
-    p_box->data.p_cmvd->compressed_size = i_read;
+   p_box->data.p_cmvd->compressed_size = i_read;
 
-    if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
-        MP4_READBOX_EXIT( 0 );
+   if( !( p_box->data.p_cmvd->data = malloc( i_read ) ) )
+      MP4_READBOX_EXIT( 0 );
 
-    /* now copy compressed data */
-    memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
+   /* now copy compressed data */
+   memcpy( p_box->data.p_cmvd->data, p_peek,i_read);
 
-    p_box->data.p_cmvd->b_compressed = 1;
+   p_box->data.p_cmvd->b_compressed = 1;
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cmvd\" compressed data size %d",
-            p_box->data.p_cmvd->compressed_size );
+      p_box->data.p_cmvd->compressed_size );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 static void MP4_FreeBox_cmvd( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_cmvd->data );
+   FREENULL( p_box->data.p_cmvd->data );
 }
 
 
 static int MP4_ReadBox_cmov( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t *p_dcom;
-    mp4_box_t *p_cmvd;
+   mp4_box_t *p_dcom;
+   mp4_box_t *p_cmvd;
 
 #ifdef HAVE_ZLIB_H
-    stream_t *p_stream_memory;
-    z_stream z_data;
-    uint8_t *p_data;
-    int i_result;
+   stream_t *p_stream_memory;
+   z_stream z_data;
+   uint8_t *p_data;
+   int i_result;
 #endif
 
-    if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
-        return 0;
-
-    if( !p_box->p_father ||
-            ( p_box->p_father->i_type != ATOM_moov &&
-              p_box->p_father->i_type != ATOM_foov ) )
-    {
-        printf( "Read box: \"cmov\" box alone" );
-        return 1;
-    }
-
-    if( !MP4_ReadBoxContainer( p_stream, p_box ) )
-    {
-        return 0;
-    }
-
-    if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
-            ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
-            p_cmvd->data.p_cmvd->data == NULL )
-    {
-        printf( "read box: \"cmov\" incomplete" );
-        return 0;
-    }
-
-    if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
-    {
-        printf( "read box: \"cmov\" compression algorithm : %4.4s "
-                "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
-        return 0;
-    }
+   if( !( p_box->data.p_cmov = calloc(1, sizeof( mp4_box_data_cmov_t ) ) ) )
+      return 0;
+
+   if( !p_box->p_father ||
+      ( p_box->p_father->i_type != ATOM_moov &&
+      p_box->p_father->i_type != ATOM_foov ) )
+   {
+      printf( "Read box: \"cmov\" box alone" );
+      return 1;
+   }
+
+   if( !MP4_ReadBoxContainer( p_stream, p_box ) )
+   {
+      return 0;
+   }
+
+   if( ( p_dcom = MP4_BoxGet( p_box, "dcom" ) ) == NULL ||
+      ( p_cmvd = MP4_BoxGet( p_box, "cmvd" ) ) == NULL ||
+      p_cmvd->data.p_cmvd->data == NULL )
+   {
+      printf( "read box: \"cmov\" incomplete" );
+      return 0;
+   }
+
+   if( p_dcom->data.p_dcom->algorithm != ATOM_zlib )
+   {
+      printf( "read box: \"cmov\" compression algorithm : %4.4s "
+         "not supported", (char*)&p_dcom->data.p_dcom->algorithm );
+      return 0;
+   }
 
 #ifndef HAVE_ZLIB_H
-    printf(  "read box: \"cmov\" zlib unsupported" );
-    return 0;
+   printf(  "read box: \"cmov\" zlib unsupported" );
+   return 0;
 #else
 
-    /* decompress data */
-    /* allocate a new buffer */
-    if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
-        return 0;
-    /* init default structures */
-    z_data.next_in   = p_cmvd->data.p_cmvd->data;
-    z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
-    z_data.next_out  = p_data;
-    z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
-    z_data.zalloc    = (alloc_func)Z_NULL;
-    z_data.zfree     = (free_func)Z_NULL;
-    z_data.opaque    = (voidpf)Z_NULL;
-
-    /* init zlib */
-    if( inflateInit( &z_data ) != Z_OK )
-    {
-        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
-        free( p_data );
-        return 0;
-    }
-
-    /* uncompress */
-    i_result = inflate( &z_data, Z_NO_FLUSH );
-    if( i_result != Z_OK && i_result != Z_STREAM_END )
-    {
-        msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
-        free( p_data );
-        return 0;
-    }
-
-    if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
-    {
-        printf( "read box: \"cmov\" uncompressing data size "
-                "mismatch" );
-    }
-    p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
-
-    /* close zlib */
-    if( inflateEnd( &z_data ) != Z_OK )
-    {
-        printf( "read box: \"cmov\" error while uncompressing "
-                "data (ignored)" );
-    }
-
-    free( p_cmvd->data.p_cmvd->p_data );
-    p_cmvd->data.p_cmvd->data = p_data;
-    p_cmvd->data.p_cmvd->b_compressed = 0;
+   /* decompress data */
+   /* allocate a new buffer */
+   if( !( p_data = malloc( p_cmvd->data.p_cmvd->uncompressed_size ) ) )
+      return 0;
+   /* init default structures */
+   z_data.next_in   = p_cmvd->data.p_cmvd->data;
+   z_data.avail_in  = p_cmvd->data.p_cmvd->compressed_size;
+   z_data.next_out  = p_data;
+   z_data.avail_out = p_cmvd->data.p_cmvd->uncompressed_size;
+   z_data.zalloc    = (alloc_func)Z_NULL;
+   z_data.zfree     = (free_func)Z_NULL;
+   z_data.opaque    = (voidpf)Z_NULL;
+
+   /* init zlib */
+   if( inflateInit( &z_data ) != Z_OK )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   /* uncompress */
+   i_result = inflate( &z_data, Z_NO_FLUSH );
+   if( i_result != Z_OK && i_result != Z_STREAM_END )
+   {
+      msg_Err( p_stream, "read box: \"cmov\" error while uncompressing" );
+      free( p_data );
+      return 0;
+   }
+
+   if( p_cmvd->data.p_cmvd->uncompressed_size != z_data.total_out )
+   {
+      printf( "read box: \"cmov\" uncompressing data size "
+         "mismatch" );
+   }
+   p_cmvd->data.p_cmvd->uncompressed_size = z_data.total_out;
+
+   /* close zlib */
+   if( inflateEnd( &z_data ) != Z_OK )
+   {
+      printf( "read box: \"cmov\" error while uncompressing "
+         "data (ignored)" );
+   }
+
+   free( p_cmvd->data.p_cmvd->p_data );
+   p_cmvd->data.p_cmvd->data = p_data;
+   p_cmvd->data.p_cmvd->b_compressed = 0;
 
     printf( "read box: \"cmov\" box successfully uncompressed" );
 
-    /* now create a memory stream */
-    p_stream_memory =
-        stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
-                p_cmvd->data.p_cmvd->uncompressed_size, true );
+   /* now create a memory stream */
+   p_stream_memory =
+      stream_MemoryNew( VLC_OBJECT(p_stream), p_cmvd->data.p_cmvd->data,
+      p_cmvd->data.p_cmvd->uncompressed_size, true );
 
-    /* and read uncompressd moov */
-    p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
+   /* and read uncompressd moov */
+   p_box->data.p_cmov->moov = MP4_ReadBox( p_stream_memory, NULL );
 
-    stream_Delete( p_stream_memory );
+   stream_Delete( p_stream_memory );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"cmov\" compressed movie header completed");
 #endif
 
-    return p_box->data.p_cmov->moov ? 1 : 0;
+   return p_box->data.p_cmov->moov ? 1 : 0;
 #endif /* HAVE_ZLIB_H */
 }
 
 static int MP4_ReadBox_rdrf( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_len;
-    unsigned i = 0;
-    MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
+   uint32_t i_len;
+   unsigned i = 0;
+   MP4_READBOX_ENTER( mp4_box_data_rdrf_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
-    MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
-    MP4_GET4BYTES( i_len );
-    i_len++;
+   MP4_GETVERSIONFLAGS( p_box->data.p_rdrf );
+   MP4_GETFOURCC( p_box->data.p_rdrf->ref_type );
+   MP4_GET4BYTES( i_len );
+   i_len++;
 
-    if( i_len > 0 )
-    {
-        p_box->data.p_rdrf->psz_ref = malloc( i_len );
-        if( p_box->data.p_rdrf->psz_ref == NULL )
-            MP4_READBOX_EXIT( 0 );
-        i_len--;
+   if( i_len > 0 )
+   {
+      p_box->data.p_rdrf->psz_ref = malloc( i_len );
+      if( p_box->data.p_rdrf->psz_ref == NULL )
+         MP4_READBOX_EXIT( 0 );
+      i_len--;
 
-        for( i = 0; i < i_len; i++ )
-        {
-            MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
-        }
-        p_box->data.p_rdrf->psz_ref[i_len] = '\0';
-    }
-    else
-    {
-        p_box->data.p_rdrf->psz_ref = NULL;
-    }
+      for( i = 0; i < i_len; i++ )
+      {
+         MP4_GET1BYTE( p_box->data.p_rdrf->psz_ref[i] );
+      }
+      p_box->data.p_rdrf->psz_ref[i_len] = '\0';
+   }
+   else
+   {
+      p_box->data.p_rdrf->psz_ref = NULL;
+   }
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rdrf\" type:%4.4s ref %s",
-            (char*)&p_box->data.p_rdrf->ref_type,
-            p_box->data.p_rdrf->psz_ref );
+      "read box: \"rdrf\" type:%4.4s ref %s",
+      (char*)&p_box->data.p_rdrf->ref_type,
+      p_box->data.p_rdrf->psz_ref );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_rdrf( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_rdrf->psz_ref );
+   FREENULL( p_box->data.p_rdrf->psz_ref );
 }
 
 
 static int MP4_ReadBox_rmdr( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
+   MP4_READBOX_ENTER( mp4_box_data_rmdr_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmdr );
 
-    MP4_GET4BYTES( p_box->data.p_rmdr->rate );
+   MP4_GET4BYTES( p_box->data.p_rmdr->rate );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmdr\" rate:%d",
-            p_box->data.p_rmdr->rate );
+      "read box: \"rmdr\" rate:%d",
+      p_box->data.p_rmdr->rate );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_rmqu( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
+   MP4_READBOX_ENTER( mp4_box_data_rmqu_t );
 
-    MP4_GET4BYTES( p_box->data.p_rmqu->quality );
+   MP4_GET4BYTES( p_box->data.p_rmqu->quality );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmqu\" quality:%d",
-            p_box->data.p_rmqu->quality );
+      "read box: \"rmqu\" quality:%d",
+      p_box->data.p_rmqu->quality );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_rmvc( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
+   MP4_READBOX_ENTER( mp4_box_data_rmvc_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_rmvc );
 
-    MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
-    MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
-    MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
-    MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
+   MP4_GETFOURCC( p_box->data.p_rmvc->gestaltType );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val1 );
+   MP4_GET4BYTES( p_box->data.p_rmvc->val2 );
+   MP4_GET2BYTES( p_box->data.p_rmvc->checkType );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
-            (char*)&p_box->data.p_rmvc->gestaltType,
-            p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
-            p_box->data.p_rmvc->checkType );
+      "read box: \"rmvc\" gestaltType:%4.4s val1:0x%x val2:0x%x checkType:0x%x",
+      (char*)&p_box->data.p_rmvc->gestaltType,
+      p_box->data.p_rmvc->val1,p_box->data.p_rmvc->val2,
+      p_box->data.p_rmvc->checkType );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_frma( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_frma_t );
+   MP4_READBOX_ENTER( mp4_box_data_frma_t );
 
-    MP4_GETFOURCC( p_box->data.p_frma->type );
+   MP4_GETFOURCC( p_box->data.p_frma->type );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"frma\" i_type:%4.4s",
-            (char *)&p_box->data.p_frma->i_type );
+      (char *)&p_box->data.p_frma->i_type );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_skcr( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_skcr_t );
+   MP4_READBOX_ENTER( mp4_box_data_skcr_t );
 
-    MP4_GET4BYTES( p_box->data.p_skcr->init );
-    MP4_GET4BYTES( p_box->data.p_skcr->encr );
-    MP4_GET4BYTES( p_box->data.p_skcr->decr );
+   MP4_GET4BYTES( p_box->data.p_skcr->init );
+   MP4_GET4BYTES( p_box->data.p_skcr->encr );
+   MP4_GET4BYTES( p_box->data.p_skcr->decr );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"skcr\" i_init:%d i_encr:%d i_decr:%d",
-            p_box->data.p_skcr->init,
-            p_box->data.p_skcr->encr,
-            p_box->data.p_skcr->decr );
+      p_box->data.p_skcr->init,
+      p_box->data.p_skcr->encr,
+      p_box->data.p_skcr->decr );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_drms( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_t *p_drms_box = p_box;
-    void *p_drms = NULL;
+   mp4_box_t *p_drms_box = p_box;
+   void *p_drms = NULL;
 
-    MP4_READBOX_ENTER( uint8_t );
+   MP4_READBOX_ENTER( uint8_t );
 
-    do
-    {
-        p_drms_box = p_drms_box->p_father;
-    } while( p_drms_box && p_drms_box->i_type != ATOM_drms
-            && p_drms_box->i_type != ATOM_drmi );
+   do
+   {
+      p_drms_box = p_drms_box->p_father;
+   } while( p_drms_box && p_drms_box->i_type != ATOM_drms
+      && p_drms_box->i_type != ATOM_drmi );
 
-    if( p_drms_box && p_drms_box->i_type == ATOM_drms )
-        p_drms = p_drms_box->data.p_sample_soun->drms;
-    else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
-        p_drms = p_drms_box->data.p_sample_vide->drms;
-
-    if( p_drms_box && p_drms )
-    {
-        int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
-        if( i_ret )
-        {
-            assert(0);
-            //             const char *psz_error;
-            // 
-            //             switch( i_ret )
-            //             {
-            //                 case -1: psz_error = "unimplemented"; break;
-            //                 case -2: psz_error = "invalid argument"; break;
-            //                 case -3: psz_error = "could not get system key"; break;
-            //                 case -4: psz_error = "could not get SCI data"; break;
-            //                 case -5: psz_error = "no user key found in SCI data"; break;
-            //                 case -6: psz_error = "invalid user key"; break;
-            //                 default: psz_error = "unknown error"; break;
-            //             }
-            //             if MP4_BOX_TYPE_ASCII()
-            //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
-            //                         (char *)&p_box->i_type, psz_error );
-            //             else
-            //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
-            //                         (char *)&p_box->i_type+1, psz_error );
-            // 
-            //             drms_free( p_drms );
-            // 
-            //             if( p_drms_box->i_type == ATOM_drms )
-            //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
-            //             else if( p_drms_box->i_type == ATOM_drmi )
-            //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
-        }
-    }
+   if( p_drms_box && p_drms_box->i_type == ATOM_drms )
+      p_drms = p_drms_box->data.p_sample_soun->drms;
+   else if( p_drms_box && p_drms_box->i_type == ATOM_drmi )
+      p_drms = p_drms_box->data.p_sample_vide->drms;
 
-    MP4_READBOX_EXIT( 1 );
+   if( p_drms_box && p_drms )
+   {
+      int i_ret = drms_init( p_drms, p_box->i_type, p_peek, i_read );
+      if( i_ret )
+      {
+         assert(0);
+         //             const char *psz_error;
+         // 
+         //             switch( i_ret )
+         //             {
+         //                 case -1: psz_error = "unimplemented"; break;
+         //                 case -2: psz_error = "invalid argument"; break;
+         //                 case -3: psz_error = "could not get system key"; break;
+         //                 case -4: psz_error = "could not get SCI data"; break;
+         //                 case -5: psz_error = "no user key found in SCI data"; break;
+         //                 case -6: psz_error = "invalid user key"; break;
+         //                 default: psz_error = "unknown error"; break;
+         //             }
+         //             if MP4_BOX_TYPE_ASCII()
+         //                 msg_Err( p_stream, "drms_init(%4.4s) failed (%s)",
+         //                         (char *)&p_box->i_type, psz_error );
+         //             else
+         //                 msg_Err( p_stream, "drms_init(c%3.3s) failed (%s)",
+         //                         (char *)&p_box->i_type+1, psz_error );
+         // 
+         //             drms_free( p_drms );
+         // 
+         //             if( p_drms_box->i_type == ATOM_drms )
+         //                 p_drms_box->data.p_sample_soun->p_drms = NULL;
+         //             else if( p_drms_box->i_type == ATOM_drmi )
+         //                 p_drms_box->data.p_sample_vide->p_drms = NULL;
+      }
+   }
+
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_name( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_name_t );
+   MP4_READBOX_ENTER( mp4_box_data_name_t );
 
-    p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
-    if( p_box->data.p_name->psz_text == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_name->psz_text = malloc( p_box->i_size + 1 - 8 ); /* +\0, -name, -size */
+   if( p_box->data.p_name->psz_text == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
-    p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
+   memcpy( p_box->data.p_name->psz_text, p_peek, p_box->i_size - 8 );
+   p_box->data.p_name->psz_text[p_box->i_size - 8] = '\0';
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"name\" text=`%s'",
-            p_box->data.p_name->psz_text );
+      p_box->data.p_name->psz_text );
 #endif
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_name( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_name->psz_text );
+   FREENULL( p_box->data.p_name->psz_text );
 }
 
 static int MP4_ReadBox_0xa9xxx( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint16_t i16;
+   uint16_t i16;
 
-    MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
+   MP4_READBOX_ENTER( mp4_box_data_0xa9xxx_t );
 
-    p_box->data.p_0xa9xxx->psz_text = NULL;
+   p_box->data.p_0xa9xxx->psz_text = NULL;
 
-    MP4_GET2BYTES( i16 );
+   MP4_GET2BYTES( i16 );
 
-    if( i16 > 0 )
-    {
-        int i_length = i16;
+   if( i16 > 0 )
+   {
+      int i_length = i16;
 
-        MP4_GET2BYTES( i16 );
-        if( i_length >= i_read ) i_length = i_read + 1;
+      MP4_GET2BYTES( i16 );
+      if( i_length >= i_read ) i_length = i_read + 1;
 
-        p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
-        if( p_box->data.p_0xa9xxx->psz_text == NULL )
-            MP4_READBOX_EXIT( 0 );
+      p_box->data.p_0xa9xxx->psz_text = malloc( i_length );
+      if( p_box->data.p_0xa9xxx->psz_text == NULL )
+         MP4_READBOX_EXIT( 0 );
 
-        i_length--;
-        memcpy( p_box->data.p_0xa9xxx->psz_text,
-                p_peek, i_length );
-        p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
+      i_length--;
+      memcpy( p_box->data.p_0xa9xxx->psz_text,
+         p_peek, i_length );
+      p_box->data.p_0xa9xxx->psz_text[i_length] = '\0';
 
 #ifdef MP4_VERBOSE
-        printf(
-                "read box: \"c%3.3s\" text=`%s'",
-                ((char*)&p_box->i_type + 1),
-                p_box->data.p_0xa9xxx->psz_text );
+       printf(
+         "read box: \"c%3.3s\" text=`%s'",
+         ((char*)&p_box->i_type + 1),
+         p_box->data.p_0xa9xxx->psz_text );
 #endif
-    }
-    else
-    {
-        uint32_t i_data_len;
-        uint32_t i_data_tag;
-        /* try iTune/Quicktime format, rewind to start */
-        p_peek -= 2; i_read += 2;
-        // we are expecting a 'data' box
-
-        MP4_GET4BYTES( i_data_len );
-        if( i_data_len > i_read ) i_data_len = i_read;
-        MP4_GETFOURCC( i_data_tag );
-        if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
-        {
-            /* data box contains a version/flags field */
-            uint32_t i_version;
-            uint32_t i_reserved;
-            MP4_GET4BYTES( i_version );
-            MP4_GET4BYTES( i_reserved );
-            // version should be 0, flags should be 1 for text, 0 for data
-            if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
-            {
-                // the rest is the text
-                i_data_len -= 12;
-                p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
-                if( p_box->data.p_0xa9xxx->psz_text == NULL )
-                    MP4_READBOX_EXIT( 0 );
-
-                memcpy( p_box->data.p_0xa9xxx->psz_text,
-                        p_peek, i_data_len );
-                p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
+   }
+   else
+   {
+      uint32_t i_data_len;
+      uint32_t i_data_tag;
+      /* try iTune/Quicktime format, rewind to start */
+      p_peek -= 2; i_read += 2;
+      // we are expecting a 'data' box
+
+      MP4_GET4BYTES( i_data_len );
+      if( i_data_len > i_read ) i_data_len = i_read;
+      MP4_GETFOURCC( i_data_tag );
+      if( (i_data_len > 0) && (i_data_tag == ATOM_data) )
+      {
+         /* data box contains a version/flags field */
+         uint32_t i_version;
+         uint32_t i_reserved;
+         MP4_GET4BYTES( i_version );
+         MP4_GET4BYTES( i_reserved );
+         // version should be 0, flags should be 1 for text, 0 for data
+         if( ( i_version == 0x00000001 ) && (i_data_len >= 12 ) )
+         {
+            // the rest is the text
+            i_data_len -= 12;
+            p_box->data.p_0xa9xxx->psz_text = malloc( i_data_len + 1 );
+            if( p_box->data.p_0xa9xxx->psz_text == NULL )
+               MP4_READBOX_EXIT( 0 );
+
+            memcpy( p_box->data.p_0xa9xxx->psz_text,
+               p_peek, i_data_len );
+            p_box->data.p_0xa9xxx->psz_text[i_data_len] = '\0';
 #ifdef MP4_VERBOSE
-                printf(
-                        "read box: \"c%3.3s\" text=`%s'",
-                        ((char*)&p_box->i_type+1),
-                        p_box->data.p_0xa9xxx->psz_text );
+             printf(
+               "read box: \"c%3.3s\" text=`%s'",
+               ((char*)&p_box->i_type+1),
+               p_box->data.p_0xa9xxx->psz_text );
 #endif
-            }
-            else
-            {
-                // TODO: handle data values for ID3 tag values, track num or cover art,etc...
-            }
-        }
-    }
+         }
+         else
+         {
+            // TODO: handle data values for ID3 tag values, track num or cover art,etc...
+         }
+      }
+   }
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 static void MP4_FreeBox_0xa9xxx( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_0xa9xxx->psz_text );
+   FREENULL( p_box->data.p_0xa9xxx->psz_text );
 }
 
 /* Chapter support */
 static void MP4_FreeBox_chpl( mp4_box_t *p_box )
 {
-    mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
-    unsigned int i;
-    for(  i = 0; i < p_chpl->chapter; i++ )
-        free( p_chpl->p_chapter[i].psz_name );
+   mp4_box_data_chpl_t *p_chpl = p_box->data.p_chpl;
+   unsigned int i;
+   for(  i = 0; i < p_chpl->chapter; i++ )
+      free( p_chpl->p_chapter[i].psz_name );
 }
 
 static int MP4_ReadBox_chpl( stream_t *p_stream, mp4_box_t *p_box )
 {
-    mp4_box_data_chpl_t *p_chpl;
-    uint32_t i_dummy;
-    int i;
-    MP4_READBOX_ENTER( mp4_box_data_chpl_t );
+   mp4_box_data_chpl_t *p_chpl;
+   uint32_t i_dummy;
+   int i;
+   MP4_READBOX_ENTER( mp4_box_data_chpl_t );
 
-    p_chpl = p_box->data.p_chpl;
+   p_chpl = p_box->data.p_chpl;
 
-    MP4_GETVERSIONFLAGS( p_chpl );
+   MP4_GETVERSIONFLAGS( p_chpl );
 
-    MP4_GET4BYTES( i_dummy );
+   MP4_GET4BYTES( i_dummy );
 
-    MP4_GET1BYTE( p_chpl->chapter );
+   MP4_GET1BYTE( p_chpl->chapter );
 
-    for( i = 0; i < p_chpl->chapter; i++ )
-    {
-        uint64_t i_start;
-        uint8_t i_len;
-        int i_copy;
-        MP4_GET8BYTES( i_start );
-        MP4_GET1BYTE( i_len );
-
-        p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
-        if( !p_chpl->p_chapter[i].psz_name )
-            MP4_READBOX_EXIT( 0 );
+   for( i = 0; i < p_chpl->chapter; i++ )
+   {
+      uint64_t i_start;
+      uint8_t i_len;
+      int i_copy;
+      MP4_GET8BYTES( i_start );
+      MP4_GET1BYTE( i_len );
 
-        i_copy = min( i_len, i_read );
-        if( i_copy > 0 )
-            memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
-        p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
-        p_chpl->p_chapter[i].start = i_start;
+      p_chpl->p_chapter[i].psz_name = malloc( i_len + 1 );
+      if( !p_chpl->p_chapter[i].psz_name )
+         MP4_READBOX_EXIT( 0 );
 
-        p_peek += i_copy;
-        i_read -= i_copy;
-    }
-    /* Bubble sort by increasing start date */
-    do
-    {
-        for( i = 0; i < p_chpl->chapter - 1; i++ )
-        {
-            if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
-            {
-                char *psz = p_chpl->p_chapter[i+1].psz_name;
-                int64_t i64 = p_chpl->p_chapter[i+1].start;
+      i_copy = min( i_len, i_read );
+      if( i_copy > 0 )
+         memcpy( p_chpl->p_chapter[i].psz_name, p_peek, i_copy );
+      p_chpl->p_chapter[i].psz_name[i_copy] = '\0';
+      p_chpl->p_chapter[i].start = i_start;
 
-                p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
-                p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
+      p_peek += i_copy;
+      i_read -= i_copy;
+   }
+   /* Bubble sort by increasing start date */
+   do
+   {
+      for( i = 0; i < p_chpl->chapter - 1; i++ )
+      {
+         if( p_chpl->p_chapter[i].start > p_chpl->p_chapter[i+1].start )
+         {
+            char *psz = p_chpl->p_chapter[i+1].psz_name;
+            int64_t i64 = p_chpl->p_chapter[i+1].start;
 
-                p_chpl->p_chapter[i].psz_name = psz;
-                p_chpl->p_chapter[i].start = i64;
+            p_chpl->p_chapter[i+1].psz_name = p_chpl->p_chapter[i].psz_name;
+            p_chpl->p_chapter[i+1].start = p_chpl->p_chapter[i].start;
 
-                i = -1;
-                break;
-            }
-        }
-    } while( i == -1 );
+            p_chpl->p_chapter[i].psz_name = psz;
+            p_chpl->p_chapter[i].start = i64;
+
+            i = -1;
+            break;
+         }
+      }
+   } while( i == -1 );
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"chpl\" %d chapters",
-            p_chpl->chapter );
+      p_chpl->chapter );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tref_generic( stream_t *p_stream, mp4_box_t *p_box )
 {
-    unsigned int i;
-    MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
+   unsigned int i;
+   MP4_READBOX_ENTER( mp4_box_data_tref_generic_t );
 
-    p_box->data.p_tref_generic->track_ID = NULL;
-    p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
-    if( p_box->data.p_tref_generic->entry_count > 0 )
-        p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
-    if( p_box->data.p_tref_generic->track_ID == NULL )
-        MP4_READBOX_EXIT( 0 );
+   p_box->data.p_tref_generic->track_ID = NULL;
+   p_box->data.p_tref_generic->entry_count = i_read / sizeof(uint32_t);
+   if( p_box->data.p_tref_generic->entry_count > 0 )
+      p_box->data.p_tref_generic->track_ID = calloc( p_box->data.p_tref_generic->entry_count, sizeof(uint32_t) );
+   if( p_box->data.p_tref_generic->track_ID == NULL )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
-    {
-        MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
-    }
+   for( i = 0; i < p_box->data.p_tref_generic->entry_count; i++ )
+   {
+      MP4_GET4BYTES( p_box->data.p_tref_generic->track_ID[i] );
+   }
 
 #ifdef MP4_VERBOSE
     printf( "read box: \"chap\" %d references",
-            p_box->data.p_tref_generic->entry_count );
+      p_box->data.p_tref_generic->entry_count );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_tref_generic( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_tref_generic->track_ID );
+   FREENULL( p_box->data.p_tref_generic->track_ID );
 }
 
 static int MP4_ReadBox_meta( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint8_t meta_data[8];
-    int i_actually_read;
+   uint8_t meta_data[8];
+   int i_actually_read;
 
-    // skip over box header
-    i_actually_read = stream_read( p_stream, meta_data, 8 );
-    if( i_actually_read < 8 )
-        return 0;
+   // skip over box header
+   i_actually_read = stream_read( p_stream, meta_data, 8 );
+   if( i_actually_read < 8 )
+      return 0;
 
-    /* meta content starts with a 4 byte version/flags value (should be 0) */
-    i_actually_read = stream_read( p_stream, meta_data, 4 );
-    if( i_actually_read < 4 )
-        return 0;
+   /* meta content starts with a 4 byte version/flags value (should be 0) */
+   i_actually_read = stream_read( p_stream, meta_data, 4 );
+   if( i_actually_read < 4 )
+      return 0;
 
-    /* then it behaves like a container */
-    return MP4_ReadBoxContainerRaw( p_stream, p_box );
+   /* then it behaves like a container */
+   return MP4_ReadBoxContainerRaw( p_stream, p_box );
 }
 
 static int MP4_ReadBox_iods( stream_t *p_stream, mp4_box_t *p_box )
 {
-    char i_unused;
+   char i_unused;
 
-    MP4_READBOX_ENTER( mp4_box_data_iods_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_iods );
+   MP4_READBOX_ENTER( mp4_box_data_iods_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_iods );
 
-    MP4_GET1BYTE( i_unused ); /* tag */
-    MP4_GET1BYTE( i_unused ); /* length */
+   MP4_GET1BYTE( i_unused ); /* tag */
+   MP4_GET1BYTE( i_unused ); /* length */
 
-    MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
-                                                               are used for other flags */
-    MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
-    MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
+   MP4_GET2BYTES( p_box->data.p_iods->object_descriptor ); /* 10bits, 6 other bits
+                                                           are used for other flags */
+   MP4_GET1BYTE( p_box->data.p_iods->OD_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->scene_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->audio_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->visual_profile_level );
+   MP4_GET1BYTE( p_box->data.p_iods->graphics_profile_level );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
-            "visual: %i, graphics: %i",
-            p_box->data.p_iods->object_descriptor >> 6,
-            p_box->data.p_iods->OD_profile_level,
-            p_box->data.p_iods->scene_profile_level,
-            p_box->data.p_iods->audio_profile_level,
-            p_box->data.p_iods->visual_profile_level,
-            p_box->data.p_iods->graphics_profile_level );
+      "read box: \"iods\" objectDescriptorId: %i, OD: %i, scene: %i, audio: %i, "
+      "visual: %i, graphics: %i",
+      p_box->data.p_iods->object_descriptor >> 6,
+      p_box->data.p_iods->OD_profile_level,
+      p_box->data.p_iods->scene_profile_level,
+      p_box->data.p_iods->audio_profile_level,
+      p_box->data.p_iods->visual_profile_level,
+      p_box->data.p_iods->graphics_profile_level );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_pasp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_pasp_t );
+   MP4_READBOX_ENTER( mp4_box_data_pasp_t );
 
-    MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
-    MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
+   MP4_GET4BYTES( p_box->data.p_pasp->horizontal_spacing );
+   MP4_GET4BYTES( p_box->data.p_pasp->vertical_spacing );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"paps\" %dx%d",
-            p_box->data.p_pasp->horizontal_spacing,
-            p_box->data.p_pasp->vertical_spacing);
+      "read box: \"paps\" %dx%d",
+      p_box->data.p_pasp->horizontal_spacing,
+      p_box->data.p_pasp->vertical_spacing);
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_mehd( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_mehd_t );
+   MP4_READBOX_ENTER( mp4_box_data_mehd_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
-    if( p_box->data.p_mehd->version == 1 )
-        MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
-    else /* version == 0 */
-        MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
+   MP4_GETVERSIONFLAGS( p_box->data.p_mehd );
+   if( p_box->data.p_mehd->version == 1 )
+      MP4_GET8BYTES( p_box->data.p_mehd->fragment_duration );
+   else /* version == 0 */
+      MP4_GET4BYTES( p_box->data.p_mehd->fragment_duration );
 
 #ifdef MP4_VERBOSE
     printf(
-            "read box: \"mehd\" frag dur. %"PRIu64"",
-            p_box->data.p_mehd->fragment_duration );
+      "read box: \"mehd\" frag dur. %"PRIu64"",
+      p_box->data.p_mehd->fragment_duration );
 #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_trex( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_trex_t );
-    MP4_GETVERSIONFLAGS( p_box->data.p_trex );
+   MP4_READBOX_ENTER( mp4_box_data_trex_t );
+   MP4_GETVERSIONFLAGS( p_box->data.p_trex );
 
-    MP4_GET4BYTES( p_box->data.p_trex->track_ID );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
-    MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
+   MP4_GET4BYTES( p_box->data.p_trex->track_ID );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_description_index );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_duration );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_size );
+   MP4_GET4BYTES( p_box->data.p_trex->default_sample_flags );
 
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"trex\" trackID: %"PRIu32"",
-    //              p_box->data.p_trex->track_ID );
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"trex\" trackID: %"PRIu32"",
+   //              p_box->data.p_trex->track_ID );
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_sdtp( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_sample_count;
-    uint32_t i;
-    mp4_box_data_sdtp_t *p_sdtp = NULL;
-    MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
-    p_sdtp = p_box->data.p_sdtp;
-    MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
-    i_sample_count = i_read;
+   uint32_t i_sample_count;
+   uint32_t i;
+   mp4_box_data_sdtp_t *p_sdtp = NULL;
+   MP4_READBOX_ENTER( mp4_box_data_sdtp_t );
+   p_sdtp = p_box->data.p_sdtp;
+   MP4_GETVERSIONFLAGS( p_box->data.p_sdtp );
+   i_sample_count = i_read;
 
-    p_sdtp->sample_table = calloc( i_sample_count, 1 );
+   p_sdtp->sample_table = calloc( i_sample_count, 1 );
 
-    if( !p_sdtp->sample_table )
-        MP4_READBOX_EXIT( 0 );
+   if( !p_sdtp->sample_table )
+      MP4_READBOX_EXIT( 0 );
 
-    for( i = 0; i < i_sample_count; i++ )
-        MP4_GET1BYTE( p_sdtp->sample_table[i] );
+   for( i = 0; i < i_sample_count; i++ )
+      MP4_GET1BYTE( p_sdtp->sample_table[i] );
 
-    // #ifdef MP4_VERBOSE
-    //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
-    //      printf(
-    //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
-    //                  p_sdtp->sample_table[0],
-    //                  p_sdtp->sample_table[1],
-    //                  p_sdtp->sample_table[2],
-    //                  p_sdtp->sample_table[3] );
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //     msg_Info( p_stream, "i_sample_count is %"PRIu32"", i_sample_count );
+   //      printf(
+   //              "read box: \"sdtp\" head: %"PRIx8" %"PRIx8" %"PRIx8" %"PRIx8"",
+   //                  p_sdtp->sample_table[0],
+   //                  p_sdtp->sample_table[1],
+   //                  p_sdtp->sample_table[2],
+   //                  p_sdtp->sample_table[3] );
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static void MP4_FreeBox_sdtp( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_sdtp->sample_table );
+   FREENULL( p_box->data.p_sdtp->sample_table );
 }
 
 static int MP4_ReadBox_mfro( stream_t *p_stream, mp4_box_t *p_box )
 {
-    MP4_READBOX_ENTER( mp4_box_data_mfro_t );
+   MP4_READBOX_ENTER( mp4_box_data_mfro_t );
 
-    MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
-    MP4_GET4BYTES( p_box->data.p_mfro->size );
+   MP4_GETVERSIONFLAGS( p_box->data.p_mfro );
+   MP4_GET4BYTES( p_box->data.p_mfro->size );
 
-    // #ifdef MP4_VERBOSE
-    //      printf(
-    //              "read box: \"mfro\" size: %"PRIu32"",
-    //              p_box->data.p_mfro->i_size);
-    // #endif
+   // #ifdef MP4_VERBOSE
+   //      printf(
+   //              "read box: \"mfro\" size: %"PRIu32"",
+   //              p_box->data.p_mfro->i_size);
+   // #endif
 
-    MP4_READBOX_EXIT( 1 );
+   MP4_READBOX_EXIT( 1 );
 }
 
 static int MP4_ReadBox_tfra( stream_t *p_stream, mp4_box_t *p_box )
 {
-    uint32_t i_number_of_entries;
-    mp4_box_data_tfra_t *p_tfra;
-    uint32_t i_lengths;
-    size_t size;
-    uint32_t i;
-    MP4_READBOX_ENTER( mp4_box_data_tfra_t );
-    p_tfra = p_box->data.p_tfra;
-    MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
-
-    MP4_GET4BYTES( p_tfra->track_ID );
-    i_lengths = 0;
-    MP4_GET4BYTES( i_lengths );
-    MP4_GET4BYTES( p_tfra->number_of_entries );
-    i_number_of_entries = p_tfra->number_of_entries;
-    p_tfra->length_size_of_traf_num = i_lengths >> 4;
-    p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
-    p_tfra->length_size_of_sample_num = i_lengths & 0x03;
-
-    size = 4 + 4*p_tfra->version; /* size in {4, 8} */
-    p_tfra->time = calloc( i_number_of_entries, size );
-    p_tfra->moof_offset = calloc( i_number_of_entries, size );
-
-    size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
-    p_tfra->traf_number = calloc( i_number_of_entries, size );
-    size = 1 + p_tfra->length_size_of_trun_num;
-    p_tfra->trun_number = calloc( i_number_of_entries, size );
-    size = 1 + p_tfra->length_size_of_sample_num;
-    p_tfra->sample_number = calloc( i_number_of_entries, size );
-
-    if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
-            || !p_tfra->trun_number || !p_tfra->sample_number )
-        goto error;
-
-    for( i = 0; i < i_number_of_entries; i++ )
-    {
-        if( p_tfra->version == 1 )
-        {
-            MP4_GET8BYTES( p_tfra->time[i*2] );
-            MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
-        }
-        else
-        {
-            MP4_GET4BYTES( p_tfra->time[i] );
-            MP4_GET4BYTES( p_tfra->moof_offset[i] );
-        }
-        switch (p_tfra->length_size_of_traf_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->traf_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->traf_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->traf_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->traf_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-
-        switch (p_tfra->length_size_of_trun_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->trun_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->trun_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->trun_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->trun_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-
-        switch (p_tfra->length_size_of_sample_num)
-        {
-            case 0:
-                MP4_GET1BYTE( p_tfra->sample_number[i] );
-                break;
-            case 1:
-                MP4_GET2BYTES( p_tfra->sample_number[i*2] );
-                break;
-            case 2:
-                MP4_GET3BYTES( p_tfra->sample_number[i*3] );
-                break;
-            case 3:
-                MP4_GET4BYTES( p_tfra->sample_number[i*4] );
-                break;
-            default:
-                goto error;
-        }
-    }
-
-    // #ifdef MP4_VERBOSE
-    //     if( p_tfra->version == 0 )
-    //     {
-    //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
-    //                          p_tfra->time[0], p_tfra->moof_offset[0] );
-    // 
-    //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
-    //                          p_tfra->time[1], p_tfra->moof_offset[1] );
-    //     }
-    //     else
-    //     {
-    //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
-    //                 ((uint64_t *)(p_tfra->time))[0],
-    //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
-    // 
-    //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
-    //                 ((uint64_t *)(p_tfra->time))[1],
-    //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
-    //     }
-    // 
-    //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
-    //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
-    // #endif
-
-    MP4_READBOX_EXIT( 1 );
+   uint32_t i_number_of_entries;
+   mp4_box_data_tfra_t *p_tfra;
+   uint32_t i_lengths;
+   size_t size;
+   uint32_t i;
+   MP4_READBOX_ENTER( mp4_box_data_tfra_t );
+   p_tfra = p_box->data.p_tfra;
+   MP4_GETVERSIONFLAGS( p_box->data.p_tfra );
+
+   MP4_GET4BYTES( p_tfra->track_ID );
+   i_lengths = 0;
+   MP4_GET4BYTES( i_lengths );
+   MP4_GET4BYTES( p_tfra->number_of_entries );
+   i_number_of_entries = p_tfra->number_of_entries;
+   p_tfra->length_size_of_traf_num = i_lengths >> 4;
+   p_tfra->length_size_of_trun_num = ( i_lengths & 0x0c ) >> 2;
+   p_tfra->length_size_of_sample_num = i_lengths & 0x03;
+
+   size = 4 + 4*p_tfra->version; /* size in {4, 8} */
+   p_tfra->time = calloc( i_number_of_entries, size );
+   p_tfra->moof_offset = calloc( i_number_of_entries, size );
+
+   size = 1 + p_tfra->length_size_of_traf_num; /* size in [|1, 4|] */
+   p_tfra->traf_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_trun_num;
+   p_tfra->trun_number = calloc( i_number_of_entries, size );
+   size = 1 + p_tfra->length_size_of_sample_num;
+   p_tfra->sample_number = calloc( i_number_of_entries, size );
+
+   if( !p_tfra->time || !p_tfra->moof_offset || !p_tfra->traf_number
+      || !p_tfra->trun_number || !p_tfra->sample_number )
+      goto error;
+
+   for( i = 0; i < i_number_of_entries; i++ )
+   {
+      if( p_tfra->version == 1 )
+      {
+         MP4_GET8BYTES( p_tfra->time[i*2] );
+         MP4_GET8BYTES( p_tfra->moof_offset[i*2] );
+      }
+      else
+      {
+         MP4_GET4BYTES( p_tfra->time[i] );
+         MP4_GET4BYTES( p_tfra->moof_offset[i] );
+      }
+      switch (p_tfra->length_size_of_traf_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->traf_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->traf_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->traf_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->traf_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_trun_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->trun_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->trun_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->trun_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->trun_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+
+      switch (p_tfra->length_size_of_sample_num)
+      {
+      case 0:
+         MP4_GET1BYTE( p_tfra->sample_number[i] );
+         break;
+      case 1:
+         MP4_GET2BYTES( p_tfra->sample_number[i*2] );
+         break;
+      case 2:
+         MP4_GET3BYTES( p_tfra->sample_number[i*3] );
+         break;
+      case 3:
+         MP4_GET4BYTES( p_tfra->sample_number[i*4] );
+         break;
+      default:
+         goto error;
+      }
+   }
+
+   // #ifdef MP4_VERBOSE
+   //     if( p_tfra->version == 0 )
+   //     {
+   //          printf( "time[0]: %"PRIu32", moof_offset[0]: %"PRIx32"",
+   //                          p_tfra->time[0], p_tfra->moof_offset[0] );
+   // 
+   //          printf( "time[1]: %"PRIu32", moof_offset[1]: %"PRIx32"",
+   //                          p_tfra->time[1], p_tfra->moof_offset[1] );
+   //     }
+   //     else
+   //     {
+   //          printf( "time[0]: %"PRIu64", moof_offset[0]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[0],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[0] );
+   // 
+   //          printf( "time[1]: %"PRIu64", moof_offset[1]: %"PRIx64"",
+   //                 ((uint64_t *)(p_tfra->time))[1],
+   //                 ((uint64_t *)(p_tfra->moof_offset))[1] );
+   //     }
+   // 
+   //     msg_Info( p_stream, "number_of_entries is %"PRIu32"", number_of_entries );
+   //     msg_Info( p_stream, "track ID is: %"PRIu32"", p_tfra->track_ID );
+   // #endif
+
+   MP4_READBOX_EXIT( 1 );
 error:
-    MP4_READBOX_EXIT( 0 );
+   MP4_READBOX_EXIT( 0 );
 }
 
 static void MP4_FreeBox_tfra( mp4_box_t *p_box )
 {
-    FREENULL( p_box->data.p_tfra->time );
-    FREENULL( p_box->data.p_tfra->moof_offset );
-    FREENULL( p_box->data.p_tfra->traf_number );
-    FREENULL( p_box->data.p_tfra->trun_number );
-    FREENULL( p_box->data.p_tfra->sample_number );
+   FREENULL( p_box->data.p_tfra->time );
+   FREENULL( p_box->data.p_tfra->moof_offset );
+   FREENULL( p_box->data.p_tfra->traf_number );
+   FREENULL( p_box->data.p_tfra->trun_number );
+   FREENULL( p_box->data.p_tfra->sample_number );
 }
 
 
 /* For generic */
 static int MP4_ReadBox_default( stream_t *p_stream, mp4_box_t *p_box )
 {
-    if( !p_box->p_father )
-    {
-        goto unknown;
-    }
-    if( p_box->p_father->i_type == ATOM_stsd )
-    {
-        mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
-        mp4_box_t *p_hdlr;
-
-        if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
-                (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
-        {
-            goto unknown;
-        }
-        switch( p_hdlr->data.p_hdlr->handler_type )
-        {
-            case ATOM_soun:
-                return MP4_ReadBox_sample_soun( p_stream, p_box );
-            case ATOM_vide:
-                return MP4_ReadBox_sample_vide( p_stream, p_box );
-            case ATOM_text:
-                return MP4_ReadBox_sample_text( p_stream, p_box );
-            case ATOM_mmth:
-                return MP4_ReadBox_sample_mmth( p_stream, p_box );
-            case ATOM_tx3g:
-            case ATOM_sbtl:
-                return MP4_ReadBox_sample_tx3g( p_stream, p_box );
-            default:
-                printf(
-                        "unknown handler type in stsd (incompletely loaded1)" );
-                return 1;
-        }
-    }
+   if( !p_box->p_father )
+   {
+      goto unknown;
+   }
+   if( p_box->p_father->i_type == ATOM_stsd )
+   {
+      mp4_box_t *p_mdia = MP4_BoxGet( p_box, "../../../.." );
+      mp4_box_t *p_hdlr;
+
+      if( p_mdia == NULL || p_mdia->i_type != ATOM_mdia ||
+         (p_hdlr = MP4_BoxGet( p_mdia, "hdlr" )) == NULL )
+      {
+         goto unknown;
+      }
+      switch( p_hdlr->data.p_hdlr->handler_type )
+      {
+      case ATOM_soun:
+         return MP4_ReadBox_sample_soun( p_stream, p_box );
+      case ATOM_vide:
+         return MP4_ReadBox_sample_vide( p_stream, p_box );
+      case ATOM_text:
+         return MP4_ReadBox_sample_text( p_stream, p_box );
+      case ATOM_mmth:
+         return MP4_ReadBox_sample_mmth( p_stream, p_box );
+      case ATOM_tx3g:
+      case ATOM_sbtl:
+         return MP4_ReadBox_sample_tx3g( p_stream, p_box );
+      default:
+    	  printf(
+            "unknown handler type in stsd (incompletely loaded1)" );
+         return 1;
+      }
+   }
 
 unknown:
-    if MP4_BOX_TYPE_ASCII()
-        printf(
-                "unknown box type %4.4s (incompletely loaded2)",
-                (char*)&p_box->i_type );
-    else
-        printf(
-                "unknown box type c%3.3s (incompletely loaded3)",
-                (char*)&p_box->i_type+1 );
+   if MP4_BOX_TYPE_ASCII()
+      printf(
+      "unknown box type %4.4s (incompletely loaded2)",
+      (char*)&p_box->i_type );
+   else
+	   printf(
+      "unknown box type c%3.3s (incompletely loaded3)",
+      (char*)&p_box->i_type+1 );
 
-    return 1;
+   return 1;
 }
 
 static const struct
 {
-    uint32_t i_type;
-    int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
-    void (*MP4_FreeBox_function )( mp4_box_t *p_box );
+   uint32_t i_type;
+   int  (*MP4_ReadBox_function )( stream_t *p_stream, mp4_box_t *p_box );
+   void (*MP4_FreeBox_function )( mp4_box_t *p_box );
 } MP4_Box_Function [] =
 {
-    /* Containers */
-    { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-
-    /* specific box */
-    { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
-    { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
-    { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
-    { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
-    { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
-    { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
-    { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
-    { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
-    { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
-    { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
-    { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
-    { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
-    { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
-    { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
-    { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
-    { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
-    { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
-    { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
-    { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
-    { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
-    { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
-    { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
-    { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
-    { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
-    { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
-    { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
-    { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
-    { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
-    { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
-    { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
-    { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
-    { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
-    { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
-    { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
-    { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
-    { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
-    { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
-    { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
-
-    /* Nothing to do with this box */
-    { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-    { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
-
-    /* for codecs */
-    { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-
-    { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
-    { ATOM_mjht,    MP4_ReadBox_default,      NULL },
-
-    { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-    { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
-
-    { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
-
-    /* XXX there is 2 box where we could find this entry stbl and tref*/
-    { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
-    { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
-
-    /* found in tref box */
-    { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
-    { ATOM_ipir,    MP4_ReadBox_default,      NULL },
-    { ATOM_mpod,    MP4_ReadBox_default,      NULL },
-    { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
-
-    /* found in hnti */
-    { ATOM_rtp,     MP4_ReadBox_default,      NULL },
-
-    /* found in rmra */
-    { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
-    { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
-    { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
-    { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
-
-    { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
-    { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
-    { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
-    { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
-
-    /* found in udta */
-    { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-    { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
-
-    { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
-
-    /* iTunes/Quicktime meta info */
-    { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
-    { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
-
-    /* found in smoothstreaming */
-    { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
-    { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
-    { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
-    { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
-    { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
-    { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
-    { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
-    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
-    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
-
-    /* Last entry */
-    { 0,              MP4_ReadBox_default,      NULL }
+   /* Containers */
+   { ATOM_moov,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_trak,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mdia,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_moof,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_minf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_stbl,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_dinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_edts,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_udta,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_nmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_hnti,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_rmda,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_tref,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_gmhd,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_wave,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_ilst,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mvex,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+
+   /* specific box */
+   { ATOM_ftyp,    MP4_ReadBox_ftyp,         MP4_FreeBox_ftyp },
+   { ATOM_mmpu,    MP4_ReadBox_mmpu,         MP4_FreeBox_mmpu },
+   { ATOM_tfdt,    MP4_ReadBox_tfdt,         MP4_FreeBox_Common },
+   { ATOM_cmov,    MP4_ReadBox_cmov,         MP4_FreeBox_Common },
+   { ATOM_mvhd,    MP4_ReadBox_mvhd,         MP4_FreeBox_Common },
+   { ATOM_tkhd,    MP4_ReadBox_tkhd,         MP4_FreeBox_Common },
+   { ATOM_hint,    MP4_ReadBox_hint,         MP4_FreeBox_Common },
+   { ATOM_mdhd,    MP4_ReadBox_mdhd,         MP4_FreeBox_Common },
+   { ATOM_hdlr,    MP4_ReadBox_hdlr,         MP4_FreeBox_hdlr },
+   { ATOM_vmhd,    MP4_ReadBox_vmhd,         MP4_FreeBox_Common },
+   { ATOM_smhd,    MP4_ReadBox_smhd,         MP4_FreeBox_Common },
+   { ATOM_hmhd,    MP4_ReadBox_hmhd,         MP4_FreeBox_Common },
+   { ATOM_url,     MP4_ReadBox_url,          MP4_FreeBox_url },
+   { ATOM_urn,     MP4_ReadBox_urn,          MP4_FreeBox_urn },
+   { ATOM_dref,    MP4_ReadBox_dref,         MP4_FreeBox_Common },
+   { ATOM_stts,    MP4_ReadBox_stts,         MP4_FreeBox_stts },
+   { ATOM_ctts,    MP4_ReadBox_ctts,         MP4_FreeBox_ctts },
+   { ATOM_stsd,    MP4_ReadBox_stsd,         MP4_FreeBox_Common },
+   { ATOM_stsz,    MP4_ReadBox_stsz,         MP4_FreeBox_stsz },
+   { ATOM_stsc,    MP4_ReadBox_stsc,         MP4_FreeBox_stsc },
+   { ATOM_stco,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_co64,    MP4_ReadBox_stco_co64,    MP4_FreeBox_stco_co64 },
+   { ATOM_stss,    MP4_ReadBox_stss,         MP4_FreeBox_stss },
+   { ATOM_stsh,    MP4_ReadBox_stsh,         MP4_FreeBox_stsh },
+   { ATOM_stdp,    MP4_ReadBox_stdp,         MP4_FreeBox_stdp },
+   { ATOM_padb,    MP4_ReadBox_padb,         MP4_FreeBox_padb },
+   { ATOM_elst,    MP4_ReadBox_elst,         MP4_FreeBox_elst },
+   { ATOM_cprt,    MP4_ReadBox_cprt,         MP4_FreeBox_cprt },
+   { ATOM_esds,    MP4_ReadBox_esds,         MP4_FreeBox_esds },
+   { ATOM_dcom,    MP4_ReadBox_dcom,         MP4_FreeBox_Common },
+   { ATOM_cmvd,    MP4_ReadBox_cmvd,         MP4_FreeBox_cmvd },
+   { ATOM_avcC,    MP4_ReadBox_avcC,         MP4_FreeBox_avcC },
+   { ATOM_dac3,    MP4_ReadBox_dac3,         MP4_FreeBox_Common },
+   { ATOM_enda,    MP4_ReadBox_enda,         MP4_FreeBox_Common },
+   { ATOM_gnre,    MP4_ReadBox_gnre,         MP4_FreeBox_Common },
+   { ATOM_trkn,    MP4_ReadBox_trkn,         MP4_FreeBox_Common },
+   { ATOM_iods,    MP4_ReadBox_iods,         MP4_FreeBox_Common },
+   { ATOM_pasp,    MP4_ReadBox_pasp,         MP4_FreeBox_Common },
+
+   /* Nothing to do with this box */
+   { ATOM_mdat,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_skip,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_free,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+   { ATOM_wide,    MP4_ReadBoxSkip,          MP4_FreeBox_Common },
+
+   /* for codecs */
+   { ATOM_soun,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms02,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms11,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ms55,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM__mp3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_mp4a,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_twos,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sowt,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDMC,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_QDM2,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ima4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_IMA4,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_dvi,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_ulaw,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_raw,     MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC3,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_MAC6,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_Qclp,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_samr,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sawb,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_OggS,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_alac,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+
+   { ATOM_drmi,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vide,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp4v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_SVQ3,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_ZyGo,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_DIVX,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_XVID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_s263,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_cvid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IV2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3iv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3IVD,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3ivd,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3VID,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_3vid,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpa,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mjpb,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_qdrw,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_mp2v,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_hdv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mjqt,    MP4_ReadBox_default,      NULL }, /* found in mjpa/b */
+   { ATOM_mjht,    MP4_ReadBox_default,      NULL },
+
+   { ATOM_dvc,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dvp,     MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5n,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_dv5p,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_VP31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_vp31,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_h264,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_jpeg,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_avc1,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_yv12,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+   { ATOM_yuv2,    MP4_ReadBox_sample_vide,  MP4_FreeBox_sample_vide },
+
+   { ATOM_mp4s,    MP4_ReadBox_sample_mp4s,  MP4_FreeBox_Common },
+
+   /* XXX there is 2 box where we could find this entry stbl and tref*/
+   { ATOM_hint,    MP4_ReadBox_default,      MP4_FreeBox_Common },
+   { ATOM_mmth,    MP4_ReadBox_sample_mmth,  MP4_FreeBox_Common },
+
+   /* found in tref box */
+   { ATOM_dpnd,    MP4_ReadBox_default,      NULL },
+   { ATOM_ipir,    MP4_ReadBox_default,      NULL },
+   { ATOM_mpod,    MP4_ReadBox_default,      NULL },
+   { ATOM_chap,    MP4_ReadBox_tref_generic, MP4_FreeBox_tref_generic },
+
+   /* found in hnti */
+   { ATOM_rtp,     MP4_ReadBox_default,      NULL },
+
+   /* found in rmra */
+   { ATOM_rdrf,    MP4_ReadBox_rdrf,         MP4_FreeBox_rdrf   },
+   { ATOM_rmdr,    MP4_ReadBox_rmdr,         MP4_FreeBox_Common },
+   { ATOM_rmqu,    MP4_ReadBox_rmqu,         MP4_FreeBox_Common },
+   { ATOM_rmvc,    MP4_ReadBox_rmvc,         MP4_FreeBox_Common },
+
+   { ATOM_drms,    MP4_ReadBox_sample_soun,  MP4_FreeBox_sample_soun },
+   { ATOM_sinf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_schi,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_user,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_key,     MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_iviv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_priv,    MP4_ReadBox_drms,         MP4_FreeBox_Common },
+   { ATOM_frma,    MP4_ReadBox_frma,         MP4_FreeBox_Common },
+   { ATOM_skcr,    MP4_ReadBox_skcr,         MP4_FreeBox_Common },
+
+   /* found in udta */
+   { ATOM_0xa9nam, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9aut, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cpy, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9swr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9inf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ART, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dir, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9cmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9req, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9day, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9des, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9fmt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prd, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9prf, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9src, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9alb, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dis, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9enc, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9gen, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9trk, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9dsa, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9hst, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9url, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9ope, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9com, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrt, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9too, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9wrn, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mak, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9mod, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9PRD, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9grp, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+   { ATOM_0xa9lyr, MP4_ReadBox_0xa9xxx,      MP4_FreeBox_0xa9xxx },
+
+   { ATOM_chpl,    MP4_ReadBox_chpl,         MP4_FreeBox_chpl },
+
+   /* iTunes/Quicktime meta info */
+   { ATOM_meta,    MP4_ReadBox_meta,         MP4_FreeBox_Common },
+   { ATOM_name,    MP4_ReadBox_name,         MP4_FreeBox_name },
+
+   /* found in smoothstreaming */
+   { ATOM_traf,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfra,    MP4_ReadBoxContainer,     MP4_FreeBox_Common },
+   { ATOM_mfhd,    MP4_ReadBox_mfhd,         MP4_FreeBox_Common },
+   { ATOM_tfhd,    MP4_ReadBox_tfhd,         MP4_FreeBox_Common },
+   { ATOM_trun,    MP4_ReadBox_trun,         MP4_FreeBox_trun },
+   { ATOM_trex,    MP4_ReadBox_trex,         MP4_FreeBox_Common },
+   { ATOM_mehd,    MP4_ReadBox_mehd,         MP4_FreeBox_Common },
+   { ATOM_sdtp,    MP4_ReadBox_sdtp,         MP4_FreeBox_sdtp },
+   { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
+   { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
+
+   /* Last entry */
+   { 0,              MP4_ReadBox_default,      NULL }
 };
 
 
 //get full struct of the mp4,main function
 mp4_box_t *MP4_BoxGetRoot(stream_t * s)
 {
-    mp4_box_t *p_root;
-    stream_t *p_stream;
-    int i_result;
+   mp4_box_t *p_root;
+   stream_t *p_stream;
+   int i_result;
 
-    p_root = malloc( sizeof( mp4_box_t ) );
-    if( p_root == NULL )
-        return NULL;
+   p_root = malloc( sizeof( mp4_box_t ) );
+   if( p_root == NULL )
+      return NULL;
 
-    p_root->i_pos = 0;
-    p_root->i_type = ATOM_root;
-    p_root->i_shortsize = 1;
+   p_root->i_pos = 0;
+   p_root->i_type = ATOM_root;
+   p_root->i_shortsize = 1;
 
-    stream_seek(s, 0, SEEK_END);
-    p_root->i_size = stream_tell(s);
-    stream_seek(s, 0, SEEK_SET);
+   stream_seek(s, 0, SEEK_END);
+   p_root->i_size = stream_tell(s);
+   stream_seek(s, 0, SEEK_SET);
 
-    CreateUUID( &p_root->i_uuid, p_root->i_type );
+   CreateUUID( &p_root->i_uuid, p_root->i_type );
 
-    //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
-    p_root->data.p_data = NULL;
-    p_root->p_father    = NULL;
-    p_root->p_first     = NULL;
-    p_root->p_last      = NULL;
-    p_root->p_next      = NULL;
+   //printf("uuid%s\ntype%d\nsize%d\n",&p_root->i_uuid, p_root->i_type,p_root->i_size);
+   p_root->data.p_data = NULL;
+   p_root->p_father    = NULL;
+   p_root->p_first     = NULL;
+   p_root->p_last      = NULL;
+   p_root->p_next      = NULL;
 
-    p_stream = s;
+   p_stream = s;
 
-    i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
+   i_result = MP4_ReadBoxContainerRaw( p_stream, p_root );
 
-    if( i_result )
-    {
-        mp4_box_t *p_moov;
-        mp4_box_t *p_cmov;
-
-        /* check if there is a cmov, if so replace
-           compressed moov by  uncompressed one */
-        if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
-                    ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
-                ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
-                  ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
-        {
-            /* rename the compressed moov as a box to skip */
-            p_moov->i_type = ATOM_skip;
+   if( i_result )
+   {
+      mp4_box_t *p_moov;
+      mp4_box_t *p_cmov;
 
-            /* get uncompressed p_moov */
-            p_moov = p_cmov->data.p_cmov->moov;
-            p_cmov->data.p_cmov->moov = NULL;
+      /* check if there is a cmov, if so replace
+      compressed moov by  uncompressed one */
+      if( ( ( p_moov = MP4_BoxGet( p_root, "moov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "moov/cmov" ) ) ) ||
+         ( ( p_moov = MP4_BoxGet( p_root, "foov" ) ) &&
+         ( p_cmov = MP4_BoxGet( p_root, "foov/cmov" ) ) ) )
+      {
+         /* rename the compressed moov as a box to skip */
+         p_moov->i_type = ATOM_skip;
 
-            /* make p_root father of this new moov */
-            p_moov->p_father = p_root;
+         /* get uncompressed p_moov */
+         p_moov = p_cmov->data.p_cmov->moov;
+         p_cmov->data.p_cmov->moov = NULL;
 
-            /* insert this new moov box as first child of p_root */
-            p_moov->p_next = p_root->p_first;
-            p_root->p_first = p_moov;
-        }
-    }
+         /* make p_root father of this new moov */
+         p_moov->p_father = p_root;
+
+         /* insert this new moov box as first child of p_root */
+         p_moov->p_next = p_root->p_first;
+         p_root->p_first = p_moov;
+      }
+   }
 
-    return p_root;
+   return p_root;
 }
 
-//after  get full struct of the mp4,you can use this function to get the special box
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 {
-    //mp4_box_t *cur = p_head, *prev = NULL;
-    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
+	//mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+	mp4_box_t *cur = p_head;
 
     while (cur != NULL)
     {
-        if (cur->p_first == NULL)          // 1.
+		if (cur->i_type==ATOM_moov||cur->i_type==ATOM_trak||cur->i_type==ATOM_mdia||cur->i_type==ATOM_moof \
+			||cur->i_type==ATOM_minf||cur->i_type==ATOM_stbl||cur->i_type==ATOM_dinf||cur->i_type==ATOM_edts \
+			||cur->i_type==ATOM_udta||cur->i_type==ATOM_nmhd||cur->i_type==ATOM_hnti||cur->i_type==ATOM_rmra \
+			||cur->i_type==ATOM_rmda||cur->i_type==ATOM_tref||cur->i_type==ATOM_gmhd||cur->i_type==ATOM_wave \
+			||cur->i_type==ATOM_ilst||cur->i_type==ATOM_mvex||cur->i_type==ATOM_stsd||cur->i_type==ATOM_tref \
+			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root)
         {
-            if(cur->i_type == i_type)
-            {
-                return(cur); /**/
-            }
-            cur = cur->p_next;
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type==i_type)
+				return cur;
+        	 // find predecessor
+			else {
+				cur = cur->p_first;
+				return MP4_BoxSearchBox(cur, i_type);
+			}
         }
         else
         {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
+			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
+			if(cur->i_type == i_type)
+				{
+					return(cur); /*Find the box*/
+				}
+            else 
+				if(cur->p_next)
+					cur = cur->p_next;
+				else if(cur->p_father->p_next)
+					cur = cur->p_father->p_next;
+                else if (cur->p_father->p_father) {
+				    if(cur->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_next;
+				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next)
+					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next;
+				    else {
+					    printf("Format not supported!\n");
+					    return NULL;
+				    }
+                }else {
+					printf("Format not supported!\n");
+					return NULL;
+				}
 
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    return(cur); /**/
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    return(cur); /**/
-                }
-                cur = cur->p_next;
-            }
         }
     }
     return(NULL);
 }
-
-void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type)
-{
-    mp4_box_t *cur = p_head, *prev = NULL;
-    //mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    //mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
-
-    while (cur != NULL)
-    {
-        if (cur->p_first == NULL)          // 1.
-        {
-            if(cur->i_type == i_type)
-            {
-
-                //*search_box=cur;
-                free(cur);
-                free(prev);
-                break;
-            }
-            cur = cur->p_next;
-        }
-        else
-        {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
-
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    //*search_box=cur;
-                    free(cur);
-                    free(prev);
-                    break;
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    //*search_box=cur;
-                    free(cur);
-                    free(prev);
-                    break;
-                }
-                cur = cur->p_next;
-            }
-        }
-    }
-
-}
-
-//after  get full struct of the mp4,you can use this function to get the special box
-int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type)
-{
-    //mp4_box_t *cur = p_head, *prev = NULL;
-    mp4_box_t *cur = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    mp4_box_t *prev = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    cur = p_head;
-    prev = NULL;
-
-    while (cur != NULL)
-    {
-        if (cur->p_first == NULL)          // 1.
-        {
-            if(cur->i_type == i_type)
-            {
-                printf("1\n");
-                //return(1); /**/
-                //					return(cur); /**/
-            }
-            cur = cur->p_next;
-        }
-        else
-        {
-            // find predecessor
-            prev = cur->p_first;
-            while (prev->p_next != NULL && prev->p_next != cur)
-                prev = prev->p_next;
-
-            if (prev->p_next == NULL)   // 2.a)
-            {
-                prev->p_next = cur;
-                if(cur->i_type == i_type)
-                {
-                    printf("2\n");
-                    //              		return(2); /**/
-                    //						return(cur); /**/
-                }
-                cur = cur->p_first;
-            }
-            else                       // 2.b)
-            {
-                prev->p_next = NULL;
-                if(cur->i_type == i_type)
-                {
-                    printf("3\n");
-                    //              	return(3); /**/
-                    //						return(cur); /**/
-                }
-                cur = cur->p_next;
-            }
-        }
-    }
-    printf("aa0\n");
-    //    return(0);
-}
 /*****************************************************************************
- * MP4_ReadBox : parse the actual box and the children
- *  XXX : Do not go to the next box
- *****************************************************************************/
+* MP4_ReadBox : parse the actual box and the children
+*  XXX : Do not go to the next box
+*****************************************************************************/
 static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
 {
-    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
-    unsigned int i_index;
-
-    if( p_box == NULL )
-        return NULL;
-
-    if( !MP4_ReadBoxCommon( p_stream, p_box ) )
-    {
-        printf( "cannot read one box" );
-        free( p_box );
-        return NULL;
-    }
-    if( !p_box->i_size )
-    {
-        printf( "found an empty box (null size)" );
-        free( p_box );
-        return NULL;
-    }
-    p_box->p_father = p_father;
-
-    /* Now search function to call */
-    for( i_index = 0; ; i_index++ )
-    {
-        if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
-                ( MP4_Box_Function[i_index].i_type == 0 ) )
-        {
-            break;
-        }
-    }
+   mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
+   unsigned int i_index;
+
+   if( p_box == NULL )
+      return NULL;
+
+   if( !MP4_ReadBoxCommon( p_stream, p_box ) )
+   {
+      printf( "cannot read one box" );
+      free( p_box );
+      return NULL;
+   }
+   if( !p_box->i_size )
+   {
+       printf( "found an empty box (null size)" );
+      free( p_box );
+      return NULL;
+   }
+   p_box->p_father = p_father;
+
+   /* Now search function to call */
+   for( i_index = 0; ; i_index++ )
+   {
+      if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+         ( MP4_Box_Function[i_index].i_type == 0 ) )
+      {
+         break;
+      }
+   }
 
-    if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
-    {
-        MP4_BoxFree( p_stream, p_box );
-        return NULL;
-    }
+   if( !(MP4_Box_Function[i_index].MP4_ReadBox_function)( p_stream, p_box ) )
+   {
+      MP4_BoxFree( p_stream, p_box );
+      return NULL;
+   }
 
-    return p_box;
+   return p_box;
 }
 
 void MP4_BoxFree( stream_t *s, mp4_box_t *p_box )
 {
-    unsigned int i_index;
-    mp4_box_t    *p_child;
+   unsigned int i_index;
+   mp4_box_t    *p_child;
 
-    if( !p_box )
-        return; /* hehe */
+   if( !p_box )
+      return; /* hehe */
 
-    for( p_child = p_box->p_first; p_child != NULL; )
-    {
-        mp4_box_t *p_next;
+   for( p_child = p_box->p_first; p_child != NULL; )
+   {
+      mp4_box_t *p_next;
 
-        p_next = p_child->p_next;
-        MP4_BoxFree( s, p_child );
-        p_child = p_next;
-    }
+      p_next = p_child->p_next;
+      MP4_BoxFree( s, p_child );
+      p_child = p_next;
+   }
 
-    /* Now search function to call */
-    if( p_box->data.p_data )
-    {
-        for( i_index = 0; ; i_index++ )
-        {
-            if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
-                    ( MP4_Box_Function[i_index].i_type == 0 ) )
-            {
-                break;
-            }
-        }
-        if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
-        {
-            /* Should not happen */
-            if MP4_BOX_TYPE_ASCII()
-                printf(
-                        "cannot free box %4.4s, type unknown",
-                        (char*)&p_box->i_type );
-            else
-                printf(
-                        "cannot free box c%3.3s, type unknown",
-                        (char*)&p_box->i_type+1 );
-        }
-        else
-        {
-            MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
-        }
-        free( p_box->data.p_data );
-    }
-    free( p_box );
+   /* Now search function to call */
+   if( p_box->data.p_data )
+   {
+      for( i_index = 0; ; i_index++ )
+      {
+         if( ( MP4_Box_Function[i_index].i_type == p_box->i_type )||
+            ( MP4_Box_Function[i_index].i_type == 0 ) )
+         {
+            break;
+         }
+      }
+      if( MP4_Box_Function[i_index].MP4_FreeBox_function == NULL )
+      {
+         /* Should not happen */
+         if MP4_BOX_TYPE_ASCII()
+		printf(
+            "cannot free box %4.4s, type unknown",
+            (char*)&p_box->i_type );
+         else
+        	 printf(
+            "cannot free box c%3.3s, type unknown",
+            (char*)&p_box->i_type+1 );
+      }
+      else
+      {
+         MP4_Box_Function[i_index].MP4_FreeBox_function( p_box );
+      }
+      free( p_box->data.p_data );
+   }
+   free( p_box );
 }
 
 /*****************************************************************************
- *****************************************************************************
- **
- **  High level methods to acces an MP4 file
- **
- *****************************************************************************
- *****************************************************************************/
+*****************************************************************************
+**
+**  High level methods to acces an MP4 file
+**
+*****************************************************************************
+*****************************************************************************/
 static void get_token( char **ppsz_path, char **ppsz_token, int *pi_number )
 {
-    size_t i_len ;
-    if( !*ppsz_path[0] )
-    {
-        *ppsz_token = NULL;
-        *pi_number = 0;
-        return;
-    }
-    i_len = strcspn( *ppsz_path, "/[" );
-    if( !i_len && **ppsz_path == '/' )
-    {
-        i_len = 1;
-    }
-    *ppsz_token = malloc( i_len + 1 );
-
-    memcpy( *ppsz_token, *ppsz_path, i_len );
-
-    (*ppsz_token)[i_len] = '\0';
-
-    *ppsz_path += i_len;
-
-    if( **ppsz_path == '[' )
-    {
-        (*ppsz_path)++;
-        *pi_number = strtol( *ppsz_path, NULL, 10 );
-        while( **ppsz_path && **ppsz_path != ']' )
-        {
-            (*ppsz_path)++;
-        }
-        if( **ppsz_path == ']' )
-        {
-            (*ppsz_path)++;
-        }
-    }
-    else
-    {
-        *pi_number = 0;
-    }
-    while( **ppsz_path == '/' )
-    {
-        (*ppsz_path)++;
-    }
+   size_t i_len ;
+   if( !*ppsz_path[0] )
+   {
+      *ppsz_token = NULL;
+      *pi_number = 0;
+      return;
+   }
+   i_len = strcspn( *ppsz_path, "/[" );
+   if( !i_len && **ppsz_path == '/' )
+   {
+      i_len = 1;
+   }
+   *ppsz_token = malloc( i_len + 1 );
+
+   memcpy( *ppsz_token, *ppsz_path, i_len );
+
+   (*ppsz_token)[i_len] = '\0';
+
+   *ppsz_path += i_len;
+
+   if( **ppsz_path == '[' )
+   {
+      (*ppsz_path)++;
+      *pi_number = strtol( *ppsz_path, NULL, 10 );
+      while( **ppsz_path && **ppsz_path != ']' )
+      {
+         (*ppsz_path)++;
+      }
+      if( **ppsz_path == ']' )
+      {
+         (*ppsz_path)++;
+      }
+   }
+   else
+   {
+      *pi_number = 0;
+   }
+   while( **ppsz_path == '/' )
+   {
+      (*ppsz_path)++;
+   }
 }
 
 static void MP4_BoxGet_Internal(mp4_box_t **pp_result,
-        mp4_box_t *p_box, const char *psz_fmt, va_list args)
-{
-    char *psz_dup;
-    char *psz_path = malloc(4096);
-    char *psz_token;
-
-    if( !p_box )
-    {
-        *pp_result = NULL;
-        return;
-    }
-
-    if( vsprintf( psz_path, psz_fmt, args ) == -1 )
-        psz_path = NULL;
-
-    if( !psz_path || !psz_path[0] )
-    {
-        free( psz_path );
-        *pp_result = NULL;
-        return;
-    }
-
-    //    fprintf( stderr, "path:'%s'\n", psz_path );
-    psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
-    for( ; ; )
-    {
-        int i_number;
-
-        get_token( &psz_path, &psz_token, &i_number );
-        //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
-        //                 psz_path,psz_token,i_number );
-        if( !psz_token )
-        {
-            free( psz_dup );
-            *pp_result = p_box;
-            return;
-        }
-        else
-            if( !strcmp( psz_token, "/" ) )
+   mp4_box_t *p_box, const char *psz_fmt, va_list args)
+{
+   char *psz_dup;
+   char *psz_path = malloc(4096);
+   char *psz_token;
+
+   if( !p_box )
+   {
+      *pp_result = NULL;
+      return;
+   }
+
+   if( vsprintf( psz_path, psz_fmt, args ) == -1 )
+      psz_path = NULL;
+
+   if( !psz_path || !psz_path[0] )
+   {
+      free( psz_path );
+      *pp_result = NULL;
+      return;
+   }
+
+   //    fprintf( stderr, "path:'%s'\n", psz_path );
+   psz_dup = psz_path; /* keep this pointer, as it need to be unallocated */
+   for( ; ; )
+   {
+      int i_number;
+
+      get_token( &psz_path, &psz_token, &i_number );
+      //        fprintf( stderr, "path:'%s', token:'%s' n:%d\n",
+      //                 psz_path,psz_token,i_number );
+      if( !psz_token )
+      {
+         free( psz_dup );
+         *pp_result = p_box;
+         return;
+      }
+      else
+         if( !strcmp( psz_token, "/" ) )
+         {
+            /* Find root box */
+            while( p_box && p_box->i_type != ATOM_root )
+            {
+               p_box = p_box->p_father;
+            }
+            if( !p_box )
+            {
+               goto error_box;
+            }
+         }
+         else
+            if( !strcmp( psz_token, "." ) )
             {
-                /* Find root box */
-                while( p_box && p_box->i_type != ATOM_root )
-                {
-                    p_box = p_box->p_father;
-                }
-                if( !p_box )
-                {
-                    goto error_box;
-                }
+               /* Do nothing */
             }
             else
-                if( !strcmp( psz_token, "." ) )
-                {
-                    /* Do nothing */
-                }
-                else
-                    if( !strcmp( psz_token, ".." ) )
-                    {
-                        p_box = p_box->p_father;
+               if( !strcmp( psz_token, ".." ) )
+               {
+                  p_box = p_box->p_father;
+                  if( !p_box )
+                  {
+                     goto error_box;
+                  }
+               }
+               else
+                  if( strlen( psz_token ) == 4 )
+                  {
+                     uint32_t i_fourcc;
+                     i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
+                        psz_token[2], psz_token[3] );
+                     p_box = p_box->p_first;
+                     for( ; ; )
+                     {
                         if( !p_box )
                         {
-                            goto error_box;
+                           goto error_box;
                         }
-                    }
-                    else
-                        if( strlen( psz_token ) == 4 )
+                        if( p_box->i_type == i_fourcc )
                         {
-                            uint32_t i_fourcc;
-                            i_fourcc = MP4_FOURCC( psz_token[0], psz_token[1],
-                                    psz_token[2], psz_token[3] );
-                            p_box = p_box->p_first;
-                            for( ; ; )
-                            {
-                                if( !p_box )
-                                {
-                                    goto error_box;
-                                }
-                                if( p_box->i_type == i_fourcc )
-                                {
-                                    if( !i_number )
-                                    {
-                                        break;
-                                    }
-                                    i_number--;
-                                }
-                                p_box = p_box->p_next;
-                            }
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
                         }
-                        else
-                            if( *psz_token == '\0' )
-                            {
-                                p_box = p_box->p_first;
-                                for( ; ; )
-                                {
-                                    if( !p_box )
-                                    {
-                                        goto error_box;
-                                    }
-                                    if( !i_number )
-                                    {
-                                        break;
-                                    }
-                                    i_number--;
-                                    p_box = p_box->p_next;
-                                }
-                            }
-                            else
-                            {
-                                //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
-                                goto error_box;
-                            }
-
-        FREENULL( psz_token );
-    }
+                        p_box = p_box->p_next;
+                     }
+                  }
+                  else
+                     if( *psz_token == '\0' )
+                     {
+                        p_box = p_box->p_first;
+                        for( ; ; )
+                        {
+                           if( !p_box )
+                           {
+                              goto error_box;
+                           }
+                           if( !i_number )
+                           {
+                              break;
+                           }
+                           i_number--;
+                           p_box = p_box->p_next;
+                        }
+                     }
+                     else
+                     {
+                        //            fprintf( stderr, "Argg malformed token \"%s\"",psz_token );
+                        goto error_box;
+                     }
+
+                     FREENULL( psz_token );
+   }
 
-    return;
+   return;
 
 error_box:
-    free( psz_token );
-    free( psz_dup );
-    *pp_result = NULL;
-    return;
+   free( psz_token );
+   free( psz_dup );
+   *pp_result = NULL;
+   return;
 }
 
 mp4_box_t * MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...)
 {
-    va_list args;
-    mp4_box_t *p_result;
+   va_list args;
+   mp4_box_t *p_result;
 
-    va_start( args, psz_fmt );
-    MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
-    va_end( args );
+   va_start( args, psz_fmt );
+   MP4_BoxGet_Internal( &p_result, p_box, psz_fmt, args );
+   va_end( args );
 
-    return( p_result );
+   return( p_result );
 }
 
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 1d045dd..3ce4bf5 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1202,17 +1202,14 @@ typedef struct mp4_box_s
 #ifdef __cplusplus
 extern "C" {
 #endif
-
 mp4_box_t *MP4_BoxGetRoot(stream_t * s);
 void MP4_BoxFree(stream_t * s, mp4_box_t *box);
 static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
 mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
-void  MP4_BoxSearchBox2(mp4_box_t *p_head, mp4_box_t** search_box,uint32_t i_type);
-int MP4_BoxSearchBox3(mp4_box_t *p_head, uint32_t i_type);
-
 #ifdef __cplusplus
 }
 #endif
 
+
 #endif // NET_MMT_MPU_MP4_H_
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
index f512657..571d68b 100644
--- a/net/mmt/mpu/stream.c
+++ b/net/mmt/mpu/stream.c
@@ -1,12 +1,12 @@
 #include <stdio.h>
 #include <stdlib.h>
+#include <malloc.h>
 #include <memory.h>
 #include <assert.h>
 #include "net/mmt/mpu/stream.h"
 
 #define max(a,b) a>b?a:b
 #define min(a,b) a>b?b:a
-
 void* file_open(stream_t *stream_s, const char* filename, int mode)
 {
    FILE* file = NULL;
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index 34e8feb..6d570b4 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -1,8 +1,7 @@
 #ifndef NET_MMT_MPU_STREAM_H_
 #define NET_MMT_MPU_STREAM_H_
 
-#include <stdint.h>
-
+// .
 #ifndef _STDINT_H
 typedef signed char int8_t;
 typedef unsigned char uint8_t;
@@ -10,17 +9,19 @@ typedef short int16_t;
 typedef unsigned short uint16_t;
 typedef int int32_t;
 typedef unsigned uint32_t;
-//typedef long long int64_t;
+typedef long int int64_t;
 typedef unsigned long long uint64_t;
 //typedef unsigned long size_t;
 #endif
 
+// .
 #define MODE_READ             (1)
 #define MODE_WRITE            (2)
 #define MODE_READWRITEFILTER  (3)
 #define MODE_EXISTING         (4)
 #define MODE_CREATE           (8)
 
+// .
 typedef struct stream {
    void* (*open)(struct stream *stream_s, const char* filename, int mode);
    int (*read)(struct stream *stream_s, void* buf, int size);
@@ -32,6 +33,7 @@ typedef struct stream {
    void* opaque;
 } stream_t;
 
+// .
 #define stream_open(s, filename, mode) ((stream_t*)s)->open(((stream_t*)s), filename, mode)
 #define stream_read(s, buf, size) ((stream_t*)s)->read(((stream_t*)s), buf, size)
 #define stream_write(s, buf, size) ((stream_t*)s)->write(((stream_t*)s), buf, size)
@@ -40,6 +42,7 @@ typedef struct stream {
 #define stream_tell(s) ((stream_t*)s)->tell(((stream_t*)s))
 #define stream_close(s) ((stream_t*)s)->close(((stream_t*)s))
 
+// .
 void* file_open(stream_t *stream_s, const char* filename, int mode);
 int file_read(stream_t *stream_s, void* buf, int size);
 int file_write(stream_t *stream_s, void *buf, int size);
@@ -51,15 +54,15 @@ int file_close(stream_t *stream_s);
 #ifdef __cplusplus
 extern "C" {
 #endif
-
+// .
 stream_t* create_file_stream();
 void destory_file_stream(stream_t* stream_s);
-
 #ifdef __cplusplus
 }
 #endif
 
 
+// stream.
 #define READ_BUFFER_SIZE   10485760
 #define WRITE_BUFFER_SIZE  10485760
 
@@ -67,32 +70,38 @@ typedef struct buf_stream {
    stream_t s;
 
    struct read_buf {
-      void* buf;        
-      int64_t bufsize; 
-      int64_t offset; 
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
    } read_buf_s;
 
    struct write_buf {
-      void* buf;     
-      int64_t bufsize;
-      int64_t offset;
+      void* buf;        // .
+      int64_t bufsize;  // .
+      int64_t offset;   // offset.
    } write_buf_s;
 
-   uint64_t offset; 
+   uint64_t offset;     // offset.
 
 } buf_stream_t;
 
+// .
 int buf_file_read(stream_t *stream_s, void* buf, int size);
 int buf_file_write(stream_t *stream_s, void *buf, int size);
 int buf_file_peek(stream_t *stream_s, void* buf, int size);
 uint64_t buf_file_seek(stream_t *stream_s, int64_t offset, int whence);
 int buf_file_close(stream_t *stream_s);
 
+// .
 stream_t* create_buf_file_stream();
 void destory_buf_file_stream(stream_t* stream_s);
 
-#define LIL_ENDIAN_INTERNAL	1234
-#define BIG_ENDIAN_INTERNAL	4321
+// .
+#undef LIL_ENDIAN
+#undef BIG_ENDIAN
+#define LIL_ENDIAN	1234
+#define BIG_ENDIAN	4321
+/* #define BYTEORDER    1234 ? . */
 
 #ifndef BYTEORDER
 #if defined(__hppa__) || \
@@ -100,9 +109,9 @@ void destory_buf_file_stream(stream_t* stream_s);
    (defined(__MIPS__) && defined(__MISPEB__)) || \
    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
    defined(__sparc__)
-#define BYTEORDER	BIG_ENDIAN_INTERNAL
+#define BYTEORDER	BIG_ENDIAN
 #else
-#define BYTEORDER	LIL_ENDIAN_INTERNAL
+#define BYTEORDER	LIL_ENDIAN
 #endif
 #endif /* !BYTEORDER */
 
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 8c7ae7e..e65bf45 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -25,10 +25,24 @@ int main(int argc, char* argv[])
 
     mp4_box_t* box = NULL;
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
-    printf("ftyp: %p\n", box);
+    if (box) {
+        printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
+
+    box = MP4_BoxSearchBox(box, ATOM_moof);
+    if (box) {
+        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
 
-    box = MP4_BoxSearchBox(root, ATOM_moof);
-    printf("moof: %p\n", box);
+    box = MP4_BoxSearchBox(box, ATOM_mdat);
+    if (box) {
+        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
+
+    box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
+    if (box) {
+        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }
 
     MP4_BoxFree(s, root);
 
-- 
1.7.9.5


From c6e01c1e02463b95cde82b850627a27ca18b1068 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 23 Jan 2015 18:38:12 -0800
Subject: [PATCH 046/128] add tool curfile

---
 net/mmt/mpu/cutfile.c |   29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 net/mmt/mpu/cutfile.c

diff --git a/net/mmt/mpu/cutfile.c b/net/mmt/mpu/cutfile.c
new file mode 100644
index 0000000..d977505
--- /dev/null
+++ b/net/mmt/mpu/cutfile.c
@@ -0,0 +1,29 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]) {
+    if (argc != 4) {
+        printf("usage: %s infile offset outfile\n", argv[0]);
+        return 1;
+    }
+
+    int offset = atoi(argv[2]);
+    if (offset < 0) return -1;
+    FILE* infp = fopen(argv[1], "rb");
+    if (!infp) return 1;
+    int ierr = fseek(infp, offset, SEEK_SET);
+    if (ierr != 0)  return -1;
+
+    FILE* outfp = fopen(argv[3], "wb");
+    if (!outfp) return 1;
+
+    char data[128*1024];
+    while(1) {
+        int iret = fread(data, 1, sizeof(data), infp);
+        if (iret <= 0) break;
+        fwrite(data, 1, iret, outfp);
+    }
+    fclose(infp);
+    fclose(outfp);
+    return 0;
+}
-- 
1.7.9.5


From 6b8d549be173dfd29bc13d925806d7f239d82e74 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 04:32:30 -0800
Subject: [PATCH 047/128] [todo] integrate with mpu parser

---
 net/mmt/mmt_control.cc |    8 +--
 net/mmt/mmt_control.h  |    2 +-
 net/mmt/mmt_stream.cc  |  143 ++++++++++++++++++------------------------------
 net/mmt/mmt_stream.h   |   38 +++++++++----
 net/mmt/mpu/mp4.h      |    2 +-
 5 files changed, 87 insertions(+), 106 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 28d1ff4..4b51ef8 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -93,7 +93,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     // TODO: for local file testing
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
-    streams_.insert(stream_t(key, stream));
+    streams_.insert(StreamPtr_t(key, stream));
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
@@ -103,10 +103,10 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
-    streams_t::iterator iter = streams_.find(key);
+    StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
-        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size, msg.sinfo.offset);
+        int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
 #if 0
         LOG(INFO) << __func__ 
             << " head=" << head 
@@ -125,7 +125,7 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
-    streams_t::iterator iter = streams_.find(key);
+    StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index df79ea1..3f09941 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -58,7 +58,7 @@ private:
     bool running_;
     std::vector<ctrl_msg_t> queue_;
     base::Lock lock_;
-    streams_t streams_;
+    StreamPtrs_t streams_;
 };
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index f473d76..bae7daf 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,5 +1,6 @@
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_inc.h"
+#include "net/mmt/mpu/mp4.h"
 
 namespace mmt {
 
@@ -92,10 +93,6 @@ Stream::~Stream() {
     Uninit();
 }
 
-GURL Stream::getUrl() {
-    return url_;
-}
-
 bool Stream::ParseSequence(int& index) {
     // if exists query, then should redirect to real file name
     std::string query = url_.query();
@@ -115,20 +112,31 @@ bool Stream::ParseSequence(int& index) {
     }
     return true;
 }
+bool Stream::Prepare(long *size) {
+    if (!Open(nullptr, 0)) return false;
 
-bool Stream::Init(int index) {
-    if (file_) return true;
+    long lret = 1<<30; // default 1GB
+    if (midx_.cur == -1) {
+        lret = offmap_[midx_.cur].size; // for single file or the 1st file
+    }
+    if (size)   *size = lret;
+    LOG(INFO) << __func__ << " lret=" << lret;
+    return true;
+}
+void* Stream::Open(const char* filename, int mode) {
+    if (file_) return (void *)file_;
 
+    int index = midx_.cur;
     if(index < 0 && !ParseSequence(index)) {
         LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
-        return false;
+        return nullptr;
     }
 
     // default file is html
     std::string fname = GURL2FilePath(url_);
     if (index >= 0) {
         if (index < midx_.begin || index > midx_.end)
-            return false;
+            return nullptr;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
@@ -137,109 +145,64 @@ bool Stream::Init(int index) {
             fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
-    LOG(INFO) << __func__ << " fname=" << fname;
+    LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
-    // open and get file size
+    // open and get file size for the 1st seq
     file_ = fopen(fname.c_str(), "rb");
-    if (!file_) return false;
+    if (!file_) return nullptr;
+
     int ierr = fseek(file_, 0L, SEEK_END);
+    if (ierr != 0) return nullptr; 
     long lret = ftell(file_);
     ierr = fseek(file_, 0L, SEEK_SET);
+    if (ierr != 0) return nullptr; 
 
-    offmap_[index] = offset_t();
-    offmap_[index].off = 0;
-    offmap_[index].size = lret;
-    if (index > midx_.begin) { // media sequence
-        offmap_[index].off = offmap_[index-1].off + offmap_[index-1].size;
-    }
-    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+    if (index != midx_.cur) {
+        mp4_box_t* root = MP4_BoxGetRoot((stream_t *)this);
+        mp4_box_t* box = MP4_BoxSearchBox(root, ATOM_ftyp);
+        box = MP4_BoxSearchBox(box, ATOM_moof);
+        if (!box) return nullptr;
+        offmap_[index] = offset_t(box->i_pos, lret);
 
-    midx_.cur = index;
-    return true;
-}
-bool Stream::Prepare(long *size) {
-    if (!Init(midx_.cur)) return false;
-    long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) {
-        lret = offmap_[midx_.cur].size;
+        ierr = fseek(file_, box->i_pos, SEEK_SET);
+        if (ierr != 0) return nullptr; 
+    }else {
+        offmap_[index] = offset_t(0, lret);
     }
-    if (size)   *size = lret;
-    LOG(INFO) << __func__ << " lret=" << lret;
-    return true;
-}
-long Stream::Seek(int offset, int whence) {
-    if (!Init(midx_.cur)) return -1;
 
-    long lret = -1;
-    int cur = midx_.cur;
-    if (cur == -1) { // for html file
-        int ierr = fseek(file_, offset, whence);
-        if (ierr == 0) {
-            lret = ftell(file_);
-        }
-    }else { // for media sequence
-        int idx = -1;
-        int off = -1;
-        if (offset < offmap_[cur].off) { // backward
-            Close();
-            for (int k=cur; k >= midx_.begin; k--) {
-                off = offset - offmap_[k].off;
-                if (off > 0) {
-                    idx = k;
-                    break;
-                }
-            }
-        }else if (offset >= offmap_[cur].off + offmap_[cur].size) { //forward
-            for(int k=cur+1; k <= midx_.end; k++) {
-                Close();
-                if(!Init(k)) break;
-                off = offmap_[k].off + offmap_[k].size - offset;
-                if (off > 0) {
-                    idx = k;
-                    break;
-                }
-            }
-        }else {
-            idx = cur;
-            off = offset - offmap_[cur].off;
-        }
-        LOG(INFO) << __func__ << " cur=" << cur << " next=" << idx << " relative off=" << off;
+    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
-        if (idx == -1) return -1;
-        if (!Init(idx)) return -1;
-        int ierr = fseek(file_, off, whence);
-        if (ierr == 0)
-            lret = ftell(file_);
-    }
-    LOG(INFO) << __func__ << " lret=" << lret << " offset=" << offset;
-    return lret;
+    midx_.cur = index;
+    return file_;
 }
-int Stream::Read(char *buf, int size, int offset) {
-    if (!Init(midx_.cur)) return -1;
-
-    long lret = Seek(offset, SEEK_SET);
-    if (lret < 0) return -1;
+int Stream::Read(void *buf, int size) {
+    if (!Open(nullptr, 0)) return -1;
 
     int iret = fread(buf, 1, size, file_);
-    if (iret <= 0) {
-        LOG(INFO) << __func__ << " iret=" << iret 
-            << " size=" << size << " offset=" << offset;
-    }else if (iret < size) {
-        //lret = Seek(offset+iret, SEEK_SET);
-        //if (lret < 0) return iret;
-        //iret += fread(buf+iret, 1, size-iret, file_);
+    if (iret < size) {
         Close();
-        midx_.cur++;
+        if (midx_.cur != -1) midx_.cur++; // goto next file
     }
     return iret; 
 }
-void Stream::Close() {
+int Stream::Write(void *buf, int size) {
+    return -1;
+}
+int Stream::Peek(void *buf, int size) {
+    return -1;
+}
+uint64_t Stream::Seek(int64_t offset, int whence) {
+    return fseek(file_, offset, whence);
+}
+uint64_t Stream::Tell() {
+    return ftell(file_);
+}
+int Stream::Close() {
     if (file_) fclose(file_);
     file_ = nullptr;
+    return 0;
 }
-
 void Stream::Uninit() {
-    //LOG(INFO) << "Stream::Uninit" << ", thiz=" << this << ", uri=" << uri_;
     Close();
     midx_.begin = -1;
     midx_.end = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 066d257..deb8aea 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -50,21 +50,39 @@ struct triple_t {
 };
 struct offset_t {
     offset_t() : off(0), size(0) {}
+    offset_t(long off, long size) : off(off), size(size) {}
+
     long off;
     long size;
 };
-class Stream : public base::RefCounted<Stream> {
+
+class IStream {
+public:
+   virtual void*    Open(const char* filename, int mode) = 0;
+   virtual int      Read(void* buf, int size) = 0;
+   virtual int      Write(void *buf, int size) = 0;
+   virtual int      Peek(void* buf, int size) = 0;
+   virtual uint64_t Seek(int64_t offset, int whence) = 0;
+   virtual uint64_t Tell() = 0;
+   virtual int      Close() = 0;
+
+   virtual ~IStream() {}
+};
+
+class Stream : public IStream, public base::RefCounted<Stream> {
 public:
+    virtual void*    Open(const char* fname, int mode) override;
+    virtual int      Read(void* buf, int size) override;
+    virtual int      Write(void *buf, int size) override;
+    virtual int      Peek(void* buf, int size) override;
+    virtual uint64_t Seek(int64_t offset, int whence) override;
+    virtual uint64_t Tell() override;
+    virtual int      Close() override;
+
     explicit Stream(const GURL &url);
-    GURL getUrl();
-    bool ParseSequence(int& index);
-    bool Init(int index);
     bool Prepare(long *size);
-    long Seek(int offset, int whence);
-    int Read(char *buf, int size, int offset);
-    void Close();
+    bool ParseSequence(int& index);
     void Uninit();
-
 protected:
     friend class base::RefCounted<Stream>;
     virtual ~Stream();
@@ -79,8 +97,8 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> stream_t;
-typedef std::map<std::string, StreamPtr>  streams_t;
+typedef std::pair<std::string, StreamPtr> StreamPtr_t;
+typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
 
 } // namespace mmt
 
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 3ce4bf5..13134d0 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1204,7 +1204,7 @@ extern "C" {
 #endif
 mp4_box_t *MP4_BoxGetRoot(stream_t * s);
 void MP4_BoxFree(stream_t * s, mp4_box_t *box);
-static mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
+mp4_box_t *MP4_ReadBox(stream_t *s, mp4_box_t *father);
 mp4_box_t *MP4_BoxGet(mp4_box_t *p_box, const char *psz_fmt, ...);
 mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type);
 #ifdef __cplusplus
-- 
1.7.9.5


From ec3ff649b1263681b4d73808271449de65d31fa2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 05:27:54 -0800
Subject: [PATCH 048/128] [todo] add mpu to chrome

---
 net/mmt/mmt_stream.cc      |   37 +++++++++++++++++++++----------------
 net/mmt/mpu/mp4.c          |   24 ++++++++++++------------
 net/mmt/mpu/mp4.h          |    2 +-
 net/mmt/mpu/mpu.gyp        |    6 ++++--
 net/mmt/mpu/stream.c       |    2 +-
 net/mmt/mpu/test_parser.cc |    5 -----
 net/net.gyp                |    1 +
 7 files changed, 40 insertions(+), 37 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index bae7daf..378382e 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -81,8 +81,7 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
-Stream::Stream(const GURL &url) 
-    : url_(url), file_(nullptr) { 
+Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
     midx_.end = -1;
@@ -116,8 +115,8 @@ bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
     long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) {
-        lret = offmap_[midx_.cur].size; // for single file or the 1st file
+    if (midx_.cur == -1) { // for one single file
+        lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -151,6 +150,7 @@ void* Stream::Open(const char* filename, int mode) {
     file_ = fopen(fname.c_str(), "rb");
     if (!file_) return nullptr;
 
+    // get file size
     int ierr = fseek(file_, 0L, SEEK_END);
     if (ierr != 0) return nullptr; 
     long lret = ftell(file_);
@@ -158,28 +158,33 @@ void* Stream::Open(const char* filename, int mode) {
     if (ierr != 0) return nullptr; 
 
     if (index != midx_.cur) {
-        mp4_box_t* root = MP4_BoxGetRoot((stream_t *)this);
-        mp4_box_t* box = MP4_BoxSearchBox(root, ATOM_ftyp);
-        box = MP4_BoxSearchBox(box, ATOM_moof);
-        if (!box) return nullptr;
-        offmap_[index] = offset_t(box->i_pos, lret);
-
-        ierr = fseek(file_, box->i_pos, SEEK_SET);
+        mp4_box_t* root = MP4_BoxGetRoot((stream_t*)this);
+        mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+        mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
+        LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
+        long offset = -1;
+        if (box) offset = box->i_pos;
+        MP4_BoxFree((stream_t*)this, root);
+        if (offset == -1) return nullptr;
+        
+        // seek to the 1st moof-box
+        offmap_[index] = offset_t(offset, lret);
+        ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
-    }else {
+    }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
-
-    LOG(INFO) << __func__ << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+    LOG(INFO) << __func__ << " index=" << index
+        << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
     midx_.cur = index;
-    return file_;
+    return (void *)file_;
 }
 int Stream::Read(void *buf, int size) {
     if (!Open(nullptr, 0)) return -1;
 
     int iret = fread(buf, 1, size, file_);
-    if (iret < size) {
+    if (iret < size) { // read to eof
         Close();
         if (midx_.cur != -1) midx_.cur++; // goto next file
     }
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index bc6af51..adf2898 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -4,7 +4,7 @@
 #include <assert.h>
 #include <math.h>
 #include <stdarg.h>
-#include "net/mmt/mpu/mp4.h"
+#include "mp4.h"
 
 void *debug_malloc(size_t size, const char *file, int line, const char *func)
 {
@@ -25,7 +25,7 @@ void *debug_free(char *p)
             	free(p) ;
                 p = NULL;
             }
-
+            return p;
 }
 
 //#define free(p)  do {                                                                                   \
@@ -203,9 +203,9 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
    const uint8_t *p_buff = malloc(32);
    const uint8_t *p_peek = p_buff;
 
-   if( ( ( i_read = stream_peek( p_stream, p_peek, 32 ) ) < 8 ) )
+   if( ( ( i_read = stream_peek( p_stream, (void*)p_peek, 32 ) ) < 8 ) )
    {
-      free(p_buff);
+      free((void*)p_buff);
       return 0;
    }
 
@@ -244,7 +244,7 @@ int MP4_ReadBoxCommon( stream_t *p_stream, mp4_box_t *p_box )
       CreateUUID( &p_box->i_uuid, p_box->i_type );
    }
 
-   free(p_buff);
+   free((void*)p_buff);
 
 // #ifdef MP4_VERBOSE
 //    if( p_box->i_size )
@@ -367,7 +367,7 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
       int     i_read;
       uint32_t i_fcc;
 
-      i_read  = stream_peek( p_stream, p_peek, 44 );
+      i_read  = stream_peek( p_stream, (void *)p_peek, 44 );
 
       p_peek += mp4_box_headersize( p_box ) + 4;
       i_read -= mp4_box_headersize( p_box ) + 4;
@@ -381,11 +381,11 @@ static int MP4_ReadBoxSkip( stream_t *p_stream, mp4_box_t *p_box )
             printf( "detected moov hidden in a free box ..." );
 
             p_box->i_type = ATOM_foov;
-            free(p_buff);
+            free((void *)p_buff);
             return MP4_ReadBoxContainer( p_stream, p_box );
          }
       }
-      free(p_buff);
+      free((void *)p_buff);
    }
 
    /* Nothing to do */
@@ -815,7 +815,7 @@ static int MP4_ReadBox_mdhd( stream_t *p_stream, mp4_box_t *p_box )
         MP4_GET4BYTES( p_box->data.p_mdhd->timescale );
         MP4_GET4BYTES( p_box->data.p_mdhd->duration );
     }
-    p_box->data.p_mdhd->language_code = i_language = SwapBE16( p_peek );
+    p_box->data.p_mdhd->language_code = i_language = SwapBE16( (uint16_t)p_peek );
     for( i = 0; i < 3; i++ )
     {
         p_box->data.p_mdhd->language[i] =
@@ -1479,7 +1479,7 @@ static int MP4_ReadBox_sample_soun( stream_t *p_stream, mp4_box_t *p_box )
 {
    unsigned int i = 0;
    MP4_READBOX_ENTER( mp4_box_data_sample_soun_t );
-   p_box->data.p_sample_soun->qt_description = NULL;
+   p_box->data.p_sample_soun->qt_description = 0;
 
    /* Sanity check needed because the "wave" box does also contain an
    * "mp4a" box that we don't understand. */
@@ -2289,7 +2289,7 @@ static int MP4_ReadBox_cprt( stream_t *p_stream, mp4_box_t *p_box )
 
    MP4_GETVERSIONFLAGS( p_box->data.p_cprt );
 
-   i_language = SwapBE16( p_peek );
+   i_language = SwapBE16( (uint16_t)p_peek );
    for( i = 0; i < 3; i++ )
    {
       p_box->data.p_cprt->language[i] =
@@ -3576,7 +3576,7 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 * MP4_ReadBox : parse the actual box and the children
 *  XXX : Do not go to the next box
 *****************************************************************************/
-static mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
+mp4_box_t *MP4_ReadBox( stream_t *p_stream, mp4_box_t *p_father )
 {
    mp4_box_t *p_box = calloc( 1, sizeof( mp4_box_t ) ); /* Needed to ensure simple on error handler */
    unsigned int i_index;
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 13134d0..8cff958 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -1,7 +1,7 @@
 #ifndef NET_MMT_MPU_MP4_H_
 #define NET_MMT_MPU_MP4_H_
 
-#include "net/mmt/mpu/stream.h"
+#include "stream.h"
 
 
 #define MP4_FOURCC( a, b, c, d ) \
diff --git a/net/mmt/mpu/mpu.gyp b/net/mmt/mpu/mpu.gyp
index 8f5acf2..597fb94 100644
--- a/net/mmt/mpu/mpu.gyp
+++ b/net/mmt/mpu/mpu.gyp
@@ -22,8 +22,10 @@
   'targets': [
     {
       'target_name': 'libmpu',
-      'type': '<(component)',
-      'product_name': 'libmpu',  # Don't conflict with OpenSSL's libssl
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mpu',
       'sources': [
         'stream.c',
         'mp4.c',
diff --git a/net/mmt/mpu/stream.c b/net/mmt/mpu/stream.c
index 571d68b..8be0258 100644
--- a/net/mmt/mpu/stream.c
+++ b/net/mmt/mpu/stream.c
@@ -3,7 +3,7 @@
 #include <malloc.h>
 #include <memory.h>
 #include <assert.h>
-#include "net/mmt/mpu/stream.h"
+#include "stream.h"
 
 #define max(a,b) a>b?a:b
 #define min(a,b) a>b?b:a
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index e65bf45..0a3e294 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -34,11 +34,6 @@ int main(int argc, char* argv[])
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
     }
 
-    box = MP4_BoxSearchBox(box, ATOM_mdat);
-    if (box) {
-        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
-
     box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
     if (box) {
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
diff --git a/net/net.gyp b/net/net.gyp
index 242582f..5b77dba 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -96,6 +96,7 @@
         '../url/url.gyp:url_lib',
         'net_derived_sources',
         'net_resources',
+        '../net/mmt/mpu/mpu.gyp:libmpu',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
-- 
1.7.9.5


From 8ef655e00ec8974453079c1fa3214808d54b711b Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 07:36:15 -0800
Subject: [PATCH 049/128] refile stream for mpu

---
 net/mmt/mmt_stream.cc      |   47 ++++++++++++++++++++++++++++++++++++++----
 net/mmt/mpu/stream.h       |   12 +++++------
 net/mmt/mpu/test_parser.cc |   49 ++++++++++++++++++++++++++++++++++++--------
 3 files changed, 89 insertions(+), 19 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 378382e..640fb07 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -81,6 +81,40 @@ content_t::~content_t() {
 /// for class Stream and StreamPool
 namespace mmt {
 
+void* mmtp_open(stream_t *s, const char* filename, int mode) {
+    return ((Stream*)s->opaque)->Open(filename, mode);
+}
+int mmtp_read(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Read(buf, size);
+}
+int mmtp_write(stream_t *s, void *buf, int size) {
+    return ((Stream*)s->opaque)->Write(buf, size);
+}
+int mmtp_peek(stream_t *s, void* buf, int size) {
+    return ((Stream*)s->opaque)->Peek(buf, size);
+}
+uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
+    return ((Stream*)s->opaque)->Seek(offset, whence);
+}
+uint64_t mmtp_tell(stream_t *s) {
+    return ((Stream*)s->opaque)->Tell();
+}
+int mmtp_close(stream_t *s) {
+    return ((Stream*)s->opaque)->Close();
+}
+static stream_t* InitMpuStream(Stream* ptr) {
+    stream_t* s = (stream_t*)malloc(sizeof(stream_t));
+    s->opaque = (void*)ptr;
+    s->open = mmtp_open;
+    s->read = mmtp_read;
+    s->write = mmtp_write;
+    s->peek = mmtp_peek;
+    s->seek = mmtp_seek;
+    s->tell = mmtp_tell;
+    s->close = mmtp_close;
+    return s;
+}
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
@@ -157,14 +191,16 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != midx_.cur) {
-        mp4_box_t* root = MP4_BoxGetRoot((stream_t*)this);
+    if (index != midx_.begin) {
+        stream_t* s = InitMpuStream(this);
+        mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
         mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
         LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
         long offset = -1;
         if (box) offset = box->i_pos;
-        MP4_BoxFree((stream_t*)this, root);
+        MP4_BoxFree(s, root);
+        free(s);
         if (offset == -1) return nullptr;
         
         // seek to the 1st moof-box
@@ -194,7 +230,10 @@ int Stream::Write(void *buf, int size) {
     return -1;
 }
 int Stream::Peek(void *buf, int size) {
-    return -1;
+    long offset = ftell(file_);
+    int iret = fread(buf, 1, size, file_);
+    fseek(file_, offset, SEEK_SET);
+    return iret;
 }
 uint64_t Stream::Seek(int64_t offset, int whence) {
     return fseek(file_, offset, whence);
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index 6d570b4..e528a9e 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -97,10 +97,8 @@ stream_t* create_buf_file_stream();
 void destory_buf_file_stream(stream_t* stream_s);
 
 // .
-#undef LIL_ENDIAN
-#undef BIG_ENDIAN
-#define LIL_ENDIAN	1234
-#define BIG_ENDIAN	4321
+#define LIL_ENDIAN__	1234
+#define BIG_ENDIAN__	4321
 /* #define BYTEORDER    1234 ? . */
 
 #ifndef BYTEORDER
@@ -109,9 +107,9 @@ void destory_buf_file_stream(stream_t* stream_s);
    (defined(__MIPS__) && defined(__MISPEB__)) || \
    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \
    defined(__sparc__)
-#define BYTEORDER	BIG_ENDIAN
+#define BYTEORDER	BIG_ENDIAN__
 #else
-#define BYTEORDER	LIL_ENDIAN
+#define BYTEORDER	LIL_ENDIAN__
 #endif
 #endif /* !BYTEORDER */
 
@@ -119,7 +117,7 @@ uint16_t Swap16(uint16_t x);
 uint32_t Swap32(uint32_t x);
 uint64_t Swap64(uint64_t x);
 
-#if BYTEORDER == LIL_ENDIAN
+#if BYTEORDER == LIL_ENDIAN__
 #define SwapLE16(X)	(X)
 #define SwapLE32(X)	(X)
 #define SwapLE64(X)	(X)
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 0a3e294..4263520 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -4,6 +4,35 @@
 #include "stream.h"
 #include "mp4.h"
 
+mp4_box_t* print_traf(mp4_box_t* box) {
+    printf("\n");
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_traf);
+        if (!box) break;
+        printf("traf: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+
+        box = MP4_BoxSearchBox(box, ATOM_tfhd);
+        if (!box) break;
+        else {
+            printf("tfhd: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%u size=%u\n", 
+                box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
+                box->data.p_tfhd->base_data_offset, box->data.p_tfhd->default_sample_size);
+        }
+
+        box = MP4_BoxSearchBox(box, ATOM_trun);
+        if (!box) break;
+        else {
+            printf("trun: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
+                box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
+                box->data.p_trun->data_offset);
+        }
+    }while(0);
+    printf("\n");
+    return box;
+}
+
 int main(int argc, char* argv[])
 {
     if (argc != 2) {
@@ -27,20 +56,24 @@ int main(int argc, char* argv[])
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
     if (box) {
         printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }else {
+        box = root;
     }
 
-    box = MP4_BoxSearchBox(box, ATOM_moof);
-    if (box) {
+    do {
+        box = MP4_BoxSearchBox(box, ATOM_moof);
+        if (!box) break;
         printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
 
-    box = MP4_BoxSearchBox(box!=NULL ? box->p_next : box, ATOM_moof);
-    if (box) {
-        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-    }
+        box = print_traf(box);
+        box = print_traf(box);
 
-    MP4_BoxFree(s, root);
+        box = MP4_BoxSearchBox(box, ATOM_mdat);
+        if (!box) break;
+        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+    }while(1);
 
+    MP4_BoxFree(s, root);
     stream_close(s);
     destory_file_stream(s);
 
-- 
1.7.9.5


From a20772e9d65103c28fc3758341a3c130c7c99046 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 25 Jan 2015 20:51:21 -0800
Subject: [PATCH 050/128] [ok][todo] for mmt parser and stream

---
 net/mmt/mmt_control.cc |   33 +---------------
 net/mmt/mmt_control.h  |    1 -
 net/mmt/mmt_inc.h      |    9 +++++
 net/mmt/mmt_parser.cc  |   21 ++++++++++
 net/mmt/mmt_parser.h   |   29 ++++++++++++++
 net/mmt/mmt_stream.cc  |   77 ++++--------------------------------
 net/mmt/mmt_stream.h   |    3 --
 net/mmt/mmt_utils.cc   |  101 ++++++++++++++++++++++++++++++++++++++++++++++++
 net/net.gyp            |   11 +++++-
 net/net.gypi           |    4 +-
 10 files changed, 181 insertions(+), 108 deletions(-)
 create mode 100644 net/mmt/mmt_parser.cc
 create mode 100644 net/mmt/mmt_parser.h
 create mode 100644 net/mmt/mmt_utils.cc

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 4b51ef8..6928caa 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -144,7 +144,7 @@ void MmtControl::Run() {
 
         std::string head = msg.head;
         if (head == "@ctrl") {
-            PostNativeMsg(msg.body);
+            SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
             StreamOpen(msg);
@@ -185,36 +185,5 @@ void MmtControl::Push(ctrl_msg_t &msg) {
     lock_.Release();
 }
 
-
-void PostNativeMsg(std::string msg) {
-    int sock = socket(AF_INET, SOCK_DGRAM, 0);
-    if(sock <= 0) {
-        LOG(INFO) << __func__ << " Open failed sock=" << sock;
-        return;
-    }
-    
-    int port = 54321;
-    std::string szaddr = "127.0.0.1";
-    net::IPAddressNumber ipnum;
-    if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
-        return;
-    }
-
-    net::IPEndPoint ip(ipnum, port);
-    struct sockaddr addr;
-    socklen_t addrlen;
-    if(!ip.ToSockAddr(&addr, &addrlen)) {
-        close(sock);
-        LOG(INFO) << __func__ << " ToSockAddr failed";
-        return;
-    }
-
-    int iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
-    LOG(INFO) << __func__ << " sendto iret=" << iret;
-    close(sock);
-}
-
 } // namespace mmt
 
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 3f09941..f597605 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -67,7 +67,6 @@ private:
 namespace mmt {
 
 void StartMmtCtrl();
-void PostNativeMsg(std::string msg);
 
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index ebe8715..485621b 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -5,6 +5,7 @@
 #include <sstream>
 #include <iomanip>
 
+#include "base/logging.h"
 #include "base/values.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/files/file_path.h"
@@ -33,9 +34,17 @@
 #include "chrome/browser/extensions/extension_tab_util.h"
 #include "url/gurl.h"
 
+
 namespace mmt{
+
 void Wait(int ms);
+std::string Int2String(int value, int width=0);
+int String2Int(std::string value);
 std::string GURL2FilePath(GURL gurl);
+std::string GetQueryValue(std::string query, std::string key);
+bool GetRangeValue(std::string range, int &lval, int &rval);
+int SendToHost(std::string msg, std::string szaddr, int port);
+
 }
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
new file mode 100644
index 0000000..70ed2ed
--- /dev/null
+++ b/net/mmt/mmt_parser.cc
@@ -0,0 +1,21 @@
+#include "net/mmt/mmt_parser.h"
+
+#include "libxml/parser.h"
+
+namespace mmt {
+
+CiParser::CiParser(std::string xml) : xml_(xml) {
+}
+
+CiParser::~CiParser() {
+}
+
+bool Parse() {
+    return true;
+}
+
+bool Merge(const CiParser& parser) {
+    return true;
+}
+
+}
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
new file mode 100644
index 0000000..77a14d0
--- /dev/null
+++ b/net/mmt/mmt_parser.h
@@ -0,0 +1,29 @@
+#ifndef NET_MMT_MMT_PARSER_H_
+#define NET_MMT_MMT_PARSER_H_
+
+#include "base/memory/ref_counted.h"
+
+namespace mmt {
+
+class CiParser : public base::RefCounted<CiParser> {
+public:
+    explicit CiParser(std::string xml);
+
+    bool Parse();
+    bool Merge(const CiParser& parser);
+
+protected:
+    friend class base::RefCounted<CiParser>;
+    virtual ~CiParser();
+
+private:
+    std::string xml_;
+
+};
+typedef scoped_refptr<CiParser> CiParserPtr;
+
+
+} // namespace mmt
+
+
+#endif // NET_MMT_MMT_PARSER_H_
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 640fb07..bf8a3a6 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,67 +4,6 @@
 
 namespace mmt {
 
-void Wait(int ms) {
-    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
-}
-std::string Int2String(int value, int width=0) {
-    std::string szval;
-    std::stringstream sstr;
-    if (width == 0)
-        sstr << value;
-    else
-        sstr << std::setfill('0') << std::setw(width)<< value;
-    sstr >> szval;
-    return szval;
-}
-int String2Int(std::string value) {
-    int ival = -1;
-    std::stringstream sstr;
-    sstr << value;
-    sstr >> ival;
-    return ival;
-}
-std::string GURL2FilePath(GURL gurl) {
-    std::string szpath;
-    base::FilePath file_path;
-    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
-    if (is_file) {
-        szpath = file_path.value();
-    }
-    return szpath;
-}
-std::string GetQueryValue(std::string query, std::string key) {
-    std::string value;
-    std::string::size_type begin, end;
-
-    key += "=";
-    begin = query.find(key);
-    if (begin != std::string::npos) {
-        begin += key.size();
-        end = query.find("&", begin);
-        if (end == std::string::npos)
-            end = query.size();
-        value = query.substr(begin, end-begin);
-    }
-    return value;
-}
-bool GetRangeValue(std::string range, int &lval, int &rval) {
-    bool bok = false;
-    std::string lstr = "0";
-    std::string rstr = "9999999";
-    int begin = range.find("-");
-    if (begin >= 0) {
-        lstr = range.substr(0, begin);
-        if (lstr.empty()) lstr = "-1";
-        rstr = range.substr(begin+1, range.size()-begin);
-        if (rstr.empty()) rstr = "9999999";
-        bok = true;
-    }
-    lval = String2Int(lstr);
-    rval = String2Int(rstr);
-    return bok;
-}
-
 content_t::content_t() {
     process_id = 0;
     frame_id = 0;
@@ -78,28 +17,28 @@ content_t::~content_t() {
 } // namespace mmt
 
 
-/// for class Stream and StreamPool
+/// for class Stream
 namespace mmt {
 
-void* mmtp_open(stream_t *s, const char* filename, int mode) {
+static void* mmtp_open(stream_t *s, const char* filename, int mode) {
     return ((Stream*)s->opaque)->Open(filename, mode);
 }
-int mmtp_read(stream_t *s, void* buf, int size) {
+static int mmtp_read(stream_t *s, void* buf, int size) {
     return ((Stream*)s->opaque)->Read(buf, size);
 }
-int mmtp_write(stream_t *s, void *buf, int size) {
+static int mmtp_write(stream_t *s, void *buf, int size) {
     return ((Stream*)s->opaque)->Write(buf, size);
 }
-int mmtp_peek(stream_t *s, void* buf, int size) {
+static int mmtp_peek(stream_t *s, void* buf, int size) {
     return ((Stream*)s->opaque)->Peek(buf, size);
 }
-uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
+static uint64_t mmtp_seek(stream_t *s, int64_t offset, int whence) {
     return ((Stream*)s->opaque)->Seek(offset, whence);
 }
-uint64_t mmtp_tell(stream_t *s) {
+static uint64_t mmtp_tell(stream_t *s) {
     return ((Stream*)s->opaque)->Tell();
 }
-int mmtp_close(stream_t *s) {
+static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
 static stream_t* InitMpuStream(Stream* ptr) {
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index deb8aea..d552463 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -6,15 +6,12 @@
 #include <vector>
 #include <sstream>
 
-#include "base/logging.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "base/synchronization/lock.h"
 
 #include "base/threading/thread_restrictions.h"
-#include "base/memory/ref_counted.h"
 #include "base/threading/simple_thread.h"
-#include "base/synchronization/lock.h"
 #include "base/threading/platform_thread.h"
 #include "base/time/time.h"
 #include "url/gurl.h"
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
new file mode 100644
index 0000000..76b9776
--- /dev/null
+++ b/net/mmt/mmt_utils.cc
@@ -0,0 +1,101 @@
+#include "net/mmt/mmt_inc.h"
+
+namespace mmt {
+
+void Wait(int ms) {
+    base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
+}
+std::string Int2String(int value, int width) {
+    std::string szval;
+    std::stringstream sstr;
+    if (width == 0)
+        sstr << value;
+    else
+        sstr << std::setfill('0') << std::setw(width)<< value;
+    sstr >> szval;
+    return szval;
+}
+int String2Int(std::string value) {
+    int ival = -1;
+    std::stringstream sstr;
+    sstr << value;
+    sstr >> ival;
+    return ival;
+}
+std::string GURL2FilePath(GURL gurl) {
+    std::string szpath;
+    base::FilePath file_path;
+    const bool is_file = net::FileURLToFilePath(gurl, &file_path);
+    if (is_file) {
+        szpath = file_path.value();
+    }
+    return szpath;
+}
+std::string GetQueryValue(std::string query, std::string key) {
+    std::string value;
+    std::string::size_type begin, end;
+
+    key += "=";
+    begin = query.find(key);
+    if (begin != std::string::npos) {
+        begin += key.size();
+        end = query.find("&", begin);
+        if (end == std::string::npos)
+            end = query.size();
+        value = query.substr(begin, end-begin);
+    }
+    return value;
+}
+bool GetRangeValue(std::string range, int &lval, int &rval) {
+    bool bok = false;
+    std::string lstr = "0";
+    std::string rstr = "9999999";
+    int begin = range.find("-");
+    if (begin >= 0) {
+        lstr = range.substr(0, begin);
+        if (lstr.empty()) lstr = "-1";
+        rstr = range.substr(begin+1, range.size()-begin);
+        if (rstr.empty()) rstr = "9999999";
+        bok = true;
+    }
+    lval = String2Int(lstr);
+    rval = String2Int(rstr);
+    return bok;
+}
+
+int SendToHost(std::string msg, std::string szaddr, int port) {
+    if (msg.empty() || szaddr.empty() || port <= 0) 
+        return -1;
+
+    int sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if(sock <= 0) {
+        LOG(INFO) << __func__ << " Open failed sock=" << sock;
+        return -1;
+    }
+    
+    int iret = -1;
+    do{
+        net::IPAddressNumber ipnum;
+        if (!net::ParseIPLiteralToNumber(szaddr, &ipnum)) {
+            LOG(INFO) << __func__ << " ParseURLHostnameToNumber failed";
+            break;
+        }
+
+        struct sockaddr addr;
+        socklen_t addrlen;
+        net::IPEndPoint ip(ipnum, port);
+        if(!ip.ToSockAddr(&addr, &addrlen)) {
+            LOG(INFO) << __func__ << " ToSockAddr failed";
+            break;
+        }
+
+        iret = sendto(sock, msg.c_str(), msg.size(), 0, &addr, sizeof(struct sockaddr));
+    }while(0);
+
+    close(sock);
+    LOG(INFO) << __func__ << " sendto iret=" << iret;
+    return iret;
+}
+
+
+} // namespace mmt
diff --git a/net/net.gyp b/net/net.gyp
index 5b77dba..ceb82ee 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -36,6 +36,11 @@
         'use_v8_in_net%': 1,
         'enable_built_in_dns%': 1,
       }],
+      ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+        'os_include': 'linux'
+      }],
+      ['OS=="mac"', {'os_include': 'mac'}],
+      ['OS=="win"', {'os_include': 'win32'}],
     ],
   },
   'includes': [
@@ -103,8 +108,10 @@
         '<@(net_non_nacl_sources)',
       ],
       'include_dirs': [
-         '../skia/config',
-         '../third_party/skia/include/core',
+        '../skia/config',
+        '../third_party/skia/include/core',
+        '../third_party/libxml/src/include',
+        '../third_party/libxml/<(os_include)/include',
       ],
       'defines': [
         'NET_IMPLEMENTATION',
diff --git a/net/net.gypi b/net/net.gypi
index 99959ba..ea5c471 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -700,8 +700,10 @@
       'http/url_security_manager.h',
       'http/url_security_manager_posix.cc',
       'http/url_security_manager_win.cc',
-      'mmt/mmt_stream.cc',
       'mmt/mmt_control.cc',
+      'mmt/mmt_parser.cc',
+      'mmt/mmt_stream.cc',
+      'mmt/mmt_utils.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
-- 
1.7.9.5


From ab032b1415248b8109e9e72acfd2a85e6887f6f9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 00:03:18 -0800
Subject: [PATCH 051/128] [todo] implement xml parser

---
 net/mmt/mmt_parser.cc |   86 +++++++++++++++++++++++++++++++++++++++++++++++--
 net/mmt/mmt_parser.h  |    6 ++--
 net/mmt/mmt_stream.cc |    4 ++-
 net/mmt/mmt_stream.h  |    5 +--
 4 files changed, 93 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 70ed2ed..63ac417 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -1,16 +1,98 @@
 #include "net/mmt/mmt_parser.h"
+#include "net/mmt/mmt_stream.h"
 
 #include "libxml/parser.h"
 
 namespace mmt {
 
-CiParser::CiParser(std::string xml) : xml_(xml) {
+struct node {
+	char *name;
+	struct node *parent;
+};
+
+static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts)
+{
+    fprintf(stdout, "[xml][start] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+	while (NULL != atts && NULL != *atts) {
+        if (atts[0] && atts[1]) {
+            fprintf(stdout, "[xml][start] attr name=%s value=%s", atts[0], atts[1]);
+        }else if (atts[0]) {
+            fprintf(stdout, "[xml][start] attr name=%s", atts[0]);
+        }
+		atts += 2;
+	}
+}
+
+static void sax_end_element(void *x,const xmlChar *name)
+{
+    fprintf(stdout, "[xml][end] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+}
+
+static void sax_characters(void *x,const xmlChar *ch,int len)
+{
+}
+
+static void sax_pi(void *x,const xmlChar *target,const xmlChar *data)
+{
+    fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
+}
+
+static void sax_comment(void *x,const xmlChar *value)
+{
+    fprintf(stdout, "[xml][comment] %s\n", value);
+}
+
+static void sax_error(void *x,const char *msg,...)
+{
+	va_list ap;
+	va_start(ap,msg);
+	fputs("[xml][error] ",stderr);
+	vfprintf(stderr,msg,ap);
+	va_end(ap);
+}
+
+static void init(xmlSAXHandlerPtr sax)
+{
+	sax->startElement = sax_start_element;
+	sax->endElement = sax_end_element;
+	sax->characters = sax_characters;
+	sax->processingInstruction = sax_pi;
+	sax->comment = sax_comment;
+	sax->warning = sax_error;
+	sax->error = sax_error;
+	sax->fatalError = sax_error;
+}
+
+
+CiParser::CiParser(const std::string& fname) : fname_(fname) {
 }
 
 CiParser::~CiParser() {
 }
 
-bool Parse() {
+bool CiParser::ParseXml() {
+    if (fname_.empty()) return false;
+
+	xmlSAXHandler sax;
+	xmlParserCtxtPtr ctxt;
+
+	xmlSubstituteEntitiesDefault(1);
+	memset(&sax,'\0',sizeof(sax));
+	init(&sax);
+
+	ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
+    ctxt->_private = (void *)this;
+    LOG(INFO) << __func__ << " thiz=" << this;
+
+	int num;
+	char buffer[4096];
+    StreamPtr stream = new Stream(fname_);
+    if (!stream->Prepare(nullptr)) return false;
+	while (0 < (num = stream->Read(buffer,sizeof(buffer)))
+	   &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
+	xmlParseChunk(ctxt,NULL,0,1);
+	xmlFreeParserCtxt(ctxt);
+
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 77a14d0..6883afe 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -7,9 +7,9 @@ namespace mmt {
 
 class CiParser : public base::RefCounted<CiParser> {
 public:
-    explicit CiParser(std::string xml);
+    explicit CiParser(const std::string& fname);
 
-    bool Parse();
+    bool ParseXml();
     bool Merge(const CiParser& parser);
 
 protected:
@@ -17,7 +17,7 @@ protected:
     virtual ~CiParser();
 
 private:
-    std::string xml_;
+    std::string fname_;
 
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index bf8a3a6..5c40616 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -60,6 +60,8 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
     midx_.end = -1;
     midx_.cur = -1;
 }
+Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
+}
 
 Stream::~Stream() {
     Uninit();
@@ -130,7 +132,7 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != midx_.begin) {
+    if (index != -1 && index != midx_.begin) {
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d552463..6142b3a 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -76,8 +76,9 @@ public:
     virtual uint64_t Tell() override;
     virtual int      Close() override;
 
-    explicit Stream(const GURL &url);
-    bool Prepare(long *size);
+    explicit Stream(const GURL& url);
+    explicit Stream(const std::string& szurl);
+    bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
 protected:
-- 
1.7.9.5


From f61d90e750985f799c816d719495860a2a726ff3 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 04:35:36 -0800
Subject: [PATCH 052/128] [done] for xml parser

---
 net/mmt/mmt_parser.cc |  152 ++++++++++++++++++++++++++++++-------------------
 net/mmt/mmt_parser.h  |   31 +++++++++-
 2 files changed, 123 insertions(+), 60 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 63ac417..6e479b3 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -5,66 +5,66 @@
 
 namespace mmt {
 
-struct node {
-	char *name;
-	struct node *parent;
-};
-
-static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts)
-{
-    fprintf(stdout, "[xml][start] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
-	while (NULL != atts && NULL != *atts) {
+static const char kNoValue[] = "no-value";
+
+static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->AddNode((const char*)name);
+
+    while (NULL != atts && NULL != *atts) {
         if (atts[0] && atts[1]) {
-            fprintf(stdout, "[xml][start] attr name=%s value=%s", atts[0], atts[1]);
+            if (ptr) ptr->AddAttr((const char*)atts[0], (const char*)atts[1]);
         }else if (atts[0]) {
-            fprintf(stdout, "[xml][start] attr name=%s", atts[0]);
+            if (ptr) ptr->AddAttr((const char*)atts[0], kNoValue);
         }
-		atts += 2;
-	}
+        atts += 2;
+    }
 }
-
-static void sax_end_element(void *x,const xmlChar *name)
-{
-    fprintf(stdout, "[xml][end] priv=%p name=%s\n", ((xmlParserCtxtPtr)x)->_private, name);
+static void sax_end_element(void *x,const xmlChar *name){
+    CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
+    if (ptr) ptr->EndNode((const char*)name);
 }
-
-static void sax_characters(void *x,const xmlChar *ch,int len)
-{
+static void sax_characters(void *x,const xmlChar *ch,int len){
 }
-
-static void sax_pi(void *x,const xmlChar *target,const xmlChar *data)
-{
+static void sax_pi(void *x,const xmlChar *target,const xmlChar *data){
     fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
 }
-
-static void sax_comment(void *x,const xmlChar *value)
-{
+static void sax_comment(void *x,const xmlChar *value) {
     fprintf(stdout, "[xml][comment] %s\n", value);
 }
-
-static void sax_error(void *x,const char *msg,...)
-{
-	va_list ap;
-	va_start(ap,msg);
-	fputs("[xml][error] ",stderr);
-	vfprintf(stderr,msg,ap);
-	va_end(ap);
+static void sax_error(void *x,const char *msg,...){
+    va_list ap;
+    va_start(ap,msg);
+    fputs("[xml][error] ",stderr);
+    vfprintf(stderr,msg,ap);
+    va_end(ap);
 }
 
-static void init(xmlSAXHandlerPtr sax)
-{
-	sax->startElement = sax_start_element;
-	sax->endElement = sax_end_element;
-	sax->characters = sax_characters;
-	sax->processingInstruction = sax_pi;
-	sax->comment = sax_comment;
-	sax->warning = sax_error;
-	sax->error = sax_error;
-	sax->fatalError = sax_error;
+static void init_sax(xmlSAXHandlerPtr sax) {
+    sax->startElement = sax_start_element;
+    sax->endElement = sax_end_element;
+    sax->characters = sax_characters;
+    sax->processingInstruction = sax_pi;
+    sax->comment = sax_comment;
+    sax->warning = sax_error;
+    sax->error = sax_error;
+    sax->fatalError = sax_error;
 }
 
+} // namespace mmt
+
 
-CiParser::CiParser(const std::string& fname) : fname_(fname) {
+namespace mmt {
+
+node_t::node_t(std::string name) 
+    : name(name), parent(nullptr) {
+}
+node_t::~node_t() {
+    nodes.clear();
+}
+
+CiParser::CiParser(const std::string& fname) 
+    : fname_(fname), root_(nullptr), cur_(nullptr) {
 }
 
 CiParser::~CiParser() {
@@ -73,31 +73,65 @@ CiParser::~CiParser() {
 bool CiParser::ParseXml() {
     if (fname_.empty()) return false;
 
-	xmlSAXHandler sax;
-	xmlParserCtxtPtr ctxt;
+    xmlSAXHandler sax;
+    xmlParserCtxtPtr ctxt;
 
-	xmlSubstituteEntitiesDefault(1);
-	memset(&sax,'\0',sizeof(sax));
-	init(&sax);
+    xmlSubstituteEntitiesDefault(1);
+    memset(&sax,'\0',sizeof(sax));
+    init_sax(&sax);
 
-	ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
+    ctxt = xmlCreatePushParserCtxt(&sax,NULL,NULL,0, NULL);
     ctxt->_private = (void *)this;
-    LOG(INFO) << __func__ << " thiz=" << this;
 
-	int num;
-	char buffer[4096];
     StreamPtr stream = new Stream(fname_);
     if (!stream->Prepare(nullptr)) return false;
-	while (0 < (num = stream->Read(buffer,sizeof(buffer)))
-	   &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
-	xmlParseChunk(ctxt,NULL,0,1);
-	xmlFreeParserCtxt(ctxt);
 
+    int num;
+    char buffer[4096];
+    while (0 < (num = stream->Read(buffer,sizeof(buffer)))
+            &&  0 == xmlParseChunk(ctxt,buffer,num,0)) ;
+    xmlParseChunk(ctxt,NULL,0,1);
+    xmlFreeParserCtxt(ctxt);
+
+    return true;
+}
+
+bool CiParser::Merge(const CiParser& parser) {
+    return false;
+}
+
+bool CiParser::AddNode(std::string name) {
+    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    nodeptr_t node = new node_t(name);
+    if (!root_)  {
+        root_ = node;
+        cur_ = root_;
+        return true;
+    }
+
+    if (!cur_) return false; // the end of xml file
+    node->parent = cur_;
+    cur_->nodes.push_back(node);
+    cur_ = node;
     return true;
 }
 
-bool Merge(const CiParser& parser) {
+bool CiParser::EndNode(std::string name) {
+    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
+    if (!cur_) return false;
+    if (name != cur_->name) {
+        LOG(INFO) << __func__ << " name=" << name;
+    }
+    cur_ = cur_->parent;
     return true;
 }
 
+bool CiParser::AddAttr(std::string name, std::string value) {
+    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+        << " attr: " << name << " => " << value;
+    if (!cur_) return false;
+    cur_->attrs[name] = value;
+    return true;
 }
+
+} // namespace mmt
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 6883afe..b04718e 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -1,10 +1,34 @@
 #ifndef NET_MMT_MMT_PARSER_H_
 #define NET_MMT_MMT_PARSER_H_
 
+#include <map>
+#include <string>
+#include <vector>
 #include "base/memory/ref_counted.h"
 
 namespace mmt {
 
+struct attr_t {
+    std::string name;
+    std::string value;
+};
+
+struct node_t : public base::RefCounted<node_t>{
+public:
+    explicit node_t(std::string name);
+
+    std::string name;
+    std::map<std::string, std::string> attrs;
+    std::vector<scoped_refptr<node_t> > nodes; // sub-nodes
+    scoped_refptr<node_t> parent;
+
+protected:
+    friend class base::RefCounted<node_t>;
+    virtual ~node_t();
+};
+typedef scoped_refptr<node_t> nodeptr_t;
+
+
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
@@ -12,13 +36,18 @@ public:
     bool ParseXml();
     bool Merge(const CiParser& parser);
 
+    bool AddNode(std::string name);
+    bool EndNode(std::string name);
+    bool AddAttr(std::string name, std::string value);
+    
 protected:
     friend class base::RefCounted<CiParser>;
     virtual ~CiParser();
 
 private:
     std::string fname_;
-
+    nodeptr_t root_;
+    nodeptr_t cur_; // only for AddNode and AddAttr
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From 3eeae87fc0e1ff71073f3284e95252d1ff6ee828 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 26 Jan 2015 08:22:36 -0800
Subject: [PATCH 053/128] [todo] process ci time range

---
 net/mmt/mmt_parser.cc |   54 +++++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mmt_parser.h  |   17 ++++++++--------
 2 files changed, 63 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 6e479b3..4be7897 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -126,11 +126,65 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
+int ParseTimeStr(std::string timestr) {
+    int sec = atoi(timestr.c_str());
+    std::string::size_type lpos, rpos;
+    lpos = timestr.find(":");
+    rpos = timestr.rfind(":");
+    if (lpos != std::string::npos) {
+        if (lpos != rpos) {
+            sec = sec * 3600;
+            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+        }else {
+            sec = sec * 60;
+        }
+    }
+    return sec;
+}
+
+bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
+    bool is_begin = true;
+    std::string::size_type pos;
+
+    pos = value.find(".begin");
+    if (pos == std::string::npos) {
+        is_begin = false;
+        pos = value.find(".end");
+    }
+    if (pos == std::string::npos) {
+        return false;
+    }
+
+    second = -2;
+    std::string idstr = value.substr(0, pos);
+    nodeptrs_t::iterator iter = node->nodes.begin();
+    for (; iter != node->nodes.end(); iter++) {
+        nodeptr_t sub = *iter;
+        if (sub->name == "mmtci:MediaSync") {
+            if (sub->attrs["refId"] == idstr) {
+                std::string timestr = (is_begin) ? sub->attrs["mmtci:begin"] : sub->attrs["mmtci:end"];
+                second = ParseTimeStr(timestr);
+            }
+        }
+    }
+    return true;
+}
+
 bool CiParser::AddAttr(std::string name, std::string value) {
     LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
         << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
+    if (name == "mmtci:begin" || name == "mmtci:end") {
+        int sec = -2;
+        if(!ParseTimeById(root_, value, sec))
+            sec = ParseTimeStr(value);
+        if (name == "mmtci:begin")
+            cur_->time.first = sec;
+        else
+            cur_->time.second = sec;
+        LOG(INFO) << __func__ << " sec=" << sec; 
+    }
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index b04718e..fa66194 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -8,25 +8,26 @@
 
 namespace mmt {
 
-struct attr_t {
-    std::string name;
-    std::string value;
-};
+struct node_t;
+typedef scoped_refptr<node_t> nodeptr_t;
+typedef std::map<std::string, std::string> attrs_t;
+typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
+typedef std::pair<int, int> range_t;
 
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
 
     std::string name;
-    std::map<std::string, std::string> attrs;
-    std::vector<scoped_refptr<node_t> > nodes; // sub-nodes
-    scoped_refptr<node_t> parent;
+    attrs_t attrs;
+    range_t time;     // for time range
+    nodeptrs_t nodes; // sub-nodes
+    nodeptr_t parent;
 
 protected:
     friend class base::RefCounted<node_t>;
     virtual ~node_t();
 };
-typedef scoped_refptr<node_t> nodeptr_t;
 
 
 class CiParser : public base::RefCounted<CiParser> {
-- 
1.7.9.5


From 912e65954b0a68c380bca2b13d6fd4a6a0ec0766 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 00:36:40 -0800
Subject: [PATCH 054/128] [todo] process <div><video><audio>

---
 net/mmt/mmt_parser.cc |  128 ++++++++++++++++++++++++++++++++++++++++++++-----
 net/mmt/mmt_parser.h  |   40 +++++++++++++++-
 2 files changed, 154 insertions(+), 14 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 4be7897..5a8d1e8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -7,6 +7,22 @@ namespace mmt {
 
 static const char kNoValue[] = "no-value";
 
+// node
+//static const char kCI[]             = "mmtci:CI";
+//static const char kview[]           = "mmtci:view";
+static const char kdivLocation[]    = "mmtci:divLocation";
+static const char kMediaSync[]      = "mmtci:MediaSync";
+static const char ksourceList[]     = "mmtci:sourceList";
+
+// attr
+static const char krefId[]      = "refId";
+static const char krefDiv[]     = "mmtci:refDiv";
+static const char kmediaSrc[]   = "mmtci:mediaSrc";
+static const char kbegin[]      = "mmtci:begin";
+static const char kend[]        = "mmtci:end";
+static const char kstyle[]      = "style";
+
+
 static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
     CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
     if (ptr) ptr->AddNode((const char*)name);
@@ -63,6 +79,17 @@ node_t::~node_t() {
     nodes.clear();
 }
 
+// for html tag <div>, <audio>, <video>
+html_div_t::html_div_t() {
+}
+html_div_t::~html_div_t() {
+}
+html_media_t::html_media_t() {
+}
+html_media_t::~html_media_t() {
+}
+
+
 CiParser::CiParser(const std::string& fname) 
     : fname_(fname), root_(nullptr), cur_(nullptr) {
 }
@@ -96,8 +123,84 @@ bool CiParser::ParseXml() {
     return true;
 }
 
-bool CiParser::Merge(const CiParser& parser) {
-    return false;
+bool CiParser::ParseHtmlTag() {
+    nodeptr_t node = root_;
+    if (!node) return false;
+
+    nodeptrs_t::iterator iter = node->nodes.begin();
+    for (; iter != node->nodes.end(); iter++) {
+        nodeptr_t sub = *iter;
+        if (sub->name == kdivLocation) {
+            if (sub->attrs.find(krefDiv) == sub->attrs.end())
+                continue;
+
+            divptr_t div = new html_div_t;
+            div->id = sub->attrs[krefDiv];
+            div->style = sub->attrs[kstyle];
+            divs_.push_back(div);
+        }else if (sub->name == kMediaSync) {
+            if (sub->attrs.find(krefId) == sub->attrs.end())
+                continue;
+
+            mediaptr_t media = new html_media_t;;
+            media->id = sub->attrs[krefId];
+            media->time = sub->time;
+            media->style = sub->attrs[kstyle];
+            if (sub->attrs.find(kmediaSrc) != sub->attrs.end())
+                media->srcs.push_back(sub->attrs[kmediaSrc]);
+
+            nodeptrs_t::iterator iter2 = sub->nodes.begin();
+            for (; iter2 != sub->nodes.end(); iter2++) {
+                nodeptr_t sub2 = *iter2;
+                if (sub2->name == ksourceList) {
+                    if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
+                        media->srcs.push_back(sub2->attrs[kmediaSrc]);
+                }
+            }
+            medias_.push_back(media);
+        }
+    }
+    return true;
+}
+bool CiParser::GetDivJS(std::string& divjs) {
+    if (divs_.empty()) return false;
+
+    std::vector<divptr_t>::iterator iter = divs_.begin();
+    for (; iter != divs_.end(); iter++) {
+        divptr_t div = *iter;
+        if (!div->style.empty()) {
+            divjs += div->id+"=document.getElementById('"+div->id+"');";
+            divjs += div->id+".style='"+div->style+"';";
+        }
+    }
+
+    return true;
+}
+bool CiParser::GetMediaJS(long current, std::string& mediajs) {
+    if (medias_.empty()) return false;
+
+    std::vector<mediaptr_t>::iterator iter = medias_.begin();
+    for (; iter != medias_.end(); iter++) {
+        mediaptr_t media = *iter;
+        int begin = media->time.first;
+        int end = media->time.second;
+        if (begin < 0) continue;
+        if (current < begin) continue;
+
+        std::string id = media->id;
+        bool bstart = (current<end || end<0);
+        if (bstart) {
+            if (!media->srcs.empty()) {
+                mediajs += id+"=document.getElementById('"+id+"');";
+                mediajs += id+".src="+media->srcs[0]+"');";
+                mediajs += id+".play();";
+            }
+        }else {
+            mediajs += id+"=document.getElementById('"+id+"');";
+            mediajs += id+".stop();";
+        }
+    }
+    return true;
 }
 
 bool CiParser::AddNode(std::string name) {
@@ -145,14 +248,15 @@ int ParseTimeStr(std::string timestr) {
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
-
     pos = value.find(".begin");
     if (pos == std::string::npos) {
         is_begin = false;
         pos = value.find(".end");
     }
+
     if (pos == std::string::npos) {
-        return false;
+        second = ParseTimeStr(value);
+        return true;
     }
 
     second = -2;
@@ -160,10 +264,11 @@ bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     nodeptrs_t::iterator iter = node->nodes.begin();
     for (; iter != node->nodes.end(); iter++) {
         nodeptr_t sub = *iter;
-        if (sub->name == "mmtci:MediaSync") {
-            if (sub->attrs["refId"] == idstr) {
-                std::string timestr = (is_begin) ? sub->attrs["mmtci:begin"] : sub->attrs["mmtci:end"];
+        if (sub->name == kMediaSync) {
+            if (sub->attrs[krefId] == idstr) {
+                std::string timestr = (is_begin) ? sub->attrs[kbegin] : sub->attrs[kend];
                 second = ParseTimeStr(timestr);
+                break;
             }
         }
     }
@@ -175,15 +280,14 @@ bool CiParser::AddAttr(std::string name, std::string value) {
         << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
-    if (name == "mmtci:begin" || name == "mmtci:end") {
+    if (name == kbegin || name == kend) {
         int sec = -2;
-        if(!ParseTimeById(root_, value, sec))
-            sec = ParseTimeStr(value);
-        if (name == "mmtci:begin")
+        ParseTimeById(root_, value, sec);
+        if (name == kbegin)
             cur_->time.first = sec;
         else
             cur_->time.second = sec;
-        LOG(INFO) << __func__ << " sec=" << sec; 
+        LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
     }
     return true;
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index fa66194..53a93aa 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -12,7 +12,7 @@ struct node_t;
 typedef scoped_refptr<node_t> nodeptr_t;
 typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
-typedef std::pair<int, int> range_t;
+typedef std::pair<long, long> range_t;
 
 struct node_t : public base::RefCounted<node_t>{
 public:
@@ -29,13 +29,46 @@ protected:
     virtual ~node_t();
 };
 
+// for tag <div>
+struct html_div_t : public base::RefCounted<html_div_t> {
+public: 
+    explicit html_div_t();
+
+    std::string id; // tag id
+    std::string style;
+
+protected:
+    friend class base::RefCounted<html_div_t>;
+    virtual ~html_div_t();
+};
+typedef scoped_refptr<html_div_t> divptr_t;
+
+// for tags of <audio> and <video>
+struct html_media_t : public base::RefCounted<html_media_t> { 
+public:
+    explicit html_media_t();
+
+    std::string id;     // tag id
+    range_t time;       // [begin, end]
+    std::string style;
+    std::vector<std::string> srcs;    //src list
+
+protected:
+    friend class base::RefCounted<html_media_t>;
+    virtual ~html_media_t();
+};
+typedef scoped_refptr<html_media_t> mediaptr_t;
+
 
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
 
     bool ParseXml();
-    bool Merge(const CiParser& parser);
+    bool ParseHtmlTag();
+
+    bool GetDivJS(std::string& divjs);
+    bool GetMediaJS(long current, std::string& mediajs);
 
     bool AddNode(std::string name);
     bool EndNode(std::string name);
@@ -49,6 +82,9 @@ private:
     std::string fname_;
     nodeptr_t root_;
     nodeptr_t cur_; // only for AddNode and AddAttr
+
+    std::vector<divptr_t> divs_;
+    std::vector<mediaptr_t> medias_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From f73314d3ed7697e9428b1aa5af4a7497c92c98dd Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 04:43:06 -0800
Subject: [PATCH 055/128] [todo] generate js

---
 net/mmt/mmt_control.cc |   17 ++++++++++
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_parser.cc  |   81 ++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_parser.h   |    8 ++++-
 4 files changed, 82 insertions(+), 25 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 6928caa..77390e3 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -131,6 +131,21 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
+void TestXmlParser() {
+    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    CiParserPtr parser = new CiParser(xml);
+    parser->ParseXml();
+    parser->ParseHtmlTag();
+    std::string js;
+    parser->GetDivJS(js);
+    LOG(INFO) << __func__ << " div js: " << js;
+    parser->GetMediaJS(0, js);
+    LOG(INFO) << __func__ << " media js1: " << js;
+    parser->GetMediaJS(1080, js);
+    LOG(INFO) << __func__ << " media js2: " << js;
+    parser->GetMediaJS(1086, js);
+    LOG(INFO) << __func__ << " media js3: " << js;
+}
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
@@ -147,12 +162,14 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
+            TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
             StreamClose(msg);
             ms = 100;
         }else if (msg.head == "@read") {
+            //TODO: if io pending, should re-push this msg again.
             StreamRead(msg);
             ms = 10;
         }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f597605..185f8f4 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -3,6 +3,7 @@
 
 #include <string>
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_parser.h"
 
 namespace net {
 class IOBuffer;
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 5a8d1e8..890f2d8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -9,7 +9,7 @@ static const char kNoValue[] = "no-value";
 
 // node
 //static const char kCI[]             = "mmtci:CI";
-//static const char kview[]           = "mmtci:view";
+static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
 static const char ksourceList[]     = "mmtci:sourceList";
@@ -85,6 +85,7 @@ html_div_t::html_div_t() {
 html_div_t::~html_div_t() {
 }
 html_media_t::html_media_t() {
+    type = html_media_t::AVImage;
 }
 html_media_t::~html_media_t() {
 }
@@ -130,14 +131,20 @@ bool CiParser::ParseHtmlTag() {
     nodeptrs_t::iterator iter = node->nodes.begin();
     for (; iter != node->nodes.end(); iter++) {
         nodeptr_t sub = *iter;
-        if (sub->name == kdivLocation) {
-            if (sub->attrs.find(krefDiv) == sub->attrs.end())
-                continue;
-
-            divptr_t div = new html_div_t;
-            div->id = sub->attrs[krefDiv];
-            div->style = sub->attrs[kstyle];
-            divs_.push_back(div);
+        if (sub->name == kview) {
+            nodeptrs_t::iterator iter2 = sub->nodes.begin();
+            for (; iter2 != sub->nodes.end(); iter2++) {
+                nodeptr_t sub2 = *iter2;
+                if (sub2->name != kdivLocation) 
+                    continue;
+                if (sub2->attrs.find(krefDiv) == sub2->attrs.end())
+                    continue;
+
+                divptr_t div = new html_div_t;
+                div->id = sub2->attrs[krefDiv];
+                div->style = sub2->attrs[kstyle];
+                divs_.push_back(div);
+            }
         }else if (sub->name == kMediaSync) {
             if (sub->attrs.find(krefId) == sub->attrs.end())
                 continue;
@@ -146,15 +153,18 @@ bool CiParser::ParseHtmlTag() {
             media->id = sub->attrs[krefId];
             media->time = sub->time;
             media->style = sub->attrs[kstyle];
-            if (sub->attrs.find(kmediaSrc) != sub->attrs.end())
+            if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
+                media->type = html_media_t::AVImage;
                 media->srcs.push_back(sub->attrs[kmediaSrc]);
-
-            nodeptrs_t::iterator iter2 = sub->nodes.begin();
-            for (; iter2 != sub->nodes.end(); iter2++) {
-                nodeptr_t sub2 = *iter2;
-                if (sub2->name == ksourceList) {
-                    if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
-                        media->srcs.push_back(sub2->attrs[kmediaSrc]);
+            }else {
+                media->type = html_media_t::AVMedia;
+                nodeptrs_t::iterator iter2 = sub->nodes.begin();
+                for (; iter2 != sub->nodes.end(); iter2++) {
+                    nodeptr_t sub2 = *iter2;
+                    if (sub2->name == ksourceList) {
+                        if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
+                            media->srcs.push_back(sub2->attrs[kmediaSrc]);
+                    }
                 }
             }
             medias_.push_back(media);
@@ -162,23 +172,35 @@ bool CiParser::ParseHtmlTag() {
     }
     return true;
 }
+inline std::string GetObject(std::string id) {
+    return "g_"+id+"=document.getElementById('"+id+"');";
+}
+inline std::string SetAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+"='"+value+"';";
+}
+inline std::string CallFunc(std::string id, std::string name) {
+    return "g_"+id+"."+name+"();";
+}
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
 
+    divjs = "";
     std::vector<divptr_t>::iterator iter = divs_.begin();
     for (; iter != divs_.end(); iter++) {
         divptr_t div = *iter;
         if (!div->style.empty()) {
-            divjs += div->id+"=document.getElementById('"+div->id+"');";
-            divjs += div->id+".style='"+div->style+"';";
+            divjs += GetObject(div->id);
+            divjs += SetAttr(div->id, "style", div->style);
         }
     }
 
     return true;
 }
+
 bool CiParser::GetMediaJS(long current, std::string& mediajs) {
     if (medias_.empty()) return false;
 
+    mediajs = "";
     std::vector<mediaptr_t>::iterator iter = medias_.begin();
     for (; iter != medias_.end(); iter++) {
         mediaptr_t media = *iter;
@@ -190,14 +212,16 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
         std::string id = media->id;
         bool bstart = (current<end || end<0);
         if (bstart) {
+            mediajs += GetObject(id);
             if (!media->srcs.empty()) {
-                mediajs += id+"=document.getElementById('"+id+"');";
-                mediajs += id+".src="+media->srcs[0]+"');";
-                mediajs += id+".play();";
+                mediajs += SetAttr(id, "src", media->srcs[0]);
             }
+            mediajs += CallFunc(id, "play");
         }else {
-            mediajs += id+"=document.getElementById('"+id+"');";
-            mediajs += id+".stop();";
+            mediajs += GetObject(id);
+            if (media->type == html_media_t::AVImage)
+                mediajs += SetAttr(id, "src", "");
+            mediajs += CallFunc(id, "stop");
         }
     }
     return true;
@@ -238,8 +262,10 @@ int ParseTimeStr(std::string timestr) {
         if (lpos != rpos) {
             sec = sec * 3600;
             sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atoi(timestr.substr(rpos+1).c_str());
         }else {
             sec = sec * 60;
+            sec = sec + atoi(timestr.substr(lpos+1).c_str());
         }
     }
     return sec;
@@ -248,6 +274,13 @@ int ParseTimeStr(std::string timestr) {
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
+
+    pos = value.find(".click");
+    if (pos != std::string::npos) {
+        // todo: proc click event
+        return true;
+    }
+
     pos = value.find(".begin");
     if (pos == std::string::npos) {
         is_begin = false;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 53a93aa..1e84919 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -43,11 +43,17 @@ protected:
 };
 typedef scoped_refptr<html_div_t> divptr_t;
 
-// for tags of <audio> and <video>
+// for tags of <image>, <audio> and <video>
 struct html_media_t : public base::RefCounted<html_media_t> { 
 public:
+    enum {
+        AVImage,
+        AVMedia,
+    };
+
     explicit html_media_t();
 
+    int type;
     std::string id;     // tag id
     range_t time;       // [begin, end]
     std::string style;
-- 
1.7.9.5


From 5aa5018c9e4b9783dc545271999182fb9cad310c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 06:25:06 -0800
Subject: [PATCH 056/128] [ok] for video mmt

---
 net/mmt/mmt_control.cc                 |    4 ++--
 net/mmt/mmt_parser.cc                  |    3 +++
 net/mmt/mmt_parser.h                   |    2 ++
 net/mmt/mmt_stream.cc                  |    2 +-
 net/mmt/mmt_stream.h                   |    1 -
 net/url_request/url_request_mmt_job.cc |   11 +++++------
 6 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 77390e3..04a7f93 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -93,7 +93,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     // TODO: for local file testing
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
-    streams_.insert(StreamPtr_t(key, stream));
+    streams_[key] = stream;
     stream->Prepare(&lsize);
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
@@ -162,7 +162,7 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
-            TestXmlParser();
+            //TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 890f2d8..0fc0e1c 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -74,9 +74,11 @@ namespace mmt {
 
 node_t::node_t(std::string name) 
     : name(name), parent(nullptr) {
+    time.first = time.second = -1;
 }
 node_t::~node_t() {
     nodes.clear();
+    parent = nullptr;
 }
 
 // for html tag <div>, <audio>, <video>
@@ -86,6 +88,7 @@ html_div_t::~html_div_t() {
 }
 html_media_t::html_media_t() {
     type = html_media_t::AVImage;
+    time.first = time.second = -1;
 }
 html_media_t::~html_media_t() {
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 1e84919..93a70cc 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -14,6 +14,7 @@ typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
 typedef std::pair<long, long> range_t;
 
+// for xml node
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
@@ -66,6 +67,7 @@ protected:
 typedef scoped_refptr<html_media_t> mediaptr_t;
 
 
+/// for xml sax parser
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 5c40616..3c8e446 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -158,7 +158,7 @@ void* Stream::Open(const char* filename, int mode) {
     return (void *)file_;
 }
 int Stream::Read(void *buf, int size) {
-    if (!Open(nullptr, 0)) return -1;
+    if (!Open(nullptr, 0)) return -2;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 6142b3a..88907de 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -95,7 +95,6 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::pair<std::string, StreamPtr> StreamPtr_t;
 typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
 
 } // namespace mmt
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 6cdffa9..807e5fa 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -204,8 +204,11 @@ void URLRequestMmtJob::DidStart(int iret) {
 }
 
 void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  LOG(INFO) << __func__ << " iret=" << iret << 
-    " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
+  if (iret < 0) {
+    LOG(INFO) << __func__ << " iret=" << iret << 
+        " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
+    return;
+  }
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
@@ -222,10 +225,6 @@ void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
     DCHECK_GE(read_info_.remaining_bytes, 0);
   }
 
-  // fix error
-  if (result == -1)
-    result = OK;
-
   if (result == OK) {
     NotifyDone(URLRequestStatus());
   } else if (result < 0) {
-- 
1.7.9.5


From e78a196a331e9abd4ee179efdd905c83240a4709 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 08:49:13 -0800
Subject: [PATCH 057/128] [ok] for seq start from 1

---
 net/mmt/mmt_control.cc                 |   53 ++++++++++++++++++++++++++++----
 net/mmt/mmt_control.h                  |    9 ++++--
 net/mmt/mmt_parser.cc                  |   13 ++++----
 net/url_request/url_request_mmt_job.cc |    6 ++--
 4 files changed, 64 insertions(+), 17 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 04a7f93..d74a076 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -27,26 +27,28 @@ void PostCtrlMsg(ctrl_msg_t &msg) {
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
+    msg.url = gurl;
     msg.body = body;
     msg.tabid = tabid;
-    msg.url = gurl;
     PostCtrlMsg(msg);
 }
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr) {
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
-    msg.ptr = refptr;
     msg.url = gurl;
+    msg.ptr = refptr;
+    msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
 // for @open and @read
-int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr) {
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
+    msg.url = gurl;
     msg.sinfo = sinfo;
     msg.ptr = ptr;
-    msg.url = gurl;
+    msg.tabid = tabid;
     PostCtrlMsg(msg);
     return -1; // IO_PENDING
 }
@@ -88,7 +90,7 @@ MmtControl::~MmtControl() {}
 // for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tab=" << msg.tabid;
 
     // TODO: for local file testing
     long lsize = -1;
@@ -98,6 +100,8 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
     }
+
+    tabs_[msg.tabid] = (lsize > 0) ? "loading" : "failed";
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -130,6 +134,41 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
     }
+    tabs_[msg.tabid] = "loaded";
+}
+void MmtControl::CheckEvent() {
+    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+
+    std::map<int, std::string>::iterator iter;
+    for (iter=tabs_.begin(); iter != tabs_.end(); iter++) {
+        if (iter->second != "failed") {
+            CiParserPtr parser;
+            if (parsers_.find(iter->first) == parsers_.end()) {
+                parser = new CiParser(xml);
+                parser->ParseXml();
+                parser->ParseHtmlTag();
+                parsers_[iter->first] = parser;
+            }else {
+                parser = parsers_[iter->first];
+            }
+
+            if (iter->second == "loaded") {
+                std::string divjs, mediajs;
+                parser->GetDivJS(divjs);
+                parser->GetMediaJS(0, mediajs);
+
+                std::string js;
+                js += "{";
+                js += "\"tabid\" : " + Int2String(iter->first);
+                js += ", ";
+                js += "\"js\" : \"" + divjs + mediajs + "\"";
+                js += "}";
+                LOG(INFO) << __func__ << " js => " << js;
+                SendToHost(js, "127.0.0.1", 54321);
+                iter->second = "ci-init";
+            }
+        }
+    }
 }
 void TestXmlParser() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
@@ -151,6 +190,8 @@ void MmtControl::Run() {
     running_ = true;
     int ms = 100;
     while(loop_) {
+        CheckEvent();
+
         ctrl_msg_t msg;
         if (!Pop(msg)) {
             Wait(ms);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 185f8f4..0f7a52b 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -54,10 +54,15 @@ protected:
     void StreamRead(ctrl_msg_t msg);
     void StreamClose(ctrl_msg_t msg);
 
+    // check event and process it, such as A/V sync.
+    void CheckEvent();
+
 private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
+    std::map<int, std::string> tabs_;
+    std::map<int, CiParserPtr> parsers_;
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
@@ -72,9 +77,9 @@ void StartMmtCtrl();
 // for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr);
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
 // for @open and @read
-int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr);
+int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
 } // namespace mmt
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 0fc0e1c..bee93e8 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -182,7 +182,8 @@ inline std::string SetAttr(std::string id, std::string name, std::string value)
     return "g_"+id+"."+name+"='"+value+"';";
 }
 inline std::string CallFunc(std::string id, std::string name) {
-    return "g_"+id+"."+name+"();";
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+"!=undefined){" + func + "();}";  
 }
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
@@ -231,7 +232,7 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
 }
 
 bool CiParser::AddNode(std::string name) {
-    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    //LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
     if (!root_)  {
         root_ = node;
@@ -247,7 +248,7 @@ bool CiParser::AddNode(std::string name) {
 }
 
 bool CiParser::EndNode(std::string name) {
-    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
+    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") << " node=" << name;
     if (!cur_) return false;
     if (name != cur_->name) {
         LOG(INFO) << __func__ << " name=" << name;
@@ -312,8 +313,8 @@ bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
 }
 
 bool CiParser::AddAttr(std::string name, std::string value) {
-    LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
-        << " attr: " << name << " => " << value;
+    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+    //    << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
     if (name == kbegin || name == kend) {
@@ -323,7 +324,7 @@ bool CiParser::AddAttr(std::string name, std::string value) {
             cur_->time.first = sec;
         else
             cur_->time.second = sec;
-        LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
+        //LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
     }
     return true;
 }
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 807e5fa..4e10c38 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -56,11 +56,11 @@ URLRequestMmtJob::URLRequestMmtJob(
 void URLRequestMmtJob::Start() {
   mmt::stream_info_t sinfo;
   sinfo.func = &URLRequestMmtJob::DoStart;
-  mmt::PostCtrlTask("@open", request_->url(), sinfo, this);
+  mmt::PostCtrlTask("@open", request_->url(), sinfo, this, content_.tab_id);
 }
 
 void URLRequestMmtJob::Kill() {
-  mmt::PostCtrlTask("@close", request_->url(), this);
+  mmt::PostCtrlTask("@close", request_->url(), this, content_.tab_id);
   weak_ptr_factory_.InvalidateWeakPtrs();
 
   URLRequestJob::Kill();
@@ -90,7 +90,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.func = &URLRequestMmtJob::DoRead;
 
   // return ERR_IO_PENDING if aysnc read
-  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this);
+  int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this, content_.tab_id);
   if (rv >= 0) {
     // Data is immediately available.
     *bytes_read = rv;
-- 
1.7.9.5


From ceacfcda24e0b584b7732891f4392e60a3dd54a1 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 27 Jan 2015 23:19:22 -0800
Subject: [PATCH 058/128] fix non-json exception

---
 .../api/cictrl/res/native-messaging-cictrl         |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
index 05279a2..787b81e 100755
--- a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -13,6 +13,7 @@ import Queue
 
 import time
 import socket
+import signal
 from json import JSONDecoder
 
 gDaemon = True
@@ -26,7 +27,10 @@ except ImportError:
 def send_message(message):
   # message must be JSON string
   if len(message) < 16: return
-  jdata = JSONDecoder().decode(message)
+  try:
+    jdata = JSONDecoder().decode(message)
+  except:
+    jdata = None
   if not jdata: return
 
   # Write message size.
@@ -144,8 +148,14 @@ def Main():
   main_window.mainloop()
   sys.exit(0)
 
+def OnSignal(a, b):
+    sys.exit(0)
+    pass
 
 if __name__ == '__main__':
+  signal.signal(signal.SIGTERM, OnSignal)
+  signal.signal(signal.SIGINT, OnSignal)
+
   if gDaemon:   Daemon()
   else:         Main()
 
-- 
1.7.9.5


From 8259d50d0746ee613979875ea9dbe34ca83133ea Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 01:13:58 -0800
Subject: [PATCH 059/128] Add ci xml proc

---
 net/mmt/mmt_control.cc |   84 +++++++++++++++++++++++++++++++-----------------
 net/mmt/mmt_control.h  |   16 +++++++--
 2 files changed, 68 insertions(+), 32 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index d74a076..4f5b8af 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -73,6 +73,13 @@ ctrl_msg_t::ctrl_msg_t() {
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
+cixml_t::cixml_t() {
+    status = "initing";
+}
+cixml_t::~cixml_t() {
+    parser = nullptr;
+}
+
 static std::string mmtjob_key(GURL url, void* ptr) {
     std::string name = url.spec();
     std::stringstream sstr;
@@ -90,7 +97,7 @@ MmtControl::~MmtControl() {}
 // for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tab=" << msg.tabid;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
 
     // TODO: for local file testing
     long lsize = -1;
@@ -100,8 +107,6 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     if (msg.sinfo.func) {
         msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
     }
-
-    tabs_[msg.tabid] = (lsize > 0) ? "loading" : "failed";
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -124,49 +129,69 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
             msg.sinfo.func(msg.ptr, msg.sinfo, iret);
         }
     }
+
+    if (msg.tabid > 0) {
+        if (cixmls_.find(msg.tabid) == cixmls_.end()) {
+            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
+            cixmls_[msg.tabid] = new cixml_t;;
+        }
+    }
 }
 void MmtControl::StreamClose(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
-    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
+    LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
 
     StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         streams_.erase(iter);
     }
-    tabs_[msg.tabid] = "loaded";
 }
 void MmtControl::CheckEvent() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
 
-    std::map<int, std::string>::iterator iter;
-    for (iter=tabs_.begin(); iter != tabs_.end(); iter++) {
-        if (iter->second != "failed") {
-            CiParserPtr parser;
-            if (parsers_.find(iter->first) == parsers_.end()) {
-                parser = new CiParser(xml);
+    std::map<int, cixmlptr_t>::iterator iter;
+    for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
+        cixmlptr_t cixml = iter->second;
+        if (!cixml) {
+            iter->second = new cixml_t;
+            continue;
+        }
+
+        CiParserPtr parser = cixml->parser;
+        if (cixml->status == "end") continue;
+
+        LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        if (cixml->status == "initing") {
+            if (!cixml->parser) {
+                cixml->parser = new CiParser(xml);
+            }
+            cixml->status = "loading";
+        }else if (cixml->status == "loading") {
+            if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
-                parsers_[iter->first] = parser;
-            }else {
-                parser = parsers_[iter->first];
             }
-
-            if (iter->second == "loaded") {
-                std::string divjs, mediajs;
-                parser->GetDivJS(divjs);
-                parser->GetMediaJS(0, mediajs);
-
-                std::string js;
-                js += "{";
-                js += "\"tabid\" : " + Int2String(iter->first);
-                js += ", ";
-                js += "\"js\" : \"" + divjs + mediajs + "\"";
-                js += "}";
-                LOG(INFO) << __func__ << " js => " << js;
-                SendToHost(js, "127.0.0.1", 54321);
-                iter->second = "ci-init";
+            cixml->status = "loaded";
+        }else if (cixml->status == "loaded") {
+            if (!parser) {
+                cixml->status = "end";
+                continue;
             }
+
+            std::string divjs, mediajs;
+            parser->GetDivJS(divjs);
+            parser->GetMediaJS(0, mediajs);
+
+            std::string js;
+            js += "{";
+            js += "\"tabid\" : " + Int2String(iter->first);
+            js += ", ";
+            js += "\"js\" : \"" + divjs + mediajs + "\"";
+            js += "}";
+            LOG(INFO) << __func__ << " js => " << js;
+            SendToHost(js, "127.0.0.1", 54321);
+            cixml->status = "end";
         }
     }
 }
@@ -203,7 +228,6 @@ void MmtControl::Run() {
             SendToHost(msg.body, "127.0.0.1", 54321);
             ms = 100;
         }else if (msg.head == "@open") {
-            //TestXmlParser();
             StreamOpen(msg);
             ms = 100;
         }else if (msg.head == "@close") {
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 0f7a52b..3c096db 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -37,6 +37,19 @@ struct ctrl_msg_t {
     stream_info_t sinfo;
 };
 
+struct cixml_t : public base::RefCounted<cixml_t> {
+public:
+    cixml_t();
+    std::string status;
+    CiParserPtr parser;
+
+protected:
+    friend class base::RefCounted<cixml_t>;
+    virtual ~cixml_t();
+};
+typedef scoped_refptr<cixml_t> cixmlptr_t;
+
+
 class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
@@ -61,8 +74,7 @@ private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
-    std::map<int, std::string> tabs_;
-    std::map<int, CiParserPtr> parsers_;
+    std::map<int, cixmlptr_t> cixmls_; // tab id => ci xml
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
-- 
1.7.9.5


From 8524981bc2abe58903b9fd010f70093f1e044790 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 03:09:58 -0800
Subject: [PATCH 060/128] Add docs to mmt

---
 net/mmt/mmt_control.cc |   64 ++++++++++++++++++++----------------
 net/mmt/mmt_control.h  |   46 ++++++++++++++++++++------
 net/mmt/mmt_parser.cc  |   84 +++++++++++++++++++++++++++---------------------
 net/mmt/mmt_parser.h   |   29 +++++++++++------
 net/mmt/mmt_stream.cc  |   10 +++++-
 net/mmt/mmt_stream.h   |   21 ++++++++----
 6 files changed, 162 insertions(+), 92 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 4f5b8af..5dfc760 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -50,7 +50,7 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
     msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
-    return -1; // IO_PENDING
+    return -1; //> default IO_PENDING(-1) and Async Read
 }
 
 } // namespace mmt
@@ -80,6 +80,9 @@ cixml_t::~cixml_t() {
     parser = nullptr;
 }
 
+/**
+ * The algorithm to generate unique key for UrlRequestJob
+ */
 static std::string mmtjob_key(GURL url, void* ptr) {
     std::string name = url.spec();
     std::stringstream sstr;
@@ -94,7 +97,6 @@ MmtControl::MmtControl() : SimpleThread("mmt_control"){
 }
 MmtControl::~MmtControl() {}
 
-// for I/O stream
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key << " tabid=" << msg.tabid;
@@ -133,7 +135,8 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (msg.tabid > 0) {
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
-            cixmls_[msg.tabid] = new cixml_t;;
+            cixmlptr_t cixml = new cixml_t;
+            cixmls_[msg.tabid] = cixml;;
         }
     }
 }
@@ -148,53 +151,54 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
     }
 }
 void MmtControl::CheckEvent() {
+    // TODO for testing
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
 
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
         cixmlptr_t cixml = iter->second;
-        if (!cixml) {
-            iter->second = new cixml_t;
-            continue;
-        }
-
-        CiParserPtr parser = cixml->parser;
+        if (!cixml) continue;
         if (cixml->status == "end") continue;
 
         LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        std::string next_status = cixml->status;
+        CiParserPtr parser = cixml->parser;
+
         if (cixml->status == "initing") {
             if (!cixml->parser) {
                 cixml->parser = new CiParser(xml);
             }
-            cixml->status = "loading";
+            next_status = "loading";
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
             }
-            cixml->status = "loaded";
+            next_status = "loaded";
         }else if (cixml->status == "loaded") {
-            if (!parser) {
-                cixml->status = "end";
-                continue;
-            }
+            if (parser) {
+                std::string divjs, mediajs;
+                parser->GetDivJS(divjs);
+                parser->GetMediaJS(0, mediajs);
 
-            std::string divjs, mediajs;
-            parser->GetDivJS(divjs);
-            parser->GetMediaJS(0, mediajs);
-
-            std::string js;
-            js += "{";
-            js += "\"tabid\" : " + Int2String(iter->first);
-            js += ", ";
-            js += "\"js\" : \"" + divjs + mediajs + "\"";
-            js += "}";
-            LOG(INFO) << __func__ << " js => " << js;
-            SendToHost(js, "127.0.0.1", 54321);
-            cixml->status = "end";
+                std::string js;
+                js += "{";
+                js += "\"tabid\" : " + Int2String(iter->first);
+                js += ", ";
+                js += "\"js\" : \"" + divjs + mediajs + "\"";
+                js += "}";
+                LOG(INFO) << __func__ << " js => " << js;
+                SendToHost(js, "127.0.0.1", 54321);
+            }
+            next_status = "end";
         }
+        cixml->status = next_status;
     }
 }
+
+/**
+ * UnitTest for class CiParser
+ */
 void TestXmlParser() {
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
     CiParserPtr parser = new CiParser(xml);
@@ -210,6 +214,10 @@ void TestXmlParser() {
     parser->GetMediaJS(1086, js);
     LOG(INFO) << __func__ << " media js3: " << js;
 }
+
+/**
+ * Thread Main Loop
+ */
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 3c096db..6b9d6ae 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -1,6 +1,12 @@
 #ifndef NET_MMT_MMT_CONTROL_H_
 #define NET_MMT_MMT_CONTROL_H_
 
+/**
+ * Control center, 
+ *  which process mmt protocl, CI, Stream IO(mmtp) and A/V sync.
+ *  It will be activated by mmt:// protocol and only start one seperate thread.
+ */
+
 #include <string>
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_parser.h"
@@ -15,8 +21,16 @@ namespace mmt {
 struct stream_info_t;
 typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
 
-// (ptr, stream_info_t, errno)
+
+/**
+ * Stream IO callback function,
+ *  three parameters: (job object, stream_info_t, errno)
+ */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+
+/**
+ * Stream IO Information
+ */
 struct stream_info_t {
     net::IOBuffer*  buf;
     int             size;
@@ -24,19 +38,25 @@ struct stream_info_t {
     stream_func_t   func;
 };
 
+/**
+ * The message for Control Center.
+ */
 struct ctrl_msg_t {
     ctrl_msg_t();
     ~ctrl_msg_t();
 
-    std::string head;
+    std::string head;   //> msg tag: @open, @read, @close, @ctrl and etc.
     std::string body;
-    GURL url;
-    int tabid;
-    job_refptr_t ptr;
+    GURL url;           //> access url
+    int tabid;          //> chrome's tab id
+    job_refptr_t ptr;   //> job object
 
-    stream_info_t sinfo;
+    stream_info_t sinfo;    //> valid for @open, @read and @close
 };
 
+/**
+ * Structure for CI XML to process ci. 
+ */
 struct cixml_t : public base::RefCounted<cixml_t> {
 public:
     cixml_t();
@@ -50,6 +70,9 @@ protected:
 typedef scoped_refptr<cixml_t> cixmlptr_t;
 
 
+/**
+ * class for Control Center
+ */
 class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
@@ -62,19 +85,20 @@ public:
     void Push(ctrl_msg_t& msg);
 
 protected:
-    // operations for I/O stream
+    // Operations for I/O Stream
     void StreamOpen(ctrl_msg_t msg);
     void StreamRead(ctrl_msg_t msg);
     void StreamClose(ctrl_msg_t msg);
 
-    // check event and process it, such as A/V sync.
+    // Check CI events.
     void CheckEvent();
 
 private:
     bool loop_;
     bool running_;
     std::vector<ctrl_msg_t> queue_;
-    std::map<int, cixmlptr_t> cixmls_; // tab id => ci xml
+    std::map<int, cixmlptr_t> cixmls_; //> (tabid => cixml_t)
+
     base::Lock lock_;
     StreamPtrs_t streams_;
 };
@@ -84,6 +108,7 @@ private:
 
 namespace mmt {
 
+// Start control center
 void StartMmtCtrl();
 
 // for @ctrl
@@ -92,6 +117,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
 // for @open and @read
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
+
 } // namespace mmt
 
-#endif
+#endif // NET_MMT_MMT_CONTROL_H_
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index bee93e8..45a7f72 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -7,14 +7,18 @@ namespace mmt {
 
 static const char kNoValue[] = "no-value";
 
-// node
+/**
+ * String constants for ci xml node
+ */
 //static const char kCI[]             = "mmtci:CI";
 static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
 static const char ksourceList[]     = "mmtci:sourceList";
 
-// attr
+/**
+ * String constants for ci xml attr
+ */
 static const char krefId[]      = "refId";
 static const char krefDiv[]     = "mmtci:refDiv";
 static const char kmediaSrc[]   = "mmtci:mediaSrc";
@@ -23,6 +27,9 @@ static const char kend[]        = "mmtci:end";
 static const char kstyle[]      = "style";
 
 
+/**
+ * callback functions for libxml2's sax parser
+ */
 static void sax_start_element(void *x,const xmlChar *name,const xmlChar **atts){
     CiParser* ptr = (CiParser*)((xmlParserCtxtPtr)x)->_private;
     if (ptr) ptr->AddNode((const char*)name);
@@ -67,6 +74,42 @@ static void init_sax(xmlSAXHandlerPtr sax) {
     sax->fatalError = sax_error;
 }
 
+/**
+ * Utils for generating javascript 
+ */
+inline std::string GetObject(std::string id) {
+    return "g_"+id+"=document.getElementById('"+id+"');";
+}
+inline std::string SetAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+"='"+value+"';";
+}
+inline std::string CallFunc(std::string id, std::string name) {
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+"!=undefined){" + func + "();}";  
+}
+
+/**
+ * To parse CI's time
+ */
+int ParseTimeStr(std::string timestr) {
+    int sec = atoi(timestr.c_str());
+    std::string::size_type lpos, rpos;
+    lpos = timestr.find(":");
+    rpos = timestr.rfind(":");
+    if (lpos != std::string::npos) {
+        if (lpos != rpos) {
+            sec = sec * 3600;
+            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atoi(timestr.substr(rpos+1).c_str());
+        }else {
+            sec = sec * 60;
+            sec = sec + atoi(timestr.substr(lpos+1).c_str());
+        }
+    }
+    return sec;
+}
+
+
 } // namespace mmt
 
 
@@ -81,13 +124,12 @@ node_t::~node_t() {
     parent = nullptr;
 }
 
-// for html tag <div>, <audio>, <video>
 html_div_t::html_div_t() {
 }
 html_div_t::~html_div_t() {
 }
+
 html_media_t::html_media_t() {
-    type = html_media_t::AVImage;
     time.first = time.second = -1;
 }
 html_media_t::~html_media_t() {
@@ -157,10 +199,8 @@ bool CiParser::ParseHtmlTag() {
             media->time = sub->time;
             media->style = sub->attrs[kstyle];
             if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
-                media->type = html_media_t::AVImage;
                 media->srcs.push_back(sub->attrs[kmediaSrc]);
             }else {
-                media->type = html_media_t::AVMedia;
                 nodeptrs_t::iterator iter2 = sub->nodes.begin();
                 for (; iter2 != sub->nodes.end(); iter2++) {
                     nodeptr_t sub2 = *iter2;
@@ -175,16 +215,7 @@ bool CiParser::ParseHtmlTag() {
     }
     return true;
 }
-inline std::string GetObject(std::string id) {
-    return "g_"+id+"=document.getElementById('"+id+"');";
-}
-inline std::string SetAttr(std::string id, std::string name, std::string value) {
-    return "g_"+id+"."+name+"='"+value+"';";
-}
-inline std::string CallFunc(std::string id, std::string name) {
-    std::string func = "g_"+id+"."+name;
-    return "if("+func+"!=undefined){" + func + "();}";  
-}
+
 bool CiParser::GetDivJS(std::string& divjs) {
     if (divs_.empty()) return false;
 
@@ -223,8 +254,7 @@ bool CiParser::GetMediaJS(long current, std::string& mediajs) {
             mediajs += CallFunc(id, "play");
         }else {
             mediajs += GetObject(id);
-            if (media->type == html_media_t::AVImage)
-                mediajs += SetAttr(id, "src", "");
+            mediajs += SetAttr(id, "src", "");
             mediajs += CallFunc(id, "stop");
         }
     }
@@ -257,24 +287,6 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
-int ParseTimeStr(std::string timestr) {
-    int sec = atoi(timestr.c_str());
-    std::string::size_type lpos, rpos;
-    lpos = timestr.find(":");
-    rpos = timestr.rfind(":");
-    if (lpos != std::string::npos) {
-        if (lpos != rpos) {
-            sec = sec * 3600;
-            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
-            sec = sec + atoi(timestr.substr(rpos+1).c_str());
-        }else {
-            sec = sec * 60;
-            sec = sec + atoi(timestr.substr(lpos+1).c_str());
-        }
-    }
-    return sec;
-}
-
 bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
     bool is_begin = true;
     std::string::size_type pos;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 93a70cc..7b84035 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -1,6 +1,10 @@
 #ifndef NET_MMT_MMT_PARSER_H_
 #define NET_MMT_MMT_PARSER_H_
 
+/**
+ * XML Parser for CI files which is based on libxml2.
+ */
+
 #include <map>
 #include <string>
 #include <vector>
@@ -14,7 +18,10 @@ typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
 typedef std::pair<long, long> range_t;
 
-// for xml node
+
+/**
+ * Structure for xml node
+ */
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
@@ -30,7 +37,10 @@ protected:
     virtual ~node_t();
 };
 
-// for tag <div>
+
+/** 
+ * Structure for html tag <div>
+ */
 struct html_div_t : public base::RefCounted<html_div_t> {
 public: 
     explicit html_div_t();
@@ -44,17 +54,14 @@ protected:
 };
 typedef scoped_refptr<html_div_t> divptr_t;
 
-// for tags of <image>, <audio> and <video>
+
+/** 
+ * Sturcture for tags of html <img>, <audio> and <video>
+ */
 struct html_media_t : public base::RefCounted<html_media_t> { 
 public:
-    enum {
-        AVImage,
-        AVMedia,
-    };
-
     explicit html_media_t();
 
-    int type;
     std::string id;     // tag id
     range_t time;       // [begin, end]
     std::string style;
@@ -67,7 +74,9 @@ protected:
 typedef scoped_refptr<html_media_t> mediaptr_t;
 
 
-/// for xml sax parser
+/** 
+ * class for parsing xml  
+ */
 class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 3c8e446..06600da 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -17,9 +17,11 @@ content_t::~content_t() {
 } // namespace mmt
 
 
-/// for class Stream
 namespace mmt {
 
+/**
+ * For mpu's stream io
+ */
 static void* mmtp_open(stream_t *s, const char* filename, int mode) {
     return ((Stream*)s->opaque)->Open(filename, mode);
 }
@@ -54,6 +56,12 @@ static stream_t* InitMpuStream(Stream* ptr) {
     return s;
 }
 
+} // namespace mmt
+
+
+
+namespace mmt {
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 88907de..cb78227 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -24,15 +24,18 @@ class IOBuffer;
 
 namespace mmt {
 
+/**
+ * Collect the information of URLRequestJob
+ */
 struct content_t {
     content_t();
     ~content_t();
 
-    int process_id;
-    int frame_id;
-    int routing_id;
-    int tab_id;
-    std::string tab_url;
+    int process_id; //> render process id
+    int frame_id;   //> render frame id
+    int routing_id; //> render host routing id 
+    int tab_id;     //> chrome's tab id
+    std::string tab_url;    //> chrome's tab url
 };
 
 } // namespace mmt
@@ -66,6 +69,9 @@ public:
    virtual ~IStream() {}
 };
 
+/**
+ * Stream IO for both local file and mmtp receiver
+ */
 class Stream : public IStream, public base::RefCounted<Stream> {
 public:
     virtual void*    Open(const char* fname, int mode) override;
@@ -81,14 +87,15 @@ public:
     bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
+
 protected:
     friend class base::RefCounted<Stream>;
     virtual ~Stream();
 
 private:
     GURL url_;
-    triple_t midx_;
-    std::map<int, offset_t> offmap_;
+    triple_t midx_; //> media index
+    std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
-- 
1.7.9.5


From cba363bcfdfba83f6da7facde395ddafdf941134 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 03:10:48 -0800
Subject: [PATCH 061/128] remove cimsg extension

---
 .../docs/examples/api/cimsg/background.js          |   86 -----------
 .../docs/examples/api/cimsg/install_host.sh        |   40 -----
 .../docs/examples/api/cimsg/manifest.json          |   24 ---
 .../docs/examples/api/cimsg/native-messaging-cimsg |  154 --------------------
 .../examples/api/cimsg/org.chromium.cimsg.json     |   13 --
 5 files changed, 317 deletions(-)
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/background.js
 delete mode 100755 chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/manifest.json
 delete mode 100755 chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
 delete mode 100644 chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json

diff --git a/chrome/common/extensions/docs/examples/api/cimsg/background.js b/chrome/common/extensions/docs/examples/api/cimsg/background.js
deleted file mode 100644
index daf7dd5..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/background.js
+++ /dev/null
@@ -1,86 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-var port = null;
-var tabid = -1;
-
-var getKeys = function(obj){
-  var keys = [];
-  for(var key in obj){
-    keys.push(key);
-  }
-  return keys;
-}
-
-function parseJSON(data) {
-  return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function("return " + data))(); 
-}
-
-function logMsg(msg) {
-  //alert(msg);
-  console.log(msg);
-}
-
-function sendNativeMessage(message) {
-  if (port == null) return;
-  if(typeof(message) != "object") {
-    logMsg(typeof(message) + " is not a json object");
-    return;
-  }
-  port.postMessage(message);
-}
-
-function onNativeMessage(message) {
-  if(typeof(message) != "object") {
-    logMsg(typeof(message) + " is not a json object");
-    return;
-  }
-
-  js = message["js"];
-  if (js != undefined) {
-    chrome.tabs.executeScript({
-        code: js
-    });
-  }
-
-  css = message["css"];
-  if (css != undefined) {
-    chrome.tabs.insertCSS({
-        code: css
-    });
-  }
-}
-
-function onDisconnected() {
-  port = null;
-}
-
-function connect() {
-  var hostName = "org.chromium.cimsg";
-  port = chrome.runtime.connectNative(hostName);
-  if (port != null) {
-    port.onMessage.addListener(onNativeMessage);
-    port.onDisconnect.addListener(onDisconnected);
-  }
-}
-
-
-/// events
-chrome.tabs.onCreated.addListener(function(tab) {
-});
-chrome.tabs.onActivated.addListener(function(info) {
-  //chrome.tabs.executeScript({file: "ci.js"});
-});
-chrome.browserAction.onClicked.addListener(function(tab) {
-  chrome.tabs.executeScript({
-    code: 'document.body.style.backgroundColor="red"'
-  });
-});
-chrome.tabs.onUpdated.addListener(function(tid, info, tab) {
-  if (info.status == "complete" && tab.url.indexOf("chrome://") < 0) {
-    tabid = tab.id;
-    connect();
-  }
-});
-
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh b/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
deleted file mode 100755
index da7105e..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/install_host.sh
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/bin/sh
-# Copyright 2013 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-set -e
-
-DIR="$( cd "$( dirname "$0" )" && pwd )"
-if [ $(uname -s) == 'Darwin' ]; then
-  if [ "$(whoami)" == "root" ]; then
-    TARGET_DIR="/Library/Chromium/NativeMessagingHosts"
-  else
-    TARGET_DIR=\
-        "$HOME/Library/Application Support/Chromium/NativeMessagingHosts"
-  fi
-else
-  if [ "$(whoami)" == "root" ]; then
-    TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
-  else
-    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
-  fi
-fi
-
-HOST_NAME=org.chromium.cimsg
-
-# Create directory to store native messaging host.
-mkdir -p $TARGET_DIR
-
-# Copy native messaging host manifest.
-cp $DIR/$HOST_NAME.json $TARGET_DIR
-
-# Update host path in the manifest.
-HOST_PATH=$DIR/native-messaging-cimsg
-ESCAPED_HOST_PATH=${HOST_PATH////\\/}
-sed -i -e "s/HOST_PATH/$ESCAPED_HOST_PATH/" $TARGET_DIR/$HOST_NAME.json
-
-# Set permissions for the manifest so that all users can read it.
-chmod o+r $TARGET_DIR/$HOST_NAME.json
-
-echo Native messaging host $HOST_NAME has been installed.
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json b/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
deleted file mode 100644
index fea9000..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/manifest.json
+++ /dev/null
@@ -1,24 +0,0 @@
-{
-    "key": "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDcBHwzDvyBQ6bDppkIs9MP4ksKqCMyXQ/A52JivHZKh4YO/9vJsT3oaYhSpDCE9RPocOEQvwsHsFReW2nUEc6OLLyoCFFxIb7KkLGsmfakkut/fFdNJYh0xOTbSN8YvLWcqph09XAY2Y/f0AL7vfO1cuCqtkMt8hFrBGWxDdf9CQIDAQAB",
-    "name": "org.chromium.cimsg",
-    "version": "1.0",
-    "manifest_version": 2,
-    "description": "chromium native messaging for ci",
-    "permissions": [
-        "tabs",
-        "nativeMessaging",
-        "activeTab",
-        "notifications",
-        "http://*/",
-        "https://*/",
-        "file://*/",
-        "mmt://*/"
-    ],
-   "browser_action": {
-        "default_title": "Make this page red"
-    },
-    "background": {
-        "scripts": ["background.js"],
-        "persistent": false
-    }
-}
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg b/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
deleted file mode 100755
index 2b31c6b..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/native-messaging-cimsg
+++ /dev/null
@@ -1,154 +0,0 @@
-#!/usr/bin/env python
-# Copyright (c) 2012 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# A simple native messaging host. Shows a Tkinter dialog with incoming messages
-# that also allows to send message back to the webapp.
-
-import struct
-import sys
-import threading
-import Queue
-
-import time
-import socket
-from json import JSONDecoder
-
-gDaemon = True
-try:
-  import Tkinter
-  import tkMessageBox
-except ImportError:
-  Tkinter = None
-
-# Helper function that sends a message to the webapp.
-def send_message(message):
-  # message must be JSON string
-  if len(message) < 16: return
-  try:
-    jdata = JSONDecoder().decode(message)
-  except:
-    jdata = None
-  if not jdata: return
-
-  # Write message size.
-  sys.stdout.write(struct.pack('I', len(message)))
-  # Write the message itself.
-  sys.stdout.write(message)
-  try:
-    sys.stdout.flush()
-  except: return
-
-# Thread that reads messages from control point
-def read_ctrl_func():
-  host = "localhost"
-  port = 54321
-  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
-  sock.sendto("@quit", (host,port))
-  sock.close()
-  time.sleep(3)
-  
-  sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
-  sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-  sock.bind((host, port))
-  while True:
-    msg, addr = sock.recvfrom(65536)
-    if msg[:5] == "@quit":
-      break
-    send_message(msg)
-  sock.close()
-
-# Thread that reads messages from the webapp.
-def read_thread_func(queue):
-  while True:
-    # Read the message length (first 4 bytes).
-    text_length_bytes = sys.stdin.read(4)
-    if len(text_length_bytes) == 0:
-      if queue: queue.put(None)
-      sys.exit(0)
-
-    # Unpack message length as 4 byte integer.
-    text_length = struct.unpack('i', text_length_bytes)[0]
-    # Read the text (JSON object) of the message.
-    text = sys.stdin.read(text_length).decode('utf-8')
-    if queue: queue.put(text)
-
-if Tkinter:
-  class NativeMessagingWindow(Tkinter.Frame):
-    def __init__(self, queue):
-      self.queue = queue
-
-      Tkinter.Frame.__init__(self)
-      self.pack()
-
-      self.text = Tkinter.Text(self)
-      self.text.grid(row=0, column=0, padx=10, pady=10, columnspan=2)
-      self.text.config(state=Tkinter.DISABLED, height=10, width=40)
-
-      self.messageContent = Tkinter.StringVar()
-      self.sendEntry = Tkinter.Entry(self, textvariable=self.messageContent)
-      self.sendEntry.grid(row=1, column=0, padx=10, pady=10)
-
-      self.sendButton = Tkinter.Button(self, text="Send", command=self.onSend)
-      self.sendButton.grid(row=1, column=1, padx=10, pady=10)
-
-      self.after(100, self.processMessages)
-
-    def processMessages(self):
-      while not self.queue.empty():
-        message = self.queue.get_nowait()
-        if message == None:
-          self.quit()
-          return
-        self.log("Received %s" % message)
-
-      self.after(100, self.processMessages)
-
-    def onSend(self):
-      #text = '{"text": "' + self.messageContent.get() + '"}'
-      text = self.messageContent.get()
-      self.log('Sending %s' % text)
-      try:
-        send_message(text)
-      except IOError:
-        tkMessageBox.showinfo('Native Messaging Example',
-                              'Failed to send message.')
-        sys.exit(1)
-
-    def log(self, message):
-      self.text.config(state=Tkinter.NORMAL)
-      self.text.insert(Tkinter.END, message + "\n")
-      self.text.config(state=Tkinter.DISABLED)
-
-def Daemon():
-  queue = Queue.Queue()
-  rthread = threading.Thread(target=read_thread_func, args=(queue,))
-  rthread.daemon = True
-  rthread.start()
-  read_ctrl_func()
-  sys.exit(0)
-
-def Main():
-  if not Tkinter:
-    send_message('"Tkinter python module wasn\'t found. Running in headless ' +
-                 'mode. Please consider installing Tkinter."')
-    read_thread_func(None)
-    sys.exit(0)
-
-  queue = Queue.Queue()
-  main_window = NativeMessagingWindow(queue)
-  main_window.master.title('Native Messaging Example')
-
-  thread = threading.Thread(target=read_thread_func, args=(queue,))
-  thread.daemon = True
-  thread.start()
-
-  main_window.mainloop()
-  sys.exit(0)
-
-
-if __name__ == '__main__':
-  if gDaemon:   Daemon()
-  else:         Main()
-
diff --git a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json b/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
deleted file mode 100644
index 2118005..0000000
--- a/chrome/common/extensions/docs/examples/api/cimsg/org.chromium.cimsg.json
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-{
-  "name": "org.chromium.cimsg",
-  "description": "Chromium Native Messaging For CI",
-  "path": "HOST_PATH",
-  "type": "stdio",
-  "allowed_origins": [
-    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
-  ]
-}
-- 
1.7.9.5


From cccf21a9c58182e21d2c40fce95afe71b4a094eb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:06:35 -0800
Subject: [PATCH 062/128] refine cictrl

---
 .../docs/examples/api/cictrl/content_scripts.js    |    1 +
 .../docs/examples/api/cictrl/manifest.json         |    2 +-
 .../api/cictrl/res/native-messaging-cictrl         |    2 +-
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
index 745d2ff..d22f883 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
+++ b/chrome/common/extensions/docs/examples/api/cictrl/content_scripts.js
@@ -1,4 +1,5 @@
 function log(msg) {
+    msg = "[CI] " + msg;
     //alert(msg);
     console.log(msg);
 }
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
index e86769b..15a90c6 100644
--- a/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
+++ b/chrome/common/extensions/docs/examples/api/cictrl/manifest.json
@@ -21,7 +21,7 @@
     "content_scripts": [
         {
             "matches" : ["mmt://*/*", "http://*/*", "file://*/*"],
-            "run_at" : "document_end",
+            "run_at" : "document_start",
             "js" : ["content_scripts.js"]
         }
     ]
diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
index 787b81e..94d6a43 100755
--- a/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/native-messaging-cictrl
@@ -48,7 +48,7 @@ def read_ctrl_func():
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.sendto("@quit", (host,port))
   sock.close()
-  time.sleep(3)
+  time.sleep(1)
   
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
   sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-- 
1.7.9.5


From febe5ce5538842172bbfa4125690f9657abedcc6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:07:11 -0800
Subject: [PATCH 063/128] refine ci control

---
 net/mmt/mmt_control.cc |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 5dfc760..1f6ca2f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -169,12 +169,14 @@ void MmtControl::CheckEvent() {
                 cixml->parser = new CiParser(xml);
             }
             next_status = "loading";
+            Wait(100);
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
                 parser->ParseHtmlTag();
             }
             next_status = "loaded";
+            Wait(100);
         }else if (cixml->status == "loaded") {
             if (parser) {
                 std::string divjs, mediajs;
@@ -187,6 +189,7 @@ void MmtControl::CheckEvent() {
                 js += ", ";
                 js += "\"js\" : \"" + divjs + mediajs + "\"";
                 js += "}";
+                Wait(1000);
                 LOG(INFO) << __func__ << " js => " << js;
                 SendToHost(js, "127.0.0.1", 54321);
             }
-- 
1.7.9.5


From ed538ff1fff318d5900af2bb233b0fe5ac3cd68f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 28 Jan 2015 04:11:38 -0800
Subject: [PATCH 064/128] add docs for util

---
 net/mmt/mmt_inc.h    |   27 +++++++++++++++++++++++++++
 net/mmt/mmt_utils.cc |    5 +++++
 2 files changed, 32 insertions(+)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 485621b..bdac625 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -37,12 +37,39 @@
 
 namespace mmt{
 
+/**
+ * Wait millseconds
+ */
 void Wait(int ms);
+
+/**
+ * Convert int to string with fill 0 of width.
+ */
 std::string Int2String(int value, int width=0);
+
+/**
+ * Convert string to int
+ */
 int String2Int(std::string value);
+
+/**
+ * Convert GURL to file path
+ */
 std::string GURL2FilePath(GURL gurl);
+
+/**
+ * Parse models with ?k1=v1&k2=v2
+ */
 std::string GetQueryValue(std::string query, std::string key);
+
+/**
+ * Parse models with n1-n2, n1-.
+ */
 bool GetRangeValue(std::string range, int &lval, int &rval);
+
+/**
+ * Send to some host with msg over UDP
+ */
 int SendToHost(std::string msg, std::string szaddr, int port);
 
 }
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 76b9776..2aba4aa 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -5,6 +5,7 @@ namespace mmt {
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
+
 std::string Int2String(int value, int width) {
     std::string szval;
     std::stringstream sstr;
@@ -15,6 +16,7 @@ std::string Int2String(int value, int width) {
     sstr >> szval;
     return szval;
 }
+
 int String2Int(std::string value) {
     int ival = -1;
     std::stringstream sstr;
@@ -22,6 +24,7 @@ int String2Int(std::string value) {
     sstr >> ival;
     return ival;
 }
+
 std::string GURL2FilePath(GURL gurl) {
     std::string szpath;
     base::FilePath file_path;
@@ -31,6 +34,7 @@ std::string GURL2FilePath(GURL gurl) {
     }
     return szpath;
 }
+
 std::string GetQueryValue(std::string query, std::string key) {
     std::string value;
     std::string::size_type begin, end;
@@ -46,6 +50,7 @@ std::string GetQueryValue(std::string query, std::string key) {
     }
     return value;
 }
+
 bool GetRangeValue(std::string range, int &lval, int &rval) {
     bool bok = false;
     std::string lstr = "0";
-- 
1.7.9.5


From d7e5e7579da635202fef2264d46ce175f6c463a6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 3 Feb 2015 22:03:15 -0800
Subject: [PATCH 065/128] [todo] to process ci begin/end/click

---
 net/mmt/mmt_control.cc |   41 +++--
 net/mmt/mmt_parser.cc  |  395 ++++++++++++++++++++++++++++++++----------------
 net/mmt/mmt_parser.h   |   82 +++++-----
 net/mmt/mmt_stream.cc  |   10 +-
 4 files changed, 334 insertions(+), 194 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 1f6ca2f..19785ef 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -150,6 +150,13 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
+void GetJsonData(int tabid, std::string js, std::string& json) {
+    json += "{";
+    json += "\"tabid\" : " + Int2String(tabid);
+    json += ", ";
+    json += "\"js\" : \"" + js + "\"";
+    json += "}";
+}
 void MmtControl::CheckEvent() {
     // TODO for testing
     std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
@@ -176,22 +183,16 @@ void MmtControl::CheckEvent() {
                 parser->ParseHtmlTag();
             }
             next_status = "loaded";
-            Wait(100);
+            Wait(1000);
         }else if (cixml->status == "loaded") {
             if (parser) {
-                std::string divjs, mediajs;
-                parser->GetDivJS(divjs);
-                parser->GetMediaJS(0, mediajs);
-
                 std::string js;
-                js += "{";
-                js += "\"tabid\" : " + Int2String(iter->first);
-                js += ", ";
-                js += "\"js\" : \"" + divjs + mediajs + "\"";
-                js += "}";
-                Wait(1000);
-                LOG(INFO) << __func__ << " js => " << js;
-                SendToHost(js, "127.0.0.1", 54321);
+                if(parser->GetHtmlJS(0, js) && !js.empty()) {
+                    std::string json;
+                    GetJsonData(iter->first, js, json);
+                    LOG(INFO) << __func__ << " json => " << json;
+                    SendToHost(json, "127.0.0.1", 54321);
+                }
             }
             next_status = "end";
         }
@@ -208,14 +209,12 @@ void TestXmlParser() {
     parser->ParseXml();
     parser->ParseHtmlTag();
     std::string js;
-    parser->GetDivJS(js);
-    LOG(INFO) << __func__ << " div js: " << js;
-    parser->GetMediaJS(0, js);
-    LOG(INFO) << __func__ << " media js1: " << js;
-    parser->GetMediaJS(1080, js);
-    LOG(INFO) << __func__ << " media js2: " << js;
-    parser->GetMediaJS(1086, js);
-    LOG(INFO) << __func__ << " media js3: " << js;
+    parser->GetHtmlJS(0, js);
+    LOG(INFO) << __func__ << " js1: " << js;
+    parser->GetHtmlJS(1080, js);
+    LOG(INFO) << __func__ << " js2: " << js;
+    parser->GetHtmlJS(1086, js);
+    LOG(INFO) << __func__ << " js3: " << js;
 }
 
 /**
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 45a7f72..3e5d17a 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -26,6 +26,14 @@ static const char kbegin[]      = "mmtci:begin";
 static const char kend[]        = "mmtci:end";
 static const char kstyle[]      = "style";
 
+/**
+ * Event constatnts for the value of kbegin and kend
+ */
+static const char kevinf[]      = "indefinite";
+static const char kevbegin[]    = ".begin";
+static const char kevend[]      = ".end";
+static const char kevclick[]    = ".click";
+
 
 /**
  * callback functions for libxml2's sax parser
@@ -77,36 +85,59 @@ static void init_sax(xmlSAXHandlerPtr sax) {
 /**
  * Utils for generating javascript 
  */
-inline std::string GetObject(std::string id) {
-    return "g_"+id+"=document.getElementById('"+id+"');";
+inline std::string GetJSObject(std::string id) {
+    return "g_"+id+" = document.getElementById('"+id+"');";
 }
-inline std::string SetAttr(std::string id, std::string name, std::string value) {
-    return "g_"+id+"."+name+"='"+value+"';";
+inline std::string SetJSBegin(std::string id) {
+    return "if(g_"+id+" != undefined) {";
 }
-inline std::string CallFunc(std::string id, std::string name) {
+inline std::string SetJSAttr(std::string id, std::string name, std::string value) {
+    return "g_"+id+"."+name+" = '"+value+"';";
+}
+inline std::string SetJSFunc(std::string id, std::string name) {
     std::string func = "g_"+id+"."+name;
-    return "if("+func+"!=undefined){" + func + "();}";  
+    return "if("+func+" != undefined) {" + func + "();}";  
+}
+inline std::string SetJSEvent(std::string id, std::string name, std::string value) {
+    std::string func = "g_"+id+"."+name;
+    return "if("+func+" != undefined) {" + func + " = function() {" + value + "}}";  
+}
+inline std::string SetJSEnd() {
+    return "}";
 }
 
 /**
- * To parse CI's time
+ * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
  */
-int ParseTimeStr(std::string timestr) {
-    int sec = atoi(timestr.c_str());
+long ParseTimeStr(std::string timestr) {
+    long ms = 0;
+    if (timestr == kevinf) {
+        return -1;
+    }
+
+#if 1
+    long sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
     rpos = timestr.rfind(":");
     if (lpos != std::string::npos) {
         if (lpos != rpos) {
             sec = sec * 3600;
-            sec = sec + 60 * atoi(timestr.substr(lpos+1).c_str());
-            sec = sec + atoi(timestr.substr(rpos+1).c_str());
+            sec = sec + 60 * atol(timestr.substr(lpos+1).c_str());
+            sec = sec + atol(timestr.substr(rpos+1).c_str());
         }else {
             sec = sec * 60;
-            sec = sec + atoi(timestr.substr(lpos+1).c_str());
+            sec = sec + atol(timestr.substr(lpos+1).c_str());
         }
     }
-    return sec;
+    ms = sec * 1000;
+#else
+    Time time;
+    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+        return 0;
+    ms = (long)base::Time::ToJsTime(); //milliseconds
+#endif
+    return ms;
 }
 
 
@@ -115,24 +146,23 @@ int ParseTimeStr(std::string timestr) {
 
 namespace mmt {
 
+event_t::event_t() {
+    is_event = false;   // default is time
+    is_timeout = 0;     // default non-timeout, that will be processed next time
+    time = -1;          // default infinite
+}
+
 node_t::node_t(std::string name) 
     : name(name), parent(nullptr) {
-    time.first = time.second = -1;
 }
 node_t::~node_t() {
     nodes.clear();
     parent = nullptr;
 }
 
-html_div_t::html_div_t() {
-}
-html_div_t::~html_div_t() {
-}
-
-html_media_t::html_media_t() {
-    time.first = time.second = -1;
+html_t::html_t() {
 }
-html_media_t::~html_media_t() {
+html_t::~html_t() {
 }
 
 
@@ -145,6 +175,8 @@ CiParser::~CiParser() {
 
 bool CiParser::ParseXml() {
     if (fname_.empty()) return false;
+    root_ = nullptr;
+    cur_ = nullptr;
 
     xmlSAXHandler sax;
     xmlParserCtxtPtr ctxt;
@@ -168,96 +200,207 @@ bool CiParser::ParseXml() {
 
     return true;
 }
+void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
+    if (!node) return;
+
+    std::string id;
+    if (node->name == kdivLocation)
+        id = node->attrs[krefDiv];
+    else if (node->name == kMediaSync)
+        id = node->attrs[krefId];
+    if (id.empty()) return;
+
+    std::string js0, js1;       // for time
+    std::string js00, js11;     // for click event
+    js0 = js1 = SetJSBegin(id);
+    js00 = js11 = SetJSBegin(id);
+
+    std::string style = node->attrs[kstyle];
+    if (!style.empty()) {
+        js0 += SetJSAttr(id, "style", style);
+        js1 += SetJSAttr(id, "style", style);
+    }
+
+    if (node->name == kMediaSync) {
+        // set media src
+        nodeptrs_t::iterator iter = node->nodes.begin();
+        for (; iter != node->nodes.end(); iter++) {
+            nodeptr_t sub = *iter;
+            if (sub->name != ksourceList) continue;
+            std::string src = sub->attrs[kmediaSrc];
+            js0 += SetJSAttr(id, "src", src);
+            js1 += SetJSAttr(id, "src", "");
+            break;
+        }
+        js0 += SetJSFunc(id, "play");
+    }
 
+    htmlptr_t html = new html_t;
+    html->node = node;
+    html->js[EHtmlBegin] = js0;
+    html->js[EHtmlEnd] = js1;
+    html->js[EHtmlClickBegin] = js00;
+    html->js[EHtmlClickEnd] = js11;
+    htmls[id] = html;
+}
+void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
+    if (!event.is_event || (event.event != kevbegin && event.event != kevend)) 
+        return;
+
+    event.is_event = false;
+    event.time = -1;
+    if (htmls_.find(event.id) != htmls_.end()) {
+        htmlptr_t html = htmls_[event.id];
+        // only support 1 level
+        if (event.event == kevbegin)
+            event.time = html->node->time.begin.time;
+        else
+            event.time = html->node->time.end.time; 
+    }
+}
 bool CiParser::ParseHtmlTag() {
     nodeptr_t node = root_;
     if (!node) return false;
+    htmls_.clear();
+
+    nodeptrs_t::iterator iter1;
 
-    nodeptrs_t::iterator iter = node->nodes.begin();
-    for (; iter != node->nodes.end(); iter++) {
-        nodeptr_t sub = *iter;
-        if (sub->name == kview) {
-            nodeptrs_t::iterator iter2 = sub->nodes.begin();
-            for (; iter2 != sub->nodes.end(); iter2++) {
+    // init html js
+    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2 = sub1->nodes.begin();
+            for (; iter2 != sub1->nodes.end(); iter2++) {
                 nodeptr_t sub2 = *iter2;
-                if (sub2->name != kdivLocation) 
-                    continue;
-                if (sub2->attrs.find(krefDiv) == sub2->attrs.end())
-                    continue;
-
-                divptr_t div = new html_div_t;
-                div->id = sub2->attrs[krefDiv];
-                div->style = sub2->attrs[kstyle];
-                divs_.push_back(div);
-            }
-        }else if (sub->name == kMediaSync) {
-            if (sub->attrs.find(krefId) == sub->attrs.end())
-                continue;
-
-            mediaptr_t media = new html_media_t;;
-            media->id = sub->attrs[krefId];
-            media->time = sub->time;
-            media->style = sub->attrs[kstyle];
-            if (sub->attrs.find(kmediaSrc) != sub->attrs.end()) {
-                media->srcs.push_back(sub->attrs[kmediaSrc]);
-            }else {
-                nodeptrs_t::iterator iter2 = sub->nodes.begin();
-                for (; iter2 != sub->nodes.end(); iter2++) {
-                    nodeptr_t sub2 = *iter2;
-                    if (sub2->name == ksourceList) {
-                        if (sub2->attrs.find(kmediaSrc) != sub2->attrs.end())
-                            media->srcs.push_back(sub2->attrs[kmediaSrc]);
-                    }
+                if (sub2->name == kdivLocation) {
+                    LOG(INFO) << __func__ << " process view's " << kdivLocation;
+                    InitHtmlJS(sub2, htmls_);
                 }
             }
-            medias_.push_back(media);
+        }else if (sub1->name == kdivLocation) { // krefDiv of <div>
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+            InitHtmlJS(sub1, htmls_);
+        }else if (sub1->name == kMediaSync) {   // krefId of <img>, <audio>, <video>
+            LOG(INFO) << __func__ << " process top " << sub1->name;
+            InitHtmlJS(sub1, htmls_);
         }
     }
-    return true;
-}
 
-bool CiParser::GetDivJS(std::string& divjs) {
-    if (divs_.empty()) return false;
 
-    divjs = "";
-    std::vector<divptr_t>::iterator iter = divs_.begin();
-    for (; iter != divs_.end(); iter++) {
-        divptr_t div = *iter;
-        if (!div->style.empty()) {
-            divjs += GetObject(div->id);
-            divjs += SetAttr(div->id, "style", div->style);
+    //
+    // process html js
+    htmlmap_t::iterator iter;
+
+    // end for time
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        html->js[EHtmlBegin] += SetJSEnd();
+        html->js[EHtmlEnd] += SetJSEnd();
+    }
+
+    // process interaction events
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        event_t begin = node->time.begin;
+        if (begin.is_event) {
+            if (begin.event == kevclick) {
+                std::string js = SetJSEvent(begin.id, "onclick", html->js[EHtmlBegin]);
+                htmls_[begin.id]->js[EHtmlClickBegin] += js;
+            }else if (begin.event == kevbegin || begin.event == kevend) {
+                SetNodeTime(node->time.begin, node);
+            }
+
+        }
+
+        event_t end = node->time.end;
+        if (end.is_event) {
+            if (end.event == kevclick) {
+                std::string js = SetJSEvent(end.id, "onclick", html->js[EHtmlEnd]);
+                htmls_[end.id]->js[EHtmlClickEnd] += js;
+            }else if (end.event == kevbegin || end.event == kevend) {
+                SetNodeTime(node->time.end, node);
+            }
         }
     }
 
+    // end for event click
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        html->js[EHtmlClickBegin] += SetJSEnd();
+        html->js[EHtmlClickEnd] += SetJSEnd();
+    }
     return true;
 }
 
-bool CiParser::GetMediaJS(long current, std::string& mediajs) {
-    if (medias_.empty()) return false;
-
-    mediajs = "";
-    std::vector<mediaptr_t>::iterator iter = medias_.begin();
-    for (; iter != medias_.end(); iter++) {
-        mediaptr_t media = *iter;
-        int begin = media->time.first;
-        int end = media->time.second;
-        if (begin < 0) continue;
-        if (current < begin) continue;
-
-        std::string id = media->id;
-        bool bstart = (current<end || end<0);
-        if (bstart) {
-            mediajs += GetObject(id);
-            if (!media->srcs.empty()) {
-                mediajs += SetAttr(id, "src", media->srcs[0]);
-            }
-            mediajs += CallFunc(id, "play");
-        }else {
-            mediajs += GetObject(id);
-            mediajs += SetAttr(id, "src", "");
-            mediajs += CallFunc(id, "stop");
+/**
+ * To process both @begin and @end
+ */
+bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
+    long curtime = -1;
+    if (!cnode) return false;
+
+    event_t begin = cnode->time.begin;
+    if (begin.is_timeout > 0) return false;
+
+    if (begin.event == kevclick) {
+        ev = EHtmlClickBegin;
+        cnode->time.begin.is_timeout = 1;
+        return true;
+    }else {
+        ev = EHtmlBegin;
+        curtime = begin.time;
+    }
+
+    // search cnode's parent
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.begin.is_event) {
+            if (node->time.begin.time >= 0 && node->time.begin.time > curtime)
+                curtime = node->time.begin.time;
+        }
+    }while(true);
+
+    LOG(INFO) << __func__ << " node name=" << begin.id << " curtime=" << curtime << " current=" << current;
+    if (curtime < 0 || curtime <= current) {
+        cnode->time.begin.is_timeout = 1;
+        return true;
+    }
+    return false;
+}
+bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
+    return false;
+}
+bool CiParser::GetHtmlJS(long current, std::string& js) {
+    js = "";
+    if (htmls_.empty()) return false;
+
+    std::string js1, js2;
+
+    // init js object
+    htmlmap_t::iterator iter;
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        std::string id = iter->first;
+        js1 += GetJSObject(id);
+    }
+
+    // add js process
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        int ev;
+        if (ShouldBeginTime(current, node, ev)) {
+            js2 += html->js[ev];
+        }
+        if (ShouldEndTime(current, node, ev)) {
+            js2 += html->js[ev];
         }
     }
+
+    if (!js2.empty()) js = js1 + js2;
+
     return true;
 }
 
@@ -287,57 +430,47 @@ bool CiParser::EndNode(std::string name) {
     return true;
 }
 
-bool ParseTimeById(nodeptr_t node, std::string value, int& second) {
-    bool is_begin = true;
+/**
+ * To parse the content of mmtci::begin or mmtci:end to event_t
+ */
+bool ParseTimeEvent(std::string value, event_t& event) {
+    // time's event
     std::string::size_type pos;
+    do {
+        pos = value.find(kevclick);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevbegin);
+        if (pos != std::string::npos) break;
+        pos = value.find(kevend);
+        if (pos != std::string::npos) break;
+    }while(false);
 
-    pos = value.find(".click");
     if (pos != std::string::npos) {
-        // todo: proc click event
-        return true;
-    }
-
-    pos = value.find(".begin");
-    if (pos == std::string::npos) {
-        is_begin = false;
-        pos = value.find(".end");
-    }
-
-    if (pos == std::string::npos) {
-        second = ParseTimeStr(value);
-        return true;
-    }
-
-    second = -2;
-    std::string idstr = value.substr(0, pos);
-    nodeptrs_t::iterator iter = node->nodes.begin();
-    for (; iter != node->nodes.end(); iter++) {
-        nodeptr_t sub = *iter;
-        if (sub->name == kMediaSync) {
-            if (sub->attrs[krefId] == idstr) {
-                std::string timestr = (is_begin) ? sub->attrs[kbegin] : sub->attrs[kend];
-                second = ParseTimeStr(timestr);
-                break;
-            }
-        }
+        event.is_event = true;
+        event.id = value.substr(0, pos);
+        event.event = value.substr(pos);
+        LOG(INFO) << __func__ << " event.id=" << event.id << " event.event=" << event.event;
+    }else {
+        event.is_event = false;
+        event.time = ParseTimeStr(value);
+        LOG(INFO) << __func__ << " event.time=" << event.time;
     }
     return true;
 }
 
 bool CiParser::AddAttr(std::string name, std::string value) {
-    //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
-    //    << " attr: " << name << " => " << value;
     if (!cur_) return false;
     cur_->attrs[name] = value;
     if (name == kbegin || name == kend) {
-        int sec = -2;
-        ParseTimeById(root_, value, sec);
-        if (name == kbegin)
-            cur_->time.first = sec;
-        else
-            cur_->time.second = sec;
-        //LOG(INFO) << __func__ << " name=" << name << " sec=" << sec; 
+        //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
+        //    << " attr: " << name << " => " << value;
     }
+    if (name == kbegin) {
+        ParseTimeEvent(value, cur_->time.begin);
+    }else if (name == kend) {
+        ParseTimeEvent(value, cur_->time.end);
+    }
+
     return true;
 }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 7b84035..8eef4a8 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -16,7 +16,30 @@ struct node_t;
 typedef scoped_refptr<node_t> nodeptr_t;
 typedef std::map<std::string, std::string> attrs_t;
 typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
-typedef std::pair<long, long> range_t;
+
+
+/**
+ * Structore for mmtci:begin and mmtci:end
+ */
+enum EHtmlEvent{
+    EHtmlBegin,
+    EHtmlEnd,
+    EHtmlClickBegin,
+    EHtmlClickEnd,
+};
+
+struct event_t {
+    event_t();
+    bool is_event;
+    int is_timeout;
+    std::string id;
+    std::string event;
+    long time;          // ms, valid if no id
+};
+struct citime_t {
+    event_t begin;
+    event_t end;
+};
 
 
 /**
@@ -28,8 +51,9 @@ public:
 
     std::string name;
     attrs_t attrs;
-    range_t time;     // for time range
-    nodeptrs_t nodes; // sub-nodes
+    citime_t time;      // for time range
+
+    nodeptrs_t nodes;   // sub-nodes
     nodeptr_t parent;
 
 protected:
@@ -37,41 +61,20 @@ protected:
     virtual ~node_t();
 };
 
-
-/** 
- * Structure for html tag <div>
- */
-struct html_div_t : public base::RefCounted<html_div_t> {
-public: 
-    explicit html_div_t();
-
-    std::string id; // tag id
-    std::string style;
-
-protected:
-    friend class base::RefCounted<html_div_t>;
-    virtual ~html_div_t();
-};
-typedef scoped_refptr<html_div_t> divptr_t;
-
-
-/** 
- * Sturcture for tags of html <img>, <audio> and <video>
- */
-struct html_media_t : public base::RefCounted<html_media_t> { 
+typedef std::map<int, std::string> jsmap_t;  // k/v: EHtmlEvent => ..
+struct html_t : public base::RefCounted<html_t>{
 public:
-    explicit html_media_t();
-
-    std::string id;     // tag id
-    range_t time;       // [begin, end]
-    std::string style;
-    std::vector<std::string> srcs;    //src list
+    explicit html_t();
+    std::string id;
+    jsmap_t js;
+    nodeptr_t node;
 
 protected:
-    friend class base::RefCounted<html_media_t>;
-    virtual ~html_media_t();
+    friend class base::RefCounted<html_t>;
+    virtual ~html_t();
 };
-typedef scoped_refptr<html_media_t> mediaptr_t;
+typedef scoped_refptr<html_t> htmlptr_t;
+typedef std::map<std::string, htmlptr_t> htmlmap_t; // k/v: tag id => ..
 
 
 /** 
@@ -83,9 +86,11 @@ public:
 
     bool ParseXml();
     bool ParseHtmlTag();
+    bool GetHtmlJS(long current, std::string& js);
 
-    bool GetDivJS(std::string& divjs);
-    bool GetMediaJS(long current, std::string& mediajs);
+    void SetNodeTime(event_t& event, nodeptr_t node);
+    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
 
     bool AddNode(std::string name);
     bool EndNode(std::string name);
@@ -98,10 +103,9 @@ protected:
 private:
     std::string fname_;
     nodeptr_t root_;
-    nodeptr_t cur_; // only for AddNode and AddAttr
+    nodeptr_t cur_; // only for AddNode/AddAttr
 
-    std::vector<divptr_t> divs_;
-    std::vector<mediaptr_t> medias_;
+    htmlmap_t htmls_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 06600da..e9aa6a7 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -43,7 +43,7 @@ static uint64_t mmtp_tell(stream_t *s) {
 static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
-static stream_t* InitMpuStream(Stream* ptr) {
+stream_t* InitMpuStream(Stream* ptr) {
     stream_t* s = (stream_t*)malloc(sizeof(stream_t));
     s->opaque = (void*)ptr;
     s->open = mmtp_open;
@@ -122,9 +122,9 @@ void* Stream::Open(const char* filename, int mode) {
 
         std::string mtype = GetQueryValue(url_.query(), "type");
         if (mtype == "audio") {
-            fname = fname + "/audio/Channel1_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
+            fname = fname + "/audio/loveapartment_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == "video") {
-            fname = fname + "/video/Channel1_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
+            fname = fname + "/video/loveapartment_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
         }
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
@@ -141,6 +141,7 @@ void* Stream::Open(const char* filename, int mode) {
     if (ierr != 0) return nullptr; 
 
     if (index != -1 && index != midx_.begin) {
+#if 1
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
@@ -156,6 +157,9 @@ void* Stream::Open(const char* filename, int mode) {
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
+#else
+        offmap_[index] = offset_t(0, lret);
+#endif
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
-- 
1.7.9.5


From a9af6db45debf43a7289f7735f9b659b86ea04d6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 05:56:35 -0800
Subject: [PATCH 066/128] [todo] add ntp interface to process event

---
 net/mmt/mmt_control.cc      |    7 +++---
 net/mmt/mmt_inc.h           |    5 +++++
 net/mmt/mmt_parser.cc       |   52 ++++++++++++++++++++++++++++++-------------
 net/mmt/mmt_utils.cc        |   12 ++++++++++
 net/mmt/mpu/moof_combine.sh |   19 ++++++++++++++++
 5 files changed, 77 insertions(+), 18 deletions(-)
 create mode 100644 net/mmt/mpu/moof_combine.sh

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 19785ef..acb27d4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -167,7 +167,7 @@ void MmtControl::CheckEvent() {
         if (!cixml) continue;
         if (cixml->status == "end") continue;
 
-        LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
         std::string next_status = cixml->status;
         CiParserPtr parser = cixml->parser;
 
@@ -187,14 +187,15 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loaded") {
             if (parser) {
                 std::string js;
-                if(parser->GetHtmlJS(0, js) && !js.empty()) {
+                long ntp = GetNTPTime();
+                if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
                 }
             }
-            next_status = "end";
+            //next_status = "end";
         }
         cixml->status = next_status;
     }
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index bdac625..74a0dea 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -72,6 +72,11 @@ bool GetRangeValue(std::string range, int &lval, int &rval);
  */
 int SendToHost(std::string msg, std::string szaddr, int port);
 
+/**
+ *
+ */
+long GetNTPTime();
+
 }
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 3e5d17a..cd71f93 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -99,8 +99,7 @@ inline std::string SetJSFunc(std::string id, std::string name) {
     return "if("+func+" != undefined) {" + func + "();}";  
 }
 inline std::string SetJSEvent(std::string id, std::string name, std::string value) {
-    std::string func = "g_"+id+"."+name;
-    return "if("+func+" != undefined) {" + func + " = function() {" + value + "}}";  
+    return "g_"+id+"."+name+" = function() {" + value + "}";  
 }
 inline std::string SetJSEnd() {
     return "}";
@@ -221,18 +220,33 @@ void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
         js1 += SetJSAttr(id, "style", style);
     }
 
+    // set media src
     if (node->name == kMediaSync) {
-        // set media src
-        nodeptrs_t::iterator iter = node->nodes.begin();
-        for (; iter != node->nodes.end(); iter++) {
-            nodeptr_t sub = *iter;
-            if (sub->name != ksourceList) continue;
-            std::string src = sub->attrs[kmediaSrc];
+        bool bfind = false;
+        // for <img>
+        if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
+            std::string src = node->attrs[kmediaSrc];
             js0 += SetJSAttr(id, "src", src);
             js1 += SetJSAttr(id, "src", "");
-            break;
+            bfind = true;
+        }else {
+            // for <audio> <video>
+            nodeptrs_t::iterator iter = node->nodes.begin();
+            for (; iter != node->nodes.end(); iter++) {
+                nodeptr_t sub = *iter;
+                if (sub->name != ksourceList) continue;
+                std::string src = sub->attrs[kmediaSrc];
+                js0 += SetJSAttr(id, "src", src);
+                js1 += SetJSAttr(id, "src", "");
+                bfind = true;
+                break;
+            }
+        }
+
+        if (bfind) {
+            js0 += SetJSFunc(id, "play");
+            js1 += SetJSFunc(id, "pause");
         }
-        js0 += SetJSFunc(id, "play");
     }
 
     htmlptr_t html = new html_t;
@@ -387,15 +401,23 @@ bool CiParser::GetHtmlJS(long current, std::string& js) {
     }
 
     // add js process
+    int ev;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
-        int ev;
-        if (ShouldBeginTime(current, node, ev)) {
-            js2 += html->js[ev];
-        }
         if (ShouldEndTime(current, node, ev)) {
-            js2 += html->js[ev];
+            if (ev == EHtmlClickEnd)
+                html = htmls_[node->time.end.id];
+            if (html) js2 += html->js[ev];
+        }
+    }
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        if (ShouldBeginTime(current, node, ev)) {
+            if (ev == EHtmlClickBegin)
+                html = htmls_[node->time.begin.id];
+            if (html) js2 += html->js[ev];
         }
     }
 
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 2aba4aa..ddcba66 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -102,5 +102,17 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
+long GetNTPTime() {
+    static long _last = 0;
+
+    struct timeval tv;
+    memset(&tv, 0, sizeof(tv));
+    gettimeofday(&tv, NULL);
+    long current = tv.tv_sec*1000 + tv.tv_usec/1000;
+    if (_last == 0) {
+        _last = current;
+    }
+    return current - _last;
+}
 
 } // namespace mmt
diff --git a/net/mmt/mpu/moof_combine.sh b/net/mmt/mpu/moof_combine.sh
new file mode 100644
index 0000000..5b6cf0e
--- /dev/null
+++ b/net/mmt/mpu/moof_combine.sh
@@ -0,0 +1,19 @@
+
+rm -rf audio
+mkdir -p audio
+
+apath="/home/yongzxu/Downloads/MPUFile/"
+apath="/home/yongzxu/Videos/mmt/loveapartment_0203/audio"
+name="loveapartment_Audio1_MPU"
+offset=1037
+
+for i in `seq 1 99`; do
+    [ $i -lt 10 ] && ./cutfile $apath/${name}_000$i.mp4 $offset audio/t$i.mp4 && continue
+    [ $i -lt 100 ] && ./cutfile $apath/${name}_00$i.mp4 $offset audio/t$i.mp4 && continue
+    [ $i -lt 250 ] && ./cutfile $apath/${name}_0$i.mp4 $offset audio/t$i.mp4 && continue
+done
+
+cp -f $apath/${name}_0000.mp4 /tmp/test_audio.mp4
+for i in `seq 1 99`; do
+    cat audio/t$i.mp4 >> /tmp/test_audio.mp4
+done
-- 
1.7.9.5


From a1e5262300701487c0063d9d275dfe591641bac6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 09:03:04 -0800
Subject: [PATCH 067/128] [todo] add ntp module

---
 net/mmt/mmt_inc.h       |    3 +-
 net/mmt/mmt_utils.cc    |   30 +-
 net/mmt/ntp/HOWTO       |  177 ++++++++++++
 net/mmt/ntp/Makefile    |   37 +++
 net/mmt/ntp/ntp.gyp     |   80 +++++
 net/mmt/ntp/ntpclient.c |  739 +++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/ntp/ntpclient.h |   18 ++
 net/mmt/ntp/phaselock.c |  339 ++++++++++++++++++++++
 net/net.gyp             |    1 +
 9 files changed, 1416 insertions(+), 8 deletions(-)
 create mode 100644 net/mmt/ntp/HOWTO
 create mode 100644 net/mmt/ntp/Makefile
 create mode 100644 net/mmt/ntp/ntp.gyp
 create mode 100644 net/mmt/ntp/ntpclient.c
 create mode 100644 net/mmt/ntp/ntpclient.h
 create mode 100644 net/mmt/ntp/phaselock.c

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 74a0dea..9a5761a 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -73,8 +73,9 @@ bool GetRangeValue(std::string range, int &lval, int &rval);
 int SendToHost(std::string msg, std::string szaddr, int port);
 
 /**
- *
+ * Get local/ntp time (ms)
  */
+long GetLocalTime();
 long GetNTPTime();
 
 }
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index ddcba66..6ff147e 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -1,5 +1,7 @@
 #include "net/mmt/mmt_inc.h"
 
+#include "net/mmt/ntp/ntpclient.h"
+
 namespace mmt {
 
 void Wait(int ms) {
@@ -102,17 +104,31 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
-long GetNTPTime() {
-    static long _last = 0;
-
+long GetLocalTime() {
     struct timeval tv;
     memset(&tv, 0, sizeof(tv));
     gettimeofday(&tv, NULL);
-    long current = tv.tv_sec*1000 + tv.tv_usec/1000;
-    if (_last == 0) {
-        _last = current;
+    return tv.tv_sec*1000 + tv.tv_usec/1000;
+}
+
+long GetNTPTime() {
+    static long _lastntp = 0;   // ntp time
+    static long _last = 0;      // local tome
+
+    if (_lastntp == 0) {
+        struct ntp_time_t ntp_time;
+        int iret = ntp_get_time("time.apple.com", &ntp_time);
+        _last = GetLocalTime();
+        if (iret == 0)
+            _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
+        else
+            _lastntp = _last;
+        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last;
     }
-    return current - _last;
+
+    long diff = GetLocalTime() - _last;
+    //long currentntp = _lastntp + diff;
+    return diff;
 }
 
 } // namespace mmt
diff --git a/net/mmt/ntp/HOWTO b/net/mmt/ntp/HOWTO
new file mode 100644
index 0000000..cf0e7429
--- /dev/null
+++ b/net/mmt/ntp/HOWTO
@@ -0,0 +1,177 @@
+The goal of ntpclient is not only to set your computer's clock
+right once, but keep it there.
+
+First, a note on typical 1990's and 2000's computer crystals.  They
+are truly pathetic.  A "real" crystal oscillator (TCXO) usually has
+an initial set error of less than 5 ppm, and variation over time, voltage,
+and temperature measured in tenths of a ppm (and an OCXO can reach 0.3 ppm
+stability over ten years and 85C temperature swing).  The devices used
+in conventional PC motherboards and single board computers, however,
+often have initial set errors up to 150 ppm, and will vary 5 ppm over
+the course of a day-night cycle in a pseudo-air-conditioned space.
+
+[Operating system software can sometimes exacerbate the problem.  I
+have seen some i686 Red Hat 7.3 systems run the clock at 512 Hz, or 953
+microseconds per tick, giving a built in 64 ppm error.  Even the normally
+exemplary DEC Alpha has, when run with Linux, a truly awful calibration
+scheme; Linux runs it with a nominal ticks per second of 1024, which
+gives a tick value of 977, theoretical additional error -448 ppm, actual
+frequency observed -443.7 ppm.]
+
+Still, the pattern is clear: the first and largest error of a crystal
+is its initial set error.  I strongly urge the calibration of each computer,
+and storing its frequency error in a non-volatile medium, before you
+do anything else with time setting and locking.  While you could do it
+in a few seconds using an accurate frequency counter, below I show a
+software-only method using ntpclient and a high quality NTP server.
+
+To perform the activities described, you need a way to control and monitor
+your system's clock -- both its frequency and value.  On Linux, the
+kernel API is described in adjtimex(2).  There are two programs that
+I know of that provide shell-level access to this interface, both called
+adjtimex(1).
+
+One is written by Steven Dick and Jim Van Zandt, see the adjtimex* files in
+http://metalab.unc.edu/pub/Linux/system/admin/time/
+It uses long options, and includes some interesting functionality beyond
+the basic exposure of adjtimex(2).
+
+I (Larry Doolittle) wrote the other; it uses short options, and has no
+bloat^H^H^H^H^Hextra features.  I include the code here for a standalone
+version; it is also incorporated into busybox (http://www.busybox.net),
+although you may have to select it at compile time, like any other component.
+
+Fortunately (and not coincidentally) the core functions of the two adjtimex
+programs can be used interchangeably, as long as you only use the short option
+variant of the Dick/Van Zandt adjtimex.  The options discussed here are:
+       -f    frequency (integer kernel units)
+       -o    time offset in microseconds
+       -t    kernel tick (microseconds per jiffy)
+
+First, set the time approximately right, as root:
+   ntpclient -s -h $NTPHOST
+You should see a single line printed like
+36765 4980.373    1341.0     39.7  956761.4    839.2  0
+Get used to this line: column headers are
+ 1. day since 1900
+ 2. seconds since midnight
+ 3. elapsed time for NTP transaction (microseconds)
+ 4. internal server delay (microseconds)
+ 5. clock difference between your computer and the NTP server (microseconds)
+ 6. dispersion reported by server (microseconds)
+ 7. your computer's adjtimex frequency (ppm * 65536)
+So in the example above, your computer's clock was a bit more than
+0.95 seconds fast, compared to the clock on $NTPHOST.
+Now check that the clock setting worked.
+   ntpclient -c 1 -h $NTPHOST
+36765 4993.512    1345.0     40.9    3615.3    839.2  0
+So now the time difference is only a few milliseconds.
+
+On to measure the frequency calibration for your system.
+If you're in a hurry, it's OK to only spend 20 minutes on this step.
+    ntpclient -i 60 -c 20 -h $NTPHOST >$(hostname).ntp.log &
+
+Otherwise, you will learn much more about your system and its communication
+with the NTP server by letting the log run for 24 hours.
+    ntpclient -i 300 -c 288 -h $NTPHOST >$(hostname).ntp.log &
+
+Things to watch for in the above log:
+
+If the last column (kernel frequency fine tune) ever changes, you haven't
+turned off other time adjustment programs.  AFAIK the only programs around
+that would move this number are ntpclient and xntpd.  On most out-of-the-box
+systems, that last column should start zero and stay zero.
+
+Use gnuplot to plot the resulting file as follows:
+   plot "HOSTNAME.ntp.log" using (($1-36765)*86400+$2):5:($3+$6) with yerrorbars
+This shows time error (microseconds) as a function of elapsed time (seconds).
+The error bars show the uncertainty in the measurement.  Ideally, it would
+be a smooth, straight line, where the slope represents the frequency error
+of your crystal.
+
+If an occasional point is both off-center and has a large error bar, it shows
+a transaction got delayed somewhere in the process, either inside the server,
+or one of the two UDP packet propagation steps.  This is normal, and ntpclient
+can deal with those quite well.  If points are not evenly spaced on the
+horizontal axis, packets were actually lost; this is less common, but still OK.
+
+If the error bar becomes suddenly large, and takes a few minutes to slowly
+recover, your NTP host (presumably xntpd) had problems communicating with
+_its_ server, and reported that problem to you by increasing its "dispersion"
+(this is a hack, required by xntpd's core incorrect assumption that errors
+in network delays have Gaussian statistics; ntpclient does not have this flaw).
+
+If there are sudden large, persistent steps in error, some other program is
+making step changes to time.  Check for, e.g., ntpdate run as a cron job.
+If your client machine is OK, check for problems on the _host_ machine.
+
+Assuming the graph above is clean, and has non-garbled data for the first
+and last points, you can run it through the enclosed awk script (rate.awk)
+to determine the appropriate frequency value.
+$ awk -f rate.awk <test.dat
+delta-t 119400 seconds
+delta-o -142308 useconds
+slope -1.19186 ppm
+old frequency -1240000 ( -18.9209 ppm)
+new frequency -1318109 ( -20.1127 ppm)
+$
+
+For now, you should plug in the new frequency value
+   adjtimex -f -1318109
+Then reset the clock
+   ntpclient -s -h $NTPHOST
+and ponder how it makes sense in _your_ (possibly embedded) environment
+to have the number -1318109 applied via adjtimex every time your machine
+boots.  Or, simpler still, combine these two steps using a post-2005 version:
+   ntpclient -f -1318109 -s -h $NTPHOST
+
+If the frequency offset (absolute value) is greater than about 230 ppm
+(15073280), you have a problem: you may be able to fix it with the -t
+option to adjtimex, or you need to hack phaselock.c, that has a
+maximum adjustment extent of +/- 250 ppm built into phaselock.c (change
+the #define MAX_CORRECT and rebuild ntpclient).  I'd like to suggest that
+you replace the defective crystal instead, but I understand that is rarely
+practical.
+
+On to ntpclient -l.  This is actually easy, if you performed and understood
+the previous steps.  Run
+  ntpclient -l -h $NTPHOST
+in the background.  It will make small (probably less than 3 ppm) adjustments
+to the system frequency to keep the clocks locked.  Typical performance over
+Ethernet (even through a few routers) is a worst case error of +/- 10 ms.
+
+I won't try to tell you _where_ to put the boot time commands.  They should
+boil down to:
+   adjtimex -f $NONVOLATILE_MEMORY_VALUE
+   ntpclient -s -i 15 -g 10000 -h $NTPHOST
+   ntpclient -l -h $NTPHOST >some_log_file
+The second line makes explicit the retries that may be required for this
+UDP-based time protocol.  If the first time request takes longer than 10000
+microseconds to resolve, or the packets get lost, it instructs ntpclient to
+try again 15 seconds later (the minimum retry period mandated by RFC-4330),
+and it won't exit until it gets such a suitable response.
+
+As of 2006, ntpclient can in theory combine the three lines above into one:
+   ntpclient -f $NONVOLATILE_MEMORY_VALUE -s -l -i 600 -g 10000 -h $NTPHOST >some_log_file
+This can streamline the startup process, since you may be able to avoid a
+layer of shell scripting.  On the other hand, it is less tested, and there
+is no (current) means to independently set the packet interval for the
+set and lock phases.
+
+It's an interesting question how sensitive the boot process should be
+to the time set process.  If you have a battery backed hardware clock,
+there's not much problem running for a while without a network-accurate
+system clock.  In that case you could put both ntpclient commands into a
+background script, and the only possible issue is the sudden (but probably
+small) warp of the clock at the indefinite time in the boot sequence when
+ntpclient gets its acceptable answer.  On the other hand, some embedded
+computers have no clue what time it is until the network responds.  Any
+files created will be marked Jan 1 1970, and other application-dependent
+issues may arise if there is a nonsense time on the system during later
+parts of the boot sequence.  Then you may well want to enforce completion
+of the first ntpclient before starting your application.  If this is too
+drastic for you, and you want a fallback mode when the time server is dead,
+add a "-c 5" switch to the end of that ntpclient command, giving at most 5
+retries, if something goes wrong with the time set.  For that approach to be
+useful, consider patching the source to lower the minimum packet send
+interval from the RFC-4330-mandated 15 seconds.
diff --git a/net/mmt/ntp/Makefile b/net/mmt/ntp/Makefile
new file mode 100644
index 0000000..34cef76
--- /dev/null
+++ b/net/mmt/ntp/Makefile
@@ -0,0 +1,37 @@
+# A long time ago, far, far away, under Solaris, you needed to
+#    CFLAGS += -xO2 -Xc
+#    LDLIBS += -lnsl -lsocket
+# To cross-compile
+#    CC = arm-linux-gcc
+# To check for lint
+#    CFLAGS += -Wpointer-arith -Wcast-align -Wcast-qual -Wshadow -Wundef \
+#     -Waggregate-return -Wnested-externs -Winline -Wwrite-strings -Wstrict-prototypes
+
+# This is old-school networking code, making the traditional cast between
+# struct sockaddr* and struct sockaddr_in*.  Thus a modern gcc needs:
+CFLAGS += -fno-strict-aliasing
+
+CFLAGS += -std=c89
+CFLAGS += -W -Wall
+CFLAGS += -O2
+# CFLAGS += -DPRECISION_SIOCGSTAMP
+#CFLAGS += -DENABLE_DEBUG
+#CFLAGS += -DENABLE_REPLAY
+# CFLAGS += -DUSE_OBSOLETE_GETTIMEOFDAY
+
+LDFLAGS += -lrt
+
+all: ntpclient
+
+test: ntpclient
+	./ntpclient -d -r <test.dat
+
+ntpclient: ntpclient.o phaselock.o
+	$(CC) -o ntpclient ntpclient.o phaselock.o $(LDFLAGS) 
+
+ntpclient.o phaselock.o: ntpclient.h
+
+adjtimex: adjtimex.o
+
+clean:
+	rm -f ntpclient adjtimex *.o
diff --git a/net/mmt/ntp/ntp.gyp b/net/mmt/ntp/ntp.gyp
new file mode 100644
index 0000000..6ec9ea7
--- /dev/null
+++ b/net/mmt/ntp/ntp.gyp
@@ -0,0 +1,80 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libntp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'ntp',
+      'sources': [
+        'ntpclient.c',
+        'phaselock.c',
+      ],
+      'defines': [
+        'LIBNTP'
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '-std=c89',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lrt',
+          ],
+        }],
+      ],
+    },
+  ],
+}
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
new file mode 100644
index 0000000..293eca0
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.c
@@ -0,0 +1,739 @@
+/*
+ * ntpclient.c - NTP client
+ *
+ * Copyright (C) 1997, 1999, 2000, 2003, 2006, 2007, 2010  Larry Doolittle  <larry@doolittle.boa.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Write more documentation  :-(
+ *      - Support leap second processing
+ *      - Support IPv6
+ *      - Support multiple (interleaved) servers
+ *
+ *  Compile with -DPRECISION_SIOCGSTAMP if your machine really has it.
+ *  There are patches floating around to add this to Linux, but
+ *  usually you only get an answer to the nearest jiffy.
+ *  Hint for Linux hacker wannabes: look at the usage of get_fast_time()
+ *  in net/core/dev.c, and its definition in kernel/time.c .
+ *
+ *  If the compile gives you any flak, check below in the section
+ *  labelled "XXX fixme - non-automatic build configuration".
+ */
+
+#define _POSIX_C_SOURCE 199309
+#define _BSD_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>     /* gethostbyname */
+#include <arpa/inet.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#ifdef PRECISION_SIOCGSTAMP
+#include <sys/ioctl.h>
+#endif
+#ifdef USE_OBSOLETE_GETTIMEOFDAY
+#include <sys/time.h>
+#endif
+
+#include "ntpclient.h"
+
+/* Default to the RFC-4330 specified value */
+#ifndef MIN_INTERVAL
+#define MIN_INTERVAL 15
+#endif
+
+#ifdef ENABLE_DEBUG
+#define DEBUG_OPTION "d"
+int debug=0;
+#else
+#define DEBUG_OPTION
+#define debug 0
+#endif
+
+#ifdef ENABLE_REPLAY
+#define  REPLAY_OPTION   "r"
+#else
+#define  REPLAY_OPTION
+#endif
+
+/* global tuning parameter */
+extern double min_delay;
+
+/* prototype for function defined in phaselock.c */
+extern int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq);
+
+extern char *optarg;  /* according to man 2 getopt */
+
+#include <stdint.h>
+typedef uint32_t u32;  /* universal for C99 */
+/* typedef u_int32_t u32;   older Linux installs? */
+
+/* XXX fixme - non-automatic build configuration */
+#ifdef __linux__
+#include <sys/utsname.h>
+#include <sys/time.h>
+#include <sys/timex.h>
+#include <netdb.h>
+#else
+extern struct hostent *gethostbyname(const char *name);
+extern int h_errno;
+#define herror(hostname) \
+	fprintf(stderr,"Error %d looking up hostname %s\n", h_errno,hostname)
+#endif
+/* end configuration for host systems */
+
+#define JAN_1970        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define NTP_PORT (123)
+
+/* How to multiply by 4294.967296 quickly (and not quite exactly)
+ * without using floating point or greater than 32-bit integers.
+ * If you want to fix the last 12 microseconds of error, add in
+ * (2911*(x))>>28)
+ */
+#define NTPFRAC(x) ( 4294*(x) + ( (1981*(x))>>11 ) )
+
+/* The reverse of the above, needed if we want to set our microsecond
+ * clock (via clock_settime) based on the incoming time in NTP format.
+ * Basically exact.
+ */
+#define USEC(x) ( ( (x) >> 12 ) - 759 * ( ( ( (x) >> 10 ) + 32768 ) >> 16 ) )
+
+/* Converts NTP delay and dispersion, apparently in seconds scaled
+ * by 65536, to microseconds.  RFC-1305 states this time is in seconds,
+ * doesn't mention the scaling.
+ * Should somehow be the same as 1000000 * x / 65536
+ */
+#define sec2u(x) ( (x) * 15.2587890625 )
+
+struct ntptime {
+	unsigned int coarse;
+	unsigned int fine;
+};
+
+struct ntp_control {
+	u32 time_of_send[2];
+	int live;
+	int set_clock;   /* non-zero presumably needs root privs */
+	int probe_count;
+	int cycle_time;
+	int goodness;
+	int cross_check;
+	char serv_addr[4];
+};
+
+/* prototypes for some local routines */
+static void send_packet(int usd, u32 time_sent[2]);
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time);
+/* static void udp_handle(int usd, char *data, int data_len, struct sockaddr *sa_source, int sa_len); */
+
+static int get_current_freq(void)
+{
+	/* OS dependent routine to get the current value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes=0;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static int set_freq(int new_freq)
+{
+	/* OS dependent routine to set a new value of clock frequency.
+	 */
+#ifdef __linux__
+	struct timex txc;
+	txc.modes = ADJ_FREQUENCY;
+	txc.freq = new_freq;
+	if (adjtimex(&txc) < 0) {
+		perror("adjtimex"); return -1;
+	}
+	return txc.freq;
+#else
+	return 0;
+#endif
+}
+
+static void set_time(struct ntptime *new)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to set the system clock
+	 */
+	struct timespec tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_nsec = USEC(new->fine)*1000;
+	if (clock_settime(CLOCK_REALTIME, &tv_set)<0) {
+		perror("clock_settime");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.9lu\n", tv_set.tv_sec, tv_set.tv_nsec);
+	}
+#else
+	/* Traditional Linux way to set the system clock
+	 */
+	struct timeval tv_set;
+	/* it would be even better to subtract half the slop */
+	tv_set.tv_sec  = new->coarse - JAN_1970;
+	/* divide xmttime.fine by 4294.967296 */
+	tv_set.tv_usec = USEC(new->fine);
+	if (settimeofday(&tv_set,NULL)<0) {
+		perror("settimeofday");
+        return;
+	}
+	if (debug) {
+		printf("set time to %lu.%.6lu\n", tv_set.tv_sec, tv_set.tv_usec);
+	}
+#endif
+}
+
+static void ntpc_gettime(u32 *time_coarse, u32 *time_fine)
+{
+#ifndef USE_OBSOLETE_GETTIMEOFDAY
+	/* POSIX 1003.1-2001 way to get the system time
+	 */
+	struct timespec now;
+	clock_gettime(CLOCK_REALTIME, &now);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_nsec/1000);
+#else
+	/* Traditional Linux way to get the system time
+	 */
+	struct timeval now;
+	gettimeofday(&now, NULL);
+	*time_coarse = now.tv_sec + JAN_1970;
+	*time_fine   = NTPFRAC(now.tv_usec);
+#endif
+}
+
+static void send_packet(int usd, u32 time_sent[2])
+{
+	u32 data[12];
+#define LI 0
+#define VN 3
+#define MODE 3
+#define STRATUM 0
+#define POLL 4
+#define PREC -6
+
+	if (debug) fprintf(stderr,"Sending ...\n");
+	if (sizeof data != 48) {
+		fprintf(stderr,"size error\n");
+		return;
+	}
+	memset(data,0,sizeof data);
+	data[0] = htonl (
+		( LI << 30 ) | ( VN << 27 ) | ( MODE << 24 ) |
+		( STRATUM << 16) | ( POLL << 8 ) | ( PREC & 0xff ) );
+	data[1] = htonl(1<<16);  /* Root Delay (seconds) */
+	data[2] = htonl(1<<16);  /* Root Dispersion (seconds) */
+	ntpc_gettime(time_sent, time_sent+1);
+	data[10] = htonl(time_sent[0]); /* Transmit Timestamp coarse */
+	data[11] = htonl(time_sent[1]); /* Transmit Timestamp fine   */
+	send(usd,data,48,0);
+}
+
+static void get_packet_timestamp(int usd, struct ntptime *udp_arrival_ntp)
+{
+#ifdef PRECISION_SIOCGSTAMP
+	/* XXX broken */
+	struct timeval udp_arrival;
+	if ( ioctl(usd, SIOCGSTAMP, &udp_arrival) < 0 ) {
+		perror("ioctl-SIOCGSTAMP");
+		gettimeofday(&udp_arrival, NULL);
+	}
+	udp_arrival_ntp->coarse = udp_arrival.tv_sec + JAN_1970;
+	udp_arrival_ntp->fine   = NTPFRAC(udp_arrival.tv_usec);
+#else
+	(void) usd;  /* not used */
+	ntpc_gettime(&udp_arrival_ntp->coarse, &udp_arrival_ntp->fine);
+#endif
+}
+
+static int check_source(int data_len, struct sockaddr *sa_source, unsigned int sa_len, struct ntp_control *ntpc)
+{
+	struct sockaddr_in *sa_in=(struct sockaddr_in *)sa_source;
+	(void) sa_len;  /* not used */
+	if (debug) {
+		printf("packet of length %d received\n",data_len);
+		if (sa_source->sa_family==AF_INET) {
+			printf("Source: INET Port %d host %s\n",
+				ntohs(sa_in->sin_port),inet_ntoa(sa_in->sin_addr));
+		} else {
+			printf("Source: Address family %d\n",sa_source->sa_family);
+		}
+	}
+	/* we could check that the source is the server we expect, but
+	 * Denys Vlasenko recommends against it: multihomed hosts get it
+	 * wrong too often. */
+#if 0
+	if (memcmp(ntpc->serv_addr, &(sa_in->sin_addr), 4)!=0) {
+		return 1;  /* fault */
+	}
+#else
+	(void) ntpc; /* not used */
+#endif
+	if (NTP_PORT != ntohs(sa_in->sin_port)) {
+		return 1;  /* fault */
+	}
+	return 0;
+}
+
+static double ntpdiff( struct ntptime *start, struct ntptime *stop)
+{
+	int a;
+	unsigned int b;
+	a = stop->coarse - start->coarse;
+	if (stop->fine >= start->fine) {
+		b = stop->fine - start->fine;
+	} else {
+		b = start->fine - stop->fine;
+		b = ~b;
+		a -= 1;
+	}
+
+	return a*1.e6 + b * (1.e6/4294967296.0);
+}
+
+/* Does more than print, so this name is bogus.
+ * It also makes time adjustments, both sudden (-s)
+ * and phase-locking (-l).
+ * sets *error to the number of microseconds uncertainty in answer
+ * returns 0 normally, 1 if the message fails sanity checks
+ */
+static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *ntpc, int *error, struct ntp_time_t* ntp_time)
+{
+/* straight out of RFC-1305 Appendix A */
+	int li, vn, mode, stratum, poll, prec;
+	int delay, disp, refid;
+	struct ntptime reftime, orgtime, rectime, xmttime;
+	double el_time,st_time,skew1,skew2;
+	int freq;
+#ifdef ENABLE_DEBUG
+	const char *drop_reason=NULL;
+#endif
+
+#define Data(i) ntohl(((u32 *)data)[i])
+	li      = Data(0) >> 30 & 0x03;
+	vn      = Data(0) >> 27 & 0x07;
+	mode    = Data(0) >> 24 & 0x07;
+	stratum = Data(0) >> 16 & 0xff;
+	poll    = Data(0) >>  8 & 0xff;
+	prec    = Data(0)       & 0xff;
+	if (prec & 0x80) prec|=0xffffff00;
+	delay   = Data(1);
+	disp    = Data(2);
+	refid   = Data(3);
+	reftime.coarse = Data(4);
+	reftime.fine   = Data(5);
+	orgtime.coarse = Data(6);
+	orgtime.fine   = Data(7);
+	rectime.coarse = Data(8);
+	rectime.fine   = Data(9);
+	xmttime.coarse = Data(10);
+	xmttime.fine   = Data(11);
+#undef Data
+
+	if (debug) {
+	printf("LI=%d  VN=%d  Mode=%d  Stratum=%d  Poll=%d  Precision=%d\n",
+		li, vn, mode, stratum, poll, prec);
+	printf("Delay=%.1f  Dispersion=%.1f  Refid=%u.%u.%u.%u\n",
+		sec2u(delay),sec2u(disp),
+		refid>>24&0xff, refid>>16&0xff, refid>>8&0xff, refid&0xff);
+	printf("Reference %u.%.6u\n", reftime.coarse, USEC(reftime.fine));
+	printf("(sent)    %u.%.6u\n", ntpc->time_of_send[0], USEC(ntpc->time_of_send[1]));
+	printf("Originate %u.%.6u\n", orgtime.coarse, USEC(orgtime.fine));
+	printf("Receive   %u.%.6u\n", rectime.coarse, USEC(rectime.fine));
+	printf("Transmit  %u.%.6u\n", xmttime.coarse, USEC(xmttime.fine));
+	printf("Our recv  %u.%.6u\n", arrival->coarse, USEC(arrival->fine));
+	}
+	el_time=ntpdiff(&orgtime,arrival);   /* elapsed */
+	st_time=ntpdiff(&rectime,&xmttime);  /* stall */
+	skew1=ntpdiff(&orgtime,&rectime);
+	skew2=ntpdiff(&xmttime,arrival);
+	freq=get_current_freq();
+	if (debug) {
+	printf("Total elapsed: %9.2f\n"
+	       "Server stall:  %9.2f\n"
+	       "Slop:          %9.2f\n",
+		el_time, st_time, el_time-st_time);
+	printf("Skew:          %9.2f\n"
+	       "Frequency:     %9d\n"
+	       " day   second     elapsed    stall     skew  dispersion  freq\n",
+		(skew1-skew2)/2, freq);
+	}
+
+	/* error checking, see RFC-4330 section 5 */
+#ifdef ENABLE_DEBUG
+#define FAIL(x) do { drop_reason=(x); goto fail;} while (0)
+#else
+#define FAIL(x) goto fail;
+#endif
+	if (ntpc->cross_check) {
+		if (li == 3) FAIL("LI==3");  /* unsynchronized */
+		if (vn < 3) FAIL("VN<3");   /* RFC-4330 documents SNTP v4, but we interoperate with NTP v3 */
+		if (mode != 4) FAIL("MODE!=3");
+		if (orgtime.coarse != ntpc->time_of_send[0] ||
+		    orgtime.fine   != ntpc->time_of_send[1] ) FAIL("ORG!=sent");
+		if (xmttime.coarse == 0 && xmttime.fine == 0) FAIL("XMT==0");
+		if (delay > 65536 || delay < -65536) FAIL("abs(DELAY)>65536");
+		if (disp  > 65536 || disp  < -65536) FAIL("abs(DISP)>65536");
+		if (stratum == 0) FAIL("STRATUM==0");  /* kiss o' death */
+#undef FAIL
+	}
+
+	/* XXX should I do this if debug flag is set? */
+	if (ntpc->set_clock) { /* you'd better be root, or ntpclient will exit here! */
+		set_time(&xmttime);
+	}
+
+	/* Not the ideal order for printing, but we want to be sure
+	 * to do all the time-sensitive thinking (and time setting)
+	 * before we start the output, especially fflush() (which
+	 * could be slow).  Of course, if debug is turned on, speed
+	 * has gone down the drain anyway. */
+	if (ntpc->live) {
+		int new_freq;
+		new_freq = contemplate_data(arrival->coarse, (skew1-skew2)/2,
+			el_time+sec2u(disp), freq);
+		if (!debug && new_freq != freq) set_freq(new_freq);
+	}
+
+    if (ntp_time) {
+        ntp_time->day = arrival->coarse/86400;
+        ntp_time->sec = arrival->coarse%86400;
+    }else {
+	    printf("%d %.5d.%.3d  %8.1f %8.1f  %8.1f %8.1f %9d\n",
+		    arrival->coarse/86400, arrival->coarse%86400,
+		    arrival->fine/4294967, el_time, st_time,
+		    (skew1-skew2)/2, sec2u(disp), freq);
+	    fflush(stdout);
+    }
+	*error = el_time-st_time;
+
+	return 0;
+fail:
+#ifdef ENABLE_DEBUG
+	printf("%d %.5d.%.3d  rejected packet: %s\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967, drop_reason);
+#else
+	printf("%d %.5d.%.3d  rejected packet\n",
+		arrival->coarse/86400, arrival->coarse%86400,
+		arrival->fine/4294967);
+#endif
+	return 1;
+}
+
+static void stuff_net_addr(struct in_addr *p, char *hostname)
+{
+	struct hostent *ntpserver;
+	ntpserver=gethostbyname(hostname);
+	if (ntpserver == NULL) {
+		herror(hostname);
+		return;
+	}
+	if (ntpserver->h_length != 4) {
+		/* IPv4 only, until I get a chance to test IPv6 */
+		fprintf(stderr,"oops %d\n",ntpserver->h_length);
+        return;
+	}
+	memcpy(&(p->s_addr),ntpserver->h_addr_list[0],4);
+}
+
+static void setup_receive(int usd, unsigned int interface, short port)
+{
+	struct sockaddr_in sa_rcvr;
+	memset(&sa_rcvr,0,sizeof sa_rcvr);
+	sa_rcvr.sin_family=AF_INET;
+	sa_rcvr.sin_addr.s_addr=htonl(interface);
+	sa_rcvr.sin_port=htons(port);
+	if(bind(usd,(struct sockaddr *) &sa_rcvr,sizeof sa_rcvr) == -1) {
+		perror("bind");
+		fprintf(stderr,"could not bind to udp port %d\n",port);
+        return;
+	}
+	/* listen(usd,3); this isn't TCP; thanks Alexander! */
+}
+
+static void setup_transmit(int usd, char *host, short port, struct ntp_control *ntpc)
+{
+	struct sockaddr_in sa_dest;
+	memset(&sa_dest,0,sizeof sa_dest);
+	sa_dest.sin_family=AF_INET;
+	stuff_net_addr(&(sa_dest.sin_addr),host);
+	memcpy(ntpc->serv_addr,&(sa_dest.sin_addr),4); /* XXX asumes IPv4 */
+	sa_dest.sin_port=htons(port);
+	if (connect(usd,(struct sockaddr *)&sa_dest,sizeof sa_dest)==-1)
+		{perror("connect");return;}
+}
+
+static void primary_loop(int usd, struct ntp_control *ntpc, struct ntp_time_t* ntp_time)
+{
+	fd_set fds;
+	struct sockaddr sa_xmit;
+	int i, pack_len, probes_sent, error;
+	socklen_t sa_xmit_len;
+	struct timeval to;
+	struct ntptime udp_arrival_ntp;
+	static u32 incoming_word[325];
+#define incoming ((char *) incoming_word)
+#define sizeof_incoming (sizeof incoming_word)
+
+	if (debug) printf("Listening...\n");
+
+	probes_sent=0;
+	sa_xmit_len=sizeof sa_xmit;
+	to.tv_sec=0;
+	to.tv_usec=0;
+	for (;;) {
+		FD_ZERO(&fds);
+		FD_SET(usd,&fds);
+		i=select(usd+1,&fds,NULL,NULL,&to);  /* Wait on read or error */
+		if ((i!=1)||(!FD_ISSET(usd,&fds))) {
+			if (i<0) {
+				if (errno != EINTR) perror("select");
+				continue;
+			}
+			if (to.tv_sec == 0) {
+				if (probes_sent >= ntpc->probe_count &&
+					ntpc->probe_count != 0) break;
+				send_packet(usd,ntpc->time_of_send);
+				++probes_sent;
+				to.tv_sec=ntpc->cycle_time;
+				to.tv_usec=0;
+			}
+			continue;
+		}
+		pack_len=recvfrom(usd,incoming,sizeof_incoming,0,
+		                  &sa_xmit,&sa_xmit_len);
+		error = ntpc->goodness;
+		if (pack_len<0) {
+			perror("recvfrom");
+		} else if (pack_len>0 && (unsigned)pack_len<sizeof_incoming){
+			get_packet_timestamp(usd, &udp_arrival_ntp);
+			if (check_source(pack_len, &sa_xmit, sa_xmit_len, ntpc)!=0) continue;
+			if (rfc1305print(incoming_word, &udp_arrival_ntp, ntpc, &error, ntp_time)!=0) continue;
+			/* udp_handle(usd,incoming,pack_len,&sa_xmit,sa_xmit_len); */
+		} else {
+			printf("Ooops.  pack_len=%d\n",pack_len);
+			fflush(stdout);
+		}
+		/* best rollover option: specify -g, -s, and -l.
+		 * simpler rollover option: specify -s and -l, which
+		 * triggers a magic -c 1 */
+		if ((error < ntpc->goodness && ntpc->goodness != 0) ||
+		    (probes_sent >= ntpc->probe_count && ntpc->probe_count != 0)) {
+			ntpc->set_clock = 0;
+			if (!ntpc->live) break;
+		}
+	}
+#undef incoming
+#undef sizeof_incoming
+}
+
+#ifdef ENABLE_REPLAY
+static void do_replay(void)
+{
+	char line[100];
+	int n, day, freq, absolute;
+	float sec, el_time, st_time, disp;
+	double skew, errorbar;
+	int simulated_freq = 0;
+	unsigned int last_fake_time = 0;
+	double fake_delta_time = 0.0;
+
+	while (fgets(line,sizeof line,stdin)) {
+		n=sscanf(line,"%d %f %f %f %lf %f %d",
+			&day, &sec, &el_time, &st_time, &skew, &disp, &freq);
+		if (n==7) {
+			fputs(line,stdout);
+			absolute=day*86400+(int)sec;
+			errorbar=el_time+disp;
+			if (debug) printf("contemplate %u %.1f %.1f %d\n",
+				absolute,skew,errorbar,freq);
+			if (last_fake_time==0) simulated_freq=freq;
+			fake_delta_time += (absolute-last_fake_time)*((double)(freq-simulated_freq))/65536;
+			if (debug) printf("fake %f %d \n", fake_delta_time, simulated_freq);
+			skew += fake_delta_time;
+			freq = simulated_freq;
+			last_fake_time = absolute;
+			simulated_freq = contemplate_data(absolute, skew, errorbar, freq);
+		} else {
+			fprintf(stderr,"Replay input error\n");
+            return;
+		}
+	}
+}
+#endif
+
+static void usage(char *argv0)
+{
+	fprintf(stderr,
+	"Usage: %s [-c count]"
+#ifdef ENABLE_DEBUG
+	" [-d]"
+#endif
+	" [-f frequency] [-g goodness] -h hostname\n"
+	"\t[-i interval] [-l] [-p port] [-q min_delay]"
+#ifdef ENABLE_REPLAY
+	" [-r]"
+#endif
+	" [-s] [-t]\n",
+	argv0);
+}
+
+#ifdef LIBNTP 
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time) {
+    if (!host || !ntp_time) return -1;
+    int argc = 4;
+    char* argv[] = {
+        "ntp_get_time",
+        "-h time.apple.com",
+        "-i 1",
+        "-c 1"
+    };
+#else
+int main(int argc, char *argv[]) {
+    struct ntp_time_t* ntp_time = NULL;
+#endif
+	int usd;  /* socket */
+	int c;
+	/* These parameters are settable from the command line
+	   the initializations here provide default behavior */
+	short int udp_local_port=0;   /* default of 0 means kernel chooses */
+	char *hostname=NULL;          /* must be set */
+	int initial_freq;             /* initial freq value to use */
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=0;           /* default of 0 means loop forever */
+	ntpc.cycle_time=600;          /* seconds */
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
+
+	for (;;) {
+		c = getopt( argc, argv, "c:" DEBUG_OPTION "f:g:h:i:lp:q:" REPLAY_OPTION "st");
+		if (c == EOF) break;
+		switch (c) {
+			case 'c':
+				ntpc.probe_count = atoi(optarg);
+				break;
+#ifdef ENABLE_DEBUG
+			case 'd':
+				++debug;
+				break;
+#endif
+			case 'f':
+				initial_freq = atoi(optarg);
+				if (debug) printf("initial frequency %d\n",
+						initial_freq);
+				set_freq(initial_freq);
+				break;
+			case 'g':
+				ntpc.goodness = atoi(optarg);
+				break;
+			case 'h':
+				hostname = optarg;
+				break;
+			case 'i':
+				ntpc.cycle_time = atoi(optarg);
+				break;
+			case 'l':
+				(ntpc.live)++;
+				break;
+			case 'p':
+				udp_local_port = atoi(optarg);
+				break;
+			case 'q':
+				min_delay = atof(optarg);
+				break;
+#ifdef ENABLE_REPLAY
+			case 'r':
+				do_replay();
+                return -1;
+				break;
+#endif
+			case 's':
+				(ntpc.set_clock)++;
+				break;
+
+			case 't':
+				(ntpc.cross_check)=0;
+				break;
+
+			default:
+				usage(argv[0]);
+                return -1;
+		}
+	}
+	if (hostname == NULL) {
+		usage(argv[0]);
+        return -1;
+	}
+
+	if (ntpc.set_clock && !ntpc.live && !ntpc.goodness && !ntpc.probe_count) {
+		ntpc.probe_count = 1;
+	}
+
+	/* respect only applicable MUST of RFC-4330 */
+	if (ntpc.probe_count != 1 && ntpc.cycle_time < MIN_INTERVAL) {
+		ntpc.cycle_time = MIN_INTERVAL;
+	}
+
+	if (debug) {
+		printf("Configuration:\n"
+		"  -c probe_count %d\n"
+		"  -d (debug)     %d\n"
+		"  -g goodness    %d\n"
+		"  -h hostname    %s\n"
+		"  -i interval    %d\n"
+		"  -l live        %d\n"
+		"  -p local_port  %d\n"
+		"  -q min_delay   %f\n"
+		"  -s set_clock   %d\n"
+		"  -x cross_check %d\n",
+		ntpc.probe_count, debug, ntpc.goodness,
+		hostname, ntpc.cycle_time, ntpc.live, udp_local_port, min_delay,
+		ntpc.set_clock, ntpc.cross_check );
+	}
+
+	/* Startup sequence */
+	if ((usd=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==-1) {
+        perror ("socket");
+        return -1;
+    }
+
+	setup_receive(usd, INADDR_ANY, udp_local_port);
+
+	setup_transmit(usd, hostname, NTP_PORT, &ntpc);
+
+	primary_loop(usd, &ntpc, ntp_time);
+
+	close(usd);
+	return 0;
+}
diff --git a/net/mmt/ntp/ntpclient.h b/net/mmt/ntp/ntpclient.h
new file mode 100644
index 0000000..c6aa46e
--- /dev/null
+++ b/net/mmt/ntp/ntpclient.h
@@ -0,0 +1,18 @@
+#ifndef NET_MMT_NTP_NTPCLIENT_H_
+#define NET_MMT_NTP_NTPCLIENT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ntp_time_t {
+    int day;
+    float sec;
+};
+int ntp_get_time(const char* host, struct ntp_time_t* ntp_time);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/net/mmt/ntp/phaselock.c b/net/mmt/ntp/phaselock.c
new file mode 100644
index 0000000..d1ab598
--- /dev/null
+++ b/net/mmt/ntp/phaselock.c
@@ -0,0 +1,339 @@
+/*
+ * phaselock.c - Phase locking for NTP client
+ *
+ * Copyright (C) 2000, 2007  Larry Doolittle  <larry@doolittle.boa.org>
+ * Last hack: 30 December, 2007
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License (Version 2,
+ *  June 1991) as published by the Free Software Foundation.  At the
+ *  time of writing, that license was published by the FSF with the URL
+ *  http://www.gnu.org/copyleft/gpl.html, and is incorporated herein by
+ *  reference.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  Possible future improvements:
+ *      - Subtract configurable amount from errorbar
+ *      - Build in general run-time access to tune parameters
+ *      - Sculpt code so it's legible, this version is out of control
+ *      - Write documentation  :-(
+ */
+
+#include <stdio.h>
+#include "ntpclient.h"
+
+/* when present, debug is a true global */
+#ifdef ENABLE_DEBUG
+extern int debug;
+#else
+#define debug 0
+#endif
+
+double min_delay = 800.0;  /* global, user-changeable, units are microseconds */
+
+#define RING_SIZE 16
+#define MAX_CORRECT 250   /* ppm change to system clock */
+#define MAX_C ((MAX_CORRECT)*65536)
+static struct datum {
+	unsigned int absolute;
+	double skew;
+	double errorbar;
+	int freq;
+	/* s.s.min and s.s.max (skews) are "corrected" to what they would
+	 * have been if freq had been constant at its current value during
+	 * the measurements.
+	 */
+	union {
+		struct { double min; double max; } s;
+		double ss[2];
+	} s;
+	/*
+	double smin;
+	double smax;
+	 */
+} d_ring[RING_SIZE];
+
+static struct _seg {
+	double slope;
+	double offset;
+} maxseg[RING_SIZE+1], minseg[RING_SIZE+1];
+
+#if 0
+/* draw a line from a to c, what the offset is of that line
+ * where that line matches b's slope coordinate.
+ */
+static double interpolate(struct _seg *a, struct _seg *b, struct _seg *c)
+{
+	double x, y;
+	x = (b->slope - a->slope) / (c->slope  - a->slope) ;
+	y =         a->offset + x * (c->offset - a->offset);
+	return y;
+}
+#endif
+
+static int next_up(int i) { int r = i+1; if (r>=RING_SIZE) r=0; return r;}
+static int next_dn(int i) { int r = i-1; if (r<0) r=RING_SIZE-1; return r;}
+
+/* Looks at the line segments that start at point j, that end at
+ * all following points (ending at index rp).  The initial point
+ * is on curve s0, the ending point is on curve s1.  The curve choice
+ * (s.min vs. s.max) is based on the index in ss[].  The scan
+ * looks for the largest (sign=0) or smallest (sign=1) slope.
+ */
+static int search(int rp, int j, int s0, int s1, int sign, struct _seg *answer)
+{
+	double dt, slope;
+	int n, nextj=0, cinit=1;
+	for (n=next_up(j); n!=next_up(rp); n=next_up(n)) {
+		if (0 && debug) printf("d_ring[%d].s.ss[%d]=%f d_ring[%d].s.ss[%d]=%f\n",
+			n, s0, d_ring[n].s.ss[s0], j, s1, d_ring[j].s.ss[s1]);
+		dt = d_ring[n].absolute - d_ring[j].absolute;
+		slope = (d_ring[n].s.ss[s0] - d_ring[j].s.ss[s1]) / dt;
+		if (0 && debug) printf("slope %d%d%d [%d,%d] = %f\n",
+			s0, s1, sign, j, n, slope);
+		if (cinit || (slope < answer->slope) ^ sign) {
+			answer->slope = slope;
+			answer->offset = d_ring[n].s.ss[s0] +
+				slope*(d_ring[rp].absolute - d_ring[n].absolute);
+			cinit = 0;
+			nextj = n;
+		}
+	}
+	return nextj;
+}
+
+/* Pseudo-class for finding consistent frequency shift */
+#define MIN_INIT 20
+static struct _polygon {
+	double l_min;
+	double r_min;
+} df;
+
+static void polygon_reset(void)
+{
+	df.l_min = MIN_INIT;
+	df.r_min = MIN_INIT;
+}
+
+static double find_df(int *flag)
+{
+	if (df.l_min == 0.0) {
+		if (df.r_min == 0.0) {
+			return 0.0;   /* every point was OK */
+		} else {
+			return -df.r_min;
+		}
+	} else {
+		if (df.r_min == 0.0) {
+			return df.l_min;
+		} else {
+			if (flag) *flag=1;
+			return 0.0;   /* some points on each side,
+			               * or no data at all */
+		}
+	}
+}
+
+/* Finds the amount of delta-f required to move a point onto a
+ * target line in delta-f/delta-t phase space.  Any line is OK
+ * as long as it's not convex and never returns greater than
+ * MIN_INIT. */
+static double find_shift(double slope, double offset)
+{
+	double shift  = slope - offset/600.0;
+	double shift2 = slope + 0.3 - offset/6000.0;
+	if (shift2 < shift) shift = shift2;
+	if (debug) printf("find_shift %f %f -> %f\n", slope, offset, shift);
+	if (shift  < 0) return 0.0;
+	return shift;
+}
+
+static void polygon_point(struct _seg *s)
+{
+	double l, r;
+	if (debug) printf("loop %f %f\n", s->slope, s->offset);
+	l = find_shift(- s->slope,   s->offset);
+	r = find_shift(  s->slope, - s->offset);
+	if (l < df.l_min) df.l_min = l;
+	if (r < df.r_min) df.r_min = r;
+	if (debug) printf("constraint left:  %f %f \n", l, df.l_min);
+	if (debug) printf("constraint right: %f %f \n", r, df.r_min);
+}
+
+/* Something like linear feedback to be used when we are "close" to
+ * phase lock.  Not really used at the moment:  the logic in find_df()
+ * never sets the flag. */
+static double find_df_center(struct _seg *min, struct _seg *max, double gross_df)
+{
+	const double crit_time=1000.0;
+	double slope  = 0.5 * (max->slope  + min->slope)+gross_df;
+	double dslope =       (max->slope  - min->slope);
+	double offset = 0.5 * (max->offset + min->offset);
+	double doffset =      (max->offset - min->offset);
+	double delta1 = -offset/ 600.0 - slope;
+	double delta2 = -offset/1800.0 - slope;
+	double delta  = 0.0;
+	double factor = crit_time/(crit_time+doffset+dslope*1200.0);
+	if (offset <  0 && delta2 > 0) delta = delta2;
+	if (offset <  0 && delta1 < 0) delta = delta1;
+	if (offset >= 0 && delta1 > 0) delta = delta1;
+	if (offset >= 0 && delta2 < 0) delta = delta2;
+	if (max->offset < -crit_time || min->offset > crit_time) return 0.0;
+	if (debug) printf("find_df_center %f %f\n", delta, factor);
+	return factor*delta;
+}
+
+int contemplate_data(unsigned int absolute, double skew, double errorbar, int freq)
+{
+	/*  Here is the actual phase lock loop.
+	 *  Need to keep a ring buffer of points to make a rational
+	 *  decision how to proceed.  if (debug) print a lot.
+	 */
+	static int rp=0, valid=0;
+	int both_sides_now=0;
+	int j, n, c, max_avail, min_avail, dinit;
+	int nextj=0;	/* initialization not needed; but gcc can't figure out my logic */
+	double cum;
+	struct _seg check, save_min, save_max;
+	double last_slope;
+	int delta_freq;
+	double delta_f;
+	int inconsistent=0, max_imax, max_imin=0, min_imax, min_imin=0;
+	int computed_freq=freq;
+
+	if (debug) printf("xontemplate %u %.1f %.1f %d\n",absolute,skew,errorbar,freq);
+	d_ring[rp].absolute = absolute;
+	d_ring[rp].skew     = skew;
+	d_ring[rp].errorbar = errorbar - min_delay;   /* quick hack to speed things up */
+	d_ring[rp].freq     = freq;
+
+	if (valid<RING_SIZE) ++valid;
+	if (valid==RING_SIZE) {
+		/*
+		 * Pass 1: correct for wandering freq's */
+		cum = 0.0;
+		if (debug) printf("\n");
+		for (j=rp; ; j=n) {
+			d_ring[j].s.s.max = d_ring[j].skew - cum + d_ring[j].errorbar;
+			d_ring[j].s.s.min = d_ring[j].skew - cum - d_ring[j].errorbar;
+			if (debug) printf("hist %d %d %f %f %f\n",j,d_ring[j].absolute-absolute,
+				cum,d_ring[j].s.s.min,d_ring[j].s.s.max);
+			n=next_dn(j);
+			if (n == rp) break;
+			/* Assume the freq change took place immediately after
+			 * the data was taken; this is valid for the case where
+			 * this program was responsible for the change.
+			 */
+			cum = cum + (d_ring[j].absolute-d_ring[n].absolute) *
+				(double)(d_ring[j].freq-freq)/65536;
+		}
+		/*
+		 * Pass 2: find the convex down envelope of s.max, composed of
+		 * line segments in s.max vs. absolute space, which are
+		 * points in freq vs. dt space.  Find points in order of increasing
+		 * slope == freq */
+		dinit=1; last_slope=-2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 1, 1, 0, &maxseg[c]);
+			        search(rp, j, 0, 1, 1, &check);
+			if (check.slope < maxseg[c].slope && check.slope > last_slope &&
+			    (dinit || check.slope < save_min.slope)) {dinit=0; save_min=check; }
+			if (debug) printf("maxseg[%d] = %f *x+ %f\n",
+				 c, maxseg[c].slope, maxseg[c].offset);
+			last_slope = maxseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("mincross %f *x+ %f\n", save_min.slope, save_min.offset);
+		max_avail=c;
+		/*
+		 * Pass 3: find the convex up envelope of s.min, composed of
+		 * line segments in s.min vs. absolute space, which are
+		 * points in freq vs. dt space.  These points are found in
+		 * order of decreasing slope. */
+		dinit=1; last_slope=+2*MAX_CORRECT;
+		for (c=1, j=next_up(rp); ; j=nextj) {
+			nextj = search(rp, j, 0, 0, 1, &minseg[c]);
+			        search(rp, j, 1, 0, 0, &check);
+			if (check.slope > minseg[c].slope && check.slope < last_slope &&
+			    (dinit || check.slope < save_max.slope)) {dinit=0; save_max=check; }
+			if (debug) printf("minseg[%d] = %f *x+ %f\n",
+				 c, minseg[c].slope, minseg[c].offset);
+			last_slope = minseg[c].slope;
+			c++;
+			if (nextj == rp) break;
+		}
+		if (dinit==1) inconsistent=1;
+		if (debug && dinit==0) printf ("maxcross %f *x+ %f\n", save_max.slope, save_max.offset);
+		min_avail=c;
+		/*
+		 * Pass 4: splice together the convex polygon that forms
+		 * the envelope of slope/offset coordinates that are consistent
+		 * with the observed data.  The order of calls to polygon_point
+		 * doesn't matter for the frequency shift determination, but
+		 * the order chosen is nice for visual display. */
+		if (!inconsistent) {
+		polygon_reset();
+		polygon_point(&save_min);
+		for (dinit=1, c=1; c<max_avail; c++) {
+			if (dinit && maxseg[c].slope > save_min.slope) {
+				max_imin = c-1;
+				maxseg[max_imin] = save_min;
+				dinit = 0;
+			}
+			if (maxseg[c].slope > save_max.slope)
+				break;
+			if (dinit==0) polygon_point(&maxseg[c]);
+		}
+		if (dinit && debug) printf("found maxseg vs. save_min inconsistency\n");
+		if (dinit) inconsistent=1;
+		max_imax = c;
+		maxseg[max_imax] = save_max;
+
+		polygon_point(&save_max);
+		for (dinit=1, c=1; c<min_avail; c++) {
+			if (dinit && minseg[c].slope < save_max.slope) {
+				max_imin = c-1;
+				minseg[min_imin] = save_max;
+				dinit = 0;
+			}
+			if (minseg[c].slope < save_min.slope)
+				break;
+			if (dinit==0) polygon_point(&minseg[c]);
+		}
+		if (dinit && debug) printf("found minseg vs. save_max inconsistency\n");
+		if (dinit) inconsistent=1;
+		min_imax = c;
+		minseg[min_imax] = save_max;
+
+		/* not needed for analysis, but shouldn't hurt either */
+		if (debug) polygon_point(&save_min);
+		} /* !inconsistent */
+
+		/*
+		 * Pass 5: decide on a new freq */
+		if (inconsistent) {
+			printf("# inconsistent\n");
+		} else {
+			delta_f = find_df(&both_sides_now);
+			if (debug) printf("find_df() = %e\n", delta_f);
+			delta_f += find_df_center(&save_min,&save_max, delta_f);
+			delta_freq = delta_f*65536+.5;
+			if (debug) printf("delta_f %f  delta_freq %d  bsn %d\n", delta_f, delta_freq, both_sides_now);
+			computed_freq -= delta_freq;
+			printf ("# box [( %.3f , %.1f ) ",  save_min.slope, save_min.offset);
+			printf (      " ( %.3f , %.1f )] ", save_max.slope, save_max.offset);
+			printf (" delta_f %.3f  computed_freq %d\n", delta_f, computed_freq);
+
+			if (computed_freq < -MAX_C) computed_freq=-MAX_C;
+			if (computed_freq >  MAX_C) computed_freq= MAX_C;
+		}
+	}
+	rp = (rp+1)%RING_SIZE;
+	return computed_freq;
+}
diff --git a/net/net.gyp b/net/net.gyp
index ceb82ee..25d6654 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -102,6 +102,7 @@
         'net_derived_sources',
         'net_resources',
         '../net/mmt/mpu/mpu.gyp:libmpu',
+        '../net/mmt/ntp/ntp.gyp:libntp',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
-- 
1.7.9.5


From c486788156a04b1b23b837ec5647901f479f7f6d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Feb 2015 22:10:26 -0800
Subject: [PATCH 068/128] [ok] for current mmt

---
 net/mmt/mmt_control.cc                 |   29 ++++++++++++++++++++++------
 net/mmt/mmt_control.h                  |    4 ++++
 net/mmt/mmt_stream.cc                  |    5 ++++-
 net/mmt/mmt_stream.h                   |    6 +++++-
 net/mmt/mpu/moof_combine.sh            |    4 ++--
 net/url_request/url_request_mmt_job.cc |   33 +++++++++++++++++++++++++-------
 net/url_request/url_request_mmt_job.h  |    1 +
 7 files changed, 65 insertions(+), 17 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index acb27d4..91be573 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -33,11 +33,11 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     PostCtrlMsg(msg);
 }
 // for @close
-void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid) {
+void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
     msg.url = gurl;
-    msg.ptr = refptr;
+    msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
@@ -69,15 +69,22 @@ ctrl_msg_t::ctrl_msg_t() {
     sinfo.size = 0;
     sinfo.offset = 0;
     sinfo.func = nullptr;
+    sinfo.postui = nullptr;
 }
 ctrl_msg_t::~ctrl_msg_t() {
 }
 
 cixml_t::cixml_t() {
     status = "initing";
+    parser = nullptr;
+    job = nullptr;
+    postui = nullptr;
 }
 cixml_t::~cixml_t() {
+    status = "uniniting";
     parser = nullptr;
+    job = nullptr;
+    postui = nullptr;
 }
 
 /**
@@ -132,12 +139,18 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         }
     }
 
+    // save information of current table
     if (msg.tabid > 0) {
+        cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
-            cixmlptr_t cixml = new cixml_t;
+            cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
+        }else {
+            cixml = cixmls_[msg.tabid];
         }
+        cixml->job = msg.ptr;
+        cixml->postui = msg.sinfo.postui;
     }
 }
 void MmtControl::StreamClose(ctrl_msg_t msg) {
@@ -159,7 +172,7 @@ void GetJsonData(int tabid, std::string js, std::string& json) {
 }
 void MmtControl::CheckEvent() {
     // TODO for testing
-    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    std::string xml = "mmt://localhost/tmp/ci.xml";
 
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
@@ -185,14 +198,18 @@ void MmtControl::CheckEvent() {
             next_status = "loaded";
             Wait(1000);
         }else if (cixml->status == "loaded") {
-            if (parser) {
+            if (parser && cixml->postui) {
                 std::string js;
                 long ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
+#if 0
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
+#else
+                    cixml->postui(cixml->job, "@js", js);
+#endif
                 }
             }
             //next_status = "end";
@@ -205,7 +222,7 @@ void MmtControl::CheckEvent() {
  * UnitTest for class CiParser
  */
 void TestXmlParser() {
-    std::string xml = "mmt://localhost/home/yongzxu/Videos/mmt/ci.xml";
+    std::string xml = "mmt://localhost/tmp/ci.xml";
     CiParserPtr parser = new CiParser(xml);
     parser->ParseXml();
     parser->ParseHtmlTag();
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 6b9d6ae..aa11a6c 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -27,6 +27,7 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
  *  three parameters: (job object, stream_info_t, errno)
  */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+typedef void (*postui_func_t) (job_refptr_t, const std::string, const std::string&);
 
 /**
  * Stream IO Information
@@ -36,6 +37,7 @@ struct stream_info_t {
     int             size;
     int             offset;
     stream_func_t   func;
+    postui_func_t   postui;
 };
 
 /**
@@ -62,6 +64,8 @@ public:
     cixml_t();
     std::string status;
     CiParserPtr parser;
+    job_refptr_t job;
+    postui_func_t postui;
 
 protected:
     friend class base::RefCounted<cixml_t>;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index e9aa6a7..2d0440f 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -9,7 +9,10 @@ content_t::content_t() {
     frame_id = 0;
     routing_id = 0;
     tab_id = 0;
-    tab_url = "";
+    //tab_url = "";
+    
+    head = "";
+    body = "";
 }
 content_t::~content_t() {
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index cb78227..32712d3 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -35,7 +35,11 @@ struct content_t {
     int frame_id;   //> render frame id
     int routing_id; //> render host routing id 
     int tab_id;     //> chrome's tab id
-    std::string tab_url;    //> chrome's tab url
+    GURL tab_url;   //> chrome's tab url
+
+    // for extra message
+    std::string head;
+    std::string body;
 };
 
 } // namespace mmt
diff --git a/net/mmt/mpu/moof_combine.sh b/net/mmt/mpu/moof_combine.sh
index 5b6cf0e..78d964b 100644
--- a/net/mmt/mpu/moof_combine.sh
+++ b/net/mmt/mpu/moof_combine.sh
@@ -2,8 +2,8 @@
 rm -rf audio
 mkdir -p audio
 
-apath="/home/yongzxu/Downloads/MPUFile/"
-apath="/home/yongzxu/Videos/mmt/loveapartment_0203/audio"
+apath="$HOME/Downloads/MPUFile/"
+apath="$HOME/Videos/mmt/loveapartment_0203/audio"
 name="loveapartment_Audio1_MPU"
 offset=1037
 
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4e10c38..230ecff 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -88,6 +88,7 @@ bool URLRequestMmtJob::ReadRawData(IOBuffer* dest,
   sinfo.size = dest_size;
   sinfo.offset = read_info_.read_offset;
   sinfo.func = &URLRequestMmtJob::DoRead;
+  sinfo.postui = &URLRequestMmtJob::DoPostUI;
 
   // return ERR_IO_PENDING if aysnc read
   int rv = mmt::PostCtrlTask("@read", request_->url(), sinfo, this, content_.tab_id);
@@ -299,7 +300,7 @@ bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserCon
 void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
     if (!content) return;
     content->tab_id = -1;
-    content->tab_url = "";
+    //content->tab_url = "";
 
     content::RenderFrameHost* rfh = 
         content::RenderFrameHost::FromID(content->process_id, content->frame_id);
@@ -318,16 +319,34 @@ void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_stor
         LOG(INFO) << __func__ << " web_contents is nullptr";
         return;
     }
+
     content->tab_id = extensions::ExtensionTabUtil::GetTabId(web_contents);
-    std::ostringstream sstr;
-    sstr << web_contents->GetURL();
-    content->tab_url = sstr.str();
-    LOG(INFO) << __func__ 
-        << " tab id=" << content->tab_id
-        << ", tab url=" << content->tab_url;
+    content->tab_url = web_contents->GetURL();
+    content::RenderFrameHost* main_frame = web_contents->GetMainFrame();
+    LOG(INFO) << __func__  
+        << " main_frame=" << main_frame << ", head=" << content->head
+        << " tab id=" << content->tab_id << ", tab url=" << content->tab_url;
+    if (main_frame) {
+        if(content->head == "@js" && !content->body.empty()) { // for js
+            main_frame->ExecuteJavaScript(base::ASCIIToUTF16(content->body.c_str()));
+        }
+    }
+
+    // for extension and chrome.storage
     if (has_storage) {
         GetExtension(content, web_contents->GetBrowserContext());
     }
 }
 
+void URLRequestMmtJob::DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body) {
+    LOG(INFO) << __func__;
+    scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
+    if (thiz) {
+        thiz->content_.head = head;
+        thiz->content_.body = body;
+        content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+            base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &thiz->content_, false));
+    }
+}
+
 }  // namespace net
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index dd34d13..ece9f1e 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -79,6 +79,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
   static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
   static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
+  static void DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body);
 
  private:
   const scoped_refptr<base::TaskRunner> task_runner_;
-- 
1.7.9.5


From dc13475f1413a65318fc8df178e65b6ad13f077a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 06:16:41 -0800
Subject: [PATCH 069/128] [ok] refine docs for mmt_control

---
 net/mmt/mmt_control.cc |  153 ++++++++++++++++++++++++++++--------------------
 net/mmt/mmt_control.h  |   64 +++++++++++++-------
 2 files changed, 131 insertions(+), 86 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 91be573..95d2e56 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -3,6 +3,10 @@
 
 namespace mmt {
 
+static const int kMmtLoopInterval = 100; // ms
+static const int kMmtReadInterval = 10; // ms
+static const char kMmtDefaultXml[] = "mmt://localhost/tmp/ci.xml";
+
 static MmtControl *g_ctrl = nullptr;
 
 void StartMmtCtrl() {
@@ -17,13 +21,11 @@ void StartMmtCtrl() {
     LOG(INFO) << __func__ << " started=" << g_ctrl->HasBeenStarted();
 }
 
-void PostCtrlMsg(ctrl_msg_t &msg) {
+static void PostCtrlMsg(ctrl_msg_t &msg) {
     if (!g_ctrl) return;
     g_ctrl->Push(msg);
 }
 
-
-// for @ctrl
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -32,7 +34,7 @@ void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid) {
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
-// for @close
+
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -41,7 +43,7 @@ void PostCtrlTask(std::string head, GURL gurl, job_refptr_t ptr, int tabid) {
     msg.tabid = tabid;
     PostCtrlMsg(msg);
 }
-// for @open and @read
+
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t ptr, int tabid) {
     ctrl_msg_t msg;
     msg.head = head;
@@ -50,7 +52,47 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
     msg.ptr = ptr;
     msg.tabid = tabid;
     PostCtrlMsg(msg);
-    return -1; //> default IO_PENDING(-1) and Async Read
+    return -1; 
+}
+
+/**
+ * UnitTest for class CiParser
+ */
+void TestXmlParser() {
+    std::string xml = kMmtDefaultXml;
+    CiParserPtr parser = new CiParser(xml);
+    parser->ParseXml();
+    parser->ParseHtmlTag();
+    std::string js;
+    parser->GetHtmlJS(0, js);
+    LOG(INFO) << __func__ << " js1: " << js;
+    parser->GetHtmlJS(1080, js);
+    LOG(INFO) << __func__ << " js2: " << js;
+    parser->GetHtmlJS(1086, js);
+    LOG(INFO) << __func__ << " js3: " << js;
+}
+
+/**
+ * To generate json data for mmt native message
+ */
+void GetJsonData(int tabid, std::string js, std::string& json) {
+    json += "{";
+    json += "\"tabid\" : " + Int2String(tabid);
+    json += ", ";
+    json += "\"js\" : \"" + js + "\"";
+    json += "}";
+}
+
+/**
+ * The algorithm to generate unique key for UrlRequestMmtJob
+ */
+static std::string mmtjob_key(GURL url, void* ptr) {
+    std::string name = url.spec();
+    std::stringstream sstr;
+    sstr << name << "@" << ptr;
+    std::string key;
+    sstr >> key;
+    return key;
 }
 
 } // namespace mmt
@@ -59,50 +101,52 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
 /// for class MmtControl
 namespace mmt {
 
+stream_info_t::stream_info_t() {
+    buf = nullptr;
+    size = 0;
+    offset = 0;
+    func = nullptr;
+    postui = nullptr;
+}
+stream_info_t::~stream_info_t() {
+    buf = nullptr;
+    func = nullptr;
+    postui = nullptr;
+}
+
 ctrl_msg_t::ctrl_msg_t() {
     head = "";
     body = "";
     tabid = -1;
     ptr = nullptr;
-
-    sinfo.buf = nullptr;
-    sinfo.size = 0;
-    sinfo.offset = 0;
-    sinfo.func = nullptr;
-    sinfo.postui = nullptr;
 }
 ctrl_msg_t::~ctrl_msg_t() {
+    ptr = nullptr;
 }
 
 cixml_t::cixml_t() {
+    fname = "";
     status = "initing";
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
 }
 cixml_t::~cixml_t() {
-    status = "uniniting";
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
 }
 
-/**
- * The algorithm to generate unique key for UrlRequestJob
- */
-static std::string mmtjob_key(GURL url, void* ptr) {
-    std::string name = url.spec();
-    std::stringstream sstr;
-    sstr << name << "@" << ptr;
-    std::string key;
-    sstr >> key;
-    return key;
-}
 
 MmtControl::MmtControl() : SimpleThread("mmt_control"){
     running_ = false;
 }
-MmtControl::~MmtControl() {}
+MmtControl::~MmtControl() {
+    loop_ = false;
+    queue_.clear();
+    cixmls_.clear();
+    streams_.clear();
+}
 
 void MmtControl::StreamOpen(ctrl_msg_t msg) {
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
@@ -139,17 +183,21 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         }
     }
 
-    // save information of current table
+    // save information of current tab of chrome
     if (msg.tabid > 0) {
         cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
             LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
             cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
+            // TODO ci xml for testing
+            cixml->fname = kMmtDefaultXml;
         }else {
             cixml = cixmls_[msg.tabid];
         }
-        cixml->job = msg.ptr;
+
+        // do it repeatly to avoid changes of UrlRequestMmtJob
+        cixml->job = msg.ptr; 
         cixml->postui = msg.sinfo.postui;
     }
 }
@@ -163,30 +211,22 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
-void GetJsonData(int tabid, std::string js, std::string& json) {
-    json += "{";
-    json += "\"tabid\" : " + Int2String(tabid);
-    json += ", ";
-    json += "\"js\" : \"" + js + "\"";
-    json += "}";
-}
 void MmtControl::CheckEvent() {
-    // TODO for testing
-    std::string xml = "mmt://localhost/tmp/ci.xml";
-
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
         cixmlptr_t cixml = iter->second;
         if (!cixml) continue;
         if (cixml->status == "end") continue;
+        if (cixml->fname.empty()) continue;
 
-        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << cixml->status;
+        std::string xml_name = cixml->fname;
         std::string next_status = cixml->status;
         CiParserPtr parser = cixml->parser;
 
+        //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
         if (cixml->status == "initing") {
             if (!cixml->parser) {
-                cixml->parser = new CiParser(xml);
+                cixml->parser = new CiParser(xml_name);
             }
             next_status = "loading";
             Wait(100);
@@ -202,7 +242,7 @@ void MmtControl::CheckEvent() {
                 std::string js;
                 long ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
-#if 0
+#ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
                     GetJsonData(iter->first, js, json);
                     LOG(INFO) << __func__ << " json => " << json;
@@ -218,53 +258,36 @@ void MmtControl::CheckEvent() {
     }
 }
 
-/**
- * UnitTest for class CiParser
- */
-void TestXmlParser() {
-    std::string xml = "mmt://localhost/tmp/ci.xml";
-    CiParserPtr parser = new CiParser(xml);
-    parser->ParseXml();
-    parser->ParseHtmlTag();
-    std::string js;
-    parser->GetHtmlJS(0, js);
-    LOG(INFO) << __func__ << " js1: " << js;
-    parser->GetHtmlJS(1080, js);
-    LOG(INFO) << __func__ << " js2: " << js;
-    parser->GetHtmlJS(1086, js);
-    LOG(INFO) << __func__ << " js3: " << js;
-}
-
-/**
- * Thread Main Loop
- */
 void MmtControl::Run() {
     LOG(INFO) << __func__ << " begin";
     running_ = true;
-    int ms = 100;
+    int ms = kMmtLoopInterval;
     while(loop_) {
+        // check ci event
         CheckEvent();
 
+        // get one msg
         ctrl_msg_t msg;
         if (!Pop(msg)) {
             Wait(ms);
             continue;
         }
 
+        // process msg
         std::string head = msg.head;
         if (head == "@ctrl") {
             SendToHost(msg.body, "127.0.0.1", 54321);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@open") {
             StreamOpen(msg);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@close") {
             StreamClose(msg);
-            ms = 100;
+            ms = kMmtLoopInterval;
         }else if (msg.head == "@read") {
             //TODO: if io pending, should re-push this msg again.
             StreamRead(msg);
-            ms = 10;
+            ms = kMmtReadInterval;
         }
         Wait(ms);
     };
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index aa11a6c..67d5c87 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -23,21 +23,28 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
 
 
 /**
- * Stream IO callback function,
+ * Stream IO callback function, which is used to pass data to UrlRequestMmtJob.
  *  three parameters: (job object, stream_info_t, errno)
  */
 typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+
+/**
+ * Post task over UI thread, which is used to execute JS scripts in UrlRequestMmtJob.
+ */
 typedef void (*postui_func_t) (job_refptr_t, const std::string, const std::string&);
 
 /**
  * Stream IO Information
  */
 struct stream_info_t {
-    net::IOBuffer*  buf;
-    int             size;
-    int             offset;
-    stream_func_t   func;
-    postui_func_t   postui;
+    stream_info_t();
+    ~stream_info_t();
+
+    net::IOBuffer*  buf;        // media buffer
+    int             size;       // data size
+    int             offset;     // data offset from the beginning
+    stream_func_t   func;       // stream io callback function
+    postui_func_t   postui;     // post task function
 };
 
 /**
@@ -48,24 +55,26 @@ struct ctrl_msg_t {
     ~ctrl_msg_t();
 
     std::string head;   //> msg tag: @open, @read, @close, @ctrl and etc.
-    std::string body;
+    std::string body;   //> msg body: only valid for @ctrl
+
     GURL url;           //> access url
     int tabid;          //> chrome's tab id
-    job_refptr_t ptr;   //> job object
-
-    stream_info_t sinfo;    //> valid for @open, @read and @close
+    job_refptr_t ptr;   //> job(UrlRequestMmtJob) object
+    stream_info_t sinfo;    //> only valid for @open, @read and @close
 };
 
 /**
- * Structure for CI XML to process ci. 
+ * Structure for CI XML. 
  */
 struct cixml_t : public base::RefCounted<cixml_t> {
 public:
     cixml_t();
-    std::string status;
-    CiParserPtr parser;
-    job_refptr_t job;
-    postui_func_t postui;
+
+    std::string fname;      //> xml file name
+    std::string status;     //> ci status: initing,loading,loaded
+    CiParserPtr parser;     //> xml parser for ci
+    job_refptr_t job;       //> UrlRequestMmtJob object
+    postui_func_t postui;   //> function for execute js script
 
 protected:
     friend class base::RefCounted<cixml_t>;
@@ -81,6 +90,10 @@ class MmtControl : public base::SimpleThread {
 public:
     MmtControl();
     virtual ~MmtControl();
+
+    /**
+     * Thread Main Loop
+     */
     virtual void Run() override;
 
     void Reset();
@@ -100,10 +113,10 @@ protected:
 private:
     bool loop_;
     bool running_;
-    std::vector<ctrl_msg_t> queue_;
-    std::map<int, cixmlptr_t> cixmls_; //> (tabid => cixml_t)
-
     base::Lock lock_;
+
+    std::vector<ctrl_msg_t> queue_;     
+    std::map<int, cixmlptr_t> cixmls_;  //> key/value: tabid => cixml_t
     StreamPtrs_t streams_;
 };
 
@@ -115,11 +128,20 @@ namespace mmt {
 // Start control center
 void StartMmtCtrl();
 
-// for @ctrl
+/**
+ * param head: @ctrl, not be used now
+ */
 void PostCtrlTask(std::string head, GURL gurl, std::string body, int tabid);
-// for @close
+
+/**
+ * param head: @close
+ */
 void PostCtrlTask(std::string head, GURL gurl, job_refptr_t refptr, int tabid);
-// for @open and @read
+
+/**
+ * param head: @open or @read
+ * default return IO_PENDING(-1) which means open/read async
+ */
 int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t refptr, int tabid);
 
 } // namespace mmt
-- 
1.7.9.5


From 8c23ebfc55d3c588366d7d4c4c1251d87f5af439 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 06:50:19 -0800
Subject: [PATCH 070/128] [todo] refine for mmt_stream and add some support
 mp4 image file

---
 net/mmt/mmt_stream.cc |   65 ++++++++++++++++++++++++++++++++++---------------
 net/mmt/mmt_stream.h  |   25 +++++++++++++------
 2 files changed, 64 insertions(+), 26 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 2d0440f..caaa964 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,24 +4,26 @@
 
 namespace mmt {
 
+static const char kMmtMediaAudio[] = "audio";
+static const char kMmtMediaVideo[] = "video";
+static const char kMmtMediaImage[] = "image";
+
+static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
+static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
+
+
 content_t::content_t() {
     process_id = 0;
     frame_id = 0;
     routing_id = 0;
     tab_id = 0;
     //tab_url = "";
-    
     head = "";
     body = "";
 }
 content_t::~content_t() {
 }
 
-} // namespace mmt
-
-
-namespace mmt {
-
 /**
  * For mpu's stream io
  */
@@ -46,6 +48,7 @@ static uint64_t mmtp_tell(stream_t *s) {
 static int mmtp_close(stream_t *s) {
     return ((Stream*)s->opaque)->Close();
 }
+
 stream_t* InitMpuStream(Stream* ptr) {
     stream_t* s = (stream_t*)malloc(sizeof(stream_t));
     s->opaque = (void*)ptr;
@@ -71,6 +74,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
     midx_.end = -1;
     midx_.cur = -1;
 }
+
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
 }
 
@@ -79,7 +83,7 @@ Stream::~Stream() {
 }
 
 bool Stream::ParseSequence(int& index) {
-    // if exists query, then should redirect to real file name
+    // if exists query in URL, then should redirect to real filename
     std::string query = url_.query();
     if (!query.empty()) { // media sequence
         std::string mtype = GetQueryValue(query, "type");
@@ -87,27 +91,34 @@ bool Stream::ParseSequence(int& index) {
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
         if (mtype.empty()) return false;
 
+        if (mtype == kMmtMediaImage) {
+            index = -2;
+            return true;
+        }
+
         // compute the sequence of media
         GetRangeValue(range, midx_.begin, midx_.end);
         index = midx_.begin;
         LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
         if (index < 0 || midx_.begin > midx_.end) return false;
-    }else {
+    }else { // may be one seperate file, not one media sequence
         index = -1;
     }
     return true;
 }
+
 bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
-    long lret = 1<<30; // default 1GB
-    if (midx_.cur == -1) { // for one single file
+    long lret = 1<<31;      // TODO: default 2GB size for media sequence
+    if (midx_.cur < 0) {  // return real size for single file
         lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
     return true;
 }
+
 void* Stream::Open(const char* filename, int mode) {
     if (file_) return (void *)file_;
 
@@ -117,17 +128,22 @@ void* Stream::Open(const char* filename, int mode) {
         return nullptr;
     }
 
-    // default file is html
+    // default for one seperate file
+    //  index >= 0: media sequence
+    //  index == -1: common file
+    //  index == -2: mp4 image file
     std::string fname = GURL2FilePath(url_);
-    if (index >= 0) {
+    if (index >= 0) { // for media sequence
         if (index < midx_.begin || index > midx_.end)
             return nullptr;
 
         std::string mtype = GetQueryValue(url_.query(), "type");
-        if (mtype == "audio") {
-            fname = fname + "/audio/loveapartment_Audio1_MPU_" + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == "video") {
-            fname = fname + "/video/loveapartment_Video1_MPU_" + Int2String(index, 4) + ".mp4"; 
+        if (mtype == kMmtMediaAudio) {
+            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype == kMmtMediaVideo) {
+            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype == kMmtMediaImage) {
+            // nothing to do
         }
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
@@ -145,18 +161,22 @@ void* Stream::Open(const char* filename, int mode) {
 
     if (index != -1 && index != midx_.begin) {
 #if 1
+        // TODO: process image of mp4 here
+        // check moof box and other
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
         mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
         LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
+
+        // get the pos of the 1st moof-box
         long offset = -1;
         if (box) offset = box->i_pos;
         MP4_BoxFree(s, root);
         free(s);
-        if (offset == -1) return nullptr;
         
         // seek to the 1st moof-box
+        if (offset == -1) return nullptr;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
@@ -172,36 +192,43 @@ void* Stream::Open(const char* filename, int mode) {
     midx_.cur = index;
     return (void *)file_;
 }
+
 int Stream::Read(void *buf, int size) {
     if (!Open(nullptr, 0)) return -2;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
         Close();
-        if (midx_.cur != -1) midx_.cur++; // goto next file
+        if (midx_.cur >= 0) midx_.cur++; // goto next file if it is media sequence
     }
     return iret; 
 }
+
 int Stream::Write(void *buf, int size) {
-    return -1;
+    return -1; // unsupported
 }
+
 int Stream::Peek(void *buf, int size) {
     long offset = ftell(file_);
     int iret = fread(buf, 1, size, file_);
     fseek(file_, offset, SEEK_SET);
     return iret;
 }
+
 uint64_t Stream::Seek(int64_t offset, int whence) {
     return fseek(file_, offset, whence);
 }
+
 uint64_t Stream::Tell() {
     return ftell(file_);
 }
+
 int Stream::Close() {
     if (file_) fclose(file_);
     file_ = nullptr;
     return 0;
 }
+
 void Stream::Uninit() {
     Close();
     midx_.begin = -1;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 32712d3..65916b2 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -25,7 +25,7 @@ class IOBuffer;
 namespace mmt {
 
 /**
- * Collect the information of URLRequestJob
+ * To collect the information of URLRequestMmtJob
  */
 struct content_t {
     content_t();
@@ -37,8 +37,8 @@ struct content_t {
     int tab_id;     //> chrome's tab id
     GURL tab_url;   //> chrome's tab url
 
-    // for extra message
-    std::string head;
+    // for extra message (now for js script)
+    std::string head; //> tag: @js
     std::string body;
 };
 
@@ -52,14 +52,21 @@ struct triple_t {
     int end;
     int cur;
 };
+
+/**
+ * stream read offset/size
+ */
 struct offset_t {
     offset_t() : off(0), size(0) {}
     offset_t(long off, long size) : off(off), size(size) {}
 
-    long off;
-    long size;
+    long off;   //> offset of reading 
+    long size;  //> size of reading
 };
 
+/**
+ * Stream IO interfaces
+ */
 class IStream {
 public:
    virtual void*    Open(const char* filename, int mode) = 0;
@@ -88,6 +95,10 @@ public:
 
     explicit Stream(const GURL& url);
     explicit Stream(const std::string& szurl);
+
+    /**
+     * if success, set size with the data length
+     */
     bool Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
@@ -98,7 +109,7 @@ protected:
 
 private:
     GURL url_;
-    triple_t midx_; //> media index
+    triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
 
@@ -106,7 +117,7 @@ private:
 };
 
 typedef scoped_refptr<Stream> StreamPtr;
-typedef std::map<std::string, StreamPtr>  StreamPtrs_t;
+typedef std::map<std::string, StreamPtr> StreamPtrs_t;
 
 } // namespace mmt
 
-- 
1.7.9.5


From bf4c2d6a1827f9bcee13cb276e85a259658d02b5 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 07:08:34 -0800
Subject: [PATCH 071/128] [todo] refine file size with long to replace int

---
 net/mmt/mmt_control.h                  |    2 +-
 net/mmt/mmt_stream.cc                  |    6 ++++--
 net/url_request/url_request_mmt_job.cc |   22 +++++++++++-----------
 net/url_request/url_request_mmt_job.h  |    8 ++++----
 4 files changed, 20 insertions(+), 18 deletions(-)

diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 67d5c87..150f148 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -26,7 +26,7 @@ typedef scoped_refptr<net::URLRequestJob> job_refptr_t;
  * Stream IO callback function, which is used to pass data to UrlRequestMmtJob.
  *  three parameters: (job object, stream_info_t, errno)
  */
-typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, int);
+typedef void (*stream_func_t)(job_refptr_t, stream_info_t&, long);
 
 /**
  * Post task over UI thread, which is used to execute JS scripts in UrlRequestMmtJob.
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index caaa964..75e90e5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -4,6 +4,8 @@
 
 namespace mmt {
 
+static const long kMmtMediaSize = 0x7fffffff;
+
 static const char kMmtMediaAudio[] = "audio";
 static const char kMmtMediaVideo[] = "video";
 static const char kMmtMediaImage[] = "image";
@@ -110,8 +112,8 @@ bool Stream::ParseSequence(int& index) {
 bool Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return false;
 
-    long lret = 1<<31;      // TODO: default 2GB size for media sequence
-    if (midx_.cur < 0) {  // return real size for single file
+    long lret = kMmtMediaSize;  // TODO: default size for media sequence
+    if (midx_.cur < 0) {        // return real size for single file
         lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 230ecff..0ffc7bc 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -159,18 +159,18 @@ URLRequestMmtJob::~URLRequestMmtJob() {
   LOG(INFO) << __func__ << " thiz=" << this;
 }
 
-void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  LOG(INFO) << __func__ << " iret=" << iret;
+void URLRequestMmtJob::DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  LOG(INFO) << __func__ << " lret=" << lret;
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), iret));
+        base::Bind(&URLRequestMmtJob::DidStart, thiz->weak_ptr_factory_.GetWeakPtr(), lret));
   }
 }
 
-void URLRequestMmtJob::DidStart(int iret) {
+void URLRequestMmtJob::DidStart(long lret) {
   int result = OK;
-  if (iret <= 0) {
+  if (lret <= 0) {
     result = ERR_FAILED;
   }
 
@@ -183,7 +183,7 @@ void URLRequestMmtJob::DidStart(int iret) {
     return;
   }
 
-  read_info_.total_size = iret;
+  read_info_.total_size = lret;
   if (!byte_range_.ComputeBounds(read_info_.total_size)) {
     NotifyDone(URLRequestStatus(URLRequestStatus::FAILED,
                ERR_REQUEST_RANGE_NOT_SATISFIABLE));
@@ -204,20 +204,20 @@ void URLRequestMmtJob::DidStart(int iret) {
   NotifyHeadersComplete();
 }
 
-void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret) {
-  if (iret < 0) {
-    LOG(INFO) << __func__ << " iret=" << iret << 
+void URLRequestMmtJob::DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret) {
+  if (lret < 0) {
+    LOG(INFO) << __func__ << " lret=" << lret << 
         " size=" << sinfo.size << " offset=" << sinfo.offset << " ptr=" << ptr;
     return;
   }
   scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
   if (thiz) {
     content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, iret));
+        base::Bind(&URLRequestMmtJob::DidRead, thiz->weak_ptr_factory_.GetWeakPtr(), nullptr, lret));
   }
 }
 
-void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, int size) {
+void URLRequestMmtJob::DidRead(net::IOBuffer* iobuf, long size) {
   int result = size;
   if (result > 0) {
     SetStatus(URLRequestStatus());  // Clear the IO_PENDING status
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index ece9f1e..f1f189c 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -65,11 +65,11 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
     GURL url;
   };
 
-  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
-  void DidStart(int iret);
+  static void DoStart(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidStart(long iret);
 
-  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, int iret);
-  void DidRead(net::IOBuffer* iobuf, int size);
+  static void DoRead(mmt::job_refptr_t ptr, mmt::stream_info_t& sinfo, long lret);
+  void DidRead(net::IOBuffer* iobuf, long size);
 
   static void DoTest(void* ptr);
   void DidTest(void* ptr);
-- 
1.7.9.5


From 91369cd3ad86e1bd74c0b60013457a2bbe55358f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 19:21:47 -0800
Subject: [PATCH 072/128] [todo] refine mmt_parse's docs

---
 net/mmt/mmt_control.cc |    5 ++-
 net/mmt/mmt_parser.cc  |   51 ++++++++++++++-----------
 net/mmt/mmt_parser.h   |   98 +++++++++++++++++++++++++++++++-----------------
 net/mmt/mmt_utils.cc   |   10 ++++-
 4 files changed, 104 insertions(+), 60 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 95d2e56..9500f2e 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -3,6 +3,7 @@
 
 namespace mmt {
 
+//#define USE_MMT_NATIVE_MESSAGE 1
 static const int kMmtLoopInterval = 100; // ms
 static const int kMmtReadInterval = 10; // ms
 static const char kMmtDefaultXml[] = "mmt://localhost/tmp/ci.xml";
@@ -62,7 +63,7 @@ void TestXmlParser() {
     std::string xml = kMmtDefaultXml;
     CiParserPtr parser = new CiParser(xml);
     parser->ParseXml();
-    parser->ParseHtmlTag();
+    parser->ParseHtml();
     std::string js;
     parser->GetHtmlJS(0, js);
     LOG(INFO) << __func__ << " js1: " << js;
@@ -233,7 +234,7 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loading") {
             if (parser) {
                 parser->ParseXml();
-                parser->ParseHtmlTag();
+                parser->ParseHtml();
             }
             next_status = "loaded";
             Wait(1000);
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index cd71f93..af65760 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -10,7 +10,7 @@ static const char kNoValue[] = "no-value";
 /**
  * String constants for ci xml node
  */
-//static const char kCI[]             = "mmtci:CI";
+static const char kCI[]             = "mmtci:CI";
 static const char kview[]           = "mmtci:view";
 static const char kdivLocation[]    = "mmtci:divLocation";
 static const char kMediaSync[]      = "mmtci:MediaSync";
@@ -114,7 +114,12 @@ long ParseTimeStr(std::string timestr) {
         return -1;
     }
 
-#if 1
+#ifdef USE_NTP_TIME
+    Time time;
+    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+        return 0;
+    ms = (long)base::Time::ToJsTime(); //milliseconds
+#else
     long sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
@@ -130,16 +135,10 @@ long ParseTimeStr(std::string timestr) {
         }
     }
     ms = sec * 1000;
-#else
-    Time time;
-    if(!base::Time::FromUTCString(timestr.c_str(), &time))
-        return 0;
-    ms = (long)base::Time::ToJsTime(); //milliseconds
 #endif
     return ms;
 }
 
-
 } // namespace mmt
 
 
@@ -159,9 +158,11 @@ node_t::~node_t() {
     parent = nullptr;
 }
 
-html_t::html_t() {
+html_t::html_t() : node(nullptr) {
 }
 html_t::~html_t() {
+    js.clear();
+    node = nullptr;
 }
 
 
@@ -170,6 +171,8 @@ CiParser::CiParser(const std::string& fname)
 }
 
 CiParser::~CiParser() {
+    root_ = nullptr;
+    cur_ = nullptr;
 }
 
 bool CiParser::ParseXml() {
@@ -199,18 +202,19 @@ bool CiParser::ParseXml() {
 
     return true;
 }
-void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
+
+static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     if (!node) return;
 
     std::string id;
-    if (node->name == kdivLocation)
+    if (node->name == kdivLocation)     // div
         id = node->attrs[krefDiv];
-    else if (node->name == kMediaSync)
+    else if (node->name == kMediaSync)  // <audio><video><image>
         id = node->attrs[krefId];
     if (id.empty()) return;
 
-    std::string js0, js1;       // for time
-    std::string js00, js11;     // for click event
+    std::string js0, js1;       // for time of begin and end
+    std::string js00, js11;     // for click event of begin and end
     js0 = js1 = SetJSBegin(id);
     js00 = js11 = SetJSBegin(id);
 
@@ -257,6 +261,7 @@ void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     html->js[EHtmlClickEnd] = js11;
     htmls[id] = html;
 }
+
 void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
     if (!event.is_event || (event.event != kevbegin && event.event != kevend)) 
         return;
@@ -265,21 +270,21 @@ void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
     event.time = -1;
     if (htmls_.find(event.id) != htmls_.end()) {
         htmlptr_t html = htmls_[event.id];
-        // only support 1 level
+        //TODO: only support 1 level's event
         if (event.event == kevbegin)
             event.time = html->node->time.begin.time;
         else
             event.time = html->node->time.end.time; 
     }
 }
-bool CiParser::ParseHtmlTag() {
+
+bool CiParser::ParseHtml() {
     nodeptr_t node = root_;
     if (!node) return false;
     htmls_.clear();
 
-    nodeptrs_t::iterator iter1;
-
     // init html js
+    nodeptrs_t::iterator iter1;
     for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
         nodeptr_t sub1 = *iter1;
         if (sub1->name == kview) {
@@ -300,11 +305,8 @@ bool CiParser::ParseHtmlTag() {
         }
     }
 
-
-    //
     // process html js
     htmlmap_t::iterator iter;
-
     // end for time
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
@@ -338,7 +340,7 @@ bool CiParser::ParseHtmlTag() {
         }
     }
 
-    // end for event click
+    // process end for event click
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         html->js[EHtmlClickBegin] += SetJSEnd();
@@ -384,9 +386,11 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     }
     return false;
 }
+
 bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
     return false;
 }
+
 bool CiParser::GetHtmlJS(long current, std::string& js) {
     js = "";
     if (htmls_.empty()) return false;
@@ -432,6 +436,9 @@ bool CiParser::AddNode(std::string name) {
     if (!root_)  {
         root_ = node;
         cur_ = root_;
+        if (name != kCI) {
+            LOG(INFO) << __func__ << " invalid root node=" << name;
+        }
         return true;
     }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 8eef4a8..eb7e1fc 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -12,30 +12,38 @@
 
 namespace mmt {
 
-struct node_t;
+struct node_t; // xml node
 typedef scoped_refptr<node_t> nodeptr_t;
-typedef std::map<std::string, std::string> attrs_t;
-typedef std::vector<scoped_refptr<node_t> > nodeptrs_t;
+typedef std::vector<nodeptr_t> nodeptrs_t;
+typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name => value
 
 
 /**
- * Structore for mmtci:begin and mmtci:end
+ * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
-    EHtmlBegin,
-    EHtmlEnd,
-    EHtmlClickBegin,
-    EHtmlClickEnd,
+    EHtmlBegin,         //> mmtci:begin
+    EHtmlEnd,           //> mmtci:end
+    EHtmlClickBegin,    //> mmtci:begin's .click
+    EHtmlClickEnd,      //> mmtci:end's .click
 };
 
+/**
+ * The value of mmtci:begin or mmtci:end
+ */
 struct event_t {
     event_t();
-    bool is_event;
-    int is_timeout;
-    std::string id;
-    std::string event;
-    long time;          // ms, valid if no id
+
+    bool is_event;      //> event or time
+    int is_timeout;     //> 0: not timeout,
+    std::string id;     //> event id
+    std::string event;  //> event type
+    long time;          //> ms, valid if id is empty
 };
+
+/**
+ * For node's time (begin/end)
+ */
 struct citime_t {
     event_t begin;
     event_t end;
@@ -43,38 +51,41 @@ struct citime_t {
 
 
 /**
- * Structure for xml node
+ * The structure for xml node
  */
 struct node_t : public base::RefCounted<node_t>{
 public:
     explicit node_t(std::string name);
 
-    std::string name;
-    attrs_t attrs;
-    citime_t time;      // for time range
+    std::string name;   //> node's name
+    attrs_t attrs;      //> node's attr
+    citime_t time;      //> for time range(begin/end)
 
-    nodeptrs_t nodes;   // sub-nodes
-    nodeptr_t parent;
+    nodeptrs_t nodes;   //> sub nodes
+    nodeptr_t parent;   //> parent node
 
 protected:
     friend class base::RefCounted<node_t>;
     virtual ~node_t();
 };
 
-typedef std::map<int, std::string> jsmap_t;  // k/v: EHtmlEvent => ..
+/**
+ * The xml node will be mapped to html's tag by [struct html_t].
+ */
+typedef std::map<int, std::string> jsmap_t; 
 struct html_t : public base::RefCounted<html_t>{
 public:
     explicit html_t();
-    std::string id;
-    jsmap_t js;
-    nodeptr_t node;
+    std::string id;     //> html tag id
+    jsmap_t js;         //> key/value: EHtmlEvent => js
+    nodeptr_t node;     //> xml node
 
 protected:
     friend class base::RefCounted<html_t>;
     virtual ~html_t();
 };
 typedef scoped_refptr<html_t> htmlptr_t;
-typedef std::map<std::string, htmlptr_t> htmlmap_t; // k/v: tag id => ..
+typedef std::map<std::string, htmlptr_t> htmlmap_t; // key/value: html tag id => html_t
 
 
 /** 
@@ -84,28 +95,47 @@ class CiParser : public base::RefCounted<CiParser> {
 public:
     explicit CiParser(const std::string& fname);
 
+    /**
+     * To parse xml with libxml2 tools
+     */
     bool ParseXml();
-    bool ParseHtmlTag();
-    bool GetHtmlJS(long current, std::string& js);
 
-    void SetNodeTime(event_t& event, nodeptr_t node);
-    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
-    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
+    /**
+     * To parse html tags based on parsed xml nodes.
+     *  So it should be called after ParseXml().
+     */
+    bool ParseHtml();
+
+    /**
+     * To get current js to operate
+     *
+     * @param current[in]: current time(ms) (ntp or ntp diff)
+     * @param js[out]: returned js 
+     * @return true if success.
+     */
+    bool GetHtmlJS(long current, std::string& js);
 
+    /**
+     * To parse xml's node and its attr
+     */
     bool AddNode(std::string name);
     bool EndNode(std::string name);
     bool AddAttr(std::string name, std::string value);
+
+protected:
+    void SetNodeTime(event_t& event, nodeptr_t node);
+    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
     
 protected:
     friend class base::RefCounted<CiParser>;
     virtual ~CiParser();
 
 private:
-    std::string fname_;
-    nodeptr_t root_;
-    nodeptr_t cur_; // only for AddNode/AddAttr
-
-    htmlmap_t htmls_;
+    std::string fname_; //> xml file name
+    nodeptr_t root_;    //> xml's root node
+    nodeptr_t cur_;     //> only work for AddNode/AddAttr
+    htmlmap_t htmls_;   //> html tags
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 6ff147e..e0060be 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -4,6 +4,9 @@
 
 namespace mmt {
 
+//#define USE_NTP_TIME 1
+static const char kMmtNtpServer[] = "time.apple.com";
+
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
@@ -117,7 +120,7 @@ long GetNTPTime() {
 
     if (_lastntp == 0) {
         struct ntp_time_t ntp_time;
-        int iret = ntp_get_time("time.apple.com", &ntp_time);
+        int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
             _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
@@ -127,8 +130,11 @@ long GetNTPTime() {
     }
 
     long diff = GetLocalTime() - _last;
-    //long currentntp = _lastntp + diff;
+#ifdef USE_NTP_TIME
+    return _lastntp + diff;
+#else
     return diff;
+#endif
 }
 
 } // namespace mmt
-- 
1.7.9.5


From f1b826a0a86b8c56c90965378c1ed75a173edcb7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 19:22:17 -0800
Subject: [PATCH 073/128] [todo] add the process of time end

---
 net/mmt/mmt_parser.cc |   33 ++++++++++++++++++++++++++++++++-
 1 file changed, 32 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index af65760..ab5f853 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -387,7 +387,38 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::ShouldEndTime(long current, nodeptr_t node, int& ev) {
+bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
+    long curtime = -1;
+    if (!cnode) return false;
+
+    event_t end = cnode->time.end;
+    if (end.is_timeout > 0) return false;
+
+    if (end.event == kevclick) {
+        ev = EHtmlClickEnd;
+        cnode->time.end.is_timeout = 1;
+        return true;
+    }else {
+        ev = EHtmlEnd;
+        curtime = end.time;
+    }
+
+    // search cnode's parent
+    nodeptr_t node = cnode;
+    do {
+        if (!node->parent) break;
+        node = node->parent;
+        if (!node->time.end.is_event) {
+            if (node->time.end.time >= 0 && node->time.end.time <= curtime)
+                curtime = node->time.end.time;
+        }
+    }while(true);
+
+    LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
+    if (curtime >= 0 || curtime >= current) {
+        cnode->time.end.is_timeout = 1;
+        return true;
+    }
     return false;
 }
 
-- 
1.7.9.5


From 04ab3c0c7c98d7e4220b71abdf6642595d4efec9 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 20:26:50 -0800
Subject: [PATCH 074/128] [ok] support time end

---
 net/mmt/mmt_control.cc |    1 +
 net/mmt/mmt_parser.cc  |    2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 9500f2e..b01b93f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -249,6 +249,7 @@ void MmtControl::CheckEvent() {
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
 #else
+                    LOG(INFO) << __func__ << " js => " << js;
                     cixml->postui(cixml->job, "@js", js);
 #endif
                 }
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index ab5f853..7f1244c 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -415,7 +415,7 @@ bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
     }while(true);
 
     LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
-    if (curtime >= 0 || curtime >= current) {
+    if (curtime >= 0 && curtime <= current) {
         cnode->time.end.is_timeout = 1;
         return true;
     }
-- 
1.7.9.5


From 9ec5efc436baf3ad1cff9c5d5dbade8767244dca Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 5 Feb 2015 21:14:30 -0800
Subject: [PATCH 075/128] [todo] refine for ntp time with int64

---
 net/mmt/mmt_control.cc  |    2 +-
 net/mmt/mmt_inc.h       |    4 ++--
 net/mmt/mmt_parser.cc   |   18 +++++++++---------
 net/mmt/mmt_parser.h    |    8 ++++----
 net/mmt/mmt_utils.cc    |   15 +++++++++------
 net/mmt/ntp/ntpclient.c |   32 ++++++++++++++++++--------------
 6 files changed, 43 insertions(+), 36 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index b01b93f..5eb3c1e 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -241,7 +241,7 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loaded") {
             if (parser && cixml->postui) {
                 std::string js;
-                long ntp = GetNTPTime();
+                int64 ntp = GetNTPTime();
                 if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 9a5761a..f389b1d 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -75,8 +75,8 @@ int SendToHost(std::string msg, std::string szaddr, int port);
 /**
  * Get local/ntp time (ms)
  */
-long GetLocalTime();
-long GetNTPTime();
+int64 GetLocalTime();
+int64 GetNTPTime();
 
 }
 
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 7f1244c..1594ca5 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -108,8 +108,8 @@ inline std::string SetJSEnd() {
 /**
  * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
  */
-long ParseTimeStr(std::string timestr) {
-    long ms = 0;
+int64 ParseTimeStr(std::string timestr) {
+    int64 ms = 0;
     if (timestr == kevinf) {
         return -1;
     }
@@ -118,9 +118,9 @@ long ParseTimeStr(std::string timestr) {
     Time time;
     if(!base::Time::FromUTCString(timestr.c_str(), &time))
         return 0;
-    ms = (long)base::Time::ToJsTime(); //milliseconds
+    ms = (int64)time.ToJsTime(); //milliseconds
 #else
-    long sec = atoi(timestr.c_str());
+    int64 sec = atoi(timestr.c_str());
     std::string::size_type lpos, rpos;
     lpos = timestr.find(":");
     rpos = timestr.rfind(":");
@@ -352,8 +352,8 @@ bool CiParser::ParseHtml() {
 /**
  * To process both @begin and @end
  */
-bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
-    long curtime = -1;
+bool CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
     if (!cnode) return false;
 
     event_t begin = cnode->time.begin;
@@ -387,8 +387,8 @@ bool CiParser::ShouldBeginTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
-    long curtime = -1;
+bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
+    int64 curtime = -1;
     if (!cnode) return false;
 
     event_t end = cnode->time.end;
@@ -422,7 +422,7 @@ bool CiParser::ShouldEndTime(long current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
-bool CiParser::GetHtmlJS(long current, std::string& js) {
+bool CiParser::GetHtmlJS(int64 current, std::string& js) {
     js = "";
     if (htmls_.empty()) return false;
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index eb7e1fc..736806a 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -38,7 +38,7 @@ struct event_t {
     int is_timeout;     //> 0: not timeout,
     std::string id;     //> event id
     std::string event;  //> event type
-    long time;          //> ms, valid if id is empty
+    int64 time;          //> ms, valid if id is empty
 };
 
 /**
@@ -113,7 +113,7 @@ public:
      * @param js[out]: returned js 
      * @return true if success.
      */
-    bool GetHtmlJS(long current, std::string& js);
+    bool GetHtmlJS(int64 current, std::string& js);
 
     /**
      * To parse xml's node and its attr
@@ -124,8 +124,8 @@ public:
 
 protected:
     void SetNodeTime(event_t& event, nodeptr_t node);
-    bool ShouldBeginTime(long current, nodeptr_t node, int& ev);
-    bool ShouldEndTime(long current, nodeptr_t node, int& ev);
+    bool ShouldBeginTime(int64 current, nodeptr_t node, int& ev);
+    bool ShouldEndTime(int64 current, nodeptr_t node, int& ev);
     
 protected:
     friend class base::RefCounted<CiParser>;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index e0060be..2327548 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -107,29 +107,32 @@ int SendToHost(std::string msg, std::string szaddr, int port) {
     return iret;
 }
 
-long GetLocalTime() {
+int64 GetLocalTime() {
     struct timeval tv;
     memset(&tv, 0, sizeof(tv));
     gettimeofday(&tv, NULL);
     return tv.tv_sec*1000 + tv.tv_usec/1000;
 }
 
-long GetNTPTime() {
-    static long _lastntp = 0;   // ntp time
-    static long _last = 0;      // local tome
+int64 GetNTPTime() {
+    static int64 _lastntp = 0;   // ntp time
+    static int64 _last = 0;      // local tome
 
     if (_lastntp == 0) {
         struct ntp_time_t ntp_time;
+        memset(&ntp_time, 0, sizeof(ntp_time));
         int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
             _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
         else
             _lastntp = _last;
-        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last;
+        LOG(INFO) << __func__ 
+            << " day=" << ntp_time.day << " sec=" << ntp_time.sec
+            << " ntp=" << _lastntp << " local=" << _last;
     }
 
-    long diff = GetLocalTime() - _last;
+    int64 diff = GetLocalTime() - _last;
 #ifdef USE_NTP_TIME
     return _lastntp + diff;
 #else
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
index 293eca0..1bd5588 100644
--- a/net/mmt/ntp/ntpclient.c
+++ b/net/mmt/ntp/ntpclient.c
@@ -610,24 +610,21 @@ static void usage(char *argv0)
 #ifdef LIBNTP 
 int ntp_get_time(const char* host, struct ntp_time_t* ntp_time) {
     if (!host || !ntp_time) return -1;
-    int argc = 4;
-    char* argv[] = {
-        "ntp_get_time",
-        "-h time.apple.com",
-        "-i 1",
-        "-c 1"
-    };
+    int argc = 1;
+    char *argv[] = {"ntp_get_time"};
+
+	char *hostname=(char *)host;
+	struct ntp_control ntpc;
+	ntpc.live=0;
+	ntpc.set_clock=0;
+	ntpc.probe_count=1;
+	ntpc.cycle_time=1;
+	ntpc.goodness=0;
+	ntpc.cross_check=1;
 #else
 int main(int argc, char *argv[]) {
     struct ntp_time_t* ntp_time = NULL;
-#endif
-	int usd;  /* socket */
-	int c;
-	/* These parameters are settable from the command line
-	   the initializations here provide default behavior */
-	short int udp_local_port=0;   /* default of 0 means kernel chooses */
 	char *hostname=NULL;          /* must be set */
-	int initial_freq;             /* initial freq value to use */
 	struct ntp_control ntpc;
 	ntpc.live=0;
 	ntpc.set_clock=0;
@@ -635,6 +632,13 @@ int main(int argc, char *argv[]) {
 	ntpc.cycle_time=600;          /* seconds */
 	ntpc.goodness=0;
 	ntpc.cross_check=1;
+#endif
+	int usd;  /* socket */
+	int c;
+	/* These parameters are settable from the command line
+	   the initializations here provide default behavior */
+	short int udp_local_port=0;   /* default of 0 means kernel chooses */
+	int initial_freq;             /* initial freq value to use */
 
 	for (;;) {
 		c = getopt( argc, argv, "c:" DEBUG_OPTION "f:g:h:i:lp:q:" REPLAY_OPTION "st");
-- 
1.7.9.5


From 5d4b2eb2b24c202e734901f3826df43013412b51 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 19:27:30 -0800
Subject: [PATCH 076/128] [todo] use ntp and adjust xml parser

---
 net/mmt/mmt_parser.cc   |   24 +++++++++++++-----------
 net/mmt/mmt_utils.cc    |   10 +++++-----
 net/mmt/ntp/ntpclient.c |    4 ++--
 net/mmt/ntp/ntpclient.h |    6 ++++--
 4 files changed, 24 insertions(+), 20 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 1594ca5..3b57285 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -5,25 +5,27 @@
 
 namespace mmt {
 
+#define USE_NTP_TIME 1
+
 static const char kNoValue[] = "no-value";
 
 /**
  * String constants for ci xml node
  */
-static const char kCI[]             = "mmtci:CI";
-static const char kview[]           = "mmtci:view";
-static const char kdivLocation[]    = "mmtci:divLocation";
-static const char kMediaSync[]      = "mmtci:MediaSync";
-static const char ksourceList[]     = "mmtci:sourceList";
+static const char kCI[]             = "CI";
+static const char kview[]           = "view";
+static const char kdivLocation[]    = "divLocation";
+static const char kMediaSync[]      = "MediaSync";
+static const char ksourceList[]     = "sourceList";
 
 /**
  * String constants for ci xml attr
  */
 static const char krefId[]      = "refId";
-static const char krefDiv[]     = "mmtci:refDiv";
-static const char kmediaSrc[]   = "mmtci:mediaSrc";
-static const char kbegin[]      = "mmtci:begin";
-static const char kend[]        = "mmtci:end";
+static const char krefDiv[]     = "refDiv";
+static const char kmediaSrc[]   = "mediaSrc";
+static const char kbegin[]      = "begin";
+static const char kend[]        = "end";
 static const char kstyle[]      = "style";
 
 /**
@@ -115,7 +117,7 @@ int64 ParseTimeStr(std::string timestr) {
     }
 
 #ifdef USE_NTP_TIME
-    Time time;
+    base::Time time;
     if(!base::Time::FromUTCString(timestr.c_str(), &time))
         return 0;
     ms = (int64)time.ToJsTime(); //milliseconds
@@ -462,7 +464,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
 }
 
 bool CiParser::AddNode(std::string name) {
-    //LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+    LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
     if (!root_)  {
         root_ = node;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 2327548..5952fab 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -4,7 +4,7 @@
 
 namespace mmt {
 
-//#define USE_NTP_TIME 1
+#define USE_NTP_TIME 1
 static const char kMmtNtpServer[] = "time.apple.com";
 
 void Wait(int ms) {
@@ -124,12 +124,12 @@ int64 GetNTPTime() {
         int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
         if (iret == 0)
-            _lastntp = ntp_time.day*86400*1000 + ntp_time.sec*1000;
+            _lastntp = (ntp_time.coarse-JAN_1970_SEC)*1000 + ntp_time.fine/4294967;
         else
             _lastntp = _last;
-        LOG(INFO) << __func__ 
-            << " day=" << ntp_time.day << " sec=" << ntp_time.sec
-            << " ntp=" << _lastntp << " local=" << _last;
+        LOG(INFO) << __func__ << " ntp=" << _lastntp << " local=" << _last
+            << " iret=" << iret
+            << " coarse=" << ntp_time.coarse << " fine=" << ntp_time.fine;
     }
 
     int64 diff = GetLocalTime() - _last;
diff --git a/net/mmt/ntp/ntpclient.c b/net/mmt/ntp/ntpclient.c
index 1bd5588..802d176 100644
--- a/net/mmt/ntp/ntpclient.c
+++ b/net/mmt/ntp/ntpclient.c
@@ -424,8 +424,8 @@ static int rfc1305print(u32 *data, struct ntptime *arrival, struct ntp_control *
 	}
 
     if (ntp_time) {
-        ntp_time->day = arrival->coarse/86400;
-        ntp_time->sec = arrival->coarse%86400;
+        ntp_time->coarse = arrival->coarse;
+        ntp_time->fine = arrival->fine;
     }else {
 	    printf("%d %.5d.%.3d  %8.1f %8.1f  %8.1f %8.1f %9d\n",
 		    arrival->coarse/86400, arrival->coarse%86400,
diff --git a/net/mmt/ntp/ntpclient.h b/net/mmt/ntp/ntpclient.h
index c6aa46e..bb756dd 100644
--- a/net/mmt/ntp/ntpclient.h
+++ b/net/mmt/ntp/ntpclient.h
@@ -5,9 +5,11 @@
 extern "C" {
 #endif
 
+//#define JAN_1970_SEC        0x83aa7e80      /* 2208988800 1970 - 1900 in seconds */
+#define JAN_1970_SEC        2208988800
 struct ntp_time_t {
-    int day;
-    float sec;
+	unsigned int coarse;
+	unsigned int fine;
 };
 int ntp_get_time(const char* host, struct ntp_time_t* ntp_time);
 
-- 
1.7.9.5


From bea4edd2c03f654777965cf78412a9d7f9b111b8 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 20:14:45 -0800
Subject: [PATCH 077/128] [todo] update libmpu to support mp4 image

---
 net/mmt/mpu/mp4.c          |  226 +++++++++++++++++++++++++++++++++++++++++---
 net/mmt/mpu/mp4.h          |   62 ++++++++++++
 net/mmt/mpu/stream.h       |    4 +-
 net/mmt/mpu/test_parser.cc |   19 ++--
 4 files changed, 290 insertions(+), 21 deletions(-)

diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index adf2898..ca562d1 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -460,6 +460,202 @@ static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
    MP4_READBOX_EXIT( 1 );
 }
 
+//Read infe box
+static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
+{
+	int i;
+	uint8_t *name,*type,*encoding;
+	uint64_t item_name_end_pos = -1;
+	uint64_t content_type_end_pos = -1;
+    MP4_READBOX_ENTER( mp4_box_data_infe_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_infe );
+
+    MP4_GET2BYTES( p_box->data.p_infe->item_ID );
+    MP4_GET2BYTES( p_box->data.p_infe->item_protection_index );
+
+    p_box->data.p_infe->item_name = NULL;
+
+    if( i_read > 0 )
+    {
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				item_name_end_pos = i;
+				break;
+			}
+		}
+        name = p_box->data.p_infe->item_name = malloc( item_name_end_pos + 1 );
+        if( unlikely( name == NULL )|| item_name_end_pos < 0)
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( name, p_peek, item_name_end_pos );
+        p_box->data.p_infe->item_name[item_name_end_pos] = '\0';
+
+		p_peek += item_name_end_pos;
+		i_read -= item_name_end_pos;
+
+		p_box->data.p_infe->content_type = NULL;
+		for(i = 1; i <= i_read; i++)
+		{
+			if(0 == *(p_peek + i))
+			{
+				content_type_end_pos = i;
+				break;
+			}
+		}
+		type = p_box->data.p_infe->content_type = malloc( content_type_end_pos + 1 );
+        if( unlikely( type == NULL || item_name_end_pos < 0))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( type, p_peek, content_type_end_pos );
+        p_box->data.p_infe->content_type[content_type_end_pos] = '\0';
+
+		p_peek += content_type_end_pos;
+		i_read -= content_type_end_pos;
+
+		p_box->data.p_infe->content_encoding = NULL;
+		encoding = p_box->data.p_infe->content_encoding = malloc( i_read + 1 );
+        if( unlikely( encoding == NULL ))
+            MP4_READBOX_EXIT( 0 );
+
+        /* Yes, I love .mp4 :( */
+        memcpy( encoding, p_peek, i_read );
+        p_box->data.p_infe->content_encoding[i_read] = '\0';
+    }
+
+#ifdef MP4_VERBOSE
+         printf( "read box: \"infe\" item_name: \"%s\" content_type: \"%s\"",
+                   (char*)&p_box->data.p_infe->item_name,
+                   p_box->data.p_infe->content_type );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iinf box
+static int MP4_ReadBox_iinf( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_iinf_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_iinf );
+
+    MP4_GET2BYTES( p_box->data.p_iinf->entry_count );
+
+    stream_seek( p_stream, p_box->i_pos + mp4_box_headersize( p_box ) + 6, SEEK_SET );
+    MP4_ReadBoxContainerRaw( p_stream, p_box );
+
+#ifdef MP4_VERBOSE
+     printf( "read box: \"iinf\" entry-count %d",
+                      p_box->data.p_iinf->entry_count );
+#endif
+
+    MP4_READBOX_EXIT( 1 );
+}
+//Read iloc box
+static int MP4_ReadBox_iloc( stream_t *p_stream, mp4_box_t *p_box )
+{
+   unsigned int i = 0;
+   unsigned char offset_size_and_length_size = 0;
+   unsigned char base_offset_size_and_index_size_or_reserved = 0;
+   MP4_READBOX_ENTER( mp4_box_data_iloc_t );
+   MP4_GETVERSIONFLAGS(p_box->data.p_iloc);
+   MP4_GET1BYTE(offset_size_and_length_size);
+   p_box->data.p_iloc->offset_size=(offset_size_and_length_size>>4)&0x0f;
+   p_box->data.p_iloc->length_size=offset_size_and_length_size&0x0f;
+   MP4_GET1BYTE(base_offset_size_and_index_size_or_reserved);
+   p_box->data.p_iloc->base_offset_size=(base_offset_size_and_index_size_or_reserved>>4)&0x0f;
+   p_box->data.p_iloc->index_size_or_reserved=base_offset_size_and_index_size_or_reserved&0x0f;
+   MP4_GET2BYTES( p_box->data.p_iloc->item_count );
+   p_box->data.p_iloc->item_ID =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->data_reference_index =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->base_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_count =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint16_t) );
+   p_box->data.p_iloc->extent_offset =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   p_box->data.p_iloc->extent_length =
+      calloc( p_box->data.p_iloc->item_count, sizeof(uint32_t) );
+   if( unlikely( p_box->data.p_iloc->item_ID == NULL
+      || p_box->data.p_iloc->data_reference_index == NULL
+      || p_box->data.p_iloc->base_offset == NULL 
+	  || p_box->data.p_iloc->extent_count == NULL
+	  || p_box->data.p_iloc->extent_offset == NULL
+	  || p_box->data.p_iloc->extent_length == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+   for( i = 0; (i < p_box->data.p_iloc->item_count )&&( i_read >= 18 );i++ )
+   {
+      MP4_GET2BYTES( p_box->data.p_iloc->item_ID[i] );
+      MP4_GET2BYTES( p_box->data.p_iloc->data_reference_index[i] );
+      MP4_GET4BYTES( p_box->data.p_iloc->base_offset[i] );
+	  MP4_GET2BYTES( p_box->data.p_iloc->extent_count[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+	  MP4_GET4BYTES( p_box->data.p_iloc->extent_offset[i] );
+   }
+
+#ifdef MP4_VERBOSE
+    printf( "read box: \"iloc\" item-count %d",
+      p_box->data.p_iloc->item_count );
+
+#endif
+   MP4_READBOX_EXIT( 1 );
+}
+//Read pitm box
+static int MP4_ReadBox_pitm( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_pitm_t );
+
+    MP4_GETVERSIONFLAGS( p_box->data.p_pitm );
+
+    MP4_GET2BYTES( p_box->data.p_pitm->item_ID );
+
+
+    MP4_READBOX_EXIT( 1 );
+}
+static int MP4_ReadBox_idat( stream_t *p_stream, mp4_box_t *p_box )
+{
+    MP4_READBOX_ENTER( mp4_box_data_idat_t );
+
+    p_box->data.p_idat->data =
+      calloc( i_read, sizeof( uint8_t ) );
+	memcpy(  p_box->data.p_idat->data, p_peek, i_read);
+
+	if( unlikely( p_box->data.p_idat->data == NULL) )
+   {
+      MP4_READBOX_EXIT( 0 );
+   }
+
+    MP4_READBOX_EXIT( 1 );
+}
+static void MP4_FreeBox_iloc( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_iloc->item_ID );
+   FREENULL( p_box->data.p_iloc->data_reference_index );
+   FREENULL( p_box->data.p_iloc->base_offset );
+   FREENULL( p_box->data.p_iloc->extent_count );
+   FREENULL( p_box->data.p_iloc->extent_offset );
+   FREENULL( p_box->data.p_iloc->extent_length );
+}
+
+static void MP4_FreeBox_infe( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_infe->item_name );
+   FREENULL( p_box->data.p_infe->content_type );
+   FREENULL( p_box->data.p_infe->content_encoding );
+}
+
+static void MP4_FreeBox_idat( mp4_box_t *p_box )
+{
+   FREENULL( p_box->data.p_idat->data );
+}
 static int MP4_ReadBox_tfdt( stream_t *p_stream, mp4_box_t *p_box )
 {
    MP4_READBOX_ENTER( mp4_box_data_tfdt_t );
@@ -3445,6 +3641,11 @@ static const struct
    { ATOM_tfra,    MP4_ReadBox_tfra,         MP4_FreeBox_tfra },
    { ATOM_mfro,    MP4_ReadBox_mfro,         MP4_FreeBox_Common },
 
+   { ATOM_pitm,    MP4_ReadBox_pitm,         MP4_FreeBox_Common},
+   { ATOM_iloc,    MP4_ReadBox_iloc,         MP4_FreeBox_iloc},
+   { ATOM_iinf,    MP4_ReadBox_iinf,         MP4_FreeBox_Common},
+   { ATOM_infe,    MP4_ReadBox_infe,         MP4_FreeBox_infe},
+   { ATOM_idat,    MP4_ReadBox_idat,         MP4_FreeBox_idat},
    /* Last entry */
    { 0,              MP4_ReadBox_default,      NULL }
 };
@@ -3525,7 +3726,8 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 			||cur->i_type==ATOM_udta||cur->i_type==ATOM_nmhd||cur->i_type==ATOM_hnti||cur->i_type==ATOM_rmra \
 			||cur->i_type==ATOM_rmda||cur->i_type==ATOM_tref||cur->i_type==ATOM_gmhd||cur->i_type==ATOM_wave \
 			||cur->i_type==ATOM_ilst||cur->i_type==ATOM_mvex||cur->i_type==ATOM_stsd||cur->i_type==ATOM_tref \
-			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root)
+			||cur->i_type==ATOM_traf||cur->i_type==ATOM_mfra||cur->i_type==ATOM_dref||cur->i_type==ATOM_root\
+			||cur->i_type==ATOM_meta||cur->i_type==ATOM_iinf)
         {
 			//printf("current box is %c%c%c%c\n",cur->i_type&0x000000ff,(cur->i_type&0x0000ff00)>>8,(cur->i_type&0x00ff0000)>>16,(cur->i_type&0xff000000)>>24);
 			if(cur->i_type==i_type)
@@ -3549,17 +3751,17 @@ mp4_box_t * MP4_BoxSearchBox(mp4_box_t *p_head, uint32_t i_type)
 				else if(cur->p_father->p_next)
 					cur = cur->p_father->p_next;
                 else if (cur->p_father->p_father) {
-				    if(cur->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_next;
-				    else if(cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next)
-					    cur = cur->p_father->p_father->p_father->p_father->p_father->p_father->p_next;
-				    else {
+	                mp4_box_t* parent = cur->p_father->p_father;
+                    cur = NULL;
+                    do {
+                        if (parent->p_next) {
+                            cur = parent->p_next;
+                            break;
+                        }
+                        parent = parent->p_father;
+                    }while(parent);
+
+				    if(!cur) {
 					    printf("Format not supported!\n");
 					    return NULL;
 				    }
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 8cff958..0aa7a96 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -233,6 +233,11 @@
 
 #define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
 
+#define ATOM_pitm MP4_FOURCC( 'p', 'i', 't', 'm' )
+#define ATOM_iloc MP4_FOURCC( 'i', 'l', 'o', 'c' )
+#define ATOM_iinf MP4_FOURCC( 'i', 'i', 'n', 'f' )
+#define ATOM_infe MP4_FOURCC( 'i', 'n', 'f', 'e' )
+#define ATOM_idat MP4_FOURCC( 'i', 'd', 'a', 't' )
 
 
 typedef struct uuid_s
@@ -263,6 +268,58 @@ typedef struct mp4_box_data_mmpu_s
    char *asset_id_value;
 
 } mp4_box_data_mmpu_t;
+typedef struct mp4_box_data_infe_s
+{
+	uint8_t  version;
+	uint32_t flags;
+	uint16_t item_ID;
+	uint16_t item_protection_index;
+    char     *item_name;
+    char     *content_type;
+	char     *content_encoding;
+
+} mp4_box_data_infe_t;
+
+typedef struct mp4_box_data_iinf_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t entry_count;
+/* XXX it's also a container with entry_count entry */
+} mp4_box_data_iinf_t;
+
+typedef struct mp4_box_data_iloc_s
+{
+    uint8_t  version;
+    uint32_t flags;
+	uint8_t  offset_size;
+	uint8_t  length_size;
+	uint8_t  base_offset_size;
+	uint8_t  index_size_or_reserved;
+    uint16_t item_count;
+
+    uint16_t *item_ID; /* theses are arrays */
+	uint16_t *data_reference_index;
+    uint32_t *base_offset;
+	uint16_t *extent_count;
+    uint32_t *extent_offset;
+	uint32_t *extent_length;
+
+} mp4_box_data_iloc_t;
+
+typedef struct mp4_box_data_pitm_s
+{
+    uint8_t  version;
+    uint32_t flags;
+    uint16_t item_ID;
+
+} mp4_box_data_pitm_t;
+
+typedef struct mp4_box_data_idat_s
+{
+    uint8_t  *data;
+
+} mp4_box_data_idat_t;
 
 typedef struct mp4_box_data_tfdt_s
 {
@@ -1182,6 +1239,11 @@ typedef union mp4_box_data_s
    mp4_box_data_chpl_t *p_chpl;
    mp4_box_data_tref_generic_t *p_tref_generic;
    mp4_box_data_name_t *p_name;
+   mp4_box_data_infe_t *p_infe;
+   mp4_box_data_iinf_t *p_iinf;
+   mp4_box_data_iloc_t *p_iloc;
+   mp4_box_data_pitm_t *p_pitm;
+   mp4_box_data_idat_t *p_idat;
    void *p_data;
 } mp4_box_data_t;
 
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index e528a9e..9815bb1 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -8,8 +8,8 @@ typedef unsigned char uint8_t;
 typedef short int16_t;
 typedef unsigned short uint16_t;
 typedef int int32_t;
-typedef unsigned uint32_t;
-typedef long int int64_t;
+typedef unsigned int uint32_t;
+//typedef long long int64_t;
 typedef unsigned long long uint64_t;
 //typedef unsigned long size_t;
 #endif
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 4263520..163ef33 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -9,13 +9,13 @@ mp4_box_t* print_traf(mp4_box_t* box) {
     do {
         box = MP4_BoxSearchBox(box, ATOM_traf);
         if (!box) break;
-        printf("traf: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("traf: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
 
         box = MP4_BoxSearchBox(box, ATOM_tfhd);
         if (!box) break;
         else {
-            printf("tfhd: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
-            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%u size=%u\n", 
+            printf("tfhd: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%llu size=%u\n", 
                 box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
                 box->data.p_tfhd->base_data_offset, box->data.p_tfhd->default_sample_size);
         }
@@ -23,7 +23,7 @@ mp4_box_t* print_traf(mp4_box_t* box) {
         box = MP4_BoxSearchBox(box, ATOM_trun);
         if (!box) break;
         else {
-            printf("trun: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+            printf("trun: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
             printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
                 box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
                 box->data.p_trun->data_offset);
@@ -55,22 +55,27 @@ int main(int argc, char* argv[])
     mp4_box_t* box = NULL;
     box = MP4_BoxSearchBox(root, ATOM_ftyp);
     if (box) {
-        printf("ftyp: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("ftyp: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
     }else {
         box = root;
     }
 
+    mp4_box_t* idat = MP4_BoxSearchBox(box, ATOM_idat); 
+    if (idat) {
+        printf("idat: %p pos: %ld size: %llu\n", idat, idat->i_pos, idat->i_size);
+    }
+
     do {
         box = MP4_BoxSearchBox(box, ATOM_moof);
         if (!box) break;
-        printf("moof: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("moof: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
 
         box = print_traf(box);
         box = print_traf(box);
 
         box = MP4_BoxSearchBox(box, ATOM_mdat);
         if (!box) break;
-        printf("mdat: %p pos: %d size: %d\n", box, box->i_pos, box->i_size);
+        printf("mdat: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
     }while(1);
 
     MP4_BoxFree(s, root);
-- 
1.7.9.5


From 40b6b70362c8392a4e5cb54edae63987feb38fd0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 21:35:52 -0800
Subject: [PATCH 078/128] [ok] support mp4 image <type=image>

---
 net/mmt/mmt_stream.cc |   22 +++++++++++++++++-----
 net/mmt/mmt_stream.h  |    1 +
 net/mmt/mpu/mp4.c     |    8 ++++----
 3 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 75e90e5..98b9dc1 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -92,6 +92,7 @@ bool Stream::ParseSequence(int& index) {
         std::string range = GetQueryValue(query, "sequence_num");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
         if (mtype.empty()) return false;
+        mtype_ = mtype;
 
         if (mtype == kMmtMediaImage) {
             index = -2;
@@ -168,17 +169,28 @@ void* Stream::Open(const char* filename, int mode) {
         stream_t* s = InitMpuStream(this);
         mp4_box_t* root = MP4_BoxGetRoot(s);
         mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
-        mp4_box_t* box = MP4_BoxSearchBox(box0, ATOM_moof);
-        LOG(INFO) << __func__ << " mp4 root=" << root << " ftyp-box=" << box0 << " moof-box=" << box;
 
-        // get the pos of the 1st moof-box
         long offset = -1;
-        if (box) offset = box->i_pos;
+        mp4_box_t* box = nullptr;
+        if (mtype_ == kMmtMediaImage) {
+            box = MP4_BoxSearchBox(box0, ATOM_idat);
+            offset = 8;
+        }else {
+            box = MP4_BoxSearchBox(box0, ATOM_moof);
+            offset = 0;
+        }
+        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+
+        // get the pos of the 1st moof-box
+        long ipos = -1;
+        if (box) ipos = box->i_pos;
         MP4_BoxFree(s, root);
         free(s);
         
         // seek to the 1st moof-box
-        if (offset == -1) return nullptr;
+        if (ipos == -1) return nullptr;
+        offset += ipos;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 65916b2..d6fac18 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -109,6 +109,7 @@ protected:
 
 private:
     GURL url_;
+    std::string mtype_;
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
diff --git a/net/mmt/mpu/mp4.c b/net/mmt/mpu/mp4.c
index ca562d1..282d2c7 100644
--- a/net/mmt/mpu/mp4.c
+++ b/net/mmt/mpu/mp4.c
@@ -464,9 +464,9 @@ static int MP4_ReadBox_mmpu( stream_t *p_stream, mp4_box_t *p_box )
 static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
 {
 	int i;
-	uint8_t *name,*type,*encoding;
-	uint64_t item_name_end_pos = -1;
-	uint64_t content_type_end_pos = -1;
+	char *name,*type,*encoding;
+	int64_t item_name_end_pos = -1;
+	int64_t content_type_end_pos = -1;
     MP4_READBOX_ENTER( mp4_box_data_infe_t );
 
     MP4_GETVERSIONFLAGS( p_box->data.p_infe );
@@ -486,7 +486,7 @@ static int MP4_ReadBox_infe( stream_t *p_stream, mp4_box_t *p_box )
 				break;
 			}
 		}
-        name = p_box->data.p_infe->item_name = malloc( item_name_end_pos + 1 );
+        name = p_box->data.p_infe->item_name = (char *)malloc( item_name_end_pos + 1 );
         if( unlikely( name == NULL )|| item_name_end_pos < 0)
             MP4_READBOX_EXIT( 0 );
 
-- 
1.7.9.5


From 98b445a83076fb64e0b6954121066a99e3ccb915 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 7 Feb 2015 22:37:54 -0800
Subject: [PATCH 079/128] [todo] add 1st version of mmtp to chrome

---
 net/mmt/mmtp/DList.c   |  276 +++++++++++
 net/mmt/mmtp/DList.h   |   84 ++++
 net/mmt/mmtp/Mlist.c   |  280 +++++++++++
 net/mmt/mmtp/Mlist.h   |   85 ++++
 net/mmt/mmtp/client.c  |  972 ++++++++++++++++++++++++++++++++++++
 net/mmt/mmtp/getfile.c |  274 ++++++++++
 net/mmt/mmtp/getfile.h |   22 +
 net/mmt/mmtp/ini.c     |  692 ++++++++++++++++++++++++++
 net/mmt/mmtp/ini.h     |  153 ++++++
 net/mmt/mmtp/mmt.c     | 1293 ++++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mmtp/mmt.h     |  464 +++++++++++++++++
 net/mmt/mmtp/mmtp.gyp  |   93 ++++
 net/mmt/mmtp/mmtp.h    |   64 +++
 net/mmt/mmtp/ringq.c   |  112 +++++
 net/mmt/mmtp/ringq.h   |   65 +++
 net/mmt/mmtp/send.c    |  199 ++++++++
 net/mmt/mmtp/send.h    |   32 ++
 net/mmt/mpu/mp4.h      |    1 +
 net/net.gyp            |    1 +
 19 files changed, 5162 insertions(+)
 create mode 100644 net/mmt/mmtp/DList.c
 create mode 100644 net/mmt/mmtp/DList.h
 create mode 100644 net/mmt/mmtp/Mlist.c
 create mode 100644 net/mmt/mmtp/Mlist.h
 create mode 100644 net/mmt/mmtp/client.c
 create mode 100644 net/mmt/mmtp/getfile.c
 create mode 100644 net/mmt/mmtp/getfile.h
 create mode 100644 net/mmt/mmtp/ini.c
 create mode 100644 net/mmt/mmtp/ini.h
 create mode 100644 net/mmt/mmtp/mmt.c
 create mode 100644 net/mmt/mmtp/mmt.h
 create mode 100644 net/mmt/mmtp/mmtp.gyp
 create mode 100644 net/mmt/mmtp/mmtp.h
 create mode 100644 net/mmt/mmtp/ringq.c
 create mode 100644 net/mmt/mmtp/ringq.h
 create mode 100644 net/mmt/mmtp/send.c
 create mode 100644 net/mmt/mmtp/send.h

diff --git a/net/mmt/mmtp/DList.c b/net/mmt/mmtp/DList.c
new file mode 100644
index 0000000..34fd494
--- /dev/null
+++ b/net/mmt/mmtp/DList.c
@@ -0,0 +1,276 @@
+#include"DList.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+Position MakeNode(const char* i)
+{
+	PNode p = NULL;
+	p = (PNode)malloc(sizeof(Node));
+	p->data=(unsigned char *)malloc(1500*sizeof(unsigned char));
+	memset((void*)p->data,0,1500);
+	if(p!=NULL)
+	{
+		//p->data = i;
+		memcpy((void*)p->data , &i[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void FreeNode(PNode p)
+{
+	 free(p);
+}
+/**/
+DList * InitList()
+{
+	DList *plist = (DList *)malloc(sizeof(DList));
+	PNode head = MakeNode("");
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void DestroyList(DList *plist)
+{
+	ClearList(plist);
+	free(GetHead(plist));
+	free(plist);
+}
+
+/**/
+int IsEmpty(DList *plist)
+{
+	if(GetSize(plist)==0&&GetTail(plist)==GetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void ClearList(DList *plist)
+{
+	PNode temp,p;
+	p = GetTail(plist);
+	while(!IsEmpty(plist))
+	{
+		temp = GetPrevious(p);
+		free(p->data);
+		FreeNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+Position GetHead(DList *plist)
+{
+	return plist->head;
+}
+
+/**/
+Position GetTail(DList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int GetSize(DList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+Position GetNext(Position p)
+{
+	return p->next;
+}
+
+/*p*/
+Position GetPrevious(Position p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode)
+{
+	Position head = GetHead(plist);
+
+	if(IsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+PNode DelFirst(DList *plist)
+{
+	Position head = GetHead(plist);
+
+	Position p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->data);
+
+	}
+	return p;
+}
+/*,,*/
+PNode DelFirst2(DList *plist)
+{
+	Position head = GetHead(plist);
+	Position p=head->next;
+	if(p!=NULL)
+	{
+		if(p==GetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* GetItem(Position p)
+{
+	return p->data;
+}
+
+/**/
+void SetItem(Position p,unsigned char* i)
+{
+	p->data = i;
+}
+
+/**/
+PNode Remove(DList *plist)
+{
+	Position p=NULL;
+	if(IsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = GetTail(plist);
+		free(p->data);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int RemovePnext(DList *plist,Position p)
+{
+	Position q=p->next;
+	if(IsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->data);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+PNode InsBefore(DList *plist,Position p,PNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == GetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+PNode LocatePos(DList *plist,int i)
+{
+	int cnt = 0;
+	Position p = GetHead(plist);
+	if(i>GetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)())
+{
+	Position p = GetHead(plist);
+	if(IsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->data);
+		}
+	}
+}
diff --git a/net/mmt/mmtp/DList.h b/net/mmt/mmtp/DList.h
new file mode 100644
index 0000000..1918862
--- /dev/null
+++ b/net/mmt/mmtp/DList.h
@@ -0,0 +1,84 @@
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+#ifndef NET_MMT_MMTP_DLIST_H_
+#define NET_MMT_MMTP_DLIST_H_
+
+#include <string.h>
+
+typedef struct Node * PNode;
+typedef PNode Position;
+/**/
+typedef struct Node
+{
+	unsigned char * data;		/**/
+	PNode previous; /**/
+	PNode next;		/**/
+}Node;
+/**/
+typedef struct
+{
+	PNode head;		/**/
+	PNode tail;		/**/
+	int size;
+}DList;
+
+/*i*/
+Position MakeNode(const char * i);
+
+/*p*/
+void FreeNode(PNode p);
+
+/**/
+DList* InitList();
+
+/**/
+void DestroyList(DList *plist);
+
+/**/
+void ClearList(DList *plist);
+
+/**/
+Position GetHead(DList *plist);
+
+/**/
+Position GetTail(DList *plist);
+
+/**/
+int GetSize(DList *plist);
+
+/*p*/
+Position GetNext(Position p);
+
+/*p*/
+Position GetPrevious(Position p);
+
+/*pnode*/
+PNode InsFirst(DList *plist,PNode pnode);
+
+/**/
+PNode DelFirst(DList *plist);
+
+/**/
+unsigned char * GetItem(Position p);
+
+/**/
+void SetItem(Position p,unsigned char * i);
+
+/**/
+PNode Remove(DList *plist);
+
+/*P*/
+int RemovePnext(DList *plist,Position p);
+
+/*pS*/
+PNode InsBefore(DList *plist,Position p,PNode s);
+
+/*ps*/
+PNode InsAfter(DList *plist,Position p,PNode s);
+
+/*i*/
+PNode LocatePos(DList *plist,int i);
+
+/*visit()*/
+void ListTraverse(DList *plist,void (*visit)());
+
+#endif
diff --git a/net/mmt/mmtp/Mlist.c b/net/mmt/mmtp/Mlist.c
new file mode 100644
index 0000000..c8f0085
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.c
@@ -0,0 +1,280 @@
+#include "Mlist.h"
+#include<malloc.h>
+#include<stdlib.h>
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf)
+{
+	mPNode p = NULL;
+	p = (mPNode)malloc(sizeof(mNode));
+	p->mpu_buf=(mpu_buf_t*)malloc(1500*sizeof(unsigned char));
+	memset((void*)p->mpu_buf,0,1500);
+	if(p!=NULL)
+	{
+		//p->mpu_buf = i;
+		memcpy((void*)p->mpu_buf , &mpu_buf[0] , 1500);
+		p->previous = NULL;
+		p->next = NULL;
+	}
+	return p;
+}
+/*p*/
+void mFreemNode(mPNode p)
+{
+	 free(p);
+}
+/**/
+MPUList * mInitList()
+{
+    mpu_buf_t tmpu;
+	MPUList *plist = (MPUList *)malloc(sizeof(MPUList));
+    memset(&tmpu, 0, sizeof(tmpu));
+	mPNode head = mMakeNode(&tmpu);
+	if(plist!=NULL)
+	{
+		if(head!=NULL)
+		{
+			plist->head = head;
+			plist->tail = head;
+			plist->size = 0;
+		}
+		else
+			return NULL;
+	}
+	return plist;
+}
+
+/**/
+void mDestroyList(MPUList *plist)
+{
+	mClearList(plist);
+	free(mGetHead(plist));
+	free(plist);
+}
+
+/**/
+int mIsEmpty(MPUList *plist)
+{
+	if(mGetSize(plist)==0&&mGetTail(plist)==mGetHead(plist))
+		return 1;
+	else
+		return 0;
+}
+/**/
+void mClearList(MPUList *plist)
+{
+	mPNode temp,p;
+	p = mGetTail(plist);
+	while(!mIsEmpty(plist))
+	{
+		temp = mGetPrevious(p);
+		free(p->mpu_buf);
+		mFreemNode(p);
+		p = temp;
+		plist->tail = temp;
+		plist->size--;
+		printf("size %d\n",plist->size);
+	}
+}
+
+/**/
+mPosition mGetHead(MPUList *plist)
+{
+	return plist->head;
+}
+
+/**/
+mPosition mGetTail(MPUList *plist)
+{
+	return plist->tail;
+}
+
+/**/
+int mGetSize(MPUList *plist)
+{
+	return plist->size;
+}
+
+/*p*/
+mPosition mGetNext(mPosition p)
+{
+	return p->next;
+}
+
+/*p*/
+mPosition mGetPrevious(mPosition p)
+{
+	return p->previous;
+}
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode pnode)
+{
+	mPosition head = mGetHead(plist);
+
+	if(mIsEmpty(plist))
+		plist->tail = pnode;
+	plist->size++;
+
+	pnode->next = head->next;
+	pnode->previous = head;
+
+	if(head->next!=NULL)
+		head->next->previous = pnode;
+	head->next = pnode;
+
+	return pnode;
+}
+
+/*,,*/
+mPNode mDelFirst(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+
+	mPosition p=head->next;
+
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+		{
+			plist->tail = p->previous;
+			head->next = NULL;
+		}
+		else
+		{
+			head->next = p->next;
+			head->next->previous = head;
+		}
+		plist->size--;
+		free(p->mpu_buf);
+
+	}
+	return p;
+}
+/*,,*/
+mPNode mDelFirst2(MPUList *plist)
+{
+	mPosition head = mGetHead(plist);
+	mPosition p=head->next;
+	if(p!=NULL)
+	{
+		if(p==mGetTail(plist))
+			plist->tail = p->previous;
+		head->next = p->next;
+		head->next->previous = head;
+		plist->size--;
+
+	}
+	return p;
+}
+
+/**/
+unsigned char* mGetItem(mPosition p)
+{
+	return (unsigned char*)p->mpu_buf;
+}
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf)
+{
+	p->mpu_buf = mpu_buf;
+}
+
+/**/
+mPNode mRemove(MPUList *plist)
+{
+	mPosition p=NULL;
+	if(mIsEmpty(plist))
+		return NULL;
+	else
+	{
+		p = mGetTail(plist);
+		free(p->mpu_buf);
+
+		plist->tail = p->previous;
+
+		p->previous->next = NULL;
+		printf("hehe\n");
+		plist->size--;
+
+		return p;
+	}
+}
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p)
+{
+	mPosition q=p->next;
+	if(mIsEmpty(plist))
+		return -1;
+	else
+	{
+		p->next=q->next;  // 2-10
+		q->next->previous=p;  // 2-10 
+		free (q->mpu_buf);
+		free (q) ; //
+		plist->size--;
+		return 0;
+	}
+}
+
+/*ps*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode s)
+{
+	s->previous = p->previous;
+	s->next = p;
+	p->previous->next = s;
+	p->previous = s;
+
+	plist->size++;
+	return s;
+}
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode s)
+{
+	s->next = p->next;
+	s->previous = p;
+
+	if(p->next != NULL)
+		p->next->previous = s;
+	p->next = s;
+
+	if(p == mGetTail(plist))
+		plist->tail = s;
+
+	plist->size++;
+	return s;
+}
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i)
+{
+	int cnt = 0;
+	mPosition p = mGetHead(plist);
+	if(i>mGetSize(plist)||i<1)
+		return NULL;
+
+	while(++cnt<=i)
+	{
+		p=p->next;
+	}
+
+	return p;
+}
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)())
+{
+	mPosition p = mGetHead(plist);
+	if(mIsEmpty(plist))
+		exit(0);
+	else
+	{
+
+		while(p->next!=NULL)
+		{
+			p = p->next;
+			visit(p->mpu_buf);
+		}
+	}
+}
+
+
diff --git a/net/mmt/mmtp/Mlist.h b/net/mmt/mmtp/Mlist.h
new file mode 100644
index 0000000..89d5028
--- /dev/null
+++ b/net/mmt/mmtp/Mlist.h
@@ -0,0 +1,85 @@
+#ifndef NET_MMT_MMTP_MLIST_H_
+#define NET_MMT_MMTP_MLIST_H_
+
+#include "mmt.h"
+//http://blog.csdn.net/hopeyouknow/article/details/6716177
+
+typedef struct mNode * mPNode;
+typedef mPNode mPosition;
+/**/
+typedef struct mNode
+{
+	mpu_buf_t *mpu_buf;		/**/
+	mPNode previous; /**/
+	mPNode next;		/**/
+}mNode;
+/**/
+typedef struct
+{
+	mPNode head;		/**/
+	mPNode tail;		/**/
+	int size;
+}MPUList;
+
+/*i*/
+mPosition mMakeNode(mpu_buf_t *mpu_buf);
+
+/*p*/
+void mFreemNode(mPNode mp);
+
+/**/
+MPUList* mInitList();
+
+/**/
+void mDestroyList(MPUList *plist);
+
+/**/
+void mClearList(MPUList *plist);
+
+/**/
+mPosition mGetHead(MPUList *plist);
+
+/**/
+mPosition mGetTail(MPUList *plist);
+
+/**/
+int mGetSize(MPUList *plist);
+
+/*p*/
+mPosition mGetNext(mPosition p);
+
+/*p*/
+mPosition mGetPrevious(mPosition p);
+
+/*pnode*/
+mPNode mInsFirst(MPUList *plist,mPNode mpnode);
+
+/**/
+mPNode mDelFirst(MPUList *plist);
+
+/**/
+unsigned char * mGetItem(mPosition p);
+
+/**/
+void mSetItem(mPosition p,mpu_buf_t *mpu_buf);
+
+/**/
+mPNode mRemove(MPUList *plist);
+
+/*P*/
+int mRemovePnext(MPUList *plist,mPosition p);
+
+/*pS*/
+mPNode mInsBefore(MPUList *plist,mPosition p,mPNode ms);
+
+/*ps*/
+mPNode mInsAfter(MPUList *plist,mPosition p,mPNode ms);
+
+/*i*/
+mPNode mLocatePos(MPUList *plist,int i);
+
+/*visit()*/
+void mListTraverse(MPUList *plist,void(*visit)());
+
+#endif
+
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
new file mode 100644
index 0000000..895014e
--- /dev/null
+++ b/net/mmt/mmtp/client.c
@@ -0,0 +1,972 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#include<signal.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <sched.h>
+#define BACKLOG 2
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "send.h"
+#include "ringq.h"
+#include "DList.h"
+
+
+#define MCAST_PORT 6080
+#define MCAST_ADDR "224.1.1.101"
+
+
+
+#define BACKLOG 2
+
+extern void sig_proccess(int signo);
+extern void sig_pipe(int signo);
+
+void *producter_f (void *arg);					/**/
+void *mpu_consumer_f (void *arg);					/**/
+void *signal_consumer_f (void *arg);					/**/
+int signal_buffer_has_item=0;							/**/
+int mpu_buffer_has_item=0;							/**/
+pthread_mutex_t mpu_mutex;							/**/
+pthread_mutex_t signal_mutex;							/**/
+int running =1 ;								/**/
+
+static int s;
+
+void sig_proccess(int signo)
+{
+	printf("catch a exit signal\n");
+	close(s);
+	exit(0);
+}
+
+void  sig_pipe(int signo)
+{
+	printf("catch a SIGPIPE signal\n");
+	close(s);
+	exit(0);
+}
+
+
+#define BUFF_LEN 1500
+
+DList *signal_buff_list = NULL;
+DList *mpu_buff_list = NULL;
+
+#if 0
+int main(int argc, char *argv[])
+{
+
+	//init a double listmpu_buff_listst = InitList();
+	signal_buff_list=InitList();
+	mpu_buff_list=InitList();
+
+	pthread_t signal_consumer_t;						/**/
+	pthread_t mpu_consumer_t;						/**/
+	pthread_t producter_t;						/**/
+
+	pthread_mutex_init (&signal_mutex,NULL);			/**/
+	pthread_mutex_init (&mpu_mutex,NULL);			/**/
+
+	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
+	usleep(10);
+	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
+	usleep(10);
+	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
+	usleep(10);
+	//pthread_join(producter_t,&buffer_has_item);			/**/
+	while(1)
+		sleep(1);
+	pthread_mutex_destroy(&signal_mutex);				/**/
+	//udpserv_echo(ss,(struct sockaddr*)&local_addr);
+
+	/**/
+
+
+    return 0;
+}
+#endif
+
+void *producter_f (void *arg)					/**/
+{
+//
+	int ss;
+
+	struct sockaddr_in local_addr;
+	int err=-1;
+	pid_t pid;
+	//sigint
+	signal(SIGINT,sig_proccess);
+	signal(SIGPIPE,sig_pipe);
+
+	//s
+	ss=socket(AF_INET, SOCK_DGRAM,0);
+	if(ss<0)
+	{
+		printf("socket error\n");
+		return NULL;
+	}
+
+//	//
+//	bzero(&server_addr,sizeof(server_addr));
+//	//memset(&server_addr,0,sizeof(server_addr));
+//	server_addr.sin_family=AF_INET;
+//	//server_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+//	server_addr.sin_addr.s_addr=inet_addr(SERVER_ADDR);
+//	server_addr.sin_port =htons(SERVER_PORT);
+//	bzero(&(server_addr.sin_zero),8);
+
+	//
+	bzero(&local_addr,sizeof(local_addr));
+	//memset(&server_addr,0,sizeof(server_addr));
+	local_addr.sin_family=AF_INET;
+	//server_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+//	local_addr.sin_addr.s_addr=inet_addr(CLIENT_ADDR);
+	local_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+	local_addr.sin_port =htons(MCAST_PORT);
+	bzero(&(local_addr.sin_zero),8);
+
+
+	//
+	err=bind(ss,(struct sockaddr*)&local_addr,sizeof(struct sockaddr_in));
+	//printf("ready for listening");
+	if(err<0)
+	{
+		printf("bind error \n");
+		return  NULL;
+	}
+	printf("ready for listening\n");
+
+	//	//BLOADCASE
+	//    int ret;
+	//    int so_broadcast = 1 ;
+	//    ret = setsockopt(ss, SOL_SOCKET, SO_BROADCAST, &so_broadcast,sizeof(so_broadcast));
+	//	if(ret ==-1)
+	//	{
+	//		printf("setsockopt failed\n");
+	//		return -1;
+	//	}
+
+	/**/
+	int loop = 1 ;
+	err = setsockopt(ss, IPPROTO_IP, IP_MULTICAST_LOOP,&loop, sizeof(loop));
+	if(err ==-1)
+	{
+		printf("setsockopt failed:setsockopt():IP_MULTICAST_LOOP\n");
+		return NULL;
+	}
+
+	/**/
+	struct ip_mreq mreq;
+	mreq.imr_multiaddr.s_addr = inet_addr(MCAST_ADDR); /**/
+	mreq.imr_interface.s_addr = htonl(INADDR_ANY); /**/
+
+	/**/
+	err = setsockopt(ss, IPPROTO_IP, IP_ADD_MEMBERSHIP,&mreq, sizeof(mreq));
+	if (err < 0)
+	{
+		printf("setsockopt():IP_ADD_MEMBERSHIP");
+		return NULL;
+	}
+
+	int n;
+	char buff[BUFF_LEN];
+	socklen_t len;//x
+	PNode p = NULL;
+
+	int lastpacket,last_flag=1;
+
+	while(running)								/**/
+	{
+		len=sizeof(local_addr);
+		n=recvfrom(ss,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
+		if(n <=0)
+		{
+			perror("recv error");
+			return NULL;
+		}
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		read_mmtp_header(&mmt_header,buff);
+//		printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag!=0)
+		{
+			puts ("packet loss");
+//			exit (EXIT_FAILURE);
+		}
+		if(mmt_header.packet_counter!=lastpacket+1 && last_flag==0)
+		{
+			puts ("packet loss");
+			exit (EXIT_FAILURE);
+		}
+		lastpacket=mmt_header.packet_counter;
+		last_flag--;
+		if(mmt_header.type==2)
+		{
+			pthread_mutex_lock (&signal_mutex);			/**/
+			//5000
+			if(GetSize(signal_buff_list)==5000)
+			{
+				//
+				free(DelFirst(signal_buff_list));
+				signal_buffer_has_item--;						/**/
+				printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			}
+			p=GetTail(signal_buff_list);
+			InsAfter(signal_buff_list,p,MakeNode(buff));
+			p = p->next;
+//			printf("mmt_header->packet_counter%d\n",mmt_header.packet_counter);
+//			printf("%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(signal_buff_list));
+			signal_buffer_has_item++;						/**/
+//			printf("signal:%d\n",signal_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&signal_mutex);			/**/
+
+		}
+
+		if(mmt_header.type==0)
+		{
+			pthread_mutex_lock (&mpu_mutex);			/**/
+			//5000
+			if(GetSize(mpu_buff_list)==5000)
+			{
+				//
+				free(DelFirst(mpu_buff_list));
+				mpu_buffer_has_item--;						/**/
+//				printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			}
+			p=GetTail(mpu_buff_list);
+			InsAfter(mpu_buff_list,p,MakeNode(buff));
+			p = p->next;
+			read_mmtp_header(&mmt_header,buff);
+
+			read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//			printf("recieve mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number);
+//			printf("mpu%d\n",mmt_header.packet_counter);
+//			printf("size%d\n",GetSize(mpu_buff_list));
+			mpu_buffer_has_item++;						/**/
+//			printf("mpu:%d\n",mpu_buffer_has_item); 	/**/
+			pthread_mutex_unlock(&mpu_mutex);			/**/
+
+
+		}
+
+//		if(buffer_has_item==100)
+//			pthread_exit((void *)3);
+	}
+
+	err = setsockopt(ss, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
+	close(ss);
+    return NULL;
+}
+
+void *signal_consumer_f(void *arg)						/**/
+{
+	PNode p = NULL;
+	unsigned char *signal_buf;
+	u_int32_t signal_seekpoint=0;
+	pa_message_t pa_message;
+	while(running)								/**/
+	{
+		pthread_mutex_lock(&signal_mutex);				/**/
+		while(GetSize(signal_buff_list)>1)
+		{
+			//signal
+			p=GetHead(signal_buff_list);
+			p=p->next;
+			unsigned char buff[BUFF_LEN];
+			memcpy(buff,p->data,BUFF_LEN);
+			mmt_packet_header_t mmt_header;
+			read_mmtp_header(&mmt_header,(const char*)buff);
+			if(mmt_header.type==2)
+			{
+				signal_header_t signal_header;
+				read_signal_header(&signal_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+				if(signal_header.f_i==0)
+				{
+						;
+				}
+				if(signal_header.f_i==1)
+				{
+					if(signal_header.H==0)
+					{
+						//need realize 32 bit signal head later on
+						read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+						signal_buf= (unsigned  char*) malloc((pa_message.length+PAh_BUFF_LEN)*sizeof( unsigned  char));
+						if(signal_buf==NULL)
+						{
+								puts ("Memory allocation failed.");
+								 exit (EXIT_FAILURE);
+						}
+//						printf("init mem\n");
+//						printf("pa_message.length%d\n",pa_message.length);
+						memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+						signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+					}
+					if(signal_header.H==1)
+					{
+						read_pa_message_header(&pa_message,(const char*)&buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN]);
+						signal_buf= (unsigned  char*) malloc((pa_message.length)*sizeof( unsigned  char));
+						memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length2);
+						signal_seekpoint=signal_seekpoint+signal_header.MSG_length2;
+					}
+				}
+				if(signal_header.f_i==2)
+				{
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+					signal_seekpoint=signal_seekpoint+signal_header.MSG_length1;
+				}
+				if(signal_header.f_i==3)
+				{
+//					printf("signal_header.f_i==3\n");
+//					printf("seekpoint%d\n",signal_seekpoint);
+//					printf("signal_header.MSG_length1%d\n",signal_header.MSG_length1);
+					memcpy(&signal_buf[signal_seekpoint] , &buff[MMTPh_BUFF_LEN+signalh_BUFF_LEN] , signal_header.MSG_length1);
+					signal_seekpoint=0;
+					//if PA message
+					read_pa_message(&pa_message,(const char*)&signal_buf[0]);
+					//PA message
+
+//					printf("finished recive signal\n");
+
+					if(signal_buf != NULL)
+					{
+						free(signal_buf);
+						signal_buf=NULL;
+//						printf("free signal_buf\n");
+					}
+					//
+					free_pa_message(&pa_message);
+				}
+
+			}
+			//
+			free(DelFirst(signal_buff_list));
+			signal_buffer_has_item--;						/**/
+//			printf(":%d\n",signal_buffer_has_item);	/**/
+		}
+
+		pthread_mutex_unlock(&signal_mutex);			/**/
+		usleep(50);
+	}
+    return NULL;
+}
+
+void *mpu_consumer_f(void *arg)						/**/
+{
+	//init a  mpu_buf and a seekpoint
+//	unsigned char *mpu_buf;
+//	u_int32_t mpu_seekpoint=0;
+
+//	//init a  mpu_meta_buf and a seekpoint
+//	unsigned char *mpu_meta_buf;
+//	u_int32_t mpu_meta_seekpoint=0;
+//
+//	//init a  frag_meta_buf and a seekpoint
+//	unsigned char *frag_meta_buf;
+//	u_int32_t frag_meta_seekpoint=0;
+//
+//	//init a  *mfu_buf and a seekpoint
+//	//unsigned char *mfu_buf;
+//	u_int32_t mfu_seekpoint=0;
+//
+//	unsigned char *muli_buf;
+//	u_int32_t muli_seekpoint=0;
+
+
+	//init a ring queue
+	RINGQ rq, * p_queue;
+	int i,data;
+
+	p_queue = &rq;
+	ringq_init(p_queue);
+
+	//init a double list
+	DList *plist = NULL;
+	PNode p = NULL;
+	PNode q = NULL;
+
+	DList *mpu_consumer_list = NULL;
+	mpu_consumer_list=InitList();
+
+//mpu_buf_t,mpu,,,!!!!!!
+	mpu_buf_t *mpu_list;
+// init_mpu_list(&mpu_list);
+
+
+	mpu_buf_t mpu_buf;
+	init_mpu_buf(&mpu_buf);
+	int mpufilter=0;
+	while(running)								/**/
+	{
+		int mpu_consumer_couter=0;
+		mmt_packet_header_t mmt_header;
+		mpu_packet_header_t mpu_header;
+		mfu_time_packet_header_t mfu_time_header;
+		unsigned char buff[BUFF_LEN];
+		pthread_mutex_lock(&mpu_mutex);				/**/
+//		printf("1111mpu:%d\n",mpu_buffer_has_item); 	/**/
+		if(GetSize(mpu_buff_list)>0)
+		{
+			p=GetHead(mpu_buff_list);
+			p=p->next;
+			memcpy(buff,p->data,BUFF_LEN);
+			read_mmtp_header(&mmt_header,(const char*)buff);
+			read_mpu_header(&mpu_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+			read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+			InsFirst(mpu_consumer_list,MakeNode((const char*)buff));
+			free(DelFirst(mpu_buff_list));
+			if(mpu_header.FT==2) {};
+//			printf("consume 	mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d ,mfu_time_header.sample_number: %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number,mfu_time_header.sample_number);
+//			printf("consume		mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number);
+//			p=GetHead(mpu_buff_list);
+//			int counter=0;
+//			while(p->next != NULL)
+//			{
+////				printf("copy GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//				p=p->next;
+//				memcpy(buff,p->data,BUFF_LEN);
+//				read_mmtp_header(&mmt_header,buff);
+//				read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//				if(mmt_header.packet_id==1 )
+//				{
+//					counter++;
+//				}
+//
+//			}
+//			printf("debug packet_id counter:%d\n",counter);
+//			//MPU
+//			p=GetHead(mpu_buff_list);
+//
+//			while(p->next != NULL)
+//			{
+////				printf("copy GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//				p=p->next;
+//				memcpy(buff,p->data,BUFF_LEN);
+//				read_mmtp_header(&mmt_header,buff);
+//				read_mpu_header(&mpu_header,&buff[MMTPh_BUFF_LEN]);
+//
+////				printf("debug packet_id: mmt_header.packet_id%d\n",mmt_header.packet_id);
+//				if(mmt_header.packet_id==1)
+//				{
+//					printf("debug packet_id: mmt_header.packet_counter%d mmt_header.packet_id%d\n",mmt_header.packet_counter,mmt_header.packet_id);
+//
+////					if(GetSize(mpu_consumer_list) == 0)
+////					{
+////						printf("GetSize(mpu_consumer_list) == 0\n");
+////						InsFirst(mpu_consumer_list,MakeNode(buff));
+////					}
+////					else
+////					{
+//
+//						InsAfter(mpu_consumer_list,GetTail(mpu_consumer_list),MakeNode(buff));
+////					}
+////					//
+////					//
+//					if(p->previous==GetHead(mpu_buff_list))
+//					{
+//						printf("1 FIRST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						q = p->next;
+////						printf("2 FIRST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						free(DelFirst(mpu_buff_list));
+//
+//						if(q != NULL)
+//						{
+//							p = q->previous;
+//						}
+//
+//					}
+//					else
+//					{
+//						if(p==GetTail(mpu_buff_list))//
+//						{
+//
+//							Remove(mpu_buff_list);
+//							p = GetTail(mpu_buff_list);
+//							printf("LAST GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						}
+//						else//
+//						{
+//							q = p->next;
+//							RemovePnext(mpu_buff_list,p->previous);
+//							p = q->previous;
+//							if(p->next == NULL )
+//							{
+//								printf("p == NULL\n");
+//							}
+////							printf("MID GetSize(mpu_buff_list):%d\n",GetSize(mpu_buff_list)); 	/**/
+//						}
+//					}
+//					mpu_buffer_has_item--;						/**/
+//					mpu_consumer_couter++;
+////					p = GetTail(mpu_consumer_list);
+////					read_mmtp_header(&mmt_header,p->data);
+////					printf("mmt_header.packet_counter%d\n",mmt_header.packet_counter);
+//					if(p->next == NULL )
+//							{
+//								printf("p == NULL\n");
+//							}
+////					printf("mpu:%d\n",mpu_buffer_has_item);	/**/
+//
+//				}
+//			}
+//			printf(":%dmpu\n",mpu_consumer_couter);	/**/
+
+		}
+		pthread_mutex_unlock(&mpu_mutex);			/**/
+
+
+		while(GetSize(mpu_consumer_list)>0)
+		{
+//			printf("GetSize(mpu_consumer_list):%d\n",GetSize(mpu_consumer_list)); 	/**/
+			p=GetHead(mpu_consumer_list);
+			p=p->next;
+			memcpy(buff,p->data,BUFF_LEN);
+			read_mmtp_header(&mmt_header,(const char*)buff);
+//			printf("consumer mmt_header->packet_counter%d mmt_header.packet_id:%d\n",mmt_header.packet_counter,mmt_header.packet_id);
+			if(mmt_header.packet_id==1)
+			{
+				mpu_packet_header_t mpu_header;
+				read_mpu_header(&mpu_header,(const char*)&buff[MMTPh_BUFF_LEN]);
+//				printf("mpu_header.MPU_sequence_number%d\n",mpu_header.MPU_sequence_number);//MPU_sequence_number
+				if(mpu_header.MPU_sequence_number!=1)
+				{
+		//			mpu metadata
+					if(mpu_header.FT==0)
+					{
+//						printf("mpu_header.FT==0\n");
+						if(mpu_header.f_i==0)
+						{
+							mpu_buf.packet_id=mmt_header.packet_id;
+							mpu_buf.MPU_sequence_number=mpu_header.MPU_sequence_number;
+							mpu_buf.mpu_metadata_buf.data = (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+							if(mpu_buf.mpu_metadata_buf.data==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+
+							memcpy(&mpu_buf.mpu_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+							mpu_buf.mpu_metadata_buf.length=mpu_header.length-6;
+							mpu_buf.mpu_metadata_buf.flag=1;
+							mpu_buf.mpu_metadata_buf.counter=1;
+						}
+						if(mpu_header.f_i==1)
+						{
+								;
+						}
+						if(mpu_header.f_i==2)
+						{
+								;
+						}
+						if(mpu_header.f_i==3)
+						{
+								;
+						}
+					}
+					//fragment metadata
+					if(mpu_header.FT==1&&mpu_buf.mpu_metadata_buf.flag==1)
+					{
+
+//						printf("mpu_header.FT==1\n");
+						if(mpu_header.f_i==0)
+						{
+//							printf("mpu_header.f_i==0\n");
+							mpu_buf.fragment_metadata_buf.data= (unsigned  char*) malloc((mpu_header.length-6)*sizeof( unsigned  char));
+							if(mpu_buf.fragment_metadata_buf.data==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+							memcpy(&mpu_buf.fragment_metadata_buf.data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN] , (mpu_header.length-6));
+							mpu_buf.fragment_metadata_buf.length=mpu_header.length-6;
+							mpu_buf.fragment_metadata_buf.flag=1;
+							mpu_buf.fragment_metadata_buf.counter=1;
+
+							//analysis fragmentdata,and decide recieve how many sample
+							mpu_buf.mfu_number=ntohl(*((u_int32_t*)&mpu_buf.fragment_metadata_buf.data[76]));;
+
+							mpu_buf.mfu= (mfu_buf_t *)malloc(sizeof(mfu_buf_t)*mpu_buf.mfu_number);
+							if(mpu_buf.mfu==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+							mpu_buf.mfu_sample= (mfu_sample_t *)malloc(sizeof(mfu_sample_t)*mpu_buf.mfu_number);
+							if(mpu_buf.mfu_sample==NULL)
+							{
+								puts ("Memory allocation failed.");
+								exit (EXIT_FAILURE);
+							}
+
+							//mfu
+							int i;
+							for(i=0;i<mpu_buf.mfu_number;i++)
+							{
+								mpu_buf.mfu[i].data= (unsigned  char*) malloc(1500000);
+								if(mpu_buf.mfu[i].data==NULL)
+								{
+									puts ("Memory allocation failed.");
+									exit (EXIT_FAILURE);
+								}
+								memset(mpu_buf.mfu[i].data,0,1500000);
+								mpu_buf.mfu[i].flag=0;
+								mpu_buf.mfu[i].length=0;
+								mpu_buf.mfu[i].number=0;
+								mpu_buf.mfu[i].counter=0;
+
+							}
+//							printf("hehe\n");
+//							muli_buf=(unsigned  char*) malloc((sample_number*34)*sizeof( unsigned  char));
+						}
+						if(mpu_header.f_i==1)
+						{
+							;
+						}
+						if(mpu_header.f_i==2)
+						{
+							;
+						}
+						if(mpu_header.f_i==3)
+						{
+							;
+						}
+
+					}
+		//			mfu_seekpoint=0;
+					//MFU
+
+					if(mpu_header.FT==2&&mpu_buf.mpu_metadata_buf.flag==1&&mpu_buf.fragment_metadata_buf.flag==1)
+					{
+//						printf("mpu_header.FT==2\n");
+						mfu_time_packet_header_t mfu_time_header;
+						read_mfu_time_header(&mfu_time_header,(const char*)&buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN]);
+//						printf("process 		mmt_header.packet_counter:%d , mpu_header.MPU_sequence_number %d ,mfu_time_header.sample_number: %d \n",mmt_header.packet_counter,mpu_header.MPU_sequence_number,mfu_time_header.sample_number);
+//						if(recive_mfu==mfu_time_header.sample_number)
+//						{
+							if(mpu_header.f_i==0)
+							{
+
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_header.length-6-MFUh_t_BUFF_LEN;
+								mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+								(mpu_buf.mfu_counter)++;
+
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+								if(mfu_time_header.sample_number==0)
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+								}
+								else
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+								}
+//								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_seekpoint;
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+
+
+
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1)//LAST MFU
+								{
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+
+									printf("mpu_buf.MPU_sequence_length:%d\n",mpu_buf.MPU_sequence_length);
+
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+										mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+									}
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+									free_mpu_buf(&mpu_buf );
+									printf("finished recive a mpu \n");
+
+								}
+//								free(mfu_buf);
+//								if(ringq_poll(p_queue,&recive_mfu)>=0);
+//									printf("recive_mfu:%d\n",recive_mfu);
+//								mfu_seekpoint=0;
+							}
+							if(mpu_header.f_i==1)
+							{
+						//
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+//								printf("mpu_header.fragment_counter%d\n",mpu_header.fragment_counter);
+//								printf("size:%d\n",((mpu_header.fragment_counter)*1500)*sizeof( unsigned  char));
+	//							mfu_buf= (unsigned  char*) malloc((mpu_header.fragment_counter)*1500);
+
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[0] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								mpu_buf.mfu[mfu_time_header.sample_number].counter=1;
+
+//								printf("expect mpu_header.fragment_counter%d\n",mpu_header.fragment_counter);
+							}
+							if(mpu_header.f_i==2)
+							{
+//								InsAfter(plist,p,MakeNode(buff));
+//								p = p->next;
+//								printf("size%d\n",mpu_header.fragment_counter);
+//								printf("size%d\n",GetSize(plist));
+
+
+//								printf("mpu_header.f_i==2\n");
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+							}
+							if(mpu_header.f_i==3)
+							{
+//								InsAfter(plist,p,MakeNode(buff));
+//								int j;
+//								Position p = GetHead(plist);
+//								p = p->next;
+//								for(j=0;j<GetSize(plist);j++)
+//								{
+//									read_mmtp_header(&mmt_header,p->data);
+//									printf("%dmmt_header->packet_counter%d\n",j,mmt_header.packet_counter);
+//									p = p->next;
+//
+//								}
+//								printf("size%d\n",GetSize(plist));
+//								printf("size%d\n",mpu_header.fragment_counter);
+//
+//								DestroyList(plist);
+
+
+//								printf("mpu_header.f_i==3\n");
+//								printf("mfu_seekpoint%d\n",mpu_buf.mfu[mfu_time_header.sample_number].length);
+//								printf("mfu_time_header.offset%d\n",mfu_time_header.offset);
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+								memcpy(&mpu_buf.mfu[mfu_time_header.sample_number].data[mpu_buf.mfu[mfu_time_header.sample_number].length] , &buff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN] , (mpu_header.length-6-MFUh_t_BUFF_LEN));
+								mpu_buf.mfu[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length+(mpu_header.length-6-MFUh_t_BUFF_LEN);
+								mpu_buf.mfu[mfu_time_header.sample_number].number=mpu_header.fragment_counter;
+								(mpu_buf.mfu[mfu_time_header.sample_number].counter)++;
+								if (mpu_buf.mfu[mfu_time_header.sample_number].counter==mpu_header.fragment_counter)
+								{
+									mpu_buf.mfu[mfu_time_header.sample_number].flag=1;
+								}
+								(mpu_buf.mfu_counter)++;
+//								printf("finished recive a mfu %d\n",mfu_time_header.sample_number);
+//								printf("expect %d ,finished %d ,mfu_counter %d\n",mpu_header.fragment_counter,mpu_buf.mfu[mfu_time_header.sample_number].counter,mpu_buf.mfu_counter);
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sequence_number=mfu_time_header.sample_number+1;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].trackrefindex=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].movie_fragment_sequence_number=mfu_time_header.movie_fragment_sequence_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].sample_number=mfu_time_header.sample_number;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].priority=mfu_time_header.subsample_priority;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].dependency_counter=mfu_time_header.dependency_counter;
+								if(mfu_time_header.sample_number==0)
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=8;
+								}
+								else
+								{
+									mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_buf.mfu_sample[mfu_time_header.sample_number-1].offset+mpu_buf.mfu[mfu_time_header.sample_number-1].length;
+								}
+//								mpu_buf.mfu_sample[mfu_time_header.sample_number].offset=mpu_seekpoint;
+
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].length=mpu_buf.mfu[mfu_time_header.sample_number].length;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_length=11;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_name=ATOM_muli;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved1=0;
+								mpu_buf.mfu_sample[mfu_time_header.sample_number].muli_reserved2=0;
+
+//								printf("length:%d,offset:%d\n",mpu_buf.mfu_sample[mfu_time_header.sample_number].length,mpu_buf.mfu_sample[mfu_time_header.sample_number].offset);
+								//MPU
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter==mpu_buf.mfu_number)
+								{
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+										mpu_seek=mpu_seek+mpu_buf.mfu[i].length;
+									}
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									mpu_buf.flag=1 ;
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+
+									free_mpu_buf(&mpu_buf );
+									init_mpu_buf(&mpu_buf);
+									printf("finished recive a mpu \n");
+
+								}
+								//,,
+								if(mfu_time_header.sample_number==mpu_buf.mfu_number-1&&mpu_buf.mfu_counter!=mpu_buf.mfu_number)
+								{
+//									printf("mpu_buf.MPU_sequence_number%d\n",mpu_buf.MPU_sequence_number);
+//									printf("mpu_buf.mfu_counter%d, mpu_buf.mfu_number%d\n",mpu_buf.mfu_counter,mpu_buf.mfu_number);
+
+									int mpu_seek=0;
+									int i;
+									mpu_buf.MPU_sequence_length=mpu_buf.mpu_metadata_buf.length+mpu_buf.fragment_metadata_buf.length+
+											mpu_buf.mfu_sample[mfu_time_header.sample_number].offset+mpu_buf.mfu[mfu_time_header.sample_number].length-8+\
+											mpu_buf.mfu_number*34;
+//									printf("				mpu_buf.MPU_sequence_length:%d\n",mpu_buf.MPU_sequence_length);
+									mpu_buf.MPU_sequence_data=(unsigned char*) malloc((mpu_buf.MPU_sequence_length)*sizeof( unsigned  char));
+									if(mpu_buf.MPU_sequence_data==NULL)
+									{
+										puts ("Memory allocation failed.");
+										exit (EXIT_FAILURE);
+									}
+
+									memcpy(&mpu_buf.MPU_sequence_data[0] , mpu_buf.mpu_metadata_buf.data , mpu_buf.mpu_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.mpu_metadata_buf.length;
+									memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] , mpu_buf.fragment_metadata_buf.data , mpu_buf.fragment_metadata_buf.length);
+									mpu_seek=mpu_seek+mpu_buf.fragment_metadata_buf.length;
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek+mpu_buf.mfu_sample[i].offset-8] , mpu_buf.mfu[i].data , mpu_buf.mfu[i].length);
+									}
+									mpu_seek=mpu_seek+mpu_buf.mfu_sample[mpu_buf.mfu_number-1].offset-8+mpu_buf.mfu[mpu_buf.mfu_number-1].length;
+									char mfu_sample_buff[34];
+
+									for(i=0;i<mpu_buf.mfu_number;i++)
+									{
+										init_mfu_sample(&mpu_buf.mfu_sample[i],(unsigned char*)&mfu_sample_buff[0]);
+										memcpy(&mpu_buf.MPU_sequence_data[mpu_seek] ,&mfu_sample_buff[0], 34);
+										mpu_seek=mpu_seek+34;
+									}
+
+									char mpu_filename[100];
+									sprintf(mpu_filename, "channel_MPU_%.4d.mp4",mpu_buf.MPU_sequence_number);
+
+
+									FILE *mpu;
+									if((mpu=fopen(mpu_filename,"w+"))==NULL)
+									{
+										printf("not open");
+										exit(0);
+									}
+									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
+
+									fclose(mpu);
+
+									free_mpu_buf(&mpu_buf );
+									init_mpu_buf(&mpu_buf);
+									printf("finished recive a mpu \n");
+								}
+
+							}
+
+//						}//RECIVE MFU
+					}//MFU end
+
+				}//MPU END
+			}//packet END
+
+			//
+			free(DelFirst(mpu_consumer_list));
+		}//FILTER END
+
+	}//WHILE END
+    return NULL;
+}//FUCTION END
diff --git a/net/mmt/mmtp/getfile.c b/net/mmt/mmtp/getfile.c
new file mode 100644
index 0000000..4a63216
--- /dev/null
+++ b/net/mmt/mmtp/getfile.c
@@ -0,0 +1,274 @@
+#include"getfile.h"
+
+
+int cmp(char *p1,char *p2) /*  */
+{int i=0;
+while (*(p1+i)==*(p2+i))
+if (*(p1+i++)=='\0') return 0; /* *(p1+i)=='\0'i++ */
+return (*(p1+i)-*(p2+i));
+}
+
+void sort(char **fileNameList, int count) /**/
+{
+	char *temp;
+	int i,j;
+	for(i=0;i<count-1;i++)/*  */
+	for(j=i+1;j<count;j++)
+	if(cmp(fileNameList[i],fileNameList[j])>0)
+	{
+		temp=fileNameList[i];/*  */
+		fileNameList[i]=fileNameList[j];
+		fileNameList[j]=temp;
+	}
+}
+
+// author:wangchangshaui jlu
+//this function can get result in fileNameList
+int getFileNameArray(const char *path, u_int32_t* fileCount,char ***fileNameList)
+{
+    int count = 0;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if (((*fileNameList) = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return -1;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return -1;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if (((*fileNameList)[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return -1;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset((*fileNameList)[i], 0, strlen(ent->d_name) + 1);
+            strcpy((*fileNameList)[i], ent->d_name);
+            printf("%d:%s\n", i, (*fileNameList)[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort((*fileNameList), count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,(*fileNameList)[i]);
+       }
+
+    return 1;
+}
+
+// author:wangchangshaui jlu
+//this function like getFileNameArray, you  can get result by return
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount)
+{
+    int count = 0;
+    char **fileNameList = NULL;
+    //char **fileNameList = NULL;
+    struct dirent* ent = NULL;
+    DIR *pDir;
+    char dir[512];
+    struct stat statbuf;
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    while ((ent = readdir(pDir)) != NULL)
+    { //
+//
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            count++;
+        }
+    } //while
+//
+    closedir(pDir);
+//  printf("%d\n", count);
+
+//
+    if ((fileNameList = (char**) malloc(sizeof(char*) * count)) == NULL)
+    {
+        printf("Malloc heap failed!\n");
+        return NULL;
+    }
+
+//
+    if ((pDir = opendir(path)) == NULL)
+    {
+        printf("Cannot open directory:%s\n", path);
+        return NULL;
+    }
+//
+    int i;
+    for (i = 0; (ent = readdir(pDir)) != NULL && i < count;)
+    {
+        if (strlen(ent->d_name) <= 0)
+        {
+            continue;
+        }
+        //
+        snprintf(dir, 512, "%s/%s", path, ent->d_name);
+        //
+        lstat(dir, &statbuf);
+        //
+        if (!S_ISDIR(statbuf.st_mode))
+        {
+            if ((fileNameList[i] = (char*) malloc(strlen(ent->d_name) + 1))
+                    == NULL)
+            {
+                printf("Malloc heap failed!\n");
+                return NULL;
+            }
+//            char dir_buf[512];
+//            memset(dir_buf, 0, strlen(dir_buf));
+//            memcpy(dir_buf,path,strlen(path));
+//            memcpy(&dir_buf[strlen(path)],ent->d_name,strlen(ent->d_name) + 1);
+//
+//            memset(fileNameList[i], 0, strlen(path)+strlen(ent->d_name) + 1);
+//            memcpy(fileNameList[i],dir_buf,strlen(dir_buf) + 1);
+//            //strcpy(fileNameList[i], dir_buf);
+
+            memset(fileNameList[i], 0, strlen(ent->d_name) + 1);
+            strcpy(fileNameList[i], ent->d_name);
+            printf("%d:%s\n", i, fileNameList[i]);
+
+
+            i++;
+        }
+    } //for
+//
+    closedir(pDir);
+    *fileCount = count;
+    //q_sortB(fileNameList, count);
+    sort(fileNameList, count);
+    for(i=0;i<count;i++)
+       {
+
+       	printf("bbbb%d:%s\n",i,fileNameList[i]);
+       }
+
+    return fileNameList;
+}
+
+void get_full_path(const char *path ,char * filename,char ** fullpath )
+{
+
+	char dir_buf[512];
+	memset(dir_buf, 0, 512);
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	*fullpath=dir_buf;
+	printf("fullpath%s\n",*fullpath);
+}
+
+char* get_full_path2(const char *path ,char * filename)
+{
+
+	static char dir_buf[512];
+	memset(dir_buf, 0, strlen(dir_buf));
+	memcpy(dir_buf,path,strlen(path));
+	memcpy(&dir_buf[strlen(path)],filename,strlen(filename) + 1);
+	//printf("fullpath%s\n",dir_buf);
+	return (char *)dir_buf;
+
+}
+
+int ReadFile(char * path, char ** fdata, u_int16_t *length)
+{
+    FILE * pfile;
+    char * data;
+
+    pfile = fopen(path, "rb");
+    if (pfile == NULL)
+    {
+        return -1;
+    }
+    fseek(pfile, 0, SEEK_END);
+    *length = ftell(pfile);
+    data = (char *)malloc((*length + 1) * sizeof(char));
+    rewind(pfile);
+    *length = fread(data, 1, *length, pfile);
+    data[*length] = '\0';
+    fclose(pfile);
+    *fdata=data;
+    return 1;
+}
+
+char* strcatex(char* str1, char* str2)
+{
+    char* buf = (char*) malloc(strlen(str1) + strlen(str2) + 1);
+    sprintf(buf, "%s", str1);
+    strcat(buf, str2);
+    return buf;
+}
diff --git a/net/mmt/mmtp/getfile.h b/net/mmt/mmtp/getfile.h
new file mode 100644
index 0000000..abcf152
--- /dev/null
+++ b/net/mmt/mmtp/getfile.h
@@ -0,0 +1,22 @@
+#ifndef NET_MMT_MMTP_GETFILE_H_
+#define NET_MMT_MMTP_GETFILE_H_
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+int getFileNameArray(const char *path, u_int32_t* fileCount,char * **fileNameList);
+char ** getFileNameArray2(const char *path, u_int32_t* fileCount);
+void get_full_path(const char *path ,char * filename,char ** fullpath );
+char *get_full_path2(const char *path ,char * filename);
+//char * ReadFile(char * path, int *length);
+int ReadFile(char * path, char ** fdata,u_int16_t *length);
+char* strcatex(char* str1, char* str2);
+
+#endif
diff --git a/net/mmt/mmtp/ini.c b/net/mmt/mmtp/ini.c
new file mode 100644
index 0000000..798f069
--- /dev/null
+++ b/net/mmt/mmtp/ini.c
@@ -0,0 +1,692 @@
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+
+# undef  _GNU_SOURCE
+# define _GNU_SOURCE
+
+# include <stdio.h>
+# include <string.h>
+# include <stdlib.h>
+# include <stdbool.h>
+# include <ctype.h>
+# include <arpa/inet.h>
+# include <fcntl.h>
+#include <unistd.h>
+
+# include "ini.h"
+#define  MAX_PATH 260
+
+static bool is_comment(char **line)
+{
+    char *content = *line;
+    while (isspace(*content))
+        ++content;
+
+    if (*content == ';' || *content == '#' || *content == '\0')
+        return true;
+
+    char *end = content + strlen(content) - 1;
+    while (isspace(*end))
+        *end-- = '\0';
+
+    *line = content;
+
+    return false;
+}
+
+static ssize_t _getline(char **lineptr, size_t *n, FILE *stream)
+{
+    ssize_t len = getline(lineptr, n, stream);
+    if (len == -1)
+        return -1;
+
+    char  *_line = NULL;
+    size_t _n    = 0;
+
+    while (len >= 2 && (*lineptr)[len - 2] == '\\')
+    {
+        if (getline(&_line, &_n, stream) == -1)
+        {
+            free(_line);
+
+            return 0;
+        }
+
+        char *next_line = _line;
+        while (isspace(*next_line))
+            ++next_line;
+        ssize_t next_len = strlen(next_line);
+        ssize_t need_len = len - 1 + next_len + 1;
+
+        if (*n < need_len)
+        {
+            while (*n < need_len)
+                *n *= 2;
+
+            *lineptr = realloc(*lineptr, *n);
+            if (*lineptr == NULL)
+            {
+                free(_line);
+
+                return -1;
+            }
+        }
+
+        if (isspace((*lineptr)[len - 3]))
+            (*lineptr)[len - 2] = '\0';
+        else
+            (*lineptr)[len - 2] = ' ';
+        (*lineptr)[len - 1] = '\0';
+
+        strcat(*lineptr, next_line);
+        len = strlen(*lineptr);
+    }
+
+    if (_line)
+        free(_line);
+
+    return len;
+}
+
+void ini_free(ini_t *handler)
+{
+    struct ini_section *curr = handler;
+    struct ini_section *next = NULL;
+
+    while (curr)
+    {
+        next = curr->next;
+
+        struct ini_arg *arg_curr = curr->args;
+        struct ini_arg *arg_next = NULL;
+
+        while (arg_curr)
+        {
+            arg_next = arg_curr->next;
+
+            free(arg_curr->name);
+            free(arg_curr->value);
+            free(arg_curr);
+
+            arg_curr = arg_next;
+        }
+
+        free(curr->name);
+        free(curr);
+
+        curr = next;
+    }
+
+    return;
+}
+
+static void ini_print(ini_t *handler)
+{
+# ifdef DEBUG
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name == NULL)
+            continue;
+
+        printf("[%s]\n", curr->name);
+
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name == NULL || arg->value == NULL)
+                continue;
+
+            printf("    %-20s = %s\n", arg->name, arg->value);
+            arg = arg->next;
+        }
+
+        curr = curr->next;
+    }
+# endif
+
+    return;
+}
+
+static struct ini_section *create_section(struct ini_section *head, char *name)
+{
+    struct ini_section *p = calloc(1, sizeof(struct ini_section));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_section *find_section(struct ini_section *head, char *name)
+{
+    struct ini_section *curr = head;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(curr->name, name) == 0)
+            return curr;
+
+        curr = curr->next;
+    }
+
+    return NULL;
+}
+
+static struct ini_arg *create_arg(struct ini_section *head, char *name, char *value)
+{
+    struct ini_arg *p = calloc(1, sizeof(struct ini_arg));
+
+    if (p == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->name = strdup(name)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    if ((p->value = strdup(value)) == NULL)
+    {
+        ini_free(head);
+
+        return NULL;
+    }
+
+    return p;
+}
+
+static struct ini_arg *find_arg(struct ini_section *curr, char *name)
+{
+    struct ini_arg *arg = curr->args;
+
+    while (arg)
+    {
+        if (arg->name && strcmp(arg->name, name) == 0)
+            return arg;
+
+        arg = arg->next;
+    }
+
+    return NULL;
+}
+
+ini_t *ini_load(char *path)
+{
+
+	char current_absolute_path[MAX_PATH];
+	memset(current_absolute_path,0,sizeof(current_absolute_path));
+	//
+	int cnt = readlink("/proc/self/exe", current_absolute_path, MAX_PATH);
+	if (cnt < 0 || cnt >= MAX_PATH)
+	{
+	    printf("***Error***\n");
+	    exit(-1);
+	}
+	//
+	int i;
+	for (i = cnt; i >=0; --i)
+	{
+	    if (current_absolute_path[i] == '/')
+	    {
+	        //current_absolute_path[i+1] = '\0';
+	    	memcpy(&current_absolute_path[i+1],path,(strlen(path)+1));
+	        break;
+	    }
+	    else
+	    	current_absolute_path[i] = '\0';
+
+	}
+
+    FILE *fp = fopen(current_absolute_path, "r");
+
+    if (fp == NULL)
+        return NULL;
+
+    struct ini_section *head = NULL;
+    struct ini_section *prev = NULL;
+    struct ini_section *curr = NULL;
+
+    struct ini_arg *arg_curr = NULL;
+    struct ini_arg *arg_prev = NULL;
+
+    char *line  = NULL;
+    size_t   n  = 0;
+    ssize_t len = 0;
+
+    while ((len = _getline(&line, &n, fp)) != -1)
+    {
+        char *s = line;
+        if (is_comment(&s))
+            continue;
+        len = strlen(s);
+
+        if (len >= 3 && s[0] == '[' && s[len - 1] == ']')
+        {
+            char *name = s + 1;
+            while (isspace(*name))
+                ++name;
+
+            char *name_end = s + len - 1;
+            *name_end-- = '\0';
+            while (isspace(*name_end))
+                *name_end-- = '\0';
+
+            if ((curr = find_section(head, name)) == NULL)
+            {
+                if ((curr = create_section(head, name)) == NULL)
+                {
+                    free(line);
+
+                    return NULL;
+                }
+
+                if (head == NULL)
+                    head = curr;
+                if (prev != NULL)
+                    prev->next = curr;
+
+                prev = curr;
+                arg_prev = NULL;
+            }
+            else
+            {
+                arg_prev = curr->args;
+                while (arg_prev->next != NULL)
+                    arg_prev = arg_prev->next;
+            }
+
+            continue;
+        }
+
+        char *delimiter = strchr(s, '=');
+        if (delimiter == NULL)
+            continue;
+        *delimiter = '\0';
+
+        char *name = s;
+        char *name_end = delimiter - 1;
+        while (isspace(*name_end))
+            *name_end-- = '\0';
+
+        char *value = delimiter + 1;
+        while (isspace(*value))
+            value++;
+
+        if (curr == NULL)
+        {
+            if ((curr = create_section(head, "global")) == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (head == NULL)
+                head = curr;
+            prev = curr;
+            arg_prev = NULL;
+        }
+
+        if ((arg_curr = find_arg(curr, name)) == NULL)
+        {
+            arg_curr = create_arg(head, name, value);
+            if (arg_curr == NULL)
+            {
+                free(line);
+
+                return NULL;
+            }
+
+            if (arg_prev)
+                arg_prev->next = arg_curr;
+            if (curr->args == NULL)
+                curr->args = arg_curr;
+
+            arg_prev = arg_curr;
+        }
+        else
+        {
+            char *old_value = arg_curr->value;
+
+            if ((arg_curr->value = strdup(value)) == NULL)
+            {
+                ini_free(head);
+
+                free(line);
+
+                return NULL;
+            }
+
+            free(old_value);
+        }
+    }
+
+    free(line);
+    fclose(fp);
+
+    if (head == NULL)
+    {
+        if ((head = calloc(1, sizeof(struct ini_section))) == NULL)
+            return NULL;
+    }
+
+    ini_print(head);
+
+    return head;
+}
+
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value)
+{
+    if (!handler || !name || !value)
+        return -1;
+
+    if (section == NULL || *section == 0)
+        section = "global";
+
+    struct ini_section *curr = handler;
+
+    while (curr)
+    {
+        if (curr->name && strcmp(section, curr->name) == 0)
+            break;
+
+        curr = curr->next;
+    }
+
+    if (curr)
+    {
+        struct ini_arg *arg = curr->args;
+
+        while (arg)
+        {
+            if (arg->name && arg->value && strcmp(arg->name, name) == 0)
+            {
+                *value = strdup(arg->value);
+                if (*value == NULL)
+                    return -1;
+
+                return 0;
+            }
+
+            arg = arg->next;
+        }
+    }
+
+    if (default_value)
+    {
+        *value = strdup(default_value);
+        if (*value == NULL)
+            return -1;
+    }
+    else
+    {
+        *value = NULL;
+    }
+
+    return 1;
+}
+
+static char *sstrncpy(char *dest, const char *src, size_t n)
+{
+    if (n == 0)
+        return dest;
+
+    dest[0] = 0;
+
+    return strncat(dest, src, n - 1);
+}
+
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(value, 0, n);
+
+    if (s)
+    {
+        sstrncpy(value, s, n);
+        free(s);
+    }
+
+    return ret;
+}
+
+static int ini_read_num(ini_t *handler,
+        char *section, char *name, void *value, bool is_unsigned)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        if (is_unsigned)
+            *(unsigned long long int*)value = strtoull(s, NULL, 0);
+        else
+            *(long long int *)value = strtoll(s, NULL, 0);
+
+        free(s);
+    }
+
+    return ret;
+}
+
+# define INI_READ_SIGNED(type) do { \
+    long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, false); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+# define INI_READ_UNSIGNED(type) do { \
+    unsigned long long int v; \
+    int ret = ini_read_num(handler, section, name, &v, true); \
+    if (ret == 0) { \
+        *value = (type)v; \
+    } \
+    else if (ret > 0) { \
+        *value = default_value; \
+    } \
+    return ret; \
+} while (0)
+
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value)
+{
+    INI_READ_SIGNED(int);
+}
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value)
+{
+    INI_READ_UNSIGNED(unsigned);
+}
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value)
+{
+    INI_READ_SIGNED(int8_t);
+}
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value)
+{
+    INI_READ_UNSIGNED(uint8_t);
+}
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value)
+{
+    INI_READ_SIGNED(int16_t);
+}
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value)
+{
+    INI_READ_UNSIGNED(uint16_t);
+}
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value)
+{
+    INI_READ_SIGNED(int32_t);
+}
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value)
+{
+    INI_READ_UNSIGNED(uint32_t);
+}
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value)
+{
+    INI_READ_SIGNED(int64_t);
+}
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value)
+{
+    INI_READ_UNSIGNED(uint64_t);
+}
+
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtof(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        *value = strtod(s, NULL);
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, default_value);
+    if (ret < 0)
+        return ret;
+
+    memset(addr, 0, sizeof(struct sockaddr_in));
+
+    if (s)
+    {
+        char *ip = strtok(s, ": \t");
+        if (ip == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        char *port = strtok(NULL, ": \t");
+        if (port == NULL)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_family = AF_INET;
+        if (inet_aton(ip, &addr->sin_addr) == 0)
+        {
+            free(s);
+
+            return -1;
+        }
+
+        addr->sin_port = htons((uint16_t)atoi(port));
+
+        free(s);
+    }
+
+    return ret;
+}
+
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value)
+{
+    char *s = NULL;
+    int ret = ini_read_str(handler, section, name, &s, NULL);
+    if (ret == 0)
+    {
+        int i;
+        for (i = 0; s[i]; ++i)
+            s[i] = tolower(s[i]);
+
+        if (strcmp(s, "true") == 0)
+            *value = true;
+        else if (strcmp(s, "false") == 0)
+            *value = false;
+        else
+            *value = default_value;
+
+        free(s);
+    }
+    else if (ret > 0)
+    {
+        *value = default_value;
+    }
+
+    return ret;
+}
+
diff --git a/net/mmt/mmtp/ini.h b/net/mmt/mmtp/ini.h
new file mode 100644
index 0000000..ab895e6
--- /dev/null
+++ b/net/mmt/mmtp/ini.h
@@ -0,0 +1,153 @@
+#ifndef NET_MMT_MMTP_INI_H_
+#define NET_MMT_MMTP_INI_H_
+
+/*
+ * Description: simple read only ini parser
+ *     History: yang@haipo.me, 2013/06/13, create
+ */
+
+# include <stdint.h>
+# include <stdbool.h>
+# include <netinet/in.h>
+
+struct ini_arg
+{
+    char  *name;
+    char  *value;
+    struct ini_arg *next;
+};
+
+struct ini_section
+{
+    char  *name;
+    struct ini_arg *args;
+    struct ini_section *next;
+};
+
+typedef struct ini_section ini_t;
+
+/*
+ * Feature:
+ * 1: If a property name declared befor any section is declared, it
+ *    is in a "global" section. If the ini_read_* function argument
+ *    section is empty string or NULL, they will find the property
+ *    name in the "global" section.
+ *
+ * 2: There is no technical LIMIT on the length of section name or
+ *    property name or value, or the num of sections and properties,
+ *    the limit is the size of memory.
+ *
+ * 3: There is no special limit on the name of section and property.
+ *    Note that the surround whitespace of the name of section and
+ *    property and value is ignored, but they can contian whitespace.
+ *    Note that the name of section and property are case insensitivity.
+ *
+ * 4: Blank line is ignored.
+ *
+ * 5: Lines beginning with '#' or ';' are ignored and may be used to
+ *    provide comments.
+ *
+ * 6: The second occurrence of a property name in the same section
+ *    overwrite the previous one. The section occurrence of a section
+ *    is joined whih the previous one.
+ *
+ * 7: If a line end with '\', where a backslash followed immediately
+ *    by EOL (end-of-line) causes the line break to be ignored, and
+ *    the "logical line" to be continued on the next actual line from
+ *    the INI file. Example:
+ *        name = simple read only ini parser
+ *    is the same with:
+ *        name = simple \
+ *               read only \
+ *               ini parser
+ */
+
+/*
+ * Load a ini config file to memory, return NULL if fail.
+ */
+ini_t *ini_load(char *path);
+
+/*
+ * Return value:
+ * If the combination of section and name found in config file, return 0.
+ * Return 1 if not found, the *value will be the default_value.
+ *
+ * Fail return -1;
+ */
+
+/*
+ * Read string from ini config handler.
+ * The string is allocated using malloc, so, you need free it after use.
+ */ 
+int ini_read_str(ini_t *handler,
+        char *section, char *name, char **value, char *default_value);
+
+/*
+ * Read string from ini config handler.
+ * If the real length of value is greater than or equal to n, n - 1
+ * characters and a null terminator will be copied to value, else
+ * the remainder of value pads with null bytes.
+ */
+int ini_read_strn(ini_t *handler,
+        char *section, char *name, char *value, size_t n, char *default_value);
+
+/*
+ * Read int or unsigned int or stdint from ini config handler.
+ * Support octal or hexadecimal base ("0" or "0x"/"0X" respectively).
+ */
+int ini_read_int(ini_t *handler,
+        char *section, char *name, int *value, int default_value);
+
+int ini_read_unsigned(ini_t *handler,
+        char *section, char *name, unsigned *value, unsigned default_value);
+
+int ini_read_int8(ini_t *handler,
+        char *section, char *name, int8_t *value, int8_t default_value);
+
+int ini_read_uint8(ini_t *handler,
+        char *section, char *name, uint8_t *value, uint8_t default_value);
+
+int ini_read_int16(ini_t *handler,
+        char *section, char *name, int16_t *value, int16_t default_value);
+
+int ini_read_uint16(ini_t *handler,
+        char *section, char *name, uint16_t *value, uint16_t default_value);
+
+int ini_read_int32(ini_t *handler,
+        char *section, char *name, int32_t *value, int32_t default_value);
+
+int ini_read_uint32(ini_t *handler,
+        char *section, char *name, uint32_t *value, uint32_t default_value);
+
+int ini_read_int64(ini_t *handler,
+        char *section, char *name, int64_t *value, int64_t default_value);
+
+int ini_read_uint64(ini_t *handler,
+        char *section, char *name, uint64_t *value, uint64_t default_value);
+
+/*
+ * Read float/double from ini config handler.
+ */
+int ini_read_float(ini_t *handler,
+        char *section, char *name, float *value, float default_value);
+
+int ini_read_double(ini_t *handler,
+        char *section, char *name, double *value, double default_value);
+
+/*
+ * Read a ipv4 addr such as: 127.0.0.1:8080 or 127.0.0.1 8080
+ */
+int ini_read_ipv4_addr(ini_t *handler,
+        char *section, char *name, struct sockaddr_in *addr, char *default_value);
+
+/*
+ * Read a bool from ini config handler. The value in the ini config file can be
+ * "true" or "false", the case are ignored.
+ */
+int ini_read_bool(ini_t *handler,
+        char *section, char *name, bool *value, bool default_value);
+
+/* Free a ini config handler */
+void ini_free(ini_t *handler);
+
+#endif
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
new file mode 100644
index 0000000..e2a09ee
--- /dev/null
+++ b/net/mmt/mmtp/mmt.c
@@ -0,0 +1,1293 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <time.h>
+#define BACKLOG 2
+
+#include "../mpu/stream.h"
+#include "../mpu/mp4.h"
+
+#include <string.h>
+#include <error.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <mcheck.h>
+#include "ini.h"
+
+#include "mmt.h"
+#include "getfile.h"
+#include "send.h"
+
+int get_send_timestamp()
+{
+	int MMT_timestamp;
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+
+	time_t timep;
+	struct tm *p;
+	time(&timep);
+	p = localtime(&timep);
+
+	MMT_timestamp=p->tm_hour*60*60*1000+p->tm_min*60*1000+p->tm_sec*1000+tv.tv_usec/1000;
+	return MMT_timestamp;
+}
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number)
+{
+	unsigned char *buff_tmp=(unsigned  char*) malloc(number*sizeof( unsigned   char));
+	memset(buff_tmp,0,number);
+	memcpy(&buff_tmp[0],srcbuff,number);
+	*dstbuff=buff_tmp;
+	return 0;
+
+}
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh)
+{
+//	mmt_packet_header_t mmt_header;
+
+//			mmt_header.version=0;
+//			mmt_header.packet_counter_flag=1;
+//			mmt_header.FEC_type=0;
+//			mmt_header.reserved_1=0;
+//			mmt_header.extension_flag=0;
+//			mmt_header.RAP_flag=0;
+//			mmt_header.reserved_2=0;
+//			mmt_header.type=2;
+//			mmt_header.packet_id=packet_id;
+//			mmt_header.timestamp=MMT_timestamp;
+//			mmt_header.packet_sequence_number=0;
+//			mmt_header.packet_counter=packet_counter;
+
+//16byte
+			memset(MMTPh,0,MMTPh_BUFF_LEN);
+			MMTPh[0]=(u_int8_t)mmt_header->version<<6
+					|(u_int8_t) mmt_header->packet_counter_flag<<5
+					|(u_int8_t) mmt_header->FEC_type<<3
+					|(u_int8_t) mmt_header->reserved_1<<2
+					|(u_int8_t) mmt_header->extension_flag<<1
+					|(u_int8_t) mmt_header->RAP_flag;
+			MMTPh[1]=(u_int8_t)mmt_header->reserved_2<<6
+					|(u_int8_t) mmt_header->type;
+			*((u_int16_t*)&MMTPh[2])=htons(mmt_header->packet_id);
+			*((u_int32_t*)&MMTPh[4])=htonl(mmt_header->present_time);
+			*((u_int32_t*)&MMTPh[8])=htonl(mmt_header->timestamp);
+			*((u_int32_t*)&MMTPh[12])=htonl(mmt_header->packet_sequence_number);
+			*((u_int32_t*)&MMTPh[16])=htonl(mmt_header->packet_counter);
+
+return 0;
+}
+
+int read_mmtp_header(mmt_packet_header_t *mmt_header, const char *MMTPh)
+{
+			mmt_header->version=(MMTPh[0]>>6)&0x03;
+			mmt_header->packet_counter_flag=(MMTPh[0]>>5)&0x01;
+			mmt_header->FEC_type=(MMTPh[0]>>3)&0x03;
+			mmt_header->reserved_1=(MMTPh[0]>>2)&0x01;
+			mmt_header->extension_flag=(MMTPh[0]>>1)&0x01;
+			mmt_header->RAP_flag=MMTPh[0]&0x01;
+			mmt_header->reserved_2=(MMTPh[1]>>6)&0x3F;
+			mmt_header->type=MMTPh[1]&0x03;
+			mmt_header->packet_id=ntohs(*((u_int16_t*)&MMTPh[2]));
+			mmt_header->present_time=ntohl(*((u_int32_t*)&MMTPh[4]));
+			mmt_header->timestamp=ntohl(*((u_int32_t*)&MMTPh[8]));
+			mmt_header->packet_sequence_number=ntohl(*((u_int32_t*)&MMTPh[12]));
+			mmt_header->packet_counter=ntohl(*((u_int32_t*)&MMTPh[16]));
+			return 0;
+}
+
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh)
+{
+			//8byte
+			memset(MPUh,0,MPUh_BUFF_LEN);
+
+//			mpu_header->length=0;
+//			mpu_header->FT=0;
+//			mpu_header->timed_Flag=0;
+//			mpu_header->f_i=0;
+//			mpu_header->aggregation_flag=0;
+//			mpu_header->fragment_counter=0;
+//			mpu_header->MPU_sequence_number=0;
+
+			*((u_int16_t*)&MPUh[0])=htons(mpu_header->length);
+			MPUh[2]=mpu_header->FT<<4
+					|(u_int8_t) mpu_header->timed_Flag<<3
+					|(u_int8_t) mpu_header->f_i<<1
+					|(u_int8_t) mpu_header->aggregation_flag;
+
+			MPUh[3]=(u_int8_t )mpu_header->fragment_counter;
+			*((u_int32_t*)&MPUh[4])=htonl(mpu_header->MPU_sequence_number);
+
+			return 0;
+}
+
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh)
+{
+	//8byte
+			mpu_header->length=ntohs(*((u_int16_t*)&MPUh[0]));
+			mpu_header->FT=(MPUh[2]>>4)&0x0F;
+			mpu_header->timed_Flag=(MPUh[2]>>3)&0x01;
+			mpu_header->f_i=(MPUh[2]>>1)&0x03;
+			mpu_header->aggregation_flag=(MPUh[2])&0x01;
+			mpu_header->fragment_counter=MPUh[3];
+			mpu_header->MPU_sequence_number=ntohl(*((u_int32_t*)&MPUh[4]));
+
+			return 0;
+}
+
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t)
+{
+	//14byte
+			memset(MFUh_t,0,MPUh_BUFF_LEN);
+
+	//		u_int32_t movie_fragment_sequence_number;
+	//			u_int32_t sample_number;
+	//			u_int32_t offset;
+	//			u_int8_t subsample_priority;
+	//			u_int8_t dependency_counter;
+//			mfu_time_header->movie_fragment_sequence_number=0;
+//			mfu_time_header->sample_number=0;
+//			mfu_time_header->offset=0;
+//			mfu_time_header->subsample_priority=0;
+//			mfu_time_header->dependency_counter=0;
+
+			*((u_int32_t*)&MFUh_t[0])=htonl(mfu_time_header->movie_fragment_sequence_number);
+			*((u_int32_t*)&MFUh_t[4])=htonl(mfu_time_header->sample_number);
+			*((u_int32_t*)&MFUh_t[8])=htonl(mfu_time_header->offset);
+			*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+			*((u_int8_t*)&MFUh_t[13])=(u_int8_t)mfu_time_header->dependency_counter;
+
+			return 0;
+}
+
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t)
+{
+			mfu_time_header->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&MFUh_t[0]));
+			mfu_time_header->sample_number=ntohl(*((u_int32_t*)&MFUh_t[4]));
+			mfu_time_header->offset=ntohl(*((u_int32_t*)&MFUh_t[8]));
+			mfu_time_header->subsample_priority=MFUh_t[12];
+			mfu_time_header->dependency_counter=MFUh_t[13];
+			return 0;
+}
+
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt)
+{
+	//4byte
+
+			memset(MFUh_nt,0,MFUh_nt_BUFF_LEN);
+
+			//u_int32_t Item_ID;
+			mfu_non_time_header->Item_ID=0;
+			*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header->Item_ID);
+
+			return 0;
+}
+
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt)
+{
+	//4byte
+			mfu_non_time_header->Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			return 0;
+}
+
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf)
+{
+	*((u_int32_t*)&mfu_sample_buf[0])=htonl(mfu_sample->sequence_number);
+	mfu_sample_buf[4]=mfu_sample->trackrefindex;
+	*((u_int32_t*)&mfu_sample_buf[5])=htonl(mfu_sample->movie_fragment_sequence_number);
+	*((u_int32_t*)&mfu_sample_buf[9])=htonl(mfu_sample->sample_number);
+	mfu_sample_buf[13]=mfu_sample->priority;
+	mfu_sample_buf[14]=mfu_sample->dependency_counter;
+	*((u_int32_t*)&mfu_sample_buf[15])=htonl(mfu_sample->offset);
+	*((u_int32_t*)&mfu_sample_buf[19])=htonl(mfu_sample->length);
+	*((u_int32_t*)&mfu_sample_buf[23])=htonl(mfu_sample->muli_length);
+	*((u_int32_t*)&mfu_sample_buf[27])=mfu_sample->muli_name;
+	*((u_int16_t*)&mfu_sample_buf[31])=htons(mfu_sample->muli_reserved1);
+	*((u_int8_t*)&mfu_sample_buf[33])=mfu_sample->muli_reserved2;
+			return 0;
+}
+
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf)
+{
+
+
+
+	mfu_sample->sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[0]));
+	mfu_sample->trackrefindex=mfu_sample_buf[4];
+	mfu_sample->sample_number=ntohl(*((u_int32_t*)&mfu_sample_buf[5]));
+	mfu_sample->movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mfu_sample_buf[9]));
+	mfu_sample->priority=mfu_sample_buf[13];
+	mfu_sample->dependency_counter=mfu_sample_buf[14];
+	mfu_sample->offset=ntohl(*((u_int32_t*)&mfu_sample_buf[15]));
+	mfu_sample->length=ntohl(*((u_int32_t*)&mfu_sample_buf[19]));
+	mfu_sample->muli_length=ntohl(*((u_int32_t*)&mfu_sample_buf[23]));
+	mfu_sample->muli_name=ntohl(*((u_int32_t*)&mfu_sample_buf[27]));
+	mfu_sample->muli_reserved1=ntohl(*((u_int16_t*)&mfu_sample_buf[31]));
+	mfu_sample->muli_reserved2=ntohl(*((u_int8_t*)&mfu_sample_buf[33]));
+			return 0;
+}
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh)
+{
+	//10 byte
+	*((u_int16_t*)&SMTh[0])=htons(smt_header->SPS);
+	*((u_int8_t*)&SMTh[2])=(u_int8_t)smt_header->SDC;
+	*((u_int16_t*)&SMTh[3])=htons(smt_header->LEN);
+	*((u_int16_t*)&SMTh[5])=htons(smt_header->TCH);
+	*((u_int16_t*)&SMTh[7])=htons(smt_header->RSV1);
+	*((u_int8_t*)&SMTh[9])=(u_int8_t)smt_header->RSV2;
+	return 0;
+
+}
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh)
+{
+	//10byte
+	smt_header->SPS=ntohs(*((u_int16_t*)&SMTh[0]));
+	smt_header->SPS=SMTh[2];
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[3]));
+	smt_header->LEN=ntohs(*((u_int16_t*)&SMTh[5]));
+	smt_header->RSV1=ntohs(*((u_int16_t*)&SMTh[7]));
+	smt_header->RSV2=SMTh[9];
+	return 0;
+
+}
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+	mp4_box_t *root = NULL;
+	mp4_box_t *moof = NULL;
+	stream_t* s = NULL;
+
+	s = create_file_stream();
+	if (stream_open(s, Fullpath, MODE_READ) == 0)
+	   return -1;
+
+	root = MP4_BoxGetRoot(s);
+	//
+	stream_seek(s, 0, 0);
+
+	mpu_metadata_t mpu_metadata;
+	fragment_metadata_t fragment_metadata;
+	mpu_metadata.start=0;
+	mpu_metadata.length=root->p_first->p_next->p_next->p_next->i_pos;
+	mpu_metadata.number=(mpu_metadata.length+MPU_BUFF_LEN-1)/(unsigned int)MPU_BUFF_LEN;
+
+	fragment_metadata.start=root->p_first->p_next->p_next->p_next->i_pos;
+	fragment_metadata.length=root->p_first->p_next->p_next->p_next->i_size+8;
+	fragment_metadata.number=(fragment_metadata.length+MPU_BUFF_LEN-1)/MPU_BUFF_LEN;
+
+	uint32_t mdat_start;
+	mdat_start=root->p_first->p_next->p_next->p_next->p_next->i_pos;
+
+	//send mpu_metadata
+	stream_seek(s, mpu_metadata.start, 0);
+	int counter;
+	for (counter=0;counter<mpu_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(mpu_metadata.number-1))
+		{
+			mpu_header.length=mpu_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=0;
+		mpu_header.timed_Flag=1;
+		if(mpu_metadata.number>1)
+		{	mpu_header.fragment_counter=mpu_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(mpu_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+		if(mpu_header.f_i==0 ||mpu_header.f_i==1 )
+		{
+			mmt_header.present_time=*MPU_present_time;
+		}
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+
+
+//		printf("send MPU_sequence_number %d mpu_metadata\n",MPU_sequence_number);
+
+	}
+	//send fragment_metadata
+	stream_seek(s, fragment_metadata.start, 0);
+	for (counter=0;counter<fragment_metadata.number;counter++)
+	{
+		mpu_packet_header_t mpu_header;
+		unsigned char MPUh[MPUh_BUFF_LEN];
+
+		if(counter==(fragment_metadata.number-1))
+		{
+			mpu_header.length=fragment_metadata.length%MPU_BUFF_LEN+6;
+			if(fragment_metadata.length%MPU_BUFF_LEN==0)
+					{
+						mpu_header.length=MPU_BUFF_LEN+6;
+					}
+		}
+		else
+		{
+			mpu_header.length=MPU_BUFF_LEN+6;
+		}
+
+		mpu_header.FT=1;
+		mpu_header.timed_Flag=1;
+		if(fragment_metadata.number>1)
+		{
+			mpu_header.fragment_counter=fragment_metadata.number;
+			if(counter==0)
+				mpu_header.f_i=1;
+			else if(counter==(fragment_metadata.number-1))
+			{
+				mpu_header.f_i=3;
+			}
+			else
+			{
+				mpu_header.f_i=2;
+			}
+		}
+		else
+		{
+			mpu_header.f_i=0;
+			mpu_header.fragment_counter=1;
+		}
+		mpu_header.aggregation_flag=0;
+		mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+		init_mpu_header(&mpu_header,MPUh);
+
+		//16byte
+		mmt_packet_header_t mmt_header;
+		unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+		mmt_header.version=0;
+		mmt_header.packet_counter_flag=1;
+		mmt_header.FEC_type=0;
+		mmt_header.reserved_1=0;
+		mmt_header.extension_flag=0;
+		mmt_header.RAP_flag=0;
+		mmt_header.reserved_2=0;
+		mmt_header.type=0;
+		mmt_header.packet_id=packet_id;
+		mmt_header.present_time=0;
+		mmt_header.timestamp=get_send_timestamp();
+		mmt_header.packet_sequence_number=*packet_sequence_number;
+		mmt_header.packet_counter=(*packet_counter);
+
+		init_mmtp_header(&mmt_header,MMTPh);
+
+		char UDPbuff[UDP_BUFF_LEN]={};
+		memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+		memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+		stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length-6);
+		send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+		if((*packet_counter)==maximum_value)
+			{
+				*packet_counter=0;
+			}
+		else
+			{
+			(*packet_counter)++;
+			}
+		if((*packet_sequence_number)==maximum_value)
+			{
+				*packet_sequence_number=0;
+			}
+		else
+			{
+			(*packet_sequence_number)++;
+			}
+
+//		printf("send MPU_sequence_number %d fragment_metadata\n",MPU_sequence_number);
+
+	}
+	//send mfu
+
+	// first get sample number
+	uint32_t sequence_number;
+	uint8_t trackrefindex;
+	uint32_t samplenumber;
+	u_int32_t movie_fragment_sequence_number;
+	uint8_t priority;
+	uint8_t dependency_counter;
+	uint32_t offset;
+	uint32_t length;
+
+
+	char mulibuff[34]={};
+	stream_seek(s, -34,2);
+	    int k;
+		k=stream_tell(s);
+	stream_read(s, mulibuff, 34);
+	sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+	trackrefindex=mulibuff[4];
+	movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+	samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+	priority=mulibuff[13];
+	dependency_counter=mulibuff[14];
+	//counter start from mdat (mdat position is 0)
+	offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+	length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+	int sample_total_number;
+	sample_total_number=samplenumber+1;
+
+	for (counter=0;counter<sample_total_number;counter++)
+	{
+		//get the sample
+		uint32_t mfu_time_offset=0;
+		stream_seek(s, -34*(sample_total_number-counter),2);
+		stream_read(s, mulibuff, 34);
+
+		sequence_number=ntohl(*((u_int32_t*)&mulibuff[0]));//from 1 counter
+		trackrefindex=mulibuff[4];
+		movie_fragment_sequence_number=ntohl(*((u_int32_t*)&mulibuff[5]));//from 0 counter
+		samplenumber=ntohl(*((u_int32_t*)&mulibuff[9]));//from 0 counter
+		priority=mulibuff[13];
+		dependency_counter=mulibuff[14];
+		//counter start from mdat (mdat position is 0)
+		offset=ntohl(*((u_int32_t*)&mulibuff[15]));
+		length=ntohl(*((u_int32_t*)&mulibuff[19]));
+
+		stream_seek(s, offset+mdat_start, 0);
+
+		int sample_frag_number=0;
+		int sample_frag_counter=0;
+
+		sample_frag_number=(length+MFU_t_BUFF_LEN-1)/MFU_t_BUFF_LEN;
+
+		 for(sample_frag_counter=0;sample_frag_counter<sample_frag_number;sample_frag_counter++)
+		 {
+			 //8 byte
+			mpu_packet_header_t mpu_header;
+			unsigned char MPUh[MPUh_BUFF_LEN];
+
+			if(sample_frag_counter==(sample_frag_number-1))
+			{
+				mpu_header.length=length%MFU_t_BUFF_LEN+MFUh_t_BUFF_LEN+6;
+				if(length%MFU_t_BUFF_LEN==0)
+				{
+					mpu_header.length=MPU_BUFF_LEN+6;
+				}
+			}
+			else
+			{
+				mpu_header.length=MPU_BUFF_LEN+6;
+			}
+
+			mpu_header.FT=2;
+			mpu_header.timed_Flag=1;
+			if(sample_frag_number>1)
+			{
+				mpu_header.fragment_counter=sample_frag_number;
+				if(sample_frag_counter==0)
+					mpu_header.f_i=1;
+				else if(sample_frag_counter==(sample_frag_number-1))
+				{
+					mpu_header.f_i=3;
+				}
+				else
+				{
+					mpu_header.f_i=2;
+				}
+			}
+			else
+			{
+				mpu_header.f_i=0;
+				mpu_header.fragment_counter=1;
+			}
+			mpu_header.aggregation_flag=0;
+			mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+			init_mpu_header(&mpu_header,MPUh);
+
+			//14byte
+			mfu_time_packet_header_t mfu_time_header;
+
+			unsigned char MFUh_t[MFUh_t_BUFF_LEN];
+
+			mfu_time_header.movie_fragment_sequence_number=movie_fragment_sequence_number;
+			mfu_time_header.sample_number=counter;
+			if(sample_frag_number==1)
+			{
+				mfu_time_header.offset=0;
+			}
+			else
+			{
+				mfu_time_header.offset=mfu_time_offset;
+				mfu_time_offset=mfu_time_offset+mpu_header.length-6-MFUh_t_BUFF_LEN;
+
+
+			}
+			mfu_time_header.subsample_priority=1;
+			mfu_time_header.dependency_counter=0;
+
+			init_mfu_time_header(&mfu_time_header,MFUh_t);
+
+	//
+	//		//4byte
+	//		mfu_non_time_packet_header_t mfu_non_time_header;
+	//		unsigned char MFUh_nt[MPUh_BUFF_LEN];
+	//
+	//
+	//		//u_int32_t Item_ID;
+	//		mfu_non_time_header.Item_ID=0;
+	//		*((u_int32_t*)&MFUh_nt[0])=htonl(mfu_non_time_header.Item_ID);
+	//
+	//		mfu_non_time_header.Item_ID=ntohl(*((u_int32_t*)&MFUh_nt[0]));
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=0;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+			memcpy(&UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN],MFUh_t,MFUh_t_BUFF_LEN);
+//			int k;
+//			k=stream_tell(s);
+//			printf("stream_tell 1  %d ",k);
+			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN+MFUh_t_BUFF_LEN],mpu_header.length-6-MFUh_t_BUFF_LEN);
+//			k=stream_tell(s);
+//			printf("  %d ",k);
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+//			socklen_t len=sizeof(*to);
+//			sendto(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length,0,to,len);
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+			if(MPU_sequence_number==0 && counter ==0&& sample_frag_counter==86 )
+			{
+//				printf("breakpoint\n");
+			}
+//			printf("send MPU_sequence_number %d mfu counter%d  total sample %d +sample_frag_counter%d total sample_frag_number%d   fragment.length%d\n",MPU_sequence_number,counter,sample_total_number,sample_frag_counter,sample_frag_number,mpu_header.length-MFUh_t_BUFF_LEN);
+		 }
+//		 printf("finished send a sample total sample %d\n",sample_total_number);
+	  }
+	printf("finished send a mpu \n");
+
+
+   //ATOM BOX name like ATOM+Box_name,for example "ATOM_moof"
+   //moof=MP4_BoxSearchBox(root,ATOM_moof);
+   //MP4_BoxFree(s, moof);
+   //moof=NULL;
+   //int i;
+   //MP4_BoxSearchBox2(root,&moof,ATOM_moof);
+	//		   i=MP4_BoxSearchBox3(root,ATOM_moof);
+   free(moof);
+   MP4_BoxFree(s, root);
+
+   stream_close(s);
+   destory_file_stream(s);
+
+	 return 0;
+}
+
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id)
+{
+
+	mpu_packet_header_t mpu_header;
+	unsigned char MPUh[MPUh_BUFF_LEN];
+
+
+	mpu_header.length=6;
+	mpu_header.FT=3;
+	mpu_header.timed_Flag=0;
+
+	mpu_header.f_i=0;
+	mpu_header.fragment_counter=0;
+
+	mpu_header.aggregation_flag=0;
+	mpu_header.MPU_sequence_number=MPU_sequence_number;
+
+	init_mpu_header(&mpu_header,MPUh);
+
+	//16byte
+	mmt_packet_header_t mmt_header;
+	unsigned char MMTPh[MMTPh_BUFF_LEN];
+
+	mmt_header.version=0;
+	mmt_header.packet_counter_flag=1;
+	mmt_header.FEC_type=0;
+	mmt_header.reserved_1=0;
+	mmt_header.extension_flag=0;
+	mmt_header.RAP_flag=0;
+	mmt_header.reserved_2=0;
+	mmt_header.type=0;
+	mmt_header.packet_id=packet_id;
+	mmt_header.present_time=0;
+	mmt_header.timestamp=0;
+	mmt_header.packet_sequence_number=*packet_sequence_number;
+	mmt_header.packet_counter=(*packet_counter);
+
+	init_mmtp_header(&mmt_header,MMTPh);
+
+	char UDPbuff[UDP_BUFF_LEN]={};
+	memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+	memcpy(&UDPbuff[MMTPh_BUFF_LEN],MPUh,MPUh_BUFF_LEN);
+
+	send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+MPUh_BUFF_LEN+mpu_header.length-6,to);
+
+	if((*packet_counter)==maximum_value)
+		{
+			*packet_counter=0;
+		}
+	else
+		{
+		(*packet_counter)++;
+		}
+	if((*packet_sequence_number)==maximum_value)
+		{
+			*packet_sequence_number=0;
+		}
+	else
+		{
+		(*packet_sequence_number)++;
+		}
+ return 0;
+}
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh)
+{
+//	memset(PAh,0,PAh_BUFF_LEN );
+//7 byte
+	*((u_int16_t*)&PAh[0])=htons((u_int16_t)pa_header->message_id);
+	*((u_int8_t*)&PAh[2])=pa_header->version;
+	*((u_int32_t*)&PAh[3])=htonl(pa_header->length);
+	*((u_int8_t*)&PAh[7])=pa_header->number_of_tables;
+//	*((u_int8_t*)&MFUh_t[12])=(u_int8_t)mfu_time_header->subsample_priority;
+    return 0;
+
+}
+int read_pa_message_header(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+
+    return 0;
+}
+
+int read_pa_message(pa_message_t *pa_message,const char *pa_message_buf)
+{
+
+	pa_message->message_id=*((u_int16_t*)&pa_message_buf[0]);
+	pa_message->version=pa_message_buf[2];
+	pa_message->length=ntohl(*((u_int32_t*)&pa_message_buf[3]));
+	pa_message->number_of_tables=pa_message_buf[7];
+	pa_message->table_header= (table_header_t *)malloc(sizeof(table_header_t )*pa_message->number_of_tables);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		read_table_header(&pa_message->table_header[i] ,&pa_message_buf[PAh_BUFF_LEN+sizeof(table_header_t )*i]);
+	}
+	//point to first table
+	int buff_seek=PAh_BUFF_LEN+sizeof(table_header_t )*pa_message->number_of_tables;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			read_pa_table(&pa_message->pa_table ,&pa_message_buf[buff_seek]);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			read_mp_table(&pa_message->mp_table ,&pa_message_buf[buff_seek]);
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			read_mpi_table(&pa_message->mpi_table,&pa_message_buf[buff_seek]);
+		}
+		//point to next table
+		buff_seek=buff_seek+table_header_LEN+pa_message->table_header[i].length;
+
+	}
+    return 0;
+}
+
+int free_pa_message(pa_message_t *pa_message)
+{
+	free(pa_message->table_header);
+	int i;
+	for(i=0;i<pa_message->number_of_tables;i++)
+	{
+		//PA table
+		if(pa_message->table_header[i].table_id==0x10)
+		{
+			free_pa_table(&pa_message->pa_table);
+		}
+		//MP table
+		if(pa_message->table_header[i].table_id==0x40)
+		{
+			free_mp_table(&pa_message->mp_table );
+		}
+		//MPI table
+		if(pa_message->table_header[i].table_id==0x20)
+		{
+			free_mpi_table(&pa_message->mpi_table);
+		}
+	}
+	return 0;
+}
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf)
+{
+	memset(table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&table_buf[0])=table_header->table_id;
+	*((u_int8_t*)&table_buf[1])=table_header->version;
+	*((u_int16_t*)&table_buf[2])=htons(table_header->length);
+    return 0;
+
+}
+
+int read_table_header(table_header_t *table_header ,const char *table_buf)
+{
+
+	table_header->table_id=*((u_int8_t*)&table_buf[0]);
+	table_header->version=*((u_int8_t*)&table_buf[1]);
+	table_header->length=ntohs(*((u_int16_t*)&table_buf[2]));
+	return 0;
+
+}
+
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf)
+{
+	memset(PA_table_buf,0,1024);
+//4 byte
+	*((u_int8_t*)&PA_table_buf[0])=pa_table->table_id;
+	*((u_int8_t*)&PA_table_buf[1])=pa_table->version;
+	*((u_int16_t*)&PA_table_buf[2])=htons(pa_table->length);
+
+    return 0;
+
+}
+
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf)
+{
+
+	pa_table->table_id=*((u_int8_t*)&PA_table_buf[0]);
+	pa_table->version=*((u_int8_t*)&PA_table_buf[1]);
+	pa_table->length=ntohs(*((u_int16_t*)&PA_table_buf[2]));
+	pa_table->pat_content=(unsigned  char*) malloc(pa_table->length*sizeof( unsigned  char));
+	memcpy(pa_table->pat_content,&PA_table_buf[4],pa_table->length);
+	//pa_table->pat_content=*((char *)&PA_table_buf[4]);
+    return 0;
+
+}
+int free_pa_table(pa_table_t *pa_table )
+{
+
+	free(pa_table->pat_content);
+    return 0;
+
+}
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf)
+{
+//	memset(mp_table_buf,0,1024);
+	unsigned char *mp_table_buf_tmp= (unsigned   char*) malloc((4+mp_table->length)*sizeof( unsigned   char));
+	if(mp_table_buf_tmp==NULL)
+		{
+			puts ("Memory allocation failed.");
+			 exit (EXIT_FAILURE);
+		}
+
+	*((u_int8_t*)&mp_table_buf_tmp[0])=mp_table->table_id;
+	*((u_int8_t*)&mp_table_buf_tmp[1])=mp_table->version;
+	*((u_int16_t*)&mp_table_buf_tmp[2])=htons(mp_table->length);
+
+	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->number_of_assets;
+//	*((u_int8_t*)&mp_table_buf_tmp[4])=mp_table->MP_table_asset[0].Identifier_mapping.identifier_type;
+	u_int32_t  i,seekpoint=5;
+
+	for (i=0;i<mp_table->number_of_assets;i++)
+	{
+		memcpy(&mp_table_buf_tmp[seekpoint],"URL",strlen("URL"));
+		memcpy(&mp_table_buf_tmp[seekpoint+3],"\0",1);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+4])=mp_table->MP_table_asset[i].Identifier_mapping.URL_length;
+		memcpy(&mp_table_buf_tmp[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+		*((u_int32_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length])=htonl(mp_table->MP_table_asset[i].asset_type);
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4])=mp_table->MP_table_asset[i].asset_clock_relation_flag;
+		*((u_int8_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5])=mp_table->MP_table_asset[i].location_count;
+		*((u_int16_t*)&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6])=htons(mp_table->MP_table_asset[i].asset_descriptors_length);
+
+		memcpy(&mp_table_buf_tmp[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_byte,mp_table->MP_table_asset[i].asset_descriptors_length);
+	//	*((u_int8_t*)&mp_table_buf_tmp[3])=mp_table->Identifier_mapping->URL_length;
+		seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+	}
+	*mp_table_buf=mp_table_buf_tmp;
+ return 0;
+}
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf)
+{
+
+	mp_table->table_id=*((u_int8_t*)&mp_table_buf[0]);
+	mp_table->version=*((u_int8_t*)&mp_table_buf[1]);
+	mp_table->length=ntohs(*((u_int16_t*)&mp_table_buf[2]));
+	mp_table->number_of_assets=*((u_int8_t*)&mp_table_buf[4]);
+	mp_table->MP_table_asset= (MP_table_asset_t *)malloc(sizeof(MP_table_asset_t)*mp_table->number_of_assets);
+
+	u_int32_t  i,seekpoint=5;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			//memcpy(&mp_table_buf[seekpoint],"URL",strlen("URL"));
+			//memcpy(&mp_table_buf[seekpoint+3],"\0",1);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_length=*((u_int8_t*)&mp_table_buf[seekpoint+4]);
+			mp_table->MP_table_asset[i].Identifier_mapping.URL_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].Identifier_mapping.URL_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte,&mp_table_buf[seekpoint+5],mp_table->MP_table_asset[i].Identifier_mapping.URL_length);
+			mp_table->MP_table_asset[i].asset_type=ntohl(*((u_int32_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length]));
+			mp_table->MP_table_asset[i].asset_clock_relation_flag=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+4]);
+			mp_table->MP_table_asset[i].location_count=*((u_int8_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+5]);
+			mp_table->MP_table_asset[i].asset_descriptors_length=ntohs(*((u_int16_t*)&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+6]));
+			mp_table->MP_table_asset[i].asset_descriptors_byte=(unsigned  char*) malloc(mp_table->MP_table_asset[i].asset_descriptors_length*sizeof( unsigned  char));
+			memcpy(mp_table->MP_table_asset[i].asset_descriptors_byte,&mp_table_buf[seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8],mp_table->MP_table_asset[i].asset_descriptors_length);
+		//	*((u_int8_t*)&mp_table_buf[3])=mp_table->Identifier_mapping->URL_length;
+			seekpoint=seekpoint+5+mp_table->MP_table_asset[i].Identifier_mapping.URL_length+8+mp_table->MP_table_asset[i].asset_descriptors_length;
+
+		}
+
+
+return 0;
+}
+
+int free_mp_table(mp_table_t *mp_table )
+{
+	u_int32_t  i;
+	for (i=0;i<mp_table->number_of_assets;i++)
+		{
+			free(mp_table->MP_table_asset[i].Identifier_mapping.URL_byte);
+			free(mp_table->MP_table_asset[i].asset_descriptors_byte);
+		}
+	free(mp_table->MP_table_asset);
+	return 0;
+
+}
+
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf)
+{
+//	memset(mpi_table_buf1,0,1024);
+
+	unsigned char *mpi_table_buf_tmp= (unsigned   char*) malloc((4+mpi_table->length)*sizeof( unsigned   char));
+	 if(mpi_table_buf_tmp==NULL)
+	 		{
+	 			puts ("Memory allocation failed.");
+	 			 exit (EXIT_FAILURE);
+	 		}
+
+	*((u_int8_t*)&mpi_table_buf_tmp[0])=mpi_table->table_id;
+	*((u_int8_t*)&mpi_table_buf_tmp[1])=mpi_table->version;
+	*((u_int16_t*)&mpi_table_buf_tmp[2])=htons(mpi_table->length);
+
+	*((u_int16_t*)&mpi_table_buf_tmp[4])=htons(mpi_table->PI_mode);
+
+	u_int32_t  i,seekpoint=6;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint])=(u_int8_t)(i+1);
+		*((u_int8_t*)&mpi_table_buf_tmp[seekpoint+1])=mpi_table->PI_content[i].PI_content_name_length;
+//		memcpy(&mpi_table_buf_tmp[seekpoint+1] , mpi_table->PI_content[i].PI_content_name_length , 1);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_byte , mpi_table->PI_content[i].PI_content_name_length);
+		*((u_int16_t*)&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length])=htons(mpi_table->PI_content[i].PI_content_length);
+//		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length] , mpi_table->PI_content[i].PI_content_length , 2);
+		memcpy(&mpi_table_buf_tmp[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_byte , mpi_table->PI_content[i].PI_content_length);
+		seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+	}
+//	printf("seekpoint%d\n",seekpoint);
+//	printf("seek%s\n",mpi_table_buf_tmp);
+//	printf("seek%c\n",mpi_table_buf_tmp[8]);
+
+
+
+//	pseudogram = malloc(psize);
+//	memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+//	memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+	*mpi_table_buf=mpi_table_buf_tmp;
+//	int j;
+//	for(j=0;j<mpi_table->length+4;j++)
+//		{
+//			printf("%c",*mpi_table_buf_tmp++);
+//		}
+//	printf("\n");
+ return 0;
+}
+
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
+{
+		mpi_table->table_id=*((u_int8_t*)&mpi_table_buf[0]);
+		mpi_table->version=*((u_int8_t*)&mpi_table_buf[1]);
+		mpi_table->length=htons(*((u_int16_t*)&mpi_table_buf[2]));
+
+		mpi_table->PI_mode=htons(*((u_int16_t*)&mpi_table_buf[4]));
+		//temp var
+		mpi_table->PI_content_count=2;
+		mpi_table->PI_content= (PI_content_t *)malloc(sizeof(PI_content_t )*mpi_table->PI_content_count);
+		u_int32_t  i,seekpoint=6;
+
+		for (i=0;i<mpi_table->PI_content_count;i++)
+		{
+			//*((u_int8_t*)&mpi_table_buf[seekpoint])=(u_int8_t)(i+1);
+			mpi_table->PI_content[i].PI_content_name_length=*((u_int8_t*)&mpi_table_buf[seekpoint+1]);
+			mpi_table->PI_content[i].PI_content_name_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_name_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_name_byte,0,(mpi_table->PI_content[i].PI_content_name_length+1));
+//			printf("mpi_table->PI_content[i].PI_content_name_length%d\n",mpi_table->PI_content[i].PI_content_name_length);
+			memcpy(mpi_table->PI_content[i].PI_content_name_byte , &mpi_table_buf[seekpoint+2] , mpi_table->PI_content[i].PI_content_name_length);
+			mpi_table->PI_content[i].PI_content_length=htons(*((u_int16_t*)&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length]));
+			mpi_table->PI_content[i].PI_content_byte=(unsigned  char*) malloc((mpi_table->PI_content[i].PI_content_length+1)*sizeof( unsigned  char));
+			memset(mpi_table->PI_content[i].PI_content_byte,0,(mpi_table->PI_content[i].PI_content_length+1));
+			memcpy( mpi_table->PI_content[i].PI_content_byte ,&mpi_table_buf[seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2] , mpi_table->PI_content[i].PI_content_length);
+			seekpoint=seekpoint+2+mpi_table->PI_content[i].PI_content_name_length+2+mpi_table->PI_content[i].PI_content_length;
+
+
+			FILE *mpi;
+			if((mpi=fopen((char *)mpi_table->PI_content[i].PI_content_name_byte,"w+"))==NULL)
+					{
+						printf("not open");
+						exit(0);
+					}
+			fwrite(mpi_table->PI_content[i].PI_content_byte,mpi_table->PI_content[i].PI_content_length,1,mpi);
+			fclose(mpi);
+		}
+	 return 0;
+
+}
+
+int free_mpi_table(mpi_table_t *mpi_table)
+{
+	u_int32_t  i;
+
+	for (i=0;i<mpi_table->PI_content_count;i++)
+	{
+		free(mpi_table->PI_content[i].PI_content_name_byte);
+		free(mpi_table->PI_content[i].PI_content_byte);
+
+	}
+	free(mpi_table->PI_content);
+	return 0;
+}
+int init_signal_header(signal_header_t *signal_header,unsigned char *Signal_h)
+
+{
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->res<<2
+								|(u_int8_t) signal_header->H<<1
+								|(u_int8_t) signal_header->A;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+int read_signal_header(signal_header_t *signal_header,const char *Signal_h)
+
+{
+	signal_header->f_i=(Signal_h[0]>>6)&0x03;
+	signal_header->res=(Signal_h[0]>>2)&0x0f;
+	signal_header->H=(Signal_h[0]>>1)&0x01;
+	signal_header->A=(Signal_h[0])&0x01;
+	signal_header->frag_counter=Signal_h[1];
+	signal_header->MSG_length1=ntohs(*((u_int16_t*)&Signal_h[2]));
+
+
+	*((u_int8_t*)&Signal_h[0])=(u_int8_t)signal_header->f_i<<6
+								|(u_int8_t) signal_header->H<<2
+								|(u_int8_t) signal_header->A<<1;
+	*((u_int8_t*)&Signal_h[1])=signal_header->frag_counter;
+	*((u_int16_t*)&Signal_h[2])=htons(signal_header->MSG_length1);
+
+
+	return 0;
+
+}
+
+
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id)
+{
+		int pa_sequence_number=(pa_header->length+4+MMTP_BUFF_LEN-1)/(unsigned int)MMTP_BUFF_LEN;;
+		int pa_length=pa_header->length+PAh_BUFF_LEN;
+		u_int32_t buf_seekpoint=0;
+
+		int counter;
+		for (counter=0;counter<pa_sequence_number;counter++)
+		{
+			signal_header_t signal_header;
+			if(counter==(pa_sequence_number-1))
+			{
+				signal_header.MSG_length1=pa_length%signal_BUFF_LEN;
+				//
+				if(pa_length%MMTP_BUFF_LEN==0)
+					{
+					signal_header.MSG_length1=signal_BUFF_LEN;
+					}
+			}
+			else
+			{
+				signal_header.MSG_length1=signal_BUFF_LEN;
+			}
+			signal_header.f_i=0;
+			signal_header.res=0;
+			signal_header.H=0;
+			signal_header.A=0;
+			signal_header.frag_counter=0;
+
+			if(pa_sequence_number>1)
+			{	signal_header.frag_counter=pa_sequence_number;
+				if(counter==0)
+					signal_header.f_i=1;
+				else if(counter==(pa_sequence_number-1))
+				{
+					signal_header.f_i=3;
+				}
+				else
+				{
+					signal_header.f_i=2;
+				}
+			}
+			else
+			{
+				signal_header.f_i=0;
+				signal_header.frag_counter=1;
+			}
+			signal_header.A=0;
+
+			unsigned char Signal_h[Signal_h_BUFF_LEN]={};
+			init_signal_header(&signal_header,Signal_h);
+
+
+			//16byte
+			mmt_packet_header_t mmt_header;
+			unsigned char MMTPh[MMTPh_BUFF_LEN];
+			mmt_header.version=0;
+			mmt_header.packet_counter_flag=1;
+			mmt_header.FEC_type=0;
+			mmt_header.reserved_1=0;
+			mmt_header.extension_flag=0;
+			mmt_header.RAP_flag=0;
+			mmt_header.reserved_2=0;
+			mmt_header.type=2;
+			mmt_header.packet_id=packet_id;
+			mmt_header.present_time=0;
+			mmt_header.timestamp=get_send_timestamp();
+			mmt_header.packet_sequence_number=*packet_sequence_number;
+			mmt_header.packet_counter=(*packet_counter);
+
+			init_mmtp_header(&mmt_header,MMTPh);
+
+			char UDPbuff[UDP_BUFF_LEN]={};
+
+			memcpy(UDPbuff,MMTPh,MMTPh_BUFF_LEN);
+			//diyige jia tou
+			if (signal_header.f_i==1)
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+			}
+			else
+			{
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN],Signal_h,Signal_h_BUFF_LEN);
+				memcpy(&UDPbuff[MMTPh_BUFF_LEN+Signal_h_BUFF_LEN],&pa_message_buf[buf_seekpoint],signal_header.MSG_length1);
+
+			}
+			buf_seekpoint=buf_seekpoint+signal_header.MSG_length1;
+//			stream_read(s, &UDPbuff[MMTPh_BUFF_LEN+MPUh_BUFF_LEN], mpu_header.length);
+
+			send_udp(ss,UDPbuff,MMTPh_BUFF_LEN+Signal_h_BUFF_LEN+signal_header.MSG_length1,to);
+
+			if((*packet_counter)==maximum_value)
+				{
+					*packet_counter=0;
+				}
+			else
+				{
+				(*packet_counter)++;
+				}
+			if((*packet_sequence_number)==maximum_value)
+				{
+					*packet_sequence_number=0;
+				}
+			else
+				{
+				(*packet_sequence_number)++;
+				}
+		}
+		printf("finished send signal\n");
+return 0;
+
+}
+
+
+
+
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to)
+
+{
+
+	int n;
+	struct timeval udp_delay;
+	udp_delay.tv_sec = 0;
+	udp_delay.tv_usec = 50; // 50 us
+	select(0, NULL, NULL, NULL, &udp_delay);
+//	printf("tmp%s/n",*tmp[1]);
+	socklen_t len=sizeof(*to);
+	n=sendto(ss,UDPbuff,length,0,to,len);
+	if(n <=0)
+	{
+		perror("send error");
+		puts ("send error");
+		exit (EXIT_FAILURE);
+		return -1;
+	}
+
+//	send_raw_udp(UDPbuff,length);
+	return 0;
+}
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf )
+//{
+//	free(mfu_buf->data);
+//	return 0;
+//}
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf )
+{
+	free(mpu_metadata_buf.data);
+	return 0;
+}
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf )
+{
+	free(fragment_metadata_buf.data);
+	return 0;
+}
+int free_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	free_mpu_metadata_buf(mpu_buf->mpu_metadata_buf);
+	free_fragment_metadata_buf(mpu_buf->fragment_metadata_buf);
+	int i;
+	for(i=0;i<mpu_buf->mfu_number;i++)
+	{
+		free(mpu_buf->mfu[i].data);
+	}
+	free(mpu_buf->mfu);
+	free(mpu_buf->mfu_sample);
+	free(mpu_buf->MPU_sequence_data);
+	return 0;
+}
+int init_mpu_buf(mpu_buf_t *mpu_buf )
+{
+	mpu_buf->packet_id=0;
+	mpu_buf->MPU_sequence_number=0;
+	mpu_buf->flag=0;
+	mpu_buf->mfu_number=0;
+	mpu_buf->mfu_counter=0;
+	mpu_buf->MPU_sequence_length=0;
+	return 0;
+}
diff --git a/net/mmt/mmtp/mmt.h b/net/mmt/mmtp/mmt.h
new file mode 100644
index 0000000..3ecd828
--- /dev/null
+++ b/net/mmt/mmtp/mmt.h
@@ -0,0 +1,464 @@
+#ifndef NET_MMT_MMTP_MMT_H_
+#define NET_MMT_MMTP_MMT_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "DList.h"
+
+#define MP4_FOURCC( a, b, c, d ) \
+   ( ((uint32_t)a) | ( ((uint32_t)b) << 8 ) \
+   | ( ((uint32_t)c) << 16 ) | ( ((uint32_t)d) << 24 ) )
+
+
+//#define eth_BUFF_LEN 1500
+//
+//#define IPh_BUFF_LEN 20
+//#define IP_BUFF_LEN 1480
+//
+//#define UDPh_BUFF_LEN 8
+//#define UDP_BUFF_LEN 1472
+//
+//#define MMTPh_BUFF_LEN 20
+//#define MMTP_BUFF_LEN 1452
+//
+//#define signalh_BUFF_LEN 4
+//#define signal_BUFF_LEN 1448
+//#define MPUh_BUFF_LEN 8
+//#define MPU_BUFF_LEN 1444
+//#define MFUh_t_BUFF_LEN 14
+//#define MFU_t_BUFF_LEN 1430
+//#define MFUh_nt_BUFF_LEN 4
+//#define MFU_nt_BUFF_LEN 1440
+//#define maximum_value 4294967295
+//#define SMTh_BUFF_LEN 10
+//
+//#define PAh_BUFF_LEN 7
+//#define PAth_BUFF_LEN 4
+//#define th_BUFF_LEN 4
+//#define Signal_h_BUFF_LEN 4
+//
+//#define table_header_LEN 4
+//#define PA_message_header_LEN 7
+
+#define eth_BUFF_LEN 1500
+
+#define IPh_BUFF_LEN 20
+#define IP_BUFF_LEN 1480
+
+#define UDPh_BUFF_LEN 8
+#define UDP_BUFF_LEN 1500
+
+#define MMTPh_BUFF_LEN 20
+#define MMTP_BUFF_LEN 1480
+
+#define signalh_BUFF_LEN 4
+#define signal_BUFF_LEN 1476
+#define MPUh_BUFF_LEN 8
+#define MPU_BUFF_LEN 1472
+#define MFUh_t_BUFF_LEN 14
+#define MFU_t_BUFF_LEN 1458
+#define MFUh_nt_BUFF_LEN 4
+#define MFU_nt_BUFF_LEN 1428
+#define maximum_value 4294967295
+#define SMTh_BUFF_LEN 10
+
+#define PAh_BUFF_LEN 8
+#define PAth_BUFF_LEN 4
+#define th_BUFF_LEN 4
+#define Signal_h_BUFF_LEN 4
+
+#define table_header_LEN 4
+
+
+typedef struct MMT_config //16Byte
+{
+	char *video_dir;
+	char **video_List;
+	//char **video_Fullpath;
+	int32_t video_id;
+	u_int32_t videoCount;
+
+	char *audio_dir;
+	char **audio_List;
+	//char **audio_Fullpath;
+	u_int32_t audioCount;
+	int32_t audio_id;
+
+	char *ci_dir;
+	int32_t ci_id;
+	char *to_addr;
+	int16_t to_port;
+
+//samsung
+	int32_t session_num;
+	char *mode;
+	int16_t listen_port;
+	char *multicast_ip;
+	int16_t multicast_port;
+	int32_t time_delay;
+	char *broadband_root;
+	char *broadcast_root;
+	int32_t fec ;
+	int32_t qos ;
+	char *log_path;
+	char *controller;
+	int32_t max_client_num;
+	char *res_map_file;
+	char *broadcast_default_ci;
+	char *broadcast_default_html;
+	int16_t multiview_port;
+
+}mmt_config_t;
+
+typedef struct MPU_metadata_s //Byte
+{
+	 u_int32_t start;
+	 u_int32_t length;
+	 u_int32_t number;
+}mpu_metadata_t;
+
+typedef struct Fragment_metadata_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}fragment_metadata_t;
+
+typedef struct MFU_s //Byte
+{
+
+    u_int32_t start;
+    u_int32_t length;
+    u_int32_t number;
+
+}mfu_t;
+
+typedef struct MMT_packet_header_s //16Byte
+{
+    u_int8_t version:2;
+    u_int8_t packet_counter_flag:1;
+    u_int8_t FEC_type:2;
+    u_int8_t reserved_1:1;
+    u_int8_t extension_flag:1;
+    u_int8_t RAP_flag:1;
+    u_int8_t reserved_2:2;
+    u_int8_t type:6;
+    u_int16_t packet_id;
+    u_int32_t present_time;
+    u_int32_t timestamp;
+    u_int32_t packet_sequence_number;
+    u_int32_t packet_counter;
+}mmt_packet_header_t,*pmmt_packet_header_t;
+
+typedef struct MMT_packet_header_extension_header_s//4Byte
+{
+	u_int16_t type;
+	u_int16_t length;
+    //no header extension
+    //no FEC
+}mmt_packet_header_extension_header_t,*pmmt_packet_header_extension_header_t;
+
+
+typedef struct MPU_packet_header_s //8Byte
+{
+
+	u_int16_t length;
+	u_int8_t FT:4;//mpu_fragment_type
+	u_int8_t timed_Flag:1;
+	u_int8_t f_i:2;//fragmentation_indicator
+	u_int8_t aggregation_flag:1;
+	u_int8_t fragment_counter;
+	u_int32_t MPU_sequence_number;
+    //no MFU
+    //for non-time
+
+}mpu_packet_header_t,*pmpu_packet_header_t;
+
+typedef struct MFU_time_packet_header_s //14Byte
+{
+	u_int32_t movie_fragment_sequence_number;
+	u_int32_t sample_number;
+	u_int32_t offset;
+	u_int8_t subsample_priority;
+	u_int8_t dependency_counter;
+    //for time
+}mfu_time_packet_header_t,*pmfu_time_packet_header_t;
+
+typedef struct MFU_non_time_packet_header_s //4Byte
+{
+	u_int32_t Item_ID;
+    //for time
+}mfu_non_time_packet_header_t,*pmfu_non_time_packet_header_t;
+
+typedef struct SMT_packet_header_s //4Byte
+{
+	u_int16_t SPS;
+	u_int8_t SDC;
+	u_int16_t LEN;
+	u_int16_t TCH;
+	u_int16_t RSV1;
+	u_int8_t RSV2;
+    //for time
+}smt_packet_header_t;
+
+typedef struct signal_header_s //4Byte
+{
+	u_int8_t f_i:2;
+	u_int8_t res:4;
+	u_int8_t H:1;
+	u_int8_t A:1;
+	u_int8_t frag_counter;
+	u_int16_t MSG_length1;
+	u_int32_t MSG_length2;
+
+    //for time
+}signal_header_t;
+
+typedef struct table_header_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+}table_header_t;
+
+
+typedef struct Identifier_mapping_s //4Byte
+{
+	u_int8_t identifier_type;
+	u_int8_t URL_length;
+	unsigned  char *URL_byte;
+
+
+}Identifier_mapping_t;
+
+typedef struct pa_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	unsigned char *pat_content;
+}pa_table_t;
+
+
+
+typedef struct MP_table_asset_s
+{
+	Identifier_mapping_t Identifier_mapping;
+	u_int32_t asset_type;
+	u_int8_t asset_clock_relation_flag;
+	u_int8_t location_count;
+	u_int16_t asset_descriptors_length;
+	unsigned char *asset_descriptors_byte;
+}MP_table_asset_t;
+
+typedef struct mp_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	u_int8_t number_of_assets;
+	MP_table_asset_t *MP_table_asset;
+}mp_table_t;
+
+
+typedef struct PI_content_s //4Byte
+{
+//	u_int8_t PI_content_type_length;
+//	char * PI_content_type_length_byte;
+	//yes
+	u_int8_t PI_content_name_length;
+	unsigned char * PI_content_name_byte;
+	//no use
+//	u_int8_t PI_content_descriptors_length;
+//	char * PI_content_descriptors_byte;
+	//yes
+	u_int16_t PI_content_length;
+	unsigned char * PI_content_byte;
+}PI_content_t,*pPI_content_t;
+
+typedef struct mpi_table_s //4Byte
+{
+	u_int8_t table_id;
+	u_int8_t version;
+	u_int16_t length;
+	//bu dui
+//	u_int8_t PI_mode:2;
+	u_int16_t PI_mode;
+	//use wrong
+	u_int8_t PI_content_count;
+	PI_content_t *PI_content;
+}mpi_table_t;
+
+//client
+
+typedef struct pa_message_s //8Byte
+{
+	u_int16_t message_id;
+	u_int8_t version;
+	u_int32_t length;// new version
+	u_int8_t number_of_tables;
+	table_header_t *table_header;
+	pa_table_t pa_table ;
+	mp_table_t mp_table;
+	mpi_table_t mpi_table;
+}pa_message_t;
+
+typedef struct signal_buf_s //4Byte
+{
+
+	char * buf_pool;
+	char * block_fill_flag;
+	u_int32_t block_number;
+	u_int8_t buff_status; 
+	u_int16_t packet_id; 
+}signal_buf_t,*psignal_buf_t;
+
+typedef struct mfu_buf_s //30Byte
+{
+	unsigned  char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mfu_buf_t,*pmfu_buf_t;
+
+// first get sample number
+typedef struct mfu_sample_s //30Byte
+{
+u_int32_t sequence_number;
+u_int8_t trackrefindex;
+u_int32_t movie_fragment_sequence_number;
+u_int32_t sample_number;
+u_int8_t priority;
+u_int8_t dependency_counter;
+u_int32_t offset;
+u_int32_t length;
+u_int32_t muli_length;
+u_int32_t muli_name;
+u_int16_t muli_reserved1;
+u_int8_t muli_reserved2;
+
+}mfu_sample_t,*pmfu_sample_t;
+
+typedef struct mpu_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}mpu_metadata_buf_t,*pmpu_metadata_buf_t;
+
+typedef struct fragment_metadata_buf_s //30Byte
+{
+	unsigned char *data;
+	u_int8_t flag ;
+	u_int32_t length;
+	u_int32_t number;
+	u_int32_t counter;
+
+}fragment_metadata_buf_t,*pfragment_metadata_buf_t;
+
+typedef struct mpu_buf_s //
+{
+	u_int16_t packet_id; 
+	u_int32_t MPU_sequence_number; 
+
+	mpu_metadata_buf_t  mpu_metadata_buf;
+	fragment_metadata_buf_t fragment_metadata_buf;
+
+	u_int8_t flag ;
+	u_int32_t mfu_number;
+	u_int32_t mfu_counter;
+	mfu_buf_t *mfu;
+	mfu_sample_t *mfu_sample;
+	u_int32_t MPU_sequence_length;
+	unsigned char * MPU_sequence_data;
+}mpu_buf_t,*pmpu_buf_t;
+
+
+//typedef struct mpu_s //
+//{
+//
+//	char * buf_pool;
+//	char *buf_pool_end; // end of data buffer
+//	char * block_fill_flag;
+//	u_int32_t capacity;// maximum number of items in the buffer
+//	u_int32_t count;// number of items in the buffer
+//	u_int32_t block_size;// size of each item in the buffer
+//	u_int8_t buff_status;
+//	u_int16_t packet_id;
+//	u_int32_t MPU_sequence_number;
+//	DList *mpu_metadata;
+//	DList *fragmen_metadata;
+//	DList *mfu;
+//}mpu_t,*pmpu_t;
+
+
+
+int get_MMT_timestamp();
+int init_mmtp_header(mmt_packet_header_t *mmt_header,unsigned char *MMTPh);
+int read_mmtp_header(mmt_packet_header_t *mmt_header,const char *MMTPh);
+int init_mpu_header(mpu_packet_header_t *mpu_header,unsigned char *MPUh);
+int read_mpu_header(mpu_packet_header_t *mpu_header,const char *MPUh);
+int init_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,unsigned char *MFUh_t);
+int read_mfu_time_header(mfu_time_packet_header_t *mfu_time_header,const char *MFUh_t);
+int init_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,unsigned char *MFUh_nt);
+int read_mfu_non_time_header(mfu_non_time_packet_header_t *mfu_non_time_header,const char *MFUh_nt);
+int init_mfu_sample(mfu_sample_t *mfu_sample,unsigned char *mfu_sample_buf);
+int read_mfu_sample(mfu_sample_t *mfu_sample,const char *mfu_sample_buf);
+
+int init_smt_header(smt_packet_header_t *smt_header,unsigned char *SMTh);
+int read_smt_header(smt_packet_header_t *smt_header,const char *SMTh);
+
+int init_signal_header(signal_header_t *signal_header,unsigned char *signal_h);
+int read_signal_header(signal_header_t *signal_header,const char *signal_h);
+
+int init_pa_message(pa_message_t *pa_header,unsigned char *PAh);
+int read_pa_message_header(pa_message_t *pa_header,const char *PAh);
+int read_pa_message(pa_message_t *pa_header,const char *PAh);
+int free_pa_message(pa_message_t *pa_header);
+
+int init_table_header(table_header_t *table_header ,unsigned char *table_buf);
+int read_table_header(table_header_t *table_header ,const char *table_buf);
+
+int init_pa_table(pa_table_t *pa_table ,unsigned char *PA_table_buf);
+int read_pa_table(pa_table_t *pa_table ,const char *PA_table_buf);
+int free_pa_table(pa_table_t *pa_table);
+
+int init_mp_table(mp_table_t *mp_table, unsigned char **mp_table_buf);
+int read_mp_table(mp_table_t *mp_table ,const char *mp_table_buf);
+int free_mp_table(mp_table_t *mp_table );
+
+int init_mpi_table(mpi_table_t *mpi_table, unsigned char **mpi_table_buf);
+int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf);
+int free_mpi_table(mpi_table_t *mpi_table);
+
+int send_mpu(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_mpu_endpacket(int ss,struct sockaddr*to,char *Fullpath,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t MPU_sequence_number,u_int32_t *MPU_present_time,u_int32_t packet_id);
+int send_signal(int ss,struct sockaddr*to,pa_message_t *pa_header,unsigned char *pa_message_buf,u_int32_t *packet_sequence_number,u_int32_t *packet_counter,u_int32_t packet_id);
+int send_udp(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+int get_bytes(unsigned char *srcbuff,unsigned char **dstbuff, u_int32_t number);
+
+
+//int free_mfu_buf(mfu_buf_t *mfu_buf );
+int free_mpu_metadata_buf(mpu_metadata_buf_t mpu_metadata_buf );
+int free_fragment_metadata_buf(fragment_metadata_buf_t fragment_metadata_buf );
+int free_mpu_buf(mpu_buf_t *mpu_buf );
+int init_mpu_buf(mpu_buf_t *mpu_buf );
+
+#endif
diff --git a/net/mmt/mmtp/mmtp.gyp b/net/mmt/mmtp/mmtp.gyp
new file mode 100644
index 0000000..7c2bc3f
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.gyp
@@ -0,0 +1,93 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libmmtp',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'mmtp',
+      'sources': [
+        'DList.c',
+        'Mlist.c',
+        'client.c',
+        'getfile.c',
+        'ini.c',
+        'mmt.c',
+        'ringq.c',  
+        'send.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '-lm',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
new file mode 100644
index 0000000..00c02cb
--- /dev/null
+++ b/net/mmt/mmtp/mmtp.h
@@ -0,0 +1,64 @@
+#ifndef NET_MMT_MMTP_MMTP_H_
+#define NET_MMT_MMTP_MMTP_H_
+
+#include "mmt.h"
+
+#if 0
+//
+pthread_mutex_t mpu_mutex;							/**/
+pthread_mutex_t signal_mutex;						/**/
+pthread_mutex_t mpu_list_mutex;						/**/
+
+pthread_t signal_consumer_t;						/**/
+pthread_t mpu_consumer_t;						/**/
+pthread_t producter_t;						/**/
+
+DList *signal_buff_list;
+DList *mpu_buff_list;
+
+int signal_buffer_has_item=0;							/**/
+int mpu_buffer_has_item=0;							/**/
+
+//mpu_buf_t,mpu
+mpu_buf_t *mpu_list;
+
+//
+int mmt_socket;
+#endif
+
+//IP,,,
+int InitMMTP(char *listen_ip, int16_t listen_port);
+
+//MPU,packet_idmpu_sequence_number,packet_idasset
+//MPU,,
+int AddMpu(mpu_buf_t *mpu_list);
+
+//MPU
+int RefreshMpu(mpu_buf_t *mpu_list);
+
+//,IP,
+int UninitMMTP();
+
+
+typedef void (*message_callback_func_t)(pa_message_t *pa_message);
+//,,pa_message
+void SetMessageCallback(message_callback_func_t func,pa_message_t *pa_message);
+
+//
+void Message_func(pa_message_t *pa_message);
+
+
+typedef void (*mpu_callback_func_t)(mpu_buf_t *mpu_buf);
+//MPU,,MPU
+void SetCICallback(mpu_callback_func_t func,mpu_buf_t *mpu_buf);
+
+//
+void Mpu_func(mpu_buf_t *mpu_buf);
+
+//,,,
+int QueryMessageResource(char* mmt_url, char* ci_fname,  int size);
+
+//,MPU,,mpu_buf_t,mpu_list
+int QueryMPUResource(mpu_buf_t *mpu_list, u_int32_t sequence,  u_int32_t packet_id);
+
+#endif
diff --git a/net/mmt/mmtp/ringq.c b/net/mmt/mmtp/ringq.c
new file mode 100644
index 0000000..8eca6b2
--- /dev/null
+++ b/net/mmt/mmtp/ringq.c
@@ -0,0 +1,112 @@
+#include <stdio.h>
+#include "ringq.h"
+#include <stdlib.h>
+#include <string.h>
+
+int ringq_init(RINGQ * p_queue)
+{
+   p_queue->size = QUEUE_MAX ;
+   
+   p_queue->head = 0;
+   p_queue->tail = 0;
+   
+   p_queue->tag = 0;
+   
+   return 0;
+}
+
+int ringq_free(RINGQ * p_queue)
+{
+  return 0;
+}
+
+
+int ringq_push(RINGQ * p_queue,int data)
+{
+//  print_ringq(p_queue);
+  
+  if(ringq_is_full(p_queue))
+   {
+     
+     printf("ringq is full\n");
+     return -1;
+   }
+      
+   p_queue->space[p_queue->tail] = data;
+   
+   p_queue->tail = (p_queue->tail + 1) % p_queue->size ;
+   
+   /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 1;
+    }
+
+    return p_queue->tag ;  
+}
+
+int ringq_poll(RINGQ * p_queue,int * p_data)
+{
+//   print_ringq(p_queue);
+  if(ringq_is_empty(p_queue))
+   {
+      
+      printf("ringq is empty\n");
+     return -1;
+   }
+   
+   *p_data = p_queue->space[p_queue->head];
+   
+   p_queue->head = (p_queue->head + 1) % p_queue->size ;
+   
+    /* */
+   if(p_queue->tail == p_queue->head)
+    {
+       p_queue->tag = 0;
+    }    
+    return p_queue->tag ;
+}
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+
+
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz)
+{
+    cb->buffer = malloc(capacity * sz);
+    if(cb->buffer == NULL)
+        // handle error
+    cb->buffer_end = (char *)cb->buffer + capacity * sz;
+    cb->capacity = capacity;
+    cb->count = 0;
+    cb->sz = sz;
+    cb->head = cb->buffer;
+    cb->tail = cb->buffer;
+}
+
+void cb_free(circular_buffer *cb)
+{
+    free(cb->buffer);
+    // clear out other fields too, just to be safe
+}
+
+void cb_push_back(circular_buffer *cb, const void *item)
+{
+    if(cb->count == cb->capacity)
+        // handle error
+    memcpy(cb->head, item, cb->sz);
+    cb->head = (char*)cb->head + cb->sz;
+    if(cb->head == cb->buffer_end)
+        cb->head = cb->buffer;
+    cb->count++;
+}
+
+void cb_pop_front(circular_buffer *cb, void *item)
+{
+    if(cb->count == 0)
+        // handle error
+    memcpy(item, cb->tail, cb->sz);
+    cb->tail = (char*)cb->tail + cb->sz;
+    if(cb->tail == cb->buffer_end)
+        cb->tail = cb->buffer;
+    cb->count--;
+}
diff --git a/net/mmt/mmtp/ringq.h b/net/mmt/mmtp/ringq.h
new file mode 100644
index 0000000..f6241c9
--- /dev/null
+++ b/net/mmt/mmtp/ringq.h
@@ -0,0 +1,65 @@
+#ifndef NET_MMT_MMTP_RINGQ_H_
+#define NET_MMT_MMTP_RINGQ_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif 
+
+#define QUEUE_MAX 1500
+/*
+
+http://blog.csdn.net/sking002007/article/details/6584590
+
+*/
+typedef struct ringq{
+   int head; /* */
+   int tail; /* */ 
+   int tag ; /* */
+    int size ; /*  */
+   int space[QUEUE_MAX]; /*  */
+}RINGQ;
+
+/* 
+  :
+     head == tail tag = 0  = 1 
+*/
+
+extern int ringq_init(RINGQ * p_queue);
+
+extern int ringq_free(RINGQ * p_queue);
+
+
+/*  */
+extern int ringq_push(RINGQ * p_queue,int data);
+
+/*  */
+extern int ringq_poll(RINGQ * p_queue,int *p_data);
+
+
+#define ringq_is_empty(q) ( (q->head == q->tail) && (q->tag == 0))
+
+#define ringq_is_full(q) ( (q->head == q->tail) && (q->tag == 1))
+
+#define print_ringq(q) printf("ring head %d,tail %d,tag %d\n", q->head,q->tail,q->tag);
+#ifdef __cplusplus
+}
+#endif 
+
+
+//http://stackoverflow.com/questions/827691/how-do-you-implement-a-circular-buffer-in-c/1771607#1771607
+typedef struct circular_buffer
+{
+    void *buffer;     // data buffer
+    void *buffer_end; // end of data buffer
+    size_t capacity;  // maximum number of items in the buffer
+    size_t count;     // number of items in the buffer
+    size_t sz;        // size of each item in the buffer
+    void *head;       // pointer to head
+    void *tail;       // pointer to tail
+} circular_buffer;
+void cb_init(circular_buffer *cb, size_t capacity, size_t sz);
+void cb_free(circular_buffer *cb);
+void cb_push_back(circular_buffer *cb, const void *item);
+void cb_pop_front(circular_buffer *cb, void *item);
+
+#endif
diff --git a/net/mmt/mmtp/send.c b/net/mmt/mmtp/send.c
new file mode 100644
index 0000000..7a783d0
--- /dev/null
+++ b/net/mmt/mmtp/send.c
@@ -0,0 +1,199 @@
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+#include "send.h"
+#include <arpa/inet.h>
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <endian.h>//just for little endian
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <mcheck.h>
+#include <time.h>
+#include "mmt.h"
+/*
+    Generic checksum calculation function
+*/
+unsigned short csum(unsigned short *ptr,int nbytes)
+{
+    register long sum;
+    unsigned short oddbyte;
+    register short answer;
+
+    sum=0;
+    while(nbytes>1) {
+        sum+=*ptr++;
+        nbytes-=2;
+    }
+    if(nbytes==1) {
+        oddbyte=0;
+        *((u_char*)&oddbyte)=*(u_char*)ptr;
+        sum+=oddbyte;
+    }
+
+    sum = (sum>>16)+(sum & 0xffff);
+    sum = sum + (sum>>16);
+    answer=(short)~sum;
+
+    return(answer);
+}
+
+int send_raw_udp(char *UDPbuff,int length)
+{
+    //Create a raw socket of type IPPROTO
+    int s = socket (AF_INET, SOCK_RAW, IPPROTO_RAW);
+
+    if(s == -1)
+    {
+        //socket creation failed, may be because of non-root privileges
+        perror("Failed to create raw socket");
+        exit(1);
+    }
+
+    //Datagram to represent the packet
+    char datagram[4096] , source_ip[32] , *data , *pseudogram;
+
+    //zero out the packet buffer
+    memset (datagram, 0, 4096);
+
+    //IP header
+    struct iphdr *iph = (struct iphdr *) datagram;
+
+    //UDP header
+    struct udphdr *udph = (struct udphdr *) (datagram + sizeof (struct ip));
+
+    struct sockaddr_in sin;
+    struct pseudo_header psh;
+
+    //Data part
+
+
+
+    memcpy(&datagram[sizeof(struct iphdr) + sizeof(struct udphdr)],UDPbuff,length);
+    data = &datagram[sizeof(struct iphdr) + sizeof(struct udphdr)];
+    //some address resolution
+    strcpy(source_ip , "172.16.7.44");
+
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons(80);
+    sin.sin_addr.s_addr = inet_addr ("224.1.1.100");
+
+    //Fill in the IP Header
+    iph->ihl = 5;
+    iph->version = 4;
+    iph->tos = 0;
+    iph->tot_len = sizeof (struct iphdr) + sizeof (struct udphdr) + length;
+    iph->id = htonl (54321); //Id of this packet
+    iph->frag_off = 0;
+    iph->ttl = 1;
+    iph->protocol = IPPROTO_UDP;
+    iph->check = 0;      //Set to 0 before calculating checksum
+    iph->saddr = inet_addr ( source_ip );    //Spoof the source ip address
+    iph->daddr = sin.sin_addr.s_addr;
+
+    //Ip checksum
+    iph->check = csum ((unsigned short *) datagram, sizeof (struct iphdr));
+
+    //UDP header
+    udph->source = htons (6666);
+    udph->dest = htons (6080);
+    udph->len = htons(8 + length); //tcp header size
+    udph->check = 0; //leave checksum 0 now, filled later by pseudo header
+
+    //Now the UDP checksum using the pseudo header
+    psh.source_address = inet_addr( source_ip );
+    psh.dest_address = sin.sin_addr.s_addr;
+    psh.placeholder = 0;
+    psh.protocol = IPPROTO_UDP;
+    psh.udp_length = htons(sizeof(struct udphdr) + length );
+
+    int psize = sizeof(struct pseudo_header) + sizeof(struct udphdr) + length;
+    pseudogram = malloc(psize);
+
+    memcpy(pseudogram , (char*) &psh , sizeof (struct pseudo_header));
+    memcpy(pseudogram + sizeof(struct pseudo_header) , udph , sizeof(struct udphdr) + length);
+
+    udph->check = csum( (unsigned short*) pseudogram , psize);
+
+    //loop if you want to flood :)
+//     while (1)
+    {
+        //Send the packet
+        if (sendto (s, datagram, iph->tot_len ,  0, (struct sockaddr *) &sin, sizeof (sin)) < 0)
+        {
+            perror("sendto failed");
+        }
+        //Data send successfully
+        else
+        {
+            printf ("Packet Send. Length : %d \n" , iph->tot_len);
+            close(s);
+        }
+
+
+
+        smt_packet_header_t smt_header;
+        unsigned char SMTh[SMTh_BUFF_LEN];
+        smt_header.SPS=0X4D54;
+        smt_header.SDC=0X01;
+        smt_header.LEN=10+iph->tot_len;
+        smt_header.TCH=1;
+        smt_header.RSV1=0;
+        smt_header.RSV2=0;
+        init_smt_header(&smt_header,SMTh);
+
+        char smt_datagram[4096];
+        memcpy(&smt_datagram[10],datagram,iph->tot_len);
+        memcpy(&smt_datagram[0],SMTh,SMTh_BUFF_LEN);
+    	//
+    	int ss2;
+    	struct sockaddr_in sendto_addr;
+    	//
+    	ss2=socket(AF_INET, SOCK_DGRAM,0);
+    	if(ss2<0)
+    	{
+    		printf("socket error\n");
+    		return -1;
+    	}
+    	//
+    	bzero(&sendto_addr,sizeof(sendto_addr));
+    	sendto_addr.sin_family=AF_INET;
+//    	sendto_addr.sin_addr.s_addr=htonl(INADDR_ANY);
+    	sendto_addr.sin_addr.s_addr=inet_addr("224.1.0.100");
+    	sendto_addr.sin_port =htons(6080);
+
+    	int addr_len =sizeof(struct sockaddr_in);
+
+//        send_udp2(ss,datagram,iph->tot_len,sendto_addr);
+//    	while(1){
+//    		int a =0;
+//    		printf("udp\n");
+//    		if(sendto(ss2,datagram,iph->tot_len,0,(struct sockaddr *)&sendto_addr,addr_len)<0)
+//
+//    			printf("send fail error\n");
+//    		}
+
+    	sendto(ss2,smt_datagram,smt_header.LEN,0,(struct sockaddr *)&sendto_addr,addr_len);
+        close(ss2);
+
+    }
+
+    return 0;
+}
+
+//Complete
diff --git a/net/mmt/mmtp/send.h b/net/mmt/mmtp/send.h
new file mode 100644
index 0000000..46c6b3b
--- /dev/null
+++ b/net/mmt/mmtp/send.h
@@ -0,0 +1,32 @@
+#ifndef NET_MMT_MMTP_SEND_H_
+#define NET_MMT_MMTP_SEND_H_
+
+/*
+    Raw UDP sockets
+    Silver Moon (m00n.silv3r@gmail.com)
+*/
+#include<stdio.h> //for printf
+#include<string.h> //memset
+#include<sys/socket.h>    //for socket ofcourse
+#include<stdlib.h> //for exit(0);
+#include<errno.h> //For errno - the error number
+#include<netinet/udp.h>   //Provides declarations for udp header
+#include<netinet/ip.h>    //Provides declarations for ip header
+#include<netinet/in.h>
+/*
+    96 bit (12 bytes) pseudo header needed for udp header checksum calculation
+*/
+struct pseudo_header
+{
+    u_int32_t source_address;
+    u_int32_t dest_address;
+    u_int8_t placeholder;
+    u_int8_t protocol;
+    u_int16_t udp_length;
+};
+
+unsigned short csum(unsigned short *ptr,int nbytes);
+int send_raw_udp(char *UDPbuff,int length);
+int send_udp2(int ss,char *UDPbuff,int length,struct sockaddr*to);
+
+#endif
diff --git a/net/mmt/mpu/mp4.h b/net/mmt/mpu/mp4.h
index 0aa7a96..0f4624b 100644
--- a/net/mmt/mpu/mp4.h
+++ b/net/mmt/mpu/mp4.h
@@ -233,6 +233,7 @@
 
 #define ATOM_chap MP4_FOURCC( 'c', 'h', 'a', 'p' )
 
+#define ATOM_muli MP4_FOURCC( 'm', 'u', 'l', 'i' )
 #define ATOM_pitm MP4_FOURCC( 'p', 'i', 't', 'm' )
 #define ATOM_iloc MP4_FOURCC( 'i', 'l', 'o', 'c' )
 #define ATOM_iinf MP4_FOURCC( 'i', 'i', 'n', 'f' )
diff --git a/net/net.gyp b/net/net.gyp
index 25d6654..0305738 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -102,6 +102,7 @@
         'net_derived_sources',
         'net_resources',
         '../net/mmt/mpu/mpu.gyp:libmpu',
+        '../net/mmt/mmtp/mmtp.gyp:libmmtp',
         '../net/mmt/ntp/ntp.gyp:libntp',
       ],
       'sources': [
-- 
1.7.9.5


From efb8b3a07c1046c3457025425ecbd11dbd27faa6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 18:27:35 +0800
Subject: [PATCH 080/128] [todo] add ci xml 's merge & update

---
 net/mmt/mmt_control.cc |   40 +++++++++++----
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_parser.cc  |  132 +++++++++++++++++++++++++++++++++++++++++++++++-
 net/mmt/mmt_parser.h   |   14 +++++
 4 files changed, 174 insertions(+), 13 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 5eb3c1e..0e48e2d 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -128,6 +128,7 @@ ctrl_msg_t::~ctrl_msg_t() {
 cixml_t::cixml_t() {
     fname = "";
     status = "initing";
+    timestamp = 0;
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
@@ -222,27 +223,44 @@ void MmtControl::CheckEvent() {
 
         std::string xml_name = cixml->fname;
         std::string next_status = cixml->status;
-        CiParserPtr parser = cixml->parser;
 
         //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
         if (cixml->status == "initing") {
-            if (!cixml->parser) {
-                cixml->parser = new CiParser(xml_name);
-            }
             next_status = "loading";
             Wait(100);
         }else if (cixml->status == "loading") {
-            if (parser) {
-                parser->ParseXml();
-                parser->ParseHtml();
-            }
             next_status = "loaded";
             Wait(1000);
         }else if (cixml->status == "loaded") {
-            if (parser && cixml->postui) {
+            if (!cixml->parser) { // first load
+                cixml->parser = new CiParser(xml_name);
+                if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
+                    cixml->parser = nullptr;
+                }
+            }
+
+            int64 ntp = GetNTPTime();
+            if (cixml->parser) {
+                // update ci xml
+                int64 timestamp = cixml->parser->GetTimestamp();
+                std::string version = cixml->parser->GetVersion();
+                if (cixml->timestamp != timestamp && timestamp > 0 && ntp >= timestamp) {
+                    CiParserPtr parser_new = new CiParser(xml_name);
+                    if(parser_new->ParseXml() && parser_new->ParseHtml()) {
+                        parser_new->MergeCI(cixml->parser.get());
+                        cixml->parser = parser_new;
+                        LOG(INFO) << __func__ << " update xml,"
+                            << " old timestamp=" << timestamp << " version=" << version
+                            << " new timestamp=" << cixml->parser->GetTimestamp()
+                            << " version=" << cixml->parser->GetVersion();
+                    }
+                    cixml->timestamp = timestamp;
+                }
+            }
+
+            if (cixml->parser && cixml->postui) {
                 std::string js;
-                int64 ntp = GetNTPTime();
-                if(parser->GetHtmlJS(ntp, js) && !js.empty()) {
+                if(cixml->parser->GetHtmlJS(ntp, js) && !js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
                     GetJsonData(iter->first, js, json);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 150f148..178643b 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,6 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
+    int64 timestamp;        //> timestamp of parsed xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
     postui_func_t postui;   //> function for execute js script
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 3b57285..5379808 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -1,5 +1,6 @@
 #include "net/mmt/mmt_parser.h"
 #include "net/mmt/mmt_stream.h"
+#include "net/mmt/mmt_inc.h"
 
 #include "libxml/parser.h"
 
@@ -21,6 +22,8 @@ static const char ksourceList[]     = "sourceList";
 /**
  * String constants for ci xml attr
  */
+static const char kversion[]    = "version";
+static const char ktimestamp[]  = "timestamp";
 static const char krefId[]      = "refId";
 static const char krefDiv[]     = "refDiv";
 static const char kmediaSrc[]   = "mediaSrc";
@@ -118,7 +121,7 @@ int64 ParseTimeStr(std::string timestr) {
 
 #ifdef USE_NTP_TIME
     base::Time time;
-    if(!base::Time::FromUTCString(timestr.c_str(), &time))
+    if(!base::Time::FromString(timestr.c_str(), &time))
         return 0;
     ms = (int64)time.ToJsTime(); //milliseconds
 #else
@@ -170,6 +173,7 @@ html_t::~html_t() {
 
 CiParser::CiParser(const std::string& fname) 
     : fname_(fname), root_(nullptr), cur_(nullptr) {
+    timestamp_ = 0;
 }
 
 CiParser::~CiParser() {
@@ -328,7 +332,6 @@ bool CiParser::ParseHtml() {
             }else if (begin.event == kevbegin || begin.event == kevend) {
                 SetNodeTime(node->time.begin, node);
             }
-
         }
 
         event_t end = node->time.end;
@@ -351,6 +354,123 @@ bool CiParser::ParseHtml() {
     return true;
 }
 
+// merge ev2 into ev1
+void MergeEvent(event_t& ev1, event_t& ev2) {
+    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << "time2="<<ev2.time;
+    if (ev1.is_event != ev2.is_event || ev1.id != ev2.id ||
+        ev1.event != ev2.event || ev1.time != ev2.time) { // update
+        ev1 = ev2;
+    }else {
+        ev1.is_timeout = ev2.is_timeout;
+    }
+}
+// merge attrs2 into attrs1
+void MergeAttrs(attrs_t& attrs1, attrs_t& attrs2) {
+    attrs_t::iterator iter1 = attrs1.begin();
+    for (; iter1 != attrs1.end(); iter1++) {
+        if (attrs2.find(iter1->first) == attrs2.end()) 
+            continue;
+        std::string value1 = iter1->second;
+        std::string value2 = attrs2[iter1->first];
+        if (value1 != value2) {
+            LOG(INFO) << __func__ << " key=" << iter1->first 
+                << " value1=" << value1 << " value2=" << value2;
+            attrs1[iter1->first] = value2;
+        } 
+    }
+}
+
+// merge node2 into node1
+bool MergeNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false; 
+
+    LOG(INFO) << __func__ << " update node name=" << node1->name;
+    MergeAttrs(node1->attrs, node2->attrs);
+    MergeEvent(node1->time.begin, node2->time.begin);
+    MergeEvent(node1->time.end, node2->time.end);
+    return 0;
+}
+
+/**
+ * Check similar node
+ */
+bool IsSameNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return false;
+    if (node1->name != node2->name) return false;
+
+    std::string id1, refId1, refDiv1;
+    if (node1->attrs.find("id") != node1->attrs.end())
+        id1 = node1->attrs["id"];
+    if (node1->attrs.find(krefId) != node1->attrs.end())
+        refId1 = node1->attrs[krefId];
+    if (node1->attrs.find(krefDiv) != node1->attrs.end())
+        refDiv1 = node1->attrs[krefDiv];
+
+    std::string id2, refId2, refDiv2;
+    if (node2->attrs.find("id") != node2->attrs.end())
+        id2 = node2->attrs["id"];
+    if (node2->attrs.find(krefId) != node2->attrs.end())
+        refId2 = node2->attrs[krefId];
+    if (node2->attrs.find(krefDiv) != node2->attrs.end())
+        refDiv2 = node2->attrs[krefDiv];
+
+    if (id1 != id2 || refId1 != refId2 || refDiv1 != refDiv2) return false;
+    return true;
+}
+
+/**
+ * find node2 from node1's subnodes
+ */
+nodeptr_t FindSubNode(nodeptr_t node1, nodeptr_t node2) {
+    if (!node1 || !node2) return nullptr;
+
+    nodeptrs_t::iterator iter1;
+    for(iter1=node1->nodes.begin(); iter1 != node1->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2;
+            for(iter2=sub1->nodes.begin(); iter2 != sub1->nodes.end(); iter2++){
+                nodeptr_t sub2 = *iter2;
+                if (IsSameNode(sub2, node2)) {
+                    return sub2;
+                }
+            }
+        }
+
+        if (IsSameNode(sub1, node2)) {
+            return sub1;
+        }
+    }
+    return nullptr;
+}
+
+// merge old pasrer's CI into this new CI
+bool CiParser::MergeCI(CiParser* parser) {
+    if (!root_ || !parser || !parser->root_) return false;
+    nodeptr_t node = root_;
+    nodeptr_t oldnode = parser->root_;
+
+    nodeptrs_t::iterator iter1;
+    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+        nodeptr_t sub1 = *iter1;
+        if (sub1->name == kview) {
+            nodeptrs_t::iterator iter2;
+            for(iter2=sub1->nodes.begin(); iter2 != sub1->nodes.end(); iter2++ ){
+                nodeptr_t sub2 = *iter2;
+                nodeptr_t sub3 = FindSubNode(oldnode, sub2);
+                MergeNode(sub2, sub3);
+            }
+        }else {
+            nodeptr_t sub2 = FindSubNode(oldnode, sub1);
+            MergeNode(sub1, sub2);  // merge old into new
+        }
+    }
+
+    return true;
+}
+
+
 /**
  * To process both @begin and @end
  */
@@ -531,6 +651,14 @@ bool CiParser::AddAttr(std::string name, std::string value) {
         ParseTimeEvent(value, cur_->time.begin);
     }else if (name == kend) {
         ParseTimeEvent(value, cur_->time.end);
+    }else if (cur_->name == kCI) {
+        if (name == kversion) {
+            version_ = value;
+            LOG(INFO) << __func__ << " xml version=" << version_;
+        }else if (name == ktimestamp) {
+            timestamp_ = ParseTimeStr(value);
+            LOG(INFO) << __func__ << " xml timestamp=" << timestamp_ << " local=" << GetLocalTime();
+        }
     }
 
     return true;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 736806a..ef97783 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -107,6 +107,11 @@ public:
     bool ParseHtml();
 
     /**
+     * To Merge another parser
+     */
+    bool MergeCI(CiParser* parser);
+
+    /**
      * To get current js to operate
      *
      * @param current[in]: current time(ms) (ntp or ntp diff)
@@ -116,6 +121,12 @@ public:
     bool GetHtmlJS(int64 current, std::string& js);
 
     /**
+     * Get Xml's timestamp and version.
+     */
+    int64 GetTimestamp() {return timestamp_;}
+    std::string GetVersion() {return version_;}
+
+    /**
      * To parse xml's node and its attr
      */
     bool AddNode(std::string name);
@@ -136,6 +147,9 @@ private:
     nodeptr_t root_;    //> xml's root node
     nodeptr_t cur_;     //> only work for AddNode/AddAttr
     htmlmap_t htmls_;   //> html tags
+
+    std::string version_;
+    int64 timestamp_;
 };
 typedef scoped_refptr<CiParser> CiParserPtr;
 
-- 
1.7.9.5


From 00e24513ee82db0ad196585a085f395d75f4f907 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 18:53:05 +0800
Subject: [PATCH 081/128] [todo] refine xml update interval; refine mmtp

---
 net/mmt/mmt_control.cc |   31 +++++++++++++++++++------------
 net/mmt/mmt_control.h  |    2 +-
 net/mmt/mmt_parser.cc  |   17 +++++++----------
 net/mmt/mmtp/Makefile  |   21 +++++++++++++++++++++
 net/mmt/mmtp/client.c  |    2 +-
 5 files changed, 49 insertions(+), 24 deletions(-)
 create mode 100644 net/mmt/mmtp/Makefile

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 0e48e2d..3050e34 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -128,7 +128,7 @@ ctrl_msg_t::~ctrl_msg_t() {
 cixml_t::cixml_t() {
     fname = "";
     status = "initing";
-    timestamp = 0;
+    update = 0;
     parser = nullptr;
     job = nullptr;
     postui = nullptr;
@@ -236,26 +236,33 @@ void MmtControl::CheckEvent() {
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
                     cixml->parser = nullptr;
+                    cixml->update = 15;
                 }
             }
 
             int64 ntp = GetNTPTime();
-            if (cixml->parser) {
+            if (cixml->parser && (cixml->update--) <= 0) {
                 // update ci xml
                 int64 timestamp = cixml->parser->GetTimestamp();
                 std::string version = cixml->parser->GetVersion();
-                if (cixml->timestamp != timestamp && timestamp > 0 && ntp >= timestamp) {
-                    CiParserPtr parser_new = new CiParser(xml_name);
-                    if(parser_new->ParseXml() && parser_new->ParseHtml()) {
-                        parser_new->MergeCI(cixml->parser.get());
-                        cixml->parser = parser_new;
-                        LOG(INFO) << __func__ << " update xml,"
-                            << " old timestamp=" << timestamp << " version=" << version
-                            << " new timestamp=" << cixml->parser->GetTimestamp()
-                            << " version=" << cixml->parser->GetVersion();
+                CiParserPtr parser2 = new CiParser(xml_name);
+                if(parser2->ParseXml()) {
+                    int64 timestamp2 = parser2->GetTimestamp();
+                    std::string version2 = parser2->GetVersion();
+                    LOG(INFO) << __func__ << " to update xml, ntp=" << ntp
+                        << " old timestamp=" << timestamp << " version=" << version
+                        << " new timestamp=" << timestamp2 << " version=" << version2;
+
+                    if (ntp >= timestamp2 && timestamp < timestamp2) {
+                        if(parser2->ParseHtml()) {
+                            parser2->MergeCI(cixml->parser.get());
+                            cixml->parser = parser2;
+                            LOG(INFO) << __func__ << " to update xml, OK";
+                        }
                     }
-                    cixml->timestamp = timestamp;
+                    cixml->update = 15;
                 }
+                parser2 = nullptr;
             }
 
             if (cixml->parser && cixml->postui) {
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 178643b..f362e3c 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,7 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
-    int64 timestamp;        //> timestamp of parsed xml
+    int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
     postui_func_t postui;   //> function for execute js script
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 5379808..0ec5aff 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -356,12 +356,10 @@ bool CiParser::ParseHtml() {
 
 // merge ev2 into ev1
 void MergeEvent(event_t& ev1, event_t& ev2) {
-    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << "time2="<<ev2.time;
-    if (ev1.is_event != ev2.is_event || ev1.id != ev2.id ||
-        ev1.event != ev2.event || ev1.time != ev2.time) { // update
-        ev1 = ev2;
-    }else {
-        ev1.is_timeout = ev2.is_timeout;
+    LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
+    if (ev1.is_event == ev2.is_event) {
+        if (!ev1.is_event) // digital time, set it with last timeout
+            ev1.is_timeout = ev2.is_timeout;
     }
 }
 // merge attrs2 into attrs1
@@ -386,7 +384,7 @@ bool MergeNode(nodeptr_t node1, nodeptr_t node2) {
     if (node1->name != node2->name) return false; 
 
     LOG(INFO) << __func__ << " update node name=" << node1->name;
-    MergeAttrs(node1->attrs, node2->attrs);
+    //MergeAttrs(node1->attrs, node2->attrs);
     MergeEvent(node1->time.begin, node2->time.begin);
     MergeEvent(node1->time.end, node2->time.end);
     return 0;
@@ -461,10 +459,9 @@ bool CiParser::MergeCI(CiParser* parser) {
                 nodeptr_t sub3 = FindSubNode(oldnode, sub2);
                 MergeNode(sub2, sub3);
             }
-        }else {
-            nodeptr_t sub2 = FindSubNode(oldnode, sub1);
-            MergeNode(sub1, sub2);  // merge old into new
         }
+        nodeptr_t sub2 = FindSubNode(oldnode, sub1);
+        MergeNode(sub1, sub2);  // merge old into new
     }
 
     return true;
diff --git a/net/mmt/mmtp/Makefile b/net/mmt/mmtp/Makefile
new file mode 100644
index 0000000..7655df9
--- /dev/null
+++ b/net/mmt/mmtp/Makefile
@@ -0,0 +1,21 @@
+TARGET = client
+OBJS = DList.o Mlist.o client.o getfile.o ini.o mmt.o ringq.o send.o ../mpu/stream.o ../mpu/mp4.o
+CFLAGS = -I../../../ -D_TEST
+LDFLAGS = -lm -lpthread
+
+all: $(TARGET)
+
+$(TARGET): $(OBJS)
+	$(CC) -o $@ $(OBJS) $(LDFLAGS)
+
+%.o:%.c
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+
+%.o:%.cc
+	$(CC) -g $(CFLAGS) -o $@ -c $<
+	
+clean:
+	@rm -f $(OBJS)
+
+distclean: clean
+	@rm -f $(TARGET)
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 895014e..aa6fdfd 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -70,7 +70,7 @@ void  sig_pipe(int signo)
 DList *signal_buff_list = NULL;
 DList *mpu_buff_list = NULL;
 
-#if 0
+#ifdef _TEST
 int main(int argc, char *argv[])
 {
 
-- 
1.7.9.5


From 27a56d4b9fef0a095586f8a3f83e59a91efe493f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 21:59:33 +0800
Subject: [PATCH 082/128] [todo] add mmtp interface

---
 net/mmt/mmtp/client.c |  112 ++++++++++++++++++++++++++++++-------------------
 net/mmt/mmtp/mmtp.h   |   65 +++++-----------------------
 2 files changed, 79 insertions(+), 98 deletions(-)

diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index aa6fdfd..fde5a7d 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -27,6 +27,7 @@
 #include "send.h"
 #include "ringq.h"
 #include "DList.h"
+#include "mmtp.h"
 
 
 #define MCAST_PORT 6080
@@ -46,59 +47,42 @@ int signal_buffer_has_item=0;							/**/
 int mpu_buffer_has_item=0;							/**/
 pthread_mutex_t mpu_mutex;							/**/
 pthread_mutex_t signal_mutex;							/**/
-int running =1 ;								/**/
 
-static int s;
+static int g_running = 1;								/**/
+static int g_sock;
+static mmtp_func_t g_mmtp_func = NULL;
+
+DList *signal_buff_list = NULL;
+DList *mpu_buff_list = NULL;
+
+#define BUFF_LEN 1500
+#define CLOSESOCKET(fd) if(fd > 0){close(fd);fd=-1;}
+
 
 void sig_proccess(int signo)
 {
 	printf("catch a exit signal\n");
-	close(s);
+	CLOSESOCKET(g_sock);
 	exit(0);
 }
 
 void  sig_pipe(int signo)
 {
 	printf("catch a SIGPIPE signal\n");
-	close(s);
+	CLOSESOCKET(g_sock);
 	exit(0);
 }
 
 
-#define BUFF_LEN 1500
-
-DList *signal_buff_list = NULL;
-DList *mpu_buff_list = NULL;
-
 #ifdef _TEST
 int main(int argc, char *argv[])
 {
-
-	//init a double listmpu_buff_listst = InitList();
-	signal_buff_list=InitList();
-	mpu_buff_list=InitList();
-
-	pthread_t signal_consumer_t;						/**/
-	pthread_t mpu_consumer_t;						/**/
-	pthread_t producter_t;						/**/
-
-	pthread_mutex_init (&signal_mutex,NULL);			/**/
-	pthread_mutex_init (&mpu_mutex,NULL);			/**/
-
-	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
-	usleep(10);
-	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
-	usleep(10);
-	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
-	usleep(10);
-	//pthread_join(producter_t,&buffer_has_item);			/**/
+    init_mmtp();
+    start_mmtp();
 	while(1)
 		sleep(1);
-	pthread_mutex_destroy(&signal_mutex);				/**/
-	//udpserv_echo(ss,(struct sockaddr*)&local_addr);
-
-	/**/
-
+    stop_mmtp();
+    uninit_mmtp();
 
     return 0;
 }
@@ -192,15 +176,15 @@ void *producter_f (void *arg)					/**/
 	PNode p = NULL;
 
 	int lastpacket,last_flag=1;
-
-	while(running)								/**/
+    g_sock = ss;
+	while(g_running)								/**/
 	{
 		len=sizeof(local_addr);
-		n=recvfrom(ss,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
+		n=recvfrom(g_sock,buff,BUFF_LEN,0,(struct sockaddr *)&local_addr,&len);
 		if(n <=0)
 		{
 			perror("recv error");
-			return NULL;
+            break;
 		}
 		mmt_packet_header_t mmt_header;
 		mpu_packet_header_t mpu_header;
@@ -215,7 +199,8 @@ void *producter_f (void *arg)					/**/
 		if(mmt_header.packet_counter!=lastpacket+1 && last_flag==0)
 		{
 			puts ("packet loss");
-			exit (EXIT_FAILURE);
+			//exit (EXIT_FAILURE);
+            break;
 		}
 		lastpacket=mmt_header.packet_counter;
 		last_flag--;
@@ -273,8 +258,8 @@ void *producter_f (void *arg)					/**/
 //			pthread_exit((void *)3);
 	}
 
-	err = setsockopt(ss, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
-	close(ss);
+	err = setsockopt(g_sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
+	CLOSESOCKET(g_sock);
     return NULL;
 }
 
@@ -284,10 +269,10 @@ void *signal_consumer_f(void *arg)						/**/
 	unsigned char *signal_buf;
 	u_int32_t signal_seekpoint=0;
 	pa_message_t pa_message;
-	while(running)								/**/
+	while(g_running)								/**/
 	{
 		pthread_mutex_lock(&signal_mutex);				/**/
-		while(GetSize(signal_buff_list)>1)
+		while(g_running && GetSize(signal_buff_list)>1)
 		{
 			//signal
 			p=GetHead(signal_buff_list);
@@ -415,7 +400,7 @@ void *mpu_consumer_f(void *arg)						/**/
 	mpu_buf_t mpu_buf;
 	init_mpu_buf(&mpu_buf);
 	int mpufilter=0;
-	while(running)								/**/
+	while(g_running)								/**/
 	{
 		int mpu_consumer_couter=0;
 		mmt_packet_header_t mmt_header;
@@ -534,7 +519,7 @@ void *mpu_consumer_f(void *arg)						/**/
 		pthread_mutex_unlock(&mpu_mutex);			/**/
 
 
-		while(GetSize(mpu_consumer_list)>0)
+		while(g_running && GetSize(mpu_consumer_list)>0)
 		{
 //			printf("GetSize(mpu_consumer_list):%d\n",GetSize(mpu_consumer_list)); 	/**/
 			p=GetHead(mpu_consumer_list);
@@ -970,3 +955,42 @@ void *mpu_consumer_f(void *arg)						/**/
 	}//WHILE END
     return NULL;
 }//FUCTION END
+
+
+void init_mmtp() {
+	signal_buff_list=InitList();
+	mpu_buff_list=InitList();
+	pthread_mutex_init (&signal_mutex,NULL);
+	pthread_mutex_init (&mpu_mutex,NULL);
+}
+
+void start_mmtp() {
+    pthread_t signal_consumer_t;
+    pthread_t mpu_consumer_t;
+    pthread_t producter_t;
+
+    g_running = 1;
+	pthread_create(&producter_t, NULL,(void*)producter_f, NULL );
+	usleep(10);
+	pthread_create(&signal_consumer_t, NULL, (void *)signal_consumer_f, NULL);
+	usleep(10);
+	pthread_create(&mpu_consumer_t, NULL, (void *)mpu_consumer_f, NULL);
+	usleep(10);
+}
+
+void stop_mmtp() {
+    CLOSESOCKET(g_sock);
+    g_running = 0;
+}
+
+void uninit_mmtp() {
+	pthread_mutex_destroy(&signal_mutex);
+	pthread_mutex_destroy(&mpu_mutex);
+    DestroyList(signal_buff_list);
+    DestroyList(mpu_buff_list);
+}
+
+void set_mmtp_notifier(mmtp_func_t func) {
+    g_mmtp_func = func;
+}
+
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index 00c02cb..6d6db81 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -1,64 +1,21 @@
 #ifndef NET_MMT_MMTP_MMTP_H_
 #define NET_MMT_MMTP_MMTP_H_
 
-#include "mmt.h"
-
-#if 0
-//
-pthread_mutex_t mpu_mutex;							/**/
-pthread_mutex_t signal_mutex;						/**/
-pthread_mutex_t mpu_list_mutex;						/**/
-
-pthread_t signal_consumer_t;						/**/
-pthread_t mpu_consumer_t;						/**/
-pthread_t producter_t;						/**/
-
-DList *signal_buff_list;
-DList *mpu_buff_list;
-
-int signal_buffer_has_item=0;							/**/
-int mpu_buffer_has_item=0;							/**/
-
-//mpu_buf_t,mpu
-mpu_buf_t *mpu_list;
-
-//
-int mmt_socket;
+#ifdef __cplusplus
+extern "C" {
 #endif
 
-//IP,,,
-int InitMMTP(char *listen_ip, int16_t listen_port);
-
-//MPU,packet_idmpu_sequence_number,packet_idasset
-//MPU,,
-int AddMpu(mpu_buf_t *mpu_list);
-
-//MPU
-int RefreshMpu(mpu_buf_t *mpu_list);
+void init_mmtp();
+void start_mmtp();
+void stop_mmtp();
+void uninit_mmtp();
 
-//,IP,
-int UninitMMTP();
+typedef void (*mmtp_func_t) (const char* fname, const char* ftype);
+void set_mmtp_notifier(mmtp_func_t func);
 
+#ifdef __cplusplus
+}
+#endif
 
-typedef void (*message_callback_func_t)(pa_message_t *pa_message);
-//,,pa_message
-void SetMessageCallback(message_callback_func_t func,pa_message_t *pa_message);
-
-//
-void Message_func(pa_message_t *pa_message);
-
-
-typedef void (*mpu_callback_func_t)(mpu_buf_t *mpu_buf);
-//MPU,,MPU
-void SetCICallback(mpu_callback_func_t func,mpu_buf_t *mpu_buf);
-
-//
-void Mpu_func(mpu_buf_t *mpu_buf);
-
-//,,,
-int QueryMessageResource(char* mmt_url, char* ci_fname,  int size);
-
-//,MPU,,mpu_buf_t,mpu_list
-int QueryMPUResource(mpu_buf_t *mpu_list, u_int32_t sequence,  u_int32_t packet_id);
 
 #endif
-- 
1.7.9.5


From 9839efe80b7f0bb4a04b21eb03cc79536e6553f6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 22:40:05 +0800
Subject: [PATCH 083/128] [todo] refine mmtp interface

---
 net/mmt/mmtp/client.c |   32 ++++++++++++++++++++++++--------
 net/mmt/mmtp/mmt.c    |   10 +++++++++-
 net/mmt/mmtp/mmtp.h   |   13 +++++++++++--
 3 files changed, 44 insertions(+), 11 deletions(-)

diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index fde5a7d..0ad507d 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -48,9 +48,9 @@ int mpu_buffer_has_item=0;							/**/
 pthread_mutex_t mpu_mutex;							/**/
 pthread_mutex_t signal_mutex;							/**/
 
-static int g_running = 1;								/**/
-static int g_sock;
-static mmtp_func_t g_mmtp_func = NULL;
+int g_running = 1;								/**/
+int g_sock = -1;
+mmtp_callback_t g_mmtp_cb;
 
 DList *signal_buff_list = NULL;
 DList *mpu_buff_list = NULL;
@@ -732,7 +732,10 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									fclose(mpu);
 									free_mpu_buf(&mpu_buf );
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 
 								}
 //								free(mfu_buf);
@@ -881,7 +884,11 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 
 								}
 								//,,
@@ -937,7 +944,11 @@ void *mpu_consumer_f(void *arg)						/**/
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
-									printf("finished recive a mpu \n");
+									printf("finished recive a mpu - %d\n", mpu_header.FT);
+
+                                    if (g_mmtp_cb.mpufunc) {
+                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
+                                    }
 								}
 
 							}
@@ -962,6 +973,7 @@ void init_mmtp() {
 	mpu_buff_list=InitList();
 	pthread_mutex_init (&signal_mutex,NULL);
 	pthread_mutex_init (&mpu_mutex,NULL);
+    memset(&g_mmtp_cb, 0, sizeof(g_mmtp_cb));
 }
 
 void start_mmtp() {
@@ -978,6 +990,10 @@ void start_mmtp() {
 	usleep(10);
 }
 
+void open_mmtp(const char* url) {
+    // TODO
+}
+
 void stop_mmtp() {
     CLOSESOCKET(g_sock);
     g_running = 0;
@@ -990,7 +1006,7 @@ void uninit_mmtp() {
     DestroyList(mpu_buff_list);
 }
 
-void set_mmtp_notifier(mmtp_func_t func) {
-    g_mmtp_func = func;
+void set_mmtp_callback(mmtp_callback_t* mmtp_cb) {
+    g_mmtp_cb = *mmtp_cb;
 }
 
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
index e2a09ee..2188743 100644
--- a/net/mmt/mmtp/mmt.c
+++ b/net/mmt/mmtp/mmt.c
@@ -22,6 +22,9 @@
 #include "mmt.h"
 #include "getfile.h"
 #include "send.h"
+#include "mmtp.h"
+
+extern mmtp_callback_t g_mmtp_cb;
 
 int get_send_timestamp()
 {
@@ -1055,7 +1058,12 @@ int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
 					}
 			fwrite(mpi_table->PI_content[i].PI_content_byte,mpi_table->PI_content[i].PI_content_length,1,mpi);
 			fclose(mpi);
-		}
+
+			printf("finished recive a ci - %d - %s\n", i, (const char *)mpi_table->PI_content[i].PI_content_name_byte);
+            if (g_mmtp_cb.cifunc) {
+                g_mmtp_cb.cifunc(NULL, (const char *)mpi_table->PI_content[i].PI_content_name_byte, i);
+            }
+        }
 	 return 0;
 
 }
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index 6d6db81..dd2099c 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -7,11 +7,20 @@ extern "C" {
 
 void init_mmtp();
 void start_mmtp();
+void open_mmtp(const char* url);
 void stop_mmtp();
 void uninit_mmtp();
 
-typedef void (*mmtp_func_t) (const char* fname, const char* ftype);
-void set_mmtp_notifier(mmtp_func_t func);
+// for ci.xml and index.html
+typedef void (*mmtp_ci_func_t) (const char* url, const char* fname, int ftype);
+// for audio, video and image
+typedef void (*mmtp_mpu_func_t) (const char* url, const char* fname, int ftype);
+typedef struct mmtp_callback_t {
+    mmtp_ci_func_t cifunc;
+    mmtp_mpu_func_t mpufunc;
+}mmtp_callback_t;
+
+void set_mmtp_callback(mmtp_callback_t* mmtp_cb);
 
 #ifdef __cplusplus
 }
-- 
1.7.9.5


From 165ab5012a61fcac77f3f2e0fd500826757d462c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 8 Feb 2015 23:32:17 +0800
Subject: [PATCH 084/128] [todo] support <sourceList> for all

---
 net/mmt/mmt_parser.cc |   23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 0ec5aff..f387cb5 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -233,23 +233,24 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     // set media src
     if (node->name == kMediaSync) {
         bool bfind = false;
-        // for <img>
-        if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
-            std::string src = node->attrs[kmediaSrc];
+        // for <img>, <audio> <video>
+        nodeptrs_t::iterator iter = node->nodes.begin();
+        for (; iter != node->nodes.end(); iter++) {
+            nodeptr_t sub = *iter;
+            if (sub->name != ksourceList) continue;
+            std::string src = sub->attrs[kmediaSrc];
             js0 += SetJSAttr(id, "src", src);
             js1 += SetJSAttr(id, "src", "");
             bfind = true;
-        }else {
-            // for <audio> <video>
-            nodeptrs_t::iterator iter = node->nodes.begin();
-            for (; iter != node->nodes.end(); iter++) {
-                nodeptr_t sub = *iter;
-                if (sub->name != ksourceList) continue;
-                std::string src = sub->attrs[kmediaSrc];
+            break;
+        }
+
+        if (!bfind) {
+            if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
+                std::string src = node->attrs[kmediaSrc];
                 js0 += SetJSAttr(id, "src", src);
                 js1 += SetJSAttr(id, "src", "");
                 bfind = true;
-                break;
             }
         }
 
-- 
1.7.9.5


From 3a8a3f39bb1309b5c7eced0c6ec089ae0f3bfe93 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 02:42:26 +0800
Subject: [PATCH 085/128] [todo] integrate mmtp into mmt_stream

---
 net/mmt/mmt_control.cc |   30 +++++-----
 net/mmt/mmt_stream.cc  |  153 ++++++++++++++++++++++++++++++++++++++++++++----
 net/mmt/mmt_stream.h   |   44 +++++++++++++-
 3 files changed, 201 insertions(+), 26 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 3050e34..bf58100 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -158,9 +158,14 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     long lsize = -1;
     StreamPtr stream = new Stream(msg.url);
     streams_[key] = stream;
-    stream->Prepare(&lsize);
-    if (msg.sinfo.func) {
-        msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+    if(stream->Prepare(&lsize) == -3) { // waiting
+        Push(msg);
+        Wait(100);
+        return;
+    }else {
+        if (msg.sinfo.func) {
+            msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+        }
     }
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
@@ -171,17 +176,14 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
-#if 0
-        LOG(INFO) << __func__ 
-            << " head=" << head 
-            << " iret=" << iret 
-            << " url=" << url
-            << " size=" << msg.sinfo.size 
-            << " offset=" << msg.sinfo.offset 
-            << " ptr=" << msg.ptr.get();
-#endif
-        if (msg.sinfo.func) {
-            msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+        if (iret == -3) { // waiting 
+            Push(msg);
+            Wait(100);
+            return;
+        }else {
+            if (msg.sinfo.func) {
+                msg.sinfo.func(msg.ptr, msg.sinfo, iret);
+            }
         }
     }
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 98b9dc1..925dea0 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -1,14 +1,20 @@
 #include "net/mmt/mmt_stream.h"
 #include "net/mmt/mmt_inc.h"
 #include "net/mmt/mpu/mp4.h"
+#include "net/mmt/mmtp/mmtp.h"
 
 namespace mmt {
 
+#define USE_MMTP 1
+
 static const long kMmtMediaSize = 0x7fffffff;
 
 static const char kMmtMediaAudio[] = "audio";
 static const char kMmtMediaVideo[] = "video";
 static const char kMmtMediaImage[] = "image";
+static const char kMmtMediaMmtp[] = "mmtp";
+static const char kMmtMediaHtml[] = "html";
+static const char kMmtMediaCI[] = "ci";
 
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
@@ -70,11 +76,127 @@ stream_t* InitMpuStream(Stream* ptr) {
 
 namespace mmt {
 
+static MmtpStream* g_mmtp = nullptr;
+
+void MmtpStart() {
+    if (!g_mmtp) {
+        g_mmtp = new MmtpStream;
+    }
+
+    if (g_mmtp) {
+        g_mmtp->StartMmtp();
+    }
+}
+void MmtpStop() {
+    if (g_mmtp) {
+        g_mmtp->StopMmtp();
+    }
+}
+bool MmtpPop(std::string key, mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        return g_mmtp->Pop(key, mmtp);
+    }
+    return false;
+}
+void MmtpPush(mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        g_mmtp->Push(mmtp);
+    }
+}
+
+void CIRecvCallback(const char* url, const char* fname, int ftype) {
+    base::FilePath fpath;
+    base::GetCurrentDirectory (&fpath);
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
+    // for test
+    static bool _had_html = false;
+    static bool _had_ci = false;
+    if (ftype == 0 && _had_html) return;
+    if (ftype == 1 && _had_ci) return;
+    _had_html = (ftype == 0);
+    _had_ci = (ftype == 1);
+
+    mmtp_info_t mmtp;
+    if (url) mmtp.url = url;
+    if (fname) mmtp.fname = fname;
+    mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
+    MmtpPush(mmtp);
+    LOG(INFO) << __func__ << " END";
+}
+
+void MPURecvCallback(const char* url, const char* fname, int ftype) {
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype;
+    mmtp_info_t mmtp;
+    if (url) mmtp.url = url;
+    if (fname) mmtp.fname = fname;
+    mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
+    MmtpPush(mmtp);
+    LOG(INFO) << __func__ << " END";
+}
+
+MmtpStream::MmtpStream(){
+    mmtprun_ = false;
+}
+MmtpStream::~MmtpStream(){
+}
+
+bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
+    if (mlist_.empty()) return false;
+
+    lock_.Acquire();
+    std::map<std::string, mmtp_infos_t>::iterator iter;
+    iter = mlist_.find(key);
+    if (iter == mlist_.end()) return false;
+
+    mmtp_infos_t& infos = iter->second;
+    if (infos.empty()) return false;
+
+    mmtp = infos.back();
+    infos.pop_back();
+    lock_.Release();
+    return true;
+}
+void MmtpStream::Push(const mmtp_info_t& mmtp) {
+    //TODO: should be url, but now testing
+    std::string key = mmtp.mtype;
+    std::map<std::string, mmtp_infos_t>::iterator iter;
+    lock_.Acquire();
+    iter = mlist_.find(key);
+    if (iter != mlist_.end()) {
+        mmtp_infos_t& infos = iter->second;
+        infos.insert(infos.begin(), mmtp);
+    }else {
+        mmtp_infos_t infos;
+        infos.push_back(mmtp);
+        mlist_[key] = infos;
+    }
+    lock_.Release();
+}
+void MmtpStream::StartMmtp() {
+    if (mmtprun_) return;
+    init_mmtp();
+    mmtp_callback_t cb;
+    cb.cifunc = CIRecvCallback;
+    cb.mpufunc = MPURecvCallback;
+    set_mmtp_callback(&cb);
+    start_mmtp();
+    mmtprun_ = true;
+}
+void MmtpStream::StopMmtp() {
+    if (!mmtprun_) return;
+    stop_mmtp();
+    uninit_mmtp();
+    mmtprun_ = false;
+}
+
+
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
     midx_.begin = -1;
     midx_.end = -1;
     midx_.cur = -1;
+    lasterr_ = 0;
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
@@ -104,14 +226,18 @@ bool Stream::ParseSequence(int& index) {
         index = midx_.begin;
         LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
         if (index < 0 || midx_.begin > midx_.end) return false;
+
+        if (mtype == kMmtMediaMmtp) { // for mmtp streaming
+            index = -3;
+        }
     }else { // may be one seperate file, not one media sequence
         index = -1;
     }
     return true;
 }
 
-bool Stream::Prepare(long *size) {
-    if (!Open(nullptr, 0)) return false;
+int Stream::Prepare(long *size) {
+    if (!Open(nullptr, 0)) return lasterr_;
 
     long lret = kMmtMediaSize;  // TODO: default size for media sequence
     if (midx_.cur < 0) {        // return real size for single file
@@ -119,12 +245,13 @@ bool Stream::Prepare(long *size) {
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
-    return true;
+    return 0;
 }
 
 void* Stream::Open(const char* filename, int mode) {
     if (file_) return (void *)file_;
 
+    lasterr_ = -2;
     int index = midx_.cur;
     if(index < 0 && !ParseSequence(index)) {
         LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
@@ -135,6 +262,7 @@ void* Stream::Open(const char* filename, int mode) {
     //  index >= 0: media sequence
     //  index == -1: common file
     //  index == -2: mp4 image file
+    //  index == -3: mmtp streaming receiver
     std::string fname = GURL2FilePath(url_);
     if (index >= 0) { // for media sequence
         if (index < midx_.begin || index > midx_.end)
@@ -145,9 +273,15 @@ void* Stream::Open(const char* filename, int mode) {
             fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
         }else if (mtype == kMmtMediaVideo) {
             fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == kMmtMediaImage) {
-            // nothing to do
         }
+    } else if (index == -3) { // mmtp streaming
+        MmtpStart();
+        mmtp_info_t mmtp;
+        if(!MmtpPop(kMmtMediaHtml, mmtp)) {
+            lasterr_ = -3;
+            return nullptr;
+        }
+        fname = mmtp.fname;
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
@@ -162,8 +296,7 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != -1 && index != midx_.begin) {
-#if 1
+    if (index != -1 && index != midx_.begin && index != -3) {
         // TODO: process image of mp4 here
         // check moof box and other
         stream_t* s = InitMpuStream(this);
@@ -194,9 +327,6 @@ void* Stream::Open(const char* filename, int mode) {
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
-#else
-        offmap_[index] = offset_t(0, lret);
-#endif
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
     }
@@ -204,11 +334,12 @@ void* Stream::Open(const char* filename, int mode) {
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
     midx_.cur = index;
+    lasterr_ = 0;
     return (void *)file_;
 }
 
 int Stream::Read(void *buf, int size) {
-    if (!Open(nullptr, 0)) return -2;
+    if (!Open(nullptr, 0)) return lasterr_;
 
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index d6fac18..f1ddab0 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -47,6 +47,47 @@ struct content_t {
 
 namespace mmt {
 
+/**
+ * Mmtp information
+ */
+struct mmtp_info_t {
+    std::string url;
+    std::string mtype; // "audio"/"video"/"image"/"ci"/"html" 
+    std::string fname;
+};
+typedef std::vector<mmtp_info_t> mmtp_infos_t;
+
+/**
+ * mmtp resource: audio/video/image/
+ */
+class MmtpStream {
+public:
+    MmtpStream();
+    virtual ~MmtpStream();
+
+    bool Pop(std::string key, mmtp_info_t& mmtp);
+    void Push(const mmtp_info_t& mmtp);
+    // for mmtp control
+    void StartMmtp();
+    void StopMmtp();
+
+private:
+    bool mmtprun_;
+    base::Lock lock_;
+    std::map<std::string, mmtp_infos_t> mlist_; // url => ..
+};
+typedef scoped_refptr<MmtpStream> MmtpStreamPtr;
+
+void MmtpStart();
+void MmtpStop();
+bool MmtpPop(std::string key, mmtp_info_t& mmtp);
+void MmtpPush(mmtp_info_t& mmtp);
+
+
+/**
+ * class for Control Center
+ */
+
 struct triple_t {
     int begin;
     int end;
@@ -99,7 +140,7 @@ public:
     /**
      * if success, set size with the data length
      */
-    bool Prepare(long* size);
+    int Prepare(long* size);
     bool ParseSequence(int& index);
     void Uninit();
 
@@ -113,6 +154,7 @@ private:
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
+    int lasterr_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
 };
-- 
1.7.9.5


From 1cfa68b51bcb7bb35833550ebaf231795a040fb2 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 07:04:31 +0800
Subject: [PATCH 086/128] [todo] redo when ci begin/end changes

---
 net/mmt/mmt_parser.cc |    5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index f387cb5..cb77847 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -359,7 +359,10 @@ bool CiParser::ParseHtml() {
 void MergeEvent(event_t& ev1, event_t& ev2) {
     LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
     if (ev1.is_event == ev2.is_event) {
-        if (!ev1.is_event) // digital time, set it with last timeout
+        // if no changes, set with previous timeout
+        if (!ev1.is_event && ev1.time == ev2.time)
+            ev1.is_timeout = ev2.is_timeout;
+        else if (ev1.is_event && ev1.id == ev2.id && ev1.event == ev2.event)
             ev1.is_timeout = ev2.is_timeout;
     }
 }
-- 
1.7.9.5


From 701a7da1cad38cd242343b2c99126286276316a6 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 07:50:36 +0800
Subject: [PATCH 087/128] [ok] (1) begin/end changes; (2)mp4 image

---
 net/mmt/mmt_control.cc |    5 +++++
 net/mmt/mmt_parser.cc  |    2 +-
 net/mmt/mmt_stream.cc  |    1 +
 3 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index bf58100..3ee8eb7 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -159,6 +159,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     StreamPtr stream = new Stream(msg.url);
     streams_[key] = stream;
     if(stream->Prepare(&lsize) == -3) { // waiting
+        LOG(INFO) << __func__ << " waiting...";
         Push(msg);
         Wait(100);
         return;
@@ -177,6 +178,7 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
         StreamPtr stream = iter->second;
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
         if (iret == -3) { // waiting 
+            LOG(INFO) << __func__ << " waiting...";
             Push(msg);
             Wait(100);
             return;
@@ -237,6 +239,7 @@ void MmtControl::CheckEvent() {
             if (!cixml->parser) { // first load
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
+                    LOG(INFO) << __func__ << " fail to parse xml first";
                     cixml->parser = nullptr;
                     cixml->update = 15;
                 }
@@ -263,6 +266,8 @@ void MmtControl::CheckEvent() {
                         }
                     }
                     cixml->update = 15;
+                }else {
+                    LOG(INFO) << __func__ << " fail to parse xml";
                 }
                 parser2 = nullptr;
             }
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index cb77847..1d522e0 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -197,7 +197,7 @@ bool CiParser::ParseXml() {
     ctxt->_private = (void *)this;
 
     StreamPtr stream = new Stream(fname_);
-    if (!stream->Prepare(nullptr)) return false;
+    if (stream->Prepare(nullptr) != 0) return false;
 
     int num;
     char buffer[4096];
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 925dea0..373a103 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -249,6 +249,7 @@ int Stream::Prepare(long *size) {
 }
 
 void* Stream::Open(const char* filename, int mode) {
+    lasterr_ = 0;
     if (file_) return (void *)file_;
 
     lasterr_ = -2;
-- 
1.7.9.5


From c4da96f77dac24a7b24f5490052cb234a676f7f4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 09:09:12 +0800
Subject: [PATCH 088/128] [todo] support to get ci.xml from mmtp

---
 net/mmt/mmt_control.cc |   18 +++++++++++++++---
 net/mmt/mmt_control.h  |    1 +
 net/mmt/mmt_inc.h      |   12 ++++++++++++
 net/mmt/mmt_stream.cc  |   42 +++++++++++++++++++++---------------------
 net/mmt/mmt_stream.h   |    2 ++
 net/mmt/mmt_utils.cc   |   10 ++++++++++
 6 files changed, 61 insertions(+), 24 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 3ee8eb7..db509e4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -170,12 +170,14 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
     }
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
+    std::string proto;
     std::string key = mmtjob_key(msg.url, msg.ptr.get());
     //LOG(INFO) << __func__ << " head=" << msg.head << " key=" << key;
 
     StreamPtrs_t::iterator iter = streams_.find(key);
     if (iter != streams_.end()) {
         StreamPtr stream = iter->second;
+        proto = stream->GetProto();
         int iret = stream->Read(msg.sinfo.buf->data(), msg.sinfo.size);
         if (iret == -3) { // waiting 
             LOG(INFO) << __func__ << " waiting...";
@@ -193,11 +195,14 @@ void MmtControl::StreamRead(ctrl_msg_t msg) {
     if (msg.tabid > 0) {
         cixmlptr_t cixml;
         if (cixmls_.find(msg.tabid) == cixmls_.end()) {
-            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid;
+            LOG(INFO) << __func__ << " set ci xmls for tabid=" << msg.tabid << " proto=" << proto;
             cixml = new cixml_t;
             cixmls_[msg.tabid] = cixml;;
             // TODO ci xml for testing
-            cixml->fname = kMmtDefaultXml;
+            cixml->proto = proto;
+            cixml->fname = "";
+            if (proto != kMmtProtoMmtp)
+                cixml->fname = kMmtDefaultXml;
         }else {
             cixml = cixmls_[msg.tabid];
         }
@@ -223,6 +228,13 @@ void MmtControl::CheckEvent() {
         cixmlptr_t cixml = iter->second;
         if (!cixml) continue;
         if (cixml->status == "end") continue;
+        if (cixml->proto == kMmtProtoMmtp && cixml->fname.empty()) {
+            mmtp_info_t mmtp;
+            if(MmtpPop(kMmtMediaCI, mmtp)) {
+                cixml->fname = mmtp.fname;
+            }
+            LOG(INFO) << __func__ << " get xml file=" << cixml->fname;
+        }
         if (cixml->fname.empty()) continue;
 
         std::string xml_name = cixml->fname;
@@ -239,7 +251,7 @@ void MmtControl::CheckEvent() {
             if (!cixml->parser) { // first load
                 cixml->parser = new CiParser(xml_name);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
-                    LOG(INFO) << __func__ << " fail to parse xml first";
+                    LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
                     cixml->parser = nullptr;
                     cixml->update = 15;
                 }
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index f362e3c..029c6f8 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -72,6 +72,7 @@ public:
 
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
+    std::string proto;      //> "local" or "mmtp"
     int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index f389b1d..a9cd73c 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -78,6 +78,18 @@ int SendToHost(std::string msg, std::string szaddr, int port);
 int64 GetLocalTime();
 int64 GetNTPTime();
 
+/**
+ * media/proto constants
+ */
+extern const char kMmtMediaAudio[];
+extern const char kMmtMediaVideo[];
+extern const char kMmtMediaImage[];
+extern const char kMmtMediaHtml[];
+extern const char kMmtMediaCI[];
+
+extern const char kMmtProtoMmtp[];
+extern const char kMmtProtoLocal[];
+
 }
 
 #endif
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 373a103..1675150 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -8,14 +8,6 @@ namespace mmt {
 #define USE_MMTP 1
 
 static const long kMmtMediaSize = 0x7fffffff;
-
-static const char kMmtMediaAudio[] = "audio";
-static const char kMmtMediaVideo[] = "video";
-static const char kMmtMediaImage[] = "image";
-static const char kMmtMediaMmtp[] = "mmtp";
-static const char kMmtMediaHtml[] = "html";
-static const char kMmtMediaCI[] = "ci";
-
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
 
@@ -119,17 +111,19 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
 
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = fname;
+    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
     mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
     MmtpPush(mmtp);
-    LOG(INFO) << __func__ << " END";
 }
 
 void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype;
+    base::FilePath fpath;
+    base::GetCurrentDirectory (&fpath);
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = fname;
+    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
     mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
     MmtpPush(mmtp);
     LOG(INFO) << __func__ << " END";
@@ -200,6 +194,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
+    proto_ = kMmtProtoLocal;
 }
 
 Stream::~Stream() {
@@ -212,22 +207,26 @@ bool Stream::ParseSequence(int& index) {
     if (!query.empty()) { // media sequence
         std::string mtype = GetQueryValue(query, "type");
         std::string range = GetQueryValue(query, "sequence_num");
-        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range; 
-        if (mtype.empty()) return false;
-        mtype_ = mtype;
+        std::string proto = GetQueryValue(query, "proto");
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range << " proto=" << proto; 
+        if (mtype.empty() && proto.empty()) return false;
+        if (!proto.empty()) proto_ = proto;
 
+        mtype_ = mtype;
         if (mtype == kMmtMediaImage) {
             index = -2;
             return true;
         }
 
         // compute the sequence of media
-        GetRangeValue(range, midx_.begin, midx_.end);
-        index = midx_.begin;
-        LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
-        if (index < 0 || midx_.begin > midx_.end) return false;
+        {
+            GetRangeValue(range, midx_.begin, midx_.end);
+            index = midx_.begin;
+            LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
+            if (index < 0 || midx_.begin > midx_.end) return false;
+        }
 
-        if (mtype == kMmtMediaMmtp) { // for mmtp streaming
+        if (proto_ == kMmtProtoMmtp) { // for mmtp streaming
             index = -3;
         }
     }else { // may be one seperate file, not one media sequence
@@ -282,7 +281,8 @@ void* Stream::Open(const char* filename, int mode) {
             lasterr_ = -3;
             return nullptr;
         }
-        fname = mmtp.fname;
+        GURL url(mmtp.fname);
+        fname = GURL2FilePath(url);
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index f1ddab0..c6e5012 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -142,6 +142,7 @@ public:
      */
     int Prepare(long* size);
     bool ParseSequence(int& index);
+    std::string GetProto() { return proto_;}
     void Uninit();
 
 protected:
@@ -151,6 +152,7 @@ protected:
 private:
     GURL url_;
     std::string mtype_;
+    std::string proto_;
     triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 5952fab..915b66b 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -7,6 +7,16 @@ namespace mmt {
 #define USE_NTP_TIME 1
 static const char kMmtNtpServer[] = "time.apple.com";
 
+const char kMmtMediaAudio[] = "audio";
+const char kMmtMediaVideo[] = "video";
+const char kMmtMediaImage[] = "image";
+const char kMmtMediaHtml[] = "html";
+const char kMmtMediaCI[] = "ci";
+
+const char kMmtProtoMmtp[] = "mmtp";
+const char kMmtProtoLocal[] = "local";
+
+
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
 }
-- 
1.7.9.5


From 848600dd7a3d3598fb97853d9004fd7396225449 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 10:14:52 +0800
Subject: [PATCH 089/128] [todo] fix dead-lock for mmtp-stream

---
 net/mmt/mmt_stream.cc |   43 +++++++++++++++++++++++++++++--------------
 1 file changed, 29 insertions(+), 14 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 1675150..50bcbac 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -2,6 +2,7 @@
 #include "net/mmt/mmt_inc.h"
 #include "net/mmt/mpu/mp4.h"
 #include "net/mmt/mmtp/mmtp.h"
+#include "net/mmt/mmt_control.h"
 
 namespace mmt {
 
@@ -99,7 +100,6 @@ void MmtpPush(mmtp_info_t& mmtp) {
 void CIRecvCallback(const char* url, const char* fname, int ftype) {
     base::FilePath fpath;
     base::GetCurrentDirectory (&fpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     // for test
     static bool _had_html = false;
@@ -109,6 +109,7 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
     _had_html = (ftype == 0);
     _had_ci = (ftype == 1);
 
+    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
     if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
@@ -138,18 +139,21 @@ MmtpStream::~MmtpStream(){
 bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
     if (mlist_.empty()) return false;
 
+    bool isok = false;
     lock_.Acquire();
-    std::map<std::string, mmtp_infos_t>::iterator iter;
-    iter = mlist_.find(key);
-    if (iter == mlist_.end()) return false;
-
-    mmtp_infos_t& infos = iter->second;
-    if (infos.empty()) return false;
+    do {
+        std::map<std::string, mmtp_infos_t>::iterator iter;
+        iter = mlist_.find(key);
+        if (iter == mlist_.end()) break;
+        mmtp_infos_t& infos = iter->second;
+        if (infos.empty()) break;
 
-    mmtp = infos.back();
-    infos.pop_back();
+        mmtp = infos.back();
+        infos.pop_back();
+        isok = true;
+    }while(false);
     lock_.Release();
-    return true;
+    return isok;
 }
 void MmtpStream::Push(const mmtp_info_t& mmtp) {
     //TODO: should be url, but now testing
@@ -240,7 +244,11 @@ int Stream::Prepare(long *size) {
 
     long lret = kMmtMediaSize;  // TODO: default size for media sequence
     if (midx_.cur < 0) {        // return real size for single file
-        lret = offmap_[midx_.cur].size; 
+        if (proto_ == kMmtProtoMmtp && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo)) {
+            // for mmtp sequence
+        }else {
+            lret = offmap_[midx_.cur].size; 
+        }
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -277,9 +285,16 @@ void* Stream::Open(const char* filename, int mode) {
     } else if (index == -3) { // mmtp streaming
         MmtpStart();
         mmtp_info_t mmtp;
-        if(!MmtpPop(kMmtMediaHtml, mmtp)) {
-            lasterr_ = -3;
-            return nullptr;
+        if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
+            if(!MmtpPop(mtype_, mmtp)) {
+                lasterr_ = -3;
+                return nullptr;
+            }
+        }else {
+            if(!MmtpPop(kMmtMediaHtml, mmtp)) {
+                lasterr_ = -3;
+                return nullptr;
+            }
         }
         GURL url(mmtp.fname);
         fname = GURL2FilePath(url);
-- 
1.7.9.5


From 48d5998bd17efcbee663c0a4a35b9c61623c189d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 10:25:05 +0800
Subject: [PATCH 090/128] [todo] support audio/video recever from mmtp

---
 net/mmt/mmt_stream.cc |   65 ++++++++++++++++++++++++++++---------------------
 net/mmt/mmt_stream.h  |    2 ++
 2 files changed, 39 insertions(+), 28 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 50bcbac..342afc8 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -199,6 +199,7 @@ Stream::Stream(const GURL &url) : url_(url), file_(nullptr) {
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
     proto_ = kMmtProtoLocal;
+    first_ = true;
 }
 
 Stream::~Stream() {
@@ -255,6 +256,37 @@ int Stream::Prepare(long *size) {
     return 0;
 }
 
+long Stream::ParseMpu() {
+    // TODO: process image of mp4 here
+    // check moof box and other
+    stream_t* s = InitMpuStream(this);
+    mp4_box_t* root = MP4_BoxGetRoot(s);
+    mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+
+    long offset = -1;
+    mp4_box_t* box = nullptr;
+    if (mtype_ == kMmtMediaImage) {
+        box = MP4_BoxSearchBox(box0, ATOM_idat);
+        offset = 8;
+    }else {
+        box = MP4_BoxSearchBox(box0, ATOM_moof);
+        offset = 0;
+    }
+    LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+        << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+
+    // get the pos of the 1st moof-box
+    long ipos = -1;
+    if (box) ipos = box->i_pos;
+    MP4_BoxFree(s, root);
+    free(s);
+
+    // seek to the 1st moof-box
+    if (ipos == -1) return -1;
+    offset += ipos;
+    return offset;
+}
+
 void* Stream::Open(const char* filename, int mode) {
     lasterr_ = 0;
     if (file_) return (void *)file_;
@@ -312,39 +344,16 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if (index != -1 && index != midx_.begin && index != -3) {
-        // TODO: process image of mp4 here
-        // check moof box and other
-        stream_t* s = InitMpuStream(this);
-        mp4_box_t* root = MP4_BoxGetRoot(s);
-        mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
-
-        long offset = -1;
-        mp4_box_t* box = nullptr;
-        if (mtype_ == kMmtMediaImage) {
-            box = MP4_BoxSearchBox(box0, ATOM_idat);
-            offset = 8;
-        }else {
-            box = MP4_BoxSearchBox(box0, ATOM_moof);
-            offset = 0;
-        }
-        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
-            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
-
-        // get the pos of the 1st moof-box
-        long ipos = -1;
-        if (box) ipos = box->i_pos;
-        MP4_BoxFree(s, root);
-        free(s);
-        
-        // seek to the 1st moof-box
-        if (ipos == -1) return nullptr;
-        offset += ipos;
+    if ((index != -1 && index != midx_.begin && index != -3) || 
+        (index == -3 && !first_ && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo))) {
+        long offset = ParseMpu();
+        if (offset == -1) return nullptr;
         offmap_[index] = offset_t(offset, lret);
         ierr = fseek(file_, offset, SEEK_SET);
         if (ierr != 0) return nullptr; 
     }else { // the 1st seq file or single file
         offmap_[index] = offset_t(0, lret);
+        if (index == -3) first_ = false;
     }
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index c6e5012..673eaf4 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -142,6 +142,7 @@ public:
      */
     int Prepare(long* size);
     bool ParseSequence(int& index);
+    long ParseMpu();
     std::string GetProto() { return proto_;}
     void Uninit();
 
@@ -157,6 +158,7 @@ private:
     std::map<int, offset_t> offmap_; //> read offset for current media index
     FILE *file_;
     int lasterr_;
+    bool first_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
 };
-- 
1.7.9.5


From de4383d58312f115a43b937fa14801b318cde6cb Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 22:19:51 +0800
Subject: [PATCH 091/128] [ok] refine mmt_stream of local & mmtp

---
 net/mmt/mmt_control.cc |    4 +-
 net/mmt/mmt_inc.h      |    3 +
 net/mmt/mmt_stream.cc  |  190 ++++++++++++++++++++++++++----------------------
 net/mmt/mmt_stream.h   |   33 +++++++--
 net/mmt/mmt_utils.cc   |    3 +-
 5 files changed, 136 insertions(+), 97 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index db509e4..9d2c786 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -230,7 +230,9 @@ void MmtControl::CheckEvent() {
         if (cixml->status == "end") continue;
         if (cixml->proto == kMmtProtoMmtp && cixml->fname.empty()) {
             mmtp_info_t mmtp;
-            if(MmtpPop(kMmtMediaCI, mmtp)) {
+            mmtp.url = "";
+            mmtp.mtype = kMmtMediaCI;
+            if(MmtpPop(mmtp)) {
                 cixml->fname = mmtp.fname;
             }
             LOG(INFO) << __func__ << " get xml file=" << cixml->fname;
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index a9cd73c..063660c 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -81,6 +81,8 @@ int64 GetNTPTime();
 /**
  * media/proto constants
  */
+extern const char kMmtNtpServer[];
+
 extern const char kMmtMediaAudio[];
 extern const char kMmtMediaVideo[];
 extern const char kMmtMediaImage[];
@@ -89,6 +91,7 @@ extern const char kMmtMediaCI[];
 
 extern const char kMmtProtoMmtp[];
 extern const char kMmtProtoLocal[];
+extern const char kMmtDefaultUrl[];
 
 }
 
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 342afc8..8e7b3c2 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -6,8 +6,6 @@
 
 namespace mmt {
 
-#define USE_MMTP 1
-
 static const long kMmtMediaSize = 0x7fffffff;
 static const char kMmtLocalAudioPrefix[] = "/audio/loveapartment_Audio1_MPU_";
 static const char kMmtLocalVideoPrefix[] = "/video/loveapartment_Video1_MPU_";
@@ -66,7 +64,6 @@ stream_t* InitMpuStream(Stream* ptr) {
 } // namespace mmt
 
 
-
 namespace mmt {
 
 static MmtpStream* g_mmtp = nullptr;
@@ -85,21 +82,25 @@ void MmtpStop() {
         g_mmtp->StopMmtp();
     }
 }
-bool MmtpPop(std::string key, mmtp_info_t& mmtp) {
+void MmtpOpen(const std::string url) {
     if (g_mmtp) {
-        return g_mmtp->Pop(key, mmtp);
+        g_mmtp->OpenMmtp(url);
+    }
+}
+bool MmtpPop(mmtp_info_t& mmtp) {
+    if (g_mmtp) {
+        return g_mmtp->Pop(mmtp);
     }
     return false;
 }
-void MmtpPush(mmtp_info_t& mmtp) {
+void MmtpPush(const mmtp_info_t& mmtp) {
     if (g_mmtp) {
         g_mmtp->Push(mmtp);
     }
 }
 
 void CIRecvCallback(const char* url, const char* fname, int ftype) {
-    base::FilePath fpath;
-    base::GetCurrentDirectory (&fpath);
+    if (!fname) return;
 
     // for test
     static bool _had_html = false;
@@ -109,68 +110,83 @@ void CIRecvCallback(const char* url, const char* fname, int ftype) {
     _had_html = (ftype == 0);
     _had_ci = (ftype == 1);
 
+    base::FilePath cpath(fname);
+    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
     LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
+    mmtp.fname = kMmtDefaultUrl + fpath.value();
     mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
     MmtpPush(mmtp);
 }
 
 void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    base::FilePath fpath;
-    base::GetCurrentDirectory (&fpath);
+    if (!fname) return;
+    base::FilePath cpath(fname);
+    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
     LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     mmtp_info_t mmtp;
     if (url) mmtp.url = url;
-    if (fname) mmtp.fname = "mmt://localhost" + fpath.value() + "/" + fname;
+    mmtp.fname = kMmtDefaultUrl + fpath.value();
     mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
     MmtpPush(mmtp);
-    LOG(INFO) << __func__ << " END";
 }
 
+mmtp_info_t::mmtp_info_t() {
+    index = -1;
+}
+
+mmtp_media_t::mmtp_media_t() {}
+mmtp_media_t::~mmtp_media_t() {}
+
 MmtpStream::MmtpStream(){
     mmtprun_ = false;
 }
 MmtpStream::~MmtpStream(){
 }
 
-bool MmtpStream::Pop(std::string key, mmtp_info_t& mmtp) {
+bool MmtpStream::Pop(mmtp_info_t& mmtp) {
     if (mlist_.empty()) return false;
 
+    std::string key = mmtp.url + "@" + mmtp.mtype;
     bool isok = false;
+
     lock_.Acquire();
     do {
-        std::map<std::string, mmtp_infos_t>::iterator iter;
+        std::map<std::string, mmtp_media_ptr_t>::iterator iter;
         iter = mlist_.find(key);
         if (iter == mlist_.end()) break;
-        mmtp_infos_t& infos = iter->second;
-        if (infos.empty()) break;
 
-        mmtp = infos.back();
-        infos.pop_back();
+        mmtp_media_ptr_t media = iter->second;
+        if (media->flist.empty()) break;
+
+        mmtp = media->flist.back();
+        media->flist.pop_back();
         isok = true;
     }while(false);
     lock_.Release();
     return isok;
 }
+
 void MmtpStream::Push(const mmtp_info_t& mmtp) {
-    //TODO: should be url, but now testing
-    std::string key = mmtp.mtype;
-    std::map<std::string, mmtp_infos_t>::iterator iter;
+    std::string key = mmtp.url + "@" + mmtp.mtype;
+    std::map<std::string, mmtp_media_ptr_t>::iterator iter;
+
     lock_.Acquire();
     iter = mlist_.find(key);
     if (iter != mlist_.end()) {
-        mmtp_infos_t& infos = iter->second;
-        infos.insert(infos.begin(), mmtp);
+        mmtp_media_ptr_t media = iter->second;
+        media->flist.insert(media->flist.begin(), mmtp);
     }else {
-        mmtp_infos_t infos;
-        infos.push_back(mmtp);
-        mlist_[key] = infos;
+        mmtp_media_ptr_t media = new mmtp_media_t;;
+        media->flist.push_back(mmtp);
+        mlist_[key] = media;
     }
     lock_.Release();
 }
+
 void MmtpStream::StartMmtp() {
     if (mmtprun_) return;
     init_mmtp();
@@ -181,6 +197,11 @@ void MmtpStream::StartMmtp() {
     start_mmtp();
     mmtprun_ = true;
 }
+
+void MmtpStream::OpenMmtp(const std::string url) {
+    open_mmtp(url.c_str());
+}
+
 void MmtpStream::StopMmtp() {
     if (!mmtprun_) return;
     stop_mmtp();
@@ -188,22 +209,22 @@ void MmtpStream::StopMmtp() {
     mmtprun_ = false;
 }
 
+} // namespace mmt
+
+
+namespace mmt {
 
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
     //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
-    midx_.begin = -1;
-    midx_.end = -1;
-    midx_.cur = -1;
-    lasterr_ = 0;
+    ReInit();
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
-    proto_ = kMmtProtoLocal;
-    first_ = true;
+    ReInit();
 }
 
 Stream::~Stream() {
-    Uninit();
+    ReInit();
 }
 
 bool Stream::ParseSequence(int& index) {
@@ -215,25 +236,18 @@ bool Stream::ParseSequence(int& index) {
         std::string proto = GetQueryValue(query, "proto");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range << " proto=" << proto; 
         if (mtype.empty() && proto.empty()) return false;
-        if (!proto.empty()) proto_ = proto;
 
-        mtype_ = mtype;
-        if (mtype == kMmtMediaImage) {
-            index = -2;
-            return true;
-        }
+        if (proto == kMmtProtoMmtp) mtype_ = kMmtMediaHtml;  // default is html for mmtp
+        if (!proto.empty()) proto_ = proto;
+        if (!mtype.empty()) mtype_ = mtype;
 
-        // compute the sequence of media
-        {
+        // compute the sequence of media and get current index
+        if (!range.empty()) {
             GetRangeValue(range, midx_.begin, midx_.end);
             index = midx_.begin;
             LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
             if (index < 0 || midx_.begin > midx_.end) return false;
         }
-
-        if (proto_ == kMmtProtoMmtp) { // for mmtp streaming
-            index = -3;
-        }
     }else { // may be one seperate file, not one media sequence
         index = -1;
     }
@@ -243,13 +257,11 @@ bool Stream::ParseSequence(int& index) {
 int Stream::Prepare(long *size) {
     if (!Open(nullptr, 0)) return lasterr_;
 
-    long lret = kMmtMediaSize;  // TODO: default size for media sequence
-    if (midx_.cur < 0) {        // return real size for single file
-        if (proto_ == kMmtProtoMmtp && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo)) {
-            // for mmtp sequence
-        }else {
-            lret = offmap_[midx_.cur].size; 
-        }
+    long lret = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
+        lret = kMmtMediaSize;
+    }else {
+        lret = offmap_[midx_.cur].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -298,38 +310,36 @@ void* Stream::Open(const char* filename, int mode) {
         return nullptr;
     }
 
-    // default for one seperate file
-    //  index >= 0: media sequence
-    //  index == -1: common file
-    //  index == -2: mp4 image file
-    //  index == -3: mmtp streaming receiver
-    std::string fname = GURL2FilePath(url_);
-    if (index >= 0) { // for media sequence
+    if (index >= 0) { // check index
         if (index < midx_.begin || index > midx_.end)
             return nullptr;
+    }
 
-        std::string mtype = GetQueryValue(url_.query(), "type");
-        if (mtype == kMmtMediaAudio) {
-            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype == kMmtMediaVideo) {
-            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
-        }
-    } else if (index == -3) { // mmtp streaming
+    std::string fname;
+    if (proto_ == kMmtProtoMmtp) { // for mmt streaming
         MmtpStart();
+
         mmtp_info_t mmtp;
-        if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
-            if(!MmtpPop(mtype_, mmtp)) {
-                lasterr_ = -3;
-                return nullptr;
-            }
-        }else {
-            if(!MmtpPop(kMmtMediaHtml, mmtp)) {
-                lasterr_ = -3;
-                return nullptr;
-            }
+        mmtp.url = "";  // TODO: now do not support url in mmtp receiver.
+        mmtp.mtype = mtype_;
+        mmtp.index = index;
+        if(!MmtpPop(mmtp)) {
+            lasterr_ = -3;
+            return nullptr;
         }
         GURL url(mmtp.fname);
         fname = GURL2FilePath(url);
+    }else if (proto_ == kMmtProtoLocal) { // for local media
+        fname = GURL2FilePath(url_);
+        if (mtype_ == kMmtMediaAudio) { 
+            fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype_ == kMmtMediaVideo) {
+            fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
+        }else if (mtype_ == kMmtMediaImage) { // not process
+        }
+    }else {
+        LOG(INFO) << __func__ << " invalid proto=" << proto_;
+        return nullptr;
     }
     LOG(INFO) << __func__ << " fname=" << fname << " index=" << index;
 
@@ -344,17 +354,18 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
-    if ((index != -1 && index != midx_.begin && index != -3) || 
-        (index == -3 && !first_ && (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo))) {
-        long offset = ParseMpu();
-        if (offset == -1) return nullptr;
-        offmap_[index] = offset_t(offset, lret);
-        ierr = fseek(file_, offset, SEEK_SET);
-        if (ierr != 0) return nullptr; 
-    }else { // the 1st seq file or single file
-        offmap_[index] = offset_t(0, lret);
-        if (index == -3) first_ = false;
+    long offset = 0;
+    if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo || mtype_ == kMmtMediaImage) {
+        if (mtype_ == kMmtMediaImage || !first_) {
+            offset = ParseMpu();
+            if (offset == -1) return nullptr;
+            ierr = fseek(file_, offset, SEEK_SET);
+            if (ierr != 0) return nullptr; 
+        }
     }
+    offmap_[index] = offset_t(offset, lret);
+    if(first_) first_ = false;
+
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
 
@@ -399,11 +410,14 @@ int Stream::Close() {
     return 0;
 }
 
-void Stream::Uninit() {
+void Stream::ReInit() {
     Close();
+    proto_ = kMmtProtoLocal;
     midx_.begin = -1;
     midx_.end = -1;
     midx_.cur = -1;
+    first_ = true;
+    lasterr_ = 0;
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 673eaf4..3c570ea 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -51,11 +51,21 @@ namespace mmt {
  * Mmtp information
  */
 struct mmtp_info_t {
+    mmtp_info_t();
     std::string url;
     std::string mtype; // "audio"/"video"/"image"/"ci"/"html" 
     std::string fname;
+    int index;
 };
-typedef std::vector<mmtp_info_t> mmtp_infos_t;
+struct mmtp_media_t : public base::RefCounted<mmtp_media_t>{
+    mmtp_media_t();
+    std::vector<mmtp_info_t> flist;
+
+protected:
+    friend class base::RefCounted<mmtp_media_t>;
+    virtual ~mmtp_media_t();
+};
+typedef scoped_refptr<mmtp_media_t> mmtp_media_ptr_t;
 
 /**
  * mmtp resource: audio/video/image/
@@ -65,23 +75,32 @@ public:
     MmtpStream();
     virtual ~MmtpStream();
 
-    bool Pop(std::string key, mmtp_info_t& mmtp);
+    /**
+     * @param mmtp: [in] should contain mtype and url, [out] return fname
+     */
+    bool Pop(mmtp_info_t& mmtp);
+
+    /**
+     * @param mmtp: [in] should contain mtype, url and fname
+     */
     void Push(const mmtp_info_t& mmtp);
+
     // for mmtp control
     void StartMmtp();
     void StopMmtp();
+    void OpenMmtp(const std::string url);
 
 private:
     bool mmtprun_;
     base::Lock lock_;
-    std::map<std::string, mmtp_infos_t> mlist_; // url => ..
+    std::map<std::string, mmtp_media_ptr_t> mlist_; // url@mtype => ..
 };
-typedef scoped_refptr<MmtpStream> MmtpStreamPtr;
 
 void MmtpStart();
 void MmtpStop();
-bool MmtpPop(std::string key, mmtp_info_t& mmtp);
-void MmtpPush(mmtp_info_t& mmtp);
+void MmtpOpen(const std::string url);
+bool MmtpPop(mmtp_info_t& mmtp);
+void MmtpPush(const mmtp_info_t& mmtp);
 
 
 /**
@@ -144,7 +163,7 @@ public:
     bool ParseSequence(int& index);
     long ParseMpu();
     std::string GetProto() { return proto_;}
-    void Uninit();
+    void ReInit();
 
 protected:
     friend class base::RefCounted<Stream>;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 915b66b..3189615 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -5,7 +5,7 @@
 namespace mmt {
 
 #define USE_NTP_TIME 1
-static const char kMmtNtpServer[] = "time.apple.com";
+const char kMmtNtpServer[] = "time.apple.com";
 
 const char kMmtMediaAudio[] = "audio";
 const char kMmtMediaVideo[] = "video";
@@ -15,6 +15,7 @@ const char kMmtMediaCI[] = "ci";
 
 const char kMmtProtoMmtp[] = "mmtp";
 const char kMmtProtoLocal[] = "local";
+const char kMmtDefaultUrl[] = "mmt://localhost";
 
 
 void Wait(int ms) {
-- 
1.7.9.5


From fe15a0adbdf4d58d213aca45965d45aecf20c34c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 9 Feb 2015 23:10:43 +0800
Subject: [PATCH 092/128] [ok] refine mmtp's callback

---
 net/mmt/mmt_stream.cc |   77 ++++++++++++++++++++-----------------------------
 net/mmt/mmtp/client.c |   28 ++++++++++--------
 net/mmt/mmtp/mmt.c    |    6 +---
 net/mmt/mmtp/mmtp.h   |   38 +++++++++++++++++-------
 4 files changed, 76 insertions(+), 73 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 8e7b3c2..563a8c9 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -72,65 +72,53 @@ void MmtpStart() {
     if (!g_mmtp) {
         g_mmtp = new MmtpStream;
     }
-
-    if (g_mmtp) {
-        g_mmtp->StartMmtp();
-    }
+    g_mmtp->StartMmtp();
 }
 void MmtpStop() {
-    if (g_mmtp) {
-        g_mmtp->StopMmtp();
-    }
+    if (!g_mmtp) return;
+    g_mmtp->StopMmtp();
 }
 void MmtpOpen(const std::string url) {
-    if (g_mmtp) {
-        g_mmtp->OpenMmtp(url);
-    }
+    if (!g_mmtp) return;
+    g_mmtp->OpenMmtp(url);
 }
 bool MmtpPop(mmtp_info_t& mmtp) {
-    if (g_mmtp) {
-        return g_mmtp->Pop(mmtp);
-    }
-    return false;
+    if (!g_mmtp) return false;
+    return g_mmtp->Pop(mmtp);
 }
 void MmtpPush(const mmtp_info_t& mmtp) {
-    if (g_mmtp) {
-        g_mmtp->Push(mmtp);
-    }
+    if (!g_mmtp) return;
+    g_mmtp->Push(mmtp);
 }
 
-void CIRecvCallback(const char* url, const char* fname, int ftype) {
-    if (!fname) return;
+void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
+    if (!rinfo) return;
 
     // for test
-    static bool _had_html = false;
-    static bool _had_ci = false;
-    if (ftype == 0 && _had_html) return;
-    if (ftype == 1 && _had_ci) return;
-    _had_html = (ftype == 0);
-    _had_ci = (ftype == 1);
-
-    base::FilePath cpath(fname);
-    base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
-
-    mmtp_info_t mmtp;
-    if (url) mmtp.url = url;
-    mmtp.fname = kMmtDefaultUrl + fpath.value();
-    mmtp.mtype = (ftype==0) ? kMmtMediaHtml : kMmtMediaCI;
-    MmtpPush(mmtp);
-}
+    std::string mtype;
+    int ftype = rinfo->ftype;
+    if(rinfo->res & Res_Signal) {
+        static bool _had_html = false;
+        static bool _had_ci = false;
+        if (ftype == 0 && _had_html) return;
+        if (ftype == 1 && _had_ci) return;
+        _had_html = (ftype == 0);
+        _had_ci = (ftype == 1);
+        mtype = (ftype == 0) ? kMmtMediaHtml : kMmtMediaCI;
+    }else if (rinfo->res & Res_Media){
+        mtype = (ftype == 2) ? kMmtMediaVideo : kMmtMediaAudio;
+    }else {
+        return;
+    }
 
-void MPURecvCallback(const char* url, const char* fname, int ftype) {
-    if (!fname) return;
-    base::FilePath cpath(fname);
+    base::FilePath cpath(rinfo->fname);
     base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
-    LOG(INFO) << __func__ << " fname=" << fname << " ftype=" << ftype << " fpath=" << fpath.value();
+    LOG(INFO) << __func__ << " fname=" << rinfo->fname << " ftype=" << ftype << " fpath=" << fpath.value();
 
     mmtp_info_t mmtp;
-    if (url) mmtp.url = url;
+    mmtp.url = rinfo->url;
     mmtp.fname = kMmtDefaultUrl + fpath.value();
-    mmtp.mtype = (ftype==2) ? kMmtMediaVideo : kMmtMediaAudio;
+    mmtp.mtype = mtype;
     MmtpPush(mmtp);
 }
 
@@ -190,10 +178,7 @@ void MmtpStream::Push(const mmtp_info_t& mmtp) {
 void MmtpStream::StartMmtp() {
     if (mmtprun_) return;
     init_mmtp();
-    mmtp_callback_t cb;
-    cb.cifunc = CIRecvCallback;
-    cb.mpufunc = MPURecvCallback;
-    set_mmtp_callback(&cb);
+    set_mmtp_callback(MmtpRecvCallback);
     start_mmtp();
     mmtprun_ = true;
 }
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 0ad507d..99be27e 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -733,10 +733,8 @@ void *mpu_consumer_f(void *arg)						/**/
 									fclose(mpu);
 									free_mpu_buf(&mpu_buf );
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
 
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 								}
 //								free(mfu_buf);
 //								if(ringq_poll(p_queue,&recive_mfu)>=0);
@@ -886,9 +884,7 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 
 								}
 								//,,
@@ -946,9 +942,7 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    if (g_mmtp_cb.mpufunc) {
-                                        g_mmtp_cb.mpufunc(NULL, mpu_filename, mpu_header.FT);
-                                    }
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
 								}
 
 							}
@@ -973,7 +967,7 @@ void init_mmtp() {
 	mpu_buff_list=InitList();
 	pthread_mutex_init (&signal_mutex,NULL);
 	pthread_mutex_init (&mpu_mutex,NULL);
-    memset(&g_mmtp_cb, 0, sizeof(g_mmtp_cb));
+    g_mmtp_cb = NULL;
 }
 
 void start_mmtp() {
@@ -1006,7 +1000,17 @@ void uninit_mmtp() {
     DestroyList(mpu_buff_list);
 }
 
-void set_mmtp_callback(mmtp_callback_t* mmtp_cb) {
-    g_mmtp_cb = *mmtp_cb;
+void set_mmtp_callback(mmtp_callback_t cb) {
+    g_mmtp_cb = cb;
 }
 
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype) {
+    if (!g_mmtp_cb) return;
+    struct mmtp_rinfo_t rinfo;
+    memset(&rinfo, 0, sizeof(rinfo));
+    rinfo.res = res;
+    strncpy(rinfo.url, url, sizeof(rinfo.url));
+    strncpy(rinfo.fname, fname, sizeof(rinfo.fname));
+    rinfo.ftype = ftype;
+    g_mmtp_cb(&rinfo);
+}
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
index 2188743..bf813e1 100644
--- a/net/mmt/mmtp/mmt.c
+++ b/net/mmt/mmtp/mmt.c
@@ -24,8 +24,6 @@
 #include "send.h"
 #include "mmtp.h"
 
-extern mmtp_callback_t g_mmtp_cb;
-
 int get_send_timestamp()
 {
 	int MMT_timestamp;
@@ -1060,9 +1058,7 @@ int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
 			fclose(mpi);
 
 			printf("finished recive a ci - %d - %s\n", i, (const char *)mpi_table->PI_content[i].PI_content_name_byte);
-            if (g_mmtp_cb.cifunc) {
-                g_mmtp_cb.cifunc(NULL, (const char *)mpi_table->PI_content[i].PI_content_name_byte, i);
-            }
+            push_mmtp_rinfo(Res_Signal, "", (char *)mpi_table->PI_content[i].PI_content_name_byte, i);
         }
 	 return 0;
 
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index dd2099c..140fb3b 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -11,16 +11,34 @@ void open_mmtp(const char* url);
 void stop_mmtp();
 void uninit_mmtp();
 
-// for ci.xml and index.html
-typedef void (*mmtp_ci_func_t) (const char* url, const char* fname, int ftype);
-// for audio, video and image
-typedef void (*mmtp_mpu_func_t) (const char* url, const char* fname, int ftype);
-typedef struct mmtp_callback_t {
-    mmtp_ci_func_t cifunc;
-    mmtp_mpu_func_t mpufunc;
-}mmtp_callback_t;
-
-void set_mmtp_callback(mmtp_callback_t* mmtp_cb);
+enum mmtp_res_t {
+    Res_Unknown   = 0,
+    Res_CI        = 0x1,
+    Res_Html      = 0x2,
+    Res_Signal    = Res_CI + Res_Html,
+
+    Res_Video     = 0x4,
+    Res_Audio     = 0x8,
+    Res_Image     = 0x10,
+    Res_Media     = Res_Video + Res_Audio + Res_Image,
+};
+
+// info of recv data
+struct mmtp_rinfo_t {
+    int  res;      //> mmtp_res_t
+    char url[1024];
+    char fname[1024];
+    int  ftype;
+};
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype);
+
+/**
+ * for ci.xml and index.html
+ * for audio, video and image
+ */
+typedef void (*mmtp_callback_t) (struct mmtp_rinfo_t* rinfo);
+
+void set_mmtp_callback(mmtp_callback_t cb);
 
 #ifdef __cplusplus
 }
-- 
1.7.9.5


From 961d7a4b259fae7d353a65e5387cb214e22e1701 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 10 Feb 2015 23:17:16 +0800
Subject: [PATCH 093/128] [todo] support clip

---
 net/mmt/mmt_control.cc |   35 ++++++++++-----
 net/mmt/mmt_inc.h      |    7 ++-
 net/mmt/mmt_parser.cc  |   69 +++++++++++++++++++++++++++---
 net/mmt/mmt_parser.h   |    5 +++
 net/mmt/mmt_stream.cc  |  111 ++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_stream.h   |   26 +++++++++---
 net/mmt/mmt_utils.cc   |   35 +++++++++++++--
 7 files changed, 228 insertions(+), 60 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 9d2c786..88443f4 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -156,17 +156,32 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
 
     // TODO: for local file testing
     long lsize = -1;
-    StreamPtr stream = new Stream(msg.url);
-    streams_[key] = stream;
-    if(stream->Prepare(&lsize) == -3) { // waiting
-        LOG(INFO) << __func__ << " waiting...";
-        Push(msg);
-        Wait(100);
-        return;
-    }else {
-        if (msg.sinfo.func) {
-            msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
+    do {
+        StreamPtr stream = new Stream(msg.url);
+        if (!stream->Init()) break;
+
+        if (stream->IsMmtMedia()) {
+            if (cixmls_.find(msg.tabid) == cixmls_.end()) {
+                cixmlptr_t cixml = cixmls_[msg.tabid];
+                if (cixml->parser) {
+                    std::string clip;
+                    clip = cixml->parser->GetHtmlClip(stream->GetHtmlId());
+                    stream->SetHtmlClip(clip);
+                }
+            } 
+        }
+
+        streams_[key] = stream;
+        if(stream->Prepare(&lsize) == -3) { // waiting
+            LOG(INFO) << __func__ << " waiting...";
+            Push(msg);
+            Wait(100);
+            return;
         }
+    }while(false);
+    
+    if (msg.sinfo.func) {
+        msg.sinfo.func(msg.ptr, msg.sinfo, lsize);
     }
 }
 void MmtControl::StreamRead(ctrl_msg_t msg) {
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 063660c..ba2f899 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -4,6 +4,7 @@
 #include <string>
 #include <sstream>
 #include <iomanip>
+#include <vector>
 
 #include "base/logging.h"
 #include "base/values.h"
@@ -65,7 +66,8 @@ std::string GetQueryValue(std::string query, std::string key);
 /**
  * Parse models with n1-n2, n1-.
  */
-bool GetRangeValue(std::string range, int &lval, int &rval);
+bool GetRangeValue(std::string range, std::pair<int,int>& item);
+bool GetClipValue(std::string clip, std::vector<std::pair<int,int> >& items);
 
 /**
  * Send to some host with msg over UDP
@@ -93,6 +95,9 @@ extern const char kMmtProtoMmtp[];
 extern const char kMmtProtoLocal[];
 extern const char kMmtDefaultUrl[];
 
+// for url query
+extern const char kMmtHtmlId[];
+
 }
 
 #endif
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 1d522e0..2540498 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -15,7 +15,7 @@ static const char kNoValue[] = "no-value";
  */
 static const char kCI[]             = "CI";
 static const char kview[]           = "view";
-static const char kdivLocation[]    = "divLocation";
+static const char kdivLocation[]    = "area";
 static const char kMediaSync[]      = "MediaSync";
 static const char ksourceList[]     = "sourceList";
 
@@ -30,6 +30,9 @@ static const char kmediaSrc[]   = "mediaSrc";
 static const char kbegin[]      = "begin";
 static const char kend[]        = "end";
 static const char kstyle[]      = "style";
+static const char kclipBegin[]  = "clipBegin";
+static const char kclipEnd[]    = "clipEnd";
+static const char kclipList[]   = "clipList";
 
 /**
  * Event constatnts for the value of kbegin and kend
@@ -197,6 +200,7 @@ bool CiParser::ParseXml() {
     ctxt->_private = (void *)this;
 
     StreamPtr stream = new Stream(fname_);
+    if (!stream->Init()) return false;
     if (stream->Prepare(nullptr) != 0) return false;
 
     int num;
@@ -209,6 +213,18 @@ bool CiParser::ParseXml() {
     return true;
 }
 
+static std::string GetMediaSrc(std::string src, std::string id) {
+    if (src.empty() || id.empty()) return "";
+    std::string url = src;
+    if(src.find("?") == std::string::npos) {
+        url += "?";
+    }else {
+        url += "&";
+    }
+    url = url + kMmtHtmlId + "=" + id;
+    return url;
+}
+
 static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
     if (!node) return;
 
@@ -238,7 +254,10 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
         for (; iter != node->nodes.end(); iter++) {
             nodeptr_t sub = *iter;
             if (sub->name != ksourceList) continue;
-            std::string src = sub->attrs[kmediaSrc];
+            if (sub->attrs.find(kmediaSrc) == sub->attrs.end()) continue;
+            std::string src = GetMediaSrc(sub->attrs[kmediaSrc], id);
+            if (src.empty()) continue;
+
             js0 += SetJSAttr(id, "src", src);
             js1 += SetJSAttr(id, "src", "");
             bfind = true;
@@ -247,10 +266,12 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
 
         if (!bfind) {
             if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
-                std::string src = node->attrs[kmediaSrc];
-                js0 += SetJSAttr(id, "src", src);
-                js1 += SetJSAttr(id, "src", "");
-                bfind = true;
+                std::string src = GetMediaSrc(node->attrs[kmediaSrc], id);
+                if (!src.empty()) {
+                    js0 += SetJSAttr(id, "src", src);
+                    js1 += SetJSAttr(id, "src", "");
+                    bfind = true;
+                }
             }
         }
 
@@ -584,6 +605,42 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
     return true;
 }
 
+std::string CiParser::GetHtmlClip(std::string id) {
+    if (htmls_.find(id) == htmls_.end()) return "";
+    htmlptr_t html = htmls_[id];
+    nodeptr_t node = html->node;
+    if (!node) return "";
+
+    std::string clip;
+    std::string begin, end;
+
+    attrs_t::iterator iter;
+    iter = node->attrs.find(kclipBegin);
+    if (iter != node->attrs.end()) {
+        begin = iter->second;
+    }
+    iter = node->attrs.find(kclipEnd);
+    if (iter != node->attrs.end()) {
+        end = iter->second;
+    }
+
+    if (!begin.empty() || !end.empty()) {
+        if (!begin.empty()) clip += begin;       
+        clip += "-";
+        if (!end.empty()) clip += end;
+    }else {
+        std::string list;
+        iter = node->attrs.find(kclipList);
+        if (iter != node->attrs.end()) {
+            list = iter->second;
+        }
+        if (!list.empty()) {
+            clip = list;
+        }
+    }
+    return clip;
+}
+
 bool CiParser::AddNode(std::string name) {
     LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index ef97783..76e202d 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -127,6 +127,11 @@ public:
     std::string GetVersion() {return version_;}
 
     /**
+     * Get Html tag's clip info
+     */
+    std::string GetHtmlClip(std::string id);
+
+    /**
      * To parse xml's node and its attr
      */
     bool AddNode(std::string name);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 563a8c9..2161ff7 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -200,53 +200,59 @@ void MmtpStream::StopMmtp() {
 namespace mmt {
 
 Stream::Stream(const GURL &url) : url_(url), file_(nullptr) { 
-    //LOG(INFO) << "Stream::Stream" << ", thiz=" << this << ", url=" << url_;
-    ReInit();
 }
 
 Stream::Stream(const std::string& szurl) : url_(szurl), file_(nullptr) {
-    ReInit();
 }
 
 Stream::~Stream() {
-    ReInit();
+    Uninit();
 }
 
-bool Stream::ParseSequence(int& index) {
+bool Stream::ParseSequence() {
     // if exists query in URL, then should redirect to real filename
     std::string query = url_.query();
     if (!query.empty()) { // media sequence
         std::string mtype = GetQueryValue(query, "type");
         std::string range = GetQueryValue(query, "sequence_num");
         std::string proto = GetQueryValue(query, "proto");
-        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range << " proto=" << proto; 
-        if (mtype.empty() && proto.empty()) return false;
+        std::string htmlid = GetQueryValue(query, kMmtHtmlId);
+        LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range 
+            << " proto=" << proto << " htmlid=" << htmlid; 
 
+        if (htmlid.empty()) return false;
+        if (mtype.empty() && proto.empty()) return false;
         if (proto == kMmtProtoMmtp) mtype_ = kMmtMediaHtml;  // default is html for mmtp
         if (!proto.empty()) proto_ = proto;
         if (!mtype.empty()) mtype_ = mtype;
+        htmlid_ = htmlid;
 
         // compute the sequence of media and get current index
         if (!range.empty()) {
-            GetRangeValue(range, midx_.begin, midx_.end);
-            index = midx_.begin;
-            LOG(INFO) << __func__ << " range begin=" << midx_.begin << " end=" << midx_.end;
-            if (index < 0 || midx_.begin > midx_.end) return false;
+            if(!GetRangeValue(range, idxurl_)) return false;
+            LOG(INFO) << __func__ << " range begin=" << idxurl_.first << " end=" << idxurl_.second;
         }
-    }else { // may be one seperate file, not one media sequence
-        index = -1;
+    }
+    return true;
+}
+
+bool Stream::SetHtmlClip(std::string clip) {
+    if (!clip.empty()) {
+        idxclip_.clear();
+        if (!GetClipValue(clip, idxclip_)) return false;
     }
     return true;
 }
 
 int Stream::Prepare(long *size) {
+    NextIndex();
     if (!Open(nullptr, 0)) return lasterr_;
 
     long lret = 0;
     if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
         lret = kMmtMediaSize;
     }else {
-        lret = offmap_[midx_.cur].size; 
+        lret = offmap_[idxcur_].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -284,22 +290,50 @@ long Stream::ParseMpu() {
     return offset;
 }
 
+void Stream::NextIndex() {
+    int index = idxcur_;
+    if (idxcur_ < 0) { // first
+        if (!idxclip_.empty()) index = idxclip_[0].first;
+        if (index < 0) index = idxurl_.first;
+    }else {
+        index++;
+        if (idxurl_.first >= 0 && idxurl_.first <= idxurl_.second) {
+            if (index < idxurl_.first || index > idxurl_.second) 
+                return;
+        }
+
+        // find the last scope
+        int pos = -1;
+        std::vector<std::pair<int,int> >::iterator iter = idxclip_.begin();
+        for (int loop=0; iter != idxclip_.end(); iter++, loop++) {
+            if (index-1 >= iter->first && index-1 <= iter->second) {
+                pos = loop;
+            }
+        }
+
+        if (pos >= 0) {
+            for (; pos < (int)idxclip_.size(); pos++) {
+                std::pair<int,int> item = idxclip_[pos];
+                if (index < item.first) {
+                    index = item.first;
+                    break; 
+                }else if (index >= item.first && index <= item.second) {
+                    break;
+                }
+            }
+        }
+    }
+    idxcur_ = index;
+}
+
 void* Stream::Open(const char* filename, int mode) {
     lasterr_ = 0;
     if (file_) return (void *)file_;
 
     lasterr_ = -2;
-    int index = midx_.cur;
-    if(index < 0 && !ParseSequence(index)) {
-        LOG(ERROR) << " fail to ParseSequence, query=" << url_.query();
-        return nullptr;
-    }
-
-    if (index >= 0) { // check index
-        if (index < midx_.begin || index > midx_.end)
-            return nullptr;
-    }
+    if (!init_) return nullptr;
 
+    int index = idxcur_;
     std::string fname;
     if (proto_ == kMmtProtoMmtp) { // for mmt streaming
         MmtpStart();
@@ -314,7 +348,7 @@ void* Stream::Open(const char* filename, int mode) {
         }
         GURL url(mmtp.fname);
         fname = GURL2FilePath(url);
-    }else if (proto_ == kMmtProtoLocal) { // for local media
+    }else if (proto_ == kMmtProtoLocal) { // for local media: audio/video/image/html/xml
         fname = GURL2FilePath(url_);
         if (mtype_ == kMmtMediaAudio) { 
             fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
@@ -353,8 +387,6 @@ void* Stream::Open(const char* filename, int mode) {
 
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
-
-    midx_.cur = index;
     lasterr_ = 0;
     return (void *)file_;
 }
@@ -365,7 +397,7 @@ int Stream::Read(void *buf, int size) {
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
         Close();
-        if (midx_.cur >= 0) midx_.cur++; // goto next file if it is media sequence
+        NextIndex();
     }
     return iret; 
 }
@@ -395,14 +427,27 @@ int Stream::Close() {
     return 0;
 }
 
-void Stream::ReInit() {
+void Stream::Uninit() {
     Close();
+}
+
+bool Stream::Init() {
+    lasterr_ = 0;
+    idxcur_ = -1;
+    idxurl_.first = -1;
+    idxurl_.second = -1;
+
+    mtype_ = "";
     proto_ = kMmtProtoLocal;
-    midx_.begin = -1;
-    midx_.end = -1;
-    midx_.cur = -1;
+    htmlid_ = "";
     first_ = true;
-    lasterr_ = 0;
+    init_ = false;
+
+    init_ = ParseSequence();
+    return init_;
+}
+bool Stream::IsMmtMedia() {
+    return (!htmlid_.empty() && !mtype_.empty());
 }
 
 } // namespace mmt
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 3c570ea..7c85527 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -113,6 +113,7 @@ struct triple_t {
     int cur;
 };
 
+
 /**
  * stream read offset/size
  */
@@ -160,10 +161,17 @@ public:
      * if success, set size with the data length
      */
     int Prepare(long* size);
-    bool ParseSequence(int& index);
+
+    bool Init();
+    void Uninit();
+    bool IsMmtMedia();
     long ParseMpu();
-    std::string GetProto() { return proto_;}
-    void ReInit();
+    bool ParseSequence();
+    void NextIndex();
+
+    std::string GetProto() {return proto_;}
+    std::string GetHtmlId() {return htmlid_;}
+    bool SetHtmlClip(std::string clip);
 
 protected:
     friend class base::RefCounted<Stream>;
@@ -173,11 +181,17 @@ private:
     GURL url_;
     std::string mtype_;
     std::string proto_;
-    triple_t midx_; //> cur: current seq, begin: minimum seq, end: maximum seq
-    std::map<int, offset_t> offmap_; //> read offset for current media index
-    FILE *file_;
+    std::string htmlid_;
+
     int lasterr_;
     bool first_;
+    bool init_;
+
+    int idxcur_; //> current media index
+    std::pair<int,int> idxurl_; //> idx range from url
+    std::vector<std::pair<int,int> > idxclip_; // idx range from ci xml
+    std::map<int, offset_t> offmap_; //> read offset for current media index
+    FILE *file_;
 
     DISALLOW_COPY_AND_ASSIGN(Stream);
 };
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 3189615..e2744d8 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -17,6 +17,8 @@ const char kMmtProtoMmtp[] = "mmtp";
 const char kMmtProtoLocal[] = "local";
 const char kMmtDefaultUrl[] = "mmt://localhost";
 
+const char kMmtHtmlId[] = "htmlid";
+
 
 void Wait(int ms) {
     base::PlatformThread::Sleep(base::TimeDelta::FromMilliseconds(ms));
@@ -67,20 +69,45 @@ std::string GetQueryValue(std::string query, std::string key) {
     return value;
 }
 
-bool GetRangeValue(std::string range, int &lval, int &rval) {
+bool GetRangeValue(std::string range, std::pair<int,int>& item) {
+    if (range.empty()) return false;
+
     bool bok = false;
     std::string lstr = "0";
     std::string rstr = "9999999";
     int begin = range.find("-");
-    if (begin >= 0) {
+    if (begin >= 0) { // two element
         lstr = range.substr(0, begin);
         if (lstr.empty()) lstr = "-1";
         rstr = range.substr(begin+1, range.size()-begin);
         if (rstr.empty()) rstr = "9999999";
         bok = true;
+    }else { // one element
+        lstr = range;
+        rstr = range;
     }
-    lval = String2Int(lstr);
-    rval = String2Int(rstr);
+    item.first = String2Int(lstr);
+    item.second = String2Int(rstr);
+    if (item.first < 0 || item.first > item.second) bok = false;
+    return bok;
+}
+
+bool GetClipValue(std::string clip, std::vector<std::pair<int,int> >& items) {
+    if (clip.empty()) return false;
+
+    bool bok = false;
+    do {
+        std::pair<int, int> item;
+        int pos = clip.find(",");
+        if (pos < 0) {
+            bok = GetRangeValue(clip, item);
+            clip = "";
+        }else {
+            bok = GetRangeValue(clip.substr(0, pos), item);
+            clip = clip.substr(pos+1);
+        }
+        if (bok)  items.push_back(item);
+    }while(!clip.empty() && bok);
     return bok;
 }
 
-- 
1.7.9.5


From a59bf6f919ac2601cb9f9783eb395045294c27ce Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 01:01:51 +0800
Subject: [PATCH 094/128] [todo] support clipBegin and clipEnd

---
 net/mmt/mmt_control.cc |   10 ++++++++--
 net/mmt/mmt_parser.cc  |   18 ++++++++++--------
 net/mmt/mmt_parser.h   |    2 ++
 net/mmt/mmt_stream.cc  |   49 +++++++++++++++++++++++++++++++++---------------
 net/mmt/mmt_stream.h   |    6 ++++--
 net/mmt/mmt_utils.cc   |    1 +
 6 files changed, 59 insertions(+), 27 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 88443f4..76fc706 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -161,9 +161,13 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
         if (!stream->Init()) break;
 
         if (stream->IsMmtMedia()) {
-            if (cixmls_.find(msg.tabid) == cixmls_.end()) {
-                cixmlptr_t cixml = cixmls_[msg.tabid];
+            int tabid = stream->GetTabId();
+            LOG(INFO) << __func__ << " is mmt media, tabid=" << tabid;
+            if (cixmls_.find(tabid) != cixmls_.end()) {
+                LOG(INFO) << __func__ << " find cixml";
+                cixmlptr_t cixml = cixmls_[tabid];
                 if (cixml->parser) {
+                    LOG(INFO) << __func__ << " find xml parser";
                     std::string clip;
                     clip = cixml->parser->GetHtmlClip(stream->GetHtmlId());
                     stream->SetHtmlClip(clip);
@@ -267,6 +271,7 @@ void MmtControl::CheckEvent() {
         }else if (cixml->status == "loaded") {
             if (!cixml->parser) { // first load
                 cixml->parser = new CiParser(xml_name);
+                cixml->parser->SetTabId(iter->first);
                 if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
                     LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
                     cixml->parser = nullptr;
@@ -288,6 +293,7 @@ void MmtControl::CheckEvent() {
                         << " new timestamp=" << timestamp2 << " version=" << version2;
 
                     if (ntp >= timestamp2 && timestamp < timestamp2) {
+                        parser2->SetTabId(iter->first);
                         if(parser2->ParseHtml()) {
                             parser2->MergeCI(cixml->parser.get());
                             cixml->parser = parser2;
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 2540498..122415f 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -176,6 +176,7 @@ html_t::~html_t() {
 
 CiParser::CiParser(const std::string& fname) 
     : fname_(fname), root_(nullptr), cur_(nullptr) {
+    tabid_ = 0;
     timestamp_ = 0;
 }
 
@@ -213,7 +214,7 @@ bool CiParser::ParseXml() {
     return true;
 }
 
-static std::string GetMediaSrc(std::string src, std::string id) {
+static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
     if (src.empty() || id.empty()) return "";
     std::string url = src;
     if(src.find("?") == std::string::npos) {
@@ -221,11 +222,11 @@ static std::string GetMediaSrc(std::string src, std::string id) {
     }else {
         url += "&";
     }
-    url = url + kMmtHtmlId + "=" + id;
+    url = url + kMmtHtmlId+"="+id + "&tabid="+Int2String(tabid);
     return url;
 }
 
-static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
+static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     if (!node) return;
 
     std::string id;
@@ -255,7 +256,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
             nodeptr_t sub = *iter;
             if (sub->name != ksourceList) continue;
             if (sub->attrs.find(kmediaSrc) == sub->attrs.end()) continue;
-            std::string src = GetMediaSrc(sub->attrs[kmediaSrc], id);
+            std::string src = GetMediaSrc(sub->attrs[kmediaSrc], id, tabid);
             if (src.empty()) continue;
 
             js0 += SetJSAttr(id, "src", src);
@@ -266,7 +267,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls) {
 
         if (!bfind) {
             if (node->attrs.find(kmediaSrc) != node->attrs.end()) {
-                std::string src = GetMediaSrc(node->attrs[kmediaSrc], id);
+                std::string src = GetMediaSrc(node->attrs[kmediaSrc], id, tabid);
                 if (!src.empty()) {
                     js0 += SetJSAttr(id, "src", src);
                     js1 += SetJSAttr(id, "src", "");
@@ -321,15 +322,15 @@ bool CiParser::ParseHtml() {
                 nodeptr_t sub2 = *iter2;
                 if (sub2->name == kdivLocation) {
                     LOG(INFO) << __func__ << " process view's " << kdivLocation;
-                    InitHtmlJS(sub2, htmls_);
+                    InitHtmlJS(sub2, htmls_, tabid_);
                 }
             }
         }else if (sub1->name == kdivLocation) { // krefDiv of <div>
             LOG(INFO) << __func__ << " process top " << sub1->name;
-            InitHtmlJS(sub1, htmls_);
+            InitHtmlJS(sub1, htmls_, tabid_);
         }else if (sub1->name == kMediaSync) {   // krefId of <img>, <audio>, <video>
             LOG(INFO) << __func__ << " process top " << sub1->name;
-            InitHtmlJS(sub1, htmls_);
+            InitHtmlJS(sub1, htmls_, tabid_);
         }
     }
 
@@ -606,6 +607,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
 }
 
 std::string CiParser::GetHtmlClip(std::string id) {
+    LOG(INFO) << __func__ << " get tag id=" << id;
     if (htmls_.find(id) == htmls_.end()) return "";
     htmlptr_t html = htmls_[id];
     nodeptr_t node = html->node;
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 76e202d..40410e6 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -105,6 +105,7 @@ public:
      *  So it should be called after ParseXml().
      */
     bool ParseHtml();
+    void SetTabId(int tabid) {tabid_=tabid;}
 
     /**
      * To Merge another parser
@@ -153,6 +154,7 @@ private:
     nodeptr_t cur_;     //> only work for AddNode/AddAttr
     htmlmap_t htmls_;   //> html tags
 
+    int tabid_;
     std::string version_;
     int64 timestamp_;
 };
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 2161ff7..89239f5 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -217,6 +217,7 @@ bool Stream::ParseSequence() {
         std::string range = GetQueryValue(query, "sequence_num");
         std::string proto = GetQueryValue(query, "proto");
         std::string htmlid = GetQueryValue(query, kMmtHtmlId);
+        std::string tabid = GetQueryValue(query, "tabid");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range 
             << " proto=" << proto << " htmlid=" << htmlid; 
 
@@ -225,6 +226,7 @@ bool Stream::ParseSequence() {
         if (proto == kMmtProtoMmtp) mtype_ = kMmtMediaHtml;  // default is html for mmtp
         if (!proto.empty()) proto_ = proto;
         if (!mtype.empty()) mtype_ = mtype;
+        if (!tabid.empty()) tabid_ = String2Int(tabid);
         htmlid_ = htmlid;
 
         // compute the sequence of media and get current index
@@ -237,22 +239,25 @@ bool Stream::ParseSequence() {
 }
 
 bool Stream::SetHtmlClip(std::string clip) {
+    LOG(INFO) << __func__ << " clip=" << clip;
     if (!clip.empty()) {
         idxclip_.clear();
-        if (!GetClipValue(clip, idxclip_)) return false;
+        if (!GetClipValue(clip, idxclip_)) {
+            LOG(INFO) << __func__ << " fail to parse clip=" << clip;
+            return false;
+        }
     }
     return true;
 }
 
 int Stream::Prepare(long *size) {
-    NextIndex();
     if (!Open(nullptr, 0)) return lasterr_;
 
     long lret = 0;
     if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
         lret = kMmtMediaSize;
     }else {
-        lret = offmap_[idxcur_].size; 
+        lret = offmap_[idxcur_.second].size; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
@@ -290,40 +295,43 @@ long Stream::ParseMpu() {
     return offset;
 }
 
-void Stream::NextIndex() {
-    int index = idxcur_;
-    if (idxcur_ < 0) { // first
-        if (!idxclip_.empty()) index = idxclip_[0].first;
+bool Stream::CheckIndex(int last, int& index) {
+    if (last < 0) { // first time
         if (index < 0) index = idxurl_.first;
+        if (!idxclip_.empty()) index = idxclip_[0].first;
     }else {
-        index++;
         if (idxurl_.first >= 0 && idxurl_.first <= idxurl_.second) {
-            if (index < idxurl_.first || index > idxurl_.second) 
-                return;
+            if (index < idxurl_.first || index > idxurl_.second) {
+                return false;
+            }
         }
 
         // find the last scope
         int pos = -1;
         std::vector<std::pair<int,int> >::iterator iter = idxclip_.begin();
         for (int loop=0; iter != idxclip_.end(); iter++, loop++) {
-            if (index-1 >= iter->first && index-1 <= iter->second) {
+            if (last >= iter->first && last <= iter->second) {
                 pos = loop;
             }
         }
 
         if (pos >= 0) {
+            bool bok = false;
             for (; pos < (int)idxclip_.size(); pos++) {
                 std::pair<int,int> item = idxclip_[pos];
                 if (index < item.first) {
                     index = item.first;
+                    bok = true;
                     break; 
                 }else if (index >= item.first && index <= item.second) {
+                    bok = true;
                     break;
                 }
             }
+            if (!bok) return false;
         }
     }
-    idxcur_ = index;
+    return true;
 }
 
 void* Stream::Open(const char* filename, int mode) {
@@ -333,7 +341,12 @@ void* Stream::Open(const char* filename, int mode) {
     lasterr_ = -2;
     if (!init_) return nullptr;
 
-    int index = idxcur_;
+    LOG(INFO) << __func__ << " last=" << idxcur_.first << " next=" << idxcur_.second;
+    int index = idxcur_.second;
+    if(!CheckIndex(idxcur_.first, index)) {
+        return nullptr;
+    }
+
     std::string fname;
     if (proto_ == kMmtProtoMmtp) { // for mmt streaming
         MmtpStart();
@@ -387,6 +400,7 @@ void* Stream::Open(const char* filename, int mode) {
 
     LOG(INFO) << __func__ << " index=" << index
         << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+    idxcur_.second = index;
     lasterr_ = 0;
     return (void *)file_;
 }
@@ -397,7 +411,10 @@ int Stream::Read(void *buf, int size) {
     int iret = fread(buf, 1, size, file_);
     if (iret < size) { // read to eof
         Close();
-        NextIndex();
+        if (idxcur_.second >= 0) {
+            idxcur_.first = idxcur_.second;
+            idxcur_.second++;
+        }
     }
     return iret; 
 }
@@ -433,13 +450,15 @@ void Stream::Uninit() {
 
 bool Stream::Init() {
     lasterr_ = 0;
-    idxcur_ = -1;
+    idxcur_.first = -1; // last
+    idxcur_.second = -1; // current
     idxurl_.first = -1;
     idxurl_.second = -1;
 
     mtype_ = "";
     proto_ = kMmtProtoLocal;
     htmlid_ = "";
+    tabid_ = -1;
     first_ = true;
     init_ = false;
 
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 7c85527..75cf32b 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -167,10 +167,11 @@ public:
     bool IsMmtMedia();
     long ParseMpu();
     bool ParseSequence();
-    void NextIndex();
+    bool CheckIndex(int last, int& index);
 
     std::string GetProto() {return proto_;}
     std::string GetHtmlId() {return htmlid_;}
+    int GetTabId() {return tabid_;}
     bool SetHtmlClip(std::string clip);
 
 protected:
@@ -182,12 +183,13 @@ private:
     std::string mtype_;
     std::string proto_;
     std::string htmlid_;
+    int tabid_;
 
     int lasterr_;
     bool first_;
     bool init_;
 
-    int idxcur_; //> current media index
+    std::pair<int,int> idxcur_; //> last used and current using media index
     std::pair<int,int> idxurl_; //> idx range from url
     std::vector<std::pair<int,int> > idxclip_; // idx range from ci xml
     std::map<int, offset_t> offmap_; //> read offset for current media index
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index e2744d8..18b1ad1 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -85,6 +85,7 @@ bool GetRangeValue(std::string range, std::pair<int,int>& item) {
     }else { // one element
         lstr = range;
         rstr = range;
+        bok = true;
     }
     item.first = String2Int(lstr);
     item.second = String2Int(rstr);
-- 
1.7.9.5


From 7ba6ecb44bd200094219084429e4ef34c62ef43a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 01:55:56 +0800
Subject: [PATCH 095/128] [todo] prepare for xml subset

---
 net/mmt/mmt_parser.cc |   57 +++++++++++++++++++++++++++++++++++++++++++------
 net/mmt/mmt_parser.h  |    2 ++
 2 files changed, 53 insertions(+), 6 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 122415f..f963647 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -33,6 +33,8 @@ static const char kstyle[]      = "style";
 static const char kclipBegin[]  = "clipBegin";
 static const char kclipEnd[]    = "clipEnd";
 static const char kclipList[]   = "clipList";
+static const char kxlinkhref[]  = "xlink:href";
+static const char kxlinkactuate[] = "xlink:actuate";
 
 /**
  * Event constatnts for the value of kbegin and kend
@@ -41,6 +43,7 @@ static const char kevinf[]      = "indefinite";
 static const char kevbegin[]    = ".begin";
 static const char kevend[]      = ".end";
 static const char kevclick[]    = ".click";
+static const char konRequest[]  = "onRequest";
 
 
 /**
@@ -112,6 +115,25 @@ inline std::string SetJSEvent(std::string id, std::string name, std::string valu
 inline std::string SetJSEnd() {
     return "}";
 }
+inline std::string SetSubXmlJS(std::string href, std::string action) {
+    std::string js;
+    std::string id = "id_subset_xml_123";
+    js = "var div = document.createElement('div');";
+    js+= "div.innerHTML=\"<img id='"+id+"' width=1 height=1/>\";";
+
+    js+= GetJSObject(id);
+    js+= SetJSBegin(id);
+    if (action == konRequest) {
+        js+= "document.onclick = function() {";
+        js+= SetJSAttr(id, "src", href);
+        js+= "}";
+    }else {
+        js+= SetJSAttr(id, "src", href);
+    }
+    js+= SetJSEnd();
+    return js;
+}
+
 
 /**
  * To parse CI's time, return 0 if timestr is invalid, else return milliseconds
@@ -317,12 +339,28 @@ bool CiParser::ParseHtml() {
     for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
         nodeptr_t sub1 = *iter1;
         if (sub1->name == kview) {
-            nodeptrs_t::iterator iter2 = sub1->nodes.begin();
-            for (; iter2 != sub1->nodes.end(); iter2++) {
-                nodeptr_t sub2 = *iter2;
-                if (sub2->name == kdivLocation) {
-                    LOG(INFO) << __func__ << " process view's " << kdivLocation;
-                    InitHtmlJS(sub2, htmls_, tabid_);
+            if (sub1->nodes.empty()) { // for subset nodes
+                std::string href, actuate;
+                if(sub1->attrs.find(kxlinkhref) != sub1->attrs.end()) {
+                    href = sub1->attrs[kxlinkhref];
+                }
+                if (sub1->attrs.find(kxlinkactuate) != sub1->attrs.end()) {
+                    actuate = sub1->attrs[kxlinkactuate];
+                }
+
+                if (href.empty() || actuate.empty()) continue;
+                htmlptr_t html = new html_t;
+                html->node = sub1;
+                html->js[EHtmlSubXml] = SetSubXmlJS(href, actuate);
+                htmls_["html"] = html;
+            }else {
+                nodeptrs_t::iterator iter2 = sub1->nodes.begin();
+                for (; iter2 != sub1->nodes.end(); iter2++) {
+                    nodeptr_t sub2 = *iter2;
+                    if (sub2->name == kdivLocation) {
+                        LOG(INFO) << __func__ << " process view's " << kdivLocation;
+                        InitHtmlJS(sub2, htmls_, tabid_);
+                    }
                 }
             }
         }else if (sub1->name == kdivLocation) { // krefDiv of <div>
@@ -643,6 +681,13 @@ std::string CiParser::GetHtmlClip(std::string id) {
     return clip;
 }
 
+bool CiParser::GetSubXmlJS(int64 current, std::string& js) {
+    if(htmls_.find("html") == htmls_.end()) return false;
+    htmlptr_t html = htmls_["html"];
+    js = html->js[EHtmlSubXml];
+    return true;
+}
+
 bool CiParser::AddNode(std::string name) {
     LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
     nodeptr_t node = new node_t(name);
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 40410e6..7c282c5 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -26,6 +26,7 @@ enum EHtmlEvent{
     EHtmlEnd,           //> mmtci:end
     EHtmlClickBegin,    //> mmtci:begin's .click
     EHtmlClickEnd,      //> mmtci:end's .click
+    EHtmlSubXml,
 };
 
 /**
@@ -120,6 +121,7 @@ public:
      * @return true if success.
      */
     bool GetHtmlJS(int64 current, std::string& js);
+    bool GetSubXmlJS(int64 current, std::string& js);
 
     /**
      * Get Xml's timestamp and version.
-- 
1.7.9.5


From 25bd5dff3b1e86ec6b4f66b47d9f05cc7dd2c48f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 10:57:32 +0800
Subject: [PATCH 096/128] [todo] preapre subxml with type=CI

---
 net/mmt/mmt_inc.h     |    1 +
 net/mmt/mmt_parser.cc |   33 +++++++++++++++++----------------
 net/mmt/mmt_stream.h  |    1 +
 net/mmt/mmt_utils.cc  |    1 +
 4 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index ba2f899..a0a28b0 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -97,6 +97,7 @@ extern const char kMmtDefaultUrl[];
 
 // for url query
 extern const char kMmtHtmlId[];
+extern const char kMmtXmlIdPrefix[];
 
 }
 
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index f963647..2d66579 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -96,6 +96,17 @@ static void init_sax(xmlSAXHandlerPtr sax) {
 /**
  * Utils for generating javascript 
  */
+static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
+    if (src.empty() || id.empty()) return "";
+    std::string url = src;
+    if(src.find("?") == std::string::npos) {
+        url += "?";
+    }else {
+        url += "&";
+    }
+    url = url + kMmtHtmlId+"="+id + "&tabid="+Int2String(tabid);
+    return url;
+}
 inline std::string GetJSObject(std::string id) {
     return "g_"+id+" = document.getElementById('"+id+"');";
 }
@@ -115,11 +126,11 @@ inline std::string SetJSEvent(std::string id, std::string name, std::string valu
 inline std::string SetJSEnd() {
     return "}";
 }
-inline std::string SetSubXmlJS(std::string href, std::string action) {
+inline std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
     std::string js;
-    std::string id = "id_subset_xml_123";
+    href = href + "&type=" + kMmtMediaCI;
     js = "var div = document.createElement('div');";
-    js+= "div.innerHTML=\"<img id='"+id+"' width=1 height=1/>\";";
+    js+= "div.innerHTML=\"<iframe id='"+id+"' width=100 height=100/>\";";
 
     js+= GetJSObject(id);
     js+= SetJSBegin(id);
@@ -236,18 +247,6 @@ bool CiParser::ParseXml() {
     return true;
 }
 
-static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
-    if (src.empty() || id.empty()) return "";
-    std::string url = src;
-    if(src.find("?") == std::string::npos) {
-        url += "?";
-    }else {
-        url += "&";
-    }
-    url = url + kMmtHtmlId+"="+id + "&tabid="+Int2String(tabid);
-    return url;
-}
-
 static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     if (!node) return;
 
@@ -351,7 +350,9 @@ bool CiParser::ParseHtml() {
                 if (href.empty() || actuate.empty()) continue;
                 htmlptr_t html = new html_t;
                 html->node = sub1;
-                html->js[EHtmlSubXml] = SetSubXmlJS(href, actuate);
+                std::string id = kMmtXmlIdPrefix + Int2String(GetLocalTime()%100000);
+                std::string xmllink = GetMediaSrc(href, id, tabid_);
+                html->js[EHtmlSubXml] = SetSubXmlJS(id, href, actuate);
                 htmls_["html"] = html;
             }else {
                 nodeptrs_t::iterator iter2 = sub1->nodes.begin();
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 75cf32b..99fdd74 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -169,6 +169,7 @@ public:
     bool ParseSequence();
     bool CheckIndex(int last, int& index);
 
+    std::string GetMtype() {return mtype_;}
     std::string GetProto() {return proto_;}
     std::string GetHtmlId() {return htmlid_;}
     int GetTabId() {return tabid_;}
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 18b1ad1..b2f1a46 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -18,6 +18,7 @@ const char kMmtProtoLocal[] = "local";
 const char kMmtDefaultUrl[] = "mmt://localhost";
 
 const char kMmtHtmlId[] = "htmlid";
+const char kMmtXmlIdPrefix[] = "id_subxml_";
 
 
 void Wait(int ms) {
-- 
1.7.9.5


From 7241b45a71af36b2d91192996740668c84a7040e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 11:29:40 +0800
Subject: [PATCH 097/128] [todo] add extra proto to download xml

---
 net/mmt/mmt_control.cc |   14 ++++++++++++--
 net/mmt/mmt_control.h  |    2 ++
 net/mmt/mmt_inc.h      |    1 +
 net/mmt/mmt_stream.cc  |   21 +++++++++++++++------
 net/mmt/mmt_utils.cc   |    1 +
 5 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 76fc706..847bc1f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -168,9 +168,16 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
                 cixmlptr_t cixml = cixmls_[tabid];
                 if (cixml->parser) {
                     LOG(INFO) << __func__ << " find xml parser";
+                    // for clip
                     std::string clip;
                     clip = cixml->parser->GetHtmlClip(stream->GetHtmlId());
                     stream->SetHtmlClip(clip);
+
+                    // for sub xml
+                    if (stream->GetMtype() == kMmtMediaCI) {
+                        LOG(INFO) << __func__ << " find one sub xml=" << msg.url.spec();
+                        cixml->subxmls.push_back(msg.url.spec());
+                    }
                 }
             } 
         }
@@ -308,8 +315,11 @@ void MmtControl::CheckEvent() {
             }
 
             if (cixml->parser && cixml->postui) {
-                std::string js;
-                if(cixml->parser->GetHtmlJS(ntp, js) && !js.empty()) {
+                std::string js0, js1;
+                cixml->parser->GetSubXmlJS(ntp, js0);
+                cixml->parser->GetHtmlJS(ntp, js1);
+                std::string js = js0 + js1;
+                if(!js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
                     std::string json;
                     GetJsonData(iter->first, js, json);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 029c6f8..443d740 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -73,6 +73,8 @@ public:
     std::string fname;      //> xml file name
     std::string status;     //> ci status: initing,loading,loaded
     std::string proto;      //> "local" or "mmtp"
+
+    std::vector<std::string> subxmls; //> sub xmls
     int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index a0a28b0..0837837 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -93,6 +93,7 @@ extern const char kMmtMediaCI[];
 
 extern const char kMmtProtoMmtp[];
 extern const char kMmtProtoLocal[];
+extern const char kMmtProtoExtra[];
 extern const char kMmtDefaultUrl[];
 
 // for url query
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 89239f5..70a0a76 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -219,15 +219,23 @@ bool Stream::ParseSequence() {
         std::string htmlid = GetQueryValue(query, kMmtHtmlId);
         std::string tabid = GetQueryValue(query, "tabid");
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range 
-            << " proto=" << proto << " htmlid=" << htmlid; 
+            << " proto=" << proto << " htmlid=" << htmlid << " tabid=" << tabid; 
 
-        if (htmlid.empty()) return false;
-        if (mtype.empty() && proto.empty()) return false;
-        if (proto == kMmtProtoMmtp) mtype_ = kMmtMediaHtml;  // default is html for mmtp
+        if (proto == kMmtProtoMmtp) mtype = kMmtMediaHtml; // default is html for mmtp
+
+        if (mtype == kMmtMediaAudio || mtype == kMmtMediaVideo || 
+            mtype == kMmtMediaImage || mtype == kMmtMediaCI) { 
+            // for kMmtMediaCI, this CI is sub ci xml, and the main ci is got by mmtp receiver in mmt_control.
+            if (htmlid.empty()) return false;
+        }else if (mtype == kMmtMediaHtml) {
+            // ..
+        }else {
+            return false;
+        }
         if (!proto.empty()) proto_ = proto;
         if (!mtype.empty()) mtype_ = mtype;
         if (!tabid.empty()) tabid_ = String2Int(tabid);
-        htmlid_ = htmlid;
+        if (!htmlid.empty()) htmlid_ = htmlid;
 
         // compute the sequence of media and get current index
         if (!range.empty()) {
@@ -367,8 +375,9 @@ void* Stream::Open(const char* filename, int mode) {
             fname = fname + kMmtLocalAudioPrefix + Int2String(index, 4) + ".mp4"; 
         }else if (mtype_ == kMmtMediaVideo) {
             fname = fname + kMmtLocalVideoPrefix + Int2String(index, 4) + ".mp4"; 
-        }else if (mtype_ == kMmtMediaImage) { // not process
         }
+    }else if (proto_ == kMmtProtoExtra) {
+        // TODO: for extra proto, such as http/ftp. now sub xml will be got by it.
     }else {
         LOG(INFO) << __func__ << " invalid proto=" << proto_;
         return nullptr;
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index b2f1a46..851c5b8 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -15,6 +15,7 @@ const char kMmtMediaCI[] = "ci";
 
 const char kMmtProtoMmtp[] = "mmtp";
 const char kMmtProtoLocal[] = "local";
+const char kMmtProtoExtra[] = "extra";
 const char kMmtDefaultUrl[] = "mmt://localhost";
 
 const char kMmtHtmlId[] = "htmlid";
-- 
1.7.9.5


From 78b43b7dc7eda2c1c6ca862bc7d7d8c41d604fc4 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 13:51:34 +0800
Subject: [PATCH 098/128] [todo] fix kMmtMediaHtml

---
 net/mmt/mmt_control.cc |    1 +
 net/mmt/mmt_stream.cc  |    6 ++++--
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 847bc1f..604db2f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -189,6 +189,7 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
             Wait(100);
             return;
         }
+        LOG(INFO) << __func__ << " lsize=" << lsize;
     }while(false);
     
     if (msg.sinfo.func) {
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 70a0a76..21890ee 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -221,7 +221,9 @@ bool Stream::ParseSequence() {
         LOG(INFO) << __func__ << " mtype=" << mtype << " range=" << range 
             << " proto=" << proto << " htmlid=" << htmlid << " tabid=" << tabid; 
 
-        if (proto == kMmtProtoMmtp) mtype = kMmtMediaHtml; // default is html for mmtp
+        if (proto == kMmtProtoMmtp) {
+            if (mtype.empty()) mtype = kMmtMediaHtml; // default is html for mmtp
+        }
 
         if (mtype == kMmtMediaAudio || mtype == kMmtMediaVideo || 
             mtype == kMmtMediaImage || mtype == kMmtMediaCI) { 
@@ -349,7 +351,7 @@ void* Stream::Open(const char* filename, int mode) {
     lasterr_ = -2;
     if (!init_) return nullptr;
 
-    LOG(INFO) << __func__ << " last=" << idxcur_.first << " next=" << idxcur_.second;
+    LOG(INFO) << __func__ << " last=" << idxcur_.first << " next=" << idxcur_.second << " mtype=" << mtype_;
     int index = idxcur_.second;
     if(!CheckIndex(idxcur_.first, index)) {
         return nullptr;
-- 
1.7.9.5


From 69ce8f4d04fc368a60ceb218fdfdcc450ba1bc7f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 14:21:09 +0800
Subject: [PATCH 099/128] [todo] add sequence info from mmtp

---
 net/mmt/mmt_stream.cc |   18 ++++++++++++------
 net/mmt/mmt_stream.h  |    2 +-
 net/mmt/mmtp/client.c |   12 ++++++++----
 net/mmt/mmtp/mmt.c    |    2 +-
 net/mmt/mmtp/mmtp.h   |    3 ++-
 5 files changed, 24 insertions(+), 13 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 21890ee..f30c60d 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -119,6 +119,7 @@ void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
     mmtp.url = rinfo->url;
     mmtp.fname = kMmtDefaultUrl + fpath.value();
     mmtp.mtype = mtype;
+    mmtp.index = rinfo->index;
     MmtpPush(mmtp);
 }
 
@@ -138,8 +139,9 @@ MmtpStream::~MmtpStream(){
 bool MmtpStream::Pop(mmtp_info_t& mmtp) {
     if (mlist_.empty()) return false;
 
-    std::string key = mmtp.url + "@" + mmtp.mtype;
     bool isok = false;
+    int index = mmtp.index;
+    std::string key = mmtp.url + "@" + mmtp.mtype;
 
     lock_.Acquire();
     do {
@@ -148,11 +150,15 @@ bool MmtpStream::Pop(mmtp_info_t& mmtp) {
         if (iter == mlist_.end()) break;
 
         mmtp_media_ptr_t media = iter->second;
-        if (media->flist.empty()) break;
-
-        mmtp = media->flist.back();
-        media->flist.pop_back();
-        isok = true;
+        do {
+            if (media->flist.empty()) break;
+            mmtp = media->flist.back();
+            media->flist.pop_back();
+            if (mmtp.index >= index) {
+                isok = true;
+                break;
+            }
+        }while(true);
     }while(false);
     lock_.Release();
     return isok;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index 99fdd74..a765830 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -55,7 +55,7 @@ struct mmtp_info_t {
     std::string url;
     std::string mtype; // "audio"/"video"/"image"/"ci"/"html" 
     std::string fname;
-    int index;
+    int index; //> sequence index
 };
 struct mmtp_media_t : public base::RefCounted<mmtp_media_t>{
     mmtp_media_t();
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 99be27e..0aa89ce 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -734,7 +734,8 @@ void *mpu_consumer_f(void *arg)						/**/
 									free_mpu_buf(&mpu_buf );
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 								}
 //								free(mfu_buf);
 //								if(ringq_poll(p_queue,&recive_mfu)>=0);
@@ -884,7 +885,8 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 
 								}
 								//,,
@@ -942,7 +944,8 @@ void *mpu_consumer_f(void *arg)						/**/
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, mpu_header.FT);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 								}
 
 							}
@@ -1004,7 +1007,7 @@ void set_mmtp_callback(mmtp_callback_t cb) {
     g_mmtp_cb = cb;
 }
 
-void push_mmtp_rinfo(int res, char* url, char* fname, int ftype) {
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype, int index) {
     if (!g_mmtp_cb) return;
     struct mmtp_rinfo_t rinfo;
     memset(&rinfo, 0, sizeof(rinfo));
@@ -1012,5 +1015,6 @@ void push_mmtp_rinfo(int res, char* url, char* fname, int ftype) {
     strncpy(rinfo.url, url, sizeof(rinfo.url));
     strncpy(rinfo.fname, fname, sizeof(rinfo.fname));
     rinfo.ftype = ftype;
+    rinfo.index = index;
     g_mmtp_cb(&rinfo);
 }
diff --git a/net/mmt/mmtp/mmt.c b/net/mmt/mmtp/mmt.c
index bf813e1..96e09df 100644
--- a/net/mmt/mmtp/mmt.c
+++ b/net/mmt/mmtp/mmt.c
@@ -1058,7 +1058,7 @@ int read_mpi_table(mpi_table_t *mpi_table, const char *mpi_table_buf)
 			fclose(mpi);
 
 			printf("finished recive a ci - %d - %s\n", i, (const char *)mpi_table->PI_content[i].PI_content_name_byte);
-            push_mmtp_rinfo(Res_Signal, "", (char *)mpi_table->PI_content[i].PI_content_name_byte, i);
+            push_mmtp_rinfo(Res_Signal, "", (char *)mpi_table->PI_content[i].PI_content_name_byte, i, 0);
         }
 	 return 0;
 
diff --git a/net/mmt/mmtp/mmtp.h b/net/mmt/mmtp/mmtp.h
index 140fb3b..fb359e2 100644
--- a/net/mmt/mmtp/mmtp.h
+++ b/net/mmt/mmtp/mmtp.h
@@ -29,8 +29,9 @@ struct mmtp_rinfo_t {
     char url[1024];
     char fname[1024];
     int  ftype;
+    int  index;
 };
-void push_mmtp_rinfo(int res, char* url, char* fname, int ftype);
+void push_mmtp_rinfo(int res, char* url, char* fname, int ftype, int index);
 
 /**
  * for ci.xml and index.html
-- 
1.7.9.5


From 7690f8259d733f9dd63ce436c20a596f2d32a4cf Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 14:36:01 +0800
Subject: [PATCH 100/128] [todo] fix ntp issue when network is disconnected

---
 net/mmt/mmt_utils.cc |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 851c5b8..4bd0d74 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -164,7 +164,7 @@ int64 GetNTPTime() {
         memset(&ntp_time, 0, sizeof(ntp_time));
         int iret = ntp_get_time(kMmtNtpServer, &ntp_time);
         _last = GetLocalTime();
-        if (iret == 0)
+        if (iret == 0 && ntp_time.coarse >= JAN_1970_SEC)
             _lastntp = (ntp_time.coarse-JAN_1970_SEC)*1000 + ntp_time.fine/4294967;
         else
             _lastntp = _last;
-- 
1.7.9.5


From d1635356a10f18d74ba8eb970c2f8b9b2d54d2c7 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 14:59:37 +0800
Subject: [PATCH 101/128] [todo] fix mmtp seq issue

---
 net/mmt/mmt_stream.cc |    4 +++-
 net/mmt/mmtp/client.c |   16 +++++++---------
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index f30c60d..d53a297 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -113,7 +113,8 @@ void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
 
     base::FilePath cpath(rinfo->fname);
     base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
-    LOG(INFO) << __func__ << " fname=" << rinfo->fname << " ftype=" << ftype << " fpath=" << fpath.value();
+    LOG(INFO) << __func__ << " fname=" << rinfo->fname << 
+        " ftype=" << ftype << " fpath=" << fpath.value() << " seq=" << rinfo->index;
 
     mmtp_info_t mmtp;
     mmtp.url = rinfo->url;
@@ -362,6 +363,7 @@ void* Stream::Open(const char* filename, int mode) {
     if(!CheckIndex(idxcur_.first, index)) {
         return nullptr;
     }
+    LOG(INFO) << __func__ << " index=" << index;
 
     std::string fname;
     if (proto_ == kMmtProtoMmtp) { // for mmt streaming
diff --git a/net/mmt/mmtp/client.c b/net/mmt/mmtp/client.c
index 0aa89ce..1a2e6e1 100644
--- a/net/mmt/mmtp/client.c
+++ b/net/mmt/mmtp/client.c
@@ -729,13 +729,13 @@ void *mpu_consumer_f(void *arg)						/**/
 										exit(0);
 									}
 									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
-
 									fclose(mpu);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
+
 									free_mpu_buf(&mpu_buf );
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
-                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 								}
 //								free(mfu_buf);
 //								if(ringq_poll(p_queue,&recive_mfu)>=0);
@@ -878,15 +878,14 @@ void *mpu_consumer_f(void *arg)						/**/
 										exit(0);
 									}
 									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
-
 									fclose(mpu);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
-                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 
 								}
 								//,,
@@ -937,15 +936,14 @@ void *mpu_consumer_f(void *arg)						/**/
 										exit(0);
 									}
 									fwrite(mpu_buf.MPU_sequence_data,mpu_buf.MPU_sequence_length,1,mpu);
-
 									fclose(mpu);
+                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
+                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 
 									free_mpu_buf(&mpu_buf );
 									init_mpu_buf(&mpu_buf);
 									printf("finished recive a mpu - %d\n", mpu_header.FT);
 
-                                    push_mmtp_rinfo(Res_Media, "", mpu_filename, 
-                                        mpu_header.FT, mpu_buf.MPU_sequence_number);
 								}
 
 							}
-- 
1.7.9.5


From 86ae1fb0309bce1aa527c59ac8465d441b0c1b46 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 15:07:00 +0800
Subject: [PATCH 102/128] [ok] for clip & seq control of mmtp

---
 net/mmt/mmt_stream.cc |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index d53a297..6b7a9a3 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -363,7 +363,7 @@ void* Stream::Open(const char* filename, int mode) {
     if(!CheckIndex(idxcur_.first, index)) {
         return nullptr;
     }
-    LOG(INFO) << __func__ << " index=" << index;
+    //LOG(INFO) << __func__ << " index=" << index;
 
     std::string fname;
     if (proto_ == kMmtProtoMmtp) { // for mmt streaming
-- 
1.7.9.5


From 4382c27ee30812f6aa55eeaa074527a3ca8f5dc3 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 16:08:50 +0800
Subject: [PATCH 103/128] fix combine of xml js and html js

---
 net/mmt/mmt_control.cc |    3 ++-
 net/mmt/mmt_parser.cc  |    7 ++++++-
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 604db2f..92e29f2 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -318,7 +318,9 @@ void MmtControl::CheckEvent() {
             if (cixml->parser && cixml->postui) {
                 std::string js0, js1;
                 cixml->parser->GetSubXmlJS(ntp, js0);
+                LOG(INFO) << __func__ << " js0 => " << js0;
                 cixml->parser->GetHtmlJS(ntp, js1);
+                LOG(INFO) << __func__ << " js1 => " << js1;
                 std::string js = js0 + js1;
                 if(!js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
@@ -327,7 +329,6 @@ void MmtControl::CheckEvent() {
                     LOG(INFO) << __func__ << " json => " << json;
                     SendToHost(json, "127.0.0.1", 54321);
 #else
-                    LOG(INFO) << __func__ << " js => " << js;
                     cixml->postui(cixml->job, "@js", js);
 #endif
                 }
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 2d66579..f230cc6 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -131,6 +131,7 @@ inline std::string SetSubXmlJS(std::string id, std::string href, std::string act
     href = href + "&type=" + kMmtMediaCI;
     js = "var div = document.createElement('div');";
     js+= "div.innerHTML=\"<iframe id='"+id+"' width=100 height=100/>\";";
+    js+= "document.body.appendChild(div);";
 
     js+= GetJSObject(id);
     js+= SetJSBegin(id);
@@ -352,7 +353,7 @@ bool CiParser::ParseHtml() {
                 html->node = sub1;
                 std::string id = kMmtXmlIdPrefix + Int2String(GetLocalTime()%100000);
                 std::string xmllink = GetMediaSrc(href, id, tabid_);
-                html->js[EHtmlSubXml] = SetSubXmlJS(id, href, actuate);
+                html->js[EHtmlSubXml] = SetSubXmlJS(id, xmllink, actuate);
                 htmls_["html"] = html;
             }else {
                 nodeptrs_t::iterator iter2 = sub1->nodes.begin();
@@ -378,12 +379,14 @@ bool CiParser::ParseHtml() {
     // end for time
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
+        if (iter->first == "html") continue;
         html->js[EHtmlBegin] += SetJSEnd();
         html->js[EHtmlEnd] += SetJSEnd();
     }
 
     // process interaction events
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
         event_t begin = node->time.begin;
@@ -409,6 +412,7 @@ bool CiParser::ParseHtml() {
 
     // process end for event click
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         html->js[EHtmlClickBegin] += SetJSEnd();
         html->js[EHtmlClickEnd] += SetJSEnd();
@@ -686,6 +690,7 @@ bool CiParser::GetSubXmlJS(int64 current, std::string& js) {
     if(htmls_.find("html") == htmls_.end()) return false;
     htmlptr_t html = htmls_["html"];
     js = html->js[EHtmlSubXml];
+    html->js[EHtmlSubXml] = "";
     return true;
 }
 
-- 
1.7.9.5


From 3d0ab30c26bd9deaded4cc1e71259502a2b997ec Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 17:13:41 +0800
Subject: [PATCH 104/128] [todo] add libneon to chrome for processing http

---
 net/mmt/neon/CMakeLists.txt    |   65 ++
 net/mmt/neon/cmake_check.cmake |  157 ++++
 net/mmt/neon/config.h          |  506 +++++++++++
 net/mmt/neon/config.h.cmake.in |  506 +++++++++++
 net/mmt/neon/config.h.in       |  506 +++++++++++
 net/mmt/neon/config.hw         |   98 ++
 net/mmt/neon/config.hw.in      |   98 ++
 net/mmt/neon/neon.gyp          |  103 +++
 net/mmt/neon/src/memleak.h     |   55 ++
 net/mmt/neon/src/ne_207.c      |  371 ++++++++
 net/mmt/neon/src/ne_207.h      |  103 +++
 net/mmt/neon/src/ne_acl.h      |   60 ++
 net/mmt/neon/src/ne_acl3744.c  |  179 ++++
 net/mmt/neon/src/ne_acl3744.h  |   85 ++
 net/mmt/neon/src/ne_alloc.c    |  223 +++++
 net/mmt/neon/src/ne_alloc.h    |   60 ++
 net/mmt/neon/src/ne_auth.c     | 1719 +++++++++++++++++++++++++++++++++++
 net/mmt/neon/src/ne_auth.h     |  143 +++
 net/mmt/neon/src/ne_basic.c    |  501 +++++++++++
 net/mmt/neon/src/ne_basic.h    |  156 ++++
 net/mmt/neon/src/ne_compress.c |  449 +++++++++
 net/mmt/neon/src/ne_compress.h |   48 +
 net/mmt/neon/src/ne_dates.c    |  262 ++++++
 net/mmt/neon/src/ne_dates.h    |   54 ++
 net/mmt/neon/src/ne_defs.h     |   84 ++
 net/mmt/neon/src/ne_gnutls.c   | 1435 +++++++++++++++++++++++++++++
 net/mmt/neon/src/ne_i18n.c     |   47 +
 net/mmt/neon/src/ne_i18n.h     |   55 ++
 net/mmt/neon/src/ne_internal.h |   86 ++
 net/mmt/neon/src/ne_locks.c    |  816 +++++++++++++++++
 net/mmt/neon/src/ne_locks.h    |  165 ++++
 net/mmt/neon/src/ne_md5.c      |  464 ++++++++++
 net/mmt/neon/src/ne_md5.h      |   98 ++
 net/mmt/neon/src/ne_ntlm.c     |  688 ++++++++++++++
 net/mmt/neon/src/ne_ntlm.h     |   46 +
 net/mmt/neon/src/ne_oldacl.c   |  132 +++
 net/mmt/neon/src/ne_openssl.c  | 1272 ++++++++++++++++++++++++++
 net/mmt/neon/src/ne_pkcs11.c   |  625 +++++++++++++
 net/mmt/neon/src/ne_pkcs11.h   |  110 +++
 net/mmt/neon/src/ne_private.h  |  154 ++++
 net/mmt/neon/src/ne_privssl.h  |  106 +++
 net/mmt/neon/src/ne_props.c    |  675 ++++++++++++++
 net/mmt/neon/src/ne_props.h    |  249 +++++
 net/mmt/neon/src/ne_redirect.c |  141 +++
 net/mmt/neon/src/ne_redirect.h |   42 +
 net/mmt/neon/src/ne_request.c  | 1714 +++++++++++++++++++++++++++++++++++
 net/mmt/neon/src/ne_request.h  |  318 +++++++
 net/mmt/neon/src/ne_session.c  |  745 +++++++++++++++
 net/mmt/neon/src/ne_session.h  |  350 ++++++++
 net/mmt/neon/src/ne_socket.c   | 1949 ++++++++++++++++++++++++++++++++++++++++
 net/mmt/neon/src/ne_socket.h   |  311 +++++++
 net/mmt/neon/src/ne_socks.c    |  354 ++++++++
 net/mmt/neon/src/ne_ssl.h      |  201 +++++
 net/mmt/neon/src/ne_sspi.c     |  606 +++++++++++++
 net/mmt/neon/src/ne_sspi.h     |   48 +
 net/mmt/neon/src/ne_string.c   |  616 +++++++++++++
 net/mmt/neon/src/ne_string.h   |  189 ++++
 net/mmt/neon/src/ne_stubssl.c  |  145 +++
 net/mmt/neon/src/ne_uri.c      |  617 +++++++++++++
 net/mmt/neon/src/ne_uri.h      |  103 +++
 net/mmt/neon/src/ne_utils.c    |  219 +++++
 net/mmt/neon/src/ne_utils.h    |  118 +++
 net/mmt/neon/src/ne_xml.c      |  716 +++++++++++++++
 net/mmt/neon/src/ne_xml.h      |  165 ++++
 net/mmt/neon/src/ne_xmlreq.c   |  110 +++
 net/mmt/neon/src/ne_xmlreq.h   |   51 ++
 net/mmt/neon/src/neon.vers     |   22 +
 net/net.gyp                    |    1 +
 68 files changed, 23665 insertions(+)
 create mode 100644 net/mmt/neon/CMakeLists.txt
 create mode 100644 net/mmt/neon/cmake_check.cmake
 create mode 100644 net/mmt/neon/config.h
 create mode 100644 net/mmt/neon/config.h.cmake.in
 create mode 100644 net/mmt/neon/config.h.in
 create mode 100644 net/mmt/neon/config.hw
 create mode 100644 net/mmt/neon/config.hw.in
 create mode 100644 net/mmt/neon/neon.gyp
 create mode 100644 net/mmt/neon/src/memleak.h
 create mode 100644 net/mmt/neon/src/ne_207.c
 create mode 100644 net/mmt/neon/src/ne_207.h
 create mode 100644 net/mmt/neon/src/ne_acl.h
 create mode 100644 net/mmt/neon/src/ne_acl3744.c
 create mode 100644 net/mmt/neon/src/ne_acl3744.h
 create mode 100644 net/mmt/neon/src/ne_alloc.c
 create mode 100644 net/mmt/neon/src/ne_alloc.h
 create mode 100644 net/mmt/neon/src/ne_auth.c
 create mode 100644 net/mmt/neon/src/ne_auth.h
 create mode 100644 net/mmt/neon/src/ne_basic.c
 create mode 100644 net/mmt/neon/src/ne_basic.h
 create mode 100644 net/mmt/neon/src/ne_compress.c
 create mode 100644 net/mmt/neon/src/ne_compress.h
 create mode 100644 net/mmt/neon/src/ne_dates.c
 create mode 100644 net/mmt/neon/src/ne_dates.h
 create mode 100644 net/mmt/neon/src/ne_defs.h
 create mode 100644 net/mmt/neon/src/ne_gnutls.c
 create mode 100644 net/mmt/neon/src/ne_i18n.c
 create mode 100644 net/mmt/neon/src/ne_i18n.h
 create mode 100644 net/mmt/neon/src/ne_internal.h
 create mode 100644 net/mmt/neon/src/ne_locks.c
 create mode 100644 net/mmt/neon/src/ne_locks.h
 create mode 100644 net/mmt/neon/src/ne_md5.c
 create mode 100644 net/mmt/neon/src/ne_md5.h
 create mode 100644 net/mmt/neon/src/ne_ntlm.c
 create mode 100644 net/mmt/neon/src/ne_ntlm.h
 create mode 100644 net/mmt/neon/src/ne_oldacl.c
 create mode 100644 net/mmt/neon/src/ne_openssl.c
 create mode 100644 net/mmt/neon/src/ne_pkcs11.c
 create mode 100644 net/mmt/neon/src/ne_pkcs11.h
 create mode 100644 net/mmt/neon/src/ne_private.h
 create mode 100644 net/mmt/neon/src/ne_privssl.h
 create mode 100644 net/mmt/neon/src/ne_props.c
 create mode 100644 net/mmt/neon/src/ne_props.h
 create mode 100644 net/mmt/neon/src/ne_redirect.c
 create mode 100644 net/mmt/neon/src/ne_redirect.h
 create mode 100644 net/mmt/neon/src/ne_request.c
 create mode 100644 net/mmt/neon/src/ne_request.h
 create mode 100644 net/mmt/neon/src/ne_session.c
 create mode 100644 net/mmt/neon/src/ne_session.h
 create mode 100644 net/mmt/neon/src/ne_socket.c
 create mode 100644 net/mmt/neon/src/ne_socket.h
 create mode 100644 net/mmt/neon/src/ne_socks.c
 create mode 100644 net/mmt/neon/src/ne_ssl.h
 create mode 100644 net/mmt/neon/src/ne_sspi.c
 create mode 100644 net/mmt/neon/src/ne_sspi.h
 create mode 100644 net/mmt/neon/src/ne_string.c
 create mode 100644 net/mmt/neon/src/ne_string.h
 create mode 100644 net/mmt/neon/src/ne_stubssl.c
 create mode 100644 net/mmt/neon/src/ne_uri.c
 create mode 100644 net/mmt/neon/src/ne_uri.h
 create mode 100644 net/mmt/neon/src/ne_utils.c
 create mode 100644 net/mmt/neon/src/ne_utils.h
 create mode 100644 net/mmt/neon/src/ne_xml.c
 create mode 100644 net/mmt/neon/src/ne_xml.h
 create mode 100644 net/mmt/neon/src/ne_xmlreq.c
 create mode 100644 net/mmt/neon/src/ne_xmlreq.h
 create mode 100644 net/mmt/neon/src/neon.vers

diff --git a/net/mmt/neon/CMakeLists.txt b/net/mmt/neon/CMakeLists.txt
new file mode 100644
index 0000000..0471fda
--- /dev/null
+++ b/net/mmt/neon/CMakeLists.txt
@@ -0,0 +1,65 @@
+#cmake_minimum_required(VERSION 2.8)
+#project(neon)
+
+# CMAKE_C_FLAGS CMAKE_CXX_FLAGS
+add_definitions(-O2 -Wall)
+#add_definitions(-no-cpp-precomp)
+add_definitions(-DHAVE_CONFIG_H -DNE_PRIVATE=extern)
+
+include_directories(
+    .
+)
+
+link_directories(
+)
+
+# for uuid
+set(neon_LIB_SRCS
+    #src/ne_basic.c     
+    #src/ne_props.c     
+    #src/ne_locks.c   
+    #src/ne_xml.c
+    #src/ne_xmlreq.c
+    #src/ne_207.c       
+    #src/ne_oldacl.c    
+    #src/ne_acl3744.c   
+    #ne_gnutls.c  
+    #ne_openssl.c   
+    src/ne_dates.c   
+    src/ne_session.c
+    src/ne_uri.c
+    src/ne_socket.c
+    src/ne_utils.c
+    src/ne_alloc.c     
+    src/ne_i18n.c    
+    src/ne_pkcs11.c    
+    src/ne_socks.c
+    src/ne_auth.c      
+    src/ne_sspi.c
+    src/ne_md5.c     
+    src/ne_redirect.c  
+    src/ne_string.c
+    src/ne_compress.c  
+    src/ne_ntlm.c    
+    src/ne_request.c   
+    src/ne_stubssl.c
+)
+
+# add extra header/function/type check
+include(cmake_check.cmake)
+
+set(so_NAME neon)
+#add_library(${so_NAME} SHARED ${neon_LIB_SRCS})
+#set_target_properties(${so_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1) 
+#set_target_properties(${so_NAME} PROPERTIES VERSION 1.0 SOVERSION 1)
+
+set(a_NAME neon_static)
+add_library(${a_NAME} STATIC ${neon_LIB_SRCS})
+set_target_properties(${a_NAME} PROPERTIES OUTPUT_NAME ${so_NAME})
+set_target_properties(${a_NAME} PROPERTIES CLEAN_DIRECT_OUTPUT 1) 
+
+set(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib/) 
+
+#install(TARGETS ${so_NAME} LIBRARY DESTINATION lib)
+install(TARGETS ${a_NAME}  ARCHIVE DESTINATION lib)
+
diff --git a/net/mmt/neon/cmake_check.cmake b/net/mmt/neon/cmake_check.cmake
new file mode 100644
index 0000000..a423e7b
--- /dev/null
+++ b/net/mmt/neon/cmake_check.cmake
@@ -0,0 +1,157 @@
+#CheckFunctionExists
+#CheckIncludeFile
+#CheckIncludeFileCXX
+#CheckIncludeFiles
+#CheckLibraryExists
+#CheckStructHasMember
+#CheckSymbolExists
+#CheckTypeSize
+#CheckVariableExists
+
+
+include(CheckVariableExists)
+check_variable_exists(timezone HAVE_TIMEZONE)
+
+include(CheckSymbolExists)
+check_symbol_exists(AI_ADDRCONFIG netdb.h USE_GAI_ADDRCONFIG)
+
+# Check C types
+include(CheckTypeSize)
+check_type_size(int         SIZEOF_INT)
+check_type_size(long        SIZEOF_LONG)
+check_type_size("long long" SIZEOF_LONG_LONG)
+check_type_size(off64_t     SIZEOF_OFF64_T)
+check_type_size(off_t       SIZEOF_OFF_T)
+check_type_size(size_t      SIZEOF_SIZE_T)
+check_type_size(ssize_t     SIZEOF_SSIZE_T)
+check_type_size(time_t      SIZEOF_TIME_T)
+check_type_size(XML_Size    SIZEOF_XML_SIZE)
+
+include(CheckIncludeFiles)
+check_include_files("arpa/inet.h" HAVE_ARPA_INET_H)
+check_include_files("dlfcn.h" HAVE_DLFCN_H)
+check_include_files("errno.h" HAVE_ERRNO_H)
+check_include_files("fcntl.h" HAVE_FCNTL_H)
+check_include_files("iconv.h" HAVE_ICONV_H)
+check_include_files("inttypes.h" HAVE_INTTYPES_H)
+check_include_files("libintl.h" HAVE_LIBINTL_H)
+check_include_files("limits.h" HAVE_LIMITS_H)
+check_include_files("locale.h" HAVE_LOCALE_H)
+check_include_files("memory.h" HAVE_MEMORY_H)
+check_include_files("netdb.h" HAVE_NETDB_H)
+check_include_files("netinet/in.h" HAVE_NETINET_IN_H)
+check_include_files("netinet/tcp.h" HAVE_NETINET_TCP_H)
+check_include_files("signal.h" HAVE_SIGNAL_H)
+check_include_files("stdarg.h" HAVE_STDARG_H)
+check_include_files("stdint.h" HAVE_STDINT_H)
+check_include_files("stdlib.h" HAVE_STDLIB_H)
+check_include_files("strings.h" HAVE_STRINGS_H)
+check_include_files("string.h" HAVE_STRING_H)
+check_include_files("sys/limits.h" HAVE_SYS_LIMITS_H)
+check_include_files("sys/poll.h" HAVE_SYS_POLL_H)
+check_include_files("sys/select.h" HAVE_SYS_SELECT_H)
+check_include_files("sys/socket.h" HAVE_SYS_SOCKET_H)
+check_include_files("sys/stat.h" HAVE_SYS_STAT_H)
+check_include_files("sys/time.h" HAVE_SYS_TIME_H)
+check_include_files("sys/types.h" HAVE_SYS_TYPES_H)
+check_include_files("sys/uio.h" HAVE_SYS_UIO_H)
+check_include_files("trio.h" HAVE_TRIO_H)
+check_include_files("unistd.h" HAVE_UNISTD_H)
+check_include_files("time.h" HAVE_TIME_H)
+
+include(CheckFunctionExists)
+check_function_exists(stpcpy HAVE_DECL_STPCPY)
+check_function_exists(strerror_r HAVE_DECL_STRERROR_R)
+check_function_exists(fcntl HAVE_FCNTL)
+check_function_exists(fstat64 HAVE_FSTAT64)
+check_function_exists(gai_strerror HAVE_GAI_STRERROR)
+check_function_exists(gethostname HAVE_GETHOSTNAME)
+check_function_exists(getnameinfo HAVE_GETNAMEINFO)
+check_function_exists(hstrerror HAVE_HSTRERROR)
+check_function_exists(getsockopt HAVE_GETSOCKOPT)
+check_function_exists(inet_ntop HAVE_INET_NTOP)
+check_function_exists(inet_pton HAVE_INET_PTON)
+check_function_exists(isatty HAVE_ISATTY)
+check_function_exists(lseek64 HAVE_LSEEK64)
+check_function_exists(pipe HAVE_PIPE)
+check_function_exists(poll HAVE_POLL)
+check_function_exists(pthread_mutex_init HAVE_PTHREAD_MUTEX_INIT)
+check_function_exists(pthread_mutex_lock HAVE_PTHREAD_MUTEX_LOCK)
+check_function_exists(setlocale HAVE_SETLOCALE)
+check_function_exists(setsockopt HAVE_SETSOCKOPT)
+check_function_exists(setvbuf HAVE_SETVBUF)
+check_function_exists(shutdown HAVE_SHUTDOWN)
+check_function_exists(signal HAVE_SIGNAL)
+check_function_exists(snprintf HAVE_SNPRINTF)
+check_function_exists(stpcpy HAVE_STPCPY)
+check_function_exists(strcasecmp HAVE_STRCASECMP)
+check_function_exists(strerror_r HAVE_STRERROR_R)
+check_function_exists(strtoll HAVE_STRTOLL)
+check_function_exists(strtoq HAVE_STRTOQ)
+check_function_exists(usleep HAVE_USLEEP)
+check_function_exists(vsnprintf HAVE_VSNPRINTF)
+
+include(CheckStructHasMember)
+check_struct_has_member("struct tm" tm_gmtoff time.h HAVE_STRUCT_TM_TM_GMTOFF)
+check_struct_has_member("struct tm" __tm_gmtoff time.h HAVE_STRUCT_TM___TM_GMTOFF)
+
+# set the size of off_t/size_t/ssize_t/time_t
+set(NE_FMT_NE_OFF_T NE_FMT_OFF_T)
+if (${SIZEOF_OFF_T} EQUAL 4)
+    set(NE_FMT_OFF_T \"ld\")
+else()
+    set(NE_FMT_OFF_T \"lld\")
+endif()
+if (${SIZEOF_SIZE_T} EQUAL 4)
+    set(NE_FMT_SIZE_T \"u\")
+else()
+    set(NE_FMT_SIZE_T \"lu\")
+endif()
+if (${SIZEOF_SSIZE_T} EQUAL 4)
+    set(NE_FMT_SSIZE_T \"d\")
+else()
+    set(NE_FMT_SSIZE_T \"ld\")
+endif()
+if (${SIZEOF_TIME_T} EQUAL 4)
+    set(NE_FMT_TIME_T \"d\")
+else()
+    set(NE_FMT_TIME_T \"ld\")
+endif()
+
+if(${USE_GAI_ADDRCONFIG})
+    set(USE_GETADDRINFO 1)
+endif()
+
+if (${HAVE_SYS_SOCKET_H})
+    set(HAVE_SOCKLEN_T 1)
+endif()
+
+if (HAVE_SYS_TIME_H AND HAVE_TIME_H)
+    set(TIME_WITH_SYS_TIME 1)
+endif()
+
+set(STDC_HEADERS 1)
+#set(_ALL_SOURCE 1)
+#set(_GNU_SOURCE 1)
+#set(_POSIX_PTHREAD_SEMANTICS 1)
+#set(_TANDEM_SOURCE 1)
+#set(__EXTENSIONS__ 1)
+
+set(NEON_IS_LIBRARY 1)
+#set(NE_DEBUGGING 1)
+#set(NE_HAVE_DAV 1)
+
+set(NEON_VERSION \"0.30.0\")
+set(NE_VERSION_MAJOR "\(0\)")
+set(NE_VERSION_MINOR "\(30\)")
+set(NE_VERSION_PATCH "\(0\)")
+set(PACKAGE_BUGREPORT \"neon@lists.manyfish.co.uk\")
+set(PACKAGE_NAME \"neon\")
+set(PACKAGE_STRING \"neon\ 0.30.0\")
+set(PACKAGE_TARNAME \"neon\")
+set(PACKAGE_URL \"\")
+set(PACKAGE_VERSION \"0.30.0\")
+
+
+configure_file(config.h.cmake.in config.h)
+include_directories(${PROJECT_BINARY_DIR}/misc/libneon)
diff --git a/net/mmt/neon/config.h b/net/mmt/neon/config.h
new file mode 100644
index 0000000..82fa77f
--- /dev/null
+++ b/net/mmt/neon/config.h
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to specific EGD socket path */
+/* #undef EGD_PATH */
+
+/* Define if EGD should be supported */
+/* #undef ENABLE_EGD */
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+/* #undef GSS_C_NT_HOSTBASED_SERVICE */
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+/* #undef HAVE_BIND_TEXTDOMAIN_CODESET */
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+/* #undef HAVE_CRYPTO_SET_IDPTR_CALLBACK */
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_H_ERRNO */
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#define HAVE_DECL_STPCPY 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define if you have expat */
+/* #undef HAVE_EXPAT */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fstat64' function. */
+#define HAVE_FSTAT64 1
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#define HAVE_GAI_STRERROR 1
+
+/* Define to 1 if you have the `gethostname' function. */
+#define HAVE_GETHOSTNAME 1
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#define HAVE_GETNAMEINFO 1
+
+/* Define to 1 if you have the `getsockopt' function. */
+#define HAVE_GETSOCKOPT 1
+
+/* Define if GnuTLS support is enabled */
+/* #undef HAVE_GNUTLS */
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+/* #undef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER */
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+/* #undef HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS */
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+/* #undef HAVE_GNUTLS_SESSION_GET_DATA2 */
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+/* #undef HAVE_GNUTLS_SIGN_CALLBACK_SET */
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+/* #undef HAVE_GNUTLS_X509_CRT_SIGN2 */
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+/* #undef HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+/* Define if GSSAPI support is enabled */
+/* #undef HAVE_GSSAPI */
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_GENERIC_H */
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_H */
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_H */
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+/* #undef HAVE_GSS_INIT_SEC_CONTEXT */
+
+/* Define to 1 if you have the `hstrerror' function. */
+#define HAVE_HSTRERROR 1
+
+/* Define to 1 if you have the `iconv' function. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#define HAVE_ICONV_H 1
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+#define HAVE_INET_PTON 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define if libproxy is supported */
+/* #undef HAVE_LIBPROXY */
+
+/* Define if you have libxml */
+/* #undef HAVE_LIBXML */
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+/* #undef HAVE_LIBXML_PARSER_H */
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+/* #undef HAVE_LIBXML_XMLVERSION_H */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `lseek64' function. */
+#define HAVE_LSEEK64 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#define HAVE_NETINET_TCP_H 1
+
+/* Define if NTLM is supported */
+/* #undef HAVE_NTLM */
+
+/* Define if OpenSSL support is enabled */
+/* #undef HAVE_OPENSSL */
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+/* #undef HAVE_OPENSSL_OPENSSLV_H */
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef HAVE_OPENSSL_SSL_H */
+
+/* Define if pakchois library supported */
+/* #undef HAVE_PAKCHOIS */
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#define HAVE_PTHREAD_MUTEX_INIT 1
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#define HAVE_PTHREAD_MUTEX_LOCK 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the `setsockopt' function. */
+#define HAVE_SETSOCKOPT 1
+
+/* Define to 1 if you have the `setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+/* Define to 1 if you have the `shutdown' function. */
+#define HAVE_SHUTDOWN 1
+
+/* Define to 1 if you have the `signal' function. */
+#define HAVE_SIGNAL 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#define HAVE_SOCKLEN_T 1
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+/* #undef HAVE_SSL_SESSION_CMP */
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtoq' function. */
+#define HAVE_STRTOQ 1
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+/* #undef HAVE_STRUCT_TM___TM_GMTOFF */
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+/* #undef HAVE_SYS_LIMITS_H */
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#define HAVE_SYS_POLL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define if the timezone global is available */
+#define HAVE_TIMEZONE 1
+
+/* Use trio printf replacement library */
+/* #undef HAVE_TRIO */
+
+/* Define to 1 if you have the <trio.h> header file. */
+/* #undef HAVE_TRIO_H */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to be location of localedir */
+/* #undef LOCALEDIR */
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+/* #undef LT_OBJDIR */
+
+/* Defined when neon is built as a library */
+#define NEON_IS_LIBRARY 1
+
+/* Define to be the neon version string */
+#define NEON_VERSION "0.30.0"
+
+/* Define to enable debugging */
+/* #undef NE_DEBUGGING */
+
+/* Define to be printf format string for ne_off_t */
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+/* Define to be printf format string for off64_t */
+/* #undef NE_FMT_OFF64_T */
+
+/* Define to be printf format string for off_t */
+#define NE_FMT_OFF_T "lld"
+
+/* Define to be printf format string for size_t */
+#define NE_FMT_SIZE_T "lu"
+
+/* Define to be printf format string for ssize_t */
+#define NE_FMT_SSIZE_T "ld"
+
+/* Define to be printf format string for time_t */
+#define NE_FMT_TIME_T "ld"
+
+/* Define to be printf format string for XML_Size */
+/* #undef NE_FMT_XML_SIZE */
+
+/* Defined if DAV is supported */
+/* #undef NE_HAVE_DAV */
+
+/* Defined if I18N is supported */
+/* #undef NE_HAVE_I18N */
+
+/* Defined if IPV6 is supported */
+/* #undef NE_HAVE_IPV6 */
+
+/* Defined if LFS is supported */
+/* #undef NE_HAVE_LFS */
+
+/* Defined if LIBPXY is supported */
+/* #undef NE_HAVE_LIBPXY */
+
+/* Defined if SSL is supported */
+/* #undef NE_HAVE_SSL */
+
+/* Defined if TS_SSL is supported */
+/* #undef NE_HAVE_TS_SSL */
+
+/* Defined if ZLIB is supported */
+/* #undef NE_HAVE_ZLIB */
+
+/* Define to be filename of an SSL CA root bundle */
+/* #undef NE_SSL_CA_BUNDLE */
+
+/* Define if poll() should be used */
+/* #undef NE_USE_POLL */
+
+/* Define to be neon library major version */
+#define NE_VERSION_MAJOR (0)
+
+/* Define to be neon library minor version */
+#define NE_VERSION_MINOR (30)
+
+/* Define to be neon library patch version */
+#define NE_VERSION_PATCH (0)
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "neon@lists.manyfish.co.uk"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "neon"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "neon 0.30.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "neon"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.30.0"
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `off64_t', as computed by sizeof. */
+/* #undef SIZEOF_OFF64_T */
+
+/* The size of `off_t', as computed by sizeof. */
+#define SIZEOF_OFF_T 8
+
+/* The size of `size_t', as computed by sizeof. */
+#define SIZEOF_SIZE_T 8
+
+/* The size of `ssize_t', as computed by sizeof. */
+#define SIZEOF_SSIZE_T 8
+
+/* The size of `time_t', as computed by sizeof. */
+#define SIZEOF_TIME_T 8
+
+/* The size of `XML_Size', as computed by sizeof. */
+/* #undef SIZEOF_XML_SIZE */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#define USE_GAI_ADDRCONFIG 1
+
+/* Define if getaddrinfo() should be used */
+#define USE_GETADDRINFO 1
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+/* #undef _GNU_SOURCE */
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+/* #undef _POSIX_PTHREAD_SEMANTICS */
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+/* #undef _TANDEM_SOURCE */
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+/* #undef __EXTENSIONS__ */
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+/* #undef _GNU_SOURCE */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define if in_addr_t is not available */
+/* #undef in_addr_t */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define if socklen_t is not available */
+/* #undef socklen_t */
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.h.cmake.in b/net/mmt/neon/config.h.cmake.in
new file mode 100644
index 0000000..a106041
--- /dev/null
+++ b/net/mmt/neon/config.h.cmake.in
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#cmakedefine AC_APPLE_UNIVERSAL_BUILD @AC_APPLE_UNIVERSAL_BUILD@
+
+/* Define to specific EGD socket path */
+#cmakedefine EGD_PATH @EGD_PATH@
+
+/* Define if EGD should be supported */
+#cmakedefine ENABLE_EGD @ENABLE_EGD@
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+#cmakedefine GSS_C_NT_HOSTBASED_SERVICE @GSS_C_NT_HOSTBASED_SERVICE@
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#cmakedefine HAVE_ARPA_INET_H @HAVE_ARPA_INET_H@
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#cmakedefine HAVE_BIND_TEXTDOMAIN_CODESET @HAVE_BIND_TEXTDOMAIN_CODESET@
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+#cmakedefine HAVE_CRYPTO_SET_IDPTR_CALLBACK @HAVE_CRYPTO_SET_IDPTR_CALLBACK@
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_H_ERRNO @HAVE_DECL_H_ERRNO@
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_STPCPY @HAVE_DECL_STPCPY@
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_STRERROR_R @HAVE_DECL_STRERROR_R@
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H @HAVE_DLFCN_H@
+
+/* Define to 1 if you have the <errno.h> header file. */
+#cmakedefine HAVE_ERRNO_H @HAVE_ERRNO_H@
+
+/* Define if you have expat */
+#cmakedefine HAVE_EXPAT @HAVE_EXPAT@
+
+/* Define to 1 if you have the `fcntl' function. */
+#cmakedefine HAVE_FCNTL @HAVE_FCNTL@
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H @HAVE_FCNTL_H@
+
+/* Define to 1 if you have the `fstat64' function. */
+#cmakedefine HAVE_FSTAT64 @HAVE_FSTAT64@
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#cmakedefine HAVE_GAI_STRERROR @HAVE_GAI_STRERROR@
+
+/* Define to 1 if you have the `gethostname' function. */
+#cmakedefine HAVE_GETHOSTNAME @HAVE_GETHOSTNAME@
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#cmakedefine HAVE_GETNAMEINFO @HAVE_GETNAMEINFO@
+
+/* Define to 1 if you have the `getsockopt' function. */
+#cmakedefine HAVE_GETSOCKOPT @HAVE_GETSOCKOPT@
+
+/* Define if GnuTLS support is enabled */
+#cmakedefine HAVE_GNUTLS @HAVE_GNUTLS@
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+#cmakedefine HAVE_GNUTLS_CERTIFICATE_GET_ISSUER @HAVE_GNUTLS_CERTIFICATE_GET_ISSUER@
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+#cmakedefine HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS @HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS@
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+#cmakedefine HAVE_GNUTLS_SESSION_GET_DATA2 @HAVE_GNUTLS_SESSION_GET_DATA2@
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+#cmakedefine HAVE_GNUTLS_SIGN_CALLBACK_SET @HAVE_GNUTLS_SIGN_CALLBACK_SET@
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+#cmakedefine HAVE_GNUTLS_X509_CRT_SIGN2 @HAVE_GNUTLS_X509_CRT_SIGN2@
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+#cmakedefine HAVE_GNUTLS_X509_DN_GET_RDN_AVA @HAVE_GNUTLS_X509_DN_GET_RDN_AVA@
+
+/* Define if GSSAPI support is enabled */
+#cmakedefine HAVE_GSSAPI @HAVE_GSSAPI@
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+#cmakedefine HAVE_GSSAPI_GSSAPI_GENERIC_H @HAVE_GSSAPI_GSSAPI_GENERIC_H@
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+#cmakedefine HAVE_GSSAPI_GSSAPI_H @HAVE_GSSAPI_GSSAPI_H@
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+#cmakedefine HAVE_GSSAPI_H @HAVE_GSSAPI_H@
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+#cmakedefine HAVE_GSS_INIT_SEC_CONTEXT @HAVE_GSS_INIT_SEC_CONTEXT@
+
+/* Define to 1 if you have the `hstrerror' function. */
+#cmakedefine HAVE_HSTRERROR @HAVE_HSTRERROR@
+
+/* Define to 1 if you have the `iconv' function. */
+#cmakedefine HAVE_ICONV @HAVE_ICONV@
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#cmakedefine HAVE_ICONV_H @HAVE_ICONV_H@
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#cmakedefine HAVE_INET_NTOP @HAVE_INET_NTOP@
+
+/* Define to 1 if you have the `inet_pton' function. */
+#cmakedefine HAVE_INET_PTON @HAVE_INET_PTON@
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H @HAVE_INTTYPES_H@
+
+/* Define to 1 if you have the `isatty' function. */
+#cmakedefine HAVE_ISATTY @HAVE_ISATTY@
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#cmakedefine HAVE_LIBINTL_H @HAVE_LIBINTL_H@
+
+/* Define if libproxy is supported */
+#cmakedefine HAVE_LIBPROXY @HAVE_LIBPROXY@
+
+/* Define if you have libxml */
+#cmakedefine HAVE_LIBXML @HAVE_LIBXML@
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+#cmakedefine HAVE_LIBXML_PARSER_H @HAVE_LIBXML_PARSER_H@
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+#cmakedefine HAVE_LIBXML_XMLVERSION_H @HAVE_LIBXML_XMLVERSION_H@
+
+/* Define to 1 if you have the <limits.h> header file. */
+#cmakedefine HAVE_LIMITS_H @HAVE_LIMITS_H@
+
+/* Define to 1 if you have the <locale.h> header file. */
+#cmakedefine HAVE_LOCALE_H @HAVE_LOCALE_H@
+
+/* Define to 1 if you have the `lseek64' function. */
+#cmakedefine HAVE_LSEEK64 @HAVE_LSEEK64@
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H @HAVE_MEMORY_H@
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#cmakedefine HAVE_NETDB_H @HAVE_NETDB_H@
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#cmakedefine HAVE_NETINET_IN_H @HAVE_NETINET_IN_H@
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#cmakedefine HAVE_NETINET_TCP_H @HAVE_NETINET_TCP_H@
+
+/* Define if NTLM is supported */
+#cmakedefine HAVE_NTLM @HAVE_NTLM@
+
+/* Define if OpenSSL support is enabled */
+#cmakedefine HAVE_OPENSSL @HAVE_OPENSSL@
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+#cmakedefine HAVE_OPENSSL_OPENSSLV_H @HAVE_OPENSSL_OPENSSLV_H@
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#cmakedefine HAVE_OPENSSL_SSL_H @HAVE_OPENSSL_SSL_H@
+
+/* Define if pakchois library supported */
+#cmakedefine HAVE_PAKCHOIS @HAVE_PAKCHOIS@
+
+/* Define to 1 if you have the `pipe' function. */
+#cmakedefine HAVE_PIPE @HAVE_PIPE@
+
+/* Define to 1 if you have the `poll' function. */
+#cmakedefine HAVE_POLL @HAVE_POLL@
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#cmakedefine HAVE_PTHREAD_MUTEX_INIT @HAVE_PTHREAD_MUTEX_INIT@
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#cmakedefine HAVE_PTHREAD_MUTEX_LOCK @HAVE_PTHREAD_MUTEX_LOCK@
+
+/* Define to 1 if you have the `setlocale' function. */
+#cmakedefine HAVE_SETLOCALE @HAVE_SETLOCALE@
+
+/* Define to 1 if you have the `setsockopt' function. */
+#cmakedefine HAVE_SETSOCKOPT @HAVE_SETSOCKOPT@
+
+/* Define to 1 if you have the `setvbuf' function. */
+#cmakedefine HAVE_SETVBUF @HAVE_SETVBUF@
+
+/* Define to 1 if you have the `shutdown' function. */
+#cmakedefine HAVE_SHUTDOWN @HAVE_SHUTDOWN@
+
+/* Define to 1 if you have the `signal' function. */
+#cmakedefine HAVE_SIGNAL @HAVE_SIGNAL@
+
+/* Define to 1 if you have the <signal.h> header file. */
+#cmakedefine HAVE_SIGNAL_H @HAVE_SIGNAL_H@
+
+/* Define to 1 if you have the `snprintf' function. */
+#cmakedefine HAVE_SNPRINTF @HAVE_SNPRINTF@
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#cmakedefine HAVE_SOCKLEN_T @HAVE_SOCKLEN_T@
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+#cmakedefine HAVE_SSL_SESSION_CMP @HAVE_SSL_SESSION_CMP@
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#cmakedefine HAVE_STDARG_H @HAVE_STDARG_H@
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H @HAVE_STDINT_H@
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H @HAVE_STDLIB_H@
+
+/* Define to 1 if you have the `stpcpy' function. */
+#cmakedefine HAVE_STPCPY @HAVE_STPCPY@
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#cmakedefine HAVE_STRCASECMP @HAVE_STRCASECMP@
+
+/* Define to 1 if you have the `strerror_r' function. */
+#cmakedefine HAVE_STRERROR_R @HAVE_STRERROR_R@
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H @HAVE_STRINGS_H@
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H @HAVE_STRING_H@
+
+/* Define to 1 if you have the `strtoll' function. */
+#cmakedefine HAVE_STRTOLL @HAVE_STRTOLL@
+
+/* Define to 1 if you have the `strtoq' function. */
+#cmakedefine HAVE_STRTOQ @HAVE_STRTOQ@
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#cmakedefine HAVE_STRUCT_TM_TM_GMTOFF @HAVE_STRUCT_TM_TM_GMTOFF@
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+#cmakedefine HAVE_STRUCT_TM___TM_GMTOFF @HAVE_STRUCT_TM___TM_GMTOFF@
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+#cmakedefine HAVE_SYS_LIMITS_H @HAVE_SYS_LIMITS_H@
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#cmakedefine HAVE_SYS_POLL_H @HAVE_SYS_POLL_H@
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#cmakedefine HAVE_SYS_SELECT_H @HAVE_SYS_SELECT_H@
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#cmakedefine HAVE_SYS_SOCKET_H @HAVE_SYS_SOCKET_H@
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H @HAVE_SYS_STAT_H@
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H @HAVE_SYS_TIME_H@
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H @HAVE_SYS_TYPES_H@
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#cmakedefine HAVE_SYS_UIO_H @HAVE_SYS_UIO_H@
+
+/* Define if the timezone global is available */
+#cmakedefine HAVE_TIMEZONE @HAVE_TIMEZONE@
+
+/* Use trio printf replacement library */
+#cmakedefine HAVE_TRIO @HAVE_TRIO@
+
+/* Define to 1 if you have the <trio.h> header file. */
+#cmakedefine HAVE_TRIO_H @HAVE_TRIO_H@
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H @HAVE_UNISTD_H@
+
+/* Define to 1 if you have the `usleep' function. */
+#cmakedefine HAVE_USLEEP @HAVE_USLEEP@
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#cmakedefine HAVE_VSNPRINTF @HAVE_VSNPRINTF@
+
+/* Define to be location of localedir */
+#cmakedefine LOCALEDIR @LOCALEDIR@
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#cmakedefine LT_OBJDIR @LT_OBJDIR@
+
+/* Defined when neon is built as a library */
+#cmakedefine NEON_IS_LIBRARY @NEON_IS_LIBRARY@
+
+/* Define to be the neon version string */
+#cmakedefine NEON_VERSION @NEON_VERSION@
+
+/* Define to enable debugging */
+#cmakedefine NE_DEBUGGING @NE_DEBUGGING@
+
+/* Define to be printf format string for ne_off_t */
+#cmakedefine NE_FMT_NE_OFF_T @NE_FMT_NE_OFF_T@
+
+/* Define to be printf format string for off64_t */
+#cmakedefine NE_FMT_OFF64_T @NE_FMT_OFF64_T@
+
+/* Define to be printf format string for off_t */
+#cmakedefine NE_FMT_OFF_T @NE_FMT_OFF_T@
+
+/* Define to be printf format string for size_t */
+#cmakedefine NE_FMT_SIZE_T @NE_FMT_SIZE_T@
+
+/* Define to be printf format string for ssize_t */
+#cmakedefine NE_FMT_SSIZE_T @NE_FMT_SSIZE_T@
+
+/* Define to be printf format string for time_t */
+#cmakedefine NE_FMT_TIME_T @NE_FMT_TIME_T@
+
+/* Define to be printf format string for XML_Size */
+#cmakedefine NE_FMT_XML_SIZE @NE_FMT_XML_SIZE@
+
+/* Defined if DAV is supported */
+#cmakedefine NE_HAVE_DAV @NE_HAVE_DAV@
+
+/* Defined if I18N is supported */
+#cmakedefine NE_HAVE_I18N @NE_HAVE_I18N@
+
+/* Defined if IPV6 is supported */
+#cmakedefine NE_HAVE_IPV6 @NE_HAVE_IPV6@
+
+/* Defined if LFS is supported */
+#cmakedefine NE_HAVE_LFS @NE_HAVE_LFS@
+
+/* Defined if LIBPXY is supported */
+#cmakedefine NE_HAVE_LIBPXY @NE_HAVE_LIBPXY@
+
+/* Defined if SSL is supported */
+#cmakedefine NE_HAVE_SSL @NE_HAVE_SSL@
+
+/* Defined if TS_SSL is supported */
+#cmakedefine NE_HAVE_TS_SSL @NE_HAVE_TS_SSL@
+
+/* Defined if ZLIB is supported */
+#cmakedefine NE_HAVE_ZLIB @NE_HAVE_ZLIB@
+
+/* Define to be filename of an SSL CA root bundle */
+#cmakedefine NE_SSL_CA_BUNDLE @NE_SSL_CA_BUNDLE@
+
+/* Define if poll() should be used */
+#cmakedefine NE_USE_POLL @NE_USE_POLL@
+
+/* Define to be neon library major version */
+#define NE_VERSION_MAJOR @NE_VERSION_MAJOR@
+
+/* Define to be neon library minor version */
+#define NE_VERSION_MINOR @NE_VERSION_MINOR@
+
+/* Define to be neon library patch version */
+#define NE_VERSION_PATCH @NE_VERSION_PATCH@
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT @PACKAGE_BUGREPORT@
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME @PACKAGE_NAME@
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING @PACKAGE_STRING@
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME @PACKAGE_TARNAME@
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL @PACKAGE_URL@
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION @PACKAGE_VERSION@
+
+/* The size of `int', as computed by sizeof. */
+#cmakedefine SIZEOF_INT @SIZEOF_INT@
+
+/* The size of `long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+
+/* The size of `long long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG_LONG @SIZEOF_LONG_LONG@
+
+/* The size of `off64_t', as computed by sizeof. */
+#cmakedefine SIZEOF_OFF64_T @SIZEOF_OFF64_T@
+
+/* The size of `off_t', as computed by sizeof. */
+#cmakedefine SIZEOF_OFF_T @SIZEOF_OFF_T@
+
+/* The size of `size_t', as computed by sizeof. */
+#cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+
+/* The size of `ssize_t', as computed by sizeof. */
+#cmakedefine SIZEOF_SSIZE_T @SIZEOF_SSIZE_T@
+
+/* The size of `time_t', as computed by sizeof. */
+#cmakedefine SIZEOF_TIME_T @SIZEOF_TIME_T@
+
+/* The size of `XML_Size', as computed by sizeof. */
+#cmakedefine SIZEOF_XML_SIZE @SIZEOF_XML_SIZE@
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS @STDC_HEADERS@
+
+/* Define to 1 if strerror_r returns char *. */
+#cmakedefine STRERROR_R_CHAR_P @STRERROR_R_CHAR_P@
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#cmakedefine TIME_WITH_SYS_TIME @TIME_WITH_SYS_TIME@
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#cmakedefine USE_GAI_ADDRCONFIG @USE_GAI_ADDRCONFIG@
+
+/* Define if getaddrinfo() should be used */
+#cmakedefine USE_GETADDRINFO @USE_GETADDRINFO@
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+#cmakedefine _ALL_SOURCE @_ALL_SOURCE@
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+#cmakedefine _GNU_SOURCE @_GNU_SOURCE@
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+#cmakedefine _POSIX_PTHREAD_SEMANTICS @_POSIX_PTHREAD_SEMANTICS@
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+#cmakedefine _TANDEM_SOURCE @_TANDEM_SOURCE@
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+#cmakedefine __EXTENSIONS__ @__EXTENSIONS__@
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#cmakedefine WORDS_BIGENDIAN @WORDS_BIGENDIAN@
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+#cmakedefine _GNU_SOURCE @_GNU_SOURCE@
+
+/* Define to 1 if on MINIX. */
+#cmakedefine _MINIX @_MINIX@
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#cmakedefine _POSIX_1_SOURCE @_POSIX_1_SOURCE@
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#cmakedefine _POSIX_SOURCE @_POSIX_SOURCE@
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#cmakedefine const @const@
+
+/* Define if in_addr_t is not available */
+#cmakedefine in_addr_t @in_addr_t@
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#cmakedefine inline @inline@
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#cmakedefine off_t @off_t@
+
+/* Define to `int' if <sys/types.h> does not define. */
+#cmakedefine pid_t @pid_t@
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#cmakedefine size_t @size_t@
+
+/* Define if socklen_t is not available */
+#cmakedefine socklen_t @socklen_t@
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.h.in b/net/mmt/neon/config.h.in
new file mode 100644
index 0000000..c28a268
--- /dev/null
+++ b/net/mmt/neon/config.h.in
@@ -0,0 +1,506 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
+/* Define to specific EGD socket path */
+#undef EGD_PATH
+
+/* Define if EGD should be supported */
+#undef ENABLE_EGD
+
+/* Define if GSS_C_NT_HOSTBASED_SERVICE is not defined otherwise */
+#undef GSS_C_NT_HOSTBASED_SERVICE
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#undef HAVE_ARPA_INET_H
+
+/* Define to 1 if you have the `bind_textdomain_codeset' function. */
+#undef HAVE_BIND_TEXTDOMAIN_CODESET
+
+/* Define to 1 if you have the `CRYPTO_set_idptr_callback' function. */
+#undef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+#undef HAVE_DECL_H_ERRNO
+
+/* Define to 1 if you have the declaration of `stpcpy', and to 0 if you don't.
+   */
+#undef HAVE_DECL_STPCPY
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#undef HAVE_DECL_STRERROR_R
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define if you have expat */
+#undef HAVE_EXPAT
+
+/* Define to 1 if you have the `fcntl' function. */
+#undef HAVE_FCNTL
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the `fstat64' function. */
+#undef HAVE_FSTAT64
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#undef HAVE_GAI_STRERROR
+
+/* Define to 1 if you have the `gethostname' function. */
+#undef HAVE_GETHOSTNAME
+
+/* Define to 1 if you have the `getnameinfo' function. */
+#undef HAVE_GETNAMEINFO
+
+/* Define to 1 if you have the `getsockopt' function. */
+#undef HAVE_GETSOCKOPT
+
+/* Define if GnuTLS support is enabled */
+#undef HAVE_GNUTLS
+
+/* Define to 1 if you have the `gnutls_certificate_get_issuer' function. */
+#undef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+
+/* Define to 1 if you have the `gnutls_certificate_get_x509_cas' function. */
+#undef HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS
+
+/* Define to 1 if you have the `gnutls_session_get_data2' function. */
+#undef HAVE_GNUTLS_SESSION_GET_DATA2
+
+/* Define to 1 if you have the `gnutls_sign_callback_set' function. */
+#undef HAVE_GNUTLS_SIGN_CALLBACK_SET
+
+/* Define to 1 if you have the `gnutls_x509_crt_sign2' function. */
+#undef HAVE_GNUTLS_X509_CRT_SIGN2
+
+/* Define to 1 if you have the `gnutls_x509_dn_get_rdn_ava' function. */
+#undef HAVE_GNUTLS_X509_DN_GET_RDN_AVA
+
+/* Define if GSSAPI support is enabled */
+#undef HAVE_GSSAPI
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+#undef HAVE_GSSAPI_GSSAPI_GENERIC_H
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+#undef HAVE_GSSAPI_GSSAPI_H
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+#undef HAVE_GSSAPI_H
+
+/* Define to 1 if you have the `gss_init_sec_context' function. */
+#undef HAVE_GSS_INIT_SEC_CONTEXT
+
+/* Define to 1 if you have the `hstrerror' function. */
+#undef HAVE_HSTRERROR
+
+/* Define to 1 if you have the `iconv' function. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#undef HAVE_ICONV_H
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#undef HAVE_INET_NTOP
+
+/* Define to 1 if you have the `inet_pton' function. */
+#undef HAVE_INET_PTON
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `isatty' function. */
+#undef HAVE_ISATTY
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#undef HAVE_LIBINTL_H
+
+/* Define if libproxy is supported */
+#undef HAVE_LIBPROXY
+
+/* Define if you have libxml */
+#undef HAVE_LIBXML
+
+/* Define to 1 if you have the <libxml/parser.h> header file. */
+#undef HAVE_LIBXML_PARSER_H
+
+/* Define to 1 if you have the <libxml/xmlversion.h> header file. */
+#undef HAVE_LIBXML_XMLVERSION_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the `lseek64' function. */
+#undef HAVE_LSEEK64
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#undef HAVE_NETDB_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#undef HAVE_NETINET_IN_H
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#undef HAVE_NETINET_TCP_H
+
+/* Define if NTLM is supported */
+#undef HAVE_NTLM
+
+/* Define if OpenSSL support is enabled */
+#undef HAVE_OPENSSL
+
+/* Define to 1 if you have the <openssl/opensslv.h> header file. */
+#undef HAVE_OPENSSL_OPENSSLV_H
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#undef HAVE_OPENSSL_SSL_H
+
+/* Define if pakchois library supported */
+#undef HAVE_PAKCHOIS
+
+/* Define to 1 if you have the `pipe' function. */
+#undef HAVE_PIPE
+
+/* Define to 1 if you have the `poll' function. */
+#undef HAVE_POLL
+
+/* Define to 1 if you have the `pthread_mutex_init' function. */
+#undef HAVE_PTHREAD_MUTEX_INIT
+
+/* Define to 1 if you have the `pthread_mutex_lock' function. */
+#undef HAVE_PTHREAD_MUTEX_LOCK
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if you have the `setsockopt' function. */
+#undef HAVE_SETSOCKOPT
+
+/* Define to 1 if you have the `setvbuf' function. */
+#undef HAVE_SETVBUF
+
+/* Define to 1 if you have the `shutdown' function. */
+#undef HAVE_SHUTDOWN
+
+/* Define to 1 if you have the `signal' function. */
+#undef HAVE_SIGNAL
+
+/* Define to 1 if you have the <signal.h> header file. */
+#undef HAVE_SIGNAL_H
+
+/* Define to 1 if you have the `snprintf' function. */
+#undef HAVE_SNPRINTF
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#undef HAVE_SOCKLEN_T
+
+/* Define to 1 if you have the `SSL_SESSION_cmp' function. */
+#undef HAVE_SSL_SESSION_CMP
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#undef HAVE_STDARG_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `stpcpy' function. */
+#undef HAVE_STPCPY
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strerror_r' function. */
+#undef HAVE_STRERROR_R
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strtoll' function. */
+#undef HAVE_STRTOLL
+
+/* Define to 1 if you have the `strtoq' function. */
+#undef HAVE_STRTOQ
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#undef HAVE_STRUCT_TM_TM_GMTOFF
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+#undef HAVE_STRUCT_TM___TM_GMTOFF
+
+/* Define to 1 if you have the <sys/limits.h> header file. */
+#undef HAVE_SYS_LIMITS_H
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#undef HAVE_SYS_POLL_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#undef HAVE_SYS_UIO_H
+
+/* Define if the timezone global is available */
+#undef HAVE_TIMEZONE
+
+/* Use trio printf replacement library */
+#undef HAVE_TRIO
+
+/* Define to 1 if you have the <trio.h> header file. */
+#undef HAVE_TRIO_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `usleep' function. */
+#undef HAVE_USLEEP
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#undef HAVE_VSNPRINTF
+
+/* Define to be location of localedir */
+#undef LOCALEDIR
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Defined when neon is built as a library */
+#undef NEON_IS_LIBRARY
+
+/* Define to be the neon version string */
+#undef NEON_VERSION
+
+/* Define to enable debugging */
+#undef NE_DEBUGGING
+
+/* Define to be printf format string for ne_off_t */
+#undef NE_FMT_NE_OFF_T
+
+/* Define to be printf format string for off64_t */
+#undef NE_FMT_OFF64_T
+
+/* Define to be printf format string for off_t */
+#undef NE_FMT_OFF_T
+
+/* Define to be printf format string for size_t */
+#undef NE_FMT_SIZE_T
+
+/* Define to be printf format string for ssize_t */
+#undef NE_FMT_SSIZE_T
+
+/* Define to be printf format string for time_t */
+#undef NE_FMT_TIME_T
+
+/* Define to be printf format string for XML_Size */
+#undef NE_FMT_XML_SIZE
+
+/* Defined if DAV is supported */
+#undef NE_HAVE_DAV
+
+/* Defined if I18N is supported */
+#undef NE_HAVE_I18N
+
+/* Defined if IPV6 is supported */
+#undef NE_HAVE_IPV6
+
+/* Defined if LFS is supported */
+#undef NE_HAVE_LFS
+
+/* Defined if LIBPXY is supported */
+#undef NE_HAVE_LIBPXY
+
+/* Defined if SSL is supported */
+#undef NE_HAVE_SSL
+
+/* Defined if TS_SSL is supported */
+#undef NE_HAVE_TS_SSL
+
+/* Defined if ZLIB is supported */
+#undef NE_HAVE_ZLIB
+
+/* Define to be filename of an SSL CA root bundle */
+#undef NE_SSL_CA_BUNDLE
+
+/* Define if poll() should be used */
+#undef NE_USE_POLL
+
+/* Define to be neon library major version */
+#undef NE_VERSION_MAJOR
+
+/* Define to be neon library minor version */
+#undef NE_VERSION_MINOR
+
+/* Define to be neon library patch version */
+#undef NE_VERSION_PATCH
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* The size of `off64_t', as computed by sizeof. */
+#undef SIZEOF_OFF64_T
+
+/* The size of `off_t', as computed by sizeof. */
+#undef SIZEOF_OFF_T
+
+/* The size of `size_t', as computed by sizeof. */
+#undef SIZEOF_SIZE_T
+
+/* The size of `ssize_t', as computed by sizeof. */
+#undef SIZEOF_SSIZE_T
+
+/* The size of `time_t', as computed by sizeof. */
+#undef SIZEOF_TIME_T
+
+/* The size of `XML_Size', as computed by sizeof. */
+#undef SIZEOF_XML_SIZE
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define to 1 if strerror_r returns char *. */
+#undef STRERROR_R_CHAR_P
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#undef TIME_WITH_SYS_TIME
+
+/* Define if getaddrinfo supports AI_ADDRCONFIG */
+#undef USE_GAI_ADDRCONFIG
+
+/* Define if getaddrinfo() should be used */
+#undef USE_GETADDRINFO
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
+/* Always defined to enable GNU extensions */
+#undef _GNU_SOURCE
+
+/* Define to 1 if on MINIX. */
+#undef _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#undef _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#undef _POSIX_SOURCE
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define if in_addr_t is not available */
+#undef in_addr_t
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef pid_t
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define if socklen_t is not available */
+#undef socklen_t
+
+
+/* Enable leak-tracking versions of ne_*alloc when NEON_MEMLEAK is enabled */
+#ifdef NEON_MEMLEAK
+# include "memleak.h"
+#endif
+
+#if defined(HAVE_STPCPY) && defined(HAVE_DECL_STPCPY) && !HAVE_DECL_STPCPY && !defined(stpcpy)
+char *stpcpy(char *, const char *);
+#endif
diff --git a/net/mmt/neon/config.hw b/net/mmt/neon/config.hw
new file mode 100644
index 0000000..77a0358
--- /dev/null
+++ b/net/mmt/neon/config.hw
@@ -0,0 +1,98 @@
+/*                                                      -*- c -*-
+   Win32 config.h
+   Copyright (C) 1999-2000, Peter Boos <pedib@colorfullife.com>
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#if defined(_WIN32) && !defined(WIN32)
+#define WIN32
+#endif
+
+#ifdef WIN32
+
+#define NEON_VERSION "0.30.0"
+#define NE_VERSION_MAJOR (0)
+#define NE_VERSION_MINOR (30)
+
+#define HAVE_ERRNO_H
+#define HAVE_LIMITS_H
+#define HAVE_STDLIB_H
+#define HAVE_STRING_H
+
+#define HAVE_MEMCPY
+#define HAVE_SETSOCKOPT
+
+#define HAVE_SSPI
+
+#define NE_HAVE_TS_SSL 1
+
+/* Define to enable debugging */
+#define NE_DEBUGGING 1
+
+#define NE_FMT_SIZE_T "u"
+#define NE_FMT_SSIZE_T "d"
+#define NE_FMT_OFF_T "ld"
+#define NE_FMT_OFF64_T "I64d"
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+#ifndef NE_FMT_XML_SIZE
+#define NE_FMT_XML_SIZE "d"
+#endif
+
+/* needs adjusting for Win64... */
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+
+/* Win32 uses a underscore, so we use a macro to eliminate that. */
+#define snprintf			_snprintf
+/* VS2008 has this already defined */
+#if (_MSC_VER < 1500)
+#define vsnprintf			_vsnprintf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define strcasecmp			_strcmpi
+#define strncasecmp			_strnicmp
+#else
+#define strcasecmp			strcmpi
+#define strncasecmp			strnicmp
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1300
+#define HAVE_STRTOLL
+#define strtoll				_strtoi64
+#endif
+#define ssize_t				int
+#define inline                          __inline
+#if defined(NE_LFS)
+#define lseek64				_lseeki64
+#define fstat64				_fstat64
+#define stat64				__stat64
+#else
+#define off_t                           _off_t
+#endif
+
+#ifndef USE_GETADDRINFO
+#define in_addr_t                       unsigned int
+#endif
+
+typedef int socklen_t;
+
+#include <io.h>
+#define read _read
+
+#endif
diff --git a/net/mmt/neon/config.hw.in b/net/mmt/neon/config.hw.in
new file mode 100644
index 0000000..5bee759
--- /dev/null
+++ b/net/mmt/neon/config.hw.in
@@ -0,0 +1,98 @@
+/*                                                      -*- c -*-
+   Win32 config.h
+   Copyright (C) 1999-2000, Peter Boos <pedib@colorfullife.com>
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#if defined(_WIN32) && !defined(WIN32)
+#define WIN32
+#endif
+
+#ifdef WIN32
+
+#define NEON_VERSION "@VERSION@"
+#define NE_VERSION_MAJOR (@MAJOR@)
+#define NE_VERSION_MINOR (@MINOR@)
+
+#define HAVE_ERRNO_H
+#define HAVE_LIMITS_H
+#define HAVE_STDLIB_H
+#define HAVE_STRING_H
+
+#define HAVE_MEMCPY
+#define HAVE_SETSOCKOPT
+
+#define HAVE_SSPI
+
+#define NE_HAVE_TS_SSL 1
+
+/* Define to enable debugging */
+#define NE_DEBUGGING 1
+
+#define NE_FMT_SIZE_T "u"
+#define NE_FMT_SSIZE_T "d"
+#define NE_FMT_OFF_T "ld"
+#define NE_FMT_OFF64_T "I64d"
+#define NE_FMT_NE_OFF_T NE_FMT_OFF_T
+
+#ifndef NE_FMT_XML_SIZE
+#define NE_FMT_XML_SIZE "d"
+#endif
+
+/* needs adjusting for Win64... */
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 4
+
+/* Win32 uses a underscore, so we use a macro to eliminate that. */
+#define snprintf			_snprintf
+/* VS2008 has this already defined */
+#if (_MSC_VER < 1500)
+#define vsnprintf			_vsnprintf
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#define strcasecmp			_strcmpi
+#define strncasecmp			_strnicmp
+#else
+#define strcasecmp			strcmpi
+#define strncasecmp			strnicmp
+#endif
+#if defined(_MSC_VER) && _MSC_VER >= 1300
+#define HAVE_STRTOLL
+#define strtoll				_strtoi64
+#endif
+#define ssize_t				int
+#define inline                          __inline
+#if defined(NE_LFS)
+#define lseek64				_lseeki64
+#define fstat64				_fstat64
+#define stat64				__stat64
+#else
+#define off_t                           _off_t
+#endif
+
+#ifndef USE_GETADDRINFO
+#define in_addr_t                       unsigned int
+#endif
+
+typedef int socklen_t;
+
+#include <io.h>
+#define read _read
+
+#endif
diff --git a/net/mmt/neon/neon.gyp b/net/mmt/neon/neon.gyp
new file mode 100644
index 0000000..150fa8f
--- /dev/null
+++ b/net/mmt/neon/neon.gyp
@@ -0,0 +1,103 @@
+# Copyright (c) 2012 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+{
+  'conditions': [
+    [ 'os_posix == 1 and OS != "mac" and OS != "ios"', {
+      'conditions': [
+        ['sysroot!=""', {
+          'variables': {
+            'pkg-config': '../../../build/linux/pkg-config-wrapper "<(sysroot)" "<(target_arch)" "<(system_libdir)"',
+          },
+        }, {
+          'variables': {
+            'pkg-config': 'pkg-config'
+          },
+        }],
+      ],
+    }],
+  ],
+
+  'targets': [
+    {
+      'target_name': 'libneon',
+      # 'type': '<(component)',
+      # 'type': 'loadable_module',
+      'type': 'static_library',
+      'product_name': 'neon',
+      'sources': [
+          'src/ne_dates.c',
+          'src/ne_session.c',
+          'src/ne_uri.c',
+          'src/ne_socket.c',
+          'src/ne_utils.c',
+          'src/ne_alloc.c',   
+          'src/ne_i18n.c',   
+          'src/ne_pkcs11.c',   
+          'src/ne_socks.c',
+          'src/ne_auth.c',   
+          'src/ne_sspi.c',
+          'src/ne_md5.c',  
+          'src/ne_redirect.c',  
+          'src/ne_string.c',
+          'src/ne_compress.c',  
+          'src/ne_ntlm.c',
+          'src/ne_request.c',
+          'src/ne_stubssl.c',
+      ],
+      'defines': [
+        'DEBUG',
+      ],
+      'msvs_disabled_warnings': [4018, 4244, 4267],
+      'variables': {
+        'clang_warning_flags_unset': [
+          # ssl uses PR_ASSERT(!"foo") instead of PR_ASSERT(false && "foo")
+          '-Wstring-conversion',
+        ],
+      },
+      'conditions': [
+        ['component == "shared_library"', {
+          'conditions': [
+            ['OS == "mac" or OS == "ios"', {
+              'xcode_settings': {
+                'GCC_SYMBOLS_PRIVATE_EXTERN': 'NO',
+              },
+            }],
+            ['os_posix == 1 and OS != "mac" and OS != "ios"', {
+              'cflags!': ['-fvisibility=hidden'],
+            }],
+          ],
+        }],
+        [ 'clang == 1', {
+          'cflags': [
+            # There is a broken header guard in /usr/include/nss/secmod.h:
+            # https://bugzilla.mozilla.org/show_bug.cgi?id=884072
+            '-Wno-header-guard',
+          ],
+        }],
+        [ 'os_posix == 1', {
+          'include_dirs': [
+            '',
+          ],
+          'cflags': [
+            '',
+          ],
+          'ldflags': [
+            '',
+          ],
+          'libraries': [
+            '',
+          ],
+        }],
+      ],
+      'configurations': {
+        'Debug_Base': {
+          'defines': [
+            'DEBUG',
+          ],
+        },
+      },
+    },
+  ],
+}
diff --git a/net/mmt/neon/src/memleak.h b/net/mmt/neon/src/memleak.h
new file mode 100644
index 0000000..8d77dcb
--- /dev/null
+++ b/net/mmt/neon/src/memleak.h
@@ -0,0 +1,55 @@
+/* 
+   Memory leak wrappers
+   Copyright (C) 2003, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* WARNING: THIS IS AN INTERNAL NEON INTERFACE AND MUST NOT BE USED
+ * from NEON APPLICATIONS. */
+
+/* This file contains an alternate interface to the memory allocation
+ * wrappers in ne_alloc.c, which perform simple leak detection.  It
+ * MUST NOT BE INSTALLED, or used from neon applications. */
+
+#ifndef MEMLEAK_H
+#define MEMLEAK_H
+
+#include <stdio.h>
+
+#define ne_malloc(s) ne_malloc_ml(s, __FILE__, __LINE__)
+#define ne_calloc(s) ne_calloc_ml(s, __FILE__, __LINE__)
+#define ne_realloc(p, s) ne_realloc_ml(p, s, __FILE__, __LINE__)
+#define ne_strdup(s) ne_strdup_ml(s, __FILE__, __LINE__)
+#define ne_strndup(s, n) ne_strndup_ml(s, n, __FILE__, __LINE__)
+#define ne_free ne_free_ml
+
+/* Prototypes of allocation functions: */
+void *ne_malloc_ml(size_t size, const char *file, int line);
+void *ne_calloc_ml(size_t size, const char *file, int line);
+void *ne_realloc_ml(void *ptr, size_t s, const char *file, int line);
+char *ne_strdup_ml(const char *s, const char *file, int line);
+char *ne_strndup_ml(const char *s, size_t n, const char *file, int line);
+void ne_free_ml(void *ptr);
+
+/* Dump the list of currently allocated blocks to 'f'. */
+void ne_alloc_dump(FILE *f);
+
+/* Current number of bytes in allocated but not free'd. */
+extern size_t ne_alloc_used;
+
+#endif /* MEMLEAK_H */
diff --git a/net/mmt/neon/src/ne_207.c b/net/mmt/neon/src/ne_207.c
new file mode 100644
index 0000000..b9cc9e8
--- /dev/null
+++ b/net/mmt/neon/src/ne_207.c
@@ -0,0 +1,371 @@
+/* 
+   WebDAV 207 multi-status response handling
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Generic handling for WebDAV 207 Multi-Status responses. */
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_xml.h"
+#include "ne_207.h"
+#include "ne_uri.h"
+#include "ne_basic.h"
+
+#include "ne_internal.h"
+
+struct ne_207_parser_s {
+    ne_207_start_response *start_response;
+    ne_207_end_response *end_response;
+    ne_207_start_propstat *start_propstat;
+    ne_207_end_propstat *end_propstat;
+    ne_xml_parser *parser;
+    void *userdata;
+
+    ne_uri base;
+
+    ne_buffer *cdata;
+
+    /* remember whether we are in a response: the validation
+     * doesn't encapsulate this since we only count as being 
+     * "in a response" when we've seen the href element. */
+    int in_response;
+
+    /* current position */
+    void *response, *propstat;
+    /* caching */
+    ne_status status;
+    char *description, *href;
+};
+
+#define ELM_multistatus 1
+#define ELM_response 2
+#define ELM_responsedescription 3
+#define ELM_href 4
+#define ELM_prop (NE_207_STATE_PROP)
+#define ELM_status 6
+#define ELM_propstat 7
+
+static const struct ne_xml_idmap map207[] = {
+    { "DAV:", "multistatus", ELM_multistatus },
+    { "DAV:", "response", ELM_response },
+    { "DAV:", "responsedescription", ELM_responsedescription },
+    { "DAV:", "href", ELM_href },
+    { "DAV:", "propstat", ELM_propstat },
+    { "DAV:", "prop",  ELM_prop },
+    { "DAV:", "status", ELM_status }
+};
+
+/* Set the callbacks for the parser */
+void ne_207_set_response_handlers(ne_207_parser *p,
+                                  ne_207_start_response *start,
+                                  ne_207_end_response *end)
+{
+    p->start_response = start;
+    p->end_response = end;
+}
+
+void ne_207_set_propstat_handlers(ne_207_parser *p,
+				   ne_207_start_propstat *start,
+				   ne_207_end_propstat *end)
+{
+    p->start_propstat = start;
+    p->end_propstat = end;
+}
+
+void *ne_207_get_current_response(ne_207_parser *p)
+{
+    return p->response;
+}
+
+void *ne_207_get_current_propstat(ne_207_parser *p)
+{
+    return p->propstat;
+}
+
+/* return non-zero if (child, parent) is an interesting element */
+static int can_handle(int parent, int child) 
+{
+    return (parent == 0 && child == ELM_multistatus) ||
+        (parent == ELM_multistatus && child == ELM_response) ||
+        (parent == ELM_response && 
+         (child == ELM_href || child == ELM_status || 
+          child == ELM_propstat || child == ELM_responsedescription)) ||
+        (parent == ELM_propstat &&
+         (child == ELM_prop || child == ELM_status ||
+          child == ELM_responsedescription));
+}
+
+static int cdata_207(void *userdata, int state, const char *buf, size_t len)
+{
+    ne_207_parser *p = userdata;
+
+    if ((state == ELM_href || state == ELM_responsedescription ||
+         state == ELM_status) && p->cdata->used + len < 2048)
+        ne_buffer_append(p->cdata, buf, len);
+
+    return 0;
+}
+
+static int start_element(void *userdata, int parent, 
+                         const char *nspace, const char *name, 
+                         const char **atts) 
+{
+    ne_207_parser *p = userdata;
+    int state = ne_xml_mapid(map207, NE_XML_MAPLEN(map207), nspace, name);
+
+    if (!can_handle(parent, state))
+        return NE_XML_DECLINE;
+
+    /* if not in a response, ignore everything. */
+    if (!p->in_response && state != ELM_response && state != ELM_multistatus &&
+        state != ELM_href)
+        return NE_XML_DECLINE;
+
+    if (state == ELM_propstat && p->start_propstat) {
+        p->propstat = p->start_propstat(p->userdata, p->response);
+        if (p->propstat == NULL) {
+            return NE_XML_ABORT;
+        }
+    }
+
+    ne_buffer_clear(p->cdata);
+
+    return state;
+}
+
+#define GIVE_STATUS(p) ((p)->status.reason_phrase?&(p)->status:NULL)
+
+#define HAVE_CDATA(p) ((p)->cdata->used > 1)
+
+static int 
+end_element(void *userdata, int state, const char *nspace, const char *name)
+{
+    ne_207_parser *p = userdata;
+    const char *cdata = ne_shave(p->cdata->data, "\r\n\t ");
+
+    switch (state) {
+    case ELM_responsedescription:
+	if (HAVE_CDATA(p)) {
+            if (p->description) ne_free(p->description);
+	    p->description = ne_strdup(cdata);
+	}
+	break;
+    case ELM_href:
+	/* Now we have the href, begin the response */
+	if (p->start_response && HAVE_CDATA(p)) {
+            ne_uri ref, resolved;
+
+            if (ne_uri_parse(cdata, &ref) == 0) {
+                ne_uri_resolve(&p->base, &ref, &resolved);
+
+                p->response = p->start_response(p->userdata, &resolved);
+                p->in_response = 1;
+                ne_uri_free(&resolved);
+            }
+            ne_uri_free(&ref);
+	}
+	break;
+    case ELM_status:
+	if (HAVE_CDATA(p)) {
+            if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+	    if (ne_parse_statusline(cdata, &p->status)) {
+		char buf[500];
+		NE_DEBUG(NE_DBG_HTTP, "Status line: %s\n", cdata);
+		ne_snprintf(buf, 500, 
+			    _("Invalid HTTP status line in status element "
+                              "at line %d of response:\nStatus line was: %s"),
+			    ne_xml_currentline(p->parser), cdata);
+		ne_xml_set_error(p->parser, buf);
+		return -1;
+	    } else {
+		NE_DEBUG(NE_DBG_XML, "Decoded status line: %s\n", cdata);
+	    }
+	}
+	break;
+    case ELM_propstat:
+	if (p->end_propstat)
+	    p->end_propstat(p->userdata, p->propstat, GIVE_STATUS(p),
+			    p->description);
+	p->propstat = NULL;
+        if (p->description) ne_free(p->description);
+        if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+        p->description = p->status.reason_phrase = NULL;
+	break;
+    case ELM_response:
+        if (!p->in_response) break;
+	if (p->end_response)
+	    p->end_response(p->userdata, p->response, GIVE_STATUS(p),
+			    p->description);
+	p->response = NULL;
+	p->in_response = 0;
+        if (p->description) ne_free(p->description);
+        if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+        p->description = p->status.reason_phrase = NULL;
+	break;
+    }
+    return 0;
+}
+
+ne_207_parser *ne_207_create(ne_xml_parser *parser, const ne_uri *base, 
+                             void *userdata)
+{
+    ne_207_parser *p = ne_calloc(sizeof *p);
+
+    p->parser = parser;
+    p->userdata = userdata;
+    p->cdata = ne_buffer_create();
+
+    ne_uri_copy(&p->base, base);
+
+    /* Add handler for the standard 207 elements */
+    ne_xml_push_handler(parser, start_element, cdata_207, end_element, p);
+    
+    return p;
+}
+
+void ne_207_destroy(ne_207_parser *p) 
+{
+    if (p->status.reason_phrase) ne_free(p->status.reason_phrase);
+    ne_buffer_destroy(p->cdata);
+    ne_uri_free(&p->base);
+    ne_free(p);
+}
+
+int ne_accept_207(void *userdata, ne_request *req, const ne_status *status)
+{
+    return (status->code == 207);
+}
+
+/* Handling of 207 errors: we keep a string buffer, and append
+ * messages to it as they come down.
+ *
+ * Note, 424 means it would have worked but something else went wrong.
+ * We will have had the error for "something else", so we display
+ * that, and skip 424 errors. */
+
+/* This is passed as userdata to the 207 code. */
+struct context {
+    char *href;
+    ne_buffer *buf;
+    unsigned int is_error;
+};
+
+static void *start_response(void *userdata, const ne_uri *uri)
+{
+    struct context *ctx = userdata;
+    if (ctx->href) ne_free(ctx->href);
+    ctx->href = ne_uri_unparse(uri);
+    return NULL;
+}
+
+static void handle_error(struct context *ctx, const ne_status *status,
+			 const char *description)
+{
+    if (status && status->klass != 2 && status->code != 424) {
+	char buf[50];
+	ctx->is_error = 1;
+	sprintf(buf, "%d", status->code);
+	ne_buffer_concat(ctx->buf, ctx->href, ": ", 
+			 buf, " ", status->reason_phrase, "\n", NULL);
+	if (description != NULL) {
+	    /* TODO: these can be multi-line. Would be good to
+	     * word-wrap this at col 80. */
+	    ne_buffer_concat(ctx->buf, " -> ", description, "\n", NULL);
+	}
+    }
+
+}
+
+static void end_response(void *userdata, void *response,
+			 const ne_status *status, const char *description)
+{
+    struct context *ctx = userdata;
+    handle_error(ctx, status, description);
+}
+
+static void 
+end_propstat(void *userdata, void *propstat,
+	     const ne_status *status, const char *description)
+{
+    struct context *ctx = userdata;
+    handle_error(ctx, status, description);
+}
+
+/* Dispatch a DAV request and handle a 207 error response appropriately */
+/* TODO: hook up Content-Type parsing; passing charset to XML parser */
+int ne_simple_request(ne_session *sess, ne_request *req)
+{
+    int ret;
+    struct context ctx = {0};
+    ne_207_parser *p207;
+    ne_xml_parser *p = ne_xml_create();
+    ne_uri base = {0};
+
+    /* Mock up a base URI; it should really be retrieved from the
+     * request object. */
+    ne_fill_server_uri(sess, &base);
+    base.path = ne_strdup("/");
+    p207 = ne_207_create(p, &base, &ctx);
+    ne_uri_free(&base);    
+
+    /* The error string is progressively written into the
+     * ne_buffer by the element callbacks */
+    ctx.buf = ne_buffer_create();
+
+    ne_207_set_response_handlers(p207, start_response, end_response);
+    ne_207_set_propstat_handlers(p207, NULL, end_propstat);
+    
+    ne_add_response_body_reader(req, ne_accept_207, ne_xml_parse_v, p);
+
+    ret = ne_request_dispatch(req);
+
+    if (ret == NE_OK) {
+	if (ne_get_status(req)->code == 207) {
+	    if (ne_xml_failed(p)) { 
+		/* The parse was invalid */
+		ne_set_error(sess, "%s", ne_xml_get_error(p));
+		ret = NE_ERROR;
+	    } else if (ctx.is_error) {
+		/* If we've actually got any error information
+		 * from the 207, then set that as the error */
+		ne_set_error(sess, "%s", ctx.buf->data);
+		ret = NE_ERROR;
+	    }
+	} else if (ne_get_status(req)->klass != 2) {
+	    ret = NE_ERROR;
+	}
+    }
+
+    ne_207_destroy(p207);
+    ne_xml_destroy(p);
+    ne_buffer_destroy(ctx.buf);
+    if (ctx.href) ne_free(ctx.href);
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+    
diff --git a/net/mmt/neon/src/ne_207.h b/net/mmt/neon/src/ne_207.h
new file mode 100644
index 0000000..2779e56
--- /dev/null
+++ b/net/mmt/neon/src/ne_207.h
@@ -0,0 +1,103 @@
+/* 
+   WebDAV 207 multi-status response handling
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_207_H
+#define NE_207_H
+
+#include "ne_xml.h"
+#include "ne_request.h" /* for ne_request */
+#include "ne_uri.h" /* for ne_uri */
+
+NE_BEGIN_DECLS
+
+/* The defined state integer for the '{DAV:}prop' element. */
+#define NE_207_STATE_PROP (50)
+/* This interface reserves the state integers 'x' where 0 < x < 100 */
+#define NE_207_STATE_TOP (100)
+
+/* Handling of 207 multistatus XML documents.  A "multistatus"
+ * document is made up of a set of responses, each concerned with a
+ * particular resource.  Each response may have an associated result
+ * status and failure description.  A response is made up of a set of
+ * propstats, each of which again may have an associated result status
+ * and failure description. */
+
+/* Start and end response callbacks trigger at the start and end of
+ * each "response" within the multistatus body. 'uri' gives the URI
+ * of the resource which is subject of this response.  The return
+ * value of a 'start_response' callback is passed as the 'response'
+ * parameter to the corresponding 'end_response' parameter. */
+typedef void *ne_207_start_response(void *userdata, const ne_uri *uri);
+typedef void ne_207_end_response(void *userdata, void *response,
+                                 const ne_status *status,
+                                 const char *description);
+
+/* Similarly, start and end callbacks for each propstat within the
+ * response.  The return value of the 'start_response' callback for
+ * the response in which this propstat is contains is passed as the
+ * 'response' parameter.  The return value of each 'start_propstat' is
+ * passed as the 'propstat' parameter' to the corresponding
+ * 'end_propstat' callback.  If the start_propstat callback returns
+ * NULL, parsing is aborted (the XML parser error must be set by the
+ * callback). */
+typedef void *ne_207_start_propstat(void *userdata, void *response);
+typedef void ne_207_end_propstat(void *userdata, void *propstat,
+                                 const ne_status *status,
+                                 const char *description);
+
+typedef struct ne_207_parser_s ne_207_parser;
+
+/* Create 207 parser an add the handlers the the given parser's
+ * handler stack.  URI references in the 207 response will be resolved
+ * relative to the base URI 'base'. */
+ne_207_parser *ne_207_create(ne_xml_parser *parser, const ne_uri *base, 
+                             void *userdata);
+
+/* Register response handling callbacks. */
+void ne_207_set_response_handlers(ne_207_parser *p,
+                                  ne_207_start_response *start,
+                                  ne_207_end_response *end);
+
+/* Register propstat handling callbacks. */
+void ne_207_set_propstat_handlers(ne_207_parser *p, 
+                                  ne_207_start_propstat *start,
+                                  ne_207_end_propstat *end);
+
+/* Destroy the parser */
+void ne_207_destroy(ne_207_parser *p);
+
+/* An acceptance function which only accepts 207 responses */
+int ne_accept_207(void *userdata, ne_request *req, const ne_status *status);
+
+void *ne_207_get_current_propstat(ne_207_parser *p);
+void *ne_207_get_current_response(ne_207_parser *p);
+
+/* Dispatch request 'req', returning:
+ *  NE_ERROR: for a dispatch error, or a non-2xx response, or a
+ *            207 response which contained a non-2xx propstat
+ *  NE_OK: for a 2xx response or a 207 response which contained
+ *            only 2xx-class propstats.
+ * The request object is destroyed in both cases. */
+int ne_simple_request(ne_session *sess, ne_request *req);
+
+NE_END_DECLS
+
+#endif /* NE_207_H */
diff --git a/net/mmt/neon/src/ne_acl.h b/net/mmt/neon/src/ne_acl.h
new file mode 100644
index 0000000..a473981
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl.h
@@ -0,0 +1,60 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/*
+ * DEPRECATED ACL Interface.  See ne_acl3744.h for replacement API.
+ */
+
+#ifndef NE_ACL_H
+#define NE_ACL_H
+
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+typedef struct
+{
+    enum {
+	ne_acl_href,
+	ne_acl_property,
+	ne_acl_all
+    } apply;
+    
+    enum {
+	ne_acl_grant,
+	ne_acl_deny
+    } type;
+
+    char *principal;
+    int read;
+    int read_acl;
+    int write;
+    int write_acl;
+    int read_cuprivset;
+} ne_acl_entry;
+
+/* Set the ACL for the given resource to the list of ACL entries. */
+int ne_acl_set(ne_session *sess, const char *uri,
+	       const ne_acl_entry entries[], int numentries);
+
+NE_END_DECLS
+
+#endif /* NE_ACL_H */
diff --git a/net/mmt/neon/src/ne_acl3744.c b/net/mmt/neon/src/ne_acl3744.c
new file mode 100644
index 0000000..3ad7e1d
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl3744.c
@@ -0,0 +1,179 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, 2008, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2001, Arun Garg <arung@pspl.co.in>
+   Copyright (C) 2007 Henrik Holst <henrik.holst2@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Contributed by Arun Garg <arung@pspl.co.in> */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_locks.h"
+#include "ne_alloc.h"
+#include "ne_string.h"
+#include "ne_acl3744.h"
+#include "ne_uri.h"
+#include "ne_xml.h" /* for NE_XML_MEDIA_TYPE */
+
+#define EOL "\r\n"
+
+static ne_buffer *acl_body(const ne_acl_entry *right, int count)
+{
+    ne_buffer *body = ne_buffer_create();
+    int m;
+
+    ne_buffer_zappend(body,
+		      "<?xml version=\"1.0\" encoding=\"utf-8\"?>" EOL
+		      "<acl xmlns='DAV:'>" EOL);
+
+    for (m = 0; m < count; m++) {
+	const char *type;
+
+	type = (right[m].type == ne_acl_grant ? "grant" : "deny");
+
+	ne_buffer_concat(body, "<ace>" EOL "<principal>", NULL);
+
+	switch (right[m].target) {
+	case ne_acl_all:
+	    ne_buffer_czappend(body, "<all/>" EOL);
+	    break;
+	case ne_acl_authenticated:
+	    ne_buffer_czappend(body, "<authenticated/>" EOL);
+	    break;
+	case ne_acl_unauthenticated:
+	    ne_buffer_czappend(body, "<unauthenticated/>" EOL);
+	    break;
+	case ne_acl_self:
+	    ne_buffer_czappend(body, "<self/>" EOL);
+	    break;
+	case ne_acl_property:
+	    ne_buffer_concat(body, "<property><", right[m].tname,
+			     "/></property>" EOL, NULL);
+	    break;
+	case ne_acl_href:
+	    ne_buffer_concat(body, "<href>", right[m].tname,
+			     "</href>" EOL, NULL);
+	    break;
+	}
+
+	ne_buffer_concat(body, "</principal>" EOL 
+                         "<", type, ">" EOL, NULL);
+
+	if ((right[m].privileges & NE_ACL_READ) == NE_ACL_READ)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE) == NE_ACL_WRITE)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_PROPERTIES) == NE_ACL_WRITE_PROPERTIES)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-properties/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_CONTENT) == NE_ACL_WRITE_CONTENT)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-content/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_UNLOCK) == NE_ACL_UNLOCK)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<unlock/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_READ_ACL) == NE_ACL_READ_ACL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-acl/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_READ_CUPRIVSET) == NE_ACL_READ_CUPRIVSET)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-current-user-privileges-set/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_WRITE_ACL) == NE_ACL_WRITE_ACL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-acl/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_BIND) == NE_ACL_BIND)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<bind/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_UNBIND) == NE_ACL_UNBIND)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<unbind/>" "</privilege>" EOL,
+			     NULL);
+
+	if ((right[m].privileges & NE_ACL_ALL) == NE_ACL_ALL)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<all/>" "</privilege>" EOL,
+			     NULL);
+
+	ne_buffer_concat(body, "</", type, ">" EOL, NULL);
+	ne_buffer_czappend(body, "</ace>" EOL);
+    }
+
+    ne_buffer_czappend(body, "</acl>" EOL);
+
+    return body;
+}
+
+int ne_acl3744_set(ne_session *sess, const char *uri,
+                   const ne_acl_entry *entries, int numentries)
+{
+    int ret;
+    ne_request *req = ne_request_create(sess, "ACL", uri);
+    ne_buffer *body = acl_body(entries, numentries);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+#endif
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ret = ne_request_dispatch(req);
+
+    ne_buffer_destroy(body);
+
+    if (ret == NE_OK && ne_get_status(req)->code == 207) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_acl3744.h b/net/mmt/neon/src/ne_acl3744.h
new file mode 100644
index 0000000..dc8835c
--- /dev/null
+++ b/net/mmt/neon/src/ne_acl3744.h
@@ -0,0 +1,85 @@
+/*
+   Access control
+   Copyright (C) 2001-2007, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2001, Arun Garg <arung@pspl.co.in>
+   Copyright (C) 2007 Henrik Holst <henrik.holst2@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_ACL3744_H
+#define NE_ACL3744_H
+
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+#define NE_ACL_READ             (0x0001)
+#define NE_ACL_WRITE            (0x0002)
+#define NE_ACL_WRITE_PROPERTIES (0x0004)
+#define NE_ACL_WRITE_CONTENT    (0x0008)
+#define NE_ACL_UNLOCK           (0x0010)
+#define NE_ACL_READ_ACL         (0x0020)
+#define NE_ACL_READ_CUPRIVSET   (0x0040)
+#define NE_ACL_WRITE_ACL        (0x0080)
+#define NE_ACL_BIND             (0x0100)
+#define NE_ACL_UNBIND           (0x0200)
+#define NE_ACL_ALL              (0x0400)
+
+enum ne_acl_target {
+    ne_acl_href,
+    ne_acl_property,
+    ne_acl_all,
+    ne_acl_authenticated,
+    ne_acl_unauthenticated,
+    ne_acl_self
+};
+
+enum ne_acl_optype {
+    ne_acl_grant,
+    ne_acl_deny
+};
+
+/* A simplified representation of an Access Control Element (ACE): */
+typedef struct {
+    /* Identify the principal(s) to which this ACE applies: */
+    enum ne_acl_target target;
+
+    /* Whether to grant or deny access: */
+    enum ne_acl_optype type;
+
+    /* If target == ne_acl_href, tname must be non-NULL and give the
+     * principal URL.  If target == ne_acl_property, tname must be
+     * non-NULL and be a property name, including an XML namespace
+     * definition, if appropriate (the default namespace being
+     * "DAV:").  This restricts access as described at:
+     * http://tools.ietf.org/html/rfc3744#section-5.5.1 */
+    char *tname;
+
+    /* The set of privileges to be restricted; a bit mask of one or
+     * more of the NE_ACL_* constants defined above: */
+    unsigned int privileges;
+
+} ne_acl_entry;
+
+/* Set the ACL for the given resource to the list of ACL entries. */
+int ne_acl3744_set(ne_session *sess, const char *path,
+                   const ne_acl_entry entries[], int numentries);
+
+NE_END_DECLS
+
+#endif /* NE_ACL3744_H */
diff --git a/net/mmt/neon/src/ne_alloc.c b/net/mmt/neon/src/ne_alloc.c
new file mode 100644
index 0000000..7d98bf2
--- /dev/null
+++ b/net/mmt/neon/src/ne_alloc.c
@@ -0,0 +1,223 @@
+/* 
+   Replacement memory allocation handling etc.
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <stdio.h>
+
+#include "ne_alloc.h"
+
+static ne_oom_callback_fn oom;
+
+void ne_oom_callback(ne_oom_callback_fn callback)
+{
+    oom = callback;
+}
+
+#ifndef NEON_MEMLEAK
+
+#define DO_MALLOC(ptr, len) do {		\
+    ptr = malloc((len));			\
+    if (!ptr) {					\
+	if (oom != NULL)			\
+	    oom();				\
+	abort();				\
+    }						\
+} while(0);
+
+void *ne_malloc(size_t len) 
+{
+    void *ptr;
+    DO_MALLOC(ptr, len);
+    return ptr;
+}
+
+void *ne_calloc(size_t len) 
+{
+    void *ptr;
+    DO_MALLOC(ptr, len);
+    return memset(ptr, 0, len);
+}
+
+void *ne_realloc(void *ptr, size_t len)
+{
+    void *ret = realloc(ptr, len);
+    if (!ret) {
+	if (oom)
+	    oom();
+	abort();
+    }
+    return ret;
+}
+
+#ifdef WIN32
+/* Implemented only to ensure free is bound to the correct DLL. */
+void ne_free(void *ptr)
+{
+    free(ptr);
+}
+#endif
+
+char *ne_strdup(const char *s) 
+{
+    char *ret;
+    DO_MALLOC(ret, strlen(s) + 1);
+    return strcpy(ret, s);
+}
+
+char *ne_strndup(const char *s, size_t n)
+{
+    char *new;
+    DO_MALLOC(new, n+1);
+    new[n] = '\0';
+    memcpy(new, s, n);
+    return new;
+}
+
+#else /* NEON_MEMLEAK */
+
+#include <assert.h>
+
+/* Memory-leak detection implementation: ne_malloc and friends are
+ * #defined to ne_malloc_ml etc by memleak.h, which is conditionally
+ * included by config.h. */
+
+/* memory allocated be ne_*alloc, but not freed. */
+size_t ne_alloc_used = 0;
+
+static struct block {
+    void *ptr;
+    size_t len;
+    const char *file;
+    int line;
+    struct block *next;
+} *blocks = NULL;
+
+void ne_alloc_dump(FILE *f)
+{
+    struct block *b;
+
+    for (b = blocks; b != NULL; b = b->next)
+        fprintf(f, "%" NE_FMT_SIZE_T "b@%s:%d%s", b->len, b->file, b->line,
+                b->next?", ":"");
+}
+
+static void *tracking_malloc(size_t len, const char *file, int line)
+{
+    void *ptr = malloc((len));
+    struct block *block;
+
+    if (!ptr) {
+	if (oom) oom();
+	abort();
+    }
+    
+    block = malloc(sizeof *block);
+    if (block != NULL) {
+        block->ptr = ptr;
+        block->len = len;
+        block->file = file;
+        block->line = line;
+        block->next = blocks;
+        blocks = block;
+        ne_alloc_used += len;
+    }
+
+    return ptr;
+}
+
+void *ne_malloc_ml(size_t size, const char *file, int line)
+{
+    return tracking_malloc(size, file, line);
+}
+
+void *ne_calloc_ml(size_t size, const char *file, int line)
+{
+    return memset(tracking_malloc(size, file, line), 0, size);
+}
+
+void *ne_realloc_ml(void *ptr, size_t s, const char *file, int line)
+{
+    void *ret;
+    struct block *b;
+
+    if (ptr == NULL)
+        return tracking_malloc(s, file, line);
+
+    ret = realloc(ptr, s);
+    if (!ret) {
+        if (oom) oom();
+        abort();
+    }
+    
+    for (b = blocks; b != NULL; b = b->next) {
+        if (b->ptr == ptr) {
+            ne_alloc_used += s - b->len;
+            b->ptr = ret;
+            b->len = s;
+            break;
+        }
+    }
+    assert(b != NULL);
+
+    return ret;
+}
+
+char *ne_strdup_ml(const char *s, const char *file, int line)
+{
+    return strcpy(tracking_malloc(strlen(s) + 1, file, line), s);
+}
+
+char *ne_strndup_ml(const char *s, size_t n, const char *file, int line)
+{
+    char *ret = tracking_malloc(n + 1, file, line);
+    ret[n] = '\0';
+    return memcpy(ret, s, n);
+}
+
+void ne_free_ml(void *ptr)
+{
+    struct block *b, *last = NULL;
+
+    for (b = blocks; b != NULL; last = b, b = b->next) {
+        if (b->ptr == ptr) {
+            ne_alloc_used -= b->len;
+            if (last) 
+                last->next = b->next;
+            else
+                blocks = b->next;
+            free(b);
+            break;
+        }
+    }
+
+    free(ptr);
+}
+
+#endif /* NEON_MEMLEAK */
diff --git a/net/mmt/neon/src/ne_alloc.h b/net/mmt/neon/src/ne_alloc.h
new file mode 100644
index 0000000..0322fa7
--- /dev/null
+++ b/net/mmt/neon/src/ne_alloc.h
@@ -0,0 +1,60 @@
+/* 
+   Replacement memory allocation handling etc.
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_ALLOC_H
+#define NE_ALLOC_H
+
+#include <stdlib.h>
+
+#ifndef WIN32
+#include <sys/types.h>
+#endif
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+typedef void (*ne_oom_callback_fn)(void);
+
+/* Set callback which is called if malloc() returns NULL. */
+void ne_oom_callback(ne_oom_callback_fn callback);
+
+#ifndef NEON_MEMLEAK
+/* Replacements for standard C library memory allocation functions,
+ * which never return NULL. If the C library malloc() returns NULL,
+ * neon will abort(); calling an OOM callback beforehand if one is
+ * registered.  The C library will only ever return NULL if the
+ * operating system does not use optimistic memory allocation. */
+void *ne_malloc(size_t size) ne_attribute_malloc;
+void *ne_calloc(size_t size) ne_attribute_malloc;
+void *ne_realloc(void *ptr, size_t s);
+char *ne_strdup(const char *s) ne_attribute_malloc;
+char *ne_strndup(const char *s, size_t n) ne_attribute_malloc;
+#ifdef WIN32
+void ne_free(void *ptr);
+#else
+#define ne_free free
+#endif
+#endif
+
+NE_END_DECLS
+
+#endif /* NE_ALLOC_H */
diff --git a/net/mmt/neon/src/ne_auth.c b/net/mmt/neon/src/ne_auth.c
new file mode 100644
index 0000000..48a0cb5
--- /dev/null
+++ b/net/mmt/neon/src/ne_auth.c
@@ -0,0 +1,1719 @@
+/* 
+   HTTP Authentication routines
+   Copyright (C) 1999-2011, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h> /* for getpid() */
+#endif
+
+#ifdef WIN32
+#include <windows.h> /* for GetCurrentThreadId() etc */
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/rand.h>
+#elif defined(HAVE_GNUTLS)
+#include <gnutls/gnutls.h>
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b00
+#include <gcrypt.h>
+#else
+#include <gnutls/crypto.h>
+#endif
+#endif
+
+#include <errno.h>
+#include <time.h>
+
+#include "ne_md5.h"
+#include "ne_dates.h"
+#include "ne_request.h"
+#include "ne_auth.h"
+#include "ne_string.h"
+#include "ne_utils.h"
+#include "ne_alloc.h"
+#include "ne_uri.h"
+#include "ne_internal.h"
+
+#ifdef HAVE_GSSAPI
+#ifdef HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
+#include <gssapi/gssapi_generic.h>
+#endif
+#else
+#include <gssapi.h>
+#endif
+#endif
+
+#ifdef HAVE_SSPI
+#include "ne_sspi.h"
+#endif
+
+#ifdef HAVE_NTLM
+#include "ne_ntlm.h"
+#endif
+ 
+#define HOOK_SERVER_ID "http://webdav.org/neon/hooks/server-auth"
+#define HOOK_PROXY_ID "http://webdav.org/neon/hooks/proxy-auth"
+
+typedef enum { 
+    auth_alg_md5,
+    auth_alg_md5_sess,
+    auth_alg_unknown
+} auth_algorithm;
+
+/* Selected method of qop which the client is using */
+typedef enum {
+    auth_qop_none,
+    auth_qop_auth
+} auth_qop;
+
+/* A callback/userdata pair registered by the application for
+ * a particular set of protocols. */
+struct auth_handler {
+    unsigned protomask; 
+
+    ne_auth_creds creds;
+    void *userdata;
+    int attempt; /* number of invocations of this callback for
+                  * current request. */
+    
+    struct auth_handler *next;
+};
+
+/* A challenge */
+struct auth_challenge {
+    const struct auth_protocol *protocol;
+    struct auth_handler *handler;
+    const char *realm, *nonce, *opaque, *domain;
+    unsigned int stale; /* if stale=true */
+    unsigned int got_qop; /* we were given a qop directive */
+    unsigned int qop_auth; /* "auth" token in qop attrib */
+    auth_algorithm alg;
+    struct auth_challenge *next;
+};
+
+static const struct auth_class {
+    const char *id, *req_hdr, *resp_hdr, *resp_info_hdr;
+    int status_code; /* Response status-code to trap. */
+    int fail_code;   /* NE_* request to fail with. */
+    const char *error_noauth; /* Error message template use when
+                               * giving up authentication attempts. */
+} ah_server_class = {
+    HOOK_SERVER_ID,
+    "Authorization", "WWW-Authenticate", "Authentication-Info",
+    401, NE_AUTH,
+    N_("Could not authenticate to server: %s")
+}, ah_proxy_class = {
+    HOOK_PROXY_ID,
+    "Proxy-Authorization", "Proxy-Authenticate", "Proxy-Authentication-Info",
+    407, NE_PROXYAUTH,
+    N_("Could not authenticate to proxy server: %s")
+};
+
+/* Authentication session state. */
+typedef struct {
+    ne_session *sess;
+
+    /* Which context will auth challenges be accepted? */
+    enum {
+        AUTH_ANY, /* ignore nothing. */
+        AUTH_CONNECT, /* only in response to a CONNECT request. */
+        AUTH_NOTCONNECT /* only in non-CONNECT responsees */
+    } context;
+    
+    /* Protocol type for server/proxy auth. */
+    const struct auth_class *spec;
+    
+    /* The protocol used for this authentication session */
+    const struct auth_protocol *protocol;
+
+    struct auth_handler *handlers;
+
+    /*** Session details ***/
+
+    /* The username and password we are using to authenticate with */
+    char username[NE_ABUFSIZ];
+
+    /* This used for Basic auth */
+    char *basic; 
+#ifdef HAVE_GSSAPI
+    /* for the GSSAPI/Negotiate scheme: */
+    char *gssapi_token;
+    gss_ctx_id_t gssctx;
+    gss_name_t gssname;
+    gss_OID gssmech;
+#endif
+#ifdef HAVE_SSPI
+    /* This is used for SSPI (Negotiate/NTLM) auth */
+    char *sspi_token;
+    void *sspi_context;
+    char *sspi_host;
+#endif
+#ifdef HAVE_NTLM
+     /* This is used for NTLM auth */
+     ne_ntlm_context *ntlm_context;
+#endif
+    /* These all used for Digest auth */
+    char *realm;
+    char *nonce;
+    char *cnonce;
+    char *opaque;
+    char **domains; /* list of paths given as domain. */
+    size_t ndomains; /* size of domains array */
+    auth_qop qop;
+    auth_algorithm alg;
+    unsigned int nonce_count;
+    /* The ASCII representation of the session's H(A1) value */
+    char h_a1[33];
+
+    /* Temporary store for half of the Request-Digest
+     * (an optimisation - used in the response-digest calculation) */
+    struct ne_md5_ctx *stored_rdig;
+} auth_session;
+
+struct auth_request {
+    /*** Per-request details. ***/
+    ne_request *request; /* the request object. */
+
+    /* The method and URI we are using for the current request */
+    const char *uri;
+    const char *method;
+    
+    int attempt; /* number of times this request has been retries due
+                  * to auth challenges. */
+};
+
+/* Used if this protocol takes an unquoted non-name/value-pair
+ * parameter in the challenge. */
+#define AUTH_FLAG_OPAQUE_PARAM (0x0001)
+/* Used if this Authentication-Info may be sent for non-40[17]
+ * response for this protocol. */
+#define AUTH_FLAG_VERIFY_NON40x (0x0002)
+/* Used for broken the connection-based auth schemes. */
+#define AUTH_FLAG_CONN_AUTH (0x0004)
+
+struct auth_protocol {
+    unsigned id; /* public NE_AUTH_* id. */
+
+    int strength; /* protocol strength for sort order. */
+
+    const char *name; /* protocol name. */
+    
+    /* Parse the authentication challenge; returns zero on success, or
+     * non-zero if this challenge be handled.  'attempt' is the number
+     * of times the request has been resent due to auth challenges.
+     * On failure, challenge_error() should be used to append an error
+     * message to the error buffer 'errmsg'. */
+    int (*challenge)(auth_session *sess, int attempt,
+                     struct auth_challenge *chall, ne_buffer **errmsg);
+
+    /* Return the string to send in the -Authenticate request header:
+     * (ne_malloc-allocated, NUL-terminated string) */
+    char *(*response)(auth_session *sess, struct auth_request *req);
+    
+    /* Parse a Authentication-Info response; returns NE_* error code
+     * on failure; on failure, the session error string must be
+     * set. */
+    int (*verify)(struct auth_request *req, auth_session *sess,
+                  const char *value);
+    
+    int flags; /* AUTH_FLAG_* flags */
+};
+
+/* Helper function to append an error to the buffer during challenge
+ * handling.  Pass printf-style string.  *errmsg may be NULL and is
+ * allocated if necessary.  errmsg must be non-NULL. */
+static void challenge_error(ne_buffer **errmsg, const char *fmt, ...)
+    ne_attribute((format(printf, 2, 3)));
+
+/* Free the domains array, precondition sess->ndomains > 0. */
+static void free_domains(auth_session *sess)
+{
+    do {
+        ne_free(sess->domains[sess->ndomains - 1]);
+    } while (--sess->ndomains);
+    ne_free(sess->domains);
+    sess->domains = NULL;
+}
+
+static void clean_session(auth_session *sess) 
+{
+    if (sess->basic) ne_free(sess->basic);
+    if (sess->nonce) ne_free(sess->nonce);
+    if (sess->cnonce) ne_free(sess->cnonce);
+    if (sess->opaque) ne_free(sess->opaque);
+    if (sess->realm) ne_free(sess->realm);
+    sess->realm = sess->basic = sess->cnonce = sess->nonce =
+        sess->opaque = NULL;
+    if (sess->stored_rdig) {
+        ne_md5_destroy_ctx(sess->stored_rdig);
+        sess->stored_rdig = NULL;
+    }
+    if (sess->ndomains) free_domains(sess);
+#ifdef HAVE_GSSAPI
+    {
+        unsigned int major;
+
+        if (sess->gssctx != GSS_C_NO_CONTEXT)
+            gss_delete_sec_context(&major, &sess->gssctx, GSS_C_NO_BUFFER);
+        
+    }
+    if (sess->gssapi_token) ne_free(sess->gssapi_token);
+    sess->gssapi_token = NULL;
+#endif
+#ifdef HAVE_SSPI
+    if (sess->sspi_token) ne_free(sess->sspi_token);
+    sess->sspi_token = NULL;
+    ne_sspi_destroy_context(sess->sspi_context);
+    sess->sspi_context = NULL;
+    if (sess->sspi_host) ne_free(sess->sspi_host);
+    sess->sspi_host = NULL;
+#endif
+#ifdef HAVE_NTLM
+    if (sess->ntlm_context) {
+        ne__ntlm_destroy_context(sess->ntlm_context);
+        sess->ntlm_context = NULL;
+    }
+#endif
+
+    sess->protocol = NULL;
+}
+
+/* Returns client nonce string. */
+static char *get_cnonce(void) 
+{
+    char ret[33];
+    unsigned char data[256];
+    struct ne_md5_ctx *hash;
+
+    hash = ne_md5_create_ctx();
+
+#ifdef HAVE_GNUTLS
+    if (1) {
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b00
+        gcry_create_nonce(data, sizeof data);
+#else
+        gnutls_rnd(GNUTLS_RND_NONCE, data, sizeof data);
+#endif
+        ne_md5_process_bytes(data, sizeof data, hash);
+    }
+    else
+#elif defined(HAVE_OPENSSL)
+    if (RAND_status() == 1 && RAND_pseudo_bytes(data, sizeof data) >= 0) {
+	ne_md5_process_bytes(data, sizeof data, hash);
+    } 
+    else 
+#endif /* HAVE_OPENSSL */
+    {
+        /* Fallback sources of random data: all bad, but no good sources
+         * are available. */
+        
+        /* Uninitialized stack data; yes, happy valgrinders, this is
+         * supposed to be here. */
+        ne_md5_process_bytes(data, sizeof data, hash);
+        
+        {
+#ifdef HAVE_GETTIMEOFDAY
+            struct timeval tv;
+            if (gettimeofday(&tv, NULL) == 0)
+                ne_md5_process_bytes(&tv, sizeof tv, hash);
+#else /* HAVE_GETTIMEOFDAY */
+            time_t t = time(NULL);
+            ne_md5_process_bytes(&t, sizeof t, hash);
+#endif
+        }
+        {
+#ifdef WIN32
+            DWORD pid = GetCurrentThreadId();
+#else
+            pid_t pid = getpid();
+#endif
+            ne_md5_process_bytes(&pid, sizeof pid, hash);
+        }
+    }
+
+    ne_md5_finish_ascii(hash, ret);
+    ne_md5_destroy_ctx(hash);
+
+    return ne_strdup(ret);
+}
+
+/* Callback to retrieve user credentials for given session on given
+ * attempt (pre request) for given challenge.  Password is written to
+ * pwbuf (of size NE_ABUFSIZ.  On error, challenge_error() is used
+ * with errmsg. */
+static int get_credentials(auth_session *sess, ne_buffer **errmsg, int attempt,
+                           struct auth_challenge *chall, char *pwbuf) 
+{
+    if (chall->handler->creds(chall->handler->userdata, sess->realm, 
+                              chall->handler->attempt++, sess->username, pwbuf) == 0) {
+        return 0;
+    } else {
+        challenge_error(errmsg, _("rejected %s challenge"), 
+                        chall->protocol->name);
+        return -1;
+    }
+}
+
+/* Examine a Basic auth challenge.
+ * Returns 0 if an valid challenge, else non-zero. */
+static int basic_challenge(auth_session *sess, int attempt,
+                           struct auth_challenge *parms,
+                           ne_buffer **errmsg) 
+{
+    char *tmp, password[NE_ABUFSIZ];
+
+    /* Verify challenge... must have a realm */
+    if (parms->realm == NULL) {
+        challenge_error(errmsg, _("missing realm in Basic challenge"));
+	return -1;
+    }
+
+    clean_session(sess);
+    
+    sess->realm = ne_strdup(parms->realm);
+
+    if (get_credentials(sess, errmsg, attempt, parms, password)) {
+	/* Failed to get credentials */
+	return -1;
+    }
+
+    tmp = ne_concat(sess->username, ":", password, NULL);
+    sess->basic = ne_base64((unsigned char *)tmp, strlen(tmp));
+    ne_free(tmp);
+
+    /* Paranoia. */
+    memset(password, 0, sizeof password);
+
+    return 0;
+}
+
+/* Add Basic authentication credentials to a request */
+static char *request_basic(auth_session *sess, struct auth_request *req) 
+{
+    return ne_concat("Basic ", sess->basic, "\r\n", NULL);
+}
+
+#ifdef HAVE_GSSAPI
+/* Add GSSAPI authentication credentials to a request */
+static char *request_negotiate(auth_session *sess, struct auth_request *req)
+{
+    if (sess->gssapi_token) 
+        return ne_concat("Negotiate ", sess->gssapi_token, "\r\n", NULL);
+    else
+        return NULL;
+}
+
+/* Create an GSSAPI name for server HOSTNAME; returns non-zero on
+ * error. */
+static void get_gss_name(gss_name_t *server, const char *hostname)
+{
+    unsigned int major, minor;
+    gss_buffer_desc token;
+
+    token.value = ne_concat("HTTP@", hostname, NULL);
+    token.length = strlen(token.value);
+
+    major = gss_import_name(&minor, &token, GSS_C_NT_HOSTBASED_SERVICE,
+                            server);
+    ne_free(token.value);
+    
+    if (GSS_ERROR(major)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: gss_import_name failed.\n");
+        *server = GSS_C_NO_NAME;
+    }
+}
+
+/* Append GSSAPI error(s) for STATUS of type TYPE to BUF; prepending
+ * ": " to each error if *FLAG is non-zero, setting *FLAG after an
+ * error has been appended. */
+static void make_gss_error(ne_buffer *buf, int *flag,
+                           unsigned int status, int type)
+{
+    unsigned int major, minor;
+    unsigned int context = 0;
+    
+    do {
+        gss_buffer_desc msg;
+        major = gss_display_status(&minor, status, type,
+                                   GSS_C_NO_OID, &context, &msg);
+        if (major == GSS_S_COMPLETE && msg.length) {
+            if ((*flag)++) ne_buffer_append(buf, ": ", 2);
+            ne_buffer_append(buf, msg.value, msg.length);
+        }
+        if (msg.length) gss_release_buffer(&minor, &msg);
+    } while (context);
+}
+
+/* Continue a GSS-API Negotiate exchange, using input TOKEN if
+ * non-NULL.  Returns non-zero on error, in which case *errmsg is
+ * guaranteed to be non-NULL (i.e. an error message is set). */
+static int continue_negotiate(auth_session *sess, const char *token,
+                              ne_buffer **errmsg)
+{
+    unsigned int major, minor;
+    gss_buffer_desc input = GSS_C_EMPTY_BUFFER;
+    gss_buffer_desc output = GSS_C_EMPTY_BUFFER;
+    unsigned char *bintoken = NULL;
+    int ret;
+
+    if (token) {
+        input.length = ne_unbase64(token, &bintoken);
+        if (input.length == 0) {
+            challenge_error(errmsg, _("invalid Negotiate token"));
+            return -1;
+        }
+        input.value = bintoken;
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Continuation token [%s]\n", token);
+    }
+    else if (sess->gssctx != GSS_C_NO_CONTEXT) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Reset incomplete context.\n");
+        gss_delete_sec_context(&minor, &sess->gssctx, GSS_C_NO_BUFFER);
+    }
+
+    major = gss_init_sec_context(&minor, GSS_C_NO_CREDENTIAL, &sess->gssctx,
+                                 sess->gssname, sess->gssmech, 
+                                 GSS_C_MUTUAL_FLAG, GSS_C_INDEFINITE, 
+                                 GSS_C_NO_CHANNEL_BINDINGS,
+                                 &input, &sess->gssmech, &output, NULL, NULL);
+
+    /* done with the input token. */
+    if (bintoken) ne_free(bintoken);
+
+    if (GSS_ERROR(major)) {
+        int flag = 0;
+
+        challenge_error(errmsg, _("GSSAPI authentication error: "));
+        make_gss_error(*errmsg, &flag, major, GSS_C_GSS_CODE);
+        make_gss_error(*errmsg, &flag, minor, GSS_C_MECH_CODE);
+
+        return -1;
+    }
+
+    if (major == GSS_S_CONTINUE_NEEDED || major == GSS_S_COMPLETE) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: init_sec_context OK. (major=%d)\n",
+                 major);
+        ret = 0;
+    } 
+    else {
+        challenge_error(errmsg, _("GSSAPI failure (code %u)"), major);
+        ret = -1;
+    }
+
+    if (major != GSS_S_CONTINUE_NEEDED) {
+        /* context no longer needed: destroy it */
+        gss_delete_sec_context(&minor, &sess->gssctx, GSS_C_NO_BUFFER);
+    }
+
+    if (output.length) {
+        sess->gssapi_token = ne_base64(output.value, output.length);
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Output token: [%s]\n", 
+                 sess->gssapi_token);
+        gss_release_buffer(&minor, &output);
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: No output token.\n");
+    }
+
+    return ret;
+}
+
+/* Process a Negotiate challange CHALL in session SESS; returns zero
+ * if challenge is accepted. */
+static int negotiate_challenge(auth_session *sess, int attempt,
+                               struct auth_challenge *chall,
+                               ne_buffer **errmsg) 
+{
+    const char *token = chall->opaque;
+
+    /* Respect an initial challenge - which must have no input token,
+     * or a continuation - which must have an input token. */
+    if (attempt == 0 || token) {
+        return continue_negotiate(sess, token, errmsg);
+    }
+    else {
+        challenge_error(errmsg, _("ignoring empty Negotiate continuation"));
+        return -1;
+    }
+}
+
+/* Verify the header HDR in a Negotiate response. */
+static int verify_negotiate_response(struct auth_request *req, auth_session *sess,
+                                     const char *hdr)
+{
+    char *duphdr = ne_strdup(hdr);
+    char *sep, *ptr = strchr(duphdr, ' ');
+    int ret;
+    ne_buffer *errmsg = NULL;
+
+    if (!ptr || strncmp(hdr, "Negotiate", ptr - duphdr) != 0) {
+        ne_set_error(sess->sess, _("Negotiate response verification failed: "
+                                   "invalid response header token"));
+        ne_free(duphdr);
+        return NE_ERROR;
+    }
+    
+    ptr++;
+
+    if (strlen(ptr) == 0) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: No token in Negotiate response!\n");
+        ne_free(duphdr);
+        return NE_OK;
+    }
+
+    if ((sep = strchr(ptr, ',')) != NULL)
+        *sep = '\0';
+    if ((sep = strchr(ptr, ' ')) != NULL)
+        *sep = '\0';
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, "gssapi: Negotiate response token [%s]\n", ptr);
+    ret = continue_negotiate(sess, ptr, &errmsg);
+    if (ret) {
+        ne_set_error(sess->sess, _("Negotiate response verification failure: %s"),
+                     errmsg->data);
+    }
+
+    if (errmsg) ne_buffer_destroy(errmsg);
+    ne_free(duphdr);
+
+    return ret ? NE_ERROR : NE_OK;
+}
+#endif
+
+#ifdef HAVE_SSPI
+static char *request_sspi(auth_session *sess, struct auth_request *request) 
+{
+    if (sess->sspi_token)
+        return ne_concat(sess->protocol->name, " ", sess->sspi_token, "\r\n", NULL);
+    else
+        return NULL;
+}
+
+static int continue_sspi(auth_session *sess, int ntlm, const char *hdr)
+{
+    int status;
+    char *response = NULL;
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: SSPI challenge.\n");
+    
+    if (!sess->sspi_context) {
+        status = ne_sspi_create_context(&sess->sspi_context, sess->sspi_host, ntlm);
+        if (status) {
+            return status;
+        }
+    }
+    
+    status = ne_sspi_authenticate(sess->sspi_context, hdr, &response);
+    if (status) {
+        return status;
+    }
+
+    if (response && *response) {
+        sess->sspi_token = response;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: SSPI challenge [%s]\n", sess->sspi_token);
+    }
+
+    return 0;
+}
+
+static int sspi_challenge(auth_session *sess, int attempt,
+                          struct auth_challenge *parms,
+                          ne_buffer **errmsg) 
+{
+    int ntlm = ne_strcasecmp(parms->protocol->name, "NTLM") == 0;
+
+    return continue_sspi(sess, ntlm, parms->opaque);
+}
+
+static int verify_sspi(struct auth_request *req, auth_session *sess,
+                       const char *hdr)
+{
+    int ntlm = ne_strncasecmp(hdr, "NTLM ", 5) == 0;
+    char *ptr = strchr(hdr, ' ');
+
+    if (!ptr) {
+        ne_set_error(sess->sess, _("SSPI response verification failed: "
+                                   "invalid response header token"));
+        return NE_ERROR;
+    }
+
+    while(*ptr == ' ')
+        ptr++;
+
+    if (*ptr == '\0') {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: No token in SSPI response!\n");
+        return NE_OK;
+    }
+
+    return continue_sspi(sess, ntlm, ptr);
+}
+
+#endif
+
+/* Parse the "domain" challenge parameter and set the domains array up
+ * in the session appropriately. */
+static int parse_domain(auth_session *sess, const char *domain)
+{
+    char *cp = ne_strdup(domain), *p = cp;
+    ne_uri base;
+    int invalid = 0;
+
+    memset(&base, 0, sizeof base);
+    ne_fill_server_uri(sess->sess, &base);
+
+    do {
+        char *token = ne_token(&p, ' ');
+        ne_uri rel, absolute;
+        
+        if (ne_uri_parse(token, &rel) == 0) {
+            /* Resolve relative to the Request-URI. */
+            base.path = "/";
+            ne_uri_resolve(&base, &rel, &absolute);
+
+            /* Compare against the resolved path to check this URI has
+             * the same (scheme, host, port) components; ignore it
+             * otherwise: */
+            base.path = absolute.path;
+            if (absolute.path && ne_uri_cmp(&absolute, &base) == 0) {
+                sess->domains = ne_realloc(sess->domains, 
+                                           ++sess->ndomains *
+                                           sizeof(*sess->domains));
+                sess->domains[sess->ndomains - 1] = absolute.path;
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Using domain %s from %s\n",
+                         absolute.path, token);
+                absolute.path = NULL;
+            }
+            else {
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Ignoring domain %s\n",
+                         token);
+            }
+
+            ne_uri_free(&absolute);
+        }
+        else {
+            invalid = 1;
+        }
+        
+        ne_uri_free(&rel);
+        
+    } while (p && !invalid);
+
+    if (invalid && sess->ndomains) {
+        free_domains(sess);
+    }
+
+    ne_free(cp);
+    base.path = NULL;
+    ne_uri_free(&base);
+
+    return invalid;
+}
+
+#ifdef HAVE_NTLM
+
+static char *request_ntlm(auth_session *sess, struct auth_request *request) 
+{
+    char *token = ne__ntlm_getRequestToken(sess->ntlm_context);
+    if (token) {
+        char *req = ne_concat(sess->protocol->name, " ", token, "\r\n", NULL);
+        ne_free(token);
+        return req;
+    } else {
+        return NULL;
+    }
+}
+
+static int ntlm_challenge(auth_session *sess, int attempt,
+                          struct auth_challenge *parms,
+                          ne_buffer **errmsg) 
+{
+    int status;
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: NTLM challenge.\n");
+    
+    if (!parms->opaque && (!sess->ntlm_context || (attempt > 1))) {
+        char password[NE_ABUFSIZ];
+
+        if (get_credentials(sess, errmsg, attempt, parms, password)) {
+            /* Failed to get credentials */
+            return -1;
+        }
+
+        if (sess->ntlm_context) {
+            ne__ntlm_destroy_context(sess->ntlm_context);
+            sess->ntlm_context = NULL;
+        }
+
+        sess->ntlm_context = ne__ntlm_create_context(sess->username, password);
+    }
+
+    status = ne__ntlm_authenticate(sess->ntlm_context, parms->opaque);
+    if (status) {
+        return status;
+    }
+
+    return 0;
+}
+#endif /* HAVE_NTLM */
+  
+/* Examine a digest challenge: return 0 if it is a valid Digest challenge,
+ * else non-zero. */
+static int digest_challenge(auth_session *sess, int attempt,
+                            struct auth_challenge *parms,
+                            ne_buffer **errmsg) 
+{
+    char password[NE_ABUFSIZ];
+
+    if (parms->alg == auth_alg_unknown) {
+        challenge_error(errmsg, _("unknown algorithm in Digest challenge"));
+        return -1;
+    }
+    else if (parms->alg == auth_alg_md5_sess && !parms->qop_auth) {
+        challenge_error(errmsg, _("incompatible algorithm in Digest challenge"));
+        return -1;
+    }
+    else if (parms->realm == NULL || parms->nonce == NULL) {
+        challenge_error(errmsg, _("missing parameter in Digest challenge"));
+	return -1;
+    }
+    else if (parms->stale && sess->realm == NULL) {
+        challenge_error(errmsg, _("initial Digest challenge was stale"));
+        return -1;
+    }
+    else if (parms->stale && (sess->alg != parms->alg
+                              || strcmp(sess->realm, parms->realm))) {
+        /* With stale=true the realm and algorithm cannot change since these
+         * require re-hashing H(A1) which defeats the point. */
+        challenge_error(errmsg, _("stale Digest challenge with new algorithm or realm"));
+        return -1;
+    }
+
+    if (!parms->stale) {
+        /* Non-stale challenge: clear session and request credentials. */
+        clean_session(sess);
+
+        /* The domain paramater must be parsed after the session is
+         * cleaned; ignore domain for proxy auth. */
+        if (parms->domain && sess->spec == &ah_server_class
+            && parse_domain(sess, parms->domain)) {
+            challenge_error(errmsg, _("could not parse domain in Digest challenge"));
+            return -1;
+        }
+
+        sess->realm = ne_strdup(parms->realm);
+        sess->alg = parms->alg;
+        sess->cnonce = get_cnonce();
+
+        if (get_credentials(sess, errmsg, attempt, parms, password)) {
+            /* Failed to get credentials */
+            return -1;
+        }
+    }
+    else {
+        /* Stale challenge: accept a new nonce or opaque. */
+        if (sess->nonce) ne_free(sess->nonce);
+        if (sess->opaque && parms->opaque) ne_free(sess->opaque);
+    }
+    
+    sess->nonce = ne_strdup(parms->nonce);
+    if (parms->opaque) {
+	sess->opaque = ne_strdup(parms->opaque);
+    }
+    
+    if (parms->got_qop) {
+	/* What type of qop are we to apply to the message? */
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got qop, using 2617-style.\n");
+	sess->nonce_count = 0;
+        sess->qop = auth_qop_auth;
+    } else {
+	/* No qop at all/ */
+	sess->qop = auth_qop_none;
+    }
+    
+    if (!parms->stale) {
+        struct ne_md5_ctx *tmp;
+
+	/* Calculate H(A1).
+	 * tmp = H(unq(username-value) ":" unq(realm-value) ":" passwd)
+	 */
+	tmp = ne_md5_create_ctx();
+	ne_md5_process_bytes(sess->username, strlen(sess->username), tmp);
+	ne_md5_process_bytes(":", 1, tmp);
+	ne_md5_process_bytes(sess->realm, strlen(sess->realm), tmp);
+	ne_md5_process_bytes(":", 1, tmp);
+	ne_md5_process_bytes(password, strlen(password), tmp);
+	memset(password, 0, sizeof password); /* done with that. */
+	if (sess->alg == auth_alg_md5_sess) {
+	    struct ne_md5_ctx *a1;
+	    char tmp_md5_ascii[33];
+
+	    /* Now we calculate the SESSION H(A1)
+	     *    A1 = H(...above...) ":" unq(nonce-value) ":" unq(cnonce-value) 
+	     */
+	    ne_md5_finish_ascii(tmp, tmp_md5_ascii);
+	    a1 = ne_md5_create_ctx();
+	    ne_md5_process_bytes(tmp_md5_ascii, 32, a1);
+	    ne_md5_process_bytes(":", 1, a1);
+	    ne_md5_process_bytes(sess->nonce, strlen(sess->nonce), a1);
+	    ne_md5_process_bytes(":", 1, a1);
+	    ne_md5_process_bytes(sess->cnonce, strlen(sess->cnonce), a1);
+	    ne_md5_finish_ascii(a1, sess->h_a1);
+            ne_md5_destroy_ctx(a1);
+	    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Session H(A1) is [%s]\n", sess->h_a1);
+	} else {
+	    ne_md5_finish_ascii(tmp, sess->h_a1);
+	    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: H(A1) is [%s]\n", sess->h_a1);
+	}
+        ne_md5_destroy_ctx(tmp);
+	
+    }
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Accepting digest challenge.\n");
+
+    return 0;
+}
+
+/* Returns non-zero if given Request-URI is inside the authentication
+ * domain defined for the session. */
+static int inside_domain(auth_session *sess, const char *req_uri)
+{
+    int inside = 0;
+    size_t n;
+    ne_uri uri;
+    
+    /* Parse the Request-URI; it will be an absoluteURI if using a
+     * proxy, and possibly '*'. */
+    if (strcmp(req_uri, "*") == 0 || ne_uri_parse(req_uri, &uri) != 0) {
+        /* Presume outside the authentication domain. */
+        return 0;
+    }
+
+    for (n = 0; n < sess->ndomains && !inside; n++) {
+        const char *d = sess->domains[n];
+        
+        inside = strncmp(uri.path, d, strlen(d)) == 0;
+    }
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: '%s' is inside auth domain: %d.\n", 
+             uri.path, inside);
+    ne_uri_free(&uri);
+    
+    return inside;
+}            
+
+/* Return Digest authentication credentials header value for the given
+ * session. */
+static char *request_digest(auth_session *sess, struct auth_request *req) 
+{
+    struct ne_md5_ctx *a2, *rdig;
+    char a2_md5_ascii[33], rdig_md5_ascii[33];
+    char nc_value[9] = {0};
+    const char *qop_value = "auth"; /* qop-value */
+    ne_buffer *ret;
+
+    /* Do not submit credentials if an auth domain is defined and this
+     * request-uri fails outside it. */
+    if (sess->ndomains && !inside_domain(sess, req->uri)) {
+        return NULL;
+    }
+
+    /* Increase the nonce-count */
+    if (sess->qop != auth_qop_none) {
+	sess->nonce_count++;
+	ne_snprintf(nc_value, 9, "%08x", sess->nonce_count);
+    }
+
+    /* Calculate H(A2). */
+    a2 = ne_md5_create_ctx();
+    ne_md5_process_bytes(req->method, strlen(req->method), a2);
+    ne_md5_process_bytes(":", 1, a2);
+    ne_md5_process_bytes(req->uri, strlen(req->uri), a2);
+    ne_md5_finish_ascii(a2, a2_md5_ascii);
+    ne_md5_destroy_ctx(a2);
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: H(A2): %s\n", a2_md5_ascii);
+
+    /* Now, calculation of the Request-Digest.
+     * The first section is the regardless of qop value
+     *     H(A1) ":" unq(nonce-value) ":" */
+    rdig = ne_md5_create_ctx();
+
+    /* Use the calculated H(A1) */
+    ne_md5_process_bytes(sess->h_a1, 32, rdig);
+
+    ne_md5_process_bytes(":", 1, rdig);
+    ne_md5_process_bytes(sess->nonce, strlen(sess->nonce), rdig);
+    ne_md5_process_bytes(":", 1, rdig);
+    if (sess->qop != auth_qop_none) {
+	/* Add on:
+	 *    nc-value ":" unq(cnonce-value) ":" unq(qop-value) ":"
+	 */
+	ne_md5_process_bytes(nc_value, 8, rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+	ne_md5_process_bytes(sess->cnonce, strlen(sess->cnonce), rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+	/* Store a copy of this structure (see note below) */
+        if (sess->stored_rdig) ne_md5_destroy_ctx(sess->stored_rdig);
+	sess->stored_rdig = ne_md5_dup_ctx(rdig);
+	ne_md5_process_bytes(qop_value, strlen(qop_value), rdig);
+	ne_md5_process_bytes(":", 1, rdig);
+    }
+
+    /* And finally, H(A2) */
+    ne_md5_process_bytes(a2_md5_ascii, 32, rdig);
+    ne_md5_finish_ascii(rdig, rdig_md5_ascii);
+    ne_md5_destroy_ctx(rdig);
+
+    ret = ne_buffer_create();
+
+    ne_buffer_concat(ret, 
+		     "Digest username=\"", sess->username, "\", "
+		     "realm=\"", sess->realm, "\", "
+		     "nonce=\"", sess->nonce, "\", "
+		     "uri=\"", req->uri, "\", "
+		     "response=\"", rdig_md5_ascii, "\", "
+		     "algorithm=\"", sess->alg == auth_alg_md5 ? "MD5" : "MD5-sess", "\"", 
+		     NULL);
+    
+    if (sess->opaque != NULL) {
+	ne_buffer_concat(ret, ", opaque=\"", sess->opaque, "\"", NULL);
+    }
+
+    if (sess->qop != auth_qop_none) {
+	/* Add in cnonce and nc-value fields */
+	ne_buffer_concat(ret, ", cnonce=\"", sess->cnonce, "\", "
+			 "nc=", nc_value, ", "
+			 "qop=\"", qop_value, "\"", NULL);
+    }
+
+    ne_buffer_zappend(ret, "\r\n");
+
+    return ne_buffer_finish(ret);
+}
+
+/* Parse line of comma-separated key-value pairs.  If 'ischall' == 1,
+ * then also return a leading space-separated token, as *value ==
+ * NULL.  Otherwise, if return value is 0, *key and *value will be
+ * non-NULL.  If return value is non-zero, parsing has ended.  If
+ * 'sep' is non-NULL and ischall is 1, the separator character is
+ * written to *sep when a challenge is parsed. */
+static int tokenize(char **hdr, char **key, char **value, char *sep,
+                    int ischall)
+{
+    char *pnt = *hdr;
+    enum { BEFORE_EQ, AFTER_EQ, AFTER_EQ_QUOTED } state = BEFORE_EQ;
+    
+    if (**hdr == '\0')
+	return 1;
+
+    *key = NULL;
+
+    do {
+	switch (state) {
+	case BEFORE_EQ:
+	    if (*pnt == '=') {
+		if (*key == NULL)
+		    return -1;
+		*pnt = '\0';
+		*value = pnt + 1;
+		state = AFTER_EQ;
+	    } else if ((*pnt == ' ' || *pnt == ',') 
+                       && ischall && *key != NULL) {
+		*value = NULL;
+                if (sep) *sep = *pnt;
+		*pnt = '\0';
+		*hdr = pnt + 1;
+		return 0;
+	    } else if (*key == NULL && strchr(" \r\n\t", *pnt) == NULL) {
+		*key = pnt;
+	    }
+	    break;
+	case AFTER_EQ:
+	    if (*pnt == ',') {
+		*pnt = '\0';
+		*hdr = pnt + 1;
+		return 0;
+	    } else if (*pnt == '\"') {
+		state = AFTER_EQ_QUOTED;
+	    }
+	    break;
+	case AFTER_EQ_QUOTED:
+	    if (*pnt == '\"') {
+		state = AFTER_EQ;
+                *pnt = '\0';
+	    }
+	    break;
+	}
+    } while (*++pnt != '\0');
+    
+    if (state == BEFORE_EQ && ischall && *key != NULL) {
+	*value = NULL;
+        if (sep) *sep = '\0';
+    }
+
+    *hdr = pnt;
+
+    /* End of string: */
+    return 0;
+}
+
+/* Pass this the value of the 'Authentication-Info:' header field, if
+ * one is received.
+ * Returns:
+ *    0 if it gives a valid authentication for the server 
+ *    non-zero otherwise (don't believe the response in this case!).
+ */
+static int verify_digest_response(struct auth_request *req, auth_session *sess,
+                                  const char *value) 
+{
+    char *hdr, *pnt, *key, *val;
+    auth_qop qop = auth_qop_none;
+    char *nextnonce, *rspauth, *cnonce, *nc, *qop_value;
+    unsigned int nonce_count;
+    int ret = NE_OK;
+
+    nextnonce = rspauth = cnonce = nc = qop_value = NULL;
+
+    pnt = hdr = ne_strdup(value);
+    
+    NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got Auth-Info header: %s\n", value);
+
+    while (tokenize(&pnt, &key, &val, NULL, 0) == 0) {
+	val = ne_shave(val, "\"");
+
+	if (ne_strcasecmp(key, "qop") == 0) {
+            qop_value = val;
+            if (ne_strcasecmp(val, "auth") == 0) {
+		qop = auth_qop_auth;
+	    } else {
+		qop = auth_qop_none;
+	    }
+	} else if (ne_strcasecmp(key, "nextnonce") == 0) {
+	    nextnonce = val;
+	} else if (ne_strcasecmp(key, "rspauth") == 0) {
+	    rspauth = val;
+	} else if (ne_strcasecmp(key, "cnonce") == 0) {
+	    cnonce = val;
+	} else if (ne_strcasecmp(key, "nc") == 0) { 
+	    nc = val;
+        }
+    }
+
+    if (qop == auth_qop_none) {
+        /* The 2069-style A-I header only has the entity and nextnonce
+         * parameters. */
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: 2069-style A-I header.\n");
+    }
+    else if (!rspauth || !cnonce || !nc) {
+        ret = NE_ERROR;
+        ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                   "missing parameters"));
+    }
+    else if (strcmp(cnonce, sess->cnonce) != 0) {
+        ret = NE_ERROR;
+        ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                   "client nonce mismatch"));
+    }
+    else if (nc) {
+        char *ptr;
+        
+        errno = 0;
+        nonce_count = strtoul(nc, &ptr, 16);
+        if (*ptr != '\0' || errno) {
+            ret = NE_ERROR;
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "could not parse nonce count"));
+        }
+        else if (nonce_count != sess->nonce_count) {
+            ret = NE_ERROR;
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "nonce count mismatch (%u not %u)"),
+                         nonce_count, sess->nonce_count);
+        }
+    }
+
+    /* Finally, for qop=auth cases, if everything else is OK, verify
+     * the response-digest field. */    
+    if (qop == auth_qop_auth && ret == NE_OK) {
+        struct ne_md5_ctx *a2;
+        char a2_md5_ascii[33], rdig_md5_ascii[33];
+
+        /* Modified H(A2): */
+        a2 = ne_md5_create_ctx();
+        ne_md5_process_bytes(":", 1, a2);
+        ne_md5_process_bytes(req->uri, strlen(req->uri), a2);
+        ne_md5_finish_ascii(a2, a2_md5_ascii);
+        ne_md5_destroy_ctx(a2);
+
+        /* sess->stored_rdig contains digest-so-far of:
+         *   H(A1) ":" unq(nonce-value) 
+         */
+        
+        /* Add in qop-value */
+        ne_md5_process_bytes(qop_value, strlen(qop_value), 
+                             sess->stored_rdig);
+        ne_md5_process_bytes(":", 1, sess->stored_rdig);
+
+        /* Digest ":" H(A2) */
+        ne_md5_process_bytes(a2_md5_ascii, 32, sess->stored_rdig);
+        /* All done */
+        ne_md5_finish_ascii(sess->stored_rdig, rdig_md5_ascii);
+        ne_md5_destroy_ctx(sess->stored_rdig);
+        sess->stored_rdig = NULL;
+
+        /* And... do they match? */
+        ret = ne_strcasecmp(rdig_md5_ascii, rspauth) == 0 ? NE_OK : NE_ERROR;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: response-digest match: %s "
+                 "(expected [%s] vs actual [%s])\n", 
+                 ret == NE_OK ? "yes" : "no", rdig_md5_ascii, rspauth);
+
+        if (ret) {
+            ne_set_error(sess->sess, _("Digest mutual authentication failure: "
+                                       "request-digest mismatch"));
+        }
+    }
+
+    /* Check for a nextnonce */
+    if (nextnonce != NULL) {
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Found nextnonce of [%s].\n", nextnonce);
+        ne_free(sess->nonce);
+	sess->nonce = ne_strdup(nextnonce);
+        sess->nonce_count = 0;
+    }
+
+    ne_free(hdr);
+
+    return ret;
+}
+
+static const struct auth_protocol protocols[] = {
+    { NE_AUTH_BASIC, 10, "Basic",
+      basic_challenge, request_basic, NULL,
+      0 },
+    { NE_AUTH_DIGEST, 20, "Digest",
+      digest_challenge, request_digest, verify_digest_response,
+      0 },
+#ifdef HAVE_GSSAPI
+    { NE_AUTH_GSSAPI_ONLY, 30, "Negotiate",
+      negotiate_challenge, request_negotiate, verify_negotiate_response,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+#ifdef HAVE_SSPI
+    { NE_AUTH_NTLM, 30, "NTLM",
+      sspi_challenge, request_sspi, NULL,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+    { NE_AUTH_SSPI, 30, "Negotiate",
+      sspi_challenge, request_sspi, verify_sspi,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+#ifdef HAVE_NTLM
+    { NE_AUTH_NTLM, 30, "NTLM",
+      ntlm_challenge, request_ntlm, NULL,
+      AUTH_FLAG_OPAQUE_PARAM|AUTH_FLAG_VERIFY_NON40x|AUTH_FLAG_CONN_AUTH },
+#endif
+    { 0 }
+};
+
+/* Insert a new auth challenge for protocol 'proto' in list of
+ * challenges 'list'.  The challenge list is kept in sorted order of
+ * strength, with highest strength first. */
+static struct auth_challenge *insert_challenge(struct auth_challenge **list,
+                                               const struct auth_protocol *proto)
+{
+    struct auth_challenge *ret = ne_calloc(sizeof *ret);
+    struct auth_challenge *chall, *prev;
+
+    for (chall = *list, prev = NULL; chall != NULL; 
+         prev = chall, chall = chall->next) {
+        if (proto->strength > chall->protocol->strength) {
+            break;
+        }
+    }
+
+    if (prev) {
+        ret->next = prev->next;
+        prev->next = ret;
+    } else {
+        ret->next = *list;
+        *list = ret;
+    }
+
+    ret->protocol = proto;
+
+    return ret;
+}
+
+static void challenge_error(ne_buffer **errbuf, const char *fmt, ...)
+{
+    char err[128];
+    va_list ap;
+    size_t len;
+    
+    va_start(ap, fmt);
+    len = ne_vsnprintf(err, sizeof err, fmt, ap);
+    va_end(ap);
+    
+    if (*errbuf == NULL) {
+        *errbuf = ne_buffer_create();
+        ne_buffer_append(*errbuf, err, len);
+    }
+    else {
+        ne_buffer_concat(*errbuf, ", ", err, NULL);
+    }
+}
+
+/* Passed the value of a "(Proxy,WWW)-Authenticate: " header field.
+ * Returns 0 if valid challenge was accepted; non-zero if no valid
+ * challenge was found. */
+static int auth_challenge(auth_session *sess, int attempt,
+                          const char *value) 
+{
+    char *pnt, *key, *val, *hdr, sep;
+    struct auth_challenge *chall = NULL, *challenges = NULL;
+    ne_buffer *errmsg = NULL;
+
+    pnt = hdr = ne_strdup(value); 
+
+    /* The header value may be made up of one or more challenges.  We
+     * split it down into attribute-value pairs, then search for
+     * schemes in the pair keys. */
+
+    while (!tokenize(&pnt, &key, &val, &sep, 1)) {
+
+	if (val == NULL) {
+            const struct auth_protocol *proto = NULL;
+            struct auth_handler *hdl;
+            size_t n;
+
+            for (hdl = sess->handlers; hdl; hdl = hdl->next) {
+                for (n = 0; protocols[n].id; n++) {
+                    if (protocols[n].id & hdl->protomask
+                        && ne_strcasecmp(key, protocols[n].name) == 0) {
+                        proto = &protocols[n];
+                        break;
+                    }
+                }
+                if (proto) break;
+            }
+
+            if (proto == NULL) {
+                /* Ignore this challenge. */
+                chall = NULL;
+                challenge_error(&errmsg, _("ignored %s challenge"), key);
+                continue;
+	    }
+            
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got '%s' challenge.\n", proto->name);
+            chall = insert_challenge(&challenges, proto);
+            chall->handler = hdl;
+
+            if ((proto->flags & AUTH_FLAG_OPAQUE_PARAM) && sep == ' ') {
+                /* Cope with the fact that the unquoted base64
+                 * paramater token doesn't match the 2617 auth-param
+                 * grammar: */
+                chall->opaque = ne_shave(ne_token(&pnt, ','), " \t");
+                NE_DEBUG(NE_DBG_HTTPAUTH, "auth: %s opaque parameter '%s'\n",
+                         proto->name, chall->opaque);
+                if (!pnt) break; /* stop parsing at end-of-string. */
+            }
+	    continue;
+	} else if (chall == NULL) {
+	    /* Ignore pairs for an unknown challenge. */
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Ignored parameter: %s = %s\n", key, val);
+	    continue;
+	}
+
+	/* Strip quotes off value. */
+	val = ne_shave(val, "\"'");
+
+	if (ne_strcasecmp(key, "realm") == 0) {
+	    chall->realm = val;
+	} else if (ne_strcasecmp(key, "nonce") == 0) {
+	    chall->nonce = val;
+	} else if (ne_strcasecmp(key, "opaque") == 0) {
+	    chall->opaque = val;
+	} else if (ne_strcasecmp(key, "stale") == 0) {
+	    /* Truth value */
+	    chall->stale = (ne_strcasecmp(val, "true") == 0);
+	} else if (ne_strcasecmp(key, "algorithm") == 0) {
+	    if (ne_strcasecmp(val, "md5") == 0) {
+		chall->alg = auth_alg_md5;
+	    } else if (ne_strcasecmp(val, "md5-sess") == 0) {
+		chall->alg = auth_alg_md5_sess;
+	    } else {
+		chall->alg = auth_alg_unknown;
+	    }
+	} else if (ne_strcasecmp(key, "qop") == 0) {
+            /* iterate over each token in the value */
+            do {
+                const char *tok = ne_shave(ne_token(&val, ','), " \t");
+                
+                if (ne_strcasecmp(tok, "auth") == 0) {
+                    chall->qop_auth = 1;
+                }
+            } while (val);
+            
+            chall->got_qop = chall->qop_auth;
+	}
+        else if (ne_strcasecmp(key, "domain") == 0) {
+            chall->domain = val;
+        }
+    }
+    
+    sess->protocol = NULL;
+
+    /* Iterate through the challenge list (which is sorted from
+     * strongest to weakest) attempting to accept each one. */
+    for (chall = challenges; chall != NULL; chall = chall->next) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Trying %s challenge...\n",
+                 chall->protocol->name);
+        if (chall->protocol->challenge(sess, attempt, chall, &errmsg) == 0) {
+            NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Accepted %s challenge.\n", 
+                     chall->protocol->name);
+            sess->protocol = chall->protocol;
+            break;
+        }
+    }
+
+    if (!sess->protocol) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: No challenges accepted.\n");
+        ne_set_error(sess->sess, _(sess->spec->error_noauth),
+                     errmsg ? errmsg->data : _("could not parse challenge"));
+    }
+
+    while (challenges != NULL) {
+	chall = challenges->next;
+	ne_free(challenges);
+	challenges = chall;
+    }
+
+    ne_free(hdr);
+    if (errmsg) ne_buffer_destroy(errmsg);
+
+    return !(sess->protocol != NULL);
+}
+
+static void ah_create(ne_request *req, void *session, const char *method,
+		      const char *uri)
+{
+    auth_session *sess = session;
+    int is_connect = strcmp(method, "CONNECT") == 0;
+
+    if (sess->context == AUTH_ANY ||
+        (is_connect && sess->context == AUTH_CONNECT) ||
+        (!is_connect && sess->context == AUTH_NOTCONNECT)) {
+        struct auth_request *areq = ne_calloc(sizeof *areq);
+        struct auth_handler *hdl;
+        
+        NE_DEBUG(NE_DBG_HTTPAUTH, "ah_create, for %s\n", sess->spec->resp_hdr);
+        
+        areq->method = method;
+        areq->uri = uri;
+        areq->request = req;
+        
+        ne_set_request_private(req, sess->spec->id, areq);
+
+        /* For each new request, reset the attempt counter in every
+         * registered handler. */
+        for (hdl = sess->handlers; hdl; hdl = hdl->next) {
+            hdl->attempt = 0;
+        }
+    }
+}
+
+
+static void ah_pre_send(ne_request *r, void *cookie, ne_buffer *request)
+{
+    auth_session *sess = cookie;
+    struct auth_request *req = ne_get_request_private(r, sess->spec->id);
+
+    if (sess->protocol && req) {
+	char *value;
+
+        NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Sending '%s' response.\n",
+                 sess->protocol->name);
+
+        value = sess->protocol->response(sess, req);
+
+	if (value != NULL) {
+	    ne_buffer_concat(request, sess->spec->req_hdr, ": ", value, NULL);
+	    ne_free(value);
+	}
+    }
+
+}
+
+static int ah_post_send(ne_request *req, void *cookie, const ne_status *status)
+{
+    auth_session *sess = cookie;
+    struct auth_request *areq = ne_get_request_private(req, sess->spec->id);
+    const char *auth_hdr, *auth_info_hdr;
+    int ret = NE_OK;
+
+    if (!areq) return NE_OK;
+
+    auth_hdr = ne_get_response_header(req, sess->spec->resp_hdr);
+    auth_info_hdr = ne_get_response_header(req, sess->spec->resp_info_hdr);
+
+    if (sess->context == AUTH_CONNECT && status->code == 401 && !auth_hdr) {
+        /* Some broken proxies issue a 401 as a proxy auth challenge
+         * to a CONNECT request; handle this here. */
+        auth_hdr = ne_get_response_header(req, "WWW-Authenticate");
+        auth_info_hdr = NULL;
+    }
+
+#ifdef HAVE_GSSAPI
+    /* whatever happens: forget the GSSAPI token cached thus far */
+    if (sess->gssapi_token) {
+        ne_free(sess->gssapi_token);
+        sess->gssapi_token = NULL;
+    }
+#endif
+
+#ifdef HAVE_SSPI
+    /* whatever happens: forget the SSPI token cached thus far */
+    if (sess->sspi_token) {
+        ne_free(sess->sspi_token);
+        sess->sspi_token = NULL;
+    }
+#endif
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, 
+	     "ah_post_send (#%d), code is %d (want %d), %s is %s\n",
+	     areq->attempt, status->code, sess->spec->status_code, 
+	     sess->spec->resp_hdr, auth_hdr ? auth_hdr : "(none)");
+    if (auth_info_hdr && sess->protocol && sess->protocol->verify 
+        && (sess->protocol->flags & AUTH_FLAG_VERIFY_NON40x) == 0) {
+        ret = sess->protocol->verify(areq, sess, auth_info_hdr);
+    }
+    else if (sess->protocol && sess->protocol->verify
+             && (sess->protocol->flags & AUTH_FLAG_VERIFY_NON40x) 
+             && (status->klass == 2 || status->klass == 3)
+             && auth_hdr) {
+        ret = sess->protocol->verify(areq, sess, auth_hdr);
+    }
+    else if ((status->code == sess->spec->status_code ||
+              (status->code == 401 && sess->context == AUTH_CONNECT)) &&
+	       auth_hdr) {
+        /* note above: allow a 401 in response to a CONNECT request
+         * from a proxy since some buggy proxies send that. */
+	NE_DEBUG(NE_DBG_HTTPAUTH, "auth: Got challenge (code %d).\n", status->code);
+	if (!auth_challenge(sess, areq->attempt++, auth_hdr)) {
+	    ret = NE_RETRY;
+	} else {
+	    clean_session(sess);
+	    ret = sess->spec->fail_code;
+	}
+        
+        /* Set or clear the conn-auth flag according to whether this
+         * was an accepted challenge for a borked protocol. */
+        ne_set_session_flag(sess->sess, NE_SESSFLAG_CONNAUTH,
+                            sess->protocol 
+                            && (sess->protocol->flags & AUTH_FLAG_CONN_AUTH));
+    }
+
+#ifdef HAVE_SSPI
+    /* Clear the SSPI context after successful authentication. */
+    if (status->code != sess->spec->status_code && sess->sspi_context) {
+        ne_sspi_clear_context(sess->sspi_context);
+    }
+#endif
+
+    return ret;
+}
+
+static void ah_destroy(ne_request *req, void *session)
+{
+    auth_session *sess = session;
+    struct auth_request *areq = ne_get_request_private(req, sess->spec->id);
+
+    if (areq) {
+        ne_free(areq);
+    }
+}
+
+static void free_auth(void *cookie)
+{
+    auth_session *sess = cookie;
+    struct auth_handler *hdl, *next;
+
+#ifdef HAVE_GSSAPI
+    if (sess->gssname != GSS_C_NO_NAME) {
+        unsigned int major;
+        gss_release_name(&major, &sess->gssname);
+    }
+#endif
+
+    for (hdl = sess->handlers; hdl; hdl = next) {
+        next = hdl->next;
+        ne_free(hdl);
+    }
+
+    clean_session(sess);
+    ne_free(sess);
+}
+
+static void auth_register(ne_session *sess, int isproxy, unsigned protomask,
+			  const struct auth_class *ahc, const char *id, 
+			  ne_auth_creds creds, void *userdata) 
+{
+    auth_session *ahs;
+    struct auth_handler **hdl;
+
+    /* Handle the _ALL and _DEFAULT protocol masks: */
+    if (protomask == NE_AUTH_ALL) {
+        protomask |= NE_AUTH_BASIC | NE_AUTH_DIGEST | NE_AUTH_NEGOTIATE;
+    }
+    else if (protomask == NE_AUTH_DEFAULT) {
+        protomask |= NE_AUTH_BASIC | NE_AUTH_DIGEST;
+        
+        if (strcmp(ne_get_scheme(sess), "https") == 0 || isproxy) {
+            protomask |= NE_AUTH_NEGOTIATE;
+        }
+    }
+
+    if ((protomask & NE_AUTH_NEGOTIATE) == NE_AUTH_NEGOTIATE) {
+        /* Map NEGOTIATE to NTLM | GSSAPI. */
+        protomask |= NE_AUTH_GSSAPI | NE_AUTH_NTLM;
+    }
+    
+    if ((protomask & NE_AUTH_GSSAPI) == NE_AUTH_GSSAPI) {
+        /* Map GSSAPI to GSSAPI_ONLY | SSPI. */
+        protomask |= NE_AUTH_GSSAPI_ONLY | NE_AUTH_SSPI;
+    }
+
+    ahs = ne_get_session_private(sess, id);
+    if (ahs == NULL) {
+        ahs = ne_calloc(sizeof *ahs);
+        
+        ahs->sess = sess;
+        ahs->spec = ahc;
+        
+        if (strcmp(ne_get_scheme(sess), "https") == 0) {
+            ahs->context = isproxy ? AUTH_CONNECT : AUTH_NOTCONNECT;
+        } else {
+            ahs->context = AUTH_ANY;
+        }
+        
+        /* Register hooks */
+        ne_hook_create_request(sess, ah_create, ahs);
+        ne_hook_pre_send(sess, ah_pre_send, ahs);
+        ne_hook_post_send(sess, ah_post_send, ahs);
+        ne_hook_destroy_request(sess, ah_destroy, ahs);
+        ne_hook_destroy_session(sess, free_auth, ahs);
+        
+        ne_set_session_private(sess, id, ahs);
+    }
+
+#ifdef HAVE_GSSAPI
+    if ((protomask & NE_AUTH_GSSAPI_ONLY) && ahs->gssname == GSS_C_NO_NAME) {
+        ne_uri uri = {0};
+        
+        if (isproxy)
+            ne_fill_proxy_uri(sess, &uri);
+        else
+            ne_fill_server_uri(sess, &uri);
+
+        get_gss_name(&ahs->gssname, uri.host);
+
+        ne_uri_free(&uri);
+    }
+#endif
+#ifdef HAVE_SSPI
+    if ((protomask & (NE_AUTH_NTLM|NE_AUTH_SSPI)) && !ahs->sspi_host) {
+        ne_uri uri = {0};
+        
+        if (isproxy)
+            ne_fill_proxy_uri(sess, &uri);
+        else
+            ne_fill_server_uri(sess, &uri);
+
+        ahs->sspi_host = uri.host;
+        uri.host = NULL;
+
+        ne_uri_free(&uri);
+    }
+#endif        
+
+    /* Find the end of the handler list, and add a new one. */
+    hdl = &ahs->handlers;
+    while (*hdl)
+        hdl = &(*hdl)->next;
+        
+    *hdl = ne_malloc(sizeof **hdl);
+    (*hdl)->protomask = protomask;
+    (*hdl)->creds = creds;
+    (*hdl)->userdata = userdata;
+    (*hdl)->next = NULL;
+    (*hdl)->attempt = 0;
+}
+
+void ne_set_server_auth(ne_session *sess, ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 0, NE_AUTH_DEFAULT, &ah_server_class, HOOK_SERVER_ID,
+                  creds, userdata);
+}
+
+void ne_set_proxy_auth(ne_session *sess, ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 1, NE_AUTH_DEFAULT, &ah_proxy_class, HOOK_PROXY_ID,
+                  creds, userdata);
+}
+
+void ne_add_server_auth(ne_session *sess, unsigned protocol, 
+                        ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 0, protocol, &ah_server_class, HOOK_SERVER_ID,
+                  creds, userdata);
+}
+
+void ne_add_proxy_auth(ne_session *sess, unsigned protocol, 
+                       ne_auth_creds creds, void *userdata)
+{
+    auth_register(sess, 1, protocol, &ah_proxy_class, HOOK_PROXY_ID,
+                  creds, userdata);
+}
+
+void ne_forget_auth(ne_session *sess)
+{
+    auth_session *as;
+    if ((as = ne_get_session_private(sess, HOOK_SERVER_ID)) != NULL)
+	clean_session(as);
+    if ((as = ne_get_session_private(sess, HOOK_PROXY_ID)) != NULL)
+	clean_session(as);
+}
+
diff --git a/net/mmt/neon/src/ne_auth.h b/net/mmt/neon/src/ne_auth.h
new file mode 100644
index 0000000..98e7e18
--- /dev/null
+++ b/net/mmt/neon/src/ne_auth.h
@@ -0,0 +1,143 @@
+/* 
+   HTTP authentication routines
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_AUTH_H
+#define NE_AUTH_H
+
+#include "ne_session.h" /* for ne_session */
+
+NE_BEGIN_DECLS
+
+/* Size of username/password buffers passed to ne_auth_creds
+ * callback. */
+#define NE_ABUFSIZ (256)
+
+/* The callback used to request the username and password in the given
+ * realm. The username and password must be copied into the buffers
+ * which are both of size NE_ABUFSIZ.  The 'attempt' parameter is zero
+ * on the first call to the callback, and increases by one each time
+ * an attempt to authenticate fails.
+ *
+ * The callback must return zero to indicate that authentication
+ * should be attempted with the username/password, or non-zero to
+ * cancel the request. (if non-zero, username and password are
+ * ignored.)
+ *
+ * IMPORTANT NOTE: The callback will be invoked repeatedly until
+ * either it returns non-zero, or authentication is successful.
+ *
+ * Hint: if you just wish to attempt authentication just once (even if
+ * the user gets the username/password wrong), have the callback
+ * function use 'attempt' value as the function return value. */
+typedef int (*ne_auth_creds)(void *userdata, const char *realm, int attempt,
+			     char *username, char *password);
+
+/* Set callbacks to provide credentials for server and proxy
+ * authentication, using the default set of authentication protocols.
+ * userdata is passed as the first argument to the callback. */
+void ne_set_server_auth(ne_session *sess, ne_auth_creds creds, void *userdata);
+void ne_set_proxy_auth(ne_session *sess, ne_auth_creds creds, void *userdata);
+
+/* As an alternative to using ne_set_server_auth and
+ * ne_set_proxy_auth, the following interfaces may be used; these
+ * allow control over which authentication protocol is used. */
+
+/* NE_AUTH_BASIC: Basic authentication transmits the username and
+ * password unprotected over the channel; this allows a passive attack
+ * to steal the credentials if using an unsecured channel
+ * (i.e. non-SSL). */
+#define NE_AUTH_BASIC (0x0001)
+
+/* NE_AUTH_DIGEST: Digest authentication uses a hash of the username,
+ * password, and certain aspects of the request, so prevents passive
+ * attackers from obtaining the credentials; active attackers can
+ * still modify most of the request/response if using an unsecured
+ * channel. */ 
+#define NE_AUTH_DIGEST (0x0002)
+
+/* NE_AUTH_NEGOTIATE: Negotiate uses GSSAPI/SSPI, or NTLM, to
+ * authenticate the user; an active attacker can modify any of the
+ * request/response at will, so this must not be used over an
+ * unsecured channel.  NE_AUTH_NEGOTIATE is currently equivalent to
+ * use of (NE_AUTH_GSSAPI | NE_AUTH_NTLM). */
+#define NE_AUTH_NEGOTIATE (0x0004)
+
+/* NE_AUTH_GSSAPI: Use GSSAPI or SSPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. NE_AUTH_GSSAPI
+ * is currently equivalent to (NE_AUTH_GSSAPI_ONLY | NE_AUTH_SSPI). */
+#define NE_AUTH_GSSAPI (0x0008)
+
+/* NE_AUTH_NTLM: Use NTLM to authenticate the user; an active attacker
+ * can modify any of the request/response at will, so this must not be
+ * used over an unsecured channel. */
+#define NE_AUTH_NTLM (0x0010)
+
+/* NE_AUTH_SSPI: Use SSPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. */
+#define NE_AUTH_SSPI (0x0020)
+
+/* NE_AUTH_GSSAPI_ONLY: Use GSSAPI to authenticate the user; an
+ * active attacker can modify any of the request/response at will, so
+ * this must not be used over an unsecured channel. */
+#define NE_AUTH_GSSAPI_ONLY (0x0040)
+
+/* The default set of supported protocols, as deemed appropriate for
+ * the given session scheme. */
+#define NE_AUTH_DEFAULT (0x1000)
+
+/* All protocols supported by the library. */
+#define NE_AUTH_ALL (0x2000)
+
+/* Add a callback to provide credentials for server and proxy
+ * authentication using a particular auth protocol or set of
+ * protocols.  The protocol is supplied as a bitmask of NE_AUTH_*
+ * values.  For NE_AUTH_NEGOTIATE, the creds and userdata arguments
+ * are ignored and may be NULL.
+ *
+ * These functions may be called multiple times per session to
+ * register callbacks for different protocols.  If the server presents
+ * more than one protocol in an auth challenge, the following
+ * algorithm will be used to determine which callback is used:
+ *
+ * - iterate over the registered callbacks in the order registered
+ * - for each each callback, iterate over the known set of protocols
+ *   in order of algorithm strength (strongest first).
+ * - if the protocol mask for that callback matches the protocol,
+ *   attempt authentication using this protocol.
+ *
+ * Therefore, if multiple calls to ne_add_server_auth or
+ * ne_add_proxy_auth are used for a given session, the caller must
+ * ensure that the order in which those calls are made reflects the
+ * precedence of protocols to be used. */
+void ne_add_server_auth(ne_session *sess, unsigned protocol, 
+                        ne_auth_creds creds, void *userdata);
+void ne_add_proxy_auth(ne_session *sess, unsigned protocol, 
+                       ne_auth_creds creds, void *userdata);
+
+/* Clear any cached authentication credentials for the given
+ * session. */
+void ne_forget_auth(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_AUTH_H */
diff --git a/net/mmt/neon/src/ne_basic.c b/net/mmt/neon/src/ne_basic.c
new file mode 100644
index 0000000..7b7190e
--- /dev/null
+++ b/net/mmt/neon/src/ne_basic.c
@@ -0,0 +1,501 @@
+/* 
+   Basic HTTP and WebDAV methods
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/stat.h> /* for struct stat */
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <errno.h>
+
+#include "ne_request.h"
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_basic.h"
+#include "ne_207.h"
+
+#ifdef NE_HAVE_DAV
+#include "ne_uri.h"
+#include "ne_locks.h"
+#endif
+
+#include "ne_dates.h"
+#include "ne_internal.h"
+
+int ne_getmodtime(ne_session *sess, const char *uri, time_t *modtime) 
+{
+    ne_request *req = ne_request_create(sess, "HEAD", uri);
+    const char *value;
+    int ret;
+
+    ret = ne_request_dispatch(req);
+
+    value = ne_get_response_header(req, "Last-Modified"); 
+
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	*modtime = -1;
+	ret = NE_ERROR;
+    } 
+    else if (value) {
+        *modtime = ne_httpdate_parse(value);
+    }
+    else {
+        *modtime = -1;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+#ifdef NE_LFS
+#define ne_fstat fstat64
+typedef struct stat64 struct_stat;
+#else
+#define ne_fstat fstat
+typedef struct stat struct_stat;
+#endif
+
+/* PUT's from fd to URI */
+int ne_put(ne_session *sess, const char *uri, int fd) 
+{
+    ne_request *req;
+    struct_stat st;
+    int ret;
+
+    if (ne_fstat(fd, &st)) {
+        int errnum = errno;
+        char buf[200];
+
+        ne_set_error(sess, _("Could not determine file size: %s"),
+                     ne_strerror(errnum, buf, sizeof buf));
+        return NE_ERROR;
+    }
+    
+    req = ne_request_create(sess, "PUT", uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+    ne_lock_using_parent(req, uri);
+#endif
+
+    ne_set_request_body_fd(req, fd, 0, st.st_size);
+	
+    ret = ne_request_dispatch(req);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2)
+	ret = NE_ERROR;
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+/* Dispatch a GET request REQ, writing the response body to FD fd.  If
+ * RANGE is non-NULL, then it is the value of the Range request
+ * header, e.g. "bytes=1-5".  Returns an NE_* error code. */
+static int dispatch_to_fd(ne_request *req, int fd, const char *range)
+{
+    ne_session *const sess = ne_get_session(req);
+    const ne_status *const st = ne_get_status(req);
+    int ret;
+    size_t rlen;
+
+    /* length of bytespec after "bytes=" */
+    rlen = range ? strlen(range + 6) : 0;
+
+    do {
+        const char *value;
+        
+        ret = ne_begin_request(req);
+        if (ret != NE_OK) break;
+
+        value = ne_get_response_header(req, "Content-Range");
+
+        /* For a 206 response, check that a Content-Range header is
+         * given which matches the Range request header. */
+        if (range && st->code == 206 
+            && (value == NULL || strncmp(value, "bytes ", 6) != 0
+                || strncmp(range + 6, value + 6, rlen)
+                || (range[5 + rlen] != '-' && value[6 + rlen] != '/'))) {
+            ne_set_error(sess, _("Response did not include requested range"));
+            return NE_ERROR;
+        }
+
+        if ((range && st->code == 206) || (!range && st->klass == 2)) {
+            ret = ne_read_response_to_fd(req, fd);
+        } else {
+            ret = ne_discard_response(req);
+        }
+
+        if (ret == NE_OK) ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    return ret;
+}
+
+static int get_range_common(ne_session *sess, const char *uri, 
+                            const char *brange, int fd)
+
+{
+    ne_request *req = ne_request_create(sess, "GET", uri);
+    const ne_status *status;
+    int ret;
+
+    ne_add_request_header(req, "Range", brange);
+    ne_add_request_header(req, "Accept-Ranges", "bytes");
+
+    ret = dispatch_to_fd(req, fd, brange);
+
+    status = ne_get_status(req);
+
+    if (ret == NE_OK && status->code == 416) {
+	/* connection is terminated too early with Apache/1.3, so we check
+	 * this even if ret == NE_ERROR... */
+	ne_set_error(sess, _("Range is not satisfiable"));
+	ret = NE_ERROR;
+    }
+    else if (ret == NE_OK) {
+	if (status->klass == 2 && status->code != 206) {
+	    ne_set_error(sess, _("Resource does not support ranged GET requests"));
+	    ret = NE_ERROR;
+	}
+	else if (status->klass != 2) {
+	    ret = NE_ERROR;
+	}
+    } 
+    
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_get_range(ne_session *sess, const char *uri, 
+		 ne_content_range *range, int fd)
+{
+    char brange[64];
+
+    if (range->end == -1) {
+        ne_snprintf(brange, sizeof brange, "bytes=%" FMT_NE_OFF_T "-", 
+                    range->start);
+    }
+    else {
+	ne_snprintf(brange, sizeof brange,
+                    "bytes=%" FMT_NE_OFF_T "-%" FMT_NE_OFF_T,
+                    range->start, range->end);
+    }
+
+    return get_range_common(sess, uri, brange, fd);
+}
+
+/* Get to given fd */
+int ne_get(ne_session *sess, const char *uri, int fd)
+{
+    ne_request *req = ne_request_create(sess, "GET", uri);
+    int ret;
+
+    ret = dispatch_to_fd(req, fd, NULL);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+
+/* Get to given fd */
+int ne_post(ne_session *sess, const char *uri, int fd, const char *buffer)
+{
+    ne_request *req = ne_request_create(sess, "POST", uri);
+    int ret;
+
+    ne_set_request_flag(req, NE_REQFLAG_IDEMPOTENT, 0);
+
+    ne_set_request_body_buffer(req, buffer, strlen(buffer));
+
+    ret = dispatch_to_fd(req, fd, NULL);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_get_content_type(ne_request *req, ne_content_type *ct)
+{
+    const char *value;
+    char *sep, *stype;
+
+    value = ne_get_response_header(req, "Content-Type");
+    if (value == NULL || strchr(value, '/') == NULL) {
+        return -1;
+    }
+
+    ct->value = ne_strdup(value);
+    
+    stype = strchr(ct->value, '/');
+
+    *stype++ = '\0';
+    ct->type = ct->value;
+    ct->charset = NULL;
+    
+    sep = strchr(stype, ';');
+
+    if (sep) {
+	char *tok;
+	/* look for the charset parameter. TODO; probably better to
+	 * hand-carve a parser than use ne_token/strstr/shave here. */
+	*sep++ = '\0';
+	do {
+	    tok = ne_qtoken(&sep, ';', "\"\'");
+	    if (tok) {
+		tok = strstr(tok, "charset=");
+		if (tok)
+		    ct->charset = ne_shave(tok+8, "\"\'");
+	    } else {
+		break;
+	    }
+	} while (sep != NULL);
+    }
+
+    /* set subtype, losing any trailing whitespace */
+    ct->subtype = ne_shave(stype, " \t");
+    
+    if (ct->charset == NULL && ne_strcasecmp(ct->type, "text") == 0) {
+        /* 32803.1: text/xml without charset implies us-ascii. */
+        if (ne_strcasecmp(ct->subtype, "xml") == 0)
+            ct->charset = "us-ascii";
+        /* 26163.7.1: subtypes of text/ default to charset ISO-8859-1. */
+        else
+            ct->charset = "ISO-8859-1";
+    }
+    
+    return 0;
+}
+
+static const struct options_map {
+    const char *name;
+    unsigned int cap;
+} options_map[] = {
+    { "1", NE_CAP_DAV_CLASS1 },
+    { "2", NE_CAP_DAV_CLASS2 },
+    { "3", NE_CAP_DAV_CLASS3 },
+    { "<http://apache.org/dav/propset/fs/1>", NE_CAP_MODDAV_EXEC },
+    { "access-control", NE_CAP_DAV_ACL },
+    { "version-control", NE_CAP_VER_CONTROL },
+    { "checkout-in-place", NE_CAP_CO_IN_PLACE },
+    { "version-history", NE_CAP_VER_HISTORY },
+    { "workspace", NE_CAP_WORKSPACE },
+    { "update", NE_CAP_UPDATE },
+    { "label", NE_CAP_LABEL },
+    { "working-resource", NE_CAP_WORK_RESOURCE },
+    { "merge", NE_CAP_MERGE },
+    { "baseline", NE_CAP_BASELINE },
+    { "version-controlled-collection", NE_CAP_VC_COLLECTION },
+    { "extended-mkcol", NE_CAP_EXT_MKCOL }
+};
+
+static void parse_dav_header(const char *value, unsigned int *caps)
+{
+    char *tokens = ne_strdup(value), *pnt = tokens;
+    
+    *caps = 0;
+
+    do {
+        char *tok = ne_qtoken(&pnt, ',',  "\"'");
+        unsigned n;
+
+        if (!tok) break;
+        
+        tok = ne_shave(tok, " \r\t\n");
+
+        for (n = 0; n < sizeof(options_map)/sizeof(options_map[0]); n++) {
+            if (strcmp(tok, options_map[n].name) == 0) {
+                *caps |= options_map[n].cap;
+            }
+        }
+    } while (pnt != NULL);
+    
+    ne_free(tokens);
+}
+
+int ne_options2(ne_session *sess, const char *uri, unsigned int *caps)
+{
+    ne_request *req = ne_request_create(sess, "OPTIONS", uri);
+    int ret = ne_request_dispatch(req);
+    const char *header = ne_get_response_header(req, "DAV");
+    
+    if (header) parse_dav_header(header, caps);
+ 
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+    
+    ne_request_destroy(req);
+
+    return ret;
+}
+
+int ne_options(ne_session *sess, const char *path,
+               ne_server_capabilities *caps)
+{
+    int ret;
+    unsigned int capmask = 0;
+    
+    memset(caps, 0, sizeof *caps);
+
+    ret = ne_options2(sess, path, &capmask);
+
+    caps->dav_class1 = capmask & NE_CAP_DAV_CLASS1 ? 1 : 0;
+    caps->dav_class2 = capmask & NE_CAP_DAV_CLASS2 ? 1 : 0;
+    caps->dav_executable = capmask & NE_CAP_MODDAV_EXEC ? 1 : 0;
+    
+    return ret;
+}
+
+#ifdef NE_HAVE_DAV
+
+void ne_add_depth_header(ne_request *req, int depth)
+{
+    const char *value;
+    switch(depth) {
+    case NE_DEPTH_ZERO:
+	value = "0";
+	break;
+    case NE_DEPTH_ONE:
+	value = "1";
+	break;
+    default:
+	value = "infinity";
+	break;
+    }
+    ne_add_request_header(req, "Depth", value);
+}
+
+static int copy_or_move(ne_session *sess, int is_move, int overwrite,
+			int depth, const char *src, const char *dest) 
+{
+    ne_request *req = ne_request_create( sess, is_move?"MOVE":"COPY", src );
+
+    /* 2518 S8.9.2 says only use Depth: infinity with MOVE. */
+    if (!is_move) {
+	ne_add_depth_header(req, depth);
+    }
+
+#ifdef NE_HAVE_DAV
+    if (is_move) {
+	ne_lock_using_resource(req, src, NE_DEPTH_INFINITE);
+    }
+    ne_lock_using_resource(req, dest, NE_DEPTH_INFINITE);
+    /* And we need to be able to add members to the destination's parent */
+    ne_lock_using_parent(req, dest);
+#endif
+
+    if (ne_get_session_flag(sess, NE_SESSFLAG_RFC4918)) {
+        ne_add_request_header(req, "Destination", dest);
+    }
+    else {
+        ne_print_request_header(req, "Destination", "%s://%s%s", 
+                                ne_get_scheme(sess), 
+                                ne_get_server_hostport(sess), dest);
+    }
+    
+    ne_add_request_header(req, "Overwrite", overwrite?"T":"F");
+
+    return ne_simple_request(sess, req);
+}
+
+int ne_copy(ne_session *sess, int overwrite, int depth,
+	     const char *src, const char *dest) 
+{
+    return copy_or_move(sess, 0, overwrite, depth, src, dest);
+}
+
+int ne_move(ne_session *sess, int overwrite,
+	     const char *src, const char *dest) 
+{
+    return copy_or_move(sess, 1, overwrite, 0, src, dest);
+}
+
+/* Deletes the specified resource. (and in only two lines of code!) */
+int ne_delete(ne_session *sess, const char *uri) 
+{
+    ne_request *req = ne_request_create(sess, "DELETE", uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, NE_DEPTH_INFINITE);
+    ne_lock_using_parent(req, uri);
+#endif
+    
+    /* joe: I asked on the DAV WG list about whether we might get a
+     * 207 error back from a DELETE... conclusion, you shouldn't if
+     * you don't send the Depth header, since we might be an HTTP/1.1
+     * client and a 2xx response indicates success to them.  But
+     * it's all a bit unclear. In any case, DAV servers today do
+     * return 207 to DELETE even if we don't send the Depth header.
+     * So we handle 207 errors appropriately. */
+
+    return ne_simple_request(sess, req);
+}
+
+int ne_mkcol(ne_session *sess, const char *uri) 
+{
+    ne_request *req;
+    char *real_uri;
+    int ret;
+
+    if (ne_path_has_trailing_slash(uri)) {
+	real_uri = ne_strdup(uri);
+    } else {
+	real_uri = ne_concat(uri, "/", NULL);
+    }
+
+    req = ne_request_create(sess, "MKCOL", real_uri);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, real_uri, 0);
+    ne_lock_using_parent(req, real_uri);
+#endif
+    
+    ret = ne_simple_request(sess, req);
+
+    ne_free(real_uri);
+
+    return ret;
+}
+
+#endif /* NE_HAVE_DAV */
diff --git a/net/mmt/neon/src/ne_basic.h b/net/mmt/neon/src/ne_basic.h
new file mode 100644
index 0000000..257f033
--- /dev/null
+++ b/net/mmt/neon/src/ne_basic.h
@@ -0,0 +1,156 @@
+/* 
+   HTTP/1.1 methods
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_BASIC_H
+#define NE_BASIC_H
+
+#include <sys/types.h> /* for time_t */
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+/* Perform a GET request on resource at 'path', writing the entity
+ * body which is returned to 'fd'. */
+int ne_get(ne_session *sess, const char *path, int fd);
+
+/* Perform a PUT request on resource at 'path', reading the entity
+ * body to submit from 'fd'. */
+int ne_put(ne_session *sess, const char *path, int fd);
+
+#define NE_DEPTH_ZERO (0)
+#define NE_DEPTH_ONE (1)
+#define NE_DEPTH_INFINITE (2)
+
+/* For ne_copy and ne_move:
+ * 
+ * If a resource exists at "dest" and overwrite is zero, the operation
+ * will fail; if overwrite is non-zero, any existing resource will
+ * be over-written.
+ */
+
+/* Copy resource from 'src to 'dest' paths. If 'src' identifies a
+ * collection resource, depth may be NE_DEPTH_ZERO to request that the
+ * collection and its properties are to be copied, or
+ * NE_DEPTH_INFINITE to request that the collection and its contents
+ * are to be copied.  Returns NE_* error code. */
+int ne_copy(ne_session *sess, int overwrite, int depth,
+	    const char *src, const char *dest);
+
+/* Move resource from 'src' to 'dest' path.  Returns NE_* error
+ * code. */
+int ne_move(ne_session *sess, int overwrite,
+	    const char *src, const char *dest);
+
+/* Delete resource at 'path'.  Returns NE_* error code. */
+int ne_delete(ne_session *sess, const char *path);
+
+/* Create a collection at 'path', which is required to have a trailing
+ * slash.  Returns NE_* error code. */
+int ne_mkcol(ne_session *sess, const char *path);
+
+/* Adds a Depth: header to a request. */
+void ne_add_depth_header(ne_request *req, int depth);
+
+/* Retrieve modification time of resource at location 'path', using
+ * the HEAD method, placing parsed time in *modtime.  *modtime is set
+ * to -1 if no Last-Modified response header was given, or the date
+ * given could not be parsed.  Returns NE_* error code.  */
+int ne_getmodtime(ne_session *sess, const char *path, time_t *modtime);
+
+typedef struct {
+    const char *type, *subtype;
+    const char *charset;
+    char *value;
+} ne_content_type;
+
+/* Retrieve the content-type of the response; returns zero if response
+ * had valid content-type, in which case all fields in *ctype are set
+ * (and never NULL); the caller must free(ctype->value) after use.
+ * Returns non-zero on error, in which case *ctype is not altered. */
+int ne_get_content_type(ne_request *req, ne_content_type *ctype);
+
+/* DEPRECATED: Server capabilities. */
+typedef struct {
+    unsigned int dav_class1; /* True if Class 1 WebDAV server */
+    unsigned int dav_class2; /* True if Class 2 WebDAV server */
+    unsigned int dav_executable; /* True if supports the 'executable'
+				  * property a. la. mod_dav */
+} ne_server_capabilities;
+
+/* DEPRECATED: Determines server capabilities (using OPTIONS).  Use
+ * ne_options2() instead. */
+int ne_options(ne_session *sess, const char *path,
+               ne_server_capabilities *caps);
+
+#define NE_CAP_DAV_CLASS1    (0x0001) /* Class 1 WebDAV (RFC 2518) */
+#define NE_CAP_DAV_CLASS2    (0x0002) /* Class 2 WebDAV (RFC 2518) */
+#define NE_CAP_DAV_CLASS3    (0x0004) /* Class 3 WebDAV (RFC 4918) */
+#define NE_CAP_MODDAV_EXEC   (0x0008) /* mod_dav "executable" property */
+#define NE_CAP_DAV_ACL       (0x0010) /* WebDAV ACL (RFC 3744) */
+#define NE_CAP_VER_CONTROL   (0x0020) /* DeltaV version-control */
+#define NE_CAP_CO_IN_PLACE   (0x0040) /* DeltaV checkout-in-place */
+#define NE_CAP_VER_HISTORY   (0x0080) /* DeltaV version-history */
+#define NE_CAP_WORKSPACE     (0x0100) /* DeltaV workspace */
+#define NE_CAP_UPDATE        (0x0200) /* DeltaV update */
+#define NE_CAP_LABEL         (0x0400) /* DeltaV label */
+#define NE_CAP_WORK_RESOURCE (0x0800) /* DeltaV working-resouce */
+#define NE_CAP_MERGE         (0x1000) /* DeltaV merge */
+#define NE_CAP_BASELINE      (0x2000) /* DeltaV baseline */
+#define NE_CAP_ACTIVITY      (0x4000) /* DeltaV activity */
+#define NE_CAP_VC_COLLECTION (0x8000) /* DeltaV version-controlled-collection */
+#define NE_CAP_EXT_MKCOL    (0x10000) /* extended-mkcol (RFC 5689) */
+
+/* Determines resource capailities, using an OPTIONS request.  On
+ * return, *caps is set to a bit-mask of the above NE_CAP_* constants
+ * describing the advertised resource capabilities. */
+int ne_options2(ne_session *sess, const char *path, unsigned int *caps);
+
+/* Defines a range of bytes, starting at 'start' and ending
+ * at 'end'.  'total' is the number of bytes in the range.
+ */
+typedef struct {
+    ne_off_t start, end, total;
+} ne_content_range;
+
+/* Partial GET. range->start must be >= 0. range->total is ignored.
+ *
+ * If range->end is -1, then the rest of the resource from start is
+ * requested, and range->total and end are filled in on success.
+ *
+ * Otherwise, bytes from range->start to range->end are requested.
+ *
+ * This will write to the CURRENT position of f; so if you want
+ * to do a resume download, use:
+ *      struct ne_content_range range;
+ *      range.start = resume_from; 
+ *      range.end = range.start + 999;  (= 1000 bytes)
+ *      fseek(myfile, resume_from, SEEK_SET);
+ *      ne_get_range(sess, path, &range, myfile); */
+int ne_get_range(ne_session *sess, const char *path, 
+		 ne_content_range *range, int fd);
+
+/* Post using buffer as request-body: stream response into f */
+int ne_post(ne_session *sess, const char *path, int fd, const char *buffer);
+
+NE_END_DECLS
+
+#endif /* NE_BASIC_H */
diff --git a/net/mmt/neon/src/ne_compress.c b/net/mmt/neon/src/ne_compress.c
new file mode 100644
index 0000000..f122bf5
--- /dev/null
+++ b/net/mmt/neon/src/ne_compress.c
@@ -0,0 +1,449 @@
+/* 
+   Handling of compressed HTTP responses
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_compress.h"
+#include "ne_utils.h"
+#include "ne_internal.h"
+
+#ifdef NE_HAVE_ZLIB
+
+#include <zlib.h>
+
+/* Adds support for the 'gzip' Content-Encoding in HTTP.  gzip is a
+ * file format which wraps the DEFLATE compression algorithm.  zlib
+ * implements DEFLATE: we have to unwrap the gzip format (specified in
+ * RFC1952) as it comes off the wire, and hand off chunks of data to
+ * be inflated. */
+
+struct ne_decompress_s {
+    ne_request *request; /* associated request. */
+    ne_session *session; /* associated session. */
+    /* temporary buffer for holding inflated data. */
+    char outbuf[NE_BUFSIZ];
+    z_stream zstr;
+    int zstrinit; /* non-zero if zstr has been initialized */
+
+    /* pass blocks back to this. */
+    ne_block_reader reader;
+    ne_accept_response acceptor;
+    void *userdata;
+
+    /* buffer for gzip header bytes. */
+    unsigned char header[10];
+    size_t hdrcount;    /* bytes in header */
+
+    unsigned char footer[8];
+    size_t footcount; /* bytes in footer. */
+
+    /* CRC32 checksum: odd that zlib uses uLong for this since it is a
+     * 64-bit integer on LP64 platforms. */
+    uLong checksum;
+
+    /* current state. */
+    enum state {
+	NE_Z_BEFORE_DATA, /* not received any response blocks yet. */
+	NE_Z_PASSTHROUGH, /* response not compressed: passing through. */
+	NE_Z_IN_HEADER, /* received a few bytes of response data, but not
+			 * got past the gzip header yet. */
+	NE_Z_POST_HEADER, /* waiting for the end of the NUL-terminated bits. */
+	NE_Z_INFLATING, /* inflating response bytes. */
+	NE_Z_AFTER_DATA, /* after data; reading CRC32 & ISIZE */
+	NE_Z_FINISHED /* stream is finished. */
+    } state;
+};
+
+/* Convert 'buf' to unsigned int; 'buf' must be 'unsigned char *' */
+#define BUF2UINT(buf) (((buf)[3]<<24) + ((buf)[2]<<16) + ((buf)[1]<<8) + (buf)[0])
+
+#define ID1 0x1f
+#define ID2 0x8b
+
+#define HDR_DONE 0
+#define HDR_EXTENDED 1
+#define HDR_ERROR 2
+
+#define HDR_ID1(ctx) ((ctx)->header[0])
+#define HDR_ID2(ctx) ((ctx)->header[1])
+#define HDR_CMETH(ctx) ((ctx)->header[2])
+#define HDR_FLAGS(ctx) ((ctx)->header[3])
+#define HDR_MTIME(ctx) (BUF2UINT(&(ctx)->header[4]))
+#define HDR_XFLAGS(ctx) ((ctx)->header[8])
+#define HDR_OS(ctx) ((ctx)->header[9])
+
+/* parse_header parses the gzip header, sets the next state and returns
+ *   HDR_DONE: all done, bytes following are raw DEFLATE data.
+ *   HDR_EXTENDED: all done, expect a NUL-termianted string
+ *                 before the DEFLATE data
+ *   HDR_ERROR: invalid header, give up (session error is set).
+ */
+static int parse_header(ne_decompress *ctx)
+{
+    NE_DEBUG(NE_DBG_HTTP, "ID1: %d  ID2: %d, cmeth %d, flags %d\n", 
+             HDR_ID1(ctx), HDR_ID2(ctx), HDR_CMETH(ctx), HDR_FLAGS(ctx));
+    
+    if (HDR_ID1(ctx) != ID1 || HDR_ID2(ctx) != ID2 || HDR_CMETH(ctx) != 8) {
+	ne_set_error(ctx->session, "Compressed stream invalid");
+	return HDR_ERROR;
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "mtime: %d, xflags: %d, os: %d\n",
+	     HDR_MTIME(ctx), HDR_XFLAGS(ctx), HDR_OS(ctx));
+    
+    /* TODO: we can only handle one NUL-terminated extensions field
+     * currently.  Really, we should count the number of bits set, and
+     * skip as many fields as bits set (bailing if any reserved bits
+     * are set. */
+    if (HDR_FLAGS(ctx) == 8) {
+	ctx->state = NE_Z_POST_HEADER;
+	return HDR_EXTENDED;
+    } else if (HDR_FLAGS(ctx) != 0) {
+	ne_set_error(ctx->session, "Compressed stream not supported");
+	return HDR_ERROR;
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "compress: Good stream.\n");
+    
+    ctx->state = NE_Z_INFLATING;
+    return HDR_DONE;
+}
+
+/* Process extra 'len' bytes of 'buf' which were received after the
+ * DEFLATE data. */
+static int process_footer(ne_decompress *ctx, 
+			   const unsigned char *buf, size_t len)
+{
+    if (len + ctx->footcount > 8) {
+        ne_set_error(ctx->session, 
+                     "Too many bytes (%" NE_FMT_SIZE_T ") in gzip footer",
+                     len);
+        return -1;
+    } else {
+	memcpy(ctx->footer + ctx->footcount, buf, len);
+	ctx->footcount += len;
+	if (ctx->footcount == 8) {
+	    uLong crc = BUF2UINT(ctx->footer) & 0xFFFFFFFF;
+	    if (crc == ctx->checksum) {
+		ctx->state = NE_Z_FINISHED;
+		NE_DEBUG(NE_DBG_HTTP, "compress: End of response; checksum match.\n");
+	    } else {
+		NE_DEBUG(NE_DBG_HTTP, "compress: End of response; checksum mismatch: "
+			 "given %lu vs computed %lu\n", crc, ctx->checksum);
+		ne_set_error(ctx->session, 
+			     "Checksum invalid for compressed stream");
+                return -1;
+	    }
+	}
+    }
+    return 0;
+}
+
+/* A zlib function failed with 'code'; set the session error string
+ * appropriately. */
+static void set_zlib_error(ne_decompress *ctx, const char *msg, int code)
+{
+    if (ctx->zstr.msg)
+        ne_set_error(ctx->session, "%s: %s", msg, ctx->zstr.msg);
+    else {
+        const char *err;
+        switch (code) {
+        case Z_STREAM_ERROR: err = "stream error"; break;
+        case Z_DATA_ERROR: err = "data corrupt"; break;
+        case Z_MEM_ERROR: err = "out of memory"; break;
+        case Z_BUF_ERROR: err = "buffer error"; break;
+        case Z_VERSION_ERROR: err = "library version mismatch"; break;
+        default: err = "unknown error"; break;
+        }
+        ne_set_error(ctx->session, _("%s: %s (code %d)"), msg, err, code);
+    }
+}
+
+/* Inflate response buffer 'buf' of length 'len'. */
+static int do_inflate(ne_decompress *ctx, const char *buf, size_t len)
+{
+    int ret;
+
+    ctx->zstr.avail_in = len;
+    ctx->zstr.next_in = (unsigned char *)buf;
+    ctx->zstr.total_in = 0;
+    
+    do {
+	ctx->zstr.avail_out = sizeof ctx->outbuf;
+	ctx->zstr.next_out = (unsigned char *)ctx->outbuf;
+	ctx->zstr.total_out = 0;
+	
+	ret = inflate(&ctx->zstr, Z_NO_FLUSH);
+	
+	NE_DEBUG(NE_DBG_HTTP, 
+		 "compress: inflate %d, %ld bytes out, %d remaining\n",
+		 ret, ctx->zstr.total_out, ctx->zstr.avail_in);
+#if 0
+	NE_DEBUG(NE_DBG_HTTPBODY,
+		 "Inflated body block (%ld):\n[%.*s]\n", 
+		 ctx->zstr.total_out, (int)ctx->zstr.total_out, 
+		 ctx->outbuf);
+#endif
+	/* update checksum. */
+	ctx->checksum = crc32(ctx->checksum, (unsigned char *)ctx->outbuf, 
+			      ctx->zstr.total_out);
+
+	/* pass on the inflated data, if any */
+        if (ctx->zstr.total_out > 0) {
+            int rret = ctx->reader(ctx->userdata, ctx->outbuf,
+                                   ctx->zstr.total_out);
+            if (rret) return rret;
+        }	
+    } while (ret == Z_OK && ctx->zstr.avail_in > 0);
+    
+    if (ret == Z_STREAM_END) {
+	NE_DEBUG(NE_DBG_HTTP, "compress: end of data stream, %d bytes remain.\n",
+		 ctx->zstr.avail_in);
+	/* process the footer. */
+	ctx->state = NE_Z_AFTER_DATA;
+	return process_footer(ctx, ctx->zstr.next_in, ctx->zstr.avail_in);
+    } else if (ret != Z_OK) {
+        set_zlib_error(ctx, _("Could not inflate data"), ret);
+        return NE_ERROR;
+    }
+    return 0;
+}
+
+/* Callback which is passed blocks of the response body. */
+static int gz_reader(void *ud, const char *buf, size_t len)
+{
+    ne_decompress *ctx = ud;
+    const char *zbuf;
+    size_t count;
+    const char *hdr;
+
+    if (len == 0) {
+        /* End of response: */
+        switch (ctx->state) {
+        case NE_Z_BEFORE_DATA:
+            hdr = ne_get_response_header(ctx->request, "Content-Encoding");
+            if (hdr && ne_strcasecmp(hdr, "gzip") == 0) {
+                /* response was truncated: return error. */
+                break;
+            }
+            /* else, fall through */
+        case NE_Z_FINISHED: /* complete gzip response */
+        case NE_Z_PASSTHROUGH: /* complete uncompressed response */
+            return ctx->reader(ctx->userdata, buf, 0);
+        default:
+            /* invalid state: truncated response. */
+            break;
+        }
+	/* else: truncated response, fail. */
+	ne_set_error(ctx->session, "Compressed response was truncated");
+	return NE_ERROR;
+    }        
+
+    switch (ctx->state) {
+    case NE_Z_PASSTHROUGH:
+	/* move along there. */
+	return ctx->reader(ctx->userdata, buf, len);
+
+    case NE_Z_FINISHED:
+	/* Could argue for tolerance, and ignoring trailing content;
+	 * but it could mean something more serious. */
+	if (len > 0) {
+	    ne_set_error(ctx->session,
+			 "Unexpected content received after compressed stream");
+            return NE_ERROR;
+	}
+        break;
+
+    case NE_Z_BEFORE_DATA:
+	/* work out whether this is a compressed response or not. */
+        hdr = ne_get_response_header(ctx->request, "Content-Encoding");
+        if (hdr && ne_strcasecmp(hdr, "gzip") == 0) {
+            int ret;
+	    NE_DEBUG(NE_DBG_HTTP, "compress: got gzipped stream.\n");
+
+            /* inflateInit2() works here where inflateInit() doesn't. */
+            ret = inflateInit2(&ctx->zstr, -MAX_WBITS);
+            if (ret != Z_OK) {
+                set_zlib_error(ctx, _("Could not initialize zlib"), ret);
+                return -1;
+            }
+	    ctx->zstrinit = 1;
+
+	} else {
+	    /* No Content-Encoding header: pass it on.  TODO: we could
+	     * hack it and register the real callback now. But that
+	     * would require add_resp_body_rdr to have defined
+	     * ordering semantics etc etc */
+	    ctx->state = NE_Z_PASSTHROUGH;
+	    return ctx->reader(ctx->userdata, buf, len);
+	}
+
+	ctx->state = NE_Z_IN_HEADER;
+	/* FALLTHROUGH */
+
+    case NE_Z_IN_HEADER:
+	/* copy as many bytes as possible into the buffer. */
+	if (len + ctx->hdrcount > 10) {
+	    count = 10 - ctx->hdrcount;
+	} else {
+	    count = len;
+	}
+	memcpy(ctx->header + ctx->hdrcount, buf, count);
+	ctx->hdrcount += count;
+	/* have we got the full header yet? */
+	if (ctx->hdrcount != 10) {
+	    return 0;
+	}
+
+	buf += count;
+	len -= count;
+
+	switch (parse_header(ctx)) {
+	case HDR_EXTENDED:
+	    if (len == 0)
+		return 0;
+	    break;
+        case HDR_ERROR:
+            return NE_ERROR;
+	case HDR_DONE:
+	    if (len > 0) {
+		return do_inflate(ctx, buf, len);
+	    }
+            break;
+	}
+
+	/* FALLTHROUGH */
+
+    case NE_Z_POST_HEADER:
+	/* eating the filename string. */
+	zbuf = memchr(buf, '\0', len);
+	if (zbuf == NULL) {
+	    /* not found it yet. */
+	    return 0;
+	}
+
+	NE_DEBUG(NE_DBG_HTTP,
+		 "compresss: skipped %" NE_FMT_SIZE_T " header bytes.\n", 
+		 zbuf - buf);
+	/* found end of string. */
+	len -= (1 + zbuf - buf);
+	buf = zbuf + 1;
+	ctx->state = NE_Z_INFLATING;
+	if (len == 0) {
+	    /* end of string was at end of buffer. */
+	    return 0;
+	}
+
+	/* FALLTHROUGH */
+
+    case NE_Z_INFLATING:
+	return do_inflate(ctx, buf, len);
+
+    case NE_Z_AFTER_DATA:
+	return process_footer(ctx, (unsigned char *)buf, len);
+    }
+
+    return 0;
+}
+
+/* Prepare for a compressed response; may be called many times per
+ * request, for auth retries etc. */
+static void gz_pre_send(ne_request *r, void *ud, ne_buffer *req)
+{
+    ne_decompress *ctx = ud;
+
+    if (ctx->request == r) {
+        NE_DEBUG(NE_DBG_HTTP, "compress: Initialization.\n");
+        
+        /* (Re-)Initialize the context */
+        ctx->state = NE_Z_BEFORE_DATA;
+        if (ctx->zstrinit) inflateEnd(&ctx->zstr);
+        ctx->zstrinit = 0;
+        ctx->hdrcount = ctx->footcount = 0;
+        ctx->checksum = crc32(0L, Z_NULL, 0);
+    }
+}
+
+/* Wrapper for user-passed acceptor function. */
+static int gz_acceptor(void *userdata, ne_request *req, const ne_status *st)
+{
+    ne_decompress *ctx = userdata;
+    return ctx->acceptor(ctx->userdata, req, st);
+}
+
+/* A slightly ugly hack: the pre_send hook is scoped per-session, so
+ * must check that the invoking request is this one, before doing
+ * anything, and must be unregistered when the context is
+ * destroyed. */
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response acpt,
+				    ne_block_reader rdr, void *userdata)
+{
+    ne_decompress *ctx = ne_calloc(sizeof *ctx);
+
+    ne_add_request_header(req, "Accept-Encoding", "gzip");
+
+    ne_add_response_body_reader(req, gz_acceptor, gz_reader, ctx);
+
+    ctx->reader = rdr;
+    ctx->userdata = userdata;
+    ctx->session = ne_get_session(req);
+    ctx->request = req;
+    ctx->acceptor = acpt;
+
+    ne_hook_pre_send(ne_get_session(req), gz_pre_send, ctx);
+
+    return ctx;    
+}
+
+void ne_decompress_destroy(ne_decompress *ctx)
+{
+    if (ctx->zstrinit) inflateEnd(&ctx->zstr);
+
+    ne_unhook_pre_send(ctx->session, gz_pre_send, ctx);
+
+    ne_free(ctx);
+}
+
+#else /* !NE_HAVE_ZLIB */
+
+/* Pass-through interface present to provide ABI compatibility. */
+
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response acpt,
+				    ne_block_reader rdr, void *userdata)
+{
+    ne_add_response_body_reader(req, acpt, rdr, userdata);
+    /* an arbitrary return value: don't confuse them by returning NULL. */
+    return (ne_decompress *)req;
+}
+
+void ne_decompress_destroy(ne_decompress *dc)
+{
+}
+
+#endif /* NE_HAVE_ZLIB */
diff --git a/net/mmt/neon/src/ne_compress.h b/net/mmt/neon/src/ne_compress.h
new file mode 100644
index 0000000..039cebd
--- /dev/null
+++ b/net/mmt/neon/src/ne_compress.h
@@ -0,0 +1,48 @@
+/* 
+   Compressed HTTP response handling
+   Copyright (C) 2001-2004, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_COMPRESS_H
+#define NE_COMPRESS_H
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_decompress_s ne_decompress;
+
+/* Call this to register a 'reader' callback which will be passed
+ * blocks of response body (if the 'acceptance' callback is
+ * successful).  If the response body is returned compressed by the
+ * server, this reader will receive UNCOMPRESSED blocks.
+ *
+ * Returns pointer to context object which must be passed to
+ * ne_decompress_destroy after the request has been dispatched, to
+ * free any internal state.  If an error occurs during decompression,
+ * the request will be aborted and session error string set. */
+ne_decompress *ne_decompress_reader(ne_request *req, ne_accept_response accpt,
+				    ne_block_reader rdr, void *userdata);
+
+/* Destroys decompression state. */
+void ne_decompress_destroy(ne_decompress *ctx);
+
+NE_END_DECLS
+
+#endif /* NE_COMPRESS_H */
diff --git a/net/mmt/neon/src/ne_dates.c b/net/mmt/neon/src/ne_dates.c
new file mode 100644
index 0000000..b621e7a
--- /dev/null
+++ b/net/mmt/neon/src/ne_dates.c
@@ -0,0 +1,262 @@
+/* 
+   Date manipulation routines
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004 Jiang Lei <tristone@deluxe.ocn.ne.jp>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <time.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#include <stdio.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef WIN32
+#include <windows.h> /* for TIME_ZONE_INFORMATION */
+#endif
+
+#include "ne_alloc.h"
+#include "ne_dates.h"
+#include "ne_string.h"
+
+/* Generic date manipulation routines. */
+
+/* ISO8601: 2001-01-01T12:30:00Z */
+#define ISO8601_FORMAT_Z "%04d-%02d-%02dT%02d:%02d:%lfZ"
+#define ISO8601_FORMAT_M "%04d-%02d-%02dT%02d:%02d:%lf-%02d:%02d"
+#define ISO8601_FORMAT_P "%04d-%02d-%02dT%02d:%02d:%lf+%02d:%02d"
+
+/* RFC1123: Sun, 06 Nov 1994 08:49:37 GMT */
+#define RFC1123_FORMAT "%3s, %02d %3s %4d %02d:%02d:%02d GMT"
+/* RFC850:  Sunday, 06-Nov-94 08:49:37 GMT */
+#define RFC1036_FORMAT "%10s %2d-%3s-%2d %2d:%2d:%2d GMT"
+/* asctime: Wed Jun 30 21:49:08 1993 */
+#define ASCTIME_FORMAT "%3s %3s %2d %2d:%2d:%2d %4d"
+
+static const char rfc1123_weekdays[7][4] = { 
+    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" 
+};
+static const char short_months[12][4] = { 
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
+
+#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
+#define GMTOFF(t) ((t).tm_gmtoff)
+#elif defined(HAVE_STRUCT_TM___TM_GMTOFF)
+#define GMTOFF(t) ((t).__tm_gmtoff)
+#elif defined(WIN32)
+#define GMTOFF(t) (gmt_to_local_win32())
+#elif defined(HAVE_TIMEZONE)
+/* FIXME: the following assumes fixed dst offset of 1 hour */
+#define GMTOFF(t) (-timezone + ((t).tm_isdst > 0 ? 3600 : 0))
+#else
+/* FIXME: work out the offset anyway. */
+#define GMTOFF(t) (0)
+#endif
+
+#ifdef WIN32
+time_t gmt_to_local_win32(void)
+{
+    TIME_ZONE_INFORMATION tzinfo;
+    DWORD dwStandardDaylight;
+    long bias;
+
+    dwStandardDaylight = GetTimeZoneInformation(&tzinfo);
+    bias = tzinfo.Bias;
+
+    if (dwStandardDaylight == TIME_ZONE_ID_STANDARD)
+        bias += tzinfo.StandardBias;
+    
+    if (dwStandardDaylight == TIME_ZONE_ID_DAYLIGHT)
+        bias += tzinfo.DaylightBias;
+    
+    return (- bias * 60);
+}
+#endif
+
+/* Returns the time/date GMT, in RFC1123-type format: eg
+ *  Sun, 06 Nov 1994 08:49:37 GMT. */
+char *ne_rfc1123_date(time_t anytime) {
+    struct tm *gmt;
+    char *ret;
+    gmt = gmtime(&anytime);
+    if (gmt == NULL)
+	return NULL;
+    ret = ne_malloc(29 + 1); /* dates are 29 chars long */
+/*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
+    ne_snprintf(ret, 30, RFC1123_FORMAT,
+		rfc1123_weekdays[gmt->tm_wday], gmt->tm_mday, 
+		short_months[gmt->tm_mon], 1900 + gmt->tm_year, 
+		gmt->tm_hour, gmt->tm_min, gmt->tm_sec);
+    
+    return ret;
+}
+
+/* Takes an ISO-8601-formatted date string and returns the time_t.
+ * Returns (time_t)-1 if the parse fails. */
+time_t ne_iso8601_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int off_hour, off_min;
+    double sec;
+    off_t fix;
+    int n;
+    time_t result;
+
+    /*  it goes: ISO8601: 2001-01-01T12:30:00+03:30 */
+    if ((n = sscanf(date, ISO8601_FORMAT_P,
+		    &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+		    &gmt.tm_hour, &gmt.tm_min, &sec,
+		    &off_hour, &off_min)) == 8) {
+      gmt.tm_sec = (int)sec;
+      fix = - off_hour * 3600 - off_min * 60;
+    }
+    /*  it goes: ISO8601: 2001-01-01T12:30:00-03:30 */
+    else if ((n = sscanf(date, ISO8601_FORMAT_M,
+			 &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+			 &gmt.tm_hour, &gmt.tm_min, &sec,
+			 &off_hour, &off_min)) == 8) {
+      gmt.tm_sec = (int)sec;
+      fix = off_hour * 3600 + off_min * 60;
+    }
+    /*  it goes: ISO8601: 2001-01-01T12:30:00Z */
+    else if ((n = sscanf(date, ISO8601_FORMAT_Z,
+			 &gmt.tm_year, &gmt.tm_mon, &gmt.tm_mday,
+			 &gmt.tm_hour, &gmt.tm_min, &sec)) == 6) {
+      gmt.tm_sec = (int)sec;
+      fix = 0;
+    }
+    else {
+      return (time_t)-1;
+    }
+
+    gmt.tm_year -= 1900;
+    gmt.tm_isdst = -1;
+    gmt.tm_mon--;
+
+    result = mktime(&gmt) + fix;
+    return result + GMTOFF(gmt);
+}
+
+/* Takes an RFC1123-formatted date string and returns the time_t.
+ * Returns (time_t)-1 if the parse fails. */
+time_t ne_rfc1123_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    char wkday[4], mon[4];
+    int n;
+    time_t result;
+    
+/*  it goes: Sun, 06 Nov 1994 08:49:37 GMT */
+    n = sscanf(date, RFC1123_FORMAT,
+	    wkday, &gmt.tm_mday, mon, &gmt.tm_year, &gmt.tm_hour,
+	    &gmt.tm_min, &gmt.tm_sec);
+    /* Is it portable to check n==7 here? */
+    gmt.tm_year -= 1900;
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+/* Takes a string containing a RFC1036-style date and returns the time_t */
+time_t ne_rfc1036_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int n;
+    char wkday[11], mon[4];
+    time_t result;
+
+    /* RFC850/1036 style dates: Sunday, 06-Nov-94 08:49:37 GMT */
+    n = sscanf(date, RFC1036_FORMAT,
+		wkday, &gmt.tm_mday, mon, &gmt.tm_year,
+		&gmt.tm_hour, &gmt.tm_min, &gmt.tm_sec);
+    if (n != 7) {
+	return (time_t)-1;
+    }
+
+    /* portable to check n here? */
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+
+    /* Defeat Y2K bug. */
+    if (gmt.tm_year < 50)
+	gmt.tm_year += 100;
+
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+
+/* (as)ctime dates are like:
+ *    Wed Jun 30 21:49:08 1993
+ */
+time_t ne_asctime_parse(const char *date) 
+{
+    struct tm gmt = {0};
+    int n;
+    char wkday[4], mon[4];
+    time_t result;
+
+    n = sscanf(date, ASCTIME_FORMAT,
+		wkday, mon, &gmt.tm_mday, 
+		&gmt.tm_hour, &gmt.tm_min, &gmt.tm_sec,
+		&gmt.tm_year);
+    /* portable to check n here? */
+    for (n=0; n<12; n++)
+	if (strcmp(mon, short_months[n]) == 0)
+	    break;
+    /* tm_mon comes out as 12 if the month is corrupt, which is desired,
+     * since the mktime will then fail */
+    gmt.tm_mon = n;
+    gmt.tm_isdst = -1;
+    result = mktime(&gmt);
+    return result + GMTOFF(gmt);
+}
+
+/* HTTP-date parser */
+time_t ne_httpdate_parse(const char *date)
+{
+    time_t tmp;
+    tmp = ne_rfc1123_parse(date);
+    if (tmp == -1) {
+        tmp = ne_rfc1036_parse(date);
+	if (tmp == -1)
+	    tmp = ne_asctime_parse(date);
+    }
+    return tmp;
+}
diff --git a/net/mmt/neon/src/ne_dates.h b/net/mmt/neon/src/ne_dates.h
new file mode 100644
index 0000000..7be69b1
--- /dev/null
+++ b/net/mmt/neon/src/ne_dates.h
@@ -0,0 +1,54 @@
+/* 
+   Date manipulation routines
+   Copyright (C) 1999-2002, 2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_DATES_H
+#define NE_DATES_H
+
+#include <sys/types.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Date manipulation routines as per RFC1123 and RFC1036 */
+
+/* Return current date/time in RFC1123 format */
+char *ne_rfc1123_date(time_t anytime);
+
+/* Returns time from date/time using the subset of the ISO8601 format
+ * referenced in RFC2518 (e.g as used in the creationdate property in
+ * the DAV: namespace). */
+time_t ne_iso8601_parse(const char *date);
+
+/* Returns time from date/time in RFC1123 format */
+time_t ne_rfc1123_parse(const char *date);
+
+time_t ne_rfc1036_parse(const char *date);
+
+/* Parses asctime date string */
+time_t ne_asctime_parse(const char *date);
+
+/* Parse an HTTP-date as per RFC2616 */
+time_t ne_httpdate_parse(const char *date);
+
+NE_END_DECLS
+
+#endif /* NE_DATES_H */
diff --git a/net/mmt/neon/src/ne_defs.h b/net/mmt/neon/src/ne_defs.h
new file mode 100644
index 0000000..4283454
--- /dev/null
+++ b/net/mmt/neon/src/ne_defs.h
@@ -0,0 +1,84 @@
+/* 
+   Standard definitions for neon headers
+   Copyright (C) 2003-2008, 2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#undef NE_BEGIN_DECLS
+#undef NE_END_DECLS
+#ifdef __cplusplus
+# define NE_BEGIN_DECLS extern "C" {
+# define NE_END_DECLS }
+#else
+# define NE_BEGIN_DECLS /* empty */
+# define NE_END_DECLS /* empty */
+#endif
+
+#ifndef NE_DEFS_H
+#define NE_DEFS_H
+
+#include <sys/types.h>
+
+#ifdef NE_LFS
+# ifdef _MSC_VER
+typedef __int64 off64_t;
+# endif
+typedef off64_t ne_off_t;
+#else
+typedef off_t ne_off_t;
+#endif
+
+/* define ssize_t for Win32 */
+#if defined(WIN32) && !defined(ssize_t)
+#define ssize_t int
+#endif
+
+#ifdef __NETWARE__
+#include <time.h> /* for time_t */
+#endif
+
+#ifdef __GNUC__
+#if __GNUC__ >= 3
+#ifndef NE_PRIVATE
+#define NE_PRIVATE __attribute__((visibility ("hidden")))
+#endif
+#define ne_attribute_malloc __attribute__((malloc))
+#else
+#define ne_attribute_malloc
+#endif
+#if __GNUC__ > 3
+#define ne_attribute_sentinel __attribute__((sentinel))
+#else
+#define ne_attribute_sentinel 
+#endif
+#define ne_attribute(x) __attribute__(x)
+#else
+#define ne_attribute(x)
+#define ne_attribute_malloc
+#define ne_attribute_sentinel
+#endif
+
+#ifndef NE_PRIVATE
+#define NE_PRIVATE
+#endif
+
+#ifndef NE_BUFSIZ
+#define NE_BUFSIZ 8192
+#endif
+
+#endif /* NE_DEFS_H */
diff --git a/net/mmt/neon/src/ne_gnutls.c b/net/mmt/neon/src/ne_gnutls.c
new file mode 100644
index 0000000..08d78cc
--- /dev/null
+++ b/net/mmt/neon/src/ne_gnutls.c
@@ -0,0 +1,1435 @@
+/*
+   neon SSL/TLS support using GNU TLS
+   Copyright (C) 2002-2011, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004, Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <gnutls/gnutls.h>
+#include <gnutls/pkcs12.h>
+
+#ifdef NE_HAVE_TS_SSL
+#include <errno.h>
+#include <pthread.h>
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#include <gcrypt.h>
+GCRY_THREAD_OPTION_PTHREAD_IMPL;
+#endif
+#else
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#include <gcrypt.h>
+#endif
+#endif
+
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
+
+#include "ne_ssl.h"
+#include "ne_string.h"
+#include "ne_session.h"
+#include "ne_internal.h"
+
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020302
+/* The GnuTLS DN functions in 2.3.2 and later allow a simpler DN
+ * abstraction to be used. */
+#define HAVE_NEW_DN_API
+#endif
+
+struct ne_ssl_dname_s {
+#ifdef HAVE_NEW_DN_API
+    gnutls_x509_dn_t dn;
+#else
+    int subject; /* non-zero if this is the subject DN object */
+    gnutls_x509_crt_t cert;
+#endif
+};
+
+struct ne_ssl_certificate_s {
+    ne_ssl_dname subj_dn, issuer_dn;
+    gnutls_x509_crt_t subject;
+    ne_ssl_certificate *issuer;
+    char *identity;
+};
+
+struct ne_ssl_client_cert_s {
+    gnutls_pkcs12_t p12;
+    int decrypted; /* non-zero if successfully decrypted. */
+    int keyless;
+    ne_ssl_certificate cert;
+    gnutls_x509_privkey_t pkey;
+    char *friendly_name;
+};
+
+/* Returns the highest used index in subject (or issuer) DN of
+ * certificate CERT for OID, or -1 if no RDNs are present in the DN
+ * using that OID. */
+static int oid_find_highest_index(gnutls_x509_crt_t cert, int subject, const char *oid)
+{
+    int ret, idx = -1;
+
+    do {
+        size_t len = 0;
+
+        if (subject)
+            ret = gnutls_x509_crt_get_dn_by_oid(cert, oid, ++idx, 0, 
+                                                NULL, &len);
+        else
+            ret = gnutls_x509_crt_get_issuer_dn_by_oid(cert, oid, ++idx, 0, 
+                                                       NULL, &len);
+    } while (ret == GNUTLS_E_SHORT_MEMORY_BUFFER);
+    
+    return idx - 1;
+}
+
+#ifdef HAVE_GNUTLS_X509_DN_GET_RDN_AVA
+/* New-style RDN handling introduced in GnuTLS 1.7.x. */
+
+#ifdef HAVE_ICONV
+static void convert_dirstring(ne_buffer *buf, const char *charset, 
+                              gnutls_datum_t *data)
+{
+    iconv_t id = iconv_open("UTF-8", charset);
+    size_t inlen = data->size, outlen = buf->length - buf->used;
+    char *inbuf = (char *)data->data;
+    char *outbuf = buf->data + buf->used - 1;
+    
+    if (id == (iconv_t)-1) {
+        char err[128], err2[128];
+
+        ne_snprintf(err, sizeof err, "[unprintable in %s: %s]",
+                    charset, ne_strerror(errno, err2, sizeof err2));
+        ne_buffer_zappend(buf, err);
+        return;
+    }
+    
+    ne_buffer_grow(buf, buf->used + 64);
+    
+    while (inlen && outlen 
+           && iconv(id, &inbuf, &inlen, &outbuf, &outlen) == 0)
+        ;
+    
+    iconv_close(id);
+    buf->used += buf->length - buf->used - outlen;
+    buf->data[buf->used - 1] = '\0';
+}
+#endif
+
+/* From section 11.13 of the Dubuisson ASN.1 bible: */
+#define TAG_UTF8 (12)
+#define TAG_PRINTABLE (19)
+#define TAG_T61 (20)
+#define TAG_IA5 (22)
+#define TAG_VISIBLE (26)
+#define TAG_UNIVERSAL (28)
+#define TAG_BMP (30)
+
+static void append_dirstring(ne_buffer *buf, gnutls_datum_t *data, unsigned long tag)
+{
+    switch (tag) {
+    case TAG_UTF8:
+    case TAG_IA5:
+    case TAG_PRINTABLE:
+    case TAG_VISIBLE:
+        ne_buffer_append(buf, (char *)data->data, data->size);
+        break;
+#ifdef HAVE_ICONV
+    case TAG_T61:
+        convert_dirstring(buf, "ISO-8859-1", data);
+        break;
+    case TAG_BMP:
+        convert_dirstring(buf, "UCS-2BE", data);
+        break;
+#endif
+    default: {
+        char tmp[128];
+        ne_snprintf(tmp, sizeof tmp, _("[unprintable:#%lu]"), tag);
+        ne_buffer_zappend(buf, tmp);
+    } break;
+    }
+}
+
+/* OIDs to not include in readable DNs by default: */
+#define OID_emailAddress "1.2.840.113549.1.9.1"
+#define OID_commonName "2.5.4.3"
+
+#define CMPOID(a,o) ((a)->oid.size == sizeof(o)                        \
+                     && memcmp((a)->oid.data, o, strlen(o)) == 0)
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    gnutls_x509_dn_t dn;
+    int ret, rdn = 0, flag = 0;
+    ne_buffer *buf;
+    gnutls_x509_ava_st val;
+
+#ifdef HAVE_NEW_DN_API
+    dn = name->dn;
+#else
+    if (name->subject)
+        ret = gnutls_x509_crt_get_subject(name->cert, &dn);
+    else
+        ret = gnutls_x509_crt_get_issuer(name->cert, &dn);
+    
+    if (ret)
+        return ne_strdup(_("[unprintable]"));
+#endif /* HAVE_NEW_DN_API */
+
+    buf = ne_buffer_create();
+    
+    /* Find the highest rdn... */
+    while (gnutls_x509_dn_get_rdn_ava(dn, rdn++, 0, &val) == 0)
+        ;        
+
+    /* ..then iterate back to the first: */
+    while (--rdn >= 0) {
+        int ava = 0;
+
+        /* Iterate through all AVAs for multivalued AVAs; better than
+         * ne_openssl can do! */
+        do {
+            ret = gnutls_x509_dn_get_rdn_ava(dn, rdn, ava, &val);
+
+            /* If the *only* attribute to append is the common name or
+             * email address, use it; otherwise skip those
+             * attributes. */
+            if (ret == 0 && val.value.size > 0
+                && ((!CMPOID(&val, OID_emailAddress)
+                     && !CMPOID(&val, OID_commonName))
+                    || (buf->used == 1 && rdn == 0))) {
+                flag = 1;
+                if (buf->used > 1) ne_buffer_append(buf, ", ", 2);
+
+                append_dirstring(buf, &val.value, val.value_tag);
+            }
+            
+            ava++;
+        } while (ret == 0);
+    }
+
+    return ne_buffer_finish(buf);
+}
+
+#else /* !HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+/* Appends the value of RDN with given oid from certitifcate x5
+ * subject (if subject is non-zero), or issuer DN to buffer 'buf': */
+static void append_rdn(ne_buffer *buf, gnutls_x509_crt_t x5, int subject, const char *oid)
+{
+    int idx, top, ret;
+    char rdn[50];
+
+    top = oid_find_highest_index(x5, subject, oid);
+    
+    for (idx = top; idx >= 0; idx--) {
+        size_t rdnlen = sizeof rdn;
+
+        if (subject)
+            ret = gnutls_x509_crt_get_dn_by_oid(x5, oid, idx, 0, rdn, &rdnlen);
+        else
+            ret = gnutls_x509_crt_get_issuer_dn_by_oid(x5, oid, idx, 0, rdn, &rdnlen);
+        
+        if (ret < 0)
+            return;
+
+        if (buf->used > 1) {
+            ne_buffer_append(buf, ", ", 2);
+        }
+        
+        ne_buffer_append(buf, rdn, rdnlen);
+    }
+}
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    ne_buffer *buf = ne_buffer_create();
+    int ret, idx = 0;
+
+    do {
+        char oid[32] = {0};
+        size_t oidlen = sizeof oid;
+        
+        ret = name->subject 
+            ? gnutls_x509_crt_get_dn_oid(name->cert, idx, oid, &oidlen)
+            : gnutls_x509_crt_get_issuer_dn_oid(name->cert, idx, oid, &oidlen);
+        
+        if (ret == 0) {
+            append_rdn(buf, name->cert, name->subject, oid);
+            idx++;
+        }
+    } while (ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);
+
+    return ne_buffer_finish(buf);
+}
+#endif /* HAVE_GNUTLS_X509_DN_GET_RDN_AVA */
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    char c1[1024], c2[1024];
+    size_t s1 = sizeof c1, s2 = sizeof c2;
+
+#ifdef HAVE_NEW_DN_API
+    if (gnutls_x509_dn_export(dn1->dn, GNUTLS_X509_FMT_DER, c1, &s1))
+        return 1;
+        
+    if (gnutls_x509_dn_export(dn2->dn, GNUTLS_X509_FMT_DER, c2, &s2))
+        return -1;
+#else
+    int ret;
+
+    if (dn1->subject)
+        ret = gnutls_x509_crt_get_dn(dn1->cert, c1, &s1);
+    else
+        ret = gnutls_x509_crt_get_issuer_dn(dn1->cert, c1, &s1);
+    if (ret)
+        return 1;
+
+    if (dn2->subject)
+        ret = gnutls_x509_crt_get_dn(dn2->cert, c2, &s2);
+    else
+        ret = gnutls_x509_crt_get_issuer_dn(dn2->cert, c2, &s2);
+    if (ret)
+        return -1;
+#endif /* HAVE_NEW_DN_API */
+    
+    if (s1 != s2)
+        return s2 - s1;
+
+    return memcmp(c1, c2, s1);
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *cc)
+{
+    if (cc->p12)
+        gnutls_pkcs12_deinit(cc->p12);
+    if (cc->decrypted) {
+        if (cc->cert.identity) ne_free(cc->cert.identity);
+        if (cc->pkey) gnutls_x509_privkey_deinit(cc->pkey);
+        if (cc->cert.subject) gnutls_x509_crt_deinit(cc->cert.subject);
+    }
+    if (cc->friendly_name) ne_free(cc->friendly_name);
+    ne_free(cc);
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until)
+{
+    if (from) {
+        *from = gnutls_x509_crt_get_activation_time(cert->subject);
+    }
+    if (until) {
+        *until = gnutls_x509_crt_get_expiration_time(cert->subject);
+    }
+}
+
+/* Check certificate identity.  Returns zero if identity matches; 1 if
+ * identity does not match, or <0 if the certificate had no identity.
+ * If 'identity' is non-NULL, store the malloc-allocated identity in
+ * *identity.  If 'server' is non-NULL, it must be the network address
+ * of the server in use, and identity must be NULL. */
+static int check_identity(const ne_uri *server, gnutls_x509_crt_t cert,
+                          char **identity)
+{
+    char name[255];
+    unsigned int critical;
+    int ret, seq = 0;
+    int match = 0, found = 0;
+    size_t len;
+    const char *hostname;
+    
+    hostname = server ? server->host : "";
+
+    do {
+        len = sizeof name - 1;
+        ret = gnutls_x509_crt_get_subject_alt_name(cert, seq, name, &len,
+                                                   &critical);
+        switch (ret) {
+        case GNUTLS_SAN_DNSNAME:
+            name[len] = '\0';
+            if (identity && !found) *identity = ne_strdup(name);
+            match = ne__ssl_match_hostname(name, len, hostname);
+            found = 1;
+            break;
+        case GNUTLS_SAN_IPADDRESS: {
+            ne_inet_addr *ia;
+            if (len == 4)
+                ia = ne_iaddr_make(ne_iaddr_ipv4, (unsigned char *)name);
+            else if (len == 16)
+                ia = ne_iaddr_make(ne_iaddr_ipv6, (unsigned char *)name);
+            else 
+                ia = NULL;
+            if (ia) {
+                char buf[128];
+                
+                match = strcmp(hostname, 
+                               ne_iaddr_print(ia, buf, sizeof buf)) == 0;
+                if (identity) *identity = ne_strdup(buf);
+                found = 1;
+                ne_iaddr_free(ia);
+            } else {
+                NE_DEBUG(NE_DBG_SSL, "iPAddress name with unsupported "
+                         "address type (length %" NE_FMT_SIZE_T "), skipped.\n",
+                         len);
+            }
+        } break;
+        case GNUTLS_SAN_URI: {
+            ne_uri uri;
+            
+            name[len] = '\0';
+            
+            if (ne_uri_parse(name, &uri) == 0 && uri.host && uri.scheme) {
+                ne_uri tmp;
+                
+                if (identity && !found) *identity = ne_strdup(name);
+                found = 1;
+                
+                if (server) {
+                    /* For comparison purposes, all that matters is
+                     * host, scheme and port; ignore the rest. */
+                    memset(&tmp, 0, sizeof tmp);
+                    tmp.host = uri.host;
+                    tmp.scheme = uri.scheme;
+                    tmp.port = uri.port;
+                    
+                    match = ne_uri_cmp(server, &tmp) == 0;
+                }
+            }
+            
+            ne_uri_free(&uri);
+        } break;
+
+        default:
+            break;
+        }
+        seq++;
+    } while (!match && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);
+
+    /* Check against the commonName if no DNS alt. names were found,
+     * as per RFC3280. */
+    if (!found) {
+        seq = oid_find_highest_index(cert, 1, GNUTLS_OID_X520_COMMON_NAME);
+
+        if (seq >= 0) {
+            len = sizeof name;
+            name[0] = '\0';
+            ret = gnutls_x509_crt_get_dn_by_oid(cert, GNUTLS_OID_X520_COMMON_NAME,
+                                                seq, 0, name, &len);
+            if (ret == 0) {
+                if (identity) *identity = ne_strdup(name);
+                match = ne__ssl_match_hostname(name, len, hostname);
+            }
+        } else {
+            return -1;
+        }
+    }
+
+    if (*hostname)
+        NE_DEBUG(NE_DBG_SSL, "ssl: Identity match for '%s': %s\n", hostname, 
+                 match ? "good" : "bad");
+
+    return match ? 0 : 1;
+}
+
+/* Populate an ne_ssl_certificate structure from an X509 object.  Note
+ * that x5 is owned by returned cert object and must not be otherwise
+ * freed by the caller.  */
+static ne_ssl_certificate *populate_cert(ne_ssl_certificate *cert,
+                                         gnutls_x509_crt_t x5)
+{
+#ifdef HAVE_NEW_DN_API
+    gnutls_x509_crt_get_subject(x5, &cert->subj_dn.dn);
+    gnutls_x509_crt_get_issuer(x5, &cert->issuer_dn.dn);
+#else
+    cert->subj_dn.cert = x5;
+    cert->subj_dn.subject = 1;
+    cert->issuer_dn.cert = x5;
+    cert->issuer_dn.subject = 0;
+#endif
+    cert->issuer = NULL;
+    cert->subject = x5;
+    cert->identity = NULL;
+    check_identity(NULL, x5, &cert->identity);
+    return cert;
+}
+
+/* Returns a copy certificate of certificate SRC. */
+static gnutls_x509_crt_t x509_crt_copy(gnutls_x509_crt_t src)
+{
+    int ret;
+    size_t size = 0;
+    gnutls_datum_t tmp;
+    gnutls_x509_crt_t dest;
+    
+    if (gnutls_x509_crt_init(&dest) != 0) {
+        return NULL;
+    }
+
+    if (gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, NULL, &size) 
+        != GNUTLS_E_SHORT_MEMORY_BUFFER) {
+        gnutls_x509_crt_deinit(dest);
+        return NULL;
+    }
+
+    tmp.data = ne_malloc(size);
+    ret = gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, tmp.data, &size);
+    if (ret == 0) {
+        tmp.size = size;
+        ret = gnutls_x509_crt_import(dest, &tmp, GNUTLS_X509_FMT_DER);
+    }
+
+    if (ret) {
+        gnutls_x509_crt_deinit(dest);
+        dest = NULL;
+    }
+
+    ne_free(tmp.data);
+    return dest;
+}
+
+/* Duplicate a client certificate, which must be in the decrypted state. */
+static ne_ssl_client_cert *dup_client_cert(const ne_ssl_client_cert *cc)
+{
+    int ret;
+    ne_ssl_client_cert *newcc = ne_calloc(sizeof *newcc);
+
+    newcc->decrypted = 1;
+    
+    if (cc->keyless) {
+        newcc->keyless = 1;
+    }
+    else {
+        ret = gnutls_x509_privkey_init(&newcc->pkey);
+        if (ret != 0) goto dup_error;
+        
+        ret = gnutls_x509_privkey_cpy(newcc->pkey, cc->pkey);
+        if (ret != 0) goto dup_error;
+    }    
+
+    newcc->cert.subject = x509_crt_copy(cc->cert.subject);
+    if (!newcc->cert.subject) goto dup_error;
+
+    if (cc->friendly_name) newcc->friendly_name = ne_strdup(cc->friendly_name);
+
+    populate_cert(&newcc->cert, newcc->cert.subject);
+    return newcc;
+
+dup_error:
+    if (newcc->pkey) gnutls_x509_privkey_deinit(newcc->pkey);
+    if (newcc->cert.subject) gnutls_x509_crt_deinit(newcc->cert.subject);
+    ne_free(newcc);
+    return NULL;
+}    
+
+/* Callback invoked when the SSL server requests a client certificate.  */
+static int provide_client_cert(gnutls_session_t session,
+                               const gnutls_datum_t *req_ca_rdn, int nreqs,
+                               const gnutls_pk_algorithm_t *sign_algos,
+                               int sign_algos_length, gnutls_retr_st *st)
+{
+    ne_session *sess = gnutls_session_get_ptr(session);
+    
+    if (!sess) {
+        return GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Client cert provider callback; %d CA names.\n",
+             nreqs);
+
+    if (!sess->client_cert && sess->ssl_provide_fn) {
+#ifdef HAVE_NEW_DN_API
+        const ne_ssl_dname **dns;
+        ne_ssl_dname *dnarray;
+        unsigned dncount = 0;
+        int n;
+
+        dns = ne_malloc(nreqs * sizeof(ne_ssl_dname *));
+        dnarray = ne_calloc(nreqs * sizeof(ne_ssl_dname));
+
+        for (n = 0; n < nreqs; n++) {
+            gnutls_x509_dn_t dn;
+
+            if (gnutls_x509_dn_init(&dn) == 0) {
+                dnarray[n].dn = dn;
+                if (gnutls_x509_dn_import(dn, &req_ca_rdn[n]) == 0) {
+                    dns[dncount++] = &dnarray[n];
+                }
+                else {
+                    gnutls_x509_dn_deinit(dn);
+                }            
+            }
+        }
+       
+        NE_DEBUG(NE_DBG_SSL, "ssl: Mapped %d CA names to %u DN objects.\n",
+                 nreqs, dncount);
+
+        sess->ssl_provide_fn(sess->ssl_provide_ud, sess, dns, dncount);
+        
+        for (n = 0; n < nreqs; n++) {
+            if (dnarray[n].dn) {
+                gnutls_x509_dn_deinit(dnarray[n].dn);
+            }
+        }
+
+        ne_free(dns);
+        ne_free(dnarray);
+#else /* HAVE_NEW_DN_API */
+        /* Nothing to do here other than pretend no CA names were
+         * given, and hope the caller can cope. */
+        sess->ssl_provide_fn(sess->ssl_provide_ud, sess, NULL, 0);
+#endif
+    }
+
+    if (sess->client_cert) {
+        gnutls_certificate_type_t type = gnutls_certificate_type_get(session);
+        if (type == GNUTLS_CRT_X509
+#if LIBGNUTLS_VERSION_NUMBER > 0x030000
+            /* Ugly hack; prevent segfaults w/GnuTLS 3.0. */
+            && sess->client_cert->pkey != NULL
+#endif
+            ) {
+            NE_DEBUG(NE_DBG_SSL, "Supplying client certificate.\n");
+
+            st->type = type;
+            st->ncerts = 1;
+            st->cert.x509 = &sess->client_cert->cert.subject;
+            st->key.x509 = sess->client_cert->pkey;
+            
+            /* tell GNU TLS not to deallocate the certs. */
+            st->deinit_all = 0;
+        } else {
+            return GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE;
+        }
+    } 
+    else {
+        NE_DEBUG(NE_DBG_SSL, "No client certificate supplied.\n");
+        st->ncerts = 0;
+        sess->ssl_cc_requested = 1;
+        return 0;
+    }
+
+    return 0;
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc)
+{
+    sess->client_cert = dup_client_cert(cc);
+}
+
+ne_ssl_context *ne_ssl_context_create(int flags)
+{
+    ne_ssl_context *ctx = ne_calloc(sizeof *ctx);
+    gnutls_certificate_allocate_credentials(&ctx->cred);
+    if (flags == NE_SSL_CTX_CLIENT) {
+        gnutls_certificate_client_set_retrieve_function(ctx->cred,
+                                                        provide_client_cert);
+    }
+    gnutls_certificate_set_verify_flags(ctx->cred, 
+                                        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);
+    return ctx;
+}
+
+int ne_ssl_context_keypair(ne_ssl_context *ctx, 
+                           const char *cert, const char *key)
+{
+    gnutls_certificate_set_x509_key_file(ctx->cred, cert, key,
+                                         GNUTLS_X509_FMT_PEM);
+    return 0;
+}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, int required,
+                              const char *ca_names, const char *verify_cas)
+{
+    ctx->verify = required;
+    if (verify_cas) {
+        gnutls_certificate_set_x509_trust_file(ctx->cred, verify_cas,
+                                               GNUTLS_X509_FMT_PEM);
+    }
+    /* gnutls_certificate_send_x509_rdn_sequence in gnutls >= 1.2 can
+     * be used to *suppress* sending the CA names, but not control it,
+     * it seems. */
+    return 0;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value)
+{
+    /* SSLv2 not supported. */
+}
+
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag)
+{
+    return 0;
+}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx)
+{
+    gnutls_certificate_free_credentials(ctx->cred);
+    if (ctx->cache.client.data) {
+        ne_free(ctx->cache.client.data);
+    } else if (ctx->cache.server.key.data) {
+        gnutls_free(ctx->cache.server.key.data);
+        gnutls_free(ctx->cache.server.data.data);
+    }    
+    ne_free(ctx);
+}
+
+#if !defined(HAVE_GNUTLS_CERTIFICATE_GET_ISSUER) && defined(HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS)
+/* Return the issuer of the given certificate, or NULL if none can be
+ * found. */
+static gnutls_x509_crt_t find_issuer(gnutls_x509_crt_t *ca_list,
+                                   unsigned int num_cas,
+                                   gnutls_x509_crt_t cert)
+{
+    unsigned int n;
+
+    for (n = 0; n < num_cas; n++) {
+        if (gnutls_x509_crt_check_issuer(cert, ca_list[n]) == 1)
+            return ca_list[n];
+    }
+
+    return NULL;
+}
+#endif
+
+/* Return the certificate chain sent by the peer, or NULL on error. */
+static ne_ssl_certificate *make_peers_chain(gnutls_session_t sock,
+                                            gnutls_certificate_credentials_t crd)
+{
+    ne_ssl_certificate *current = NULL, *top = NULL;
+    const gnutls_datum_t *certs;
+    unsigned int n, count;
+    ne_ssl_certificate *cert;
+
+    certs = gnutls_certificate_get_peers(sock, &count);
+    if (!certs) {
+        return NULL;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Got %u certs in peer chain.\n", count);
+    
+    for (n = 0; n < count; n++) {
+        gnutls_x509_crt_t x5;
+
+        if (gnutls_x509_crt_init(&x5) ||
+            gnutls_x509_crt_import(x5, &certs[n], GNUTLS_X509_FMT_DER)) {
+            if (top) {
+                ne_ssl_cert_free(top);
+            }
+            return NULL;
+        }
+
+        cert = populate_cert(ne_calloc(sizeof *cert), x5);
+        
+        if (top == NULL) {
+            current = top = cert;
+        } else {
+            current->issuer = cert;
+            current = cert;
+        }
+    }
+
+#if defined(HAVE_GNUTLS_CERTIFICATE_GET_ISSUER) || defined(HAVE_GNUTLS_CERTIFICATE_GET_X509_CAS)
+    /* GnuTLS only returns the peers which were *sent* by the server
+     * in the Certificate list during the handshake.  Fill in the
+     * complete chain manually against the certs we trust: */
+    if (current->issuer == NULL) {
+        gnutls_x509_crt_t issuer;
+
+#ifndef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+        gnutls_x509_crt_t *ca_list;
+        unsigned int num_cas;
+        
+        gnutls_certificate_get_x509_cas(crd, &ca_list, &num_cas);
+#endif
+
+        do { 
+            /* Look up the issuer. */
+#ifndef HAVE_GNUTLS_CERTIFICATE_GET_ISSUER
+            issuer = find_issuer(ca_list, num_cas, current->subject);
+#else
+            if (gnutls_certificate_get_issuer(crd, current->subject, &issuer, 0))
+                issuer = NULL;
+#endif
+
+            if (issuer) {
+                issuer = x509_crt_copy(issuer);
+                if (issuer == NULL)
+                    break;
+
+                cert = populate_cert(ne_calloc(sizeof *cert), issuer);
+                /* Check that the issuer does not match the current
+                 * cert. */
+                if (ne_ssl_cert_cmp(current, cert)) {
+                    current = current->issuer = cert;
+                }
+                else {
+                    ne_ssl_cert_free(cert);
+                    issuer = NULL;
+                }
+            }
+        } while (issuer);
+    }
+#endif
+    
+    return top;
+}
+
+/* Map from GnuTLS verify failure mask *status to NE_SSL_* failure
+ * bitmask, which is returned.  *status is modified, removing all
+ * mapped bits. */
+static int map_verify_failures(unsigned int *status)
+{
+    static const struct {
+        gnutls_certificate_status_t from;
+        int to;
+    } map[] = {
+        { GNUTLS_CERT_REVOKED, NE_SSL_REVOKED },
+#if LIBGNUTLS_VERSION_NUMBER >= 0x020800
+        { GNUTLS_CERT_NOT_ACTIVATED, NE_SSL_NOTYETVALID },
+        { GNUTLS_CERT_EXPIRED, NE_SSL_EXPIRED },
+#endif
+        { GNUTLS_CERT_INVALID|GNUTLS_CERT_SIGNER_NOT_FOUND, NE_SSL_UNTRUSTED },
+        { GNUTLS_CERT_INVALID|GNUTLS_CERT_SIGNER_NOT_CA, NE_SSL_UNTRUSTED }
+    };
+    size_t n;
+    int ret = 0;
+
+    for (n = 0; n < sizeof(map)/sizeof(map[0]); n++) {
+        if ((*status & map[n].from) == map[n].from) {
+            *status &= ~map[n].from;
+            ret |= map[n].to;
+        }
+    }
+
+    return ret;
+}
+
+/* Return a malloc-allocated human-readable error string describing
+ * GnuTLS verification error bitmask 'status'; return value must be
+ * freed by the caller. */
+static char *verify_error_string(unsigned int status)
+{
+    ne_buffer *buf = ne_buffer_create();
+
+    /* sorry, i18n-ers */
+    if (status & GNUTLS_CERT_INSECURE_ALGORITHM) {
+        ne_buffer_zappend(buf, _("signed using insecure algorithm"));
+    }
+    else {
+        ne_buffer_snprintf(buf, 64, _("unrecognized errors (%u)"),
+                           status);
+    }
+    
+    return ne_buffer_finish(buf);
+}
+
+/* Return NE_SSL_* failure bits after checking chain expiry. */
+static int check_chain_expiry(ne_ssl_certificate *chain)
+{
+    time_t before, after, now = time(NULL);
+    ne_ssl_certificate *cert;
+    int failures = 0;
+    
+    /* Check that all certs within the chain are inside their defined
+     * validity period.  Note that the errors flagged for the server
+     * cert are different from the generic error for issues higher up
+     * the chain. */
+    for (cert = chain; cert; cert = cert->issuer) {
+        before = gnutls_x509_crt_get_activation_time(cert->subject);
+        after = gnutls_x509_crt_get_expiration_time(cert->subject);
+        
+        if (now < before)
+            failures |= (cert == chain) ? NE_SSL_NOTYETVALID : NE_SSL_BADCHAIN;
+        else if (now > after)
+            failures |= (cert == chain) ? NE_SSL_EXPIRED : NE_SSL_BADCHAIN;
+    }
+
+    return failures;
+}
+
+/* Verifies an SSL server certificate. */
+static int check_certificate(ne_session *sess, gnutls_session_t sock,
+                             ne_ssl_certificate *chain)
+{
+    int ret, failures = 0;
+    ne_uri server;
+    unsigned int status;
+
+    memset(&server, 0, sizeof server);
+    ne_fill_server_uri(sess, &server);
+    ret = check_identity(&server, chain->subject, NULL);
+    ne_uri_free(&server);
+
+    if (ret < 0) {
+        ne_set_error(sess, _("Server certificate was missing commonName "
+                             "attribute in subject name"));
+        return NE_ERROR;
+    } 
+    else if (ret > 0) {
+        failures |= NE_SSL_IDMISMATCH;
+    }
+    
+    failures |= check_chain_expiry(chain);
+
+    ret = gnutls_certificate_verify_peers2(sock, &status);
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify peers returned %d, status=%u\n", 
+             ret, status);
+    if (ret != GNUTLS_E_SUCCESS) {
+        ne_set_error(sess, _("Could not verify server certificate: %s"),
+                     gnutls_strerror(ret));
+        return NE_ERROR;
+    }
+
+    failures |= map_verify_failures(&status);
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verification failures = %d (status = %u).\n", 
+             failures, status);
+    
+    if (status && status != GNUTLS_CERT_INVALID) {
+        char *errstr = verify_error_string(status);
+        ne_set_error(sess, _("Certificate verification error: %s"), errstr);
+        ne_free(errstr);       
+        return NE_ERROR;
+    }
+
+    if (failures == 0) {
+        ret = NE_OK;
+    } else {
+        ne__ssl_set_verify_err(sess, failures);
+        ret = NE_ERROR;
+        if (sess->ssl_verify_fn
+            && sess->ssl_verify_fn(sess->ssl_verify_ud, failures, chain) == 0)
+            ret = NE_OK;
+    }
+
+    return ret;
+}
+
+/* Negotiate an SSL connection. */
+int ne__negotiate_ssl(ne_session *sess)
+{
+    ne_ssl_context *const ctx = sess->ssl_context;
+    ne_ssl_certificate *chain;
+    gnutls_session_t sock;
+
+    NE_DEBUG(NE_DBG_SSL, "Negotiating SSL connection.\n");
+
+    /* Pass through the hostname if SNI is enabled. */
+    ctx->hostname = 
+        sess->flags[NE_SESSFLAG_TLS_SNI] ? sess->server.hostname : NULL;
+
+    if (ne_sock_connect_ssl(sess->socket, ctx, sess)) {
+        if (sess->ssl_cc_requested) {
+            ne_set_error(sess, _("SSL handshake failed, "
+                                 "client certificate was requested: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        else {
+            ne_set_error(sess, _("SSL handshake failed: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        return NE_ERROR;
+    }
+
+    sock = ne__sock_sslsock(sess->socket);
+
+    chain = make_peers_chain(sock, ctx->cred);
+    if (chain == NULL) {
+        ne_set_error(sess, _("Server did not send certificate chain"));
+        return NE_ERROR;
+    }
+
+    if (sess->server_cert && ne_ssl_cert_cmp(sess->server_cert, chain) == 0) {
+        /* Same cert as last time; presume OK.  This is not optimal as
+         * make_peers_chain() has already gone through and done the
+         * expensive DER parsing stuff for the whole chain by now. */
+        ne_ssl_cert_free(chain);
+        return NE_OK;
+    }
+
+    if (check_certificate(sess, sock, chain)) {
+        ne_ssl_cert_free(chain);
+        return NE_ERROR;
+    }
+
+    sess->server_cert = chain;
+
+    return NE_OK;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return &cert->issuer_dn;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return &cert->subj_dn;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{
+    return cert->issuer;
+}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return cert->identity;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{
+    gnutls_x509_crt_t certs = cert->subject;
+    gnutls_certificate_set_x509_trust(ctx->cred, &certs, 1);
+}
+
+void ne_ssl_trust_default_ca(ne_session *sess)
+{
+#ifdef NE_SSL_CA_BUNDLE
+    gnutls_certificate_set_x509_trust_file(sess->ssl_context->cred,
+                                           NE_SSL_CA_BUNDLE,
+                                           GNUTLS_X509_FMT_PEM);
+#endif
+}
+
+/* Read the contents of file FILENAME into *DATUM. */
+static int read_to_datum(const char *filename, gnutls_datum_t *datum)
+{
+    FILE *f = fopen(filename, "r");
+    ne_buffer *buf;
+    char tmp[4192];
+    size_t len;
+
+    if (!f) {
+        return -1;
+    }
+
+    buf = ne_buffer_ncreate(8192);
+    while ((len = fread(tmp, 1, sizeof tmp, f)) > 0) {
+        ne_buffer_append(buf, tmp, len);
+    }
+
+    if (!feof(f)) {
+        fclose(f);
+        ne_buffer_destroy(buf);
+        return -1;
+    }
+    
+    fclose(f);
+
+    datum->size = ne_buffer_size(buf);
+    datum->data = (unsigned char *)ne_buffer_finish(buf);
+    return 0;
+}
+
+/* Parses a PKCS#12 structure and loads the certificate, private key
+ * and friendly name if possible.  Returns zero on success, non-zero
+ * on error. */
+static int pkcs12_parse(gnutls_pkcs12_t p12, gnutls_x509_privkey_t *pkey,
+                        gnutls_x509_crt_t *x5, char **friendly_name,
+                        const char *password)
+{
+    gnutls_pkcs12_bag_t bag = NULL;
+    int i, j, ret = 0;
+
+    for (i = 0; ret == 0; ++i) {
+        if (bag) gnutls_pkcs12_bag_deinit(bag);
+
+        ret = gnutls_pkcs12_bag_init(&bag);
+        if (ret < 0) continue;
+
+        ret = gnutls_pkcs12_get_bag(p12, i, bag);
+        if (ret < 0) continue;
+
+        gnutls_pkcs12_bag_decrypt(bag, password);
+
+        for (j = 0; ret == 0 && j < gnutls_pkcs12_bag_get_count(bag); ++j) {
+            gnutls_pkcs12_bag_type_t type;
+            gnutls_datum_t data;
+
+            if (friendly_name && *friendly_name == NULL) {
+                char *name = NULL;
+                gnutls_pkcs12_bag_get_friendly_name(bag, j, &name);
+                if (name) {
+                    if (name[0] == '.') name++; /* weird GnuTLS bug? */
+                    *friendly_name = ne_strdup(name);
+                }
+            }
+
+            type = gnutls_pkcs12_bag_get_type(bag, j);
+            switch (type) {
+            case GNUTLS_BAG_PKCS8_KEY:
+            case GNUTLS_BAG_PKCS8_ENCRYPTED_KEY:
+                /* Ignore any but the first key encountered; really
+                 * need to match up keyids. */
+                if (*pkey) break;
+
+                gnutls_x509_privkey_init(pkey);
+
+                ret = gnutls_pkcs12_bag_get_data(bag, j, &data);
+                if (ret < 0) continue;
+
+                ret = gnutls_x509_privkey_import_pkcs8(*pkey, &data,
+                                                       GNUTLS_X509_FMT_DER,
+                                                       password,
+                                                       0);
+                if (ret < 0) continue;
+                break;
+            case GNUTLS_BAG_CERTIFICATE:
+                /* Ignore any but the first cert encountered; again,
+                 * really need to match up keyids. */
+                if (*x5) break;
+
+                ret = gnutls_x509_crt_init(x5);
+                if (ret < 0) continue;
+
+                ret = gnutls_pkcs12_bag_get_data(bag, j, &data);
+                if (ret < 0) continue;
+
+                ret = gnutls_x509_crt_import(*x5, &data, GNUTLS_X509_FMT_DER);
+                if (ret < 0) continue;
+
+                break;
+            default:
+                break;
+            }
+        }
+    }
+
+    /* Make sure last bag is freed */
+    if (bag) gnutls_pkcs12_bag_deinit(bag);
+
+    /* Free in case of error */
+    if (ret < 0 && ret != GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {
+        if (*x5) gnutls_x509_crt_deinit(*x5);
+        if (*pkey) gnutls_x509_privkey_deinit(*pkey);
+        if (friendly_name && *friendly_name) ne_free(*friendly_name);
+    }
+
+    if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) ret = 0;
+    return ret;
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    gnutls_datum_t datum;
+    ne_ssl_client_cert *cc;
+
+    if (read_to_datum(filename, &datum))
+        return NULL;
+
+    cc = ne_ssl_clicert_import(datum.data, datum.size);
+
+    ne_free(datum.data);
+
+    return cc;
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, size_t buflen)
+{
+    int ret;
+    gnutls_datum_t data;
+    gnutls_pkcs12_t p12;
+    ne_ssl_client_cert *cc;
+    char *friendly_name = NULL;
+    gnutls_x509_crt_t cert = NULL;
+    gnutls_x509_privkey_t pkey = NULL;
+
+    data.data = buffer;
+    data.size = buflen;
+
+    if (gnutls_pkcs12_init(&p12) != 0) {
+        return NULL;
+    }
+
+    ret = gnutls_pkcs12_import(p12, &data, GNUTLS_X509_FMT_DER, 0);
+    if (ret < 0) {
+        gnutls_pkcs12_deinit(p12);
+        return NULL;
+    }
+
+    if (gnutls_pkcs12_verify_mac(p12, "") == 0) {
+        if (pkcs12_parse(p12, &pkey, &cert, &friendly_name, "") != 0
+            || !cert || !pkey) {
+            gnutls_pkcs12_deinit(p12);
+            return NULL;
+        }
+
+        cc = ne_calloc(sizeof *cc);
+        cc->pkey = pkey;
+        cc->decrypted = 1;
+        cc->friendly_name = friendly_name;
+        populate_cert(&cc->cert, cert);
+        gnutls_pkcs12_deinit(p12);
+        cc->p12 = NULL;
+        return cc;
+    } else {
+        /* TODO: calling pkcs12_parse() here to find the friendly_name
+         * seems to break horribly.  */
+        cc = ne_calloc(sizeof *cc);
+        cc->p12 = p12;
+        return cc;
+    }
+}
+
+ne_ssl_client_cert *ne__ssl_clicert_exkey_import(const unsigned char *der,
+                                                 size_t der_len)
+{
+    ne_ssl_client_cert *cc;
+    gnutls_x509_crt_t x5;
+    gnutls_datum_t datum;
+
+    datum.data = (unsigned char *)der;
+    datum.size = der_len;    
+
+    if (gnutls_x509_crt_init(&x5) 
+        || gnutls_x509_crt_import(x5, &datum, GNUTLS_X509_FMT_DER)) {
+        NE_DEBUG(NE_DBG_SSL, "ssl: crt_import failed.\n");
+        return NULL;
+    }
+    
+    cc = ne_calloc(sizeof *cc);
+    cc->keyless = 1;
+    cc->decrypted = 1;
+    populate_cert(&cc->cert, x5);
+
+    return cc;    
+}
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *cc)
+{
+    return !cc->decrypted;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *cc, const char *password)
+{
+    int ret;
+    gnutls_x509_crt_t cert = NULL;
+    gnutls_x509_privkey_t pkey = NULL;
+
+    if (gnutls_pkcs12_verify_mac(cc->p12, password) != 0) {
+        return -1;
+    }        
+
+    ret = pkcs12_parse(cc->p12, &pkey, &cert, NULL, password);
+    if (ret < 0)
+        return ret;
+    
+    if (!cert || (!pkey && !cc->keyless)) {
+        if (cert) gnutls_x509_crt_deinit(cert);
+        if (pkey) gnutls_x509_privkey_deinit(pkey);
+        return -1;
+    }
+
+    gnutls_pkcs12_deinit(cc->p12);
+    populate_cert(&cc->cert, cert);
+    cc->pkey = pkey;
+    cc->decrypted = 1;
+    cc->p12 = NULL;
+    return 0;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *cc)
+{
+    return &cc->cert;
+}
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return ccert->friendly_name;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    int ret;
+    gnutls_datum_t data;
+    gnutls_x509_crt_t x5;
+
+    if (read_to_datum(filename, &data))
+        return NULL;
+
+    if (gnutls_x509_crt_init(&x5) != 0)
+        return NULL;
+
+    ret = gnutls_x509_crt_import(x5, &data, GNUTLS_X509_FMT_PEM);
+    ne_free(data.data);
+    if (ret < 0) {
+        gnutls_x509_crt_deinit(x5);
+        return NULL;
+    }
+    
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    unsigned char buffer[10*1024];
+    size_t len = sizeof buffer;
+
+    FILE *fp = fopen(filename, "w");
+
+    if (fp == NULL) return -1;
+
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_PEM, buffer,
+                               &len) < 0) {
+        fclose(fp);
+        return -1;
+    }
+
+    if (fwrite(buffer, len, 1, fp) != 1) {
+        fclose(fp);
+        return -1;
+    }
+
+    if (fclose(fp) != 0)
+        return -1;
+
+    return 0;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert)
+{
+    gnutls_x509_crt_deinit(cert->subject);
+    if (cert->identity) ne_free(cert->identity);
+    if (cert->issuer) ne_ssl_cert_free(cert->issuer);
+    ne_free(cert);
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    char digest1[NE_SSL_DIGESTLEN], digest2[NE_SSL_DIGESTLEN];
+
+    if (ne_ssl_cert_digest(c1, digest1) || ne_ssl_cert_digest(c2, digest2)) {
+        return -1;
+    }
+
+    return strcmp(digest1, digest2);
+}
+
+/* The certificate import/export format is the base64 encoding of the
+ * raw DER; PEM without the newlines and wrapping. */
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    int ret;
+    size_t len;
+    unsigned char *der;
+    gnutls_datum_t buffer = { NULL, 0 };
+    gnutls_x509_crt_t x5;
+
+    if (gnutls_x509_crt_init(&x5) != 0)
+        return NULL;
+
+    /* decode the base64 to get the raw DER representation */
+    len = ne_unbase64(data, &der);
+    if (len == 0) return NULL;
+
+    buffer.data = der;
+    buffer.size = len;
+
+    ret = gnutls_x509_crt_import(x5, &buffer, GNUTLS_X509_FMT_DER);
+    ne_free(der);
+
+    if (ret < 0) {
+        gnutls_x509_crt_deinit(x5);
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    unsigned char *der;
+    size_t len = 0;
+    char *ret;
+
+    /* find the length of the DER encoding. */
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_DER, NULL, &len) != 
+        GNUTLS_E_SHORT_MEMORY_BUFFER) {
+        return NULL;
+    }
+    
+    der = ne_malloc(len);
+    if (gnutls_x509_crt_export(cert->subject, GNUTLS_X509_FMT_DER, der, &len)) {
+        ne_free(der);
+        return NULL;
+    }
+    
+    ret = ne_base64(der, len);
+    ne_free(der);
+    return ret;
+}
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest)
+{
+    char sha1[20], *p;
+    int j;
+    size_t len = sizeof sha1;
+
+    if (gnutls_x509_crt_get_fingerprint(cert->subject, GNUTLS_DIG_SHA,
+                                        sha1, &len) < 0)
+        return -1;
+
+    for (j = 0, p = digest; j < 20; j++) {
+        *p++ = NE_HEX2ASC((sha1[j] >> 4) & 0x0f);
+        *p++ = NE_HEX2ASC(sha1[j] & 0x0f);
+        *p++ = ':';
+    }
+
+    *--p = '\0';
+    return 0;
+}
+
+int ne__ssl_init(void)
+{
+#if LIBGNUTLS_VERSION_NUMBER < 0x020b01
+#ifdef NE_HAVE_TS_SSL
+    gcry_control(GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);
+#endif
+    gcry_control(GCRYCTL_ENABLE_QUICK_RANDOM, 0);
+#endif
+    return gnutls_global_init();
+}
+
+void ne__ssl_exit(void)
+{
+    /* No way to unregister the thread callbacks.  Doomed. */
+#if LIBGNUTLS_VERSION_MAJOR > 1 || LIBGNUTLS_VERSION_MINOR > 3 \
+    || (LIBGNUTLS_VERSION_MINOR == 3 && LIBGNUTLS_VERSION_PATCH >= 3)
+    /* It's safe to call gnutls_global_deinit() here only with
+     * gnutls >= 1.3., since older versions don't refcount and
+     * doing so would prevent any other use of gnutls within
+     * the process. */
+    gnutls_global_deinit();
+#endif
+}
diff --git a/net/mmt/neon/src/ne_i18n.c b/net/mmt/neon/src/ne_i18n.c
new file mode 100644
index 0000000..0fb4a3b
--- /dev/null
+++ b/net/mmt/neon/src/ne_i18n.c
@@ -0,0 +1,47 @@
+/* 
+   Internationalization of neon
+   Copyright (C) 1999-2005, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include "ne_i18n.h"
+
+#ifdef HAVE_LIBINTL_H
+#include <libintl.h>
+#endif
+
+void ne_i18n_init(const char *encoding)
+{
+#if defined(NE_HAVE_I18N) && defined(NEON_IS_LIBRARY)
+    /* The bindtextdomain call is only enabled if neon is built as a
+     * library rather than as a bundled source; it would be possible
+     * in the future to allow it for bundled builds too, if the neon
+     * message catalogs could be installed alongside the app's own
+     * message catalogs. */
+    bindtextdomain("neon", LOCALEDIR);
+
+#ifdef HAVE_BIND_TEXTDOMAIN_CODESET
+    if (encoding) {
+        bind_textdomain_codeset("neon", encoding);
+    }
+#endif /* HAVE_BIND_TEXTDOMAIN_CODESET */
+
+#endif
+}
diff --git a/net/mmt/neon/src/ne_i18n.h b/net/mmt/neon/src/ne_i18n.h
new file mode 100644
index 0000000..b6dd219
--- /dev/null
+++ b/net/mmt/neon/src/ne_i18n.h
@@ -0,0 +1,55 @@
+/* 
+   Internationalization of neon
+   Copyright (C) 2005-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_I18N_H
+#define NE_I18N_H
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Initialize translated error messages within neon.  If 'encoding' is
+ * non-NULL, it specifies the character encoding for the generated
+ * translated strings.  If it is NULL, the appropriate character
+ * encoding for the locale will be used.
+ *
+ * This call is only strictly necessary if either:
+ *
+ * a) neon has been installed into a different prefix than the
+ * gettext() implementation on which it depends for i18n purposes, or
+ *
+ * b) the caller requires that translated messages are in a particular
+ * character encoding.
+ *
+ * If ne_i18n_init() is never called, the message catalogs will not be
+ * found if case (a) applies (and so English error messages will be
+ * used), and will use the default character encoding specified by the
+ * process locale.  The library will otherwise operate correctly.
+ *
+ * Note that the encoding used is a process-global setting and so
+ * results may be unexpected if other users of neon within the process
+ * call ne_i18n_init() with a different encoding parameter.
+ */
+void ne_i18n_init(const char *encoding);
+
+NE_END_DECLS
+
+#endif /* NE_I18N_H */
diff --git a/net/mmt/neon/src/ne_internal.h b/net/mmt/neon/src/ne_internal.h
new file mode 100644
index 0000000..c9c6eff
--- /dev/null
+++ b/net/mmt/neon/src/ne_internal.h
@@ -0,0 +1,86 @@
+/* 
+   Global interfaces private to neon.
+   Copyright (C) 2005-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* NOTE WELL: The interfaces defined in this file are internal to neon
+ * and MUST NOT be used by neon-based applications. */
+
+#ifndef NE_INTERNAL_H
+#define NE_INTERNAL_H 1
+
+#include "config.h"
+
+#ifdef HAVE_SYS_LIMITS_H
+#include <sys/limits.h>
+#endif
+#ifdef HAVE_LIMITS_H
+#include <limits.h> /* for UINT_MAX etc */
+#endif
+
+#include "ne_defs.h"
+
+#undef _
+#ifdef NE_HAVE_I18N
+#include <libintl.h>
+#define _(str) dgettext(PACKAGE_NAME, str)
+#else
+#define _(str) (str)
+#endif /* NE_ENABLE_NLS */
+#define N_(str) (str)
+
+#if !defined(LONG_LONG_MAX) && defined(LLONG_MAX)
+#define LONG_LONG_MAX LLONG_MAX
+#elif !defined(LONG_LONG_MAX) && defined(LONGLONG_MAX)
+#define LONG_LONG_MAX LONGLONG_MAX
+#endif
+
+#if defined(NE_LFS)
+
+#define ne_lseek lseek64
+#define FMT_NE_OFF_T NE_FMT_OFF64_T
+#define NE_OFFT_MAX LONG_LONG_MAX
+#ifdef HAVE_STRTOLL
+#define ne_strtoff strtoll
+#else
+#define ne_strtoff strtoq
+#endif
+
+#else /* !NE_LFS */
+
+#define ne_lseek lseek
+#define FMT_NE_OFF_T NE_FMT_OFF_T
+
+#if defined(SIZEOF_LONG_LONG) && defined(LONG_LONG_MAX) \
+    && SIZEOF_OFF_T == SIZEOF_LONG_LONG
+#define NE_OFFT_MAX LONG_LONG_MAX
+#else
+#define NE_OFFT_MAX LONG_MAX
+#endif
+
+#if SIZEOF_OFF_T > SIZEOF_LONG && defined(HAVE_STRTOLL)
+#define ne_strtoff strtoll
+#elif SIZEOF_OFF_T > SIZEOF_LONG && defined(HAVE_STRTOQ)
+#define ne_strtoff strtoq
+#else
+#define ne_strtoff strtol
+#endif
+#endif /* NE_LFS */
+
+#endif /* NE_INTERNAL_H */
diff --git a/net/mmt/neon/src/ne_locks.c b/net/mmt/neon/src/ne_locks.c
new file mode 100644
index 0000000..fbe390c
--- /dev/null
+++ b/net/mmt/neon/src/ne_locks.c
@@ -0,0 +1,816 @@
+/* 
+   WebDAV Class 2 locking operations
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#endif
+
+#include <ctype.h> /* for isdigit() */
+
+#include "ne_alloc.h"
+
+#include "ne_request.h"
+#include "ne_xml.h"
+#include "ne_locks.h"
+#include "ne_uri.h"
+#include "ne_basic.h"
+#include "ne_props.h"
+#include "ne_207.h"
+#include "ne_internal.h"
+#include "ne_xmlreq.h"
+
+#define HOOK_ID "http://webdav.org/neon/hooks/webdav-locking"
+
+/* A list of lock objects. */
+struct lock_list {
+    struct ne_lock *lock;
+    struct lock_list *next, *prev;
+};
+
+struct ne_lock_store_s {
+    struct lock_list *locks;
+    struct lock_list *cursor; /* current position in 'locks' */
+};
+
+struct lh_req_cookie {
+    const ne_lock_store *store;
+    struct lock_list *submit;
+};
+
+/* Context for PROPFIND/lockdiscovery callbacks */
+struct discover_ctx {
+    ne_propfind_handler *phandler;
+    ne_lock_result results;
+    void *userdata;
+    ne_buffer *cdata;
+};
+
+/* Context for handling LOCK response */
+struct lock_ctx {
+    struct ne_lock active; /* activelock */
+    ne_request *req; /* the request in question */
+    ne_xml_parser *parser;
+    char *token; /* the token we're after. */
+    int found;
+    ne_buffer *cdata;
+};
+
+/* use the "application" state space. */
+#define ELM_LOCK_FIRST (NE_PROPS_STATE_TOP + 66)
+
+#define ELM_lockdiscovery (ELM_LOCK_FIRST)
+#define ELM_activelock (ELM_LOCK_FIRST + 1)
+#define ELM_lockscope (ELM_LOCK_FIRST + 2)
+#define ELM_locktype (ELM_LOCK_FIRST + 3)
+#define ELM_depth (ELM_LOCK_FIRST + 4)
+#define ELM_owner (ELM_LOCK_FIRST + 5)
+#define ELM_timeout (ELM_LOCK_FIRST + 6)
+#define ELM_locktoken (ELM_LOCK_FIRST + 7)
+#define ELM_lockinfo (ELM_LOCK_FIRST + 8)
+#define ELM_write (ELM_LOCK_FIRST + 9)
+#define ELM_exclusive (ELM_LOCK_FIRST + 10)
+#define ELM_shared (ELM_LOCK_FIRST + 11)
+#define ELM_href (ELM_LOCK_FIRST + 12)
+#define ELM_prop (NE_207_STATE_PROP)
+
+static const struct ne_xml_idmap element_map[] = {
+#define ELM(x) { "DAV:", #x, ELM_ ## x }
+    ELM(lockdiscovery), ELM(activelock), ELM(prop), ELM(lockscope),
+    ELM(locktype), ELM(depth), ELM(owner), ELM(timeout), ELM(locktoken),
+    ELM(lockinfo), ELM(lockscope), ELM(locktype), ELM(write), ELM(exclusive),
+    ELM(shared), ELM(href)
+    /* no "lockentry" */
+#undef ELM
+};
+
+static const ne_propname lock_props[] = {
+    { "DAV:", "lockdiscovery" },
+    { NULL }
+};
+
+/* this simply registers the accessor for the function. */
+static void lk_create(ne_request *req, void *session, 
+		       const char *method, const char *uri)
+{
+    struct lh_req_cookie *lrc = ne_malloc(sizeof *lrc);
+    lrc->store = session;
+    lrc->submit = NULL;
+    ne_set_request_private(req, HOOK_ID, lrc);
+}
+
+static void lk_pre_send(ne_request *r, void *userdata, ne_buffer *req)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(r, HOOK_ID);
+
+    if (lrc->submit != NULL) {
+	struct lock_list *item;
+
+	/* Add in the If header */
+	ne_buffer_czappend(req, "If:");
+	for (item = lrc->submit; item != NULL; item = item->next) {
+	    char *uri = ne_uri_unparse(&item->lock->uri);
+	    ne_buffer_concat(req, " <", uri, "> (<",
+			     item->lock->token, ">)", NULL);
+	    ne_free(uri);
+	}
+	ne_buffer_czappend(req, "\r\n");
+    }
+}
+
+/* Insert 'lock' into lock list *list. */
+static void insert_lock(struct lock_list **list, struct ne_lock *lock)
+{
+    struct lock_list *item = ne_malloc(sizeof *item);
+    if (*list != NULL) {
+	(*list)->prev = item;
+    }
+    item->prev = NULL;
+    item->next = *list;
+    item->lock = lock;
+    *list = item;
+}
+
+static void free_list(struct lock_list *list, int destroy)
+{
+    struct lock_list *next;
+
+    while (list != NULL) {
+	next = list->next;
+	if (destroy)
+	    ne_lock_destroy(list->lock);
+	ne_free(list);
+	list = next;
+    }
+}
+
+static void lk_destroy(ne_request *req, void *userdata)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    free_list(lrc->submit, 0);
+    ne_free(lrc);
+}
+
+void ne_lockstore_destroy(ne_lock_store *store)
+{
+    free_list(store->locks, 1);
+    ne_free(store);
+}
+
+ne_lock_store *ne_lockstore_create(void)
+{
+    return ne_calloc(sizeof(ne_lock_store));
+}
+
+#define CURSOR_RET(s) ((s)->cursor?(s)->cursor->lock:NULL)
+
+struct ne_lock *ne_lockstore_first(ne_lock_store *store)
+{
+    store->cursor = store->locks;
+    return CURSOR_RET(store);
+}
+
+struct ne_lock *ne_lockstore_next(ne_lock_store *store)
+{
+    store->cursor = store->cursor->next;
+    return CURSOR_RET(store);
+}
+
+void ne_lockstore_register(ne_lock_store *store, ne_session *sess)
+{
+    /* Register the hooks */
+    ne_hook_create_request(sess, lk_create, store);
+    ne_hook_pre_send(sess, lk_pre_send, store);
+    ne_hook_destroy_request(sess, lk_destroy, store);
+}
+
+/* Submit the given lock for the given URI */
+static void submit_lock(struct lh_req_cookie *lrc, struct ne_lock *lock)
+{
+    struct lock_list *item;
+
+    /* Check for dups */
+    for (item = lrc->submit; item != NULL; item = item->next) {
+	if (ne_strcasecmp(item->lock->token, lock->token) == 0)
+	    return;
+    }
+
+    insert_lock(&lrc->submit, lock);
+}
+
+struct ne_lock *ne_lockstore_findbyuri(ne_lock_store *store,
+				       const ne_uri *uri)
+{
+    struct lock_list *cur;
+
+    for (cur = store->locks; cur != NULL; cur = cur->next) {
+	if (ne_uri_cmp(&cur->lock->uri, uri) == 0) {
+	    return cur->lock;
+	}
+    }
+
+    return NULL;
+}
+
+void ne_lock_using_parent(ne_request *req, const char *path)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    ne_uri u = {0};
+    struct lock_list *item;
+    char *parent;
+
+    if (lrc == NULL)
+	return;
+    
+    parent = ne_path_parent(path);
+    if (parent == NULL)
+	return;
+    
+    ne_fill_server_uri(ne_get_session(req), &u);
+
+    for (item = lrc->store->locks; item != NULL; item = item->next) {
+
+	/* Only care about locks which are on this server. */
+	u.path = item->lock->uri.path;
+	if (ne_uri_cmp(&u, &item->lock->uri))
+	    continue;
+	
+	/* This lock is needed if it is an infinite depth lock which
+	 * covers the parent, or a lock on the parent itself. */
+	if ((item->lock->depth == NE_DEPTH_INFINITE && 
+	     ne_path_childof(item->lock->uri.path, parent)) ||
+	    ne_path_compare(item->lock->uri.path, parent) == 0) {
+	    NE_DEBUG(NE_DBG_LOCKS, "Locked parent, %s on %s\n",
+		     item->lock->token, item->lock->uri.path);
+	    submit_lock(lrc, item->lock);
+	}
+    }
+
+    u.path = parent; /* handy: makes u.path valid and ne_free(parent). */
+    ne_uri_free(&u);
+}
+
+void ne_lock_using_resource(ne_request *req, const char *uri, int depth)
+{
+    struct lh_req_cookie *lrc = ne_get_request_private(req, HOOK_ID);
+    struct lock_list *item;
+    int match;
+
+    if (lrc == NULL)
+	return;	
+
+    /* Iterate over the list of stored locks to see if any of them
+     * apply to this resource */
+    for (item = lrc->store->locks; item != NULL; item = item->next) {
+	
+	match = 0;
+	
+	if (depth == NE_DEPTH_INFINITE &&
+	    ne_path_childof(uri, item->lock->uri.path)) {
+	    /* Case 1: this is a depth-infinity request which will 
+	     * modify a lock somewhere inside the collection. */
+	    NE_DEBUG(NE_DBG_LOCKS, "Has child: %s\n", item->lock->token);
+	    match = 1;
+	} 
+	else if (ne_path_compare(uri, item->lock->uri.path) == 0) {
+	    /* Case 2: this request is directly on a locked resource */
+	    NE_DEBUG(NE_DBG_LOCKS, "Has direct lock: %s\n", item->lock->token);
+	    match = 1;
+	}
+	else if (item->lock->depth == NE_DEPTH_INFINITE && 
+		 ne_path_childof(item->lock->uri.path, uri)) {
+	    /* Case 3: there is a higher-up infinite-depth lock which
+	     * covers the resource that this request will modify. */
+	    NE_DEBUG(NE_DBG_LOCKS, "Is child of: %s\n", item->lock->token);
+	    match = 1;
+	}
+	
+	if (match) {
+	    submit_lock(lrc, item->lock);
+	}
+    }
+
+}
+
+void ne_lockstore_add(ne_lock_store *store, struct ne_lock *lock)
+{
+    insert_lock(&store->locks, lock);
+}
+
+void ne_lockstore_remove(ne_lock_store *store, struct ne_lock *lock)
+{
+    struct lock_list *item;
+
+    /* Find the lock */
+    for (item = store->locks; item != NULL; item = item->next)
+	if (item->lock == lock)
+	    break;
+    
+    if (item->prev != NULL) {
+	item->prev->next = item->next;
+    } else {
+	store->locks = item->next;
+    }
+    if (item->next != NULL) {
+	item->next->prev = item->prev;
+    }
+    ne_free(item);
+}
+
+struct ne_lock *ne_lock_copy(const struct ne_lock *lock)
+{
+    struct ne_lock *ret = ne_calloc(sizeof *ret);
+
+    ne_uri_copy(&ret->uri, &lock->uri);
+    ret->token = ne_strdup(lock->token);
+    ret->depth = lock->depth;
+    ret->type = lock->type;
+    ret->scope = lock->scope;
+    if (lock->owner) ret->owner = ne_strdup(lock->owner);
+    ret->timeout = lock->timeout;
+
+    return ret;
+}
+
+struct ne_lock *ne_lock_create(void)
+{
+    struct ne_lock *lock = ne_calloc(sizeof *lock);
+    lock->depth = NE_DEPTH_ZERO;
+    lock->type = ne_locktype_write;
+    lock->scope = ne_lockscope_exclusive;
+    lock->timeout = NE_TIMEOUT_INVALID;
+    return lock;
+}
+
+void ne_lock_free(struct ne_lock *lock)
+{
+    ne_uri_free(&lock->uri);
+    if (lock->owner) {
+        ne_free(lock->owner);
+        lock->owner = NULL;
+    }
+    if (lock->token) {
+        ne_free(lock->token);
+        lock->token = NULL;
+    }
+}
+
+void ne_lock_destroy(struct ne_lock *lock)
+{
+    ne_lock_free(lock);
+    ne_free(lock);
+}
+
+int ne_unlock(ne_session *sess, const struct ne_lock *lock)
+{
+    ne_request *req = ne_request_create(sess, "UNLOCK", lock->uri.path);
+    int ret;
+    
+    ne_print_request_header(req, "Lock-Token", "<%s>", lock->token);
+    
+    /* UNLOCK of a lock-null resource removes the resource from the
+     * parent collection; so an UNLOCK may modify the parent
+     * collection. (somewhat counter-intuitive, and not easily derived
+     * from 2518.) */
+    ne_lock_using_parent(req, lock->uri.path);
+
+    ret = ne_request_dispatch(req);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    
+    return ret;
+}
+
+static int parse_depth(const char *depth)
+{
+    if (ne_strcasecmp(depth, "infinity") == 0) {
+	return NE_DEPTH_INFINITE;
+    } else if (isdigit(depth[0])) {
+	return atoi(depth);
+    } else {
+	return -1;
+    }
+}
+
+static long parse_timeout(const char *timeout)
+{
+    if (ne_strcasecmp(timeout, "infinite") == 0) {
+	return NE_TIMEOUT_INFINITE;
+    } else if (strncasecmp(timeout, "Second-", 7) == 0) {
+	long to = strtol(timeout+7, NULL, 10);
+	if (to == LONG_MIN || to == LONG_MAX)
+	    return NE_TIMEOUT_INVALID;
+	return to;
+    } else {
+	return NE_TIMEOUT_INVALID;
+    }
+}
+
+static void discover_results(void *userdata, const ne_uri *uri,
+			     const ne_prop_result_set *set)
+{
+    struct discover_ctx *ctx = userdata;
+    struct ne_lock *lock = ne_propset_private(set);
+    const ne_status *status = ne_propset_status(set, &lock_props[0]);
+
+    /* Require at least that the lock has a token. */
+    if (lock->token) {
+	if (status && status->klass != 2) {
+	    ctx->results(ctx->userdata, NULL, uri, status);
+	} else {
+	    ctx->results(ctx->userdata, lock, uri, NULL);
+	}
+    }
+    else if (status) {
+	ctx->results(ctx->userdata, NULL, uri, status);
+    }
+
+    NE_DEBUG(NE_DBG_LOCKS, "End of response for %s\n", uri->path);
+}
+
+static int 
+end_element_common(struct ne_lock *l, int state, const char *cdata)
+{
+    switch (state) { 
+    case ELM_write:
+	l->type = ne_locktype_write;
+	break;
+    case ELM_exclusive:
+	l->scope = ne_lockscope_exclusive;
+	break;
+    case ELM_shared:
+	l->scope = ne_lockscope_shared;
+	break;
+    case ELM_depth:
+	NE_DEBUG(NE_DBG_LOCKS, "Got depth: %s\n", cdata);
+	l->depth = parse_depth(cdata);
+	if (l->depth == -1) {
+	    return -1;
+	}
+	break;
+    case ELM_timeout:
+	NE_DEBUG(NE_DBG_LOCKS, "Got timeout: %s\n", cdata);
+	l->timeout = parse_timeout(cdata);
+	if (l->timeout == NE_TIMEOUT_INVALID) {
+	    return -1;
+	}
+	break;
+    case ELM_owner:
+	l->owner = strdup(cdata);
+	break;
+    case ELM_href:
+	l->token = strdup(cdata);
+	break;
+    }
+    return 0;
+}
+
+/* End-element handler for lock discovery PROPFIND response */
+static int end_element_ldisc(void *userdata, int state, 
+                             const char *nspace, const char *name)
+{
+    struct discover_ctx *ctx = userdata;
+    struct ne_lock *lock = ne_propfind_current_private(ctx->phandler);
+
+    return end_element_common(lock, state, ctx->cdata->data);
+}
+
+static inline int can_accept(int parent, int id)
+{
+    return (parent == NE_XML_STATEROOT && id == ELM_prop) ||
+        (parent == ELM_prop && id == ELM_lockdiscovery) ||
+        (parent == ELM_lockdiscovery && id == ELM_activelock) ||
+        (parent == ELM_activelock && 
+         (id == ELM_lockscope || id == ELM_locktype ||
+          id == ELM_depth || id == ELM_owner ||
+          id == ELM_timeout || id == ELM_locktoken)) ||
+        (parent == ELM_lockscope &&
+         (id == ELM_exclusive || id == ELM_shared)) ||
+        (parent == ELM_locktype && id == ELM_write) ||
+        (parent == ELM_locktoken && id == ELM_href);
+}
+
+static int ld_startelm(void *userdata, int parent,
+                       const char *nspace, const char *name,
+		       const char **atts)
+{
+    struct discover_ctx *ctx = userdata;
+    int id = ne_xml_mapid(element_map, NE_XML_MAPLEN(element_map),
+                          nspace, name);
+    
+    ne_buffer_clear(ctx->cdata);
+    
+    if (can_accept(parent, id))
+        return id;
+    else
+        return NE_XML_DECLINE;
+}    
+
+#define MAX_CDATA (256)
+
+static int lk_cdata(void *userdata, int state,
+                    const char *cdata, size_t len)
+{
+    struct lock_ctx *ctx = userdata;
+
+    if (ctx->cdata->used + len < MAX_CDATA)
+        ne_buffer_append(ctx->cdata, cdata, len);
+    
+    return 0;
+}
+
+static int ld_cdata(void *userdata, int state,
+                    const char *cdata, size_t len)
+{
+    struct discover_ctx *ctx = userdata;
+
+    if (ctx->cdata->used + len < MAX_CDATA)
+        ne_buffer_append(ctx->cdata, cdata, len);
+    
+    return 0;
+}
+
+static int lk_startelm(void *userdata, int parent,
+                       const char *nspace, const char *name,
+		       const char **atts)
+{
+    struct lock_ctx *ctx = userdata;
+    int id;
+
+    id = ne_xml_mapid(element_map, NE_XML_MAPLEN(element_map), nspace, name);
+
+    NE_DEBUG(NE_DBG_LOCKS, "lk_startelm: %s => %d\n", name, id);
+    
+    if (id == 0)
+        return NE_XML_DECLINE;    
+
+    if (parent == 0 && ctx->token == NULL) {
+        const char *token = ne_get_response_header(ctx->req, "Lock-Token");
+        /* at the root element; retrieve the Lock-Token header,
+         * and bail if it wasn't given. */
+        if (token == NULL) {
+            ne_xml_set_error(ctx->parser, 
+                             _("LOCK response missing Lock-Token header"));
+            return NE_XML_ABORT;
+        }
+
+        if (token[0] == '<') token++;
+        ctx->token = ne_strdup(token);
+        ne_shave(ctx->token, ">");
+        NE_DEBUG(NE_DBG_LOCKS, "lk_startelm: Finding token %s\n",
+                 ctx->token);
+    }
+
+    /* TODO: only accept 'prop' as root for LOCK response */
+    if (!can_accept(parent, id))
+        return NE_XML_DECLINE;
+
+    if (id == ELM_activelock && !ctx->found) {
+	/* a new activelock */
+	ne_lock_free(&ctx->active);
+	memset(&ctx->active, 0, sizeof ctx->active);
+        ctx->active.timeout = NE_TIMEOUT_INVALID;
+    }
+
+    ne_buffer_clear(ctx->cdata);
+
+    return id;
+}
+
+/* End-element handler for LOCK response */
+static int lk_endelm(void *userdata, int state,
+                     const char *nspace, const char *name)
+{
+    struct lock_ctx *ctx = userdata;
+
+    if (ctx->found)
+	return 0;
+
+    if (end_element_common(&ctx->active, state, ctx->cdata->data))
+	return -1;
+
+    if (state == ELM_activelock) {
+	if (ctx->active.token && strcmp(ctx->active.token, ctx->token) == 0) {
+	    ctx->found = 1;
+	}
+    }
+
+    return 0;
+}
+
+/* Creator callback for private structure. */
+static void *ld_create(void *userdata, const ne_uri *uri)
+{
+    struct ne_lock *lk = ne_lock_create();
+
+    ne_uri_copy(&lk->uri, uri);
+
+    return lk;
+}
+
+/* Destructor callback for private structure. */
+static void ld_destroy(void *userdata, void *private)
+{
+    struct ne_lock *lk = private;
+
+    ne_lock_destroy(lk);
+}
+
+/* Discover all locks on URI */
+int ne_lock_discover(ne_session *sess, const char *uri, 
+		     ne_lock_result callback, void *userdata)
+{
+    ne_propfind_handler *handler;
+    struct discover_ctx ctx = {0};
+    int ret;
+    
+    ctx.results = callback;
+    ctx.userdata = userdata;
+    ctx.cdata = ne_buffer_create();
+    ctx.phandler = handler = ne_propfind_create(sess, uri, NE_DEPTH_ZERO);
+
+    ne_propfind_set_private(handler, ld_create, ld_destroy, &ctx);
+    
+    ne_xml_push_handler(ne_propfind_get_parser(handler), 
+                        ld_startelm, ld_cdata, end_element_ldisc, &ctx);
+    
+    ret = ne_propfind_named(handler, lock_props, discover_results, &ctx);
+    
+    ne_buffer_destroy(ctx.cdata);
+    ne_propfind_destroy(handler);
+
+    return ret;
+}
+
+static void add_timeout_header(ne_request *req, long timeout)
+{
+    if (timeout == NE_TIMEOUT_INFINITE) {
+	ne_add_request_header(req, "Timeout", "Infinite");
+    } 
+    else if (timeout != NE_TIMEOUT_INVALID && timeout > 0) {
+	ne_print_request_header(req, "Timeout", "Second-%ld", timeout);
+    }
+    /* just ignore it if timeout == 0 or invalid. */
+}
+
+int ne_lock(ne_session *sess, struct ne_lock *lock) 
+{
+    ne_request *req = ne_request_create(sess, "LOCK", lock->uri.path);
+    ne_buffer *body = ne_buffer_create();
+    ne_xml_parser *parser = ne_xml_create();
+    int ret;
+    struct lock_ctx ctx;
+
+    memset(&ctx, 0, sizeof ctx);
+    ctx.cdata = ne_buffer_create();    
+    ctx.req = req;
+    ctx.parser = parser;
+
+    /* LOCK is not idempotent. */
+    ne_set_request_flag(req, NE_REQFLAG_IDEMPOTENT, 0);
+
+    ne_xml_push_handler(parser, lk_startelm, lk_cdata, lk_endelm, &ctx);
+    
+    /* Create the body */
+    ne_buffer_concat(body, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
+		    "<lockinfo xmlns='DAV:'>\n" " <lockscope>",
+		    lock->scope==ne_lockscope_exclusive?
+		    "<exclusive/>":"<shared/>",
+		    "</lockscope>\n"
+		    "<locktype><write/></locktype>", NULL);
+
+    if (lock->owner) {
+	ne_buffer_concat(body, "<owner>", lock->owner, "</owner>\n", NULL);
+    }
+    ne_buffer_czappend(body, "</lockinfo>\n");
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ne_add_depth_header(req, lock->depth);
+    add_timeout_header(req, lock->timeout);
+    
+    /* TODO: 
+     * By 2518, we need this only if we are creating a lock-null resource.
+     * Since we don't KNOW whether the lock we're given is a lock-null
+     * or not, we cover our bases.
+     */
+    ne_lock_using_parent(req, lock->uri.path);
+    /* This one is clearer from 2518 sec 8.10.4. */
+    ne_lock_using_resource(req, lock->uri.path, lock->depth);
+
+    ret = ne_xml_dispatch_request(req, parser);
+
+    ne_buffer_destroy(body);
+    ne_buffer_destroy(ctx.cdata);
+    
+    if (ret == NE_OK && ne_get_status(req)->klass == 2) {
+        if (ne_get_status(req)->code == 207) {
+            ret = NE_ERROR;
+            /* TODO: set the error string appropriately */
+        } else if (ctx.found) {
+	    /* it worked: copy over real lock details if given. */
+            if (lock->token) ne_free(lock->token);
+	    lock->token = ctx.token;
+            ctx.token = NULL;
+	    if (ctx.active.timeout != NE_TIMEOUT_INVALID)
+		lock->timeout = ctx.active.timeout;
+	    lock->scope = ctx.active.scope;
+	    lock->type = ctx.active.type;
+	    if (ctx.active.depth >= 0)
+		lock->depth = ctx.active.depth;
+	    if (ctx.active.owner) {
+		if (lock->owner) ne_free(lock->owner);
+		lock->owner = ctx.active.owner;
+		ctx.active.owner = NULL;
+	    }
+	} else {
+	    ret = NE_ERROR;
+	    ne_set_error(sess, _("Response missing activelock for %s"), 
+			 ctx.token);
+	}
+    } else if (ret == NE_OK /* && status != 2xx */) {
+	ret = NE_ERROR;
+    }
+
+    ne_lock_free(&ctx.active);
+    if (ctx.token) ne_free(ctx.token);
+    ne_request_destroy(req);
+    ne_xml_destroy(parser);
+
+    return ret;
+}
+
+int ne_lock_refresh(ne_session *sess, struct ne_lock *lock)
+{
+    ne_request *req = ne_request_create(sess, "LOCK", lock->uri.path);
+    ne_xml_parser *parser = ne_xml_create();
+    int ret;
+    struct lock_ctx ctx;
+
+    memset(&ctx, 0, sizeof ctx);
+    ctx.cdata = ne_buffer_create();
+    ctx.req = req;
+    ctx.token = lock->token;
+    ctx.parser = parser;
+
+    /* Handle the response and update *lock appropriately. */
+    ne_xml_push_handler(parser, lk_startelm, lk_cdata, lk_endelm, &ctx);
+    
+    /* For a lock refresh, submitting only this lock token must be
+     * sufficient. */
+    ne_print_request_header(req, "If", "(<%s>)", lock->token);
+    add_timeout_header(req, lock->timeout);
+
+    ret = ne_xml_dispatch_request(req, parser);
+
+    if (ret == NE_OK) {
+        if (ne_get_status(req)->klass != 2) {
+            ret = NE_ERROR; /* and use default session error */
+	} else if (!ctx.found) {
+            ne_set_error(sess, _("No activelock for <%s> returned in "
+                                 "LOCK refresh response"), lock->token);
+            ret = NE_ERROR;
+        } else /* success! */ {
+            /* update timeout for passed-in lock structure. */
+            lock->timeout = ctx.active.timeout;
+        }
+    }
+
+    ne_lock_free(&ctx.active);
+    ne_buffer_destroy(ctx.cdata);
+    ne_request_destroy(req);
+    ne_xml_destroy(parser);
+
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_locks.h b/net/mmt/neon/src/ne_locks.h
new file mode 100644
index 0000000..db98f11
--- /dev/null
+++ b/net/mmt/neon/src/ne_locks.h
@@ -0,0 +1,165 @@
+/* 
+   WebDAV Class 2 locking operations
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_LOCKS_H
+#define NE_LOCKS_H
+
+#include "ne_request.h" /* for ne_session + ne_request */
+#include "ne_uri.h" /* for ne_uri */
+
+NE_BEGIN_DECLS
+
+/* The scope of a lock */
+enum ne_lock_scope {
+    ne_lockscope_exclusive,
+    ne_lockscope_shared
+};
+
+/* Lock type. Only write locks are defined in RFC2518. */
+enum ne_lock_type {
+    ne_locktype_write
+};
+
+/* A lock object. */
+struct ne_lock {
+    ne_uri uri;
+    int depth; /* the depth of the lock (NE_DEPTH_*). */
+    enum ne_lock_type type;
+    enum ne_lock_scope scope;
+    char *token; /* the lock token: uniquely identifies this lock. */
+    char *owner; /* string describing the owner of the lock. */
+    long timeout; /* timeout in seconds. (or NE_TIMEOUT_*) */
+};
+/* NB: struct ne_lock Would be typedef'ed to ne_lock except lock is
+ * a verb and a noun, so we already have ne_lock the function. Damn
+ * the English language. */
+
+#define NE_TIMEOUT_INFINITE -1
+#define NE_TIMEOUT_INVALID -2
+
+/* Create a depth zero, exclusive write lock, with default timeout
+ * (allowing a server to pick a default).  token, owner and uri are
+ * unset. */
+struct ne_lock *ne_lock_create(void);
+
+/* HINT: to initialize uri host/port/scheme for the lock's URI, use
+ * ne_fill_server_uri from ne_session.h. */
+
+/* Deep-copy a lock structure: strdup's any of path, token, owner,
+ * hostport which are set. */
+struct ne_lock *ne_lock_copy(const struct ne_lock *lock);
+
+/* Free a lock structure; free's any of any of the URI, token and
+ * owner which are set, but not the lock object itself. */
+void ne_lock_free(struct ne_lock *lock);
+
+/* Like ne_lock_free; but free's the lock object itself too. */
+void ne_lock_destroy(struct ne_lock *lock);
+
+/* ne_lock_store: an opaque type which is used to store a set of lock
+ * objects. */
+typedef struct ne_lock_store_s ne_lock_store;
+
+/* Create a lock store. */
+ne_lock_store *ne_lockstore_create(void);
+
+/* Register the lock store 'store' with the HTTP session 'sess': any
+ * operations made using 'sess' which operate on a locked resource,
+ * can use the locks from 'store' if needed. */
+void ne_lockstore_register(ne_lock_store *store, ne_session *sess);
+
+/* Destroy a lock store, free'ing any locks remaining inside. */
+void ne_lockstore_destroy(ne_lock_store *store);
+
+/* Add a lock to the store: the store then "owns" the lock object, and
+ * you must not free it. The lock MUST have all of:
+ *  - a completed URI structure: scheme, host, port, and path all set
+ *  - a valid lock token
+ *  - a valid depth
+ */
+void ne_lockstore_add(ne_lock_store *store, struct ne_lock *lock);
+
+/* Remove given lock object from store: 'lock' MUST point to a lock
+ * object which is known to be in the store. */
+void ne_lockstore_remove(ne_lock_store *store, struct ne_lock *lock);
+
+/* Returns the first lock in the lock store, or NULL if the store is
+ * empty. */
+struct ne_lock *ne_lockstore_first(ne_lock_store *store);
+
+/* After ne_lockstore_first has been called; returns the next lock in
+ * the lock store, or NULL if there are no more locks stored.
+ * Behaviour is undefined if ne_lockstore_first has not been called on
+ * 'store' since the store was created, or the last time this function
+ * returned NULL for the store.. */
+struct ne_lock *ne_lockstore_next(ne_lock_store *store);
+
+/* Find a lock in the store for the given server, and with the given
+ * path. */
+struct ne_lock *ne_lockstore_findbyuri(ne_lock_store *store, 
+				       const ne_uri *uri);
+
+/* Issue a LOCK request for the given lock.  Requires that the uri,
+ * depth, type, scope, and timeout members of 'lock' are filled in.
+ * owner and token must be malloc-allocated if not NULL; and may be
+ * free()d by this function.  On successful return, lock->token will
+ * contain the lock token. */
+int ne_lock(ne_session *sess, struct ne_lock *lock);
+
+/* Issue an UNLOCK request for the given lock */
+int ne_unlock(ne_session *sess, const struct ne_lock *lock);
+
+/* Refresh a lock. Updates lock->timeout appropriately. */
+int ne_lock_refresh(ne_session *sess, struct ne_lock *lock);
+
+/* Callback for lock discovery.  If 'lock' is NULL, something went
+ * wrong performing lockdiscovery for the resource, look at 'status'
+ * for the details.
+ * 
+ * If lock is non-NULL, at least lock->uri and lock->token will be
+ * filled in; and status will be NULL. */
+typedef void (*ne_lock_result)(void *userdata, const struct ne_lock *lock, 
+			       const ne_uri *uri, const ne_status *status);
+
+/* Perform lock discovery on the given path.  'result' is called with
+ * the results (possibly >1 times).  */
+int ne_lock_discover(ne_session *sess, const char *path,
+		     ne_lock_result result, void *userdata);
+
+/* The ne_lock_using_* functions should be used before dispatching a
+ * request which modify resources.  If a lock store has been
+ * registered with the session associated with the request, and locks
+ * are present in the lock store which cover the resources which are
+ * being modified by the request, then the appropriate lock tokens are
+ * submitted in the request headers. */
+
+/* Indicate that request 'req' will modify the resource at 'path', and
+ * is an operation of given 'depth'. */
+void ne_lock_using_resource(ne_request *req, const char *path, int depth);
+
+/* Indicate that request 'req' will modify the parent collection of
+ * the resource found at 'path' (for instance when removing the
+ * resource from the collection). */
+void ne_lock_using_parent(ne_request *req, const char *path);
+
+NE_END_DECLS
+
+#endif /* NE_LOCKS_H */
diff --git a/net/mmt/neon/src/ne_md5.c b/net/mmt/neon/src/ne_md5.c
new file mode 100644
index 0000000..35d7109
--- /dev/null
+++ b/net/mmt/neon/src/ne_md5.c
@@ -0,0 +1,464 @@
+/* md5.c - Functions to compute MD5 message digest of files or memory blocks
+   according to the definition of MD5 in RFC 1321 from April 1992.
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <stdlib.h>
+#include <string.h>
+#ifdef HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
+#include "ne_md5.h"
+#include "ne_string.h" /* for NE_ASC2HEX */
+
+#define md5_process_block ne_md5_process_block
+#define md5_process_bytes ne_md5_process_bytes
+#define md5_finish_ctx ne_md5_finish_ctx
+#define md5_read_ctx ne_md5_read_ctx
+#define md5_stream ne_md5_stream
+#define md5_ctx ne_md5_ctx
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n)							\
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#else
+# define SWAP(n) (n)
+#endif
+
+#if SIZEOF_INT == 4
+typedef unsigned int md5_uint32;
+#elif SIZEOF_LONG == 4
+typedef unsigned long md5_uint32;
+#else
+# error "Cannot determine unsigned 32-bit data type."
+#endif
+
+/* Structure to save state of computation between the single steps.  */
+struct md5_ctx
+{
+  md5_uint32 A;
+  md5_uint32 B;
+  md5_uint32 C;
+  md5_uint32 D;
+
+  md5_uint32 total[2];
+  md5_uint32 buflen;
+  char buffer[128];
+};
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+static void 
+md5_init_ctx (struct md5_ctx *ctx)
+{
+  ctx->A = 0x67452301;
+  ctx->B = 0xefcdab89;
+  ctx->C = 0x98badcfe;
+  ctx->D = 0x10325476;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+struct ne_md5_ctx *
+ne_md5_create_ctx(void)
+{
+  struct md5_ctx *ctx = ne_malloc(sizeof *ctx);
+  md5_init_ctx(ctx);
+  return ctx;
+}
+
+extern void 
+ne_md5_reset_ctx(struct ne_md5_ctx *ctx)
+{
+  md5_init_ctx(ctx);
+}
+
+struct ne_md5_ctx *
+ne_md5_dup_ctx(struct ne_md5_ctx *ctx)
+{
+  return memcpy(ne_malloc(sizeof *ctx), ctx, sizeof *ctx);
+}
+
+void
+ne_md5_destroy_ctx(struct ne_md5_ctx *ctx)
+{
+  ne_free(ctx);
+}
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)
+{
+  ((md5_uint32 *) resbuf)[0] = SWAP (ctx->A);
+  ((md5_uint32 *) resbuf)[1] = SWAP (ctx->B);
+  ((md5_uint32 *) resbuf)[2] = SWAP (ctx->C);
+  ((md5_uint32 *) resbuf)[3] = SWAP (ctx->D);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+void *
+md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)
+{
+  /* Take yet unprocessed bytes into account.  */
+  md5_uint32 bytes = ctx->buflen;
+  md5_uint32 swap_bytes;
+  size_t pad;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  pad = bytes >= 56 ? 64 + 56 - bytes : 56 - bytes;
+  memcpy (&ctx->buffer[bytes], fillbuf, pad);
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.
+     Use memcpy to avoid aliasing problems.  On most systems, this
+     will be optimized away to the same code.  */
+  swap_bytes = SWAP (ctx->total[0] << 3);
+  memcpy (&ctx->buffer[bytes + pad], &swap_bytes, sizeof (swap_bytes));
+  swap_bytes = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));
+  memcpy (&ctx->buffer[bytes + pad + 4], &swap_bytes, sizeof (swap_bytes));
+
+  /* Process last bytes.  */
+  md5_process_block (ctx->buffer, bytes + pad + 8, ctx);
+
+  return md5_read_ctx (ctx, resbuf);
+}
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+int
+md5_stream (FILE *stream, void *resblock)
+{
+  /* Important: BLOCKSIZE must be a multiple of 64.  */
+#define BLOCKSIZE 4096
+  struct md5_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+	 computation function processes the whole buffer so that with the
+	 next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      do
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+	}
+      while (sum < BLOCKSIZE && n != 0);
+      if (n == 0 && ferror (stream))
+        return 1;
+
+      /* If end of file is reached, end the loop.  */
+      if (n == 0)
+	break;
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+			BLOCKSIZE % 64 == 0
+       */
+      md5_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+  /* Add the last bytes if necessary.  */
+  if (sum > 0)
+    md5_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  md5_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+void
+md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+
+      memcpy (&ctx->buffer[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (left_over + add > 64)
+	{
+	  md5_process_block (ctx->buffer, (left_over + add) & ~63, ctx);
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer, &ctx->buffer[(left_over + add) & ~63],
+		  (left_over + add) & 63);
+	  ctx->buflen = (left_over + add) & 63;
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len > 64)
+    {
+      md5_process_block (buffer, len & ~63, ctx);
+      buffer = (const char *) buffer + (len & ~63);
+      len &= 63;
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      memcpy (ctx->buffer, buffer, len);
+      ctx->buflen = len;
+    }
+}
+
+
+/* These are the four functions used in the four steps of the MD5 algorithm
+   and defined in the RFC 1321.  The first function is a little bit optimized
+   (as found in Colin Plumbs public domain implementation).  */
+/* #define FF(b, c, d) ((b & c) | (~b & d)) */
+#define FF(b, c, d) (d ^ (b & (c ^ d)))
+#define FG(b, c, d) FF (d, b, c)
+#define FH(b, c, d) (b ^ c ^ d)
+#define FI(b, c, d) (c ^ (b | ~d))
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.  */
+
+void
+md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  md5_uint32 correct_words[16];
+  const unsigned char *words = buffer;
+  const unsigned char *endp = words + len;
+  md5_uint32 A = ctx->A;
+  md5_uint32 B = ctx->B;
+  md5_uint32 C = ctx->C;
+  md5_uint32 D = ctx->D;
+
+  /* First increment the byte count.  RFC 1321 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+  /* Process all bytes in the buffer with 64 bytes in each round of
+     the loop.  */
+  while (words < endp)
+    {
+      md5_uint32 *cwp = correct_words;
+      md5_uint32 A_save = A;
+      md5_uint32 B_save = B;
+      md5_uint32 C_save = C;
+      md5_uint32 D_save = D;
+
+      /* First round: using the given function, the context and a constant
+	 the next context is computed.  Because the algorithms processing
+	 unit is a 32-bit word and it is determined to work on words in
+	 little endian byte order we perhaps have to change the byte order
+	 before the computation.  To reduce the work for the next steps
+	 we store the swapped words in the array CORRECT_WORDS.  */
+
+#define OP(a, b, c, d, s, T)						\
+      do								\
+        {								\
+	  md5_uint32 WORD_ = (md5_uint32)words[0] | ((md5_uint32)words[1] << 8) \
+	       | ((md5_uint32)words[2] << 16) | ((md5_uint32)words[3] << 24); \
+	  a += FF (b, c, d) + (*cwp++ = WORD_) + T;		\
+	  words += 4;							\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+        }								\
+      while (0)
+
+      /* It is unfortunate that C does not provide an operator for
+	 cyclic rotation.  Hope the C compiler is smart enough.  */
+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
+
+      /* Before we start, one word to the strange constants.
+	 They are defined in RFC 1321 as
+
+	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
+       */
+
+      /* Round 1.  */
+      OP (A, B, C, D,  7, 0xd76aa478);
+      OP (D, A, B, C, 12, 0xe8c7b756);
+      OP (C, D, A, B, 17, 0x242070db);
+      OP (B, C, D, A, 22, 0xc1bdceee);
+      OP (A, B, C, D,  7, 0xf57c0faf);
+      OP (D, A, B, C, 12, 0x4787c62a);
+      OP (C, D, A, B, 17, 0xa8304613);
+      OP (B, C, D, A, 22, 0xfd469501);
+      OP (A, B, C, D,  7, 0x698098d8);
+      OP (D, A, B, C, 12, 0x8b44f7af);
+      OP (C, D, A, B, 17, 0xffff5bb1);
+      OP (B, C, D, A, 22, 0x895cd7be);
+      OP (A, B, C, D,  7, 0x6b901122);
+      OP (D, A, B, C, 12, 0xfd987193);
+      OP (C, D, A, B, 17, 0xa679438e);
+      OP (B, C, D, A, 22, 0x49b40821);
+
+      /* For the second to fourth round we have the possibly swapped words
+	 in CORRECT_WORDS.  Redefine the macro to take an additional first
+	 argument specifying the function to use.  */
+#undef OP
+#define OP(f, a, b, c, d, k, s, T)					\
+      do 								\
+	{								\
+	  a += f (b, c, d) + correct_words[k] + T;			\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+	}								\
+      while (0)
+
+      /* Round 2.  */
+      OP (FG, A, B, C, D,  1,  5, 0xf61e2562);
+      OP (FG, D, A, B, C,  6,  9, 0xc040b340);
+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
+      OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa);
+      OP (FG, A, B, C, D,  5,  5, 0xd62f105d);
+      OP (FG, D, A, B, C, 10,  9, 0x02441453);
+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
+      OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8);
+      OP (FG, A, B, C, D,  9,  5, 0x21e1cde6);
+      OP (FG, D, A, B, C, 14,  9, 0xc33707d6);
+      OP (FG, C, D, A, B,  3, 14, 0xf4d50d87);
+      OP (FG, B, C, D, A,  8, 20, 0x455a14ed);
+      OP (FG, A, B, C, D, 13,  5, 0xa9e3e905);
+      OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8);
+      OP (FG, C, D, A, B,  7, 14, 0x676f02d9);
+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
+
+      /* Round 3.  */
+      OP (FH, A, B, C, D,  5,  4, 0xfffa3942);
+      OP (FH, D, A, B, C,  8, 11, 0x8771f681);
+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
+      OP (FH, A, B, C, D,  1,  4, 0xa4beea44);
+      OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9);
+      OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60);
+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
+      OP (FH, A, B, C, D, 13,  4, 0x289b7ec6);
+      OP (FH, D, A, B, C,  0, 11, 0xeaa127fa);
+      OP (FH, C, D, A, B,  3, 16, 0xd4ef3085);
+      OP (FH, B, C, D, A,  6, 23, 0x04881d05);
+      OP (FH, A, B, C, D,  9,  4, 0xd9d4d039);
+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
+      OP (FH, B, C, D, A,  2, 23, 0xc4ac5665);
+
+      /* Round 4.  */
+      OP (FI, A, B, C, D,  0,  6, 0xf4292244);
+      OP (FI, D, A, B, C,  7, 10, 0x432aff97);
+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
+      OP (FI, B, C, D, A,  5, 21, 0xfc93a039);
+      OP (FI, A, B, C, D, 12,  6, 0x655b59c3);
+      OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92);
+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
+      OP (FI, B, C, D, A,  1, 21, 0x85845dd1);
+      OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f);
+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
+      OP (FI, C, D, A, B,  6, 15, 0xa3014314);
+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
+      OP (FI, A, B, C, D,  4,  6, 0xf7537e82);
+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
+      OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb);
+      OP (FI, B, C, D, A,  9, 21, 0xeb86d391);
+
+      /* Add the starting values of the context.  */
+      A += A_save;
+      B += B_save;
+      C += C_save;
+      D += D_save;
+    }
+
+  /* Put checksum in context given as argument.  */
+  ctx->A = A;
+  ctx->B = B;
+  ctx->C = C;
+  ctx->D = D;
+}
+
+/* Writes the ASCII representation of the MD5 digest into the
+ * given buffer, which must be at least 33 characters long. */
+void ne_md5_to_ascii(const unsigned char md5_buf[16], char *buffer) 
+{
+    int count;
+    for (count = 0; count<16; count++) {
+	buffer[count*2] = NE_HEX2ASC(md5_buf[count] >> 4);
+	buffer[count*2+1] = NE_HEX2ASC(md5_buf[count] & 0x0f);
+    }
+    buffer[32] = '\0';
+}
+
+/* Reads the ASCII representation of an MD5 digest. The buffer must
+ * be at least 32 characters long. */
+void ne_ascii_to_md5(const char *buffer, unsigned char md5_buf[16]) 
+{
+    int count;
+    for (count = 0; count<16; count++) {
+	md5_buf[count] = ((NE_ASC2HEX(buffer[count*2])) << 4) |
+	    NE_ASC2HEX(buffer[count*2+1]);
+    }
+}
+
+char *ne_md5_finish_ascii(struct ne_md5_ctx *ctx, char buffer[33])
+{
+    md5_uint32 result[4];
+
+    ne_md5_finish_ctx(ctx, (void *)result);
+    ne_md5_to_ascii((void *)result, buffer);
+
+    return buffer;
+}
+
diff --git a/net/mmt/neon/src/ne_md5.h b/net/mmt/neon/src/ne_md5.h
new file mode 100644
index 0000000..9a625bc
--- /dev/null
+++ b/net/mmt/neon/src/ne_md5.h
@@ -0,0 +1,98 @@
+/* Declaration of functions and data types used for MD5 sum computing
+   library functions.
+   Copyright (C) 2006, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef NE_MD5_H
+#define NE_MD5_H 1
+
+#include <stdio.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/*
+ * The following three functions are build up the low level used in
+ * the functions `md5_stream' and `md5_buffer'.
+ */
+struct ne_md5_ctx;
+
+/* Create structure containing state of computation. */
+extern struct ne_md5_ctx *ne_md5_create_ctx(void);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 64!!! */
+extern void ne_md5_process_block(const void *buffer, size_t len,
+                                 struct ne_md5_ctx *ctx);
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 64.  */
+extern void ne_md5_process_bytes(const void *buffer, size_t len,
+                                 struct ne_md5_ctx *ctx);
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 16 bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *ne_md5_finish_ctx(struct ne_md5_ctx *ctx, void *resbuf);
+
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32 bits value.  */
+extern void *ne_md5_read_ctx(const struct ne_md5_ctx *ctx, void *resbuf);
+
+/* Take a copy of the state structure. */
+extern struct ne_md5_ctx *ne_md5_dup_ctx(struct ne_md5_ctx *ctx);
+
+/* Re-initialize the context structure. */
+extern void ne_md5_reset_ctx(struct ne_md5_ctx *ctx);
+
+/* Destroy the context structure. */
+extern void ne_md5_destroy_ctx(struct ne_md5_ctx *ctx);
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+extern int ne_md5_stream(FILE *stream, void *resblock);
+
+/* Process the remaining bytes in the buffer and put ASCII
+   representation of the resulting message digest from CTX in the
+   first 33 bytes of BUFFER, including a trailing NUL terminator
+   byte.  Returns pointer to buffer. */
+char *ne_md5_finish_ascii(struct ne_md5_ctx *ctx, char buffer[33]);
+
+/* MD5 ascii->binary conversion */
+void ne_md5_to_ascii(const unsigned char md5_buf[16], char *buffer);
+void ne_ascii_to_md5(const char *buffer, unsigned char md5_buf[16]);
+
+NE_END_DECLS
+
+#endif /* NE_MD5_H */
diff --git a/net/mmt/neon/src/ne_ntlm.c b/net/mmt/neon/src/ne_ntlm.c
new file mode 100644
index 0000000..3c00e79
--- /dev/null
+++ b/net/mmt/neon/src/ne_ntlm.c
@@ -0,0 +1,688 @@
+/* 
+   Handling of NTLM Authentication
+   Copyright (C) 2003, Daniel Stenberg <daniel@haxx.se>
+   Copyright (C) 2009, Kai Sommerfeld <kso@openoffice.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* NTLM details:
+   
+   http://davenport.sourceforge.net/ntlm.html
+   http://www.innovation.ch/java/ntlm.html
+
+*/
+
+#include "ne_ntlm.h"
+
+#ifdef HAVE_NTLM
+
+#include "ne_string.h"
+
+typedef enum {
+  NTLMSTATE_NONE,
+  NTLMSTATE_TYPE1,
+  NTLMSTATE_TYPE2,
+  NTLMSTATE_TYPE3,
+  NTLMSTATE_LAST
+} NTLMState;
+
+struct ne_ntlm_context_s {
+  NTLMState state;
+  unsigned char nonce[8];
+  char *user;
+  char *passwd;
+  char *requestToken;
+};
+
+typedef enum {
+  NTLM_NONE, /* not a ntlm */
+  NTLM_BAD,  /* an ntlm, but one we don't like */
+  NTLM_FIRST, /* the first 401-reply we got with NTLM */
+  NTLM_FINE, /* an ntlm we act on */
+
+  NTLM_LAST  /* last entry in this enum, don't use */
+} ntlm;
+
+/* Flag bits definitions based on http://davenport.sourceforge.net/ntlm.html */
+
+#define NTLMFLAG_NEGOTIATE_UNICODE               (1<<0)
+/* Indicates that Unicode strings are supported for use in security buffer
+   data. */
+
+#define NTLMFLAG_NEGOTIATE_OEM                   (1<<1)
+/* Indicates that OEM strings are supported for use in security buffer data. */
+
+#define NTLMFLAG_REQUEST_TARGET                  (1<<2)
+/* Requests that the server's authentication realm be included in the Type 2
+   message. */
+
+/* unknown (1<<3) */
+#define NTLMFLAG_NEGOTIATE_SIGN                  (1<<4)
+/* Specifies that authenticated communication between the client and server
+   should carry a digital signature (message integrity). */
+
+#define NTLMFLAG_NEGOTIATE_SEAL                  (1<<5)
+/* Specifies that authenticated communication between the client and server
+   should be encrypted (message confidentiality). */
+
+#define NTLMFLAG_NEGOTIATE_DATAGRAM_STYLE        (1<<6)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_LM_KEY                (1<<7)
+/* Indicates that the LAN Manager session key should be used for signing and
+   sealing authenticated communications. */
+
+#define NTLMFLAG_NEGOTIATE_NETWARE               (1<<8)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_NTLM_KEY              (1<<9)
+/* Indicates that NTLM authentication is being used. */
+
+/* unknown (1<<10) */
+/* unknown (1<<11) */
+
+#define NTLMFLAG_NEGOTIATE_DOMAIN_SUPPLIED       (1<<12)
+/* Sent by the client in the Type 1 message to indicate that a desired
+   authentication realm is included in the message. */
+
+#define NTLMFLAG_NEGOTIATE_WORKSTATION_SUPPLIED  (1<<13)
+/* Sent by the client in the Type 1 message to indicate that the client
+   workstation's name is included in the message. */
+
+#define NTLMFLAG_NEGOTIATE_LOCAL_CALL            (1<<14)
+/* Sent by the server to indicate that the server and client are on the same
+   machine. Implies that the client may use a pre-established local security
+   context rather than responding to the challenge. */
+
+#define NTLMFLAG_NEGOTIATE_ALWAYS_SIGN           (1<<15)
+/* Indicates that authenticated communication between the client and server
+   should be signed with a "dummy" signature. */
+
+#define NTLMFLAG_TARGET_TYPE_DOMAIN              (1<<16)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a domain. */
+
+#define NTLMFLAG_TARGET_TYPE_SERVER              (1<<17)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a server. */
+
+#define NTLMFLAG_TARGET_TYPE_SHARE               (1<<18)
+/* Sent by the server in the Type 2 message to indicate that the target
+   authentication realm is a share. Presumably, this is for share-level
+   authentication. Usage is unclear. */
+
+#define NTLMFLAG_NEGOTIATE_NTLM2_KEY             (1<<19)
+/* Indicates that the NTLM2 signing and sealing scheme should be used for
+   protecting authenticated communications. */
+
+#define NTLMFLAG_REQUEST_INIT_RESPONSE           (1<<20)
+/* unknown purpose */
+
+#define NTLMFLAG_REQUEST_ACCEPT_RESPONSE         (1<<21)
+/* unknown purpose */
+
+#define NTLMFLAG_REQUEST_NONNT_SESSION_KEY       (1<<22)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_TARGET_INFO           (1<<23)
+/* Sent by the server in the Type 2 message to indicate that it is including a
+   Target Information block in the message. */
+
+/* unknown (1<24) */
+/* unknown (1<25) */
+/* unknown (1<26) */
+/* unknown (1<27) */
+/* unknown (1<28) */
+
+#define NTLMFLAG_NEGOTIATE_128                   (1<<29)
+/* Indicates that 128-bit encryption is supported. */
+
+#define NTLMFLAG_NEGOTIATE_KEY_EXCHANGE          (1<<30)
+/* unknown purpose */
+
+#define NTLMFLAG_NEGOTIATE_56                    (1<<31)
+/* Indicates that 56-bit encryption is supported. */
+
+#ifdef HAVE_OPENSSL
+/* We need OpenSSL for the crypto lib to provide us with MD4 and DES */
+
+/* -- WIN32 approved -- */
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <ctype.h>
+
+#include <openssl/des.h>
+#include <openssl/md4.h>
+#include <openssl/ssl.h>
+
+#if OPENSSL_VERSION_NUMBER < 0x00907001L
+#define DES_key_schedule des_key_schedule
+#define DES_cblock des_cblock
+#define DES_set_odd_parity des_set_odd_parity
+#define DES_set_key des_set_key
+#define DES_ecb_encrypt des_ecb_encrypt
+
+/* This is how things were done in the old days */
+#define DESKEY(x) x
+#define DESKEYARG(x) x
+#else
+/* Modern version */
+#define DESKEYARG(x) *x
+#define DESKEY(x) &x
+#endif
+
+/* Define this to make the type-3 message include the NT response message */
+#define USE_NTRESPONSES 1
+
+/*
+  (*) = A "security buffer" is a triplet consisting of two shorts and one
+  long:
+
+  1. a 'short' containing the length of the buffer in bytes
+  2. a 'short' containing the allocated space for the buffer in bytes
+  3. a 'long' containing the offset to the start of the buffer from the
+     beginning of the NTLM message, in bytes.
+*/
+
+static ntlm ne_input_ntlm(ne_ntlm_context *ctx,
+			  const char *responseToken)
+{
+  if(responseToken) {
+    /* We got a type-2 message here:
+
+       Index   Description         Content
+       0       NTLMSSP Signature   Null-terminated ASCII "NTLMSSP"
+                                   (0x4e544c4d53535000)
+       8       NTLM Message Type   long (0x02000000)
+       12      Target Name         security buffer(*)
+       20      Flags               long
+       24      Challenge           8 bytes
+       (32)    Context (optional)  8 bytes (two consecutive longs)
+       (40)    Target Information  (optional) security buffer(*)
+       32 (48) start of data block
+    */
+    unsigned char * buffer = NULL;
+
+    int size = ne_unbase64(responseToken, &buffer);
+
+    ctx->state = NTLMSTATE_TYPE2; /* we got a type-2 */
+
+    if(size >= 48)
+      /* the nonce of interest is index [24 .. 31], 8 bytes */
+      memcpy(ctx->nonce, &buffer[24], 8);
+
+    /* at index decimal 20, there's a 32bit NTLM flag field */
+      
+    if (buffer) ne_free(buffer); 
+  }
+  else {
+    if(ctx->state >= NTLMSTATE_TYPE1)
+      return NTLM_BAD;
+
+    ctx->state = NTLMSTATE_TYPE1; /* we should sent away a type-1 */
+  }
+  return NTLM_FINE;
+}
+
+/*
+ * Turns a 56 bit key into the 64 bit, odd parity key and sets the key.  The
+ * key schedule ks is also set.
+ */
+static void setup_des_key(unsigned char *key_56,
+                          DES_key_schedule DESKEYARG(ks))
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = ((key_56[0] << 7) & 0xFF) | (key_56[1] >> 1);
+  key[2] = ((key_56[1] << 6) & 0xFF) | (key_56[2] >> 2);
+  key[3] = ((key_56[2] << 5) & 0xFF) | (key_56[3] >> 3);
+  key[4] = ((key_56[3] << 4) & 0xFF) | (key_56[4] >> 4);
+  key[5] = ((key_56[4] << 3) & 0xFF) | (key_56[5] >> 5);
+  key[6] = ((key_56[5] << 2) & 0xFF) | (key_56[6] >> 6);
+  key[7] =  (key_56[6] << 1) & 0xFF;
+
+  DES_set_odd_parity(&key);
+  DES_set_key(&key, ks);
+}
+
+ /*
+  * takes a 21 byte array and treats it as 3 56-bit DES keys. The
+  * 8 byte plaintext is encrypted with each key and the resulting 24
+  * bytes are stored in the results array.
+  */
+static void calc_resp(unsigned char *keys,
+                      unsigned char *plaintext,
+                      unsigned char *results)
+{
+  DES_key_schedule ks;
+
+  setup_des_key(keys, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) results,
+                  DESKEY(ks), DES_ENCRYPT);
+
+  setup_des_key(keys+7, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results+8),
+                  DESKEY(ks), DES_ENCRYPT);
+
+  setup_des_key(keys+14, DESKEY(ks));
+  DES_ecb_encrypt((DES_cblock*) plaintext, (DES_cblock*) (results+16),
+                  DESKEY(ks), DES_ENCRYPT);
+}
+
+/*
+ * Set up lanmanager and nt hashed passwords
+ */
+static void mkhash(char *password,
+                   unsigned char *nonce,  /* 8 bytes */
+                   unsigned char *lmresp  /* must fit 0x18 bytes */
+#ifdef USE_NTRESPONSES
+                   , unsigned char *ntresp  /* must fit 0x18 bytes */
+#endif
+  )
+{
+  unsigned char lmbuffer[21];
+#ifdef USE_NTRESPONSES
+  unsigned char ntbuffer[21];
+#endif
+  unsigned char *pw;
+  static const unsigned char magic[] = {
+    0x4B, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25
+  };
+  int i;
+  int len = strlen(password);
+
+  /* make it fit at least 14 bytes */
+  pw = ne_malloc(len<7?14:len*2);
+  if(!pw)
+    return; /* this will lead to a badly generated package */
+
+  if (len > 14)
+    len = 14;
+  
+  for (i=0; i<len; i++)
+    pw[i] = toupper(password[i]);
+
+  for (; i<14; i++)
+    pw[i] = 0;
+
+  {
+    /* create LanManager hashed password */
+    DES_key_schedule ks;
+
+    setup_des_key(pw, DESKEY(ks));
+    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)lmbuffer,
+                    DESKEY(ks), DES_ENCRYPT);
+  
+    setup_des_key(pw+7, DESKEY(ks));
+    DES_ecb_encrypt((DES_cblock *)magic, (DES_cblock *)(lmbuffer+8),
+                    DESKEY(ks), DES_ENCRYPT);
+
+    memset(lmbuffer+16, 0, 5);
+  }
+  /* create LM responses */
+  calc_resp(lmbuffer, nonce, lmresp);
+
+#ifdef USE_NTRESPONSES
+  {
+    /* create NT hashed password */
+    MD4_CTX md4;
+
+    len = strlen(password);
+
+    for (i=0; i<len; i++) {
+      pw[2*i]   = password[i];
+      pw[2*i+1] = 0;
+    }
+
+    MD4_Init(&md4);
+    MD4_Update(&md4, pw, 2*len);
+    MD4_Final(ntbuffer, &md4);
+
+    memset(ntbuffer+16, 0, 5);
+  }
+
+  calc_resp(ntbuffer, nonce, ntresp);
+#endif
+
+  ne_free(pw);
+}
+
+#define SHORTPAIR(x) ((x) & 0xff), ((x) >> 8)
+#define LONGQUARTET(x) ((x) & 0xff), (((x) >> 8)&0xff), \
+  (((x) >>16)&0xff), ((x)>>24)
+
+/* this is for creating ntlm header output */
+static int ne_output_ntlm(ne_ntlm_context *ctx)
+{
+  const char *domain=""; /* empty */
+  const char *host=""; /* empty */
+  int domlen=strlen(domain);
+  int hostlen = strlen(host);
+  int hostoff; /* host name offset */
+  int domoff;  /* domain name offset */
+  int size;
+  unsigned char ntlmbuf[256]; /* enough, unless the host/domain is very long */
+
+  if(!ctx->user || !ctx->passwd)
+    /* no user, no auth */
+    return 0; /* OK */
+  
+  switch(ctx->state) {
+  case NTLMSTATE_TYPE1:
+  default: /* for the weird cases we (re)start here */
+    hostoff = 32;
+    domoff = hostoff + hostlen;
+    
+    /* Create and send a type-1 message:
+
+    Index Description          Content
+    0     NTLMSSP Signature    Null-terminated ASCII "NTLMSSP"
+                               (0x4e544c4d53535000)
+    8     NTLM Message Type    long (0x01000000)
+    12    Flags                long
+    16    Supplied Domain      security buffer(*)
+    24    Supplied Workstation security buffer(*)
+    32    start of data block
+
+    */
+
+    ne_snprintf((char *)ntlmbuf, sizeof(ntlmbuf), "NTLMSSP%c"
+             "\x01%c%c%c" /* 32-bit type = 1 */
+             "%c%c%c%c"   /* 32-bit NTLM flag field */
+             "%c%c"  /* domain length */
+             "%c%c"  /* domain allocated space */
+             "%c%c"  /* domain name offset */
+             "%c%c"  /* 2 zeroes */
+             "%c%c"  /* host length */
+             "%c%c"  /* host allocated space */
+             "%c%c"  /* host name offset */
+             "%c%c"  /* 2 zeroes */
+             "%s"   /* host name */
+             "%s",  /* domain string */
+             0,     /* trailing zero */
+             0,0,0, /* part of type-1 long */
+
+             LONGQUARTET(
+               NTLMFLAG_NEGOTIATE_OEM|      /*   2 */
+               NTLMFLAG_NEGOTIATE_NTLM_KEY  /* 200 */
+               /* equals 0x0202 */
+               ),
+             SHORTPAIR(domlen),
+             SHORTPAIR(domlen),
+             SHORTPAIR(domoff),
+             0,0,
+             SHORTPAIR(hostlen),
+             SHORTPAIR(hostlen),
+             SHORTPAIR(hostoff),
+             0,0,
+             host, domain);
+
+    /* initial packet length */
+    size = 32 + hostlen + domlen;
+
+    /* now keeper of the base64 encoded package size */
+    if (ctx->requestToken) ne_free(ctx->requestToken);
+    ctx->requestToken = ne_base64(ntlmbuf, size);
+
+    break;
+    
+  case NTLMSTATE_TYPE2:
+    /* We received the type-2 already, create a type-3 message:
+
+    Index   Description            Content
+    0       NTLMSSP Signature      Null-terminated ASCII "NTLMSSP"
+                                   (0x4e544c4d53535000)
+    8       NTLM Message Type      long (0x03000000)
+    12      LM/LMv2 Response       security buffer(*)
+    20      NTLM/NTLMv2 Response   security buffer(*)
+    28      Domain Name            security buffer(*)
+    36      User Name              security buffer(*)
+    44      Workstation Name       security buffer(*)
+    (52)    Session Key (optional) security buffer(*)
+    (60)    Flags (optional)       long
+    52 (64) start of data block
+
+    */
+  
+  {
+    int lmrespoff;
+    int ntrespoff;
+    int useroff;
+    unsigned char lmresp[0x18]; /* fixed-size */
+#ifdef USE_NTRESPONSES
+    unsigned char ntresp[0x18]; /* fixed-size */
+#endif
+    const char *user;
+    int userlen;
+
+    user = strchr(ctx->user, '\\');
+    if(!user)
+      user = strchr(ctx->user, '/');
+
+    if (user) {
+      domain = ctx->user;
+      domlen = user - domain;
+      user++;
+    }
+    else
+      user = ctx->user;
+    userlen = strlen(user);
+
+    mkhash(ctx->passwd, &ctx->nonce[0], lmresp
+#ifdef USE_NTRESPONSES
+           , ntresp
+#endif
+      );
+
+    domoff = 64; /* always */
+    useroff = domoff + domlen;
+    hostoff = useroff + userlen;
+    lmrespoff = hostoff + hostlen;
+    ntrespoff = lmrespoff + 0x18;
+
+    /* Create the big type-3 message binary blob */
+    size = ne_snprintf((char *)ntlmbuf, sizeof(ntlmbuf),
+                    "NTLMSSP%c"
+                    "\x03%c%c%c" /* type-3, 32 bits */
+
+                    "%c%c%c%c" /* LanManager length + allocated space */
+                    "%c%c" /* LanManager offset */
+                    "%c%c" /* 2 zeroes */
+
+                    "%c%c" /* NT-response length */
+                    "%c%c" /* NT-response allocated space */
+                    "%c%c" /* NT-response offset */
+                    "%c%c" /* 2 zeroes */
+                    
+                    "%c%c"  /* domain length */
+                    "%c%c"  /* domain allocated space */
+                    "%c%c"  /* domain name offset */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "%c%c"  /* user length */
+                    "%c%c"  /* user allocated space */
+                    "%c%c"  /* user offset */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "%c%c"  /* host length */
+                    "%c%c"  /* host allocated space */
+                    "%c%c"  /* host offset */
+                    "%c%c%c%c%c%c"  /* 6 zeroes */
+                    
+                    "\xff\xff"  /* message length */
+                    "%c%c"  /* 2 zeroes */
+                    
+                    "\x01\x82" /* flags */
+                    "%c%c"  /* 2 zeroes */
+
+                    /* domain string */
+                    /* user string */
+                    /* host string */
+                    /* LanManager response */
+                    /* NT response */
+                    ,
+                    0, /* zero termination */
+                    0,0,0, /* type-3 long, the 24 upper bits */
+
+                    SHORTPAIR(0x18),  /* LanManager response length, twice */
+                    SHORTPAIR(0x18),
+                    SHORTPAIR(lmrespoff),
+                    0x0, 0x0,
+                    
+#ifdef USE_NTRESPONSES
+                    SHORTPAIR(0x18),  /* NT-response length, twice */
+                    SHORTPAIR(0x18),
+#else
+                    0x0, 0x0,
+                    0x0, 0x0,
+#endif
+                    SHORTPAIR(ntrespoff),
+                    0x0, 0x0,
+
+                    SHORTPAIR(domlen),
+                    SHORTPAIR(domlen),
+                    SHORTPAIR(domoff),
+                    0x0, 0x0,
+
+                    SHORTPAIR(userlen),
+                    SHORTPAIR(userlen),
+                    SHORTPAIR(useroff),
+                    0x0, 0x0,
+                    
+                    SHORTPAIR(hostlen),
+                    SHORTPAIR(hostlen),
+                    SHORTPAIR(hostoff),
+                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+             
+                    0x0, 0x0,
+
+                    0x0, 0x0);
+
+    /* size is now 64 */
+    size=64;
+    ntlmbuf[62]=ntlmbuf[63]=0;
+
+    /* Make sure that the user and domain strings fit in the target buffer
+       before we copy them there. */
+    if((size_t)size + userlen + domlen >= sizeof(ntlmbuf)) {
+      return -1;
+    }
+
+    memcpy(&ntlmbuf[size], domain, domlen);
+    size += domlen;
+
+    memcpy(&ntlmbuf[size], user, userlen);
+    size += userlen;
+
+    /* we append the binary hashes to the end of the blob */
+    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
+      memcpy(&ntlmbuf[size], lmresp, 0x18);
+      size += 0x18;
+    }
+
+#ifdef USE_NTRESPONSES
+    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {      
+      memcpy(&ntlmbuf[size], ntresp, 0x18);
+      size += 0x18;
+    }
+#endif
+
+    ntlmbuf[56] = size & 0xff;
+    ntlmbuf[57] = size >> 8;
+
+    /* convert the binary blob into base64 */
+    ctx->requestToken = ne_base64(ntlmbuf, size);
+
+    ctx->state = NTLMSTATE_TYPE3; /* we sent a type-3 */
+  }
+  break;
+
+  case NTLMSTATE_TYPE3:
+    /* connection is already authenticated,
+     * don't send a header in future requests */
+    if (ctx->requestToken) ne_free(ctx->requestToken);
+    ctx->requestToken = NULL;
+    break;
+  }
+
+  return 0; /* OK */
+}
+
+ne_ntlm_context *ne__ntlm_create_context(const char *userName, const char *password)
+{
+    ne_ntlm_context *ctx = ne_calloc(sizeof(ne_ntlm_context));
+
+    ctx->state = NTLMSTATE_NONE;
+    ctx->user = ne_strdup(userName);
+    ctx->passwd = ne_strdup(password);
+    
+    return ctx;
+}
+
+void ne__ntlm_destroy_context(ne_ntlm_context *context)
+{
+    if (context->user)
+        ne_free(context->user);
+    
+    if (context->passwd)
+        ne_free(context->passwd);
+    
+    if (context->requestToken)
+        ne_free(context->requestToken);
+    
+    ne_free(context);
+}
+
+int ne__ntlm_authenticate(ne_ntlm_context *context, const char *responseToken)
+{
+    if (context == NULL) {
+	return -1;
+    } else {
+        if (!responseToken && (context->state == NTLMSTATE_TYPE3))
+            context->state = NTLMSTATE_NONE;
+
+        if (context->state <= NTLMSTATE_TYPE3) {
+	  ntlm ntlmstatus = ne_input_ntlm(context, responseToken);
+
+	  if (ntlmstatus != NTLM_FINE) { 
+	    return -1;
+	  }
+	}
+    }
+    return ne_output_ntlm(context);
+}
+
+char *ne__ntlm_getRequestToken(ne_ntlm_context *context)
+{
+    char *ret;
+
+    if (context == NULL || !context->requestToken) {
+	return NULL;
+    }
+
+    ret = ne_strdup(context->requestToken);
+    ne_free(context->requestToken);
+    context->requestToken = NULL;
+    return ret;
+}
+
+#endif /* HAVE_OPENSSL */
+#endif /* HAVE_NTLM */
diff --git a/net/mmt/neon/src/ne_ntlm.h b/net/mmt/neon/src/ne_ntlm.h
new file mode 100644
index 0000000..f903bcb
--- /dev/null
+++ b/net/mmt/neon/src/ne_ntlm.h
@@ -0,0 +1,46 @@
+/* 
+   Handling of NTLM Authentication
+   Copyright (C) 2009, Kai Sommerfeld <kso@openoffice.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+#ifndef NE_NTLM_H
+#define NE_NTLM_H
+
+#include "config.h"
+
+/* PRIVATE TO NEON -- NOT PART OF THE EXTERNAL API. */
+
+#ifdef HAVE_NTLM
+
+#include "ne_defs.h"
+
+typedef struct ne_ntlm_context_s ne_ntlm_context;
+
+NE_PRIVATE ne_ntlm_context *ne__ntlm_create_context(const char *userName, const char *password);
+
+NE_PRIVATE int ne__ntlm_clear_context(ne_ntlm_context *context);
+
+NE_PRIVATE void ne__ntlm_destroy_context(ne_ntlm_context *context);
+
+NE_PRIVATE int ne__ntlm_authenticate(ne_ntlm_context *context, const char *responseToken);
+
+NE_PRIVATE char *ne__ntlm_getRequestToken(ne_ntlm_context *context);
+
+#endif /* HAVE_NTLM */
+
+#endif /* NE_NTLM_H */
diff --git a/net/mmt/neon/src/ne_oldacl.c b/net/mmt/neon/src/ne_oldacl.c
new file mode 100644
index 0000000..80a6838
--- /dev/null
+++ b/net/mmt/neon/src/ne_oldacl.c
@@ -0,0 +1,132 @@
+/*
+   Access control
+   Copyright (C) 2001-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* Contributed by Arun Garg <arung@pspl.co.in> */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include "ne_request.h"
+#include "ne_locks.h"
+#include "ne_alloc.h"
+#include "ne_string.h"
+#include "ne_acl.h"
+#include "ne_uri.h"
+#include "ne_xml.h" /* for NE_XML_MEDIA_TYPE */
+
+#define EOL "\r\n"
+
+static ne_buffer *acl_body(const ne_acl_entry *right, int count)
+{
+    ne_buffer *body = ne_buffer_create();
+    int m;
+
+    ne_buffer_zappend(body,
+		      "<?xml version=\"1.0\" encoding=\"utf-8\"?>" EOL
+		      "<acl xmlns='DAV:'>" EOL);
+
+    for (m = 0; m < count; m++) {
+	const char *type;
+
+	type = (right[m].type == ne_acl_grant ? "grant" : "deny");
+
+	ne_buffer_concat(body, "<ace>" EOL "<principal>", NULL);
+
+	switch (right[m].apply) {
+	case ne_acl_all:
+	    ne_buffer_zappend(body, "<all/>" EOL);
+	    break;
+	case ne_acl_property:
+	    ne_buffer_concat(body, "<property><", right[m].principal,
+			     "/></property>" EOL, NULL);
+	    break;
+	case ne_acl_href:
+	    ne_buffer_concat(body, "<href>", right[m].principal,
+			     "</href>" EOL, NULL);
+	    break;
+	}
+
+	ne_buffer_concat(body, "</principal>" EOL "<", type, ">" EOL, NULL);
+	
+	if (right[m].read == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].read_acl == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<read-acl/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].write == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].write_acl == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>" "<write-acl/>" "</privilege>" EOL,
+			     NULL);
+	if (right[m].read_cuprivset == 0)
+	    ne_buffer_concat(body,
+			     "<privilege>"
+			     "<read-current-user-privilege-set/>"
+			     "</privilege>" EOL, NULL);
+	ne_buffer_concat(body, "</", type, ">" EOL, NULL);
+	ne_buffer_zappend(body, "</ace>" EOL);
+    }
+    ne_buffer_zappend(body, "</acl>" EOL);
+
+    return body;
+}
+
+int ne_acl_set(ne_session *sess, const char *uri,
+	       const ne_acl_entry *entries, int numentries)
+{
+    int ret;
+    ne_request *req = ne_request_create(sess, "ACL", uri);
+    ne_buffer *body = acl_body(entries, numentries);
+
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, 0);
+#endif
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    ret = ne_request_dispatch(req);
+
+    ne_buffer_destroy(body);
+
+    if (ret == NE_OK && ne_get_status(req)->code == 207) {
+	ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_openssl.c b/net/mmt/neon/src/ne_openssl.c
new file mode 100644
index 0000000..f8350fa
--- /dev/null
+++ b/net/mmt/neon/src/ne_openssl.c
@@ -0,0 +1,1272 @@
+/* 
+   neon SSL/TLS support using OpenSSL
+   Copyright (C) 2002-2011, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/pkcs12.h>
+#include <openssl/x509v3.h>
+#include <openssl/rand.h>
+#include <openssl/opensslv.h>
+
+#ifdef NE_HAVE_TS_SSL
+#include <stdlib.h> /* for abort() */
+#ifndef _WIN32
+#include <pthread.h>
+#endif
+#endif
+
+#include "ne_ssl.h"
+#include "ne_string.h"
+#include "ne_session.h"
+#include "ne_internal.h"
+
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+/* OpenSSL 0.9.6 compatibility */
+#if OPENSSL_VERSION_NUMBER < 0x0090700fL
+#define PKCS12_unpack_authsafes M_PKCS12_unpack_authsafes
+#define PKCS12_unpack_p7data M_PKCS12_unpack_p7data
+/* cast away lack of const-ness */
+#define OBJ_cmp(a,b) OBJ_cmp((ASN1_OBJECT *)(a), (ASN1_OBJECT *)(b))
+#endif
+
+/* Second argument for d2i_X509() changed type in 0.9.8. */
+#if OPENSSL_VERSION_NUMBER < 0x0090800fL
+typedef unsigned char ne_d2i_uchar;
+#else
+typedef const unsigned char ne_d2i_uchar;
+#endif
+
+struct ne_ssl_dname_s {
+    X509_NAME *dn;
+};
+
+struct ne_ssl_certificate_s {
+    ne_ssl_dname subj_dn, issuer_dn;
+    X509 *subject;
+    ne_ssl_certificate *issuer;
+    char *identity;
+};
+
+struct ne_ssl_client_cert_s {
+    PKCS12 *p12;
+    int decrypted; /* non-zero if successfully decrypted. */
+    ne_ssl_certificate cert;
+    EVP_PKEY *pkey;
+    char *friendly_name;
+};
+
+#define NE_SSL_UNHANDLED (0x20) /* failure bit for unhandled case. */
+
+/* Append an ASN.1 DirectoryString STR to buffer BUF as UTF-8.
+ * Returns zero on success or non-zero on error. */
+static int append_dirstring(ne_buffer *buf, ASN1_STRING *str)
+{
+    unsigned char *tmp = (unsigned char *)""; /* initialize to workaround 0.9.6 bug */
+    int len;
+
+    switch (str->type) {
+    case V_ASN1_IA5STRING: /* definitely ASCII */
+    case V_ASN1_VISIBLESTRING: /* probably ASCII */
+    case V_ASN1_PRINTABLESTRING: /* subset of ASCII */
+        ne_buffer_qappend(buf, str->data, str->length);
+        break;
+    case V_ASN1_UTF8STRING:
+        /* Fail for embedded NUL bytes. */
+        if (strlen((char *)str->data) != (size_t)str->length) {
+            return -1;
+        }
+        ne_buffer_append(buf, (char *)str->data, str->length);
+        break;
+    case V_ASN1_UNIVERSALSTRING:
+    case V_ASN1_T61STRING: /* let OpenSSL convert it as ISO-8859-1 */
+    case V_ASN1_BMPSTRING: 
+        len = ASN1_STRING_to_UTF8(&tmp, str);
+        if (len > 0) {
+            /* Fail if there were embedded NUL bytes. */
+            if (strlen((char *)tmp) != (size_t)len) {
+                OPENSSL_free(tmp);
+                return -1;
+            } 
+            else {
+                ne_buffer_append(buf, (char *)tmp, len);
+                OPENSSL_free(tmp);
+            }
+            break;
+        } else {
+            ERR_clear_error();
+            return -1;
+        }
+        break;
+    default:
+        NE_DEBUG(NE_DBG_SSL, "Could not convert DirectoryString type %d\n",
+                 str->type);
+        return -1;
+    }
+    return 0;
+}
+
+/* Returns a malloc-allocated version of IA5 string AS, escaped for
+ * safety. */
+static char *dup_ia5string(const ASN1_IA5STRING *as)
+{
+    return ne_strnqdup(as->data, as->length);
+}
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *name)
+{
+    int n, flag = 0;
+    ne_buffer *dump = ne_buffer_create();
+    const ASN1_OBJECT * const cname = OBJ_nid2obj(NID_commonName),
+	* const email = OBJ_nid2obj(NID_pkcs9_emailAddress);
+
+    for (n = X509_NAME_entry_count(name->dn); n > 0; n--) {
+	X509_NAME_ENTRY *ent = X509_NAME_get_entry(name->dn, n-1);
+	
+        /* Skip commonName or emailAddress except if there is no other
+         * attribute in dname. */
+	if ((OBJ_cmp(ent->object, cname) && OBJ_cmp(ent->object, email)) ||
+            (!flag && n == 1)) {
+ 	    if (flag++)
+		ne_buffer_append(dump, ", ", 2);
+
+            if (append_dirstring(dump, ent->value))
+                ne_buffer_czappend(dump, "???");
+	}
+    }
+
+    return ne_buffer_finish(dump);
+}
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    return X509_NAME_cmp(dn1->dn, dn2->dn);
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *cc)
+{
+    if (cc->p12)
+        PKCS12_free(cc->p12);
+    if (cc->decrypted) {
+        if (cc->cert.identity) ne_free(cc->cert.identity);
+        EVP_PKEY_free(cc->pkey);
+        X509_free(cc->cert.subject);
+    }
+    if (cc->friendly_name) ne_free(cc->friendly_name);
+    ne_free(cc);
+}
+
+/* Format an ASN1 time to a string. 'buf' must be at least of size
+ * 'NE_SSL_VDATELEN'. */
+static time_t asn1time_to_timet(const ASN1_TIME *atm)
+{
+    struct tm tm = {0};
+    int i = atm->length;
+    
+    if (i < 10)
+        return (time_t )-1;
+
+    tm.tm_year = (atm->data[0]-'0') * 10 + (atm->data[1]-'0');
+
+    /* Deal with Year 2000 */
+    if (tm.tm_year < 70)
+        tm.tm_year += 100;
+
+    tm.tm_mon = (atm->data[2]-'0') * 10 + (atm->data[3]-'0') - 1;
+    tm.tm_mday = (atm->data[4]-'0') * 10 + (atm->data[5]-'0');
+    tm.tm_hour = (atm->data[6]-'0') * 10 + (atm->data[7]-'0');
+    tm.tm_min = (atm->data[8]-'0') * 10 + (atm->data[9]-'0');
+    tm.tm_sec = (atm->data[10]-'0') * 10 + (atm->data[11]-'0');
+
+#ifdef HAVE_TIMEZONE
+    /* ANSI C time handling is... interesting. */
+    return mktime(&tm) - timezone;
+#else
+    return mktime(&tm);
+#endif
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until)
+{
+    if (from) {
+        *from = asn1time_to_timet(X509_get_notBefore(cert->subject));
+    }
+    if (until) {
+        *until = asn1time_to_timet(X509_get_notAfter(cert->subject));
+    }
+}
+
+/* Check certificate identity.  Returns zero if identity matches; 1 if
+ * identity does not match, or <0 if the certificate had no identity.
+ * If 'identity' is non-NULL, store the malloc-allocated identity in
+ * *identity.  Logic specified by RFC 2818 and RFC 3280. */
+static int check_identity(const ne_uri *server, X509 *cert, char **identity)
+{
+    STACK_OF(GENERAL_NAME) *names;
+    int match = 0, found = 0;
+    const char *hostname;
+    
+    hostname = server ? server->host : "";
+
+    names = X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
+    if (names) {
+	int n;
+
+        /* subjectAltName contains a sequence of GeneralNames */
+	for (n = 0; n < sk_GENERAL_NAME_num(names) && !match; n++) {
+	    GENERAL_NAME *nm = sk_GENERAL_NAME_value(names, n);
+	    
+            /* handle dNSName and iPAddress name extensions only. */
+	    if (nm->type == GEN_DNS) {
+		char *name = dup_ia5string(nm->d.ia5);
+                if (identity && !found) *identity = ne_strdup(name);
+		match = ne__ssl_match_hostname(name, strlen(name), hostname);
+		ne_free(name);
+		found = 1;
+            } 
+            else if (nm->type == GEN_IPADD) {
+                /* compare IP address with server IP address. */
+                ne_inet_addr *ia;
+                if (nm->d.ip->length == 4)
+                    ia = ne_iaddr_make(ne_iaddr_ipv4, nm->d.ip->data);
+                else if (nm->d.ip->length == 16)
+                    ia = ne_iaddr_make(ne_iaddr_ipv6, nm->d.ip->data);
+                else
+                    ia = NULL;
+                /* ne_iaddr_make returns NULL if address type is unsupported */
+                if (ia != NULL) { /* address type was supported. */
+                    char buf[128];
+
+                    match = strcmp(hostname, 
+                                   ne_iaddr_print(ia, buf, sizeof buf)) == 0;
+                    found = 1;
+                    ne_iaddr_free(ia);
+                } else {
+                    NE_DEBUG(NE_DBG_SSL, "iPAddress name with unsupported "
+                             "address type (length %d), skipped.\n",
+                             nm->d.ip->length);
+                }
+            } 
+            else if (nm->type == GEN_URI) {
+                char *name = dup_ia5string(nm->d.ia5);
+                ne_uri uri;
+
+                if (ne_uri_parse(name, &uri) == 0 && uri.host && uri.scheme) {
+                    ne_uri tmp;
+
+                    if (identity && !found) *identity = ne_strdup(name);
+                    found = 1;
+
+                    if (server) {
+                        /* For comparison purposes, all that matters is
+                         * host, scheme and port; ignore the rest. */
+                        memset(&tmp, 0, sizeof tmp);
+                        tmp.host = uri.host;
+                        tmp.scheme = uri.scheme;
+                        tmp.port = uri.port;
+                        
+                        match = ne_uri_cmp(server, &tmp) == 0;
+                    }
+                }
+
+                ne_uri_free(&uri);
+                ne_free(name);
+            }
+	}
+        /* free the whole stack. */
+        sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
+    }
+    
+    /* Check against the commonName if no DNS alt. names were found,
+     * as per RFC3280. */
+    if (!found) {
+	X509_NAME *subj = X509_get_subject_name(cert);
+	X509_NAME_ENTRY *entry;
+	ne_buffer *cname = ne_buffer_ncreate(30);
+	int idx = -1, lastidx;
+
+	/* find the most specific commonName attribute. */
+	do {
+	    lastidx = idx;
+	    idx = X509_NAME_get_index_by_NID(subj, NID_commonName, lastidx);
+	} while (idx >= 0);
+	
+	if (lastidx < 0) {
+            /* no commonName attributes at all. */
+            ne_buffer_destroy(cname);
+	    return -1;
+        }
+
+	/* extract the string from the entry */
+        entry = X509_NAME_get_entry(subj, lastidx);
+        if (append_dirstring(cname, X509_NAME_ENTRY_get_data(entry))) {
+            ne_buffer_destroy(cname);
+            return -1;
+        }
+        if (identity) *identity = ne_strdup(cname->data);
+        match = ne__ssl_match_hostname(cname->data, cname->used - 1, hostname);
+        ne_buffer_destroy(cname);
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "Identity match for '%s': %s\n", hostname, 
+             match ? "good" : "bad");
+    return match ? 0 : 1;
+}
+
+/* Populate an ne_ssl_certificate structure from an X509 object. */
+static ne_ssl_certificate *populate_cert(ne_ssl_certificate *cert, X509 *x5)
+{
+    cert->subj_dn.dn = X509_get_subject_name(x5);
+    cert->issuer_dn.dn = X509_get_issuer_name(x5);
+    cert->issuer = NULL;
+    cert->subject = x5;
+    /* Retrieve the cert identity; pass a dummy hostname to match. */
+    cert->identity = NULL;
+    check_identity(NULL, x5, &cert->identity);
+    return cert;
+}
+
+/* OpenSSL cert verification callback.  This is invoked for *each*
+ * error which is encoutered whilst verifying the cert chain; multiple
+ * invocations for any particular cert in the chain are possible. */
+static int verify_callback(int ok, X509_STORE_CTX *ctx)
+{
+    /* OpenSSL, living in its own little happy world of global state,
+     * where userdata was just a twinkle in the eye of an API designer
+     * yet to be born.  Or... "Seriously, wtf?"  */
+    SSL *ssl = X509_STORE_CTX_get_ex_data(ctx, 
+                                          SSL_get_ex_data_X509_STORE_CTX_idx());
+    ne_session *sess = SSL_get_app_data(ssl);
+    int depth = X509_STORE_CTX_get_error_depth(ctx);
+    int err = X509_STORE_CTX_get_error(ctx);
+    int failures = 0;
+
+    /* If there's no error, nothing to do here. */
+    if (ok) return ok;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify callback @ %d => %d\n", depth, err);
+
+    /* Map the error code onto any of the exported cert validation
+     * errors, if possible. */
+    switch (err) {
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
+    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
+    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+    case X509_V_ERR_CERT_UNTRUSTED:
+    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
+        failures |= NE_SSL_UNTRUSTED;
+        break;
+    case X509_V_ERR_CERT_NOT_YET_VALID:
+        failures |= depth > 0 ? NE_SSL_BADCHAIN : NE_SSL_NOTYETVALID;
+        break;
+    case X509_V_ERR_CERT_HAS_EXPIRED:
+        failures |= depth > 0 ? NE_SSL_BADCHAIN : NE_SSL_EXPIRED;
+        break;
+    case X509_V_OK:
+        break;
+    default:
+        /* Clear the failures bitmask so check_certificate knows this
+         * is a bailout. */
+        sess->ssl_context->failures |= NE_SSL_UNHANDLED;
+        NE_DEBUG(NE_DBG_SSL, "ssl: Unhandled verification error %d -> %s\n", 
+                 err, X509_verify_cert_error_string(err));
+        return 0;
+    }
+
+    sess->ssl_context->failures |= failures;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Verify failures |= %d => %d\n", failures,
+             sess->ssl_context->failures);
+    
+    return 1;
+}
+
+/* Return a linked list of certificate objects from an OpenSSL chain. */
+static ne_ssl_certificate *make_chain(STACK_OF(X509) *chain)
+{
+    int n, count = sk_X509_num(chain);
+    ne_ssl_certificate *top = NULL, *current = NULL;
+    
+    NE_DEBUG(NE_DBG_SSL, "Chain depth: %d\n", count);
+
+    for (n = 0; n < count; n++) {
+        ne_ssl_certificate *cert = ne_malloc(sizeof *cert);
+        populate_cert(cert, X509_dup(sk_X509_value(chain, n)));
+#ifdef NE_DEBUGGING
+        if (ne_debug_mask & NE_DBG_SSL) {
+            fprintf(ne_debug_stream, "Cert #%d:\n", n);
+            X509_print_fp(ne_debug_stream, cert->subject);
+        }
+#endif
+        if (top == NULL) {
+            current = top = cert;
+        } else {
+            current->issuer = cert;
+            current = cert;
+        }
+    }
+
+    return top;
+}
+
+/* Verifies an SSL server certificate. */
+static int check_certificate(ne_session *sess, SSL *ssl, ne_ssl_certificate *chain)
+{
+    X509 *cert = chain->subject;
+    int ret, failures = sess->ssl_context->failures;
+    ne_uri server;
+
+    /* If the verification callback hit a case which can't be mapped
+     * to one of the exported error bits, it's treated as a hard
+     * failure rather than invoking the callback, which can't present
+     * a useful error to the user.  "Um, something is wrong.  OK?" */
+    if (failures & NE_SSL_UNHANDLED) {
+        long result = SSL_get_verify_result(ssl);
+
+        ne_set_error(sess, _("Certificate verification error: %s"),
+                    X509_verify_cert_error_string(result));
+
+        return NE_ERROR;
+    }
+
+    /* Check certificate was issued to this server; pass URI of
+     * server. */
+    memset(&server, 0, sizeof server);
+    ne_fill_server_uri(sess, &server);
+    ret = check_identity(&server, cert, NULL);
+    ne_uri_free(&server);
+    if (ret < 0) {
+        ne_set_error(sess, _("Server certificate was missing commonName "
+                             "attribute in subject name"));
+        return NE_ERROR;
+    } else if (ret > 0) failures |= NE_SSL_IDMISMATCH;
+
+    if (failures == 0) {
+        /* verified OK! */
+        ret = NE_OK;
+    } else {
+        /* Set up the error string. */
+        ne__ssl_set_verify_err(sess, failures);
+        ret = NE_ERROR;
+        /* Allow manual override */
+        if (sess->ssl_verify_fn && 
+            sess->ssl_verify_fn(sess->ssl_verify_ud, failures, chain) == 0)
+            ret = NE_OK;
+    }
+
+    return ret;
+}
+
+/* Duplicate a client certificate, which must be in the decrypted state. */
+static ne_ssl_client_cert *dup_client_cert(const ne_ssl_client_cert *cc)
+{
+    ne_ssl_client_cert *newcc = ne_calloc(sizeof *newcc);
+    
+    newcc->decrypted = 1;
+    newcc->pkey = cc->pkey;
+    if (cc->friendly_name)
+        newcc->friendly_name = ne_strdup(cc->friendly_name);
+
+    populate_cert(&newcc->cert, cc->cert.subject);
+
+    cc->cert.subject->references++;
+    cc->pkey->references++;
+    return newcc;
+}
+
+/* Callback invoked when the SSL server requests a client certificate.  */
+static int provide_client_cert(SSL *ssl, X509 **cert, EVP_PKEY **pkey)
+{
+    ne_session *const sess = SSL_get_app_data(ssl);
+
+    if (!sess->client_cert && sess->ssl_provide_fn) {
+	ne_ssl_dname **dnames = NULL, *dnarray = NULL;
+        int n, count = 0;
+	STACK_OF(X509_NAME) *ca_list = SSL_get_client_CA_list(ssl);
+
+        count = ca_list ? sk_X509_NAME_num(ca_list) : 0;
+
+        if (count > 0) {
+            dnames = ne_malloc(count * sizeof(ne_ssl_dname *));
+            dnarray = ne_malloc(count * sizeof(ne_ssl_dname));
+            
+            for (n = 0; n < count; n++) {
+                dnames[n] = &dnarray[n];
+                dnames[n]->dn = sk_X509_NAME_value(ca_list, n);
+            }
+        }
+
+	NE_DEBUG(NE_DBG_SSL, "Calling client certificate provider...\n");
+	sess->ssl_provide_fn(sess->ssl_provide_ud, sess, 
+                             (const ne_ssl_dname *const *)dnames, count);
+        if (count) {
+            ne_free(dnarray);
+            ne_free(dnames);
+        }
+    }
+
+    if (sess->client_cert) {
+        ne_ssl_client_cert *const cc = sess->client_cert;
+	NE_DEBUG(NE_DBG_SSL, "Supplying client certificate.\n");
+	cc->pkey->references++;
+	cc->cert.subject->references++;
+	*cert = cc->cert.subject;
+	*pkey = cc->pkey;
+	return 1;
+    } else {
+        sess->ssl_cc_requested = 1;
+	NE_DEBUG(NE_DBG_SSL, "No client certificate supplied.\n");
+	return 0;
+    }
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc)
+{
+    sess->client_cert = dup_client_cert(cc);
+}
+
+ne_ssl_context *ne_ssl_context_create(int mode)
+{
+    ne_ssl_context *ctx = ne_calloc(sizeof *ctx);
+    if (mode == NE_SSL_CTX_CLIENT) {
+        ctx->ctx = SSL_CTX_new(SSLv23_client_method());
+        ctx->sess = NULL;
+        /* set client cert callback. */
+        SSL_CTX_set_client_cert_cb(ctx->ctx, provide_client_cert);
+        /* enable workarounds for buggy SSL server implementations */
+        SSL_CTX_set_options(ctx->ctx, SSL_OP_ALL);
+        SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_PEER, verify_callback);
+    } else if (mode == NE_SSL_CTX_SERVER) {
+        ctx->ctx = SSL_CTX_new(SSLv23_server_method());
+        SSL_CTX_set_session_cache_mode(ctx->ctx, SSL_SESS_CACHE_CLIENT);
+#ifdef SSL_OP_NO_TICKET
+        /* disable ticket support since it inhibits testing of session
+         * caching. */
+        SSL_CTX_set_options(ctx->ctx, SSL_OP_NO_TICKET);
+#endif
+    } else {
+#ifdef OPENSSL_NO_SSL2
+        ne_free(ctx);
+        return NULL;
+#else
+        ctx->ctx = SSL_CTX_new(SSLv2_server_method());
+        SSL_CTX_set_session_cache_mode(ctx->ctx, SSL_SESS_CACHE_CLIENT);
+#endif
+    }
+    return ctx;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value)
+{
+    long opts = SSL_CTX_get_options(ctx->ctx);
+
+    switch (flag) {
+    case NE_SSL_CTX_SSLv2:
+        if (value) { 
+            /* Enable SSLv2 support; clear the "no SSLv2" flag. */
+            opts &= ~SSL_OP_NO_SSLv2;
+        } else {
+            /* Disable it: set the flag. */
+            opts |= SSL_OP_NO_SSLv2;
+        }
+        break;
+    }
+
+    SSL_CTX_set_options(ctx->ctx, opts);
+}
+
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag)
+{
+    switch (flag) {
+    case NE_SSL_CTX_SSLv2:
+#ifdef OPENSSL_NO_SSL2
+        return 0;
+#else
+        return ! (SSL_CTX_get_options(ctx->ctx) & SSL_OP_NO_SSLv2);
+#endif
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+int ne_ssl_context_keypair(ne_ssl_context *ctx, const char *cert,
+                           const char *key)
+{
+    int ret;
+
+    ret = SSL_CTX_use_PrivateKey_file(ctx->ctx, key, SSL_FILETYPE_PEM);
+    if (ret == 1) {
+        ret = SSL_CTX_use_certificate_chain_file(ctx->ctx, cert);
+    }
+
+    return ret == 1 ? 0 : -1;
+}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, 
+                              int required,
+                              const char *ca_names,
+                              const char *verify_cas)
+{
+    if (required) {
+        SSL_CTX_set_verify(ctx->ctx, SSL_VERIFY_PEER | 
+                           SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
+    }
+    if (ca_names) {
+        SSL_CTX_set_client_CA_list(ctx->ctx, 
+                                   SSL_load_client_CA_file(ca_names));
+    }
+    if (verify_cas) {
+        SSL_CTX_load_verify_locations(ctx->ctx, verify_cas, NULL);
+    }
+    return 0;
+}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx)
+{
+    SSL_CTX_free(ctx->ctx);
+    if (ctx->sess)
+        SSL_SESSION_free(ctx->sess);
+    ne_free(ctx);
+}
+
+#if !defined(HAVE_SSL_SESSION_CMP) && !defined(SSL_SESSION_cmp) \
+    && defined(OPENSSL_VERSION_NUMBER) \
+    && OPENSSL_VERSION_NUMBER > 0x10000000L
+/* OpenSSL 1.0 removed SSL_SESSION_cmp for no apparent reason - hoping
+ * it is reasonable to assume that comparing the session IDs is
+ * sufficient. */
+static int SSL_SESSION_cmp(SSL_SESSION *a, SSL_SESSION *b)
+{
+    return a->session_id_length == b->session_id_length
+        && memcmp(a->session_id, b->session_id, a->session_id_length) == 0;
+}
+#endif
+
+/* For internal use only. */
+int ne__negotiate_ssl(ne_session *sess)
+{
+    ne_ssl_context *ctx = sess->ssl_context;
+    SSL *ssl;
+    STACK_OF(X509) *chain;
+    int freechain = 0; /* non-zero if chain should be free'd. */
+
+    NE_DEBUG(NE_DBG_SSL, "Doing SSL negotiation.\n");
+    
+    /* Pass through the hostname if SNI is enabled. */
+    ctx->hostname = 
+        sess->flags[NE_SESSFLAG_TLS_SNI] ? sess->server.hostname : NULL;
+
+    sess->ssl_cc_requested = 0;
+    ctx->failures = 0;
+
+    if (ne_sock_connect_ssl(sess->socket, ctx, sess)) {
+	if (ctx->sess) {
+	    /* remove cached session. */
+	    SSL_SESSION_free(ctx->sess);
+	    ctx->sess = NULL;
+	}
+        if (sess->ssl_cc_requested) {
+            ne_set_error(sess, _("SSL handshake failed, "
+                                 "client certificate was requested: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        else {
+            ne_set_error(sess, _("SSL handshake failed: %s"),
+                         ne_sock_error(sess->socket));
+        }
+        return NE_ERROR;
+    }	
+    
+    ssl = ne__sock_sslsock(sess->socket);
+
+    chain = SSL_get_peer_cert_chain(ssl);
+    /* For an SSLv2 connection, the cert chain will always be NULL. */
+    if (chain == NULL) {
+        X509 *cert = SSL_get_peer_certificate(ssl);
+        if (cert) {
+            chain = sk_X509_new_null();
+            sk_X509_push(chain, cert);
+            freechain = 1;
+        }
+    }
+
+    if (chain == NULL || sk_X509_num(chain) == 0) {
+	ne_set_error(sess, _("SSL server did not present certificate"));
+	return NE_ERROR;
+    }
+
+    if (sess->server_cert) {
+        int diff = X509_cmp(sk_X509_value(chain, 0), sess->server_cert->subject);
+        if (freechain) sk_X509_free(chain); /* no longer need the chain */
+	if (diff) {
+	    /* This could be a MITM attack: fail the request. */
+	    ne_set_error(sess, _("Server certificate changed: "
+				 "connection intercepted?"));
+	    return NE_ERROR;
+	} 
+	/* certificate has already passed verification: no need to
+	 * verify it again. */
+    } else {
+	/* new connection: create the chain. */
+        ne_ssl_certificate *cert = make_chain(chain);
+
+        if (freechain) sk_X509_free(chain); /* no longer need the chain */
+
+	if (check_certificate(sess, ssl, cert)) {
+	    NE_DEBUG(NE_DBG_SSL, "SSL certificate checks failed: %s\n",
+		     sess->error);
+	    ne_ssl_cert_free(cert);
+	    return NE_ERROR;
+	}
+	/* remember the chain. */
+        sess->server_cert = cert;
+    }
+    
+    if (ctx->sess) {
+        SSL_SESSION *newsess = SSL_get0_session(ssl);
+        /* Replace the session if it has changed. */ 
+        if (newsess != ctx->sess || SSL_SESSION_cmp(ctx->sess, newsess)) {
+            SSL_SESSION_free(ctx->sess);
+            ctx->sess = SSL_get1_session(ssl); /* bumping the refcount */
+        }
+    } else {
+	/* Store the session. */
+	ctx->sess = SSL_get1_session(ssl);
+    }
+
+    return NE_OK;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return &cert->issuer_dn;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return &cert->subj_dn;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{
+    return cert->issuer;
+}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return cert->identity;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{
+    X509_STORE *store = SSL_CTX_get_cert_store(ctx->ctx);
+    
+    X509_STORE_add_cert(store, cert->subject);
+}
+
+void ne_ssl_trust_default_ca(ne_session *sess)
+{
+    X509_STORE *store = SSL_CTX_get_cert_store(sess->ssl_context->ctx);
+    
+#ifdef NE_SSL_CA_BUNDLE
+    X509_STORE_load_locations(store, NE_SSL_CA_BUNDLE, NULL);
+#else
+    X509_STORE_set_default_paths(store);
+#endif
+}
+
+/* Find a friendly name in a PKCS12 structure the hard way, without
+ * decrypting the parts which are encrypted.. */
+static char *find_friendly_name(PKCS12 *p12)
+{
+    STACK_OF(PKCS7) *safes = PKCS12_unpack_authsafes(p12);
+    int n, m;
+    char *name = NULL;
+
+    if (safes == NULL) return NULL;
+    
+    /* Iterate over the unpacked authsafes: */
+    for (n = 0; n < sk_PKCS7_num(safes) && !name; n++) {
+        PKCS7 *safe = sk_PKCS7_value(safes, n);
+        STACK_OF(PKCS12_SAFEBAG) *bags;
+    
+        /* Only looking for unencrypted authsafes. */
+        if (OBJ_obj2nid(safe->type) != NID_pkcs7_data) continue;
+
+        bags = PKCS12_unpack_p7data(safe);
+        if (!bags) continue;
+
+        /* Iterate through the bags, picking out a friendly name */
+        for (m = 0; m < sk_PKCS12_SAFEBAG_num(bags) && !name; m++) {
+            PKCS12_SAFEBAG *bag = sk_PKCS12_SAFEBAG_value(bags, m);
+            name = PKCS12_get_friendlyname(bag);
+        }
+    
+        sk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);
+    }
+
+    sk_PKCS7_pop_free(safes, PKCS7_free);
+    return name;
+}
+
+static ne_ssl_client_cert *parse_client_cert(PKCS12 *p12)
+{
+    X509 *cert;
+    EVP_PKEY *pkey;
+    ne_ssl_client_cert *cc;
+
+    if (p12 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+
+    /* Try parsing with no password. */
+    if (PKCS12_parse(p12, NULL, &pkey, &cert, NULL) == 1) {
+        /* Success - no password needed for decryption. */
+        int len = 0;
+        unsigned char *name;
+
+        if (!cert || !pkey) {
+            PKCS12_free(p12);
+            return NULL;
+        }
+
+        name = X509_alias_get0(cert, &len);
+        
+        cc = ne_calloc(sizeof *cc);
+        cc->pkey = pkey;
+        cc->decrypted = 1;
+        if (name && len > 0)
+            cc->friendly_name = ne_strndup((char *)name, len);
+        populate_cert(&cc->cert, cert);
+        PKCS12_free(p12);
+        return cc;
+    } else {
+        /* Failed to parse the file */
+        int err = ERR_get_error();
+        ERR_clear_error();
+        if (ERR_GET_LIB(err) == ERR_LIB_PKCS12 &&
+            ERR_GET_REASON(err) == PKCS12_R_MAC_VERIFY_FAILURE) {
+            /* Decryption error due to bad password. */
+            cc = ne_calloc(sizeof *cc);
+            cc->friendly_name = find_friendly_name(p12);
+            cc->p12 = p12;
+            return cc;
+        } else {
+            /* Some parse error, give up. */
+            PKCS12_free(p12);
+            return NULL;
+        }
+    }
+}
+
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, 
+                                          size_t buflen)
+{
+    ne_d2i_uchar *p;
+    PKCS12 *p12;
+
+    p = buffer;
+    p12 = d2i_PKCS12(NULL, &p, buflen);
+    
+    return parse_client_cert(p12);
+}
+    
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    PKCS12 *p12;
+    FILE *fp;
+
+    fp = fopen(filename, "rb");
+    if (fp == NULL)
+        return NULL;
+
+    p12 = d2i_PKCS12_fp(fp, NULL);
+
+    fclose(fp);
+
+    return parse_client_cert(p12);
+}
+
+#ifdef HAVE_PAKCHOIS
+ne_ssl_client_cert *ne__ssl_clicert_exkey_import(const unsigned char *der,
+                                                 size_t der_len,
+                                                 const RSA_METHOD *method)
+{
+    ne_ssl_client_cert *cc;
+    ne_d2i_uchar *p;
+    X509 *x5;
+    RSA *pk;    
+    EVP_PKEY *epk, *tpk;
+
+    p = der;
+    x5 = d2i_X509(NULL, &p, der_len); /* p is incremented */
+    if (x5 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+    
+    pk = RSA_new();
+    RSA_set_method(pk, method);
+    epk = EVP_PKEY_new();
+    EVP_PKEY_assign_RSA(epk, pk);
+    
+    /* It is necessary to initialize pk->n otherwise OpenSSL will barf
+     * later calling RSA_size() on this RSA structure.
+     * X509_get_pubkey() forces the relevant RSA parameters to be
+     * extracted from the certificate. */
+    tpk = X509_get_pubkey(x5);
+    pk->n = BN_dup(tpk->pkey.rsa->n);
+    EVP_PKEY_free(tpk);
+
+    cc = ne_calloc(sizeof *cc);
+    
+    cc->decrypted = 1;
+    cc->pkey = epk;
+
+    populate_cert(&cc->cert, x5);
+
+    return cc;    
+}
+#endif
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *cc)
+{
+    return !cc->decrypted;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *cc, const char *password)
+{
+    X509 *cert;
+    EVP_PKEY *pkey;
+
+    if (PKCS12_parse(cc->p12, password, &pkey, &cert, NULL) != 1) {
+        ERR_clear_error();
+        return -1;
+    }
+    
+    if (X509_check_private_key(cert, pkey) != 1) {
+        ERR_clear_error();
+        X509_free(cert);
+        EVP_PKEY_free(pkey);
+        NE_DEBUG(NE_DBG_SSL, "Decrypted private key/cert are not matched.");
+        return -1;
+    }
+
+    PKCS12_free(cc->p12);
+    populate_cert(&cc->cert, cert);
+    cc->pkey = pkey;
+    cc->decrypted = 1;
+    cc->p12 = NULL;
+    return 0;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *cc)
+{
+    return &cc->cert;
+}
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return ccert->friendly_name;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    FILE *fp = fopen(filename, "r");
+    X509 *cert;
+
+    if (fp == NULL)
+        return NULL;
+
+    cert = PEM_read_X509(fp, NULL, NULL, NULL);
+    fclose(fp);
+
+    if (cert == NULL) {
+        NE_DEBUG(NE_DBG_SSL, "d2i_X509_fp failed: %s\n", 
+                 ERR_reason_error_string(ERR_get_error()));
+        ERR_clear_error();
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), cert);
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    FILE *fp = fopen(filename, "w");
+
+    if (fp == NULL) return -1;
+
+    if (PEM_write_X509(fp, cert->subject) != 1) {
+        ERR_clear_error();
+        fclose(fp);
+        return -1;
+    }
+    
+    if (fclose(fp) != 0)
+        return -1;
+
+    return 0;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert)
+{
+    X509_free(cert->subject);
+    if (cert->issuer)
+        ne_ssl_cert_free(cert->issuer);
+    if (cert->identity)
+        ne_free(cert->identity);
+    ne_free(cert);
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    return X509_cmp(c1->subject, c2->subject);
+}
+
+/* The certificate import/export format is the base64 encoding of the
+ * raw DER; PEM without the newlines and wrapping. */
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    unsigned char *der;
+    ne_d2i_uchar *p;
+    size_t len;
+    X509 *x5;
+    
+    /* decode the base64 to get the raw DER representation */
+    len = ne_unbase64(data, &der);
+    if (len == 0) return NULL;
+
+    p = der;
+    x5 = d2i_X509(NULL, &p, len); /* p is incremented */
+    ne_free(der);
+    if (x5 == NULL) {
+        ERR_clear_error();
+        return NULL;
+    }
+
+    return populate_cert(ne_calloc(sizeof(struct ne_ssl_certificate_s)), x5);
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    int len;
+    unsigned char *der, *p;
+    char *ret;
+    
+    /* find the length of the DER encoding. */
+    len = i2d_X509(cert->subject, NULL);
+
+    p = der = ne_malloc(len);
+    i2d_X509(cert->subject, &p); /* p is incremented */
+
+    ret = ne_base64(der, len);
+    ne_free(der);
+    return ret;
+}
+
+#if SHA_DIGEST_LENGTH != 20
+# error SHA digest length is not 20 bytes
+#endif
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest)
+{
+    unsigned char sha1[EVP_MAX_MD_SIZE];
+    unsigned int len, j;
+    char *p;
+
+    if (!X509_digest(cert->subject, EVP_sha1(), sha1, &len) || len != 20) {
+        ERR_clear_error();
+        return -1;
+    }
+    
+    for (j = 0, p = digest; j < 20; j++) {
+        *p++ = NE_HEX2ASC((sha1[j] >> 4) & 0x0f);
+        *p++ = NE_HEX2ASC(sha1[j] & 0x0f);
+        *p++ = ':';
+    }
+
+    p[-1] = '\0';
+    return 0;
+}
+
+#ifdef NE_HAVE_TS_SSL
+/* Implementation of locking callbacks to make OpenSSL thread-safe.
+ * If the OpenSSL API was better designed, this wouldn't be necessary.
+ * In OpenSSL releases without CRYPTO_set_idptr_callback, it's not
+ * possible to implement the locking in a POSIX-compliant way, since
+ * it's necessary to cast from a pthread_t to an unsigned long at some
+ * point.  */
+
+#ifndef _WIN32
+static pthread_mutex_t *locks;
+#else
+static HANDLE *locks;
+#endif
+static size_t num_locks;
+
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+/* Named to be obvious when it shows up in a backtrace. */
+static unsigned long thread_id_neon(void)
+{
+#ifndef _WIN32
+    /* This will break if pthread_t is a structure; upgrading OpenSSL
+     * >= 0.9.9 (which does not require this callback) is the only
+     * solution.  */
+    return (unsigned long) pthread_self();
+#else
+    return (unsigned long) GetCurrentThreadId();
+#endif
+}
+#endif
+
+/* Another great API design win for OpenSSL: no return value!  So if
+ * the lock/unlock fails, all that can be done is to abort. */
+static void thread_lock_neon(int mode, int n, const char *file, int line)
+{
+    if (mode & CRYPTO_LOCK) {
+#ifndef _WIN32
+        if (pthread_mutex_lock(&locks[n])) {
+#else
+        if (WaitForSingleObject(locks[n], INFINITE)) {
+#endif
+            abort();
+        }
+    }
+    else {
+#ifndef _WIN32
+        if (pthread_mutex_unlock(&locks[n])) {
+#else
+        if (!ReleaseMutex(locks[n])) {
+#endif
+            abort();
+        }
+    }
+}
+
+#endif
+
+/* ID_CALLBACK_IS_{NEON,OTHER} evaluate as true if the currently
+ * registered OpenSSL ID callback is the neon function (_NEON), or has
+ * been overwritten by some other app (_OTHER). */
+#ifdef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+#define ID_CALLBACK_IS_OTHER (0)
+#define ID_CALLBACK_IS_NEON (1)
+#else
+#define ID_CALLBACK_IS_OTHER (CRYPTO_get_id_callback() != NULL)
+#define ID_CALLBACK_IS_NEON (CRYPTO_get_id_callback() == thread_id_neon)
+#endif
+
+int ne__ssl_init(void)
+{
+    CRYPTO_malloc_init();
+    SSL_load_error_strings();
+    SSL_library_init();
+    OpenSSL_add_all_algorithms();
+
+#ifdef NE_HAVE_TS_SSL
+    /* If some other library has already come along and set up the
+     * thread-safety callbacks, then it must be presumed that the
+     * other library will have a longer lifetime in the process than
+     * neon.  If the library which has installed the callbacks is
+     * unloaded, then all bets are off. */
+    if (ID_CALLBACK_IS_OTHER || CRYPTO_get_locking_callback() != NULL) {
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: OpenSSL thread-safety callbacks already installed.\n");
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: neon will not replace existing callbacks.\n");
+    } else {
+        size_t n;
+
+        num_locks = CRYPTO_num_locks();
+
+        /* For releases where CRYPTO_set_idptr_callback is present,
+         * the default ID callback should be sufficient. */
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+        CRYPTO_set_id_callback(thread_id_neon);
+#endif
+        CRYPTO_set_locking_callback(thread_lock_neon);
+
+        locks = malloc(num_locks * sizeof *locks);
+        for (n = 0; n < num_locks; n++) {
+#ifndef _WIN32
+            if (pthread_mutex_init(&locks[n], NULL)) {
+#else
+            if ((locks[n] = CreateMutex(NULL, FALSE, NULL)) == NULL) {
+#endif
+                NE_DEBUG(NE_DBG_SOCKET, "ssl: Failed to initialize pthread mutex.\n");
+                return -1;
+            }
+        }
+        
+        NE_DEBUG(NE_DBG_SOCKET, "ssl: Initialized OpenSSL thread-safety callbacks "
+                 "for %" NE_FMT_SIZE_T " locks.\n", num_locks);
+    }
+#endif
+
+    return 0;
+}
+
+void ne__ssl_exit(void)
+{
+    /* Cannot call ERR_free_strings() etc here in case any other code
+     * in the process using OpenSSL. */
+
+#ifdef NE_HAVE_TS_SSL
+    /* Only unregister the callbacks if some *other* library has not
+     * come along in the mean-time and trampled over the callbacks
+     * installed by neon. */
+    if (CRYPTO_get_locking_callback() == thread_lock_neon
+        && ID_CALLBACK_IS_NEON) {
+        size_t n;
+
+#ifndef HAVE_CRYPTO_SET_IDPTR_CALLBACK
+        CRYPTO_set_id_callback(NULL);
+#endif
+        CRYPTO_set_locking_callback(NULL);
+
+        for (n = 0; n < num_locks; n++) {
+#ifndef _WIN32
+            pthread_mutex_destroy(&locks[n]);
+#else
+            CloseHandle(locks[n]);
+#endif
+        }
+
+        free(locks);
+    }
+#endif
+}
diff --git a/net/mmt/neon/src/ne_pkcs11.c b/net/mmt/neon/src/ne_pkcs11.c
new file mode 100644
index 0000000..69875b6
--- /dev/null
+++ b/net/mmt/neon/src/ne_pkcs11.c
@@ -0,0 +1,625 @@
+/*
+   neon PKCS#11 support
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include "ne_pkcs11.h"
+
+#ifdef HAVE_PAKCHOIS
+#include <string.h>
+
+#include <pakchois.h>
+
+#include "ne_internal.h"
+#include "ne_alloc.h"
+#include "ne_private.h"
+#include "ne_privssl.h"
+
+struct ne_ssl_pkcs11_provider_s {
+    pakchois_module_t *module;
+    ne_ssl_pkcs11_pin_fn pin_fn;
+    void *pin_data;
+    pakchois_session_t *session;
+    ne_ssl_client_cert *clicert;
+    ck_object_handle_t privkey;
+    ck_key_type_t keytype;
+};
+
+/* To do list for PKCS#11 support:
+
+   - propagate error strings back to ne_session; use new 
+   pakchois_error() for pakchois API 0.2
+   - add API to specify a particular slot number to use for clicert
+   - add API to specify a particular cert ID for clicert
+   - find a certificate which has an issuer matching the 
+     CA dnames given by GnuTLS
+   - make sure subject name matches between pubkey and privkey
+   - check error handling & fail gracefully if the token is 
+   ejected mid-session
+   - add API to enumerate/search provided certs and allow 
+     direct choice? (or just punt)
+   - the session<->provider interface requires that 
+   one clicert is used for all sessions.  remove this limitation
+   - add API to import all CA certs as trusted
+   (CKA_CERTIFICATE_CATEGORY seems to be unused unfortunately; 
+    just add all X509 certs with CKA_TRUSTED set to true))
+   - make DSA work
+
+*/
+
+#ifdef HAVE_OPENSSL
+
+#include <openssl/rsa.h>
+#include <openssl/err.h>
+
+#define PK11_RSA_ERR (RSA_F_RSA_EAY_PRIVATE_ENCRYPT)
+
+/* RSA_METHOD ->rsa_sign calback. */
+static int pk11_rsa_sign(int type,
+                         const unsigned char *m, unsigned int mlen,
+                         unsigned char *sigret, unsigned int *siglen, 
+                         const RSA *r)
+{
+    ne_ssl_pkcs11_provider *prov = (ne_ssl_pkcs11_provider *)r->meth->app_data;
+    ck_rv_t rv;
+    struct ck_mechanism mech;
+    unsigned long len;
+
+    if (!prov->session || prov->privkey == CK_INVALID_HANDLE) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Cannot sign, no session/key.\n");
+        RSAerr(PK11_RSA_ERR,ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    mech.mechanism = CKM_RSA_PKCS;
+    mech.parameter = NULL;
+    mech.parameter_len = 0;
+
+    /* Initialize signing operation; using the private key discovered
+     * earlier. */
+    rv = pakchois_sign_init(prov->session, &mech, prov->privkey);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: SignInit failed: %lx.\n", rv);
+        RSAerr(PK11_RSA_ERR, ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    len = *siglen = RSA_size(r);
+    rv = pakchois_sign(prov->session, (unsigned char *)m, mlen, sigret, &len);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign failed.\n");
+        RSAerr(PK11_RSA_ERR, ERR_R_RSA_LIB);
+        return 0;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Signed successfully.\n");
+    return 1;
+}
+
+/* RSA_METHOD ->rsa_init implementation; called during RSA_new(rsa). */
+static int pk11_rsa_init(RSA *rsa)
+{
+    /* Ensures that RSA_sign() uses meth->rsa_sign: */
+    rsa->flags |= RSA_FLAG_SIGN_VER;
+    return 1;
+}
+
+/* RSA_METHOD ->rsa_finish implementation; called during
+ * RSA_free(rsa). */
+static int pk11_rsa_finish(RSA *rsa)
+{
+    RSA_METHOD *meth = (RSA_METHOD *)rsa->meth;
+
+    /* Freeing the dynamically allocated method here works as well as
+     * doing anything else: */
+    ne_free(meth);
+    /* Does not appear that rsa->meth will be used after this, but in
+     * case it is, ensure a NULL pointer dereference rather than a
+     * random pointer dereference. */
+    rsa->meth = NULL;
+
+    return 0;
+}
+
+/* Return an RSA_METHOD which will use the PKCS#11 provider to
+ * implement the signing operation. */
+static RSA_METHOD *pk11_rsa_method(ne_ssl_pkcs11_provider *prov)
+{
+    RSA_METHOD *m = ne_calloc(sizeof *m);
+
+    m->name = "neon PKCS#11";
+    m->rsa_sign = pk11_rsa_sign;
+    
+    m->init = pk11_rsa_init;
+    m->finish = pk11_rsa_finish;
+    
+    /* This is hopefully under complete control of the RSA_METHOD,
+     * otherwise there is nowhere to put this. */
+    m->app_data = (char *)prov;
+
+    m->flags = RSA_METHOD_FLAG_NO_CHECK;
+    
+    return m;    
+}
+#endif
+
+static int pk11_find_x509(ne_ssl_pkcs11_provider *prov,
+                          pakchois_session_t *pks, 
+                          unsigned char *certid, unsigned long *cid_len)
+{
+    struct ck_attribute a[3];
+    ck_object_class_t class;
+    ck_certificate_type_t type;
+    ck_rv_t rv;
+    ck_object_handle_t obj;
+    unsigned long count;
+    int found = 0;
+
+    /* Find objects with cert class and X.509 cert type. */
+    class = CKO_CERTIFICATE;
+    type = CKC_X_509;
+
+    a[0].type = CKA_CLASS;
+    a[0].value = &class;
+    a[0].value_len = sizeof class;
+    a[1].type = CKA_CERTIFICATE_TYPE;
+    a[1].value = &type;
+    a[1].value_len = sizeof type;
+
+    rv = pakchois_find_objects_init(pks, a, 2);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: FindObjectsInit failed.\n");
+        return 0;
+    }
+
+    while (pakchois_find_objects(pks, &obj, 1, &count) == CKR_OK
+           && count == 1) {
+        unsigned char value[8192], subject[8192];
+
+        a[0].type = CKA_VALUE;
+        a[0].value = value;
+        a[0].value_len = sizeof value;
+        a[1].type = CKA_ID;
+        a[1].value = certid;
+        a[1].value_len = *cid_len;
+        a[2].type = CKA_SUBJECT;
+        a[2].value = subject;
+        a[2].value_len = sizeof subject;
+
+        if (pakchois_get_attribute_value(pks, obj, a, 3) == CKR_OK) {
+            ne_ssl_client_cert *cc;
+            
+#ifdef HAVE_GNUTLS
+            cc = ne__ssl_clicert_exkey_import(value, a[0].value_len);
+#else
+            cc = ne__ssl_clicert_exkey_import(value, a[0].value_len, pk11_rsa_method(prov));
+#endif
+            if (cc) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: Imported X.509 cert.\n");
+                prov->clicert = cc;
+                found = 1;
+                *cid_len = a[1].value_len;
+                break;
+            }
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Skipped cert, missing attrs.\n");
+        }
+    }
+
+    pakchois_find_objects_final(pks);
+    return found;    
+}
+
+#ifdef HAVE_OPENSSL
+/* No DSA support for OpenSSL (yet, anyway). */
+#define KEYTYPE_IS_DSA(kt) (0)
+#else
+#define KEYTYPE_IS_DSA(kt) (kt == CKK_DSA)
+#endif
+
+static int pk11_find_pkey(ne_ssl_pkcs11_provider *prov, 
+                          pakchois_session_t *pks,
+                          unsigned char *certid, unsigned long cid_len)
+{
+    struct ck_attribute a[3];
+    ck_object_class_t class;
+    ck_rv_t rv;
+    ck_object_handle_t obj;
+    unsigned long count;
+    int found = 0;
+
+    class = CKO_PRIVATE_KEY;
+
+    /* Find an object with private key class and a certificate ID
+     * which matches the certificate. */
+    /* FIXME: also match the cert subject. */
+    a[0].type = CKA_CLASS;
+    a[0].value = &class;
+    a[0].value_len = sizeof class;
+    a[1].type = CKA_ID;
+    a[1].value = certid;
+    a[1].value_len = cid_len;
+
+    rv = pakchois_find_objects_init(pks, a, 2);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: FindObjectsInit failed.\n");
+        /* TODO: error propagation */
+        return 0;
+    }
+
+    rv = pakchois_find_objects(pks, &obj, 1, &count);
+    if (rv == CKR_OK && count == 1) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Found private key.\n");
+
+        a[0].type = CKA_KEY_TYPE;
+        a[0].value = &prov->keytype;
+        a[0].value_len = sizeof prov->keytype;
+
+        if (pakchois_get_attribute_value(pks, obj, a, 1) == CKR_OK
+            && (prov->keytype == CKK_RSA || KEYTYPE_IS_DSA(prov->keytype))) {
+            found = 1;
+            prov->privkey = obj;
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Could not determine key type.\n");
+        }
+    }
+
+    pakchois_find_objects_final(pks);
+
+    return found;
+}
+
+static int find_client_cert(ne_ssl_pkcs11_provider *prov,
+                            pakchois_session_t *pks)
+{
+    unsigned char certid[8192];
+    unsigned long cid_len = sizeof certid;
+
+    /* TODO: match cert subject too. */
+    return pk11_find_x509(prov, pks, certid, &cid_len) 
+        && pk11_find_pkey(prov, pks, certid, cid_len);
+}
+
+#ifdef HAVE_GNUTLS
+/* Callback invoked by GnuTLS to provide the signature.  The signature
+ * operation is handled here by the PKCS#11 provider.  */
+static int pk11_sign_callback(gnutls_session_t session,
+                              void *userdata,
+                              gnutls_certificate_type_t cert_type,
+                              const gnutls_datum_t *cert,
+                              const gnutls_datum_t *hash,
+                              gnutls_datum_t *signature)
+{
+    ne_ssl_pkcs11_provider *prov = userdata;
+    ck_rv_t rv;
+    struct ck_mechanism mech;
+    unsigned long siglen;
+
+    if (!prov->session || prov->privkey == CK_INVALID_HANDLE) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Cannot sign, no session/key.\n");
+        return GNUTLS_E_NO_CERTIFICATE_FOUND;
+    }
+
+    mech.mechanism = prov->keytype == CKK_DSA ? CKM_DSA : CKM_RSA_PKCS;
+    mech.parameter = NULL;
+    mech.parameter_len = 0;
+
+    /* Initialize signing operation; using the private key discovered
+     * earlier. */
+    rv = pakchois_sign_init(prov->session, &mech, prov->privkey);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: SignInit failed: %lx.\n", rv);
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    /* Work out how long the signature must be: */
+    rv = pakchois_sign(prov->session, hash->data, hash->size, NULL, &siglen);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign1 failed.\n");
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    signature->data = gnutls_malloc(siglen);
+    signature->size = siglen;
+
+    rv = pakchois_sign(prov->session, hash->data, hash->size, 
+                       signature->data, &siglen);
+    if (rv != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Sign2 failed.\n");
+        return GNUTLS_E_PK_SIGN_FAILED;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Signed successfully.\n");
+
+    return 0;
+}
+#endif
+
+static void terminate_string(unsigned char *str, size_t len)
+{
+    unsigned char *ptr = str + len - 1;
+
+    while ((*ptr == ' ' || *ptr == '\t' || *ptr == '\0') && ptr >= str)
+        ptr--;
+    
+    if (ptr == str - 1)
+        str[0] = '\0';
+    else if (ptr == str + len - 1)
+        str[len-1] = '\0';
+    else
+        ptr[1] = '\0';
+}
+
+static int pk11_login(ne_ssl_pkcs11_provider *prov, ck_slot_id_t slot_id,
+                      pakchois_session_t *pks, struct ck_slot_info *sinfo)
+{
+    struct ck_token_info tinfo;
+    int attempt = 0;
+    ck_rv_t rv;
+
+    if (pakchois_get_token_info(prov->module, slot_id, &tinfo) != CKR_OK) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: GetTokenInfo failed\n");
+        /* TODO: propagate error. */
+        return -1;
+    }
+
+    if ((tinfo.flags & CKF_LOGIN_REQUIRED) == 0) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No login required.\n");
+        return 0;
+    }
+
+    /* For a token with a "protected" (out-of-band) authentication
+     * path, calling login with a NULL username is all that is
+     * required. */
+    if (tinfo.flags & CKF_PROTECTED_AUTHENTICATION_PATH) {
+        if (pakchois_login(pks, CKU_USER, NULL, 0) == CKR_OK) {
+            return 0;
+        }
+        else {
+            NE_DEBUG(NE_DBG_SSL, "pk11: Protected login failed.\n");
+            /* TODO: error propagation. */
+            return -1;
+        }
+    }
+
+    /* Otherwise, PIN entry is necessary for login, so fail if there's
+     * no callback. */
+    if (!prov->pin_fn) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No pin callback but login required.\n");
+        /* TODO: propagate error. */
+        return -1;
+    }
+
+    terminate_string(sinfo->slot_description, sizeof sinfo->slot_description);
+
+    do {
+        char pin[NE_SSL_P11PINLEN];
+        unsigned int flags = 0;
+
+        /* If login has been attempted once already, check the token
+         * status again, the flags might change. */
+        if (attempt) {
+            if (pakchois_get_token_info(prov->module, slot_id, 
+                                        &tinfo) != CKR_OK) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: GetTokenInfo failed\n");
+                /* TODO: propagate error. */
+                return -1;
+            }
+        }
+
+        if (tinfo.flags & CKF_USER_PIN_COUNT_LOW)
+            flags |= NE_SSL_P11PIN_COUNT_LOW;
+        if (tinfo.flags & CKF_USER_PIN_FINAL_TRY)
+            flags |= NE_SSL_P11PIN_FINAL_TRY;
+        
+        terminate_string(tinfo.label, sizeof tinfo.label);
+
+        if (prov->pin_fn(prov->pin_data, attempt++,
+                         (char *)sinfo->slot_description,
+                         (char *)tinfo.label, flags, pin)) {
+            return -1;
+        }
+
+        rv = pakchois_login(pks, CKU_USER, (unsigned char *)pin, strlen(pin));
+        
+        /* Try to scrub the pin off the stack.  Clever compilers will
+         * probably optimize this away, oh well. */
+        memset(pin, 0, sizeof pin);
+    } while (rv == CKR_PIN_INCORRECT);
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Login result = %lu\n", rv);
+
+    return (rv == CKR_OK || rv == CKR_USER_ALREADY_LOGGED_IN) ? 0 : -1;
+}
+
+static void pk11_provide(void *userdata, ne_session *sess,
+                         const ne_ssl_dname *const *dnames,
+                         int dncount)
+{
+    ne_ssl_pkcs11_provider *prov = userdata;
+    ck_slot_id_t *slots;
+    unsigned long scount, n;
+
+    if (prov->clicert) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: Using existing clicert.\n");
+        ne_ssl_set_clicert(sess, prov->clicert);
+        return;
+    }
+
+    if (pakchois_get_slot_list(prov->module, 1, NULL, &scount) != CKR_OK
+        || scount == 0) {
+        NE_DEBUG(NE_DBG_SSL, "pk11: No slots.\n");
+        /* TODO: propagate error. */
+        return;
+    }
+
+    slots = ne_malloc(scount * sizeof *slots);
+    if (pakchois_get_slot_list(prov->module, 1, slots, &scount) != CKR_OK)  {
+        ne_free(slots);
+        NE_DEBUG(NE_DBG_SSL, "pk11: Really, no slots?\n");
+        /* TODO: propagate error. */
+        return;
+    }
+
+    NE_DEBUG(NE_DBG_SSL, "pk11: Found %ld slots.\n", scount);
+
+    for (n = 0; n < scount; n++) {
+        pakchois_session_t *pks;
+        ck_rv_t rv;
+        struct ck_slot_info sinfo;
+
+        if (pakchois_get_slot_info(prov->module, slots[n], &sinfo) != CKR_OK) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: GetSlotInfo failed\n");
+            continue;
+        }
+
+        if ((sinfo.flags & CKF_TOKEN_PRESENT) == 0) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: slot empty, ignoring\n");
+            continue;
+        }
+        
+        rv = pakchois_open_session(prov->module, slots[n], 
+                                   CKF_SERIAL_SESSION,
+                                   NULL, NULL, &pks);
+        if (rv != CKR_OK) {
+            NE_DEBUG(NE_DBG_SSL, "pk11: could not open slot, %ld (%ld: %ld)\n", 
+                     rv, n, slots[n]);
+            continue;
+        }
+
+        if (pk11_login(prov, slots[n], pks, &sinfo) == 0) {
+            if (find_client_cert(prov, pks)) {
+                NE_DEBUG(NE_DBG_SSL, "pk11: Setup complete.\n");
+                prov->session = pks;
+                ne_ssl_set_clicert(sess, prov->clicert);
+                ne_free(slots);
+                return;
+            }
+        }
+
+        pakchois_close_session(pks);
+    }
+
+    ne_free(slots);
+}
+
+static int pk11_init(ne_ssl_pkcs11_provider **provider,
+                     pakchois_module_t *module)
+{
+    ne_ssl_pkcs11_provider *prov;
+
+    prov = *provider = ne_calloc(sizeof *prov);
+    prov->module = module;
+    prov->privkey = CK_INVALID_HANDLE;
+
+    return NE_PK11_OK;
+}
+
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name)
+{
+    pakchois_module_t *pm;
+    
+    if (pakchois_module_load(&pm, name) == CKR_OK) {
+        return pk11_init(provider, pm);
+    }
+    else {
+        return NE_PK11_FAILED;
+    }
+}
+
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db)
+{
+    pakchois_module_t *pm;
+    
+    if (pakchois_module_nssload(&pm, name, directory, cert_prefix,
+                                key_prefix, secmod_db) == CKR_OK) {
+        return pk11_init(provider, pm);
+    }
+    else {
+        return NE_PK11_FAILED;
+    }
+}
+
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata)
+{
+    provider->pin_fn = fn;
+    provider->pin_data = userdata;
+}
+
+void ne_ssl_set_pkcs11_provider(ne_session *sess, 
+                                ne_ssl_pkcs11_provider *provider)
+{
+#ifdef HAVE_GNUTLS
+    sess->ssl_context->sign_func = pk11_sign_callback;
+    sess->ssl_context->sign_data = provider;
+#endif
+
+    ne_ssl_provide_clicert(sess, pk11_provide, provider);
+}
+
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *prov)
+{
+    if (prov->session) {
+        pakchois_close_session(prov->session);
+    }
+    if (prov->clicert) {
+        ne_ssl_clicert_free(prov->clicert);
+    }
+    pakchois_module_destroy(prov->module);
+    ne_free(prov);
+}
+
+#else /* !HAVE_PAKCHOIS */
+
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name)
+{
+    return NE_PK11_NOTIMPL;
+}
+
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db)
+{
+    return NE_PK11_NOTIMPL;
+}
+
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *provider) { }
+
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata) { }
+
+void ne_ssl_set_pkcs11_provider(ne_session *sess,
+                                ne_ssl_pkcs11_provider *provider) { }
+
+#endif /* HAVE_PAKCHOIS */
+
diff --git a/net/mmt/neon/src/ne_pkcs11.h b/net/mmt/neon/src/ne_pkcs11.h
new file mode 100644
index 0000000..4cefeb0
--- /dev/null
+++ b/net/mmt/neon/src/ne_pkcs11.h
@@ -0,0 +1,110 @@
+/* 
+   PKCS#11 support for neon
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_PKCS11_H
+#define NE_PKCS11_H 1
+
+#include "ne_defs.h"
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_ssl_pkcs11_provider_s ne_ssl_pkcs11_provider;
+
+#define NE_PK11_OK (0)
+#define NE_PK11_NOTIMPL (-1)
+#define NE_PK11_FAILED (-2)
+
+/* Initialize a PKCS#11 provider of given name.  Returns NE_OK on
+ * success, NE_PK11_FAILED if the provider could not be
+ * loaded/initialized, and NE_PK11_NOTIMPL if PKCS#11 is not
+ * supported.  On success, *provider is set to non-NULL.  */
+int ne_ssl_pkcs11_provider_init(ne_ssl_pkcs11_provider **provider,
+                                const char *name);
+
+/* Initialize a NSS softoken pseudo-PKCS#11 provider of given name
+ * (e.g. "softokn3") to supply a client certificate if requested,
+ * using database in given directory name; the other parameters may be
+ * NULL.  Returns NE_OK on success, NE_PK11_FAILED if the provider
+ * could not be loaded/initialized, and NE_PK11_NOTIMPL if PKCS#11 is
+ * not supported.  On success, *provider is set to non-NULL. */
+int ne_ssl_pkcs11_nss_provider_init(ne_ssl_pkcs11_provider **provider,
+                                    const char *name, const char *directory,
+                                    const char *cert_prefix, 
+                                    const char *key_prefix,
+                                    const char *secmod_db);
+
+/* Destroy a PKCS#11 provider object. */
+void ne_ssl_pkcs11_provider_destroy(ne_ssl_pkcs11_provider *provider);
+
+
+/* Flags passed to PIN entry callback: */
+#define NE_SSL_P11PIN_COUNT_LOW (0x01) /* an incorrect PIN has been
+                                        * entered. */
+#define NE_SSL_P11PIN_FINAL_TRY (0x02) /* token will become locked if
+                                        * entered PIN is incorrect */
+
+/* Size of buffer passed to PIN entry callback: */
+#define NE_SSL_P11PINLEN (256)
+
+/* Callback for PKCS#11 PIN entry.  The callback provides the PIN code
+ * to unlock the token with label 'token_label' in the slot described
+ * by 'slot_descr'.
+ *
+ * The PIN code, as a NUL-terminated ASCII string, should be copied
+ * into the 'pin' buffer (of fixed length NE_SSL_P11PINLEN), and
+ * return 0 to indicate success. Alternatively, the callback may
+ * return -1 to indicate failure and cancel PIN entry (in which case,
+ * the contents of the 'pin' parameter are ignored).
+ *
+ * When a PIN is required, the callback will be invoked repeatedly
+ * (and indefinitely) until either the returned PIN code is correct,
+ * the callback returns failure, or the token refuses login (e.g. when
+ * the token is locked due to too many incorrect PINs!).  For the
+ * first such invocation, the 'attempt' counter will have value zero;
+ * it will increase by one for each subsequent attempt.
+ *
+ * The NE_SSL_P11PIN_COUNT_LOW and/or NE_SSL_P11PIN_FINAL_TRY hints
+ * may be set in the 'flags' argument, if these hints are made
+ * available by the token; not all tokens expose these hints. */
+typedef int (*ne_ssl_pkcs11_pin_fn)(void *userdata, int attempt,
+                                    const char *slot_descr,
+                                    const char *token_label,
+                                    unsigned int flags,
+                                    char *pin);
+
+/* Set the PIN entry callback for the given provider.  This is
+ * necessary for some (but not all) types of token.  For tokens which
+ * implement an out-of-band ("protected") authentication path, the PIN
+ * entry callback will not be invoked. */
+void ne_ssl_pkcs11_provider_pin(ne_ssl_pkcs11_provider *provider,
+                                ne_ssl_pkcs11_pin_fn fn,
+                                void *userdata);
+
+/* Set up a given PKCS#11 provider to supply an appropriate client
+ * certificate if requested by the server.  A provider may be
+ * configured for use in multiple sessions. */
+void ne_ssl_set_pkcs11_provider(ne_session *sess,
+                                ne_ssl_pkcs11_provider *provider);
+
+NE_END_DECLS
+
+#endif /* NE_PKCS11_H */
diff --git a/net/mmt/neon/src/ne_private.h b/net/mmt/neon/src/ne_private.h
new file mode 100644
index 0000000..a2c5fcf
--- /dev/null
+++ b/net/mmt/neon/src/ne_private.h
@@ -0,0 +1,154 @@
+/* 
+   HTTP Request Handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* THIS IS NOT A PUBLIC INTERFACE. You CANNOT include this header file
+ * from an application.  */
+ 
+#ifndef NE_PRIVATE_H
+#define NE_PRIVATE_H
+
+#include "ne_request.h"
+#include "ne_socket.h"
+#include "ne_ssl.h"
+
+struct host_info {
+    /* Type of host represented: */
+    enum proxy_type {
+        PROXY_NONE = 0,
+        PROXY_HTTP, /* an HTTP proxy */
+        PROXY_SOCKS /* a SOCKS proxy */
+    } proxy;
+    unsigned int port;
+    /* If hostname is non-NULL, host is identified by this hostname. */
+    char *hostname, *hostport;
+    /* If address is non-NULL, the result of resolving ->hostname. */
+    ne_sock_addr *address;
+    /* If current non-NULL, current network address used in ->address. */
+    const ne_inet_addr *current;
+    /* If override is non-NULL, the host is identified by this network
+     * address. */
+    const ne_inet_addr *network;
+    struct host_info *next;
+};
+
+/* Store every registered callback in a generic container, and cast
+ * the function pointer when calling it.  */
+struct hook {
+    void (*fn)(void);
+    void *userdata;
+    const char *id; /* non-NULL for accessors. */
+    struct hook *next;
+};
+
+#define HAVE_HOOK(st,func) (st->hook->hooks->func != NULL)
+#define HOOK_FUNC(st, func) (*st->hook->hooks->func)
+
+/* Session support. */
+struct ne_session_s {
+    /* Connection information */
+    ne_socket *socket;
+
+    /* non-zero if connection has been established. */
+    int connected;
+    
+    /* non-zero if connection has persisted beyond one request. */
+    int persisted;
+
+    int is_http11; /* >0 if connected server is known to be
+		    * HTTP/1.1 compliant. */
+
+    char *scheme;
+
+    /* Server host details. */
+    struct host_info server;
+    /* Proxy host details, or NULL if not using a proxy. */
+    struct host_info *proxies;
+    /* Most recently used proxy server. */
+    struct host_info *prev_proxy;
+
+    /* Pointer to the active .server or .proxies as appropriate: */
+    struct host_info *nexthop;
+
+    /* Local address to which sockets should be bound. */
+    const ne_inet_addr *local_addr;
+
+    /* Settings */
+    int use_ssl; /* whether a secure connection is required */
+    int in_connect; /* doing a proxy CONNECT */
+    int any_proxy_http; /* whether any configured proxy is an HTTP proxy */
+    
+    enum ne_sock_sversion socks_ver;
+    char *socks_user, *socks_password;
+
+    int flags[NE_SESSFLAG_LAST];
+
+    ne_progress progress_cb;
+    void *progress_ud;
+
+    ne_notify_status notify_cb;
+    void *notify_ud;
+
+    int rdtimeout, cotimeout; /* read, connect timeouts. */
+
+    struct hook *create_req_hooks, *pre_send_hooks, *post_send_hooks,
+        *post_headers_hooks, *destroy_req_hooks, *destroy_sess_hooks, 
+        *close_conn_hooks, *private;
+
+    char *user_agent; /* full User-Agent: header field */
+
+#ifdef NE_HAVE_SSL
+    ne_ssl_client_cert *client_cert;
+    ne_ssl_certificate *server_cert;
+    ne_ssl_context *ssl_context;
+    int ssl_cc_requested; /* set to non-zero if a client cert was
+                           * requested during initial handshake, but
+                           * none could be provided. */
+#endif
+
+    /* Server cert verification callback: */
+    ne_ssl_verify_fn ssl_verify_fn;
+    void *ssl_verify_ud;
+    /* Client cert provider callback: */
+    ne_ssl_provide_fn ssl_provide_fn;
+    void *ssl_provide_ud;
+
+    ne_session_status_info status;
+
+    /* Error string */
+    char error[512];
+};
+
+/* Pushes block of 'count' bytes at 'buf'. Returns non-zero on
+ * error. */
+typedef int (*ne_push_fn)(void *userdata, const char *buf, size_t count);
+
+/* Do the SSL negotiation. */
+NE_PRIVATE int ne__negotiate_ssl(ne_session *sess);
+
+/* Set the session error appropriate for SSL verification failures. */
+NE_PRIVATE void ne__ssl_set_verify_err(ne_session *sess, int failures);
+
+/* Return non-zero if hostname from certificate (cn) matches hostname
+ * used for session (hostname); follows RFC2818 logic. */
+NE_PRIVATE int ne__ssl_match_hostname(const char *cn, size_t cnlen, 
+                                      const char *hostname);
+
+#endif /* HTTP_PRIVATE_H */
diff --git a/net/mmt/neon/src/ne_privssl.h b/net/mmt/neon/src/ne_privssl.h
new file mode 100644
index 0000000..57d53c8
--- /dev/null
+++ b/net/mmt/neon/src/ne_privssl.h
@@ -0,0 +1,106 @@
+/* 
+   SSL interface definitions internal to neon.
+   Copyright (C) 2003-2005, 2008, 2009, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004, Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* THIS IS NOT A PUBLIC INTERFACE. You CANNOT include this header file
+ * from an application.  */
+ 
+#ifndef NE_PRIVSSL_H
+#define NE_PRIVSSL_H
+
+/* This is the private interface between ne_socket, ne_gnutls and
+ * ne_openssl. */
+
+#include "ne_ssl.h"
+#include "ne_socket.h"
+
+#ifdef HAVE_OPENSSL
+
+#include <openssl/ssl.h>
+
+struct ne_ssl_context_s {
+    SSL_CTX *ctx;
+    SSL_SESSION *sess;
+    const char *hostname; /* for SNI */
+    int failures; /* bitmask of exposed failure bits. */
+};
+
+typedef SSL *ne_ssl_socket;
+
+/* Create a clicert object from cert DER {der, der_len}, using given
+ * RSA_METHOD for the RSA object. */
+NE_PRIVATE ne_ssl_client_cert *
+ne__ssl_clicert_exkey_import(const unsigned char *der,
+                             size_t der_len,
+                             const RSA_METHOD *method);
+
+#endif /* HAVE_OPENSSL */
+
+#ifdef HAVE_GNUTLS
+
+#include <gnutls/gnutls.h>
+
+struct ne_ssl_context_s {
+    gnutls_certificate_credentials_t cred;
+    int verify; /* non-zero if client cert verification required */
+
+    const char *hostname; /* for SNI */
+
+    /* Session cache. */
+    union ne_ssl_scache {
+        struct {
+            gnutls_datum_t key, data;
+        } server;
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_datum_t client;
+#else
+        struct {
+            char *data;
+            size_t len;
+        } client;
+#endif
+    } cache;
+
+#ifdef HAVE_GNUTLS_SIGN_CALLBACK_SET
+    gnutls_sign_func sign_func;
+    void *sign_data;
+#endif
+};
+
+typedef gnutls_session_t ne_ssl_socket;
+
+NE_PRIVATE ne_ssl_client_cert *
+ne__ssl_clicert_exkey_import(const unsigned char *der, size_t der_len);
+
+#endif /* HAVE_GNUTLS */
+
+#ifdef NE_HAVE_SSL
+NE_PRIVATE ne_ssl_socket ne__sock_sslsock(ne_socket *sock);
+
+/* Process-global initialization of the SSL library; returns non-zero
+ * on error. */
+NE_PRIVATE int ne__ssl_init(void);
+
+/* Process-global de-initialization of the SSL library. */
+NE_PRIVATE void ne__ssl_exit(void);
+#endif
+
+#endif /* NE_PRIVSSL_H */
diff --git a/net/mmt/neon/src/ne_props.c b/net/mmt/neon/src/ne_props.c
new file mode 100644
index 0000000..8131709
--- /dev/null
+++ b/net/mmt/neon/src/ne_props.c
@@ -0,0 +1,675 @@
+/* 
+   WebDAV property manipulation
+   Copyright (C) 2000-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include "ne_alloc.h"
+#include "ne_xml.h"
+#include "ne_props.h"
+#include "ne_basic.h"
+#include "ne_locks.h"
+#include "ne_internal.h"
+
+/* don't store flat props with a value > 10K */
+#define MAX_FLATPROP_LEN (102400)
+
+struct ne_propfind_handler_s {
+    ne_session *sess;
+    ne_request *request;
+
+    int has_props; /* whether we've already written some
+		    * props to the body. */
+    ne_buffer *body;
+    
+    ne_207_parser *parser207;
+    ne_xml_parser *parser;
+
+    /* Creator/destructor callbacks. */
+    ne_props_create_complex creator;
+    ne_props_destroy_complex destructor;
+    void *cd_userdata;
+    
+    /* Current propset, or NULL if none being processed. */
+    ne_prop_result_set *current;
+
+    ne_buffer *value; /* current flat property value */
+    int depth; /* nesting depth within a flat property */
+
+    ne_props_result callback;
+    void *userdata;
+};
+
+#define ELM_flatprop (NE_207_STATE_TOP - 1)
+
+/* We build up the results of one 'response' element in memory. */
+struct prop {
+    char *name, *nspace, *value, *lang;
+    /* Store a ne_propname here too, for convienience.  pname.name =
+     * name, pname.nspace = nspace, but they are const'ed in pname. */
+    ne_propname pname;
+};
+
+#define NSPACE(x) ((x) ? (x) : "")
+
+struct propstat {
+    struct prop *props;
+    int numprops;
+    ne_status status;
+};
+
+/* Results set. */
+struct ne_prop_result_set_s {
+    struct propstat *pstats;
+    int numpstats, counter;
+    void *private;
+    ne_uri uri;
+};
+
+#define MAX_PROP_COUNTER (1024)
+
+static int 
+startelm(void *userdata, int state, const char *name, const char *nspace,
+	 const char **atts);
+static int 
+endelm(void *userdata, int state, const char *name, const char *nspace);
+
+/* Handle character data; flat property value. */
+static int chardata(void *userdata, int state, const char *data, size_t len)
+{
+    ne_propfind_handler *hdl = userdata;
+
+    if (state == ELM_flatprop && hdl->value->length < MAX_FLATPROP_LEN)
+        ne_buffer_append(hdl->value, data, len);
+
+    return 0;
+}
+
+ne_xml_parser *ne_propfind_get_parser(ne_propfind_handler *handler)
+{
+    return handler->parser;
+}
+
+ne_request *ne_propfind_get_request(ne_propfind_handler *handler)
+{
+    return handler->request;
+}
+
+static int propfind(ne_propfind_handler *handler, 
+		    ne_props_result results, void *userdata)
+{
+    int ret;
+    ne_request *req = handler->request;
+
+    /* Register the flat property handler to catch any properties 
+     * which the user isn't handling as 'complex'. */
+    ne_xml_push_handler(handler->parser, startelm, chardata, endelm, handler);
+
+    handler->callback = results;
+    handler->userdata = userdata;
+
+    ne_set_request_body_buffer(req, handler->body->data,
+			       ne_buffer_size(handler->body));
+
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    
+    ne_add_response_body_reader(req, ne_accept_207, ne_xml_parse_v, 
+				  handler->parser);
+
+    ret = ne_request_dispatch(req);
+
+    if (ret == NE_OK && ne_get_status(req)->klass != 2) {
+	ret = NE_ERROR;
+    } else if (ne_xml_failed(handler->parser)) {
+	ne_set_error(handler->sess, "%s", ne_xml_get_error(handler->parser));
+	ret = NE_ERROR;
+    }
+
+    return ret;
+}
+
+static void set_body(ne_propfind_handler *hdl, const ne_propname *names)
+{
+    ne_buffer *body = hdl->body;
+    int n;
+    
+    if (!hdl->has_props) {
+	ne_buffer_czappend(body, "<prop>\n");
+	hdl->has_props = 1;
+    }
+
+    for (n = 0; names[n].name != NULL; n++) {
+	ne_buffer_concat(body, "<", names[n].name, " xmlns=\"", 
+			 NSPACE(names[n].nspace), "\"/>\n", NULL);
+    }
+
+}
+
+int ne_propfind_allprop(ne_propfind_handler *handler, 
+			 ne_props_result results, void *userdata)
+{
+    ne_buffer_czappend(handler->body, "<allprop/></propfind>\n");
+    return propfind(handler, results, userdata);
+}
+
+int ne_propfind_named(ne_propfind_handler *handler, const ne_propname *props,
+		       ne_props_result results, void *userdata)
+{
+    set_body(handler, props);
+    ne_buffer_czappend(handler->body, "</prop></propfind>\n");
+    return propfind(handler, results, userdata);
+}
+
+
+/* The easy one... PROPPATCH */
+int ne_proppatch(ne_session *sess, const char *uri, 
+		 const ne_proppatch_operation *items)
+{
+    ne_request *req = ne_request_create(sess, "PROPPATCH", uri);
+    ne_buffer *body = ne_buffer_create();
+    int n, ret;
+    
+    /* Create the request body */
+    ne_buffer_czappend(body, "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n"
+                       "<D:propertyupdate xmlns:D=\"DAV:\">");
+
+    for (n = 0; items[n].name != NULL; n++) {
+	const char *elm = (items[n].type == ne_propset) ? "set" : "remove";
+
+	/* <set><prop><prop-name>value</prop-name></prop></set> */
+	ne_buffer_concat(body, "<D:", elm, "><D:prop>"
+			 "<", items[n].name->name, NULL);
+	
+	if (items[n].name->nspace) {
+	    ne_buffer_concat(body, " xmlns=\"", items[n].name->nspace, "\"", NULL);
+	}
+
+	if (items[n].type == ne_propset) {
+	    ne_buffer_concat(body, ">", items[n].value, NULL);
+	} else {
+	    ne_buffer_append(body, ">", 1);
+	}
+
+	ne_buffer_concat(body, "</", items[n].name->name, "></D:prop></D:", elm, 
+                         ">\n", NULL);
+    }	
+
+    ne_buffer_czappend(body, "</D:propertyupdate>\n");
+
+    ne_set_request_body_buffer(req, body->data, ne_buffer_size(body));
+    ne_add_request_header(req, "Content-Type", NE_XML_MEDIA_TYPE);
+    
+#ifdef NE_HAVE_DAV
+    ne_lock_using_resource(req, uri, NE_DEPTH_ZERO);
+#endif
+
+    ret = ne_simple_request(sess, req);
+    
+    ne_buffer_destroy(body);
+
+    return ret;
+}
+
+/* Compare two property names. */
+static int pnamecmp(const ne_propname *pn1, const ne_propname *pn2)
+{
+    if (pn1->nspace == NULL && pn2->nspace != NULL) {
+	return 1;
+    } else if (pn1->nspace != NULL && pn2->nspace == NULL) {
+	return -1;
+    } else if (pn1->nspace == NULL) {
+	return strcmp(pn1->name, pn2->name);
+    } else {
+	return (strcmp(pn1->nspace, pn2->nspace) ||
+		strcmp(pn1->name, pn2->name));
+    }
+}
+
+/* Find property in 'set' with name 'pname'.  If found, set pstat_ret
+ * to the containing propstat, likewise prop_ret, and returns zero.
+ * If not found, returns non-zero.  */
+static int findprop(const ne_prop_result_set *set, const ne_propname *pname,
+		    struct propstat **pstat_ret, struct prop **prop_ret)
+{
+    
+    int ps, p;
+
+    for (ps = 0; ps < set->numpstats; ps++) {
+	for (p = 0; p < set->pstats[ps].numprops; p++) {
+	    struct prop *prop = &set->pstats[ps].props[p];
+
+	    if (pnamecmp(&prop->pname, pname) == 0) {
+		if (pstat_ret != NULL)
+		    *pstat_ret = &set->pstats[ps];
+		if (prop_ret != NULL)
+		    *prop_ret = prop;
+		return 0;
+	    }
+	}
+    }
+
+    return -1;
+}
+
+const char *ne_propset_value(const ne_prop_result_set *set,
+			      const ne_propname *pname)
+{
+    struct prop *prop;
+    
+    if (findprop(set, pname, NULL, &prop)) {
+	return NULL;
+    } else {
+	return prop->value;
+    }
+}
+
+const char *ne_propset_lang(const ne_prop_result_set *set,
+			     const ne_propname *pname)
+{
+    struct prop *prop;
+
+    if (findprop(set, pname, NULL, &prop)) {
+	return NULL;
+    } else {
+	return prop->lang;
+    }
+}
+
+void *ne_propfind_current_private(ne_propfind_handler *handler)
+{
+    return handler->current ? handler->current->private : NULL;
+}
+
+void *ne_propset_private(const ne_prop_result_set *set)
+{
+    return set->private;
+}
+
+int ne_propset_iterate(const ne_prop_result_set *set,
+			ne_propset_iterator iterator, void *userdata)
+{
+    int ps, p;
+
+    for (ps = 0; ps < set->numpstats; ps++) {
+	for (p = 0; p < set->pstats[ps].numprops; p++) {
+	    struct prop *prop = &set->pstats[ps].props[p];
+	    int ret = iterator(userdata, &prop->pname, prop->value, 
+			       &set->pstats[ps].status);
+	    if (ret)
+		return ret;
+
+	}
+    }
+
+    return 0;
+}
+
+const ne_status *ne_propset_status(const ne_prop_result_set *set,
+				      const ne_propname *pname)
+{
+    struct propstat *pstat;
+    
+    if (findprop(set, pname, &pstat, NULL)) {
+	/* TODO: it is tempting to return a dummy status object here
+	 * rather than NULL, which says "Property result was not given
+	 * by server."  but I'm not sure if this is best left to the
+	 * client.  */
+	return NULL;
+    } else {
+	return &pstat->status;
+    }
+}
+
+static void *start_response(void *userdata, const ne_uri *uri)
+{
+    ne_prop_result_set *set = ne_calloc(sizeof(*set));
+    ne_propfind_handler *hdl = userdata;
+
+    ne_uri_copy(&set->uri, uri);
+
+    if (hdl->creator) {
+	set->private = hdl->creator(hdl->cd_userdata, &set->uri);
+    }
+
+    hdl->current = set;
+
+    return set;
+}
+
+static void *start_propstat(void *userdata, void *response)
+{
+    ne_prop_result_set *set = response;
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat;
+    int n;
+
+    if (++hdl->current->counter == MAX_PROP_COUNTER) {
+        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
+        return NULL;
+    }
+    
+    n = set->numpstats;
+    set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));
+    set->numpstats = n+1;
+
+    pstat = &set->pstats[n];
+    memset(pstat, 0, sizeof(*pstat));
+    
+    /* And return this as the new pstat. */
+    return &set->pstats[n];
+}
+
+static int startelm(void *userdata, int parent,
+                    const char *nspace, const char *name, const char **atts)
+{
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
+    struct prop *prop;
+    int n;
+    const char *lang;
+
+    /* Just handle all children of propstat and their descendants. */
+    if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop) 
+        || pstat == NULL)
+        return NE_XML_DECLINE;
+
+    if (parent == ELM_flatprop) {
+        /* collecting the flatprop value. */
+        hdl->depth++;
+        if (hdl->value->used < MAX_FLATPROP_LEN) {
+            const char **a = atts;
+
+            ne_buffer_concat(hdl->value, "<", nspace, name, NULL);
+            
+            while (a[0] && hdl->value->used < MAX_FLATPROP_LEN) {
+                const char *nsep = strchr(a[0], ':'), *pfx;
+
+                /* Resolve the attribute namespace prefix, if any.
+                 * Ignore a failure to resolve the namespace prefix. */
+                pfx = nsep ? ne_xml_resolve_nspace(hdl->parser,
+                                                   a[0], nsep - a[0]) : NULL;
+                
+                if (pfx) {
+                    ne_buffer_concat(hdl->value, " ", pfx, nsep + 1, "='", 
+                                     a[1], "'", NULL);
+                }
+                else {
+                    ne_buffer_concat(hdl->value, " ", a[0], "='", a[1], "'", NULL);
+                }
+                a += 2;
+            }
+
+            ne_buffer_czappend(hdl->value, ">");
+        }
+
+        return ELM_flatprop;
+    }        
+
+    /* Enforce maximum number of properties per resource to prevent a
+     * memory exhaustion attack by a hostile server. */
+    if (++hdl->current->counter == MAX_PROP_COUNTER) {
+        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
+        return NE_XML_ABORT;
+    }
+
+    /* Add a property to this propstat */
+    n = pstat->numprops;
+
+    pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));
+    pstat->numprops = n+1;
+
+    /* Fill in the new property. */
+    prop = &pstat->props[n];
+
+    prop->pname.name = prop->name = ne_strdup(name);
+    if (nspace[0] == '\0') {
+	prop->pname.nspace = prop->nspace = NULL;
+    } else {
+	prop->pname.nspace = prop->nspace = ne_strdup(nspace);
+    }
+    prop->value = NULL;
+
+    NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 
+	     NSPACE(prop->nspace), prop->name);
+
+    /* This is under discussion at time of writing (April '01), and it
+     * looks like we need to retrieve the xml:lang property from any
+     * element here or above.
+     *
+     * Also, I think we might need attribute namespace handling here.  */
+    lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");
+    if (lang != NULL) {
+	prop->lang = ne_strdup(lang);
+	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);
+    } else {
+	prop->lang = NULL;
+    }
+
+    hdl->depth = 0;
+
+    return ELM_flatprop;
+}
+
+static int endelm(void *userdata, int state,
+                  const char *nspace, const char *name)
+{
+    ne_propfind_handler *hdl = userdata;
+    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
+    int n;
+
+    if (hdl->depth > 0) {
+        /* nested. */
+        if (hdl->value->used < MAX_FLATPROP_LEN)
+            ne_buffer_concat(hdl->value, "</", nspace, name, ">", NULL);
+        hdl->depth--;
+    } else {
+        /* end of the current property value */
+        n = pstat->numprops - 1;
+        pstat->props[n].value = ne_buffer_finish(hdl->value);
+        hdl->value = ne_buffer_create();
+    }
+    return 0;
+}
+
+static void end_propstat(void *userdata, void *pstat_v, 
+			 const ne_status *status,
+			 const char *description)
+{
+    struct propstat *pstat = pstat_v;
+
+    /* Nothing to do if no status was given. */
+    if (!status) return;
+
+    /* If we get a non-2xx response back here, we wipe the value for
+     * each of the properties in this propstat, so the caller knows to
+     * look at the status instead. It's annoying, since for each prop
+     * we will have done an unnecessary strdup("") above, but there is
+     * no easy way round that given the fact that we don't know
+     * whether we've got an error or not till after we get the
+     * property element.
+     *
+     * Interestingly IIS breaks the 2518 DTD and puts the status
+     * element first in the propstat. This is useful since then we
+     * *do* know whether each subsequent empty prop element means, but
+     * we can't rely on that here. */
+    if (status->klass != 2) {
+	int n;
+	
+	for (n = 0; n < pstat->numprops; n++) {
+	    ne_free(pstat->props[n].value);
+	    pstat->props[n].value = NULL;
+	}
+    }
+
+    /* copy the status structure, and dup the reason phrase. */
+    pstat->status = *status;
+    pstat->status.reason_phrase = ne_strdup(status->reason_phrase);
+}
+
+/* Frees up a results set */
+static void free_propset(ne_propfind_handler *handler,
+                         ne_prop_result_set *set)
+{
+    int n;
+    
+    if (handler->destructor && set->private) {
+        handler->destructor(handler->cd_userdata, set->private);
+    }
+
+    for (n = 0; n < set->numpstats; n++) {
+	int m;
+	struct propstat *p = &set->pstats[n];
+
+	for (m = 0; m < p->numprops; m++) {
+            if (p->props[m].nspace) ne_free(p->props[m].nspace);
+            ne_free(p->props[m].name);
+            if (p->props[m].lang) ne_free(p->props[m].lang);
+            if (p->props[m].value) ne_free(p->props[m].value);
+            p->props[m].nspace = p->props[m].lang = 
+                p->props[m].value = NULL;
+	}
+
+	if (p->status.reason_phrase)
+	    ne_free(p->status.reason_phrase);
+	if (p->props)
+	    ne_free(p->props);
+    }
+
+    if (set->pstats)
+	ne_free(set->pstats);
+    ne_uri_free(&set->uri);
+    ne_free(set);
+}
+
+static void end_response(void *userdata, void *resource,
+			 const ne_status *status,
+			 const char *description)
+{
+    ne_propfind_handler *handler = userdata;
+    ne_prop_result_set *set = resource;
+
+    /* Pass back the results for this resource. */
+    if (handler->callback && set->numpstats > 0)
+	handler->callback(handler->userdata, &set->uri, set);
+
+    /* Clean up the propset tree we've just built. */
+    free_propset(handler, set);
+    handler->current = NULL;
+}
+
+ne_propfind_handler *
+ne_propfind_create(ne_session *sess, const char *uri, int depth)
+{
+    ne_propfind_handler *ret = ne_calloc(sizeof(ne_propfind_handler));
+    ne_uri base = {0};
+
+    ne_fill_server_uri(sess, &base);
+    base.path = ne_strdup(uri);
+
+    ret->parser = ne_xml_create();
+    ret->parser207 = ne_207_create(ret->parser, &base, ret);
+    ret->sess = sess;
+    ret->body = ne_buffer_create();
+    ret->request = ne_request_create(sess, "PROPFIND", uri);
+    ret->value = ne_buffer_create();
+
+    ne_add_depth_header(ret->request, depth);
+
+    ne_207_set_response_handlers(ret->parser207, 
+				  start_response, end_response);
+
+    ne_207_set_propstat_handlers(ret->parser207, start_propstat,
+				  end_propstat);
+
+    /* The start of the request body is fixed: */
+    ne_buffer_czappend(ret->body, 
+                       "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" 
+                       "<propfind xmlns=\"DAV:\">");
+
+    ne_uri_free(&base);
+
+    return ret;
+}
+
+/* Destroy a propfind handler */
+void ne_propfind_destroy(ne_propfind_handler *handler)
+{
+    ne_buffer_destroy(handler->value);
+    if (handler->current)
+        free_propset(handler, handler->current);
+    ne_207_destroy(handler->parser207);
+    ne_xml_destroy(handler->parser);
+    ne_buffer_destroy(handler->body);
+    ne_request_destroy(handler->request);
+    ne_free(handler);    
+}
+
+int ne_simple_propfind(ne_session *sess, const char *href, int depth,
+			const ne_propname *props,
+			ne_props_result results, void *userdata)
+{
+    ne_propfind_handler *hdl;
+    int ret;
+
+    hdl = ne_propfind_create(sess, href, depth);
+    if (props != NULL) {
+	ret = ne_propfind_named(hdl, props, results, userdata);
+    } else {
+	ret = ne_propfind_allprop(hdl, results, userdata);
+    }
+	
+    ne_propfind_destroy(hdl);
+    
+    return ret;
+}
+
+int ne_propnames(ne_session *sess, const char *href, int depth,
+		  ne_props_result results, void *userdata)
+{
+    ne_propfind_handler *hdl;
+    int ret;
+
+    hdl = ne_propfind_create(sess, href, depth);
+
+    ne_buffer_czappend(hdl->body, "<propname/></propfind>");
+
+    ret = propfind(hdl, results, userdata);
+
+    ne_propfind_destroy(hdl);
+
+    return ret;
+}
+
+void ne_propfind_set_private(ne_propfind_handler *hdl,
+                             ne_props_create_complex creator,
+                             ne_props_destroy_complex destructor,
+                             void *userdata)
+{
+    hdl->creator = creator;
+    hdl->destructor = destructor;
+    hdl->cd_userdata = userdata;
+}
diff --git a/net/mmt/neon/src/ne_props.h b/net/mmt/neon/src/ne_props.h
new file mode 100644
index 0000000..fdeb8ff
--- /dev/null
+++ b/net/mmt/neon/src/ne_props.h
@@ -0,0 +1,249 @@
+/* 
+   WebDAV Properties manipulation
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_PROPS_H
+#define NE_PROPS_H
+
+#include "ne_request.h"
+#include "ne_207.h"
+
+NE_BEGIN_DECLS
+
+/* There are two interfaces for fetching properties. The first is
+ * 'ne_simple_propfind', which is relatively simple, and easy to use,
+ * but only lets you fetch FLAT properties, i.e. properties which are
+ * just a string of bytes.  The complex interface is 'ne_propfind_*',
+ * which is complicated, and hard to use, but lets you parse
+ * structured properties, i.e.  properties which have XML content.  */
+
+/* The 'ne_simple_propfind' interface. ***
+ *
+ * ne_simple_propfind allows you to fetch a set of properties for a
+ * single resource, or a tree of resources.  You set the operation
+ * going by passing these arguments:
+ *
+ *  - the session which should be used.
+ *  - the URI and the depth of the operation (0, 1, infinite)
+ *  - the names of the properties which you want to fetch
+ *  - a results callback, and the userdata for the callback.
+ *
+ * For each resource found, the results callback is called, passing
+ * you two things along with the userdata you passed in originally:
+ *
+ *   - the URI of the resource (const ne_uri *uri)
+ *   - the properties results set (const ne_prop_result_set *results)
+ * */
+
+/* The name of a WebDAV property. 'nspace' may be NULL. */
+typedef struct {
+    const char *nspace, *name;
+} ne_propname;
+
+typedef struct ne_prop_result_set_s ne_prop_result_set;
+
+/* Get the value of a given property. Will return NULL if there was an
+ * error fetching this property on this resource.  Call
+ * ne_propset_result to get the response-status if so.  */
+const char *ne_propset_value(const ne_prop_result_set *set,
+			      const ne_propname *propname);
+
+/* Returns the status structure for fetching the given property on
+ * this resource. This function will return NULL if the server did not
+ * return the property (which is a server error). */
+const ne_status *ne_propset_status(const ne_prop_result_set *set,
+				      const ne_propname *propname);
+
+/* Returns the private pointer for the given propset. */
+void *ne_propset_private(const ne_prop_result_set *set);
+
+/* Return language string of property (may be NULL). */
+const char *ne_propset_lang(const ne_prop_result_set *set,
+			     const ne_propname *pname);
+
+/* ne_propset_iterate iterates over a properties result set,
+ * calling the callback for each property in the set. userdata is
+ * passed as the first argument to the callback. value may be NULL,
+ * indicating an error occurred fetching this property: look at 
+ * status for the error in that case.
+ *
+ * If the iterator returns non-zero, ne_propset_iterate will return
+ * immediately with that value.
+ */
+typedef int (*ne_propset_iterator)(void *userdata,
+				    const ne_propname *pname,
+				    const char *value,
+				    const ne_status *status);
+
+/* Iterate over all the properties in 'set', calling 'iterator'
+ * for each, passing 'userdata' as the first argument to callback.
+ * 
+ * Returns:
+ *   whatever value iterator returns.
+ */
+int ne_propset_iterate(const ne_prop_result_set *set,
+			ne_propset_iterator iterator, void *userdata);
+
+/* Callback for handling the results of fetching properties for a
+ * single resource (identified by URI 'uri').  The results are stored
+ * in the result set 'results': use ne_propset_* to examine this
+ * object.  */
+typedef void (*ne_props_result)(void *userdata, const ne_uri *uri,
+                                const ne_prop_result_set *results);
+
+/* Fetch properties for a resource (if depth == NE_DEPTH_ZERO),
+ * or a tree of resources (if depth == NE_DEPTH_ONE or _INFINITE).
+ *
+ * Names of the properties required must be given in 'props',
+ * or if props is NULL, *all* properties are fetched.
+ *
+ * 'results' is called for each resource in the response, userdata is
+ * passed as the first argument to the callback. It is important to
+ * note that the callback is called as the response is read off the
+ * socket, so don't do anything silly in it (e.g. sleep(100), or call
+ * any functions which use this session).
+ *
+ * Note that if 'depth' is NE_DEPTH_INFINITY, some servers may refuse
+ * the request.
+ *
+ * Returns NE_*.  */
+int ne_simple_propfind(ne_session *sess, const char *path, int depth,
+			const ne_propname *props,
+			ne_props_result results, void *userdata);
+
+/* The properties of a resource can be manipulated using ne_proppatch.
+ * A single proppatch request may include any number of individual
+ * "set" and "remove" operations, and is defined to have
+ * "all-or-nothing" semantics, so either all the operations succeed,
+ * or none do. */
+
+/* A proppatch operation may either set a property to have a new
+ * value, in which case 'type' must be ne_propset, and 'value' must be
+ * non-NULL; or it can remove a property; in which case 'type' must be
+ * ne_propremove, and 'value' is ignored.  In both cases, 'name' must
+ * be set to the name of the property to alter. */
+enum ne_proppatch_optype {
+    ne_propset,
+    ne_propremove
+};
+typedef struct {
+    const ne_propname *name;
+    enum ne_proppatch_optype type;
+    const char *value;
+} ne_proppatch_operation;
+
+/* Execute a set of property operations 'ops' on 'path'. 'ops' is an
+ * array terminated by an operation with a NULL 'name' field. Returns
+ * NE_*. */
+int ne_proppatch(ne_session *sess, const char *path,
+		 const ne_proppatch_operation *ops);
+
+/* Retrieve property names for the resources at 'path'.  'results'
+ * callback is called for each resource.  Use 'ne_propset_iterate' on
+ * the passed results object to retrieve the list of property names.
+ * */
+int ne_propnames(ne_session *sess, const char *path, int depth,
+		 ne_props_result results, void *userdata);
+
+/* The complex, you-do-all-the-work, property fetch interface:
+ */
+
+struct ne_propfind_handler_s;
+typedef struct ne_propfind_handler_s ne_propfind_handler;
+
+/* Retrieve the 'private' pointer for the current propset for the
+ * given handler, as returned by the ne_props_create_complex callback
+ * installed using 'ne_propfind_set_private'.  If this callback was
+ * not registered, this function will return NULL.  */
+void *ne_propfind_current_private(ne_propfind_handler *handler);
+
+/* Create a PROPFIND handler, for the given resource or set of 
+ * resources.
+ *
+ * Depth must be one of NE_DEPTH_*. */
+ne_propfind_handler *
+ne_propfind_create(ne_session *sess, const char *path, int depth);
+
+/* Return the XML parser for the given handler (only need if you want
+ * to handle complex properties). */
+ne_xml_parser *ne_propfind_get_parser(ne_propfind_handler *handler);
+
+/* This interface reserves the state integer range 'x' where 0 < x
+ * and x < NE_PROPS_STATE_TOP. */
+#define NE_PROPS_STATE_TOP (NE_207_STATE_TOP + 100)
+
+/* Return the request object for the given handler.  You MUST NOT use
+ * ne_set_request_body_* on this request object.  (this call is only
+ * needed if for instance, you want to add extra headers to the
+ * PROPFIND request).  The result of using the request pointer after
+ * ne_propfind_destroy(handler) has been called is undefined. */
+ne_request *ne_propfind_get_request(ne_propfind_handler *handler);
+
+/* A "complex property" has a value which is structured XML. To handle
+ * complex properties, you must set up and register an XML handler
+ * which will understand the elements which make up such properties.
+ * The handler must be registered with the parser returned by
+ * 'ne_propfind_get_parser'.
+ *
+ * To store the parsed value of the property, a 'private' structure is
+ * allocated in each propset (i.e. one per resource). When parsing the
+ * property value elements, for each new resource encountered in the
+ * response, the 'creator' callback is called to retrieve a 'private'
+ * structure for this resource.  When the private structure is no longer
+ * needed, the 'destructor' callback is called to deallocate any 
+ * memory, if necessary.
+ *
+ * Whilst in XML element callbacks you will have registered to handle
+ * complex properties, you can use the 'ne_propfind_current_private'
+ * call to retrieve the pointer to this private structure.
+ *
+ * To retrieve this 'private' structure from the propset in the
+ * results callback, simply call 'ne_propset_private'.
+ * */
+typedef void *(*ne_props_create_complex)(void *userdata, const ne_uri *uri);
+typedef void (*ne_props_destroy_complex)(void *userdata, void *complex);
+
+void ne_propfind_set_private(ne_propfind_handler *handler,
+			     ne_props_create_complex creator,
+			     ne_props_destroy_complex destructor,
+			     void *userdata);
+
+/* Fetch all properties.
+ *
+ * Returns NE_*. */
+int ne_propfind_allprop(ne_propfind_handler *handler, 
+			ne_props_result result, void *userdata);
+
+/* Fetch all properties with names listed in array 'names', which is
+ * terminated by a property with a NULL name field.  For each resource
+ * encountered, the result callback will be invoked, passing in
+ * 'userdata' as the first argument.
+ *
+ * Returns NE_*. */
+int ne_propfind_named(ne_propfind_handler *handler, 
+		      const ne_propname *names,
+		      ne_props_result result, void *userdata);
+
+/* Destroy a propfind handler after use. */
+void ne_propfind_destroy(ne_propfind_handler *handler);
+
+NE_END_DECLS
+
+#endif /* NE_PROPS_H */
diff --git a/net/mmt/neon/src/ne_redirect.c b/net/mmt/neon/src/ne_redirect.c
new file mode 100644
index 0000000..171795b
--- /dev/null
+++ b/net/mmt/neon/src/ne_redirect.c
@@ -0,0 +1,141 @@
+/* 
+   HTTP-redirect support
+   Copyright (C) 1999-2007, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include "ne_session.h"
+#include "ne_request.h"
+#include "ne_alloc.h"
+#include "ne_uri.h"
+#include "ne_redirect.h"
+#include "ne_internal.h"
+#include "ne_string.h"
+
+#define REDIRECT_ID "http://www.webdav.org/neon/hooks/http-redirect"
+
+struct redirect {
+    char *requri;
+    int valid; /* non-zero if .uri contains a redirect */
+    ne_uri uri;
+    ne_session *sess;
+};
+
+static void
+create(ne_request *req, void *session, const char *method, const char *uri)
+{
+    struct redirect *red = session;
+    if (red->requri) ne_free(red->requri);
+    red->requri = ne_strdup(uri);
+}
+
+#define REDIR(n) ((n) == 301 || (n) == 302 || (n) == 303 || \
+		  (n) == 307)
+
+static int post_send(ne_request *req, void *private, const ne_status *status)
+{
+    struct redirect *red = private;
+    const char *location = ne_get_response_header(req, "Location");
+    ne_buffer *path = NULL;
+    int ret;
+
+    /* Don't do anything for non-redirect status or no Location header. */
+    if (!REDIR(status->code) || location == NULL)
+	return NE_OK;
+
+    if (strstr(location, "://") == NULL && location[0] != '/') {
+	char *pnt;
+
+	path = ne_buffer_create();
+	ne_buffer_zappend(path, red->requri);
+	pnt = strrchr(path->data, '/');
+
+	if (pnt && pnt[1] != '\0') {
+	    /* Chop off last path segment. */
+	    pnt[1] = '\0';
+	    ne_buffer_altered(path);
+	}
+	ne_buffer_zappend(path, location);
+	location = path->data;
+    }
+
+    /* free last uri. */
+    ne_uri_free(&red->uri);
+    
+    /* Parse the Location header */
+    if (ne_uri_parse(location, &red->uri) || red->uri.path == NULL) {
+        red->valid = 0;
+	ne_set_error(red->sess, _("Could not parse redirect destination URL"));
+        ret = NE_ERROR;
+    } else {
+        /* got a valid redirect. */
+        red->valid = 1;
+        ret = NE_REDIRECT;
+
+        if (!red->uri.host) {
+            /* Not an absoluteURI: breaks 2616 but everybody does it. */
+            ne_fill_server_uri(red->sess, &red->uri);
+        }
+    }
+
+    if (path) ne_buffer_destroy(path);
+
+    return ret;
+}
+
+static void free_redirect(void *cookie)
+{
+    struct redirect *red = cookie;
+    ne_uri_free(&red->uri);
+    if (red->requri)
+        ne_free(red->requri);
+    ne_free(red);
+}
+
+void ne_redirect_register(ne_session *sess)
+{
+    struct redirect *red = ne_calloc(sizeof *red);
+    
+    red->sess = sess;
+
+    ne_hook_create_request(sess, create, red);
+    ne_hook_post_send(sess, post_send, red);
+    ne_hook_destroy_session(sess, free_redirect, red);
+
+    ne_set_session_private(sess, REDIRECT_ID, red);
+}
+
+const ne_uri *ne_redirect_location(ne_session *sess)
+{
+    struct redirect *red = ne_get_session_private(sess, REDIRECT_ID);
+
+    if (red && red->valid)
+        return &red->uri;
+    else
+        return NULL;
+}
+
diff --git a/net/mmt/neon/src/ne_redirect.h b/net/mmt/neon/src/ne_redirect.h
new file mode 100644
index 0000000..f9b437a
--- /dev/null
+++ b/net/mmt/neon/src/ne_redirect.h
@@ -0,0 +1,42 @@
+/* 
+   HTTP-redirect support
+   Copyright (C) 1999-2002, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_REDIRECT_H
+#define NE_REDIRECT_H
+
+#include "ne_request.h"
+
+NE_BEGIN_DECLS
+
+/* Register redirect handling for the session: if a valid redirect
+ * (30x) response is given for any request in this session, the
+ * request will fail with the NE_REDIRECT code, and the destination of
+ * the redirect can be retrieved using ne_redirect_location(). */
+void ne_redirect_register(ne_session *sess);
+
+/* Returns location of last redirect for the session.  Returns NULL if
+ * no redirect has been encountered for given session, or the last
+ * redirect encountered could not be parsed. */
+const ne_uri *ne_redirect_location(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_REDIRECT_H */
diff --git a/net/mmt/neon/src/ne_request.c b/net/mmt/neon/src/ne_request.c
new file mode 100644
index 0000000..e28fcd4
--- /dev/null
+++ b/net/mmt/neon/src/ne_request.c
@@ -0,0 +1,1714 @@
+/* 
+   HTTP request/response handling
+   Copyright (C) 1999-2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* This is the HTTP client request/response implementation.
+ * The goal of this code is to be modular and simple.
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif 
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include "ne_internal.h"
+
+#include "ne_alloc.h"
+#include "ne_request.h"
+#include "ne_string.h" /* for ne_buffer */
+#include "ne_utils.h"
+#include "ne_socket.h"
+#include "ne_uri.h"
+
+#include "ne_private.h"
+
+#define SOCK_ERR(req, op, msg) do { ssize_t sret = (op); \
+if (sret < 0) return aborted(req, msg, sret); } while (0)
+
+#define EOL "\r\n"
+
+struct body_reader {
+    ne_block_reader handler;
+    ne_accept_response accept_response;
+    unsigned int use;
+    void *userdata;
+    struct body_reader *next;
+};
+
+struct field {
+    char *name, *value;
+    size_t vlen;
+    struct field *next;
+};
+
+/* Maximum number of header fields per response: */
+#define MAX_HEADER_FIELDS (100)
+/* Size of hash table; 43 is the smallest prime for which the common
+ * header names hash uniquely using the *33 hash function. */
+#define HH_HASHSIZE (43)
+/* Hash iteration step: *33 known to be a good hash for ASCII, see RSE. */
+#define HH_ITERATE(hash, ch) (((hash)*33 + (unsigned char)(ch)) % HH_HASHSIZE)
+
+/* pre-calculated hash values for given header names: */
+#define HH_HV_CONNECTION        (0x14)
+#define HH_HV_PROXY_CONNECTION  (0x1A)
+#define HH_HV_CONTENT_LENGTH    (0x13)
+#define HH_HV_TRANSFER_ENCODING (0x07)
+
+struct ne_request_s {
+    char *method, *uri; /* method and Request-URI */
+
+    ne_buffer *headers; /* request headers */
+
+    /* Request body. */
+    ne_provide_body body_cb;
+    void *body_ud;
+
+    /* Request body source: file or buffer (if not callback). */
+    union {
+        struct {
+            int fd;
+            ne_off_t offset, length;
+            ne_off_t remain; /* remaining bytes to send. */
+        } file;
+	struct {
+            /* length bytes @ buffer = whole body.
+             * remain bytes @ pnt = remaining bytes to send */
+	    const char *buffer, *pnt;
+	    size_t length, remain;
+	} buf;
+    } body;
+	    
+    ne_off_t body_length; /* length of request body */
+
+    /* temporary store for response lines. */
+    char respbuf[NE_BUFSIZ];
+
+    /**** Response ***/
+
+    /* The transfer encoding types */
+    struct ne_response {
+	enum {
+	    R_TILLEOF = 0, /* read till eof */
+	    R_NO_BODY, /* implicitly no body (HEAD, 204, 304) */
+	    R_CHUNKED, /* using chunked transfer-encoding */
+	    R_CLENGTH  /* using given content-length */
+	} mode;
+        union {
+            /* clen: used if mode == R_CLENGTH; total and bytes
+             * remaining to be read of response body. */
+            struct {
+                ne_off_t total, remain;
+            } clen;
+            /* chunk: used if mode == R_CHUNKED; total and bytes
+             * remaining to be read of current chunk */
+            struct {
+                size_t total, remain;
+            } chunk;
+        } body;
+        ne_off_t progress; /* number of bytes read of response */
+    } resp;
+    
+    struct hook *private;
+
+    /* response header fields */
+    struct field *response_headers[HH_HASHSIZE];
+    
+    unsigned int current_index; /* response_headers cursor for iterator */
+
+    /* List of callbacks which are passed response body blocks */
+    struct body_reader *body_readers;
+
+    /*** Miscellaneous ***/
+    unsigned int method_is_head;
+    unsigned int can_persist;
+
+    int flags[NE_REQFLAG_LAST];
+
+    ne_session *session;
+    ne_status status;
+};
+
+static int open_connection(ne_session *sess);
+
+/* Returns hash value for header 'name', converting it to lower-case
+ * in-place. */
+static inline unsigned int hash_and_lower(char *name)
+{
+    char *pnt;
+    unsigned int hash = 0;
+
+    for (pnt = name; *pnt != '\0'; pnt++) {
+	*pnt = ne_tolower(*pnt);
+	hash = HH_ITERATE(hash,*pnt);
+    }
+
+    return hash;
+}
+
+/* Abort a request due to an non-recoverable HTTP protocol error,
+ * whilst doing 'doing'.  'code', if non-zero, is the socket error
+ * code, NE_SOCK_*, or if zero, is ignored. */
+static int aborted(ne_request *req, const char *doing, ssize_t code)
+{
+    ne_session *sess = req->session;
+    int ret = NE_ERROR;
+
+    NE_DEBUG(NE_DBG_HTTP, "Aborted request (%" NE_FMT_SSIZE_T "): %s\n",
+	     code, doing);
+
+    switch(code) {
+    case NE_SOCK_CLOSED:
+	if (sess->nexthop->proxy != PROXY_NONE) {
+	    ne_set_error(sess, _("%s: connection was closed by proxy server"),
+			 doing);
+	} else {
+	    ne_set_error(sess, _("%s: connection was closed by server"),
+			 doing);
+	}
+	break;
+    case NE_SOCK_TIMEOUT:
+	ne_set_error(sess, _("%s: connection timed out"), doing);
+	ret = NE_TIMEOUT;
+	break;
+    case NE_SOCK_ERROR:
+    case NE_SOCK_RESET:
+    case NE_SOCK_TRUNC:
+        ne_set_error(sess, "%s: %s", doing, ne_sock_error(sess->socket));
+        break;
+    case 0:
+	ne_set_error(sess, "%s", doing);
+	break;
+    }
+
+    ne_close_connection(sess);
+    return ret;
+}
+
+static void notify_status(ne_session *sess, ne_session_status status)
+{
+    if (sess->notify_cb) {
+	sess->notify_cb(sess->notify_ud, status, &sess->status);
+    }
+}
+
+static void *get_private(const struct hook *hk, const char *id)
+{
+    for (; hk != NULL; hk = hk->next)
+	if (strcmp(hk->id, id) == 0)
+	    return hk->userdata;
+    return NULL;
+}
+
+void *ne_get_request_private(ne_request *req, const char *id)
+{
+    return get_private(req->private, id);
+}
+
+void *ne_get_session_private(ne_session *sess, const char *id)
+{
+    return get_private(sess->private, id);
+}
+
+void ne_set_request_private(ne_request *req, const char *id, void *userdata)
+{
+    struct hook *hk = ne_malloc(sizeof (struct hook)), *pos;
+
+    if (req->private != NULL) {
+	for (pos = req->private; pos->next != NULL; pos = pos->next)
+	    /* nullop */;
+	pos->next = hk;
+    } else {
+	req->private = hk;
+    }
+
+    hk->id = id;
+    hk->fn = NULL;
+    hk->userdata = userdata;
+    hk->next = NULL;
+}
+
+static ssize_t body_string_send(void *userdata, char *buffer, size_t count)
+{
+    ne_request *req = userdata;
+    
+    if (count == 0) {
+	req->body.buf.remain = req->body.buf.length;
+	req->body.buf.pnt = req->body.buf.buffer;
+    } else {
+	/* if body_left == 0 we fall through and return 0. */
+	if (req->body.buf.remain < count)
+	    count = req->body.buf.remain;
+
+	memcpy(buffer, req->body.buf.pnt, count);
+	req->body.buf.pnt += count;
+	req->body.buf.remain -= count;
+    }
+
+    return count;
+}    
+
+static ssize_t body_fd_send(void *userdata, char *buffer, size_t count)
+{
+    ne_request *req = userdata;
+
+    if (count) {
+        ssize_t ret;
+
+        if (req->body.file.remain == 0)
+            return 0;
+
+        /* Casts here are necessary for LFS platforms for safe and
+         * warning-free assignment/comparison between 32-bit size_t
+         * and 64-bit off64_t: */
+        if ((ne_off_t)count > req->body.file.remain)
+            count = (size_t)req->body.file.remain;
+        
+        ret = read(req->body.file.fd, buffer, count);
+        if (ret > 0) {
+            req->body.file.remain -= ret;
+            return ret;
+        }
+        else if (ret == 0) {
+            ne_set_error(req->session, 
+                         _("Premature EOF in request body file"));
+        }
+        else if (ret < 0) {
+            char err[200];
+            int errnum = errno;
+
+            ne_set_error(req->session, 
+                         _("Failed reading request body file: %s"),
+                         ne_strerror(errnum, err, sizeof err));
+        }
+
+        return -1;
+    } else {
+        ne_off_t newoff;
+
+        /* rewind for next send. */
+        newoff = ne_lseek(req->body.file.fd, req->body.file.offset, SEEK_SET);
+        if (newoff == req->body.file.offset) {
+            req->body.file.remain = req->body.file.length;
+            return 0;
+        } else {
+            char err[200], offstr[20];
+
+            if (newoff == -1) {
+                /* errno was set */
+                ne_strerror(errno, err, sizeof err);
+            } else {
+                strcpy(err, _("offset invalid"));
+            }
+            ne_snprintf(offstr, sizeof offstr, "%" FMT_NE_OFF_T,
+                        req->body.file.offset);
+            ne_set_error(req->session, 
+                         _("Could not seek to offset %s"
+                           " of request body file: %s"), 
+                           offstr, err);
+            return -1;
+        }
+    }
+}
+
+/* For accurate persistent connection handling, for any write() or
+ * read() operation for a new request on an already-open connection,
+ * an EOF or RST error MUST be treated as a persistent connection
+ * timeout, and the request retried on a new connection.  Once a
+ * read() operation has succeeded, any subsequent error MUST be
+ * treated as fatal.  A 'retry' flag is used; retry=1 represents the
+ * first case, retry=0 the latter. */
+
+/* RETRY_RET() crafts a function return value given the 'retry' flag,
+ * the socket error 'code', and the return value 'acode' from the
+ * aborted() function. */
+#define RETRY_RET(retry, code, acode) \
+((((code) == NE_SOCK_CLOSED || (code) == NE_SOCK_RESET || \
+ (code) == NE_SOCK_TRUNC) && retry) ? NE_RETRY : (acode))
+
+/* For sending chunks, an 8-byte prefix is reserved at the beginning
+ * of the buffer.  This is large enough for a trailing \r\n for the
+ * previous chunk, the chunk size, and the \r\n following the
+ * chunk-size. */
+#define CHUNK_OFFSET (8)
+#define CHUNK_TERM "\r\n0\r\n\r\n"
+#define CHUNK_NULL_TERM "0\r\n\r\n"
+
+/* Sends the request body; returns 0 on success or an NE_* error code.
+ * If retry is non-zero; will return NE_RETRY on persistent connection
+ * timeout.  On error, the session error string is set and the
+ * connection is closed. */
+static int send_request_body(ne_request *req, int retry)
+{
+    ne_session *const sess = req->session;
+    char buffer[NE_BUFSIZ], *start;
+    ssize_t bytes;
+    size_t buflen;
+    int chunked = req->body_length < 0, chunknum = 0;
+    int ret;
+
+    NE_DEBUG(NE_DBG_HTTP, "Sending request body:\n");
+
+    /* Set up status union and (start, buflen) as the buffer to be
+     * passed the supplied callback. */
+    if (chunked) {
+        start = buffer + CHUNK_OFFSET;
+        buflen = sizeof(buffer) - CHUNK_OFFSET;
+        req->session->status.sr.total = -1;
+    }
+    else {
+        start = buffer;
+        buflen = sizeof buffer;
+        req->session->status.sr.total = req->body_length;
+    }
+
+    req->session->status.sr.progress = 0;
+    notify_status(sess, ne_status_sending);
+    
+    /* tell the source to start again from the beginning. */
+    if (req->body_cb(req->body_ud, NULL, 0) != 0) {
+        ne_close_connection(sess);
+        return NE_ERROR;
+    }
+    
+    while ((bytes = req->body_cb(req->body_ud, start, buflen)) > 0) {
+        req->session->status.sr.progress += bytes;
+        if (chunked) {
+            /* Overwrite the buffer prefix with the appropriate chunk
+             * size; since ne_snprintf always NUL-terminates, the \n
+             * is omitted and placed over the NUL afterwards. */
+            if (chunknum++ == 0)
+                ne_snprintf(buffer, CHUNK_OFFSET, 
+                            "%06x\r", (unsigned)bytes);
+            else
+                ne_snprintf(buffer, CHUNK_OFFSET, 
+                            "\r\n%04x\r", (unsigned)bytes);
+            buffer[CHUNK_OFFSET - 1] = '\n';
+            bytes += CHUNK_OFFSET;
+        }
+        ret = ne_sock_fullwrite(sess->socket, buffer, bytes);
+
+        if (ret < 0) {
+            int aret = aborted(req, _("Could not send request body"), ret);
+            return RETRY_RET(retry, ret, aret);
+        }
+
+	NE_DEBUG(NE_DBG_HTTPBODY, 
+		 "Body block (%" NE_FMT_SSIZE_T " bytes):\n[%.*s]\n",
+		 bytes, (int)bytes, buffer);
+
+        /* invoke progress callback */
+        notify_status(sess, ne_status_sending);
+    }
+
+    if (bytes) {
+        NE_DEBUG(NE_DBG_HTTP, "Request body provider failed with "
+                 "%" NE_FMT_SSIZE_T "\n", bytes);
+        ne_close_connection(sess);
+        return NE_ERROR;
+    }
+
+    if (chunked) {
+        if (chunknum == 0)
+            ret = ne_sock_fullwrite(sess->socket, CHUNK_NULL_TERM, 
+                                    sizeof(CHUNK_NULL_TERM) - 1);
+        else
+            ret = ne_sock_fullwrite(sess->socket, CHUNK_TERM, 
+                                    sizeof(CHUNK_TERM) - 1);
+        if (ret < 0) {
+            int aret = aborted(req, _("Could not send chunked "
+                                      "request terminator"), ret);
+            return RETRY_RET(retry, ret, aret);
+        }
+    }
+    
+    return NE_OK;
+}
+
+/* Lob the User-Agent, connection and host headers in to the request
+ * headers */
+static void add_fixed_headers(ne_request *req) 
+{
+    ne_session *const sess = req->session;
+
+    if (sess->user_agent) {
+        ne_buffer_zappend(req->headers, sess->user_agent);
+    }
+
+    /* If persistent connections are disabled, just send Connection:
+     * close; otherwise, send Connection: Keep-Alive to pre-1.1 origin
+     * servers to try harder to get a persistent connection, except if
+     * using a proxy as per 206819.7.1.  Always add TE: trailers. */
+    if (!sess->flags[NE_SESSFLAG_PERSIST]) {
+       ne_buffer_czappend(req->headers, "Connection: TE, close" EOL);
+    } 
+    else if (!sess->is_http11 && !sess->any_proxy_http) {
+        ne_buffer_czappend(req->headers, 
+                           "Keep-Alive: " EOL
+                          "Connection: TE, Keep-Alive" EOL);
+    } 
+    else if (!req->session->is_http11 && !sess->any_proxy_http) {
+        ne_buffer_czappend(req->headers, 
+                           "Keep-Alive: " EOL
+                           "Proxy-Connection: Keep-Alive" EOL
+                           "Connection: TE" EOL);
+    } 
+    else {
+        ne_buffer_czappend(req->headers, "Connection: TE" EOL);
+    }
+
+    ne_buffer_concat(req->headers, "TE: trailers" EOL "Host: ", 
+                     req->session->server.hostport, EOL, NULL);
+}
+
+int ne_accept_always(void *userdata, ne_request *req, const ne_status *st)
+{
+    return 1;
+}				   
+
+int ne_accept_2xx(void *userdata, ne_request *req, const ne_status *st)
+{
+    return (st->klass == 2);
+}
+
+ne_request *ne_request_create(ne_session *sess,
+			      const char *method, const char *path) 
+{
+    ne_request *req = ne_calloc(sizeof *req);
+
+    req->session = sess;
+    req->headers = ne_buffer_create();
+    
+    /* Presume the method is idempotent by default. */
+    req->flags[NE_REQFLAG_IDEMPOTENT] = 1;
+    /* Expect-100 default follows the corresponding session flag. */
+    req->flags[NE_REQFLAG_EXPECT100] = sess->flags[NE_SESSFLAG_EXPECT100];
+
+    /* Add in the fixed headers */
+    add_fixed_headers(req);
+
+    /* Set the standard stuff */
+    req->method = ne_strdup(method);
+    req->method_is_head = (strcmp(method, "HEAD") == 0);
+
+    /* Only use an absoluteURI here when we might be using an HTTP
+     * proxy, and SSL is in use: some servers can't parse them. */
+    if (sess->any_proxy_http && !req->session->use_ssl && path[0] == '/')
+	req->uri = ne_concat(req->session->scheme, "://", 
+                             req->session->server.hostport, path, NULL);
+    else
+	req->uri = ne_strdup(path);
+
+    {
+	struct hook *hk;
+
+	for (hk = sess->create_req_hooks; hk != NULL; hk = hk->next) {
+	    ne_create_request_fn fn = (ne_create_request_fn)hk->fn;
+	    fn(req, hk->userdata, req->method, req->uri);
+	}
+    }
+
+    return req;
+}
+
+/* Set the request body length to 'length' */
+static void set_body_length(ne_request *req, ne_off_t length)
+{
+    req->body_length = length;
+
+    if (length >= 0)
+        ne_print_request_header(req, "Content-Length", "%" FMT_NE_OFF_T, length);
+    else /* length < 0 => chunked body */
+        ne_add_request_header(req, "Transfer-Encoding", "chunked");
+
+}
+
+void ne_set_request_body_buffer(ne_request *req, const char *buffer,
+				size_t size)
+{
+    req->body.buf.buffer = buffer;
+    req->body.buf.length = size;
+    req->body_cb = body_string_send;
+    req->body_ud = req;
+    set_body_length(req, size);
+}
+
+void ne_set_request_body_provider(ne_request *req, ne_off_t bodysize,
+				  ne_provide_body provider, void *ud)
+{
+    req->body_cb = provider;
+    req->body_ud = ud;
+    set_body_length(req, bodysize);
+}
+
+void ne_set_request_body_fd(ne_request *req, int fd,
+                            ne_off_t offset, ne_off_t length)
+{
+    req->body.file.fd = fd;
+    req->body.file.offset = offset;
+    req->body.file.length = length;
+    req->body_cb = body_fd_send;
+    req->body_ud = req;
+    set_body_length(req, length);
+}
+
+void ne_set_request_flag(ne_request *req, ne_request_flag flag, int value)
+{
+    if (flag < (ne_request_flag)NE_SESSFLAG_LAST) {
+        req->flags[flag] = value;
+    }
+}
+
+int ne_get_request_flag(ne_request *req, ne_request_flag flag)
+{
+    if (flag < (ne_request_flag)NE_REQFLAG_LAST) {
+        return req->flags[flag];
+    }
+    return -1;
+}
+
+void ne_add_request_header(ne_request *req, const char *name, 
+			   const char *value)
+{
+    ne_buffer_concat(req->headers, name, ": ", value, EOL, NULL);
+}
+
+void ne_print_request_header(ne_request *req, const char *name,
+			     const char *format, ...)
+{
+    va_list params;
+    char buf[NE_BUFSIZ];
+    
+    va_start(params, format);
+    ne_vsnprintf(buf, sizeof buf, format, params);
+    va_end(params);
+    
+    ne_buffer_concat(req->headers, name, ": ", buf, EOL, NULL);
+}
+
+/* Returns the value of the response header 'name', for which the hash
+ * value is 'h', or NULL if the header is not found. */
+static inline char *get_response_header_hv(ne_request *req, unsigned int h,
+                                           const char *name)
+{
+    struct field *f;
+
+    for (f = req->response_headers[h]; f; f = f->next)
+        if (strcmp(f->name, name) == 0)
+            return f->value;
+
+    return NULL;
+}
+
+const char *ne_get_response_header(ne_request *req, const char *name)
+{
+    char *lcname = ne_strdup(name);
+    unsigned int hash = hash_and_lower(lcname);
+    char *value = get_response_header_hv(req, hash, lcname);
+    ne_free(lcname);
+    return value;
+}
+
+/* The return value of the iterator function is a pointer to the
+ * struct field of the previously returned header. */
+void *ne_response_header_iterate(ne_request *req, void *iterator,
+                                 const char **name, const char **value)
+{
+    struct field *f = iterator;
+    unsigned int n;
+
+    if (f == NULL) {
+        n = 0;
+    } else if ((f = f->next) == NULL) {
+        n = req->current_index + 1;
+    }
+
+    if (f == NULL) {
+        while (n < HH_HASHSIZE && req->response_headers[n] == NULL)
+            n++;
+        if (n == HH_HASHSIZE)
+            return NULL; /* no more headers */
+        f = req->response_headers[n];
+        req->current_index = n;
+    }
+    
+    *name = f->name;
+    *value = f->value;
+    return f;
+}
+
+/* Removes the response header 'name', which has hash value 'hash'. */
+static void remove_response_header(ne_request *req, const char *name, 
+                                   unsigned int hash)
+{
+    struct field **ptr = req->response_headers + hash;
+
+    while (*ptr) {
+        struct field *const f = *ptr;
+
+        if (strcmp(f->name, name) == 0) {
+            *ptr = f->next;
+            ne_free(f->name);
+            ne_free(f->value);
+            ne_free(f);
+            return;
+        }
+        
+        ptr = &f->next;
+    }
+}
+
+/* Free all stored response headers. */
+static void free_response_headers(ne_request *req)
+{
+    int n;
+
+    for (n = 0; n < HH_HASHSIZE; n++) {
+        struct field **ptr = req->response_headers + n;
+
+        while (*ptr) {
+            struct field *const f = *ptr;
+            *ptr = f->next;
+            ne_free(f->name);
+            ne_free(f->value);
+            ne_free(f);
+	}
+    }
+}
+
+void ne_add_response_body_reader(ne_request *req, ne_accept_response acpt,
+				 ne_block_reader rdr, void *userdata)
+{
+    struct body_reader *new = ne_malloc(sizeof *new);
+    new->accept_response = acpt;
+    new->handler = rdr;
+    new->userdata = userdata;
+    new->next = req->body_readers;
+    req->body_readers = new;
+}
+
+void ne_request_destroy(ne_request *req) 
+{
+    struct body_reader *rdr, *next_rdr;
+    struct hook *hk, *next_hk;
+
+    ne_free(req->uri);
+    ne_free(req->method);
+
+    for (rdr = req->body_readers; rdr != NULL; rdr = next_rdr) {
+	next_rdr = rdr->next;
+	ne_free(rdr);
+    }
+
+    free_response_headers(req);
+
+    ne_buffer_destroy(req->headers);
+
+    NE_DEBUG(NE_DBG_HTTP, "Running destroy hooks.\n");
+    for (hk = req->session->destroy_req_hooks; hk; hk = next_hk) {
+	ne_destroy_req_fn fn = (ne_destroy_req_fn)hk->fn;
+        next_hk = hk->next;
+	fn(req, hk->userdata);
+    }
+
+    for (hk = req->private; hk; hk = next_hk) {
+	next_hk = hk->next;
+	ne_free(hk);
+    }
+
+    if (req->status.reason_phrase)
+	ne_free(req->status.reason_phrase);
+
+    NE_DEBUG(NE_DBG_HTTP, "Request ends.\n");
+    ne_free(req);
+}
+
+
+/* Reads a block of the response into BUFFER, which is of size
+ * *BUFLEN.  Returns zero on success or non-zero on error.  On
+ * success, *BUFLEN is updated to be the number of bytes read into
+ * BUFFER (which will be 0 to indicate the end of the repsonse).  On
+ * error, the connection is closed and the session error string is
+ * set.  */
+static int read_response_block(ne_request *req, struct ne_response *resp, 
+			       char *buffer, size_t *buflen) 
+{
+    ne_socket *const sock = req->session->socket;
+    size_t willread;
+    ssize_t readlen;
+    
+    switch (resp->mode) {
+    case R_CHUNKED:
+        /* Chunked transfer-encoding: chunk syntax is "SIZE CRLF CHUNK
+         * CRLF SIZE CRLF CHUNK CRLF ..." followed by zero-length
+         * chunk: "CHUNK CRLF 0 CRLF".  resp.chunk.remain contains the
+         * number of bytes left to read in the current chunk. */
+	if (resp->body.chunk.remain == 0) {
+	    unsigned long chunk_len;
+	    char *ptr;
+
+            /* Read the chunk size line into a temporary buffer. */
+            SOCK_ERR(req,
+                     ne_sock_readline(sock, req->respbuf, sizeof req->respbuf),
+                     _("Could not read chunk size"));
+            NE_DEBUG(NE_DBG_HTTP, "[chunk] < %s", req->respbuf);
+            chunk_len = strtoul(req->respbuf, &ptr, 16);
+	    /* limit chunk size to <= UINT_MAX, so it will probably
+	     * fit in a size_t. */
+	    if (ptr == req->respbuf || 
+		chunk_len == ULONG_MAX || chunk_len > UINT_MAX) {
+		return aborted(req, _("Could not parse chunk size"), 0);
+	    }
+	    NE_DEBUG(NE_DBG_HTTP, "Got chunk size: %lu\n", chunk_len);
+	    resp->body.chunk.remain = chunk_len;
+	}
+	willread = resp->body.chunk.remain > *buflen
+            ? *buflen : resp->body.chunk.remain;
+	break;
+    case R_CLENGTH:
+	willread = resp->body.clen.remain > (off_t)*buflen 
+            ? *buflen : (size_t)resp->body.clen.remain;
+	break;
+    case R_TILLEOF:
+	willread = *buflen;
+	break;
+    case R_NO_BODY:
+    default:
+	willread = 0;
+	break;
+    }
+    if (willread == 0) {
+	*buflen = 0;
+	return 0;
+    }
+    NE_DEBUG(NE_DBG_HTTP,
+	     "Reading %" NE_FMT_SIZE_T " bytes of response body.\n", willread);
+    readlen = ne_sock_read(sock, buffer, willread);
+
+    /* EOF is only valid when response body is delimited by it.
+     * Strictly, an SSL truncation should not be treated as an EOF in
+     * any case, but SSL servers are just too buggy.  */
+    if (resp->mode == R_TILLEOF && 
+	(readlen == NE_SOCK_CLOSED || readlen == NE_SOCK_TRUNC)) {
+	NE_DEBUG(NE_DBG_HTTP, "Got EOF.\n");
+	req->can_persist = 0;
+	readlen = 0;
+    } else if (readlen < 0) {
+	return aborted(req, _("Could not read response body"), readlen);
+    } else {
+	NE_DEBUG(NE_DBG_HTTP, "Got %" NE_FMT_SSIZE_T " bytes.\n", readlen);
+    }
+    /* safe to cast: readlen guaranteed to be >= 0 above */
+    *buflen = (size_t)readlen;
+    NE_DEBUG(NE_DBG_HTTPBODY,
+	     "Read block (%" NE_FMT_SSIZE_T " bytes):\n[%.*s]\n",
+	     readlen, (int)readlen, buffer);
+    if (resp->mode == R_CHUNKED) {
+	resp->body.chunk.remain -= readlen;
+	if (resp->body.chunk.remain == 0) {
+	    char crlfbuf[2];
+	    /* If we've read a whole chunk, read a CRLF */
+	    readlen = ne_sock_fullread(sock, crlfbuf, 2);
+            if (readlen < 0)
+                return aborted(req, _("Could not read chunk delimiter"),
+                               readlen);
+            else if (crlfbuf[0] != '\r' || crlfbuf[1] != '\n')
+                return aborted(req, _("Chunk delimiter was invalid"), 0);
+	}
+    } else if (resp->mode == R_CLENGTH) {
+	resp->body.clen.remain -= readlen;
+    }
+    resp->progress += readlen;
+    return NE_OK;
+}
+
+ssize_t ne_read_response_block(ne_request *req, char *buffer, size_t buflen)
+{
+    struct body_reader *rdr;
+    size_t readlen = buflen;
+    struct ne_response *const resp = &req->resp;
+
+    if (read_response_block(req, resp, buffer, &readlen))
+	return -1;
+
+    if (readlen) {
+        req->session->status.sr.progress += readlen;
+        notify_status(req->session, ne_status_recving);
+    }
+
+    for (rdr = req->body_readers; rdr!=NULL; rdr=rdr->next) {
+	if (rdr->use && rdr->handler(rdr->userdata, buffer, readlen) != 0) {
+            ne_close_connection(req->session);
+            return -1;
+        }
+    }
+    
+    return readlen;
+}
+
+/* Build the request string, returning the buffer. */
+static ne_buffer *build_request(ne_request *req) 
+{
+    struct hook *hk;
+    ne_buffer *buf = ne_buffer_create();
+
+    /* Add Request-Line and headers: */
+    ne_buffer_concat(buf, req->method, " ", req->uri, " HTTP/1.1" EOL, NULL);
+
+    /* Add custom headers: */
+    ne_buffer_append(buf, req->headers->data, ne_buffer_size(req->headers));
+
+    if (req->body_length && req->flags[NE_REQFLAG_EXPECT100]) {
+        ne_buffer_czappend(buf, "Expect: 100-continue\r\n");
+    }
+
+    NE_DEBUG(NE_DBG_HTTP, "Running pre_send hooks\n");
+    for (hk = req->session->pre_send_hooks; hk!=NULL; hk = hk->next) {
+	ne_pre_send_fn fn = (ne_pre_send_fn)hk->fn;
+	fn(req, hk->userdata, buf);
+    }
+    
+    ne_buffer_czappend(buf, "\r\n");
+    return buf;
+}
+
+#ifdef NE_DEBUGGING
+#define DEBUG_DUMP_REQUEST(x) dump_request(x)
+
+static void dump_request(const char *request)
+{ 
+    if (ne_debug_mask & NE_DBG_HTTPPLAIN) { 
+	/* Display everything mode */
+	NE_DEBUG(NE_DBG_HTTP, "Sending request headers:\n%s", request);
+    } else if (ne_debug_mask & NE_DBG_HTTP) {
+	/* Blank out the Authorization paramaters */
+	char *reqdebug = ne_strdup(request), *pnt = reqdebug;
+	while ((pnt = strstr(pnt, "Authorization: ")) != NULL) {
+	    for (pnt += 15; *pnt != '\r' && *pnt != '\0'; pnt++) {
+		*pnt = 'x';
+	    }
+	}
+	NE_DEBUG(NE_DBG_HTTP, "Sending request headers:\n%s", reqdebug);
+	ne_free(reqdebug);
+    }
+}
+
+#else
+#define DEBUG_DUMP_REQUEST(x)
+#endif /* DEBUGGING */
+
+/* remove trailing EOL from 'buf', where strlen(buf) == *len.  *len is
+ * adjusted in accordance with any changes made to the string to
+ * remain equal to strlen(buf). */
+static inline void strip_eol(char *buf, ssize_t *len)
+{
+    char *pnt = buf + *len - 1;
+    while (pnt >= buf && (*pnt == '\r' || *pnt == '\n')) {
+	*pnt-- = '\0';
+	(*len)--;
+    }
+}
+
+/* Read and parse response status-line into 'status'.  'retry' is non-zero
+ * if an NE_RETRY should be returned if an EOF is received. */
+static int read_status_line(ne_request *req, ne_status *status, int retry)
+{
+    char *buffer = req->respbuf;
+    ssize_t ret;
+
+    ret = ne_sock_readline(req->session->socket, buffer, sizeof req->respbuf);
+    if (ret <= 0) {
+	int aret = aborted(req, _("Could not read status line"), ret);
+	return RETRY_RET(retry, ret, aret);
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "[status-line] < %s", buffer);
+    strip_eol(buffer, &ret);
+    
+    if (status->reason_phrase) ne_free(status->reason_phrase);
+    memset(status, 0, sizeof *status);
+
+    /* Hack to allow ShoutCast-style servers, if requested. */
+    if (req->session->flags[NE_SESSFLAG_ICYPROTO]
+        && strncmp(buffer, "ICY ", 4) == 0 && strlen(buffer) > 8
+        && buffer[7] == ' ') {
+        status->code = atoi(buffer + 4);
+        status->major_version = 1;
+        status->minor_version = 0;
+        status->reason_phrase = ne_strclean(ne_strdup(buffer + 8));
+        status->klass = buffer[4] - '0';
+        NE_DEBUG(NE_DBG_HTTP, "[status-line] ICY protocol; code %d\n", 
+                 status->code);
+    } else if (ne_parse_statusline(buffer, status)) {
+	return aborted(req, _("Could not parse response status line"), 0);
+    }
+
+    return 0;
+}
+
+/* Discard a set of message headers. */
+static int discard_headers(ne_request *req)
+{
+    do {
+	SOCK_ERR(req, ne_sock_readline(req->session->socket, req->respbuf, 
+				       sizeof req->respbuf),
+		 _("Could not read interim response headers"));
+	NE_DEBUG(NE_DBG_HTTP, "[discard] < %s", req->respbuf);
+    } while (strcmp(req->respbuf, EOL) != 0);
+    return NE_OK;
+}
+
+/* Send the request, and read the response Status-Line. Returns:
+ *   NE_RETRY   connection closed by server; persistent connection
+ *		timeout
+ *   NE_OK	success
+ *   NE_*	error
+ * On NE_RETRY and NE_* responses, the connection will have been 
+ * closed already.
+ */
+static int send_request(ne_request *req, const ne_buffer *request)
+{
+    ne_session *const sess = req->session;
+    ne_status *const status = &req->status;
+    int sentbody = 0; /* zero until body has been sent. */
+    int ret, retry; /* retry non-zero whilst the request should be retried */
+    ssize_t sret;
+
+    /* Send the Request-Line and headers */
+    NE_DEBUG(NE_DBG_HTTP, "Sending request-line and headers:\n");
+    /* Open the connection if necessary */
+    ret = open_connection(sess);
+    if (ret) return ret;
+
+    /* Allow retry if a persistent connection has been used. */
+    retry = sess->persisted;
+    
+    sret = ne_sock_fullwrite(req->session->socket, request->data, 
+                             ne_buffer_size(request));
+    if (sret < 0) {
+	int aret = aborted(req, _("Could not send request"), sret);
+	return RETRY_RET(retry, sret, aret);
+    }
+    
+    if (!req->flags[NE_REQFLAG_EXPECT100] && req->body_length) {
+	/* Send request body, if not using 100-continue. */
+	ret = send_request_body(req, retry);
+	if (ret) {
+            return ret;
+	}
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Request sent; retry is %d.\n", retry);
+
+    /* Loop eating interim 1xx responses (RFC2616 says these MAY be
+     * sent by the server, even if 100-continue is not used). */
+    while ((ret = read_status_line(req, status, retry)) == NE_OK 
+	   && status->klass == 1) {
+	NE_DEBUG(NE_DBG_HTTP, "Interim %d response.\n", status->code);
+	retry = 0; /* successful read() => never retry now. */
+	/* Discard headers with the interim response. */
+	if ((ret = discard_headers(req)) != NE_OK) break;
+
+	if (req->flags[NE_REQFLAG_EXPECT100] && (status->code == 100)
+            && req->body_length && !sentbody) {
+	    /* Send the body after receiving the first 100 Continue */
+	    if ((ret = send_request_body(req, 0)) != NE_OK) break;	    
+	    sentbody = 1;
+	}
+    }
+
+    return ret;
+}
+
+/* Read a message header from sock into buf, which has size 'buflen'.
+ *
+ * Returns:
+ *   NE_RETRY: Success, read a header into buf.
+ *   NE_OK: End of headers reached.
+ *   NE_ERROR: Error (session error is set, connection closed).
+ */
+static int read_message_header(ne_request *req, char *buf, size_t buflen)
+{
+    ssize_t n;
+    ne_socket *sock = req->session->socket;
+
+    n = ne_sock_readline(sock, buf, buflen);
+    if (n <= 0)
+	return aborted(req, _("Error reading response headers"), n);
+    NE_DEBUG(NE_DBG_HTTP, "[hdr] %s", buf);
+
+    strip_eol(buf, &n);
+
+    if (n == 0) {
+	NE_DEBUG(NE_DBG_HTTP, "End of headers.\n");
+	return NE_OK;
+    }
+
+    buf += n;
+    buflen -= n;
+
+    while (buflen > 0) {
+	char ch;
+
+	/* Collect any extra lines into buffer */
+	SOCK_ERR(req, ne_sock_peek(sock, &ch, 1),
+		 _("Error reading response headers"));
+
+	if (ch != ' ' && ch != '\t') {
+	    /* No continuation of this header: stop reading. */
+	    return NE_RETRY;
+	}
+
+	/* Otherwise, read the next line onto the end of 'buf'. */
+	n = ne_sock_readline(sock, buf, buflen);
+	if (n <= 0) {
+	    return aborted(req, _("Error reading response headers"), n);
+	}
+
+	NE_DEBUG(NE_DBG_HTTP, "[cont] %s", buf);
+
+	strip_eol(buf, &n);
+	
+	/* assert(buf[0] == ch), which implies len(buf) > 0.
+	 * Otherwise the TCP stack is lying, but we'll be paranoid.
+	 * This might be a \t, so replace it with a space to be
+	 * friendly to applications (2616 says we MAY do this). */
+	if (n) buf[0] = ' ';
+
+	/* ready for the next header. */
+	buf += n;
+	buflen -= n;
+    }
+
+    ne_set_error(req->session, _("Response header too long"));
+    return NE_ERROR;
+}
+
+#define MAX_HEADER_LEN (8192)
+
+/* Add a respnose header field for the given request, using
+ * precalculated hash value. */
+static void add_response_header(ne_request *req, unsigned int hash,
+                                char *name, char *value)
+{
+    struct field **nextf = &req->response_headers[hash];
+    size_t vlen = strlen(value);
+
+    while (*nextf) {
+        struct field *const f = *nextf;
+        if (strcmp(f->name, name) == 0) {
+            if (vlen + f->vlen < MAX_HEADER_LEN) {
+                /* merge the header field */
+                f->value = ne_realloc(f->value, f->vlen + vlen + 3);
+                memcpy(f->value + f->vlen, ", ", 2);
+                memcpy(f->value + f->vlen + 2, value, vlen + 1);
+                f->vlen += vlen + 2;
+            }
+            return;
+        }
+        nextf = &f->next;
+    }
+    
+    (*nextf) = ne_malloc(sizeof **nextf);
+    (*nextf)->name = ne_strdup(name);
+    (*nextf)->value = ne_strdup(value);
+    (*nextf)->vlen = vlen;
+    (*nextf)->next = NULL;
+}
+
+/* Read response headers.  Returns NE_* code, sets session error and
+ * closes connection on error. */
+static int read_response_headers(ne_request *req) 
+{
+    char hdr[MAX_HEADER_LEN];
+    int ret, count = 0;
+    
+    while ((ret = read_message_header(req, hdr, sizeof hdr)) == NE_RETRY 
+	   && ++count < MAX_HEADER_FIELDS) {
+	char *pnt;
+	unsigned int hash = 0;
+	
+	/* Strip any trailing whitespace */
+	pnt = hdr + strlen(hdr) - 1;
+	while (pnt > hdr && (*pnt == ' ' || *pnt == '\t'))
+	    *pnt-- = '\0';
+
+	/* Convert the header name to lower case and hash it. */
+	for (pnt = hdr; (*pnt != '\0' && *pnt != ':' && 
+			 *pnt != ' ' && *pnt != '\t'); pnt++) {
+	    *pnt = ne_tolower(*pnt);
+	    hash = HH_ITERATE(hash,*pnt);
+	}
+
+	/* Skip over any whitespace before the colon. */
+	while (*pnt == ' ' || *pnt == '\t')
+	    *pnt++ = '\0';
+
+	/* ignore header lines which lack a ':'. */
+	if (*pnt != ':')
+	    continue;
+	
+	/* NUL-terminate at the colon (when no whitespace before) */
+	*pnt++ = '\0';
+
+	/* Skip any whitespace after the colon... */
+	while (*pnt == ' ' || *pnt == '\t')
+	    pnt++;
+
+	/* pnt now points to the header value. */
+	NE_DEBUG(NE_DBG_HTTP, "Header Name: [%s], Value: [%s]\n", hdr, pnt);
+        add_response_header(req, hash, hdr, pnt);
+    }
+
+    if (count == MAX_HEADER_FIELDS)
+	ret = aborted(
+	    req, _("Response exceeded maximum number of header fields"), 0);
+
+    return ret;
+}
+
+/* Perform any necessary DNS lookup for the host given by *info;
+ * returns NE_ code with error string set on error. */
+static int lookup_host(ne_session *sess, struct host_info *info)
+{
+    NE_DEBUG(NE_DBG_HTTP, "Doing DNS lookup on %s...\n", info->hostname);
+    sess->status.lu.hostname = info->hostname;
+    notify_status(sess, ne_status_lookup);
+    info->address = ne_addr_resolve(info->hostname, 0);
+    if (ne_addr_result(info->address)) {
+	char buf[256];
+	ne_set_error(sess, _("Could not resolve hostname `%s': %s"), 
+		     info->hostname,
+		     ne_addr_error(info->address, buf, sizeof buf));
+	ne_addr_destroy(info->address);
+	info->address = NULL;
+	return NE_LOOKUP;
+    } else {
+	return NE_OK;
+    }
+}
+
+int ne_begin_request(ne_request *req)
+{
+    struct body_reader *rdr;
+    ne_buffer *data;
+    const ne_status *const st = &req->status;
+    const char *value;
+    struct hook *hk;
+    int ret, forced_closure = 0;
+
+    /* If a non-idempotent request is sent on a persisted connection,
+     * then it is impossible to distinguish between a server failure
+     * and a connection timeout if an EOF/RST is received.  So don't
+     * do that. */
+    if (!req->flags[NE_REQFLAG_IDEMPOTENT] && req->session->persisted
+        && !req->session->flags[NE_SESSFLAG_CONNAUTH]) {
+        NE_DEBUG(NE_DBG_HTTP, "req: Closing connection for non-idempotent "
+                 "request.\n");
+        ne_close_connection(req->session);
+    }
+
+    /* Build the request string, and send it */
+    data = build_request(req);
+    DEBUG_DUMP_REQUEST(data->data);
+    ret = send_request(req, data);
+    /* Retry this once after a persistent connection timeout. */
+    if (ret == NE_RETRY) {
+	NE_DEBUG(NE_DBG_HTTP, "Persistent connection timed out, retrying.\n");
+	ret = send_request(req, data);
+    }
+    ne_buffer_destroy(data);
+    if (ret != NE_OK) return ret == NE_RETRY ? NE_ERROR : ret;
+
+    /* Determine whether server claims HTTP/1.1 compliance. */
+    req->session->is_http11 = (st->major_version == 1 && 
+                               st->minor_version > 0) || st->major_version > 1;
+
+    /* Persistent connections supported implicitly in HTTP/1.1 */
+    if (req->session->is_http11) req->can_persist = 1;
+
+    ne_set_error(req->session, "%d %s", st->code, st->reason_phrase);
+    
+    /* Empty the response header hash, in case this request was
+     * retried: */
+    free_response_headers(req);
+
+    /* Read the headers */
+    ret = read_response_headers(req);
+    if (ret) return ret;
+
+    /* check the Connection header */
+    value = get_response_header_hv(req, HH_HV_CONNECTION, "connection");
+    if (value) {
+        char *vcopy = ne_strdup(value), *ptr = vcopy;
+
+        do {
+            char *token = ne_shave(ne_token(&ptr, ','), " \t");
+            unsigned int hash = hash_and_lower(token);
+
+            if (strcmp(token, "close") == 0) {
+                req->can_persist = 0;
+                forced_closure = 1;
+            } else if (strcmp(token, "keep-alive") == 0) {
+                req->can_persist = 1;
+            } else if (!req->session->is_http11
+                       && strcmp(token, "connection")) {
+                /* Strip the header per 261614.10, last para.  Avoid
+                 * danger from "Connection: connection". */
+                remove_response_header(req, token, hash);
+            }
+        } while (ptr);
+        
+        ne_free(vcopy);
+    }
+
+    /* Support "Proxy-Connection: keep-alive" for compatibility with
+     * some HTTP/1.0 proxies; it is risky to do this, because an
+     * intermediary proxy may not support this HTTP/1.0 extension, but
+     * will not strip the header either.  Persistent connection
+     * support is enabled based on the presence of this header if:
+     * a) it is *necessary* to do so due to the use of a connection-auth
+     * scheme, and
+     * b) connection closure was not forced via "Connection: close".  */
+    if (req->session->nexthop->proxy == PROXY_HTTP && !req->session->is_http11
+        && !forced_closure && req->session->flags[NE_SESSFLAG_CONNAUTH]) {
+        value = get_response_header_hv(req, HH_HV_PROXY_CONNECTION,
+                                       "proxy-connection");
+        if (value && ne_strcasecmp(value, "keep-alive") == 0) {
+            NE_DEBUG(NE_DBG_HTTP, "req: Using persistent connection "
+                     "for HTTP/1.0 proxy requiring conn-auth hack.\n");
+            req->can_persist = 1;
+        }
+    }
+
+    /* Decide which method determines the response message-length per
+     * 26164.4 (multipart/byteranges is not supported): */
+
+#ifdef NE_HAVE_SSL
+    /* Special case for CONNECT handling: the response has no body,
+     * and the connection can persist. */
+    if (req->session->in_connect && st->klass == 2) {
+	req->resp.mode = R_NO_BODY;
+	req->can_persist = 1;
+    } else
+#endif
+    /* HEAD requests and 204, 304 responses have no response body,
+     * regardless of what headers are present. */
+    if (req->method_is_head || st->code == 204 || st->code == 304) {
+    	req->resp.mode = R_NO_BODY;
+    }
+    /* Broken intermediaries exist which use "transfer-encoding: identity"
+     * to mean "no transfer-coding".  So that case must be ignored. */
+    else if ((value = get_response_header_hv(req, HH_HV_TRANSFER_ENCODING,
+                                             "transfer-encoding")) != NULL
+             && ne_strcasecmp(value, "identity") != 0) {
+        /* Otherwise, fail iff an unknown transfer-coding is used. */
+        if (ne_strcasecmp(value, "chunked") == 0) {
+            req->resp.mode = R_CHUNKED;
+            req->resp.body.chunk.remain = 0;
+        }
+        else {
+            return aborted(req, _("Unknown transfer-coding in response"), 0);
+        }
+    } 
+    else if ((value = get_response_header_hv(req, HH_HV_CONTENT_LENGTH,
+                                             "content-length")) != NULL) {
+        char *endptr = NULL;
+        ne_off_t len = ne_strtoff(value, &endptr, 10);
+
+        if (*value && len != NE_OFFT_MAX && len >= 0 && endptr && *endptr == '\0') {
+            req->resp.mode = R_CLENGTH;
+            req->resp.body.clen.total = req->resp.body.clen.remain = len;
+        } else {
+            /* fail for an invalid content-length header. */
+            return aborted(req, _("Invalid Content-Length in response"), 0);
+        }
+    } else {
+        req->resp.mode = R_TILLEOF; /* otherwise: read-till-eof mode */
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Running post_headers hooks\n");
+    for (hk = req->session->post_headers_hooks; hk != NULL; hk = hk->next) {
+        ne_post_headers_fn fn = (ne_post_headers_fn)hk->fn;
+        fn(req, hk->userdata, &req->status);
+    }
+    
+    /* Prepare for reading the response entity-body.  Call each of the
+     * body readers and ask them whether they want to accept this
+     * response or not. */
+    for (rdr = req->body_readers; rdr != NULL; rdr=rdr->next) {
+	rdr->use = rdr->accept_response(rdr->userdata, req, st);
+    }
+
+    req->session->status.sr.progress = 0;
+    req->session->status.sr.total = 
+        req->resp.mode == R_CLENGTH ? req->resp.body.clen.total : -1;
+    notify_status(req->session, ne_status_recving);
+    
+    return NE_OK;
+}
+
+int ne_end_request(ne_request *req)
+{
+    struct hook *hk;
+    int ret;
+
+    /* Read headers in chunked trailers */
+    if (req->resp.mode == R_CHUNKED) {
+	ret = read_response_headers(req);
+        if (ret) return ret;
+    } else {
+        ret = NE_OK;
+    }
+    
+    NE_DEBUG(NE_DBG_HTTP, "Running post_send hooks\n");
+    for (hk = req->session->post_send_hooks; 
+	 ret == NE_OK && hk != NULL; hk = hk->next) {
+	ne_post_send_fn fn = (ne_post_send_fn)hk->fn;
+	ret = fn(req, hk->userdata, &req->status);
+    }
+    
+    /* Close the connection if persistent connections are disabled or
+     * not supported by the server. */
+    if (!req->session->flags[NE_SESSFLAG_PERSIST] || !req->can_persist)
+	ne_close_connection(req->session);
+    else
+	req->session->persisted = 1;
+    
+    return ret;
+}
+
+int ne_read_response_to_fd(ne_request *req, int fd)
+{
+    ssize_t len;
+
+    while ((len = ne_read_response_block(req, req->respbuf, 
+                                         sizeof req->respbuf)) > 0) {
+        const char *block = req->respbuf;
+
+        do {
+            ssize_t ret = write(fd, block, len);
+            if (ret == -1 && errno == EINTR) {
+                continue;
+            } else if (ret < 0) {
+                char err[200];
+                ne_strerror(errno, err, sizeof err);
+                ne_set_error(ne_get_session(req), 
+                             _("Could not write to file: %s"), err);
+                return NE_ERROR;
+            } else {
+                len -= ret;
+                block += ret;
+            }
+        } while (len > 0);
+    }
+    
+    return len == 0 ? NE_OK : NE_ERROR;
+}
+
+int ne_discard_response(ne_request *req)
+{
+    ssize_t len;
+
+    do {
+        len = ne_read_response_block(req, req->respbuf, sizeof req->respbuf);
+    } while (len > 0);
+    
+    return len == 0 ? NE_OK : NE_ERROR;
+}
+
+int ne_request_dispatch(ne_request *req) 
+{
+    int ret;
+    
+    do {
+	ret = ne_begin_request(req);
+        if (ret == NE_OK) ret = ne_discard_response(req);
+        if (ret == NE_OK) ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    NE_DEBUG(NE_DBG_HTTP | NE_DBG_FLUSH, 
+             "Request ends, status %d class %dxx, error line:\n%s\n", 
+             req->status.code, req->status.klass, req->session->error);
+
+    return ret;
+}
+
+const ne_status *ne_get_status(const ne_request *req)
+{
+    return &req->status;
+}
+
+ne_session *ne_get_session(const ne_request *req)
+{
+    return req->session;
+}
+
+#ifdef NE_HAVE_SSL
+/* Create a CONNECT tunnel through the proxy server.
+ * Returns HTTP_* */
+static int proxy_tunnel(ne_session *sess)
+{
+    /* Hack up an HTTP CONNECT request... */
+    ne_request *req;
+    int ret = NE_OK;
+    char ruri[200];
+
+    /* Can't use server.hostport here; Request-URI must include `:port' */
+    ne_snprintf(ruri, sizeof ruri, "%s:%u", sess->server.hostname,  
+		sess->server.port);
+    req = ne_request_create(sess, "CONNECT", ruri);
+
+    sess->in_connect = 1;
+    ret = ne_request_dispatch(req);
+    sess->in_connect = 0;
+
+    sess->persisted = 0; /* don't treat this is a persistent connection. */
+
+    if (ret != NE_OK || !sess->connected || req->status.klass != 2) {
+        char *err = ne_strdup(sess->error);
+        ne_set_error(sess, _("Could not create SSL connection "
+                             "through proxy server: %s"), err);
+        ne_free(err);
+        if (ret == NE_OK) ret = NE_ERROR;
+    }
+
+    ne_request_destroy(req);
+    return ret;
+}
+#endif
+
+/* Return the first resolved address for the given host. */
+static const ne_inet_addr *resolve_first(struct host_info *host)
+{
+    return host->network ? host->network : ne_addr_first(host->address);
+}
+
+/* Return the next resolved address for the given host or NULL if
+ * there are no more addresses. */
+static const ne_inet_addr *resolve_next(struct host_info *host)
+{
+    return host->network ? NULL : ne_addr_next(host->address);
+}
+
+/* Make new TCP connection to server at 'host' of type 'name'.  Note
+ * that once a connection to a particular network address has
+ * succeeded, that address will be used first for the next attempt to
+ * connect. */
+static int do_connect(ne_session *sess, struct host_info *host)
+{
+    int ret;
+
+    /* Resolve hostname if necessary. */
+    if (host->address == NULL && host->network == NULL) {
+        ret = lookup_host(sess, host);
+        if (ret) return ret;
+    }
+
+    if ((sess->socket = ne_sock_create()) == NULL) {
+        ne_set_error(sess, _("Could not create socket"));
+        return NE_ERROR;
+    }
+
+    if (sess->cotimeout)
+	ne_sock_connect_timeout(sess->socket, sess->cotimeout);
+
+    if (sess->local_addr)
+        ne_sock_prebind(sess->socket, sess->local_addr, 0);
+
+    if (host->current == NULL)
+	host->current = resolve_first(host);
+
+    sess->status.ci.hostname = host->hostname;
+
+    do {
+        sess->status.ci.address = host->current;
+	notify_status(sess, ne_status_connecting);
+#ifdef NE_DEBUGGING
+	if (ne_debug_mask & NE_DBG_HTTP) {
+	    char buf[150];
+	    NE_DEBUG(NE_DBG_HTTP, "req: Connecting to %s:%u\n",
+		     ne_iaddr_print(host->current, buf, sizeof buf),
+                     host->port);
+	}
+#endif
+	ret = ne_sock_connect(sess->socket, host->current, host->port);
+    } while (ret && /* try the next address... */
+	     (host->current = resolve_next(host)) != NULL);
+
+    if (ret) {
+        const char *msg;
+
+        if (host->proxy == PROXY_NONE)
+            msg = _("Could not connect to server");
+        else
+            msg = _("Could not connect to proxy server");
+
+        ne_set_error(sess, "%s: %s", msg, ne_sock_error(sess->socket));
+        ne_sock_close(sess->socket);
+	return ret == NE_SOCK_TIMEOUT ? NE_TIMEOUT : NE_CONNECT;
+    }
+
+    if (sess->rdtimeout)
+	ne_sock_read_timeout(sess->socket, sess->rdtimeout);
+
+    notify_status(sess, ne_status_connected);
+    sess->nexthop = host;
+
+    sess->connected = 1;
+    /* clear persistent connection flag. */
+    sess->persisted = 0;
+    return NE_OK;
+}
+
+/* For a SOCKSv4 proxy only, the IP address of the origin server (in
+ * addition to the proxy) must be known, and must be an IPv4 address.
+ * Returns NE_*; connection closed and error string set on error. */
+static int socks_origin_lookup(ne_session *sess)
+{
+    const ne_inet_addr *ia;
+    int ret;
+
+    ret = lookup_host(sess, &sess->server);
+    if (ret) {
+        /* lookup_host already set the error string. */
+        ne_close_connection(sess);
+        return ret;
+    }
+    
+    /* Find the first IPv4 address available for the server. */
+    for (ia = ne_addr_first(sess->server.address);
+         ia && ne_iaddr_typeof(ia) == ne_iaddr_ipv6;
+         ia = ne_addr_next(sess->server.address)) {
+        /* noop */
+    }
+
+    /* ... if any */
+    if (ia == NULL) {
+        ne_set_error(sess, _("Could not find IPv4 address of "
+                             "hostname %s for SOCKS v4 proxy"), 
+                     sess->server.hostname);
+        ne_close_connection(sess);
+        return NE_LOOKUP;
+    }
+
+    sess->server.current = ia;
+    
+    return ret;
+}
+
+static int open_connection(ne_session *sess) 
+{
+    int ret;
+    
+    if (sess->connected) return NE_OK;
+
+    if (!sess->proxies) {
+        ret = do_connect(sess, &sess->server);
+        if (ret) {
+            sess->nexthop = NULL;
+            return ret;
+        }
+    }
+    else {
+        struct host_info *hi;
+
+        /* Attempt to re-use proxy to avoid iterating through
+         * unnecessarily. */
+        if (sess->prev_proxy) 
+            ret = do_connect(sess, sess->prev_proxy);
+        else
+            ret = NE_ERROR;
+
+        /* Otherwise, try everything - but omitting prev_proxy if that
+         * has already been tried. */
+        for (hi = sess->proxies; hi && ret; hi = hi->next) {
+            if (hi != sess->prev_proxy)
+                ret = do_connect(sess, hi);
+        }
+
+        if (ret == NE_OK && sess->nexthop->proxy == PROXY_SOCKS) {
+            /* Special-case for SOCKS v4 proxies, which require the
+             * client to resolve the origin server IP address. */
+            if (sess->socks_ver == NE_SOCK_SOCKSV4) {
+                ret = socks_origin_lookup(sess);
+            }
+            
+            if (ret == NE_OK) {
+                /* Perform the SOCKS handshake, instructing the proxy
+                 * to set up the connection to the origin server. */
+                ret = ne_sock_proxy(sess->socket, sess->socks_ver, 
+                                    sess->server.current,
+                                    sess->server.hostname, sess->server.port,
+                                    sess->socks_user, sess->socks_password);
+                if (ret) {
+                    ne_set_error(sess, 
+                                 _("Could not establish connection from "
+                                   "SOCKS proxy (%s:%u): %s"),
+                                 sess->nexthop->hostname,
+                                 sess->nexthop->port,
+                                 ne_sock_error(sess->socket));
+                    ne_close_connection(sess);
+                    ret = NE_ERROR;
+                }
+            }
+        }
+
+        if (ret != NE_OK) {
+            sess->nexthop = NULL;
+            sess->prev_proxy = NULL;
+            return ret;
+        }
+        
+        /* Success - make this proxy stick. */
+        sess->prev_proxy = hi;
+    }
+
+#ifdef NE_HAVE_SSL
+    /* Negotiate SSL layer if required. */
+    if (sess->use_ssl && !sess->in_connect) {
+        /* Set up CONNECT tunnel if using an HTTP proxy. */
+        if (sess->nexthop->proxy == PROXY_HTTP)
+            ret = proxy_tunnel(sess);
+        
+        if (ret == NE_OK) {
+            ret = ne__negotiate_ssl(sess);
+            if (ret != NE_OK)
+                ne_close_connection(sess);
+        }
+    }
+#endif
+    
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_request.h b/net/mmt/neon/src/ne_request.h
new file mode 100644
index 0000000..be6f3a1
--- /dev/null
+++ b/net/mmt/neon/src/ne_request.h
@@ -0,0 +1,318 @@
+/* 
+   HTTP Request Handling
+   Copyright (C) 1999-2006, 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_REQUEST_H
+#define NE_REQUEST_H
+
+#include "ne_utils.h" /* For ne_status */
+#include "ne_string.h" /* For ne_buffer */
+#include "ne_session.h"
+
+NE_BEGIN_DECLS
+
+#define NE_OK (0) /* Success */
+#define NE_ERROR (1) /* Generic error; use ne_get_error(session) for message */
+#define NE_LOOKUP (2) /* Server or proxy hostname lookup failed */
+#define NE_AUTH (3) /* User authentication failed on server */
+#define NE_PROXYAUTH (4) /* User authentication failed on proxy */
+#define NE_CONNECT (5) /* Could not connect to server */
+#define NE_TIMEOUT (6) /* Connection timed out */
+#define NE_FAILED (7) /* The precondition failed */
+#define NE_RETRY (8) /* Retry request (ne_end_request ONLY) */
+#define NE_REDIRECT (9) /* See ne_redirect.h */
+
+/* Opaque object representing a single HTTP request. */
+typedef struct ne_request_s ne_request;
+
+/***** Request Handling *****/
+
+/* Create a request in session 'sess', with given method and path.
+ * 'path' must conform to the 'abs_path' grammar in RFC2396, with an
+ * optional "? query" part, and MUST be URI-escaped by the caller. */
+ne_request *ne_request_create(ne_session *sess,
+			      const char *method, const char *path);
+
+/* The request body will be taken from 'size' bytes of 'buffer'. */
+void ne_set_request_body_buffer(ne_request *req, const char *buffer,
+				size_t size);
+
+/* The request body will be taken from 'length' bytes read from the
+ * file descriptor 'fd', starting from file offset 'offset'. */
+void ne_set_request_body_fd(ne_request *req, int fd,
+                            ne_off_t offset, ne_off_t length);
+
+/* "Pull"-based request body provider: a callback which is invoked to
+ * provide blocks of request body on demand.
+ *
+ * Before each time the body is provided, the callback will be called
+ * once with buflen == 0.  The body may have to be provided >1 time
+ * per request (for authentication retries etc.).
+ *
+ * For a call with buflen == 0, the callback must return zero on success
+ * or non-zero on error; the session error string must be set on error.
+ * For a call with buflen > 0, the callback must return:
+ *        <0           : error, abort request; session error string must be set.
+ *         0           : ignore 'buffer' contents, end of body.
+ *     0 < x <= buflen : buffer contains x bytes of body data.  */
+typedef ssize_t (*ne_provide_body)(void *userdata, 
+				   char *buffer, size_t buflen);
+
+/* Install a callback which is invoked as needed to provide the
+ * request body, a block at a time.  The total size of the request
+ * body is 'length'; the callback must ensure that it returns no more
+ * than 'length' bytes in total.  If 'length' is set to -1, then the
+ * total size of the request is unknown by the caller and chunked 
+ * tranfer will be used. */
+void ne_set_request_body_provider(ne_request *req, ne_off_t length,
+                                  ne_provide_body provider, void *userdata);
+
+/* Handling response bodies; two callbacks must be provided:
+ *
+ * 1) 'acceptance' callback: determines whether you want to handle the
+ * response body given the response-status information, e.g., if you
+ * only want 2xx responses, say so here.
+ *
+ * 2) 'reader' callback: passed blocks of the response-body as they
+ * arrive, if the acceptance callback returned non-zero.  */
+
+/* 'acceptance' callback type. Return non-zero to accept the response,
+ * else zero to ignore it. */
+typedef int (*ne_accept_response)(void *userdata, ne_request *req, 
+                                  const ne_status *st);
+
+/* An 'acceptance' callback which only accepts 2xx-class responses.
+ * Ignores userdata. */
+int ne_accept_2xx(void *userdata, ne_request *req, const ne_status *st);
+
+/* An acceptance callback which accepts all responses.  Ignores
+ * userdata. */
+int ne_accept_always(void *userdata, ne_request *req, const ne_status *st);
+
+/* Callback for reading a block of data.  Returns zero on success, or
+ * non-zero on error.  If returning an error, the response will be
+ * aborted and the callback will not be invoked again.  The request
+ * dispatch (or ne_read_response_block call) will fail with NE_ERROR;
+ * the session error string should have been set by the callback. */
+typedef int (*ne_block_reader)(void *userdata, const char *buf, size_t len);
+
+/* Add a response reader for the given request, with the given
+ * acceptance function. userdata is passed as the first argument to
+ * the acceptance + reader callbacks. 
+ *
+ * The acceptance callback is called once each time the request is
+ * sent: it may be sent >1 time because of authentication retries etc.
+ * For each time the acceptance callback is called, if it returns
+ * non-zero, blocks of the response body will be passed to the reader
+ * callback as the response is read.  After all the response body has
+ * been read, the callback will be called with a 'len' argument of
+ * zero.  */
+void ne_add_response_body_reader(ne_request *req, ne_accept_response accpt,
+				 ne_block_reader reader, void *userdata);
+
+/* Retrieve the value of the response header field with given name;
+ * returns NULL if no response header with given name was found.  The
+ * return value is valid only until the next call to either
+ * ne_request_destroy or ne_begin_request for this request. */
+const char *ne_get_response_header(ne_request *req, const char *name);
+
+/* Iterator interface for response headers: if passed a NULL cursor,
+ * returns the first header; if passed a non-NULL cursor pointer,
+ * returns the next header.  The return value is a cursor pointer: if
+ * it is non-NULL, *name and *value are set to the name and value of
+ * the header field.  If the return value is NULL, no more headers are
+ * found, *name and *value are undefined.
+ *
+ * The order in which response headers is returned is undefined.  Both
+ * the cursor and name/value pointers are valid only until the next
+ * call to either ne_request_destroy or ne_begin_request for this
+ * request. */
+void *ne_response_header_iterate(ne_request *req, void *cursor,
+                                 const char **name, const char **value);
+
+/* Adds a header to the request with given name and value. */
+void ne_add_request_header(ne_request *req, const char *name, 
+			   const char *value);
+/* Adds a header to the request with given name, using printf-like
+ * format arguments for the value. */
+void ne_print_request_header(ne_request *req, const char *name,
+			     const char *format, ...) 
+    ne_attribute((format(printf, 3, 4)));
+
+/* ne_request_dispatch: Sends the given request, and reads the
+ * response.  Returns:
+ *  - NE_OK if the request was sent and response read successfully
+ *  - NE_AUTH, NE_PROXYAUTH for a server or proxy server authentication error
+ *  - NE_CONNECT if connection could not be established
+ *  - NE_TIMEOUT if an timeout occurred sending or reading from the server
+ *  - NE_ERROR for other fatal dispatch errors
+ * On any error, the session error string is set.  On success or
+ * authentication error, the actual response-status can be retrieved using
+ * ne_get_status(). */
+int ne_request_dispatch(ne_request *req);
+
+/* Returns a pointer to the response status information for the given
+ * request; pointer is valid until request object is destroyed. */
+const ne_status *ne_get_status(const ne_request *req) ne_attribute((const));
+
+/* Returns pointer to session associated with request. */
+ne_session *ne_get_session(const ne_request *req) ne_attribute((const));
+
+/* Destroy memory associated with request pointer */
+void ne_request_destroy(ne_request *req);
+
+/* "Caller-pulls" request interface.  This is an ALTERNATIVE interface
+ * to ne_request_dispatch: either use that, or do all this yourself:
+ *
+ * caller must call:
+ *  1. ne_begin_request (fail if returns non-NE_OK)
+ *  2. while(ne_read_response_block(...) > 0) ... loop ...;
+ *     (fail if ne_read_response_block returns <0)
+ *  3. ne_end_request
+ *
+ * ne_end_request and ne_begin_request both return an NE_* code; if
+ * ne_end_request returns NE_RETRY, you must restart the loop from (1)
+ * above. */
+int ne_begin_request(ne_request *req);
+int ne_end_request(ne_request *req);
+
+/* Read a block of the response into the passed buffer of size 'buflen'.
+ *
+ * Returns:
+ *  <0 - error, stop reading.
+ *   0 - end of response
+ *  >0 - number of bytes read into buffer.
+ */
+ssize_t ne_read_response_block(ne_request *req, char *buffer, size_t buflen);
+
+/* Read response blocks until end of response; exactly equivalent to
+ * calling ne_read_response_block() until it returns 0.  Returns
+ * non-zero on error. */
+int ne_discard_response(ne_request *req);
+
+/* Read response blocks until end of response, writing content to the
+ * given file descriptor.  Returns NE_ERROR on error. */
+int ne_read_response_to_fd(ne_request *req, int fd);
+
+/* Defined request flags: */
+typedef enum ne_request_flag_e {
+    NE_REQFLAG_EXPECT100 = 0, /* enable this flag to enable use of the
+                               * "Expect: 100-continue" for the
+                               * request. */
+
+    NE_REQFLAG_IDEMPOTENT, /* disable this flag if the request uses a
+                            * non-idempotent method such as POST. */
+
+    NE_REQFLAG_LAST /* enum sentinel value */
+} ne_request_flag;
+
+/* Set a new value for a particular request flag. */
+void ne_set_request_flag(ne_request *req, ne_request_flag flag, int value);
+
+/* Return 0 if the given flag is not set, >0 it is set, or -1 if the
+ * flag is not supported. */
+int ne_get_request_flag(ne_request *req, ne_request_flag flag);
+
+/**** Request hooks handling *****/
+
+typedef void (*ne_free_hooks)(void *cookie);
+
+/* Hook called when a request is created; passed the request method,
+ * and the string used as the Request-URI (note that this may be a
+ * absolute URI if a proxy is in use, an absolute path, a "*", etc).
+ * A create_request hook is called exactly once per request. */
+typedef void (*ne_create_request_fn)(ne_request *req, void *userdata,
+				     const char *method, const char *requri);
+void ne_hook_create_request(ne_session *sess, 
+			    ne_create_request_fn fn, void *userdata);
+
+/* Hook called before the request is sent.  'header' is the raw HTTP
+ * header before the trailing CRLF is added; more headers can be added
+ * here.  A pre_send hook may be called >1 time per request if the
+ * request is retried due to a post_send hook returning NE_RETRY. */
+typedef void (*ne_pre_send_fn)(ne_request *req, void *userdata, 
+			       ne_buffer *header);
+void ne_hook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata);
+
+/* Hook called directly after the response headers have been read, but
+ * before the resposnse body has been read.  'status' is the response
+ * status-code.  A post_header hook may be called >1 time per request
+ * if the request is retried due to a post_send hook returning
+ * NE_RETRY. */
+typedef void (*ne_post_headers_fn)(ne_request *req, void *userdata,
+                                   const ne_status *status);
+void ne_hook_post_headers(ne_session *sess, 
+                          ne_post_headers_fn fn, void *userdata);
+
+/* Hook called after the request is dispatched (request sent, and
+ * the entire response read).  If an error occurred reading the response,
+ * this hook will not run.  May return:
+ *  NE_OK     everything is okay
+ *  NE_RETRY  try sending the request again.
+ * anything else signifies an error, and the request is failed. The return
+ * code is passed back the _dispatch caller, so the session error must
+ * also be set appropriately (ne_set_error).
+ */
+typedef int (*ne_post_send_fn)(ne_request *req, void *userdata,
+			       const ne_status *status);
+void ne_hook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata);
+
+/* Hook called when the function is destroyed. */
+typedef void (*ne_destroy_req_fn)(ne_request *req, void *userdata);
+void ne_hook_destroy_request(ne_session *sess,
+			     ne_destroy_req_fn fn, void *userdata);
+
+typedef void (*ne_destroy_sess_fn)(void *userdata);
+/* Hook called when the session is about to be destroyed. */
+void ne_hook_destroy_session(ne_session *sess,
+			     ne_destroy_sess_fn fn, void *userdata);
+
+typedef void (*ne_close_conn_fn)(void *userdata);
+/* Hook called when the connection is closed; note that this hook
+ * may be called *AFTER* the destroy_session hook. */
+void ne_hook_close_conn(ne_session *sess, ne_close_conn_fn fn, void *userdata);
+
+/* The ne_unhook_* functions remove a hook registered with the given
+ * session.  If a hook is found which was registered with a given
+ * function 'fn', and userdata pointer 'userdata', then it will be
+ * removed from the hooks list.
+ *
+ * It is unsafe to use any of these functions from a hook function to
+ * unregister itself, except for ne_unhook_destroy_request. */
+void ne_unhook_create_request(ne_session *sess, 
+                              ne_create_request_fn fn, void *userdata);
+void ne_unhook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata);
+void ne_unhook_post_headers(ne_session *sess, ne_post_headers_fn fn, void *userdata);
+void ne_unhook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata);
+void ne_unhook_destroy_request(ne_session *sess,
+                               ne_destroy_req_fn fn, void *userdata);
+void ne_unhook_destroy_session(ne_session *sess,
+                               ne_destroy_sess_fn fn, void *userdata);
+void ne_unhook_close_conn(ne_session *sess, 
+                          ne_close_conn_fn fn, void *userdata);
+
+/* Store an opaque context for the request, 'priv' is returned by a
+ * call to ne_request_get_private with the same ID. */
+void ne_set_request_private(ne_request *req, const char *id, void *priv);
+void *ne_get_request_private(ne_request *req, const char *id);
+
+NE_END_DECLS
+
+#endif /* NE_REQUEST_H */
diff --git a/net/mmt/neon/src/ne_session.c b/net/mmt/neon/src/ne_session.c
new file mode 100644
index 0000000..6e1f395
--- /dev/null
+++ b/net/mmt/neon/src/ne_session.c
@@ -0,0 +1,745 @@
+/* 
+   HTTP session handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
+#ifdef HAVE_LIBPROXY
+#include <proxy.h>
+#endif
+
+#include "ne_session.h"
+#include "ne_alloc.h"
+#include "ne_utils.h"
+#include "ne_internal.h"
+#include "ne_string.h"
+#include "ne_dates.h"
+
+#include "ne_private.h"
+
+/* Destroy a a list of hooks. */
+static void destroy_hooks(struct hook *hooks)
+{
+    struct hook *nexthk;
+
+    while (hooks) {
+	nexthk = hooks->next;
+	ne_free(hooks);
+	hooks = nexthk;
+    }
+}
+
+static void free_hostinfo(struct host_info *hi)
+{
+    if (hi->hostname) ne_free(hi->hostname);
+    if (hi->hostport) ne_free(hi->hostport);
+    if (hi->address) ne_addr_destroy(hi->address);
+}
+
+/* Destroy the sess->proxies array. */
+static void free_proxies(ne_session *sess)
+{
+    struct host_info *hi, *nexthi;
+
+    for (hi = sess->proxies; hi; hi = nexthi) {
+        nexthi = hi->next;
+        free_hostinfo(hi);
+        ne_free(hi);
+    }
+
+    sess->proxies = NULL;
+    sess->any_proxy_http = 0;
+}
+
+void ne_session_destroy(ne_session *sess) 
+{
+    struct hook *hk;
+
+    NE_DEBUG(NE_DBG_HTTP, "sess: Destroying session.\n");
+
+    /* Run the destroy hooks. */
+    for (hk = sess->destroy_sess_hooks; hk != NULL; hk = hk->next) {
+	ne_destroy_sess_fn fn = (ne_destroy_sess_fn)hk->fn;
+	fn(hk->userdata);
+    }
+
+    /* Close the connection; note that the notifier callback could
+     * still be invoked here. */
+    if (sess->connected) {
+        ne_close_connection(sess);
+    }
+    
+    destroy_hooks(sess->create_req_hooks);
+    destroy_hooks(sess->pre_send_hooks);
+    destroy_hooks(sess->post_headers_hooks);
+    destroy_hooks(sess->post_send_hooks);
+    destroy_hooks(sess->destroy_req_hooks);
+    destroy_hooks(sess->destroy_sess_hooks);
+    destroy_hooks(sess->close_conn_hooks);
+    destroy_hooks(sess->private);
+
+    ne_free(sess->scheme);
+
+    free_hostinfo(&sess->server);
+    free_proxies(sess);
+
+    if (sess->user_agent) ne_free(sess->user_agent);
+    if (sess->socks_user) ne_free(sess->socks_user);
+    if (sess->socks_password) ne_free(sess->socks_password);
+
+#ifdef NE_HAVE_SSL
+    if (sess->ssl_context)
+        ne_ssl_context_destroy(sess->ssl_context);
+
+    if (sess->server_cert)
+        ne_ssl_cert_free(sess->server_cert);
+    
+    if (sess->client_cert)
+        ne_ssl_clicert_free(sess->client_cert);
+#endif
+
+    ne_free(sess);
+}
+
+int ne_version_pre_http11(ne_session *s)
+{
+    return !s->is_http11;
+}
+
+/* Stores the "hostname[:port]" segment */
+static void set_hostport(struct host_info *host, unsigned int defaultport)
+{
+    size_t len = strlen(host->hostname);
+    host->hostport = ne_malloc(len + 10);
+    strcpy(host->hostport, host->hostname);
+    if (host->port != defaultport)
+	ne_snprintf(host->hostport + len, 9, ":%u", host->port);
+}
+
+/* Stores the hostname/port in *info, setting up the "hostport"
+ * segment correctly. */
+static void set_hostinfo(struct host_info *hi, enum proxy_type type, 
+                         const char *hostname, unsigned int port)
+{
+    hi->hostname = ne_strdup(hostname);
+    hi->port = port;
+    hi->proxy = type;
+}
+
+ne_session *ne_session_create(const char *scheme,
+			      const char *hostname, unsigned int port)
+{
+    ne_session *sess = ne_calloc(sizeof *sess);
+
+    NE_DEBUG(NE_DBG_HTTP, "HTTP session to %s://%s:%d begins.\n",
+	     scheme, hostname, port);
+
+    strcpy(sess->error, "Unknown error.");
+
+    /* use SSL if scheme is https */
+    sess->use_ssl = !strcmp(scheme, "https");
+    
+    /* set the hostname/port */
+    set_hostinfo(&sess->server, PROXY_NONE, hostname, port);
+    set_hostport(&sess->server, sess->use_ssl?443:80);
+
+#ifdef NE_HAVE_SSL
+    if (sess->use_ssl) {
+        ne_inet_addr *ia;
+
+        sess->ssl_context = ne_ssl_context_create(0);
+        sess->flags[NE_SESSFLAG_SSLv2] = 1;
+        
+        /* If the hostname parses as an IP address, don't
+         * enable SNI by default. */
+        ia = ne_iaddr_parse(hostname, ne_iaddr_ipv4);
+        if (ia == NULL)
+            ia = ne_iaddr_parse(hostname, ne_iaddr_ipv6);
+
+        if (ia) {
+            ne_iaddr_free(ia);
+        } 
+        else {
+            sess->flags[NE_SESSFLAG_TLS_SNI] = 1;
+        }
+        NE_DEBUG(NE_DBG_SSL, "ssl: SNI %s by default.\n",
+                 sess->flags[NE_SESSFLAG_TLS_SNI] ?
+                 "enabled" : "disabled");
+    }
+#endif
+
+    sess->scheme = ne_strdup(scheme);
+
+    /* Set flags which default to on: */
+    sess->flags[NE_SESSFLAG_PERSIST] = 1;
+
+    return sess;
+}
+
+void ne_session_proxy(ne_session *sess, const char *hostname,
+		      unsigned int port)
+{
+    free_proxies(sess);
+
+    sess->proxies = ne_calloc(sizeof *sess->proxies);
+
+    sess->any_proxy_http = 1;
+    
+    set_hostinfo(sess->proxies, PROXY_HTTP, hostname, port);
+}
+
+void ne_session_socks_proxy(ne_session *sess, enum ne_sock_sversion vers, 
+                            const char *hostname, unsigned int port,
+                            const char *username, const char *password)
+{
+    free_proxies(sess);
+
+    sess->proxies = ne_calloc(sizeof *sess->proxies);
+
+    set_hostinfo(sess->proxies, PROXY_SOCKS, hostname, port);
+
+    sess->socks_ver = vers;
+
+    if (username) sess->socks_user = ne_strdup(username);
+    if (password) sess->socks_password = ne_strdup(password);
+}
+
+void ne_session_system_proxy(ne_session *sess, unsigned int flags)
+{
+#ifdef HAVE_LIBPROXY
+    pxProxyFactory *pxf = px_proxy_factory_new();
+    struct host_info *hi, **lasthi;
+    char *url, **proxies;
+    ne_uri uri;
+    unsigned n;
+
+    free_proxies(sess);
+
+    /* Create URI for session to pass off to libproxy */
+    memset(&uri, 0, sizeof uri);
+    ne_fill_server_uri(sess, &uri);
+
+    uri.path = "/"; /* make valid URI structure. */
+    url = ne_uri_unparse(&uri);
+    uri.path = NULL;
+
+    /* Get list of pseudo-URIs from libproxy: */
+    proxies = px_proxy_factory_get_proxies(pxf, url);
+    
+    for (n = 0, lasthi = &sess->proxies; proxies[n]; n++) {
+        enum proxy_type ptype;
+
+        ne_uri_free(&uri);
+
+        NE_DEBUG(NE_DBG_HTTP, "sess: libproxy #%u=%s\n", 
+                 n, proxies[n]);
+
+        if (ne_uri_parse(proxies[n], &uri))
+            continue;
+        
+        if (!uri.scheme) continue;
+
+        if (ne_strcasecmp(uri.scheme, "http") == 0)
+            ptype = PROXY_HTTP;
+        else if (ne_strcasecmp(uri.scheme, "socks") == 0)
+            ptype = PROXY_SOCKS;
+        else if (ne_strcasecmp(uri.scheme, "direct") == 0)
+            ptype = PROXY_NONE;
+        else
+            continue;
+
+        /* Hostname/port required for http/socks schemes. */
+        if (ptype != PROXY_NONE && !(uri.host && uri.port))
+            continue;
+        
+        /* Do nothing if libproxy returned only a single "direct://"
+         * entry -- a single "direct" (noop) proxy is equivalent to
+         * having none. */
+        if (n == 0 && proxies[1] == NULL && ptype == PROXY_NONE)
+            break;
+
+        NE_DEBUG(NE_DBG_HTTP, "sess: Got proxy %s://%s:%d\n",
+                 uri.scheme, uri.host ? uri.host : "(none)",
+                 uri.port);
+        
+        hi = *lasthi = ne_calloc(sizeof *hi);
+        
+        if (ptype == PROXY_NONE) {
+            /* A "direct" URI requires an attempt to connect directly to
+             * the origin server, so dup the server details. */
+            set_hostinfo(hi, ptype, sess->server.hostname,
+                         sess->server.port);
+        }
+        else {
+            /* SOCKS/HTTP proxy. */
+            set_hostinfo(hi, ptype, uri.host, uri.port);
+
+            if (ptype == PROXY_HTTP)
+                sess->any_proxy_http = 1;
+            else if (ptype == PROXY_SOCKS)
+                sess->socks_ver = NE_SOCK_SOCKSV5;
+        }
+
+        lasthi = &hi->next;
+    }
+
+    /* Free up the proxies array: */
+    for (n = 0; proxies[n]; n++)
+        free(proxies[n]);
+    free(proxies[n]);
+
+    ne_free(url);
+    ne_uri_free(&uri);
+    px_proxy_factory_free(pxf);
+#endif
+}
+
+void ne_set_addrlist2(ne_session *sess, unsigned int port,
+                      const ne_inet_addr **addrs, size_t n)
+{
+    struct host_info *hi, **lasthi;
+    size_t i;
+
+    free_proxies(sess);
+
+    lasthi = &sess->proxies;
+
+    for (i = 0; i < n; i++) {
+        *lasthi = hi = ne_calloc(sizeof *hi);
+        
+        hi->proxy = PROXY_NONE;
+        hi->network = addrs[i];
+        hi->port = port;
+
+        lasthi = &hi->next;
+    }
+}
+
+void ne_set_addrlist(ne_session *sess, const ne_inet_addr **addrs, size_t n)
+{
+    ne_set_addrlist2(sess, sess->server.port, addrs, n);
+}
+
+void ne_set_localaddr(ne_session *sess, const ne_inet_addr *addr)
+{
+    sess->local_addr = addr;    
+}
+
+void ne_set_error(ne_session *sess, const char *format, ...)
+{
+    va_list params;
+
+    va_start(params, format);
+    ne_vsnprintf(sess->error, sizeof sess->error, format, params);
+    va_end(params);
+}
+
+void ne_set_session_flag(ne_session *sess, ne_session_flag flag, int value)
+{
+    if (flag < NE_SESSFLAG_LAST) {
+        sess->flags[flag] = value;
+#ifdef NE_HAVE_SSL
+        if (flag == NE_SESSFLAG_SSLv2 && sess->ssl_context) {
+            ne_ssl_context_set_flag(sess->ssl_context, NE_SSL_CTX_SSLv2, value);
+            sess->flags[flag] = ne_ssl_context_get_flag(sess->ssl_context, NE_SSL_CTX_SSLv2);
+        }
+#endif
+    }
+}
+
+int ne_get_session_flag(ne_session *sess, ne_session_flag flag)
+{
+    if (flag < NE_SESSFLAG_LAST) {
+        return sess->flags[flag];
+    }
+    return -1;
+}
+
+static void progress_notifier(void *userdata, ne_session_status status,
+                              const ne_session_status_info *info)
+{
+    ne_session *sess = userdata;
+
+    if (status == ne_status_sending || status == ne_status_recving) {
+        sess->progress_cb(sess->progress_ud, info->sr.progress, info->sr.total);    
+    }
+}
+
+void ne_set_progress(ne_session *sess, ne_progress progress, void *userdata)
+{
+    if (progress) {
+        sess->progress_cb = progress;
+        sess->progress_ud = userdata;
+        ne_set_notifier(sess, progress_notifier, sess);
+    }
+    else {
+        ne_set_notifier(sess, NULL, NULL);
+    }
+}
+
+void ne_set_notifier(ne_session *sess,
+		     ne_notify_status status, void *userdata)
+{
+    sess->notify_cb = status;
+    sess->notify_ud = userdata;
+}
+
+void ne_set_read_timeout(ne_session *sess, int timeout)
+{
+    sess->rdtimeout = timeout;
+}
+
+void ne_set_connect_timeout(ne_session *sess, int timeout)
+{
+    sess->cotimeout = timeout;
+}
+
+#define UAHDR "User-Agent: "
+#define AGENT " neon/" NEON_VERSION "\r\n"
+
+void ne_set_useragent(ne_session *sess, const char *token)
+{
+    if (sess->user_agent) ne_free(sess->user_agent);
+    sess->user_agent = ne_malloc(strlen(UAHDR) + strlen(AGENT) + 
+                                 strlen(token) + 1);
+#ifdef HAVE_STPCPY
+    strcpy(stpcpy(stpcpy(sess->user_agent, UAHDR), token), AGENT);
+#else
+    strcat(strcat(strcpy(sess->user_agent, UAHDR), token), AGENT);
+#endif
+}
+
+const char *ne_get_server_hostport(ne_session *sess)
+{
+    return sess->server.hostport;
+}
+
+const char *ne_get_scheme(ne_session *sess)
+{
+    return sess->scheme;
+}
+
+void ne_fill_server_uri(ne_session *sess, ne_uri *uri)
+{
+    uri->host = ne_strdup(sess->server.hostname);
+    uri->port = sess->server.port;
+    uri->scheme = ne_strdup(sess->scheme);
+}
+
+void ne_fill_proxy_uri(ne_session *sess, ne_uri *uri)
+{
+    if (sess->proxies) {
+        struct host_info *hi = sess->nexthop ? sess->nexthop : sess->proxies;
+
+        if (hi->proxy == PROXY_HTTP) {
+            uri->host = ne_strdup(hi->hostname);
+            uri->port = hi->port;
+        }
+    }
+}
+
+const char *ne_get_error(ne_session *sess)
+{
+    return sess->error;
+}
+
+void ne_close_connection(ne_session *sess)
+{
+    if (sess->connected) {
+        struct hook *hk;
+
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Closing connection.\n");
+
+        if (sess->notify_cb) {
+            sess->status.cd.hostname = sess->nexthop->hostname;
+            sess->notify_cb(sess->notify_ud, ne_status_disconnected, 
+                            &sess->status);
+        }
+
+        /* Run the close_conn hooks. */
+        for (hk = sess->close_conn_hooks; hk != NULL; hk = hk->next) {
+            ne_close_conn_fn fn = (ne_close_conn_fn)hk->fn;
+            fn(hk->userdata);
+        }
+
+	ne_sock_close(sess->socket);
+	sess->socket = NULL;
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Connection closed.\n");
+    } else {
+        NE_DEBUG(NE_DBG_SOCKET, "sess: Not closing closed connection.\n");
+    }
+    sess->connected = 0;
+}
+
+void ne_ssl_set_verify(ne_session *sess, ne_ssl_verify_fn fn, void *userdata)
+{
+    sess->ssl_verify_fn = fn;
+    sess->ssl_verify_ud = userdata;
+}
+
+void ne_ssl_provide_clicert(ne_session *sess, 
+			  ne_ssl_provide_fn fn, void *userdata)
+{
+    sess->ssl_provide_fn = fn;
+    sess->ssl_provide_ud = userdata;
+}
+
+void ne_ssl_trust_cert(ne_session *sess, const ne_ssl_certificate *cert)
+{
+#ifdef NE_HAVE_SSL
+    if (sess->ssl_context) {
+        ne_ssl_context_trustcert(sess->ssl_context, cert);
+    }
+#endif
+}
+
+void ne_ssl_cert_validity(const ne_ssl_certificate *cert, char *from, char *until)
+{
+#ifdef NE_HAVE_SSL
+    time_t tf, tu;
+    char *date;
+
+    ne_ssl_cert_validity_time(cert, &tf, &tu);
+    
+    if (from) {
+        if (tf != (time_t) -1) {
+            date = ne_rfc1123_date(tf);
+            ne_strnzcpy(from, date, NE_SSL_VDATELEN);
+            ne_free(date);
+        }
+        else {
+            ne_strnzcpy(from, _("[invalid date]"), NE_SSL_VDATELEN);
+        }
+    }
+        
+    if (until) {
+        if (tu != (time_t) -1) {
+            date = ne_rfc1123_date(tu);
+            ne_strnzcpy(until, date, NE_SSL_VDATELEN);
+            ne_free(date);
+        }
+        else {
+            ne_strnzcpy(until, _("[invalid date]"), NE_SSL_VDATELEN);
+        }
+    }
+#endif
+}
+
+#ifdef NE_HAVE_SSL
+void ne__ssl_set_verify_err(ne_session *sess, int failures)
+{
+    static const struct {
+	int bit;
+	const char *str;
+    } reasons[] = {
+	{ NE_SSL_NOTYETVALID, N_("certificate is not yet valid") },
+	{ NE_SSL_EXPIRED, N_("certificate has expired") },
+	{ NE_SSL_IDMISMATCH, N_("certificate issued for a different hostname") },
+	{ NE_SSL_UNTRUSTED, N_("issuer is not trusted") },
+        { NE_SSL_BADCHAIN, N_("bad certificate chain") },
+        { NE_SSL_REVOKED, N_("certificate has been revoked") },
+	{ 0, NULL }
+    };
+    int n, flag = 0;
+
+    strcpy(sess->error, _("Server certificate verification failed: "));
+
+    for (n = 0; reasons[n].bit; n++) {
+	if (failures & reasons[n].bit) {
+	    if (flag) strncat(sess->error, ", ", sizeof sess->error - 1);
+	    strncat(sess->error, _(reasons[n].str), sizeof sess->error - 1);
+	    flag = 1;
+	}
+    }
+}
+
+/* This doesn't actually implement complete RFC 2818 logic; omits
+ * "f*.example.com" support for simplicity. */
+int ne__ssl_match_hostname(const char *cn, size_t cnlen, const char *hostname)
+{
+    const char *dot;
+
+    NE_DEBUG(NE_DBG_SSL, "ssl: Match common name '%s' against '%s'\n",
+             cn, hostname);
+
+    if (strncmp(cn, "*.", 2) == 0 && cnlen > 2
+        && (dot = strchr(hostname, '.')) != NULL) {
+        ne_inet_addr *ia;
+
+        /* Prevent wildcard CN matches against anything which can be
+         * parsed as an IP address (i.e. a CN of "*.1.1.1" should not
+         * be match 8.1.1.1).  draft-saintandre-tls-server-id-check
+         * will require some more significant changes to cert ID
+         * verification which will probably obviate this check, but
+         * this is a desirable policy tightening in the mean time. */
+        ia = ne_iaddr_parse(hostname, ne_iaddr_ipv4);
+        if (ia == NULL)
+            ia = ne_iaddr_parse(hostname, ne_iaddr_ipv6);
+        
+        if (ia) {
+            NE_DEBUG(NE_DBG_SSL, "ssl: Denying wildcard match for numeric "
+                     "IP address.\n");
+            ne_iaddr_free(ia);
+            return 0;
+        }
+
+	hostname = dot + 1;
+	cn += 2;
+        cnlen -= 2;
+    }
+
+    return cnlen == strlen(hostname) && !ne_strcasecmp(cn, hostname);
+}
+
+#endif /* NE_HAVE_SSL */
+
+typedef void (*void_fn)(void);
+
+#define ADD_HOOK(hooks, fn, ud) add_hook(&(hooks), NULL, (void_fn)(fn), (ud))
+
+static void add_hook(struct hook **hooks, const char *id, void_fn fn, void *ud)
+{
+    struct hook *hk = ne_malloc(sizeof (struct hook)), *pos;
+
+    if (*hooks != NULL) {
+	for (pos = *hooks; pos->next != NULL; pos = pos->next)
+	    /* nullop */;
+	pos->next = hk;
+    } else {
+	*hooks = hk;
+    }
+
+    hk->id = id;
+    hk->fn = fn;
+    hk->userdata = ud;
+    hk->next = NULL;
+}
+
+void ne_hook_create_request(ne_session *sess, 
+			    ne_create_request_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->create_req_hooks, fn, userdata);
+}
+
+void ne_hook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->pre_send_hooks, fn, userdata);
+}
+
+void ne_hook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->post_send_hooks, fn, userdata);
+}
+
+void ne_hook_post_headers(ne_session *sess, ne_post_headers_fn fn, 
+                          void *userdata)
+{
+    ADD_HOOK(sess->post_headers_hooks, fn, userdata);
+}
+
+void ne_hook_destroy_request(ne_session *sess,
+			     ne_destroy_req_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->destroy_req_hooks, fn, userdata);    
+}
+
+void ne_hook_destroy_session(ne_session *sess,
+			     ne_destroy_sess_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->destroy_sess_hooks, fn, userdata);
+}
+
+void ne_hook_close_conn(ne_session *sess,
+                        ne_close_conn_fn fn, void *userdata)
+{
+    ADD_HOOK(sess->close_conn_hooks, fn, userdata);
+}
+
+void ne_set_session_private(ne_session *sess, const char *id, void *userdata)
+{
+    add_hook(&sess->private, id, NULL, userdata);
+}
+
+static void remove_hook(struct hook **hooks, void_fn fn, void *ud)
+{
+    struct hook **p = hooks;
+
+    while (*p) {
+        if ((*p)->fn == fn && (*p)->userdata == ud) {
+            struct hook *next = (*p)->next;
+            ne_free(*p);
+            (*p) = next;
+            break;
+        }
+        p = &(*p)->next;
+    }
+}
+
+#define REMOVE_HOOK(hooks, fn, ud) remove_hook(&hooks, (void_fn)fn, ud)
+
+void ne_unhook_create_request(ne_session *sess, 
+                              ne_create_request_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->create_req_hooks, fn, userdata);
+}
+
+void ne_unhook_pre_send(ne_session *sess, ne_pre_send_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->pre_send_hooks, fn, userdata);
+}
+
+void ne_unhook_post_headers(ne_session *sess, ne_post_headers_fn fn, 
+			    void *userdata)
+{
+    REMOVE_HOOK(sess->post_headers_hooks, fn, userdata);
+}
+
+void ne_unhook_post_send(ne_session *sess, ne_post_send_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->post_send_hooks, fn, userdata);
+}
+
+void ne_unhook_destroy_request(ne_session *sess,
+                               ne_destroy_req_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->destroy_req_hooks, fn, userdata);    
+}
+
+void ne_unhook_destroy_session(ne_session *sess,
+                               ne_destroy_sess_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->destroy_sess_hooks, fn, userdata);
+}
+
+void ne_unhook_close_conn(ne_session *sess,
+                          ne_close_conn_fn fn, void *userdata)
+{
+    REMOVE_HOOK(sess->close_conn_hooks, fn, userdata);
+}
diff --git a/net/mmt/neon/src/ne_session.h b/net/mmt/neon/src/ne_session.h
new file mode 100644
index 0000000..58493bf
--- /dev/null
+++ b/net/mmt/neon/src/ne_session.h
@@ -0,0 +1,350 @@
+/* 
+   HTTP session handling
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SESSION_H
+#define NE_SESSION_H 1
+
+#include <sys/types.h>
+
+#include "ne_ssl.h"
+#include "ne_uri.h" /* for ne_uri */
+#include "ne_defs.h"
+#include "ne_socket.h"
+
+NE_BEGIN_DECLS
+
+typedef struct ne_session_s ne_session;
+
+/* Create a session to the given server, using the given scheme.  If
+ * "https" is passed as the scheme, SSL will be used to connect to the
+ * server. */
+ne_session *ne_session_create(const char *scheme,
+			      const char *hostname, unsigned int port);
+
+/* Finish an HTTP session */
+void ne_session_destroy(ne_session *sess);
+
+/* Prematurely force the connection to be closed for the given
+ * session. */
+void ne_close_connection(ne_session *sess);
+
+/* Configure an HTTP proxy server for the session.  This function will
+ * override (remove) any proxy servers previously configured, and must
+ * be called before any requests are created using this session. */
+void ne_session_proxy(ne_session *sess,
+		      const char *hostname, unsigned int port);
+
+/* Configure a SOCKS proxy server which will be used for the session.
+ * The SOCKS protocol version 'vers' will be used to contact the
+ * proxy at given 'hostname' and 'port'.
+ *
+ * If SOCKSv4 or v4a are used, username must be non-NULL.  For v5,
+ * username may be NULL, in which case, password is ignored.  If
+ * username is non-NULL, password must also be non-NULL.
+ *
+ * This function will override (remove) any proxy servers previously
+ * configured, and must be called before any requests are created
+ * using this session. */
+void ne_session_socks_proxy(ne_session *sess, enum ne_sock_sversion vers,
+                            const char *hostname, unsigned int port,
+                            const char *username, const char *password);
+
+/* Configure use of proxy servers from any system-wide default sources
+ * which are configured at build time.  This function will override
+ * (remove) any proxy servers previously configured, and must be
+ * called before any requests are created using this session.  The
+ * 'flags' parameter must be zero.  */
+void ne_session_system_proxy(ne_session *sess, unsigned int flags);
+
+/* Defined session flags: */
+typedef enum ne_session_flag_e {
+    NE_SESSFLAG_PERSIST = 0, /* disable this flag to prevent use of
+                              * persistent connections. */
+
+    NE_SESSFLAG_ICYPROTO, /* enable this flag to enable support for
+                           * non-HTTP ShoutCast-style "ICY" responses. */
+
+    NE_SESSFLAG_SSLv2, /* disable this flag to disable support for
+                        * SSLv2, if supported by the SSL library. */
+
+    NE_SESSFLAG_RFC4918, /* enable this flag to enable support for
+                          * RFC4918-only WebDAV features; losing
+                          * backwards-compatibility with RFC2518
+                          * servers. */
+
+    NE_SESSFLAG_CONNAUTH, /* enable this flag if an awful, broken,
+                           * RFC-violating, connection-based HTTP
+                           * authentication scheme is in use. */
+
+    NE_SESSFLAG_TLS_SNI, /* disable this flag to disable use of the
+                          * TLS Server Name Indication extension. */
+
+    NE_SESSFLAG_EXPECT100, /* enable this flag to enable the flag
+                            * NE_REQFLAG_EXPECT100 for new requests. */
+
+    NE_SESSFLAG_LAST /* enum sentinel value */
+} ne_session_flag;
+
+/* Set a new value for a particular session flag. */
+void ne_set_session_flag(ne_session *sess, ne_session_flag flag, int value);
+
+/* Return 0 if the given flag is not set, >0 it is set, or -1 if the
+ * flag is not supported. */
+int ne_get_session_flag(ne_session *sess, ne_session_flag flag);
+
+/* Bypass the normal name resolution; force the use of specific set of
+ * addresses for this session, addrs[0]...addrs[n-1].  The 'addrs'
+ * array and pointed-to objects must remain valid until the session is
+ * destroyed.  This function will override (remove) any proxy servers
+ * previously configured, and must be called before any requests are
+ * created using this session.  */
+void ne_set_addrlist(ne_session *sess, const ne_inet_addr **addrs, size_t n);
+
+/* Bypass the normal name resolution; force the use of specific set of
+ * addresses for this session, addrs[0]...addrs[n-1].  The 'addrs'
+ * array and pointed-to objects must remain valid until the session is
+ * destroyed.  This function will override (remove) any proxy servers
+ * previously configured, and must be called before any requests are
+ * created using this session.  Port number 'port' will be used
+ * instead of the "real" session port, to connect to the proxy. */
+void ne_set_addrlist2(ne_session *sess, unsigned int port, 
+                      const ne_inet_addr **addrs, size_t n);
+
+/* Bind connections to the specified local address.  If the address
+ * determined for the remote host has a different family (type) to
+ * 'addr', 'addr' will be ignored.  The 'addr' object must remain
+ * valid until the session is destroyed. */
+void ne_set_localaddr(ne_session *sess, const ne_inet_addr *addr);
+
+/* DEPRECATED: Progress callback. */
+typedef void (*ne_progress)(void *userdata, ne_off_t progress, ne_off_t total);
+
+/* DEPRECATED API: Set a progress callback for the session; this is
+ * deprecated in favour of ne_set_notifier().  The progress callback
+ * is invoked for after each block of the request and response body to
+ * indicate request and response progress (there is no way to
+ * distinguish between the two using this interface alone).
+ * If progress is NULL, any existing callback is deregistered and will
+ * no longer be invoked.
+ *
+ * NOTE: Use of this interface is mutually exclusive with the use of
+ * ne_set_notifier().  A call to ne_set_progress() removes the
+ * notifier callback, and vice versa. */
+void ne_set_progress(ne_session *sess, ne_progress progress, void *userdata);
+
+/* Store an opaque context for the session, 'priv' is returned by a
+ * call to ne_session_get_private with the same ID. */
+void ne_set_session_private(ne_session *sess, const char *id, void *priv);
+void *ne_get_session_private(ne_session *sess, const char *id);
+
+/* Status event type.  NOTE: More event types may be added in
+ * subsequent releases, so callers must ignore unknown status types
+ * for forwards-compatibility.  */
+typedef enum {
+    ne_status_lookup = 0, /* looking up hostname */
+    ne_status_connecting, /* connecting to host */
+    ne_status_connected, /* connected to host */
+    ne_status_sending, /* sending a request body */
+    ne_status_recving, /* receiving a response body */
+    ne_status_disconnected /* disconnected from host */
+} ne_session_status;
+
+/* Status event information union; the relevant structure within
+ * corresponds to the event type.  WARNING: the size of this union is
+ * not limited by ABI constraint; it may be extended with additional
+ * members of different size, or existing members may be extended. */
+typedef union ne_session_status_info_u {
+    struct /* ne_status_lookup */ {
+        /* The hostname which is being resolved: */
+        const char *hostname;
+    } lu;
+    struct /* ne_status_connecting */ {
+        /* The hostname and network address to which a connection
+         * attempt is being made: */
+        const char *hostname;
+        const ne_inet_addr *address;
+    } ci;
+    struct /* ne_status_connected, ne_status_disconnected */ {
+        /* The hostname to which a connection has just been
+         * established or closed: */
+        const char *hostname;
+    } cd;
+    struct /* ne_status_sending and ne_status_recving */ {
+        /* Request/response body transfer progress; if total == -1,
+         * the total size is unknown; otherwise, total gives the total
+         * number of bytes which will be transferred.  progress gives
+         * the number of bytes transferred so far. */
+        ne_off_t progress, total;
+    } sr;
+} ne_session_status_info;
+
+/* Callback invoked to notify a new session status event, given by the
+ * 'status' argument.  On invocation, the contents of exactly one of
+ * the structures in the info union will be valid, as indicated
+ * above. */
+typedef void (*ne_notify_status)(void *userdata, ne_session_status status,
+                                 const ne_session_status_info *info);
+
+/* Set a status notification callback for the session, to report
+ * session status events.  Only one notification callback per session
+ * can be registered; the most recent of successive calls to this
+ * function takes effect.  If status is NULL, any existing callback
+ * is deregistered and will no longer be invoked.
+ *
+ * NOTE: Use of this interface is mutually exclusive with the use of
+ * ne_set_progress().  A call to ne_set_notifier() removes the
+ * progress callback, and vice versa. */
+void ne_set_notifier(ne_session *sess, ne_notify_status status, void *userdata);
+
+/* Certificate verification failures. */
+
+/* NE_SSL_NOTYETVALID: the certificate is not yet valid. */
+#define NE_SSL_NOTYETVALID (0x01)
+
+/* NE_SSL_EXPIRED: the certificate has expired. */
+#define NE_SSL_EXPIRED (0x02)
+
+/* NE_SSL_IDMISMATCH: the hostname for which the certificate was
+ * issued does not match the hostname of the server; this could mean
+ * that the connection is being intercepted. */
+#define NE_SSL_IDMISMATCH (0x04)
+
+/* NE_SSL_UNTRUSTED: the certificate authority which signed the server
+ * certificate is not trusted: there is no indicatation the server is
+ * who they claim to be: */
+#define NE_SSL_UNTRUSTED (0x08)
+
+/* NE_SSL_BADCHAIN: the certificate chain contained a certificate
+ * other than the server cert which failed verification for a reason
+ * other than lack of trust; for example, due to a CA cert being
+ * outside its validity period. */
+#define NE_SSL_BADCHAIN (0x10)
+
+/* N.B.: 0x20 is reserved. */
+
+/* NE_SSL_REVOKED: the server certificate has been revoked by the
+ * issuing authority. */
+#define NE_SSL_REVOKED (0x40)
+
+/* For purposes of forwards-compatibility, the bitmask of all
+ * currently exposed failure bits is given as NE_SSL_FAILMASK.  If the
+ * expression (failures & ~NE_SSL_FAILMASK) is non-zero a failure type
+ * is present which the application does not recognize but must treat
+ * as a verification failure nonetheless. */
+#define NE_SSL_FAILMASK (0x5f)
+
+/* A callback which is used when server certificate verification is
+ * needed.  The reasons for verification failure are given in the
+ * 'failures' parameter, which is a binary OR of one or more of the
+ * above NE_SSL_* values. failures is guaranteed to be non-zero.  The
+ * callback must return zero to accept the certificate: a non-zero
+ * return value will fail the SSL negotiation. */
+typedef int (*ne_ssl_verify_fn)(void *userdata, int failures,
+				const ne_ssl_certificate *cert);
+
+/* Install a callback to handle server certificate verification.  This
+ * is required when the CA certificate is not known for the server
+ * certificate, or the server cert has other verification problems. */
+void ne_ssl_set_verify(ne_session *sess, ne_ssl_verify_fn fn, void *userdata);
+
+/* Use the given client certificate for the session.  The client cert
+ * MUST be in the decrypted state, otherwise behaviour is undefined.
+ * The 'clicert' object is duplicated internally so can be destroyed
+ * by the caller.  */
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *clicert);
+
+/* Indicate that the certificate 'cert' is trusted; the 'cert' object
+ * is duplicated internally so can be destroyed by the caller.  This
+ * function has no effect for non-SSL sessions. */
+void ne_ssl_trust_cert(ne_session *sess, const ne_ssl_certificate *cert);
+
+/* If the SSL library provided a default set of CA certificates, trust
+ * this set of CAs. */
+void ne_ssl_trust_default_ca(ne_session *sess);
+
+/* Callback used to load a client certificate on demand.  If dncount
+ * is > 0, the 'dnames' array dnames[0] through dnames[dncount-1]
+ * gives the list of CA names which the server indicated were
+ * acceptable.  The callback should load an appropriate client
+ * certificate and then pass it to 'ne_ssl_set_clicert'. */
+typedef void (*ne_ssl_provide_fn)(void *userdata, ne_session *sess,
+				  const ne_ssl_dname *const *dnames,
+                                  int dncount);
+
+/* Register a function to be called when the server requests a client
+ * certificate. */
+void ne_ssl_provide_clicert(ne_session *sess, 
+                            ne_ssl_provide_fn fn, void *userdata);
+
+/* Set the timeout (in seconds) used when reading from a socket.  The
+ * timeout value must be greater than zero. */
+void ne_set_read_timeout(ne_session *sess, int timeout);
+
+/* Set the timeout (in seconds) used when making a connection.  The
+ * timeout value must be greater than zero. */
+void ne_set_connect_timeout(ne_session *sess, int timeout);
+
+/* Sets the user-agent string. neon/VERSION will be appended, to make
+ * the full header "User-Agent: product neon/VERSION".
+ * If this function is not called, the User-Agent header is not sent.
+ * The product string must follow the RFC2616 format, i.e.
+ *       product         = token ["/" product-version]
+ *       product-version = token
+ * where token is any alpha-numeric-y string [a-zA-Z0-9]* */
+void ne_set_useragent(ne_session *sess, const char *product);
+
+/* Returns non-zero if next-hop server does not claim compliance to
+ * HTTP/1.1 or later. */
+int ne_version_pre_http11(ne_session *sess);
+
+/* Returns the 'hostport' URI segment for the end-server, e.g.
+ * "my.server.com:8080". */
+const char *ne_get_server_hostport(ne_session *sess);
+
+/* Returns the URL scheme being used for the current session, omitting
+ * the trailing ':'; e.g. "http" or "https". */
+const char *ne_get_scheme(ne_session *sess);
+
+/* Sets the host, scheme, and port fields of the given URI structure
+ * to that of the configured server and scheme for the session; host
+ * and scheme are malloc-allocated.  No other fields in the URI
+ * structure are changed. */
+void ne_fill_server_uri(ne_session *sess, ne_uri *uri);
+
+/* If a proxy is configured, sets the host and port fields in the
+ * given URI structure to that of the proxy.  If multiple proxies are
+ * configured, the active is used if any, otherwise the first.  The
+ * hostname is malloc-allocated.  No other fields in the URI structure
+ * are changed; if no proxy is configured or a non-HTTP proxy is in
+ * use, no fields are changed. */
+void ne_fill_proxy_uri(ne_session *sess, ne_uri *uri);
+
+/* Set the error string for the session; takes printf-like format
+ * string. */
+void ne_set_error(ne_session *sess, const char *format, ...)
+    ne_attribute((format (printf, 2, 3)));
+
+/* Retrieve the error string for the session */
+const char *ne_get_error(ne_session *sess);
+
+NE_END_DECLS
+
+#endif /* NE_SESSION_H */
diff --git a/net/mmt/neon/src/ne_socket.c b/net/mmt/neon/src/ne_socket.c
new file mode 100644
index 0000000..2dadac6
--- /dev/null
+++ b/net/mmt/neon/src/ne_socket.c
@@ -0,0 +1,1949 @@
+/* 
+   Socket handling routines
+   Copyright (C) 1998-2011, Joe Orton <joe@manyfish.co.uk>
+   Copyright (C) 2004 Aleix Conchillo Flaque <aleix@member.fsf.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+/*
+  portions were originally under GPL in Mutt, http://www.mutt.org/
+  Relicensed under LGPL for neon, http://www.webdav.org/neon/
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+#ifdef HAVE_SYS_UIO_h
+#include <sys/uio.h> /* writev(2) */
+#endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#include <sys/stat.h>
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#ifdef NE_USE_POLL
+#include <sys/poll.h>
+#elif defined(HAVE_SYS_SELECT_H)
+#include <sys/select.h>
+#endif
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_TCP_H
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#ifdef HAVE_NETDB_H
+#include <netdb.h>
+#endif
+
+#ifdef WIN32
+#include <winsock2.h>
+#include <stddef.h>
+#ifdef USE_GETADDRINFO
+#include <ws2tcpip.h>
+#include <wspiapi.h>
+#endif
+#endif
+
+#if defined(HAVE_OPENSSL) && defined(HAVE_LIMITS_H)
+#include <limits.h> /* for INT_MAX */
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif 
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_ERRNO_H
+#include <errno.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+
+#ifdef HAVE_SOCKS_H
+#include <socks.h>
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/pkcs12.h> /* for PKCS12_PBE_add */
+#include <openssl/rand.h>
+#include <openssl/opensslv.h> /* for OPENSSL_VERSION_NUMBER */
+#endif
+
+#ifdef HAVE_GNUTLS
+#include <gnutls/gnutls.h>
+#endif
+
+#define NE_INET_ADDR_DEFINED
+/* A slightly ugly hack: change the ne_inet_addr definition to be the
+ * real address type used.  The API only exposes ne_inet_addr as a
+ * pointer to an opaque object, so this should be well-defined
+ * behaviour.  It avoids the hassle of a real wrapper ne_inet_addr
+ * structure, or losing type-safety by using void *. */
+#ifdef USE_GETADDRINFO
+typedef struct addrinfo ne_inet_addr;
+#else
+typedef struct in_addr ne_inet_addr;
+#endif
+
+#include "ne_privssl.h" /* MUST come after ne_inet_addr is defined */
+
+/* To avoid doing AAAA queries unless absolutely necessary, either use
+ * AI_ADDRCONFIG where available, or a run-time check for working IPv6
+ * support; the latter is only known to work on Linux. */
+#if defined(USE_GETADDRINFO) && !defined(USE_GAI_ADDRCONFIG) && defined(__linux__)
+#define USE_CHECK_IPV6
+#endif
+
+/* "Be Conservative In What You Build". */
+#if defined(HAVE_FCNTL) && defined(O_NONBLOCK) && defined(F_SETFL) \
+    && defined(HAVE_GETSOCKOPT) && defined(SO_ERROR) \
+    && defined(HAVE_SOCKLEN_T) && defined(SOL_SOCKET) \
+    && defined(EINPROGRESS)
+#define USE_NONBLOCKING_CONNECT
+#endif
+
+#include "ne_internal.h"
+#include "ne_utils.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_alloc.h"
+#include "ne_sspi.h"
+
+#if defined(__BEOS__) && !defined(BONE_VERSION)
+/* pre-BONE */
+#define ne_close(s) closesocket(s)
+#define ne_errno errno
+#elif defined(WIN32)
+#define ne_close(s) closesocket(s)
+#define ne_errno WSAGetLastError()
+#else /* really Unix! */
+#define ne_close(s) close(s)
+#define ne_errno errno
+#endif
+
+#ifdef WIN32
+#define NE_ISRESET(e) ((e) == WSAECONNABORTED || (e) == WSAETIMEDOUT || \
+                       (e) == WSAECONNRESET || (e) == WSAENETRESET)
+#define NE_ISCLOSED(e) ((e) == WSAESHUTDOWN || (e) == WSAENOTCONN)
+#define NE_ISINTR(e) (0)
+#define NE_ISINPROGRESS(e) ((e) == WSAEWOULDBLOCK) /* says MSDN */
+#else /* Unix */
+/* Also treat ECONNABORTED and ENOTCONN as "connection reset" errors;
+ * both can be returned by Winsock-based sockets layers e.g. CygWin */
+#ifndef ECONNABORTED
+#define ECONNABORTED ECONNRESET
+#endif
+#ifndef ENOTCONN
+#define ENOTCONN ECONNRESET
+#endif
+#define NE_ISRESET(e) ((e) == ECONNRESET || (e) == ECONNABORTED || (e) == ENOTCONN)
+#define NE_ISCLOSED(e) ((e) == EPIPE)
+#define NE_ISINTR(e) ((e) == EINTR)
+#define NE_ISINPROGRESS(e) ((e) == EINPROGRESS)
+#endif
+
+/* Socket read timeout */
+#define SOCKET_READ_TIMEOUT 120
+
+/* Critical I/O functions on a socket: useful abstraction for easily
+ * handling SSL I/O alongside raw socket I/O. */
+struct iofns {
+    /* Read up to 'len' bytes into 'buf' from socket.  Return <0 on
+     * error or EOF, or >0; number of bytes read. */
+    ssize_t (*sread)(ne_socket *s, char *buf, size_t len);
+    /* Write up to 'len' bytes from 'buf' to socket.  Return number of
+     * bytes written on success, or <0 on error. */
+    ssize_t (*swrite)(ne_socket *s, const char *buf, size_t len);
+    /* Wait up to 'n' seconds for socket to become readable.  Returns
+     * 0 when readable, otherwise NE_SOCK_TIMEOUT or NE_SOCK_ERROR. */
+    int (*readable)(ne_socket *s, int n);
+    /* Write up to 'count' blocks described by 'vector' to socket.
+     * Return number of bytes written on success, or <0 on error. */
+    ssize_t (*swritev)(ne_socket *s, const struct ne_iovec *vector, 
+                       int count);
+};
+
+static const ne_inet_addr dummy_laddr;
+
+struct ne_socket_s {
+    int fd;
+    unsigned int lport;
+    const ne_inet_addr *laddr;
+
+    void *progress_ud;
+    int rdtimeout, cotimeout; /* timeouts */
+    const struct iofns *ops;
+#ifdef NE_HAVE_SSL
+    ne_ssl_socket ssl;
+#endif
+    /* The read buffer: ->buffer stores byte which have been read; as
+     * these are consumed and passed back to the caller, bufpos
+     * advances through ->buffer.  ->bufavail gives the number of
+     * bytes which remain to be consumed in ->buffer (from ->bufpos),
+     * and is hence always <= RDBUFSIZ. */
+    char *bufpos;
+    size_t bufavail;
+#define RDBUFSIZ 4096
+    char buffer[RDBUFSIZ];
+    /* Error string. */
+    char error[192];
+};
+
+/* ne_sock_addr represents an Internet address. */
+struct ne_sock_addr_s {
+#ifdef USE_GETADDRINFO
+    struct addrinfo *result, *cursor;
+#else
+    struct in_addr *addrs;
+    size_t cursor, count;
+    char *name;
+#endif
+    int errnum;
+};
+
+/* set_error: set socket error string to 'str'. */
+#define set_error(s, str) ne_strnzcpy((s)->error, (str), sizeof (s)->error)
+
+/* set_strerror: set socket error to system error string for 'errnum' */
+#ifdef WIN32
+/* Print system error message to given buffer. */
+static void print_error(int errnum, char *buffer, size_t buflen)
+{
+    if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
+                       | FORMAT_MESSAGE_IGNORE_INSERTS,
+                       NULL, (DWORD) errnum, 0, 
+                       buffer, buflen, NULL) == 0)
+        ne_snprintf(buffer, buflen, "Socket error %d", errnum);
+}
+#define set_strerror(s, e) print_error((e), (s)->error, sizeof (s)->error)
+#else /* not WIN32 */
+#define set_strerror(s, e) ne_strerror((e), (s)->error, sizeof (s)->error)
+#endif
+
+#ifdef HAVE_OPENSSL
+/* Seed the SSL PRNG, if necessary; returns non-zero on failure. */
+static int seed_ssl_prng(void)
+{
+    /* Check whether the PRNG has already been seeded. */
+    if (RAND_status() == 1)
+	return 0;
+
+#if defined(EGD_PATH)
+    NE_DEBUG(NE_DBG_SOCKET, "Seeding PRNG from " EGD_PATH "...\n");
+    if (RAND_egd(EGD_PATH) != -1)
+	return 0;
+#elif defined(ENABLE_EGD)
+    {
+	static const char *paths[] = { "/var/run/egd-pool", "/dev/egd-pool",
+				       "/etc/egd-pool", "/etc/entropy" };
+	size_t n;
+	for (n = 0; n < sizeof(paths) / sizeof(char *); n++) {
+	    NE_DEBUG(NE_DBG_SOCKET, "Seeding PRNG from %s...\n", paths[n]);
+	    if (RAND_egd(paths[n]) != -1)
+		return 0;
+	}
+    }
+#endif /* EGD_PATH */
+
+    NE_DEBUG(NE_DBG_SOCKET, "No entropy source found; could not seed PRNG.\n");
+    return -1;
+}
+#endif /* HAVE_OPENSSL */
+
+#ifdef USE_CHECK_IPV6
+static int ipv6_disabled = 0;
+
+/* On Linux kernels, IPv6 is typically built as a loadable module, and
+ * socket(AF_INET6, ...) will fail if this module is not loaded, so
+ * the slow AAAA lookups can be avoided for this common case. */
+static void init_ipv6(void)
+{
+    int fd = socket(AF_INET6, SOCK_STREAM, 0);
+    
+    if (fd < 0)
+        ipv6_disabled = 1;
+    else
+        close(fd);
+}
+#elif defined(AF_INET6)
+#define ipv6_disabled (0)
+#else
+#define ipv6_disabled (1)
+#endif
+
+/* If init_state is N where > 0, ne_sock_init has been called N times;
+ * if == 0, library is not initialized; if < 0, library initialization
+ * has failed. */
+static int init_state = 0;
+
+int ne_sock_init(void)
+{
+#ifdef WIN32
+    WORD wVersionRequested;
+    WSADATA wsaData;
+    int err;
+#endif
+
+    if (init_state > 0) {
+        init_state++;
+	return 0;
+    } 
+    else if (init_state < 0) {
+	return -1;
+    }
+
+#ifdef WIN32    
+    wVersionRequested = MAKEWORD(2, 2);
+    
+    err = WSAStartup(wVersionRequested, &wsaData);
+    if (err != 0) {
+	return init_state = -1;
+    }
+#ifdef HAVE_SSPI
+    if (ne_sspi_init() < 0) {
+        return init_state = -1;
+    }
+#endif
+#endif
+
+#ifdef NE_HAVE_SOCKS
+    SOCKSinit("neon");
+#endif
+
+#if defined(HAVE_SIGNAL) && defined(SIGPIPE)
+    (void) signal(SIGPIPE, SIG_IGN);
+#endif
+
+#ifdef USE_CHECK_IPV6
+    init_ipv6();
+#endif
+
+#ifdef NE_HAVE_SSL
+    if (ne__ssl_init()) {
+        return init_state = -1;
+    }
+#endif
+
+    init_state = 1;
+    return 0;
+}
+
+void ne_sock_exit(void)
+{
+    if (init_state > 0 && --init_state == 0) {
+#ifdef WIN32
+        WSACleanup();
+#endif
+#ifdef NE_HAVE_SSL
+        ne__ssl_exit();
+#endif
+        
+#ifdef HAVE_SSPI
+        ne_sspi_deinit();
+#endif
+    }
+}
+
+/* Await readability (rdwr = 0) or writability (rdwr != 0) for socket
+ * fd for secs seconds.  Returns <0 on error, zero on timeout, >0 if
+ * data is available. */
+static int raw_poll(int fdno, int rdwr, int secs)
+{
+    int ret;
+#ifdef NE_USE_POLL
+    struct pollfd fds;
+    int timeout = secs > 0 ? secs * 1000 : -1;
+
+    fds.fd = fdno;
+    fds.events = rdwr == 0 ? POLLIN : POLLOUT;
+    fds.revents = 0;
+
+    do {
+        ret = poll(&fds, 1, timeout);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+#else
+    fd_set rdfds, wrfds, exfds;
+    struct timeval timeout, *tvp = (secs >= 0 ? &timeout : NULL);
+
+    /* Init the fd set */
+    FD_ZERO(&rdfds);
+    FD_ZERO(&wrfds);
+    FD_ZERO(&exfds);
+
+    /* Note that (amazingly) the FD_SET macro does not expand
+     * correctly on Netware if not inside a compound statement
+     * block. */
+    if (rdwr == 0) {
+        FD_SET(fdno, &rdfds);
+    } else {
+        FD_SET(fdno, &wrfds);
+    }
+    FD_SET(fdno, &exfds);
+
+    if (tvp) {
+        tvp->tv_sec = secs;
+        tvp->tv_usec = 0;
+    }
+    do {
+	ret = select(fdno + 1, &rdfds, &wrfds, &exfds, tvp);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+#endif
+    return ret;
+}
+
+int ne_sock_block(ne_socket *sock, int n)
+{
+    if (sock->bufavail)
+	return 0;
+    return sock->ops->readable(sock, n);
+}
+
+/* Cast address object AD to type 'sockaddr_TY' */ 
+#define SACAST(ty, ad) ((struct sockaddr_##ty *)(ad))
+
+ssize_t ne_sock_read(ne_socket *sock, char *buffer, size_t buflen)
+{
+    ssize_t bytes;
+
+#if 0
+    NE_DEBUG(NE_DBG_SOCKET, "buf: at %d, %d avail [%s]\n", 
+	     sock->bufpos - sock->buffer, sock->bufavail, sock->bufpos);
+#endif
+
+    if (sock->bufavail > 0) {
+	/* Deliver buffered data. */
+	if (buflen > sock->bufavail)
+	    buflen = sock->bufavail;
+	memcpy(buffer, sock->bufpos, buflen);
+	sock->bufpos += buflen;
+	sock->bufavail -= buflen;
+	return buflen;
+    } else if (buflen >= sizeof sock->buffer) {
+	/* No need for read buffer. */
+	return sock->ops->sread(sock, buffer, buflen);
+    } else {
+	/* Fill read buffer. */
+	bytes = sock->ops->sread(sock, sock->buffer, sizeof sock->buffer);
+	if (bytes <= 0)
+	    return bytes;
+
+	if (buflen > (size_t)bytes)
+	    buflen = bytes;
+	memcpy(buffer, sock->buffer, buflen);
+	sock->bufpos = sock->buffer + buflen;
+	sock->bufavail = bytes - buflen;
+	return buflen; 
+    }
+}
+
+ssize_t ne_sock_peek(ne_socket *sock, char *buffer, size_t buflen)
+{
+    ssize_t bytes;
+    
+    if (sock->bufavail) {
+	/* just return buffered data. */
+	bytes = sock->bufavail;
+    } else {
+	/* fill the buffer. */
+	bytes = sock->ops->sread(sock, sock->buffer, sizeof sock->buffer);
+	if (bytes <= 0)
+	    return bytes;
+
+	sock->bufpos = sock->buffer;
+	sock->bufavail = bytes;
+    }
+
+    if (buflen > (size_t)bytes)
+	buflen = bytes;
+
+    memcpy(buffer, sock->bufpos, buflen);
+
+    return buflen;
+}
+
+/* Await data on raw fd in socket. */
+static int readable_raw(ne_socket *sock, int secs)
+{
+    int ret = raw_poll(sock->fd, 0, secs);
+
+    if (ret < 0) {
+	set_strerror(sock, ne_errno);
+	return NE_SOCK_ERROR;
+    }
+    return (ret == 0) ? NE_SOCK_TIMEOUT : 0;
+}
+
+static ssize_t read_raw(ne_socket *sock, char *buffer, size_t len)
+{
+    ssize_t ret;
+    
+    ret = readable_raw(sock, sock->rdtimeout);
+    if (ret) return ret;
+
+    do {
+	ret = recv(sock->fd, buffer, len, 0);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+
+    if (ret == 0) {
+	set_error(sock, _("Connection closed"));
+	ret = NE_SOCK_CLOSED;
+    } else if (ret < 0) {
+	int errnum = ne_errno;
+	ret = NE_ISRESET(errnum) ? NE_SOCK_RESET : NE_SOCK_ERROR;
+	set_strerror(sock, errnum);
+    }
+
+    return ret;
+}
+
+#define MAP_ERR(e) (NE_ISCLOSED(e) ? NE_SOCK_CLOSED : \
+                    (NE_ISRESET(e) ? NE_SOCK_RESET : NE_SOCK_ERROR))
+
+static ssize_t write_raw(ne_socket *sock, const char *data, size_t length) 
+{
+    ssize_t ret;
+    
+#ifdef __QNX__
+    /* Test failures seen on QNX over loopback, if passing large
+     * buffer lengths to send().  */
+    if (length > 8192) length = 8192;
+#endif
+
+    do {
+	ret = send(sock->fd, data, length, 0);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+
+    if (ret < 0) {
+	int errnum = ne_errno;
+	set_strerror(sock, errnum);
+	return MAP_ERR(errnum);
+    }
+    return ret;
+}
+
+static ssize_t writev_raw(ne_socket *sock, const struct ne_iovec *vector, int count) 
+{
+    ssize_t ret;
+#ifdef WIN32
+    LPWSABUF wasvector = (LPWSABUF)ne_malloc(count * sizeof(WSABUF));
+    DWORD total;
+    int i;
+
+    for (i = 0; i < count; i++){
+        wasvector[i].buf = vector[i].base;
+        wasvector[i].len = vector[i].len;
+    }
+        
+    ret = WSASend(sock->fd, wasvector, count, &total, 0, NULL, NULL);
+    if (ret == 0)
+        ret = total;
+    
+    ne_free(wasvector);
+#else
+    const struct iovec *vec = (const struct iovec *) vector;
+
+    do {
+	ret = writev(sock->fd, vec, count);
+    } while (ret == -1 && NE_ISINTR(ne_errno));
+#endif
+
+    if (ret < 0) {
+	int errnum = ne_errno;
+	set_strerror(sock, errnum);
+	return MAP_ERR(errnum);
+    }
+    
+    return ret;
+}
+
+#ifdef NE_HAVE_SSL
+static ssize_t writev_dummy(ne_socket *sock, const struct ne_iovec *vector, int count) 
+{
+    return sock->ops->swrite(sock, vector[0].base, vector[0].len);
+}
+#endif
+
+static const struct iofns iofns_raw = { read_raw, write_raw, readable_raw, writev_raw };
+
+#ifdef HAVE_OPENSSL
+/* OpenSSL I/O function implementations. */
+static int readable_ossl(ne_socket *sock, int secs)
+{
+    if (SSL_pending(sock->ssl))
+	return 0;
+    return readable_raw(sock, secs);
+}
+
+/* SSL error handling, according to SSL_get_error(3). */
+static int error_ossl(ne_socket *sock, int sret)
+{
+    int errnum = SSL_get_error(sock->ssl, sret);
+    unsigned long err;
+
+    if (errnum == SSL_ERROR_ZERO_RETURN) {
+	set_error(sock, _("Connection closed"));
+        return NE_SOCK_CLOSED;
+    }
+    
+    /* for all other errors, look at the OpenSSL error stack */
+    err = ERR_get_error();
+    if (err == 0) {
+        /* Empty error stack, presume this is a system call error: */
+        if (sret == 0) {
+            /* EOF without close_notify, possible truncation */
+            set_error(sock, _("Secure connection truncated"));
+            return NE_SOCK_TRUNC;
+        } else {
+            /* Other socket error. */
+            errnum = ne_errno;
+            set_strerror(sock, errnum);
+            return MAP_ERR(errnum);
+        }
+    }
+
+    if (ERR_reason_error_string(err)) {
+        ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL error: %s"), ERR_reason_error_string(err));
+    } else {
+	ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL error code %d/%d/%lu"), sret, errnum, err);
+    }
+    
+    /* make sure the error stack is now empty. */
+    ERR_clear_error();
+    return NE_SOCK_ERROR;
+}
+
+/* Work around OpenSSL's use of 'int' rather than 'size_t', to prevent
+ * accidentally passing a negative number, etc. */
+#define CAST2INT(n) (((n) > INT_MAX) ? INT_MAX : (n))
+
+static ssize_t read_ossl(ne_socket *sock, char *buffer, size_t len)
+{
+    int ret;
+
+    ret = readable_ossl(sock, sock->rdtimeout);
+    if (ret) return ret;
+    
+    ret = SSL_read(sock->ssl, buffer, CAST2INT(len));
+    if (ret <= 0)
+	ret = error_ossl(sock, ret);
+
+    return ret;
+}
+
+static ssize_t write_ossl(ne_socket *sock, const char *data, size_t len)
+{
+    int ret, ilen = CAST2INT(len);
+    ret = SSL_write(sock->ssl, data, ilen);
+    /* ssl.h says SSL_MODE_ENABLE_PARTIAL_WRITE must be enabled to
+     * have SSL_write return < length...  so, SSL_write should never
+     * return < length. */
+    if (ret != ilen)
+	return error_ossl(sock, ret);
+    return ret;
+}
+
+static const struct iofns iofns_ssl = {
+    read_ossl,
+    write_ossl,
+    readable_ossl,
+    writev_dummy
+};
+
+#elif defined(HAVE_GNUTLS)
+
+/* Return zero if an alert value can be ignored. */
+static int check_alert(ne_socket *sock, ssize_t ret)
+{
+    const char *alert;
+
+    if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED) {
+        alert = gnutls_alert_get_name(gnutls_alert_get(sock->ssl));
+        NE_DEBUG(NE_DBG_SOCKET, "TLS warning alert: %s\n", alert);
+        return 0;
+    } else if (ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {
+        alert = gnutls_alert_get_name(gnutls_alert_get(sock->ssl));
+        NE_DEBUG(NE_DBG_SOCKET, "TLS fatal alert: %s\n", alert);
+        return -1;
+    }
+    return ret;
+}
+
+static int readable_gnutls(ne_socket *sock, int secs)
+{
+    if (gnutls_record_check_pending(sock->ssl)) {
+        return 0;
+    }
+    return readable_raw(sock, secs);
+}
+
+static ssize_t error_gnutls(ne_socket *sock, ssize_t sret)
+{
+    ssize_t ret;
+
+    switch (sret) {
+    case 0:
+	ret = NE_SOCK_CLOSED;
+	set_error(sock, _("Connection closed"));
+	break;
+    case GNUTLS_E_FATAL_ALERT_RECEIVED:
+        ret = NE_SOCK_ERROR;
+        ne_snprintf(sock->error, sizeof sock->error, 
+                    _("SSL alert received: %s"),
+                    gnutls_alert_get_name(gnutls_alert_get(sock->ssl)));
+        break;
+#if GNUTLS_VERSION_MAJOR > 2 || (GNUTLS_VERSION_MAJOR == 2 && GNUTLS_VERSION_MINOR >= 99)
+    case GNUTLS_E_PREMATURE_TERMINATION:
+#else
+    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:
+#endif
+        ret = NE_SOCK_TRUNC;
+        set_error(sock, _("Secure connection truncated"));
+        break;
+    case GNUTLS_E_PUSH_ERROR:
+        ret = NE_SOCK_RESET;
+        set_error(sock, ("SSL socket write failed"));
+        break;
+    case GNUTLS_E_PULL_ERROR:
+        ret = NE_SOCK_RESET;
+        set_error(sock, _("SSL socket read failed"));
+        break;
+    default:
+        ret = NE_SOCK_ERROR;
+        ne_snprintf(sock->error, sizeof sock->error, _("SSL error: %s"),
+                    gnutls_strerror(sret));
+    }
+    return ret;
+}
+
+#define RETRY_GNUTLS(sock, ret) ((ret < 0) \
+    && (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN \
+        || check_alert(sock, ret) == 0))
+
+static ssize_t read_gnutls(ne_socket *sock, char *buffer, size_t len)
+{
+    ssize_t ret;
+    unsigned reneg = 1; /* number of allowed rehandshakes */
+
+    ret = readable_gnutls(sock, sock->rdtimeout);
+    if (ret) return ret;
+    
+    do {
+        do {
+            ret = gnutls_record_recv(sock->ssl, buffer, len);
+        } while (RETRY_GNUTLS(sock, ret));
+        
+    } while (ret == GNUTLS_E_REHANDSHAKE && reneg--
+             && (ret = gnutls_handshake(sock->ssl)) == GNUTLS_E_SUCCESS);
+
+    if (ret <= 0)
+	ret = error_gnutls(sock, ret);
+
+    return ret;
+}
+
+static ssize_t write_gnutls(ne_socket *sock, const char *data, size_t len)
+{
+    ssize_t ret;
+
+    do {
+        ret = gnutls_record_send(sock->ssl, data, len);
+    } while (RETRY_GNUTLS(sock, ret));
+
+    if (ret < 0)
+	return error_gnutls(sock, ret);
+
+    return ret;
+}
+
+static const struct iofns iofns_ssl = {
+    read_gnutls,
+    write_gnutls,
+    readable_gnutls,
+    writev_dummy
+};
+
+#endif
+
+int ne_sock_fullwrite(ne_socket *sock, const char *data, size_t len)
+{
+    ssize_t ret;
+
+    do {
+        ret = sock->ops->swrite(sock, data, len);
+        if (ret > 0) {
+            data += ret;
+            len -= ret;
+        }
+    } while (ret > 0 && len > 0);
+
+    return ret < 0 ? ret : 0;
+}
+
+int ne_sock_fullwritev(ne_socket *sock, const struct ne_iovec *vector, int count)
+{
+    ssize_t ret;
+
+    do {
+        ret = sock->ops->swritev(sock, vector, count);
+        if (ret > 0) {
+            while (count && (size_t)ret >= vector[0].len) {
+                ret -= vector[0].len;
+                count--;
+                vector++;
+            }
+            
+            if (ret && count) {
+                /* Partial buffer sent; send the rest. */
+                ret = ne_sock_fullwrite(sock, (char *)vector[0].base + ret,
+                                        vector[0].len - ret);
+                count--;
+                vector++;
+            }
+        }
+    } while (count && ret >= 0);
+
+    return ret < 0 ? ret : 0;
+}
+
+ssize_t ne_sock_readline(ne_socket *sock, char *buf, size_t buflen)
+{
+    char *lf;
+    size_t len;
+    
+    if ((lf = memchr(sock->bufpos, '\n', sock->bufavail)) == NULL
+	&& sock->bufavail < RDBUFSIZ) {
+	/* The buffered data does not contain a complete line: move it
+	 * to the beginning of the buffer. */
+	if (sock->bufavail)
+	    memmove(sock->buffer, sock->bufpos, sock->bufavail);
+	sock->bufpos = sock->buffer;
+	
+	/* Loop filling the buffer whilst no newline is found in the data
+	 * buffered so far, and there is still buffer space available */ 
+	do {
+	    /* Read more data onto end of buffer. */
+	    ssize_t ret = sock->ops->sread(sock, sock->buffer + sock->bufavail,
+                                           RDBUFSIZ - sock->bufavail);
+	    if (ret < 0) return ret;
+	    sock->bufavail += ret;
+	} while ((lf = memchr(sock->buffer, '\n', sock->bufavail)) == NULL
+		 && sock->bufavail < RDBUFSIZ);
+    }
+
+    if (lf)
+	len = lf - sock->bufpos + 1;
+    else
+	len = buflen; /* fall into "line too long" error... */
+
+    if ((len + 1) > buflen) {
+	set_error(sock, _("Line too long"));
+	return NE_SOCK_ERROR;
+    }
+
+    memcpy(buf, sock->bufpos, len);
+    buf[len] = '\0';
+    /* consume the line from buffer: */
+    sock->bufavail -= len;
+    sock->bufpos += len;
+    return len;
+}
+
+ssize_t ne_sock_fullread(ne_socket *sock, char *buffer, size_t buflen) 
+{
+    ssize_t len;
+
+    while (buflen > 0) {
+	len = ne_sock_read(sock, buffer, buflen);
+	if (len < 0) return len;
+	buflen -= len;
+	buffer += len;
+    }
+
+    return 0;
+}
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((in_addr_t) -1)
+#endif
+
+#if !defined(USE_GETADDRINFO) && !defined(WIN32) && !HAVE_DECL_H_ERRNO
+/* Ancient versions of netdb.h don't export h_errno. */
+extern int h_errno;
+#endif
+
+/* This implemementation does not attempt to support IPv6 using
+ * gethostbyname2 et al.  */
+ne_sock_addr *ne_addr_resolve(const char *hostname, int flags)
+{
+    ne_sock_addr *addr = ne_calloc(sizeof *addr);
+#ifdef USE_GETADDRINFO
+    struct addrinfo hints = {0};
+    char *pnt;
+
+    hints.ai_socktype = SOCK_STREAM;
+
+    if (flags & NE_ADDR_CANON) {
+        hints.ai_flags = AI_CANONNAME;
+    }
+
+#ifdef AF_INET6
+    if (hostname[0] == '[' && ((pnt = strchr(hostname, ']')) != NULL)) {
+	char *hn = ne_strdup(hostname + 1);
+	hn[pnt - hostname - 1] = '\0';
+#ifdef AI_NUMERICHOST /* added in the RFC2553 API */
+	hints.ai_flags |= AI_NUMERICHOST;
+#endif
+        hints.ai_family = AF_INET6;
+	addr->errnum = getaddrinfo(hn, NULL, &hints, &addr->result);
+	ne_free(hn);
+    } else 
+#endif /* AF_INET6 */
+    {
+#ifdef USE_GAI_ADDRCONFIG /* added in the RFC3493 API */
+        hints.ai_flags |= AI_ADDRCONFIG;
+        hints.ai_family = AF_UNSPEC;
+        addr->errnum = getaddrinfo(hostname, NULL, &hints, &addr->result);
+#else
+        hints.ai_family = ipv6_disabled ? AF_INET : AF_UNSPEC;
+	addr->errnum = getaddrinfo(hostname, NULL, &hints, &addr->result);
+#endif
+    }
+#else /* Use gethostbyname() */
+    in_addr_t laddr;
+    struct hostent *hp;
+    
+    laddr = inet_addr(hostname);
+    if (laddr == INADDR_NONE) {
+	hp = gethostbyname(hostname);
+	if (hp == NULL) {
+#ifdef WIN32
+	    addr->errnum = WSAGetLastError();
+#else
+            addr->errnum = h_errno;
+#endif
+	} else if (hp->h_length != sizeof(struct in_addr)) {
+	    /* fail gracefully if somebody set RES_USE_INET6 */
+	    addr->errnum = NO_RECOVERY;
+	} else {
+	    size_t n;
+	    /* count addresses */
+	    for (n = 0; hp->h_addr_list[n] != NULL; n++)
+		/* noop */;
+
+	    addr->count = n;
+	    addr->addrs = ne_malloc(n * sizeof *addr->addrs);
+
+	    for (n = 0; n < addr->count; n++)
+		memcpy(&addr->addrs[n], hp->h_addr_list[n], hp->h_length);
+            
+            if (hp->h_name && hp->h_name[0]) 
+                addr->name = ne_strdup(hp->h_name);
+	}
+    } else {
+	addr->addrs = ne_malloc(sizeof *addr->addrs);
+	addr->count = 1;
+	memcpy(addr->addrs, &laddr, sizeof *addr->addrs);
+    }
+#endif
+    return addr;
+}
+
+int ne_addr_result(const ne_sock_addr *addr)
+{
+    return addr->errnum;
+}
+
+const char *ne_addr_canonical(const ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    return addr->result ? addr->result->ai_canonname : NULL;
+#else
+    return addr->name;
+#endif
+}
+
+const ne_inet_addr *ne_addr_first(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    addr->cursor = addr->result->ai_next;
+    return addr->result;
+#else
+    addr->cursor = 0;
+    return &addr->addrs[0];
+#endif
+}
+
+const ne_inet_addr *ne_addr_next(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    struct addrinfo *ret = addr->cursor;
+    if (addr->cursor) addr->cursor = addr->cursor->ai_next;
+#else
+    struct in_addr *ret;
+    if (++addr->cursor < addr->count)
+	ret = &addr->addrs[addr->cursor];
+    else
+	ret = NULL;
+#endif
+    return ret;
+}
+
+char *ne_addr_error(const ne_sock_addr *addr, char *buf, size_t bufsiz)
+{
+#ifdef WIN32
+    print_error(addr->errnum, buf, bufsiz);
+#else
+    const char *err;
+#ifdef USE_GETADDRINFO
+    /* override horrible generic "Name or service not known" error. */
+    if (addr->errnum == EAI_NONAME)
+	err = _("Host not found");
+    else
+	err = gai_strerror(addr->errnum);
+#elif defined(HAVE_HSTRERROR)
+    err = hstrerror(addr->errnum);
+#else
+    err = _("Host not found");
+#endif
+    ne_strnzcpy(buf, err, bufsiz);
+#endif /* WIN32 */
+    return buf;
+}
+
+char *ne_iaddr_print(const ne_inet_addr *ia, char *buf, size_t bufsiz)
+{
+#if defined(USE_GETADDRINFO) && defined(HAVE_INET_NTOP)
+    const char *ret;
+#ifdef AF_INET6
+    if (ia->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in6 = SACAST(in6, ia->ai_addr);
+	ret = inet_ntop(AF_INET6, &in6->sin6_addr, buf, bufsiz);
+    } else
+#endif
+    if (ia->ai_family == AF_INET) {
+	struct sockaddr_in *in = SACAST(in, ia->ai_addr);
+	ret = inet_ntop(AF_INET, &in->sin_addr, buf, bufsiz);
+    } else
+	ret = NULL;
+    if (ret == NULL)
+	ne_strnzcpy(buf, "[IP address]", bufsiz);
+#elif defined(USE_GETADDRINFO) && defined(NI_NUMERICHOST)
+    /* use getnameinfo instead for Win32, which lacks inet_ntop: */
+    if (getnameinfo(ia->ai_addr, ia->ai_addrlen, buf, bufsiz, NULL, 0,
+                    NI_NUMERICHOST))
+        ne_strnzcpy(buf, "[IP address]", bufsiz);
+#else /* USE_GETADDRINFO */
+    ne_strnzcpy(buf, inet_ntoa(*ia), bufsiz);
+#endif
+    return buf;
+}
+
+unsigned char *ne_iaddr_raw(const ne_inet_addr *ia, unsigned char *buf)
+{
+#ifdef USE_GETADDRINFO
+#ifdef AF_INET6
+    if (ia->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in6 = SACAST(in6, ia->ai_addr);
+        return memcpy(buf, in6->sin6_addr.s6_addr, sizeof in6->sin6_addr.s6_addr);
+    } else
+#endif /* AF_INET6 */
+    {
+	struct sockaddr_in *in = SACAST(in, ia->ai_addr);
+        return memcpy(buf, &in->sin_addr.s_addr, sizeof in->sin_addr.s_addr);
+    }
+#else /* !USE_GETADDRINFO */
+    return memcpy(buf, &ia->s_addr, sizeof ia->s_addr);
+#endif
+}
+
+ne_inet_addr *ne_iaddr_parse(const char *addr, ne_iaddr_type type)
+{
+#if defined(USE_GETADDRINFO) && defined(HAVE_INET_PTON)
+    char dst[sizeof(struct in6_addr)];
+    int af = type == ne_iaddr_ipv6 ? AF_INET6 : AF_INET;
+
+    if (inet_pton(af, addr, dst) != 1) {
+        return NULL;
+    }
+    
+    return ne_iaddr_make(type, (unsigned char *)dst);
+#elif defined(USE_GETADDRINFO) && !defined(HAVE_INET_PTON)
+    /* For Windows, which lacks inet_pton(). */
+    struct addrinfo *ai, *rv, hints;
+
+    memset(&hints, 0, sizeof hints);
+    hints.ai_socktype = SOCK_STREAM;
+    hints.ai_flags = AI_NUMERICHOST;
+    hints.ai_family = type == ne_iaddr_ipv6 ? AF_INET6 : AF_INET;
+    
+    if (getaddrinfo(addr, NULL, &hints, &ai)) {
+        return NULL;
+    }
+    
+    /* Copy the returned addrinfo, since it needs to be ne_free()-able
+     * later; must only call freeaddrinfo() on ai. */
+    rv = ne_calloc(sizeof *rv);
+    memcpy(rv, ai, sizeof *rv);
+    rv->ai_next = NULL;
+    rv->ai_canonname = NULL;
+    rv->ai_addr = ne_calloc(ai->ai_addrlen);
+    memcpy(rv->ai_addr, ai->ai_addr, ai->ai_addrlen);
+    freeaddrinfo(ai);
+    
+    return rv;    
+#else /* !USE_GETADDRINFO */
+    struct in_addr a;
+    
+    if (type == ne_iaddr_ipv6) {
+        return NULL;
+    }
+
+#ifdef WIN32
+    /* inet_addr() is broken because INADDR_NONE is a valid
+     * broadcast address, so only use it on Windows. */
+    a.s_addr = inet_addr(addr);
+    if (a.s_addr == INADDR_NONE) {
+        return NULL;
+    }
+#else /* !WIN32 */
+    if (inet_aton(addr, &a) == 0) {
+        return NULL;
+    }
+#endif
+    
+    return ne_iaddr_make(ne_iaddr_ipv4, (unsigned char *)&a.s_addr);
+#endif /* !USE_GETADDRINFO */
+}
+
+int ne_iaddr_reverse(const ne_inet_addr *ia, char *buf, size_t bufsiz)
+{
+#ifdef USE_GETADDRINFO
+    return getnameinfo(ia->ai_addr, ia->ai_addrlen, buf, bufsiz,
+                       NULL, 0, 0);
+#else
+    struct hostent *hp;
+    
+    /* Cast to const void *; some old libc headers apparently expect
+     * const char * here. */
+    hp = gethostbyaddr((const void *)ia, sizeof *ia, AF_INET);
+    if (hp && hp->h_name) {
+        ne_strnzcpy(buf, hp->h_name, bufsiz);
+        return 0;
+    }
+    return -1;
+#endif
+}
+
+void ne_addr_destroy(ne_sock_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    if (addr->result)
+	freeaddrinfo(addr->result);
+#else
+    if (addr->addrs)
+	ne_free(addr->addrs);
+    if (addr->name)
+        ne_free(addr->name);
+#endif
+    ne_free(addr);
+}
+
+/* Perform a connect() for given fd, handling EINTR retries.  Returns
+ * zero on success or -1 on failure, in which case, ne_errno is set
+ * appropriately. */
+static int raw_connect(int fd, const struct sockaddr *sa, size_t salen)
+{
+    int ret;
+
+    do {
+        ret = connect(fd, sa, salen);
+    } while (ret < 0 && NE_ISINTR(ne_errno));
+
+    return ret;
+}
+
+/* Perform a connect() for fd to address sa of length salen, with a
+ * timeout if supported on this platform.  Returns zero on success or
+ * NE_SOCK_* on failure, with sock->error set appropriately. */
+static int timed_connect(ne_socket *sock, int fd,
+                         const struct sockaddr *sa, size_t salen)
+{
+    int ret;
+
+#ifdef USE_NONBLOCKING_CONNECT
+    if (sock->cotimeout) {
+        int errnum, flags;
+
+        /* Get flags and then set O_NONBLOCK. */
+        flags = fcntl(fd, F_GETFL);
+        if (flags & O_NONBLOCK) {
+            /* This socket was created using SOCK_NONBLOCK... flip the
+             * bit for restoring flags later. */
+            flags &= ~O_NONBLOCK;
+        }
+        else if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
+            set_strerror(sock, errno);
+            return NE_SOCK_ERROR;
+        }
+        
+        ret = raw_connect(fd, sa, salen);
+        if (ret == -1) {
+            errnum = ne_errno;
+            if (NE_ISINPROGRESS(errnum)) {
+                ret = raw_poll(fd, 1, sock->cotimeout);
+                if (ret > 0) { /* poll got data */
+                    socklen_t len = sizeof(errnum);
+                    
+                    /* Check whether there is a pending error for the
+                     * socket.  Per Stevens UNPv115.4, Solaris will
+                     * return a pending error via errno by failing the
+                     * getsockopt() call. */
+
+                    errnum = 0;
+                    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &errnum, &len))
+                        errnum = errno;
+                    
+                    if (errnum == 0) {
+                        ret = 0;
+                    } else {
+                        set_strerror(sock, errnum);
+                        ret = NE_SOCK_ERROR;
+                    }
+                } else if (ret == 0) { /* poll timed out */
+                    set_error(sock, _("Connection timed out"));
+                    ret = NE_SOCK_TIMEOUT;
+                } else /* poll failed */ {
+                    set_strerror(sock, errno);
+                    ret = NE_SOCK_ERROR;
+                }
+            } else /* non-EINPROGRESS error from connect() */ { 
+                set_strerror(sock, errnum);
+                ret = NE_SOCK_ERROR;
+            }
+        }
+        
+        /* Reset to old flags; fail on error if no previous error. */
+        if (fcntl(fd, F_SETFL, flags) == -1 && !ret) {
+            set_strerror(sock, errno);
+            ret = NE_SOCK_ERROR;
+        }
+    } else 
+#endif /* USE_NONBLOCKING_CONNECT */
+    {
+        ret = raw_connect(fd, sa, salen);
+        
+        if (ret < 0) {
+            set_strerror(sock, ne_errno);
+            ret = NE_SOCK_ERROR;
+        }
+    }
+
+    return ret;
+}
+
+/* Connect socket to address 'addr' on given 'port'.  Returns zero on
+ * success or NE_SOCK_* on failure with sock->error set
+ * appropriately. */
+static int connect_socket(ne_socket *sock, int fd,
+                          const ne_inet_addr *addr, unsigned int port)
+{
+#ifdef USE_GETADDRINFO
+#ifdef AF_INET6
+    /* fill in the _family field for AIX 4.3, which forgets to do so. */
+    if (addr->ai_family == AF_INET6) {
+	struct sockaddr_in6 in6;
+	memcpy(&in6, addr->ai_addr, sizeof in6);
+	in6.sin6_port = port;
+        in6.sin6_family = AF_INET6;
+        return timed_connect(sock, fd, (struct sockaddr *)&in6, sizeof in6);
+    } else
+#endif
+    if (addr->ai_family == AF_INET) {
+	struct sockaddr_in in;
+	memcpy(&in, addr->ai_addr, sizeof in);
+	in.sin_port = port;
+        in.sin_family = AF_INET;
+        return timed_connect(sock, fd, (struct sockaddr *)&in, sizeof in);
+    } else {
+        set_strerror(sock, EINVAL);
+        return NE_SOCK_ERROR;
+    }
+#else
+    struct sockaddr_in sa = {0};
+    sa.sin_family = AF_INET;
+    sa.sin_port = port;
+    sa.sin_addr = *addr;
+    return timed_connect(sock, fd, (struct sockaddr *)&sa, sizeof sa);
+#endif
+}
+
+ne_socket *ne_sock_create(void)
+{
+    ne_socket *sock = ne_calloc(sizeof *sock);
+    sock->rdtimeout = SOCKET_READ_TIMEOUT;
+    sock->cotimeout = 0;
+    sock->bufpos = sock->buffer;
+    sock->ops = &iofns_raw;
+    sock->fd = -1;
+    return sock;
+}
+
+
+#ifdef USE_GETADDRINFO
+#define ia_family(a) ((a)->ai_family)
+#define ia_proto(a)  ((a)->ai_protocol)
+#else
+#define ia_family(a) AF_INET
+#define ia_proto(a)  0
+#endif
+
+void ne_sock_prebind(ne_socket *sock, const ne_inet_addr *addr,
+                     unsigned int port)
+{
+    sock->lport = port;
+    sock->laddr = addr ? addr : &dummy_laddr;    
+}
+
+/* Bind socket 'fd' to address/port 'addr' and 'port', for subsequent
+ * connect() to address of family 'peer_family'. */
+static int do_bind(int fd, int peer_family, 
+                   const ne_inet_addr *addr, unsigned int port)
+{
+#if defined(HAVE_SETSOCKOPT) && defined(SO_REUSEADDR) && defined(SOL_SOCKET)
+    {
+        int flag = 1;
+
+        (void) setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof flag);
+        /* An error here is not fatal, so ignore it. */
+    }
+#endif        
+    
+
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    /* Use a sockaddr_in6 if an AF_INET6 local address is specifed, or
+     * if no address is specified and the peer address is AF_INET6: */
+    if ((addr != &dummy_laddr && addr->ai_family == AF_INET6)
+        || (addr == &dummy_laddr && peer_family == AF_INET6)) {
+        struct sockaddr_in6 in6;
+        
+        if (addr == &dummy_laddr)
+            memset(&in6, 0, sizeof in6);
+        else
+            memcpy(&in6, addr->ai_addr, sizeof in6);
+        in6.sin6_port = htons(port);
+        /* fill in the _family field for AIX 4.3, which forgets to do so. */
+        in6.sin6_family = AF_INET6;
+
+        return bind(fd, (struct sockaddr *)&in6, sizeof in6);
+    } else
+#endif
+    {
+	struct sockaddr_in in;
+
+        if (addr == &dummy_laddr)
+            memset(&in, 0, sizeof in);
+        else {
+#ifdef USE_GETADDRINFO
+            memcpy(&in, addr->ai_addr, sizeof in);
+#else
+            in.sin_addr = *addr;
+#endif
+        }
+        in.sin_port = htons(port);
+        in.sin_family = AF_INET;
+
+        return bind(fd, (struct sockaddr *)&in, sizeof in);
+    }
+}
+
+#ifdef SOCK_CLOEXEC
+/* sock_cloexec is initialized to SOCK_CLOEXEC and cleared to zero if
+ * a socket() call ever fails with EINVAL; not strictly thread-safe
+ * but in practice it will not matter if two threads race accessing
+ * the variable. */
+static int sock_cloexec = SOCK_CLOEXEC;
+#define RETRY_ON_EINVAL
+#else
+#define sock_cloexec 0
+#endif
+
+int ne_sock_connect(ne_socket *sock,
+                    const ne_inet_addr *addr, unsigned int port)
+{
+    int fd, ret;
+    int type = SOCK_STREAM | sock_cloexec;
+
+#if defined(RETRY_ON_EINVAL) && defined(SOCK_NONBLOCK) \
+    && defined(USE_NONBLOCKING_CONNECT)
+    /* If the SOCK_NONBLOCK flag is defined, and the retry-on-EINVAL
+     * logic is enabled, and the socket has a configured timeout, then
+     * also use the SOCK_NONBLOCK flag to save enabling O_NONBLOCK
+     * later. */
+    if (sock->cotimeout && sock_cloexec) {
+        type |= SOCK_NONBLOCK;
+    }
+#endif
+
+    /* use SOCK_STREAM rather than ai_socktype: some getaddrinfo
+     * implementations do not set ai_socktype, e.g. RHL6.2. */
+    fd = socket(ia_family(addr), type, ia_proto(addr));
+#ifdef RETRY_ON_EINVAL
+    /* Handle forwards compat for new glibc on an older kernels; clear
+     * the sock_cloexec flag and retry the call: */
+    if (fd < 0 && sock_cloexec && errno == EINVAL) {
+        sock_cloexec = 0;
+        fd = socket(ia_family(addr), SOCK_STREAM, ia_proto(addr));
+    }
+#endif
+    if (fd < 0) {
+        set_strerror(sock, ne_errno);
+	return -1;
+    }
+    
+#if !defined(NE_USE_POLL) && !defined(WIN32)
+    if (fd > FD_SETSIZE) {
+        ne_close(fd);
+        set_error(sock, _("Socket descriptor number exceeds FD_SETSIZE"));
+        return NE_SOCK_ERROR;
+    }
+#endif
+   
+#if defined(HAVE_FCNTL) && defined(F_GETFD) && defined(F_SETFD) \
+  && defined(FD_CLOEXEC)
+    /* Set the FD_CLOEXEC bit for the new fd, if the socket was not
+     * created with the CLOEXEC bit already set. */
+    if (!sock_cloexec && (ret = fcntl(fd, F_GETFD)) >= 0) {
+        fcntl(fd, F_SETFD, ret | FD_CLOEXEC);
+        /* ignore failure; not a critical error. */
+    }
+#endif
+
+    if (sock->laddr && (sock->laddr == &dummy_laddr || 
+                        ia_family(sock->laddr) == ia_family(addr))) {
+        ret = do_bind(fd, ia_family(addr), sock->laddr, sock->lport);
+        if (ret < 0) {
+            int errnum = ne_errno;
+            ne_close(fd);
+            set_strerror(sock, errnum);
+            return NE_SOCK_ERROR;
+        }
+    }
+
+#if defined(HAVE_SETSOCKOPT) && (defined(TCP_NODELAY) || defined(WIN32))
+    { /* Disable the Nagle algorithm. */
+        int flag = 1;
+        setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof flag);
+    }
+#endif
+    
+    ret = connect_socket(sock, fd, addr, htons(port));
+    if (ret == 0)
+        sock->fd = fd;
+    else
+        ne_close(fd);
+
+    return ret;
+}
+
+ne_inet_addr *ne_sock_peer(ne_socket *sock, unsigned int *port)
+{
+    union saun {
+        struct sockaddr sa;
+        struct sockaddr_in sin;
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+        struct sockaddr_in6 sin6;
+#endif
+    } saun;
+    socklen_t len = sizeof saun;
+    ne_inet_addr *ia;
+    struct sockaddr *sad = (struct sockaddr *)&saun;
+
+    if (getpeername(sock->fd, sad, &len) != 0) {
+        set_strerror(sock, errno);
+        return NULL;
+    }
+
+#if !defined(USE_GETADDRINFO) || !defined(AF_INET6)
+    if (sad->sa_family != AF_INET) {
+        set_error(sock, _("Socket family not supported"));
+        return NULL;
+    }
+#endif                  
+
+    ia = ne_calloc(sizeof *ia);
+#ifdef USE_GETADDRINFO
+    ia->ai_addr = ne_malloc(sizeof *ia);
+    ia->ai_addrlen = len;
+    memcpy(ia->ai_addr, sad, len);
+    ia->ai_family = saun.sa.sa_family;
+#else
+    memcpy(ia, &saun.sin.sin_addr.s_addr, sizeof *ia);
+#endif    
+
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    *port = ntohs(saun.sa.sa_family == AF_INET ? 
+                  saun.sin.sin_port : saun.sin6.sin6_port);
+#else
+    *port = ntohs(saun.sin.sin_port);
+#endif
+
+    return ia;
+}
+
+ne_inet_addr *ne_iaddr_make(ne_iaddr_type type, const unsigned char *raw)
+{
+    ne_inet_addr *ia;
+#if !defined(AF_INET6) || !defined(USE_GETADDRINFO)
+    /* fail if IPv6 address is given if IPv6 is not supported. */
+    if (type == ne_iaddr_ipv6)
+	return NULL;
+#endif
+    ia = ne_calloc(sizeof *ia);
+#ifdef USE_GETADDRINFO
+    /* ai_protocol and ai_socktype aren't used by connect_socket() so
+     * ignore them here. (for now) */
+    if (type == ne_iaddr_ipv4) {
+	struct sockaddr_in *in4 = ne_calloc(sizeof *in4);
+	ia->ai_family = AF_INET;
+	ia->ai_addr = (struct sockaddr *)in4;
+	ia->ai_addrlen = sizeof *in4;
+	in4->sin_family = AF_INET;
+	memcpy(&in4->sin_addr.s_addr, raw, sizeof in4->sin_addr.s_addr);
+    }
+#ifdef AF_INET6
+    else {
+	struct sockaddr_in6 *in6 = ne_calloc(sizeof *in6);
+	ia->ai_family = AF_INET6;
+	ia->ai_addr = (struct sockaddr *)in6;
+	ia->ai_addrlen = sizeof *in6;
+	in6->sin6_family = AF_INET6;
+	memcpy(&in6->sin6_addr, raw, sizeof in6->sin6_addr.s6_addr);
+    }
+#endif
+#else /* !USE_GETADDRINFO */
+    memcpy(&ia->s_addr, raw, sizeof ia->s_addr);
+#endif    
+    return ia;
+}
+
+ne_iaddr_type ne_iaddr_typeof(const ne_inet_addr *ia)
+{
+#if defined(USE_GETADDRINFO) && defined(AF_INET6)
+    return ia->ai_family == AF_INET6 ? ne_iaddr_ipv6 : ne_iaddr_ipv4;
+#else
+    return ne_iaddr_ipv4;
+#endif
+}
+
+int ne_iaddr_cmp(const ne_inet_addr *i1, const ne_inet_addr *i2)
+{
+#ifdef USE_GETADDRINFO
+    if (i1->ai_family != i2->ai_family)
+	return i2->ai_family - i1->ai_family;
+    if (i1->ai_family == AF_INET) {
+	struct sockaddr_in *in1 = SACAST(in, i1->ai_addr), 
+	    *in2 = SACAST(in, i2->ai_addr);
+	return memcmp(&in1->sin_addr.s_addr, &in2->sin_addr.s_addr, 
+		      sizeof in1->sin_addr.s_addr);
+    } 
+#ifdef AF_INET6
+    else if (i1->ai_family == AF_INET6) {
+	struct sockaddr_in6 *in1 = SACAST(in6, i1->ai_addr), 
+	    *in2 = SACAST(in6, i2->ai_addr);
+	return memcmp(in1->sin6_addr.s6_addr, in2->sin6_addr.s6_addr,
+		      sizeof in1->sin6_addr.s6_addr);
+    } 
+#endif /* AF_INET6 */
+    else
+	return -1;
+#else
+    return memcmp(&i1->s_addr, &i2->s_addr, sizeof i1->s_addr);
+#endif /* USE_GETADDRINFO */
+}
+
+void ne_iaddr_free(ne_inet_addr *addr)
+{
+#ifdef USE_GETADDRINFO
+    ne_free(addr->ai_addr);
+#endif
+    ne_free(addr);
+}
+
+int ne_sock_accept(ne_socket *sock, int listener) 
+{
+    int fd = accept(listener, NULL, NULL);
+
+    if (fd < 0) {
+        set_strerror(sock, ne_errno);
+        return -1;
+    }
+
+    sock->fd = fd;
+    return 0;
+}
+
+int ne_sock_fd(const ne_socket *sock)
+{
+    return sock->fd;
+}
+
+void ne_sock_read_timeout(ne_socket *sock, int timeout)
+{
+    sock->rdtimeout = timeout;
+}
+
+void ne_sock_connect_timeout(ne_socket *sock, int timeout)
+{
+    sock->cotimeout = timeout;
+}
+
+#ifdef NE_HAVE_SSL
+
+#ifdef HAVE_GNUTLS
+/* Dumb server session cache implementation for GNUTLS; holds a single
+ * session. */
+
+/* Copy datum 'src' to 'dest'. */
+static void copy_datum(gnutls_datum_t *dest, gnutls_datum_t *src)
+{
+    dest->size = src->size;
+    dest->data = memcpy(gnutls_malloc(src->size), src->data, src->size);
+}
+
+/* Callback to store a session 'data' with id 'key'. */
+static int store_sess(void *userdata, gnutls_datum_t key, gnutls_datum_t data)
+{
+    ne_ssl_context *ctx = userdata;
+
+    if (ctx->cache.server.key.data) { 
+        gnutls_free(ctx->cache.server.key.data);
+        gnutls_free(ctx->cache.server.data.data);
+    }
+
+    copy_datum(&ctx->cache.server.key, &key);
+    copy_datum(&ctx->cache.server.data, &data);
+
+    return 0;
+}
+
+/* Returns non-zero if d1 and d2 are the same datum. */
+static int match_datum(gnutls_datum_t *d1, gnutls_datum_t *d2)
+{
+    return d1->size == d2->size
+        && memcmp(d1->data, d2->data, d1->size) == 0;
+}
+
+/* Callback to retrieve a session of id 'key'. */
+static gnutls_datum_t retrieve_sess(void *userdata, gnutls_datum_t key)
+{
+    ne_ssl_context *ctx = userdata;
+    gnutls_datum_t ret = { NULL, 0 };
+
+    if (match_datum(&ctx->cache.server.key, &key)) {
+        copy_datum(&ret, &ctx->cache.server.data);
+    }
+
+    return ret;
+}
+
+/* Callback to remove a session of id 'key'; stub needed but
+ * implementation seems unnecessary. */
+static int remove_sess(void *userdata, gnutls_datum_t key)
+{
+    return -1;
+}
+#endif
+
+int ne_sock_accept_ssl(ne_socket *sock, ne_ssl_context *ctx)
+{
+    int ret;
+    ne_ssl_socket ssl;
+
+#if defined(HAVE_OPENSSL)
+    ssl = SSL_new(ctx->ctx);
+    
+    SSL_set_fd(ssl, sock->fd);
+
+    sock->ssl = ssl;
+    ret = SSL_accept(ssl);
+    if (ret != 1) {
+        return error_ossl(sock, ret);
+    }
+
+    if (SSL_session_reused(ssl)) {
+        NE_DEBUG(NE_DBG_SSL, "ssl: Server reused session.\n");
+    }
+#elif defined(HAVE_GNUTLS)
+    unsigned int verify_status;
+
+    gnutls_init(&ssl, GNUTLS_SERVER);
+    gnutls_credentials_set(ssl, GNUTLS_CRD_CERTIFICATE, ctx->cred);
+    gnutls_set_default_priority(ssl);
+
+    /* Set up dummy session cache. */
+    gnutls_db_set_store_function(ssl, store_sess);
+    gnutls_db_set_retrieve_function(ssl, retrieve_sess);    
+    gnutls_db_set_remove_function(ssl, remove_sess);    
+    gnutls_db_set_ptr(ssl, ctx);
+
+    if (ctx->verify)
+        gnutls_certificate_server_set_request(ssl, GNUTLS_CERT_REQUIRE);
+
+    sock->ssl = ssl;
+    gnutls_transport_set_ptr(sock->ssl, (gnutls_transport_ptr_t)(long)sock->fd);
+    ret = gnutls_handshake(ssl);
+    if (ret < 0) {
+        return error_gnutls(sock, ret);
+    }
+    if (ctx->verify && (gnutls_certificate_verify_peers2(ssl, &verify_status) || verify_status)) {
+        set_error(sock, _("Client certificate verification failed"));
+        return NE_SOCK_ERROR;
+    }
+#endif
+    sock->ops = &iofns_ssl;
+    return 0;
+}
+
+int ne_sock_connect_ssl(ne_socket *sock, ne_ssl_context *ctx, void *userdata)
+{
+    int ret;
+
+#if defined(HAVE_OPENSSL)
+    SSL *ssl;
+
+    if (seed_ssl_prng()) {
+	set_error(sock, _("SSL disabled due to lack of entropy"));
+	return NE_SOCK_ERROR;
+    }
+
+    sock->ssl = ssl = SSL_new(ctx->ctx);
+    if (!ssl) {
+	set_error(sock, _("Could not create SSL structure"));
+	return NE_SOCK_ERROR;
+    }
+    
+    SSL_set_app_data(ssl, userdata);
+    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
+    SSL_set_fd(ssl, sock->fd);
+    sock->ops = &iofns_ssl;
+
+#ifdef SSL_set_tlsext_host_name
+    if (ctx->hostname) {
+        /* Try to enable SNI, but ignore failure (should only fail for
+         * >255 char hostnames, which are probably not legal
+         * anyway).  */
+        if (SSL_set_tlsext_host_name(ssl, ctx->hostname) != 1) {
+            ERR_clear_error();
+        }
+    }
+#endif
+    
+    if (ctx->sess)
+	SSL_set_session(ssl, ctx->sess);
+
+    ret = SSL_connect(ssl);
+    if (ret != 1) {
+	error_ossl(sock, ret);
+	SSL_free(ssl);
+	sock->ssl = NULL;
+	return NE_SOCK_ERROR;
+    }
+#elif defined(HAVE_GNUTLS)
+    /* DH and RSA params are set in ne_ssl_context_create */
+    gnutls_init(&sock->ssl, GNUTLS_CLIENT);
+    gnutls_set_default_priority(sock->ssl);
+    gnutls_session_set_ptr(sock->ssl, userdata);
+    gnutls_credentials_set(sock->ssl, GNUTLS_CRD_CERTIFICATE, ctx->cred);
+
+#ifdef HAVE_GNUTLS_SIGN_CALLBACK_SET
+    if (ctx->sign_func)
+        gnutls_sign_callback_set(sock->ssl, ctx->sign_func, ctx->sign_data);    
+#endif
+
+    if (ctx->hostname) {
+        gnutls_server_name_set(sock->ssl, GNUTLS_NAME_DNS, ctx->hostname,
+                               strlen(ctx->hostname));
+    }                               
+
+    gnutls_transport_set_ptr(sock->ssl, (gnutls_transport_ptr_t)(long)sock->fd);
+
+    if (ctx->cache.client.data) {
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_session_set_data(sock->ssl, 
+                                ctx->cache.client.data, 
+                                ctx->cache.client.size);
+#else
+        gnutls_session_set_data(sock->ssl, 
+                                ctx->cache.client.data, 
+                                ctx->cache.client.len);
+#endif
+    }
+    sock->ops = &iofns_ssl;
+
+    do {
+        ret = gnutls_handshake(sock->ssl);
+    } while (RETRY_GNUTLS(sock, ret));
+    if (ret < 0) {
+	error_gnutls(sock, ret);
+        return NE_SOCK_ERROR;
+    }
+
+    if (!gnutls_session_is_resumed(sock->ssl)) {
+        /* New session.  The old method of using the _get_data
+         * function seems to be broken with 1.3.0 and later*/
+#if defined(HAVE_GNUTLS_SESSION_GET_DATA2)
+        gnutls_session_get_data2(sock->ssl, &ctx->cache.client);
+#else
+        ctx->cache.client.len = 0;
+        if (gnutls_session_get_data(sock->ssl, NULL, 
+                                    &ctx->cache.client.len) == 0) {
+            ctx->cache.client.data = ne_malloc(ctx->cache.client.len);
+            gnutls_session_get_data(sock->ssl, ctx->cache.client.data, 
+                                    &ctx->cache.client.len);
+        }
+#endif
+    }
+#endif
+    return 0;
+}
+
+ne_ssl_socket ne__sock_sslsock(ne_socket *sock)
+{
+    return sock->ssl;
+}
+
+#endif
+
+int ne_sock_sessid(ne_socket *sock, unsigned char *buf, size_t *buflen)
+{
+#ifdef NE_HAVE_SSL
+#ifdef HAVE_GNUTLS
+    if (sock->ssl) {
+        return gnutls_session_get_id(sock->ssl, buf, buflen);
+    } else {
+        return -1;
+    }
+#else
+    SSL_SESSION *sess;
+
+    if (!sock->ssl) {
+        return -1;
+    }
+
+    sess = SSL_get0_session(sock->ssl);
+
+    if (!buf) {
+        *buflen = sess->session_id_length;
+        return 0;
+    }
+
+    if (*buflen < sess->session_id_length) {
+        return -1;
+    }
+
+    *buflen = sess->session_id_length;
+    memcpy(buf, sess->session_id, *buflen);
+    return 0;
+#endif
+#else
+    return -1;
+#endif
+}
+
+char *ne_sock_cipher(ne_socket *sock)
+{
+#ifdef NE_HAVE_SSL
+    if (sock->ssl) {
+#ifdef HAVE_OPENSSL
+        const char *name = SSL_get_cipher(sock->ssl);
+        return ne_strdup(name);
+#elif defined(HAVE_GNUTLS)
+        const char *name = gnutls_cipher_get_name(gnutls_cipher_get(sock->ssl));
+        return ne_strdup(name);
+#endif
+    }
+    else 
+#endif /* NE_HAVE_SSL */
+    {
+        return NULL;
+    }    
+}
+
+const char *ne_sock_error(const ne_socket *sock)
+{
+    return sock->error;
+}
+
+void ne_sock_set_error(ne_socket *sock, const char *format, ...)
+{
+    va_list params;
+
+    va_start(params, format);
+    ne_vsnprintf(sock->error, sizeof sock->error, format, params);
+    va_end(params);
+}
+
+int ne_sock_close(ne_socket *sock)
+{
+    int ret;
+
+    /* Per API description - for an SSL connection, simply send the
+     * close_notify but do not wait for the peer's response. */
+#if defined(HAVE_OPENSSL)
+    if (sock->ssl) {
+        SSL_shutdown(sock->ssl);
+	SSL_free(sock->ssl);
+    }
+#elif defined(HAVE_GNUTLS)
+    if (sock->ssl) {
+        do {
+            ret = gnutls_bye(sock->ssl, GNUTLS_SHUT_WR);
+        } while (ret < 0
+                 && (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN));
+        gnutls_deinit(sock->ssl);
+    }
+#endif
+
+    if (sock->fd < 0)
+        ret = 0;
+    else
+        ret = ne_close(sock->fd);
+    ne_free(sock);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_socket.h b/net/mmt/neon/src/ne_socket.h
new file mode 100644
index 0000000..22b203d
--- /dev/null
+++ b/net/mmt/neon/src/ne_socket.h
@@ -0,0 +1,311 @@
+/* 
+   socket handling interface
+   Copyright (C) 1999-2010, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SOCKET_H
+#define NE_SOCKET_H
+
+#include <sys/types.h>
+
+#ifdef WIN32
+#include <stdlib.h> /* for size_t */
+#endif
+
+#include "ne_defs.h"
+#include "ne_ssl.h" /* for ne_ssl_context */
+
+NE_BEGIN_DECLS
+
+#define NE_SOCK_ERROR (-1)
+/* Read/Write timed out */
+#define NE_SOCK_TIMEOUT (-2)
+/* Socket was closed */
+#define NE_SOCK_CLOSED (-3)
+/* Connection was reset (e.g. server crashed) */
+#define NE_SOCK_RESET (-4)
+/* Secure connection was closed without proper SSL shutdown. */
+#define NE_SOCK_TRUNC (-5)
+
+/* ne_socket represents a TCP socket. */
+typedef struct ne_socket_s ne_socket;
+
+/* ne_sock_addr represents an address object. */
+typedef struct ne_sock_addr_s ne_sock_addr;
+
+#ifndef NE_INET_ADDR_DEFINED
+typedef struct ne_inet_addr_s ne_inet_addr;
+#endif
+
+/* Perform process-global initialization of any libraries in use.
+ * Returns non-zero on error. */
+int ne_sock_init(void);
+
+/* Perform process-global shutdown of any libraries in use.  This
+ * function only has effect when it has been called an equal number of
+ * times to ne_sock_init() for the process. */
+void ne_sock_exit(void);
+
+#define NE_ADDR_CANON (0x01)
+/* Resolve the given hostname. Hex string IPv6 addresses (e.g. `::1')
+ * may be enclosed in brackets (e.g. `[::1]').  'flags' should be
+ * zero, or if NE_ADDR_CANON is passed, the canonical name for the
+ * hostname will be determind. */
+ne_sock_addr *ne_addr_resolve(const char *hostname, int flags);
+
+/* Returns zero if name resolution was successful, non-zero on
+ * error. */
+int ne_addr_result(const ne_sock_addr *addr);
+
+/* Returns the first network address associated with the 'addr'
+ * object.  Undefined behaviour if ne_addr_result returns non-zero for
+ * 'addr'; otherwise, never returns NULL.  */
+const ne_inet_addr *ne_addr_first(ne_sock_addr *addr);
+
+/* Returns the next network address associated with the 'addr' object,
+ * or NULL if there are no more. */
+const ne_inet_addr *ne_addr_next(ne_sock_addr *addr);
+
+/* NB: the pointers returned by ne_addr_first and ne_addr_next are
+ * valid until ne_addr_destroy is called for the corresponding
+ * ne_sock_addr object.  They must not be passed to ne_iaddr_free. */
+
+/* If name resolution fails, copies the error string into 'buffer',
+ * which is of size 'bufsiz'.  'buffer' is returned. */
+char *ne_addr_error(const ne_sock_addr *addr, char *buffer, size_t bufsiz);
+
+/* Returns the canonical name of the host as a NUL-terminated string,
+ * if NE_ADDR_CANON was used, and name resolution was successful.
+ * Otherwise, returns NULL. */
+const char *ne_addr_canonical(const ne_sock_addr *addr);
+
+/* Destroys an address object created by ne_addr_resolve. */
+void ne_addr_destroy(ne_sock_addr *addr);
+
+/* Network address type; IPv4 or IPv6 */
+typedef enum {
+    ne_iaddr_ipv4 = 0,
+    ne_iaddr_ipv6
+} ne_iaddr_type;
+
+/* Create a network address object from raw byte representation (in
+ * network byte order) of given type.  'raw' must be four bytes for an
+ * IPv4 address, 16 bytes for an IPv6 address.  May return NULL if
+ * address type is not supported. */
+ne_inet_addr *ne_iaddr_make(ne_iaddr_type type, const unsigned char *raw);
+
+/* Compare two network address objects i1 and i2; returns zero if they
+ * are equivalent or non-zero otherwise.  */
+int ne_iaddr_cmp(const ne_inet_addr *i1, const ne_inet_addr *i2);
+
+/* Return the type of the given network address object. */
+ne_iaddr_type ne_iaddr_typeof(const ne_inet_addr *ia);
+
+/* Print the string representation of network address 'ia' into the
+ * buffer 'buffer', which is of length 'bufsiz'.  Returns 'buffer'. */
+char *ne_iaddr_print(const ne_inet_addr *ia, char *buffer, size_t bufsiz);
+
+/* Dump the raw byte representation (in network byte order) of address
+ * 'ia' into the buffer 'buffer', which must be of a suitable length
+ * (4 bytes for an IPv4 address, 16 bytes for an IPv6 address).
+ * Returns 'buffer'. */
+unsigned char *ne_iaddr_raw(const ne_inet_addr *ia, unsigned char *buffer);
+
+/* Perform the reverse name lookup on network address 'ia', placing
+ * the returned name in the 'buf' buffer (of length 'bufsiz') if
+ * successful.  Returns zero on success, or non-zero on error. */
+int ne_iaddr_reverse(const ne_inet_addr *ia, char *buf, size_t bufsiz);
+
+/* Convert network address string 'addr' (for example, "127.0.0.1")
+ * into a network address object.  Returns NULL on parse error.  If
+ * non-NULL, return value must be freed using ne_iaddr_free. */
+ne_inet_addr *ne_iaddr_parse(const char *addr, ne_iaddr_type type);
+
+/* Destroy a network address object created using ne_iaddr_make or
+ * ne_iaddr_parse. */
+void ne_iaddr_free(ne_inet_addr *addr);
+
+/* Create a socket object; returns NULL on error. */
+ne_socket *ne_sock_create(void);
+
+/* Specify an address to which the local end of the socket will be
+ * bound during a subsequent ne_sock_connect() call.  If the address
+ * passed to ne_sock_connect() is of a different type (family) to
+ * 'addr', 'addr' is ignored.  Either 'addr' may be NULL, to use the
+ * given port with unspecified address, or 'port' may be 0, to use the
+ * given address with an unspecified port.
+ *
+ * (Note: This function is not equivalent to a BSD socket bind(), it
+ * only takes effect during the _connect() call). */
+void ne_sock_prebind(ne_socket *sock, const ne_inet_addr *addr,
+                     unsigned int port);
+
+/* Connect the socket to server at address 'addr' on port 'port'.
+ * Returns zero on success, NE_SOCK_TIMEOUT if a timeout occurs when a
+ * non-zero connect timeout is configured (and is supported), or
+ * NE_SOCK_ERROR on failure.  */
+int ne_sock_connect(ne_socket *sock, const ne_inet_addr *addr, 
+                    unsigned int port);
+
+/* Read up to 'count' bytes from socket into 'buffer'.  Returns:
+ *   NE_SOCK_* on error,
+ *   >0 length of data read into buffer (may be less than 'count')
+ */
+ssize_t ne_sock_read(ne_socket *sock, char *buffer, size_t count);
+
+/* Read up to 'count' bytes into 'buffer', leaving the data available
+ * in the socket buffer to be returned by a subsequent call to
+ * ne_sock_read or ne_sock_peek. Returns:
+ *   NE_SOCK_* on error,
+ *   >0 length of data read into buffer.
+ */
+ssize_t ne_sock_peek(ne_socket *sock, char *buffer, size_t count);
+
+/* Block for up to 'n' seconds until data becomes available for reading
+ * from the socket. Returns:
+ *  NE_SOCK_* on error,
+ *  NE_SOCK_TIMEOUT if no data arrives in 'n' seconds,
+ *  0 if data arrived on the socket.
+ */
+int ne_sock_block(ne_socket *sock, int n);
+
+/* Write 'count' bytes of 'data' to the socket.  Guarantees to either
+ * write all the bytes or to fail.  Returns 0 on success, or NE_SOCK_*
+ * on error. */
+int ne_sock_fullwrite(ne_socket *sock, const char *data, size_t count); 
+
+/* I/O vector. */
+struct ne_iovec {
+    void *base;
+    size_t len;
+};
+
+/* Writes 'count' blocks described by 'vector' to the socket.
+ * Guarantees to either write all the bytes or to fail.  Count must be
+ * greater than zero and smaller than the system-defined maximum
+ * vector limit.  Returns 0 on success, or NE_SOCK_* on error. */
+int ne_sock_fullwritev(ne_socket *sock, const struct ne_iovec *vector,
+                       int count); 
+
+/* Read an LF-terminated line into 'buffer', and NUL-terminate it.
+ * At most 'len' bytes are read (including the NUL terminator).
+ * Returns:
+ * NE_SOCK_* on error,
+ * >0 number of bytes read (including NUL terminator)
+ */
+ssize_t ne_sock_readline(ne_socket *sock, char *buffer, size_t len);
+
+/* Read exactly 'len' bytes into buffer, or fail; returns 0 on
+ * success, NE_SOCK_* on error. */
+ssize_t ne_sock_fullread(ne_socket *sock, char *buffer, size_t len);
+
+/* Accepts a connection from listening socket 'fd' and places the
+ * socket in 'sock'.  Returns zero on success or -1 on failure. */
+int ne_sock_accept(ne_socket *sock, int fd);
+
+/* Returns the file descriptor used for socket 'sock'. */
+int ne_sock_fd(const ne_socket *sock);
+
+/* Return address of peer, or NULL on error.  The returned address
+ * must be destroyed by caller using ne_iaddr_free. */
+ne_inet_addr *ne_sock_peer(ne_socket *sock, unsigned int *port);
+
+/* Close the socket and destroy the socket object.  If SSL is in use
+ * for the socket, a closure alert is sent to initiate a clean
+ * shutdown, but this function does not wait for the peer's response.
+ * Returns zero on success, or non-zero on failure. */
+int ne_sock_close(ne_socket *sock);
+
+/* Return current error string for socket. */
+const char *ne_sock_error(const ne_socket *sock);
+
+/* Set the error string for the socket; takes printf-like format
+ * string. */
+void ne_sock_set_error(ne_socket *sock, const char *format, ...)
+    ne_attribute((format (printf, 2, 3)));
+
+/* Set read timeout for socket, in seconds; must be a non-zero
+ * positive integer. */
+void ne_sock_read_timeout(ne_socket *sock, int timeout);
+
+/* Set connect timeout for socket, in seconds; must be a positive
+ * integer.  If a timeout of 'zero' is used then then no explicit
+ * timeout handling will be used for ne_sock_connect(), and the
+ * connect call will only timeout as dictated by the TCP stack. */
+void ne_sock_connect_timeout(ne_socket *sock, int timeout);
+
+/* Negotiate an SSL connection on socket as an SSL server, using given
+ * SSL context. */
+int ne_sock_accept_ssl(ne_socket *sock, ne_ssl_context *ctx);
+
+/* Negotiate an SSL connection on socket as an SSL client, using given
+ * SSL context.  The 'userdata' parameter is associated with the
+ * underlying SSL library's socket structure for use in callbacks.
+ * Returns zero on success, or non-zero on error. */
+int ne_sock_connect_ssl(ne_socket *sock, ne_ssl_context *ctx,
+                        void *userdata);
+
+/* Retrieve the session ID of the current SSL session.  If 'buf' is
+ * non-NULL, on success, copies at most *buflen bytes to 'buf' and
+ * sets *buflen to the exact number of bytes copied.  If 'buf' is
+ * NULL, on success, sets *buflen to the length of the session ID.
+ * Returns zero on success, non-zero on error. */
+int ne_sock_sessid(ne_socket *sock, unsigned char *buf, size_t *buflen);
+
+/* Return human-readable name of SSL/TLS cipher used for connection,
+ * or NULL if none.  The format of this string is not intended to be
+ * fixed or parseable, but is informational only.  Return value is
+ * NUL-terminated malloc-allocated string if not NULL, which must be
+ * freed by the caller. */
+char *ne_sock_cipher(ne_socket *sock);
+
+/* SOCKS proxy protocol version: */
+enum ne_sock_sversion {
+    NE_SOCK_SOCKSV4 = 0,
+    NE_SOCK_SOCKSV4A,
+    NE_SOCK_SOCKSV5
+};
+
+/* Given a socket 'sock' which is connected to a SOCKS proxy, initiate
+ * a connection to a destination server using that proxy, specified
+ * either by network address or hostname, at given port 'port'.
+ *
+ * If 'vers' is NE_SOCKS_V4, addr must be an IPv4 address; hostname
+ * and password are ignored; username must be non-NULL.
+ *
+ * If 'vers' is NE_SOCKS_V4A, hostname must be non-NULL; addr is
+ * ignored; password is ignored; username must be non-NULL.
+ *
+ * If 'vers' is NE_SOCKS_V5, addr may be NULL, in which case hostname
+ * must be non-NULL.  addr if non-NULL may be an IPv4 or IPv6 address;
+ * username may be NULL, in which case password is ignored.  If
+ * username is non-NULL password must also be non-NULL.
+ *
+ * Returns 0 on success, or NE_SOCK_* on failure - in which case, the
+ * socket error string is set.  On failure, the socket must be closed
+ * by the caller.
+ */
+int ne_sock_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                  const ne_inet_addr *addr, const char *hostname, 
+                  unsigned int port,
+                  const char *username, const char *password);
+
+NE_END_DECLS
+
+#endif /* NE_SOCKET_H */
diff --git a/net/mmt/neon/src/ne_socks.c b/net/mmt/neon/src/ne_socks.c
new file mode 100644
index 0000000..73d9f04
--- /dev/null
+++ b/net/mmt/neon/src/ne_socks.c
@@ -0,0 +1,354 @@
+/*
+   SOCKS proxy support for neon
+   Copyright (C) 2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+*/
+
+#include "config.h"
+
+#include "ne_internal.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_utils.h"
+
+#include <string.h>
+
+/* SOCKS protocol reference:
+   v4:  http://www.ufasoft.com/doc/socks4_protocol.htm
+   v4a  http://www.smartftp.com/Products/SmartFTP/RFC/socks4a.protocol
+   v5:  http://tools.ietf.org/html/rfc1928
+   ...v5 auth: http://tools.ietf.org/html/rfc1929
+*/
+
+#define V5_REPLY_OK 0
+#define V5_REPLY_FAIL 1
+#define V5_REPLY_DISALLOW 2
+#define V5_REPLY_NET_UNREACH 3
+#define V5_REPLY_HOST_UNREACH 4
+#define V5_REPLY_CONN_REFUSED 5
+#define V5_REPLY_TTL_EXPIRED 6
+#define V5_REPLY_CMD_UNSUPPORTED 7
+#define V5_REPLY_TYPE_UNSUPPORTED 8
+
+#define V5_VERSION   0x05
+#define V5_ADDR_IPV4 0x01
+#define V5_ADDR_FQDN 0x03
+#define V5_ADDR_IPV6 0x04
+
+#define V5_CMD_CONNECT 0x01
+
+#define V5_AUTH_NONE   0x00
+#define V5_AUTH_USER   0x02
+#define V5_AUTH_NOMETH 0xFF
+
+/* Fail with given V5 error code in given context. */
+static int v5fail(ne_socket *sock, unsigned int code, const char *context)
+{
+    const char *err;
+
+    switch (code) {
+    case V5_REPLY_FAIL:
+        err = _("failure");
+        break;
+    case V5_REPLY_DISALLOW:
+        err = _("connection not permitted"); 
+        break;
+    case V5_REPLY_NET_UNREACH:
+        err = _("network unreachable");
+        break;
+    case V5_REPLY_HOST_UNREACH: 
+        err = _("host unreachable");
+        break;
+    case V5_REPLY_TTL_EXPIRED:
+        err = _("TTL expired");
+        break;
+    case V5_REPLY_CMD_UNSUPPORTED:
+        err = _("command not supported");
+        break;
+    case V5_REPLY_TYPE_UNSUPPORTED: 
+        err = _("address type not supported");
+        break;
+    default:
+        ne_sock_set_error(sock, _("%s: unrecognized error (%u)"), context, code);
+        return NE_SOCK_ERROR;
+    }
+    
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    return NE_SOCK_ERROR;
+}
+
+/* Fail with given error string. */
+static int fail(ne_socket *sock, const char *error)
+{
+    ne_sock_set_error(sock, "%s", error);
+    return NE_SOCK_ERROR;
+}
+
+/* Fail with given NE_SOCK_* error code and given context. */
+static int sofail(ne_socket *sock, ssize_t ret, const char *context)
+{
+    char *err = ne_strdup(ne_sock_error(sock));
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    ne_free(err);
+    return NE_SOCK_ERROR;
+}
+
+/* SOCKSv5 proxy. */
+static int v5_proxy(ne_socket *sock, const ne_inet_addr *addr,
+                    const char *hostname, unsigned int port,
+                    const char *username, const char *password)
+{
+    unsigned char msg[1024], *p;
+    unsigned int len;
+    int ret;
+    ssize_t n;
+
+    p = msg;
+    *p++ = V5_VERSION;
+    *p++ = 2; /* Two supported auth protocols; none and user. */
+    *p++ = V5_AUTH_NONE;
+    *p++ = V5_AUTH_USER;
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send message to proxy"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 2);
+    if (n) {
+        return sofail(sock, ret, _("Could not read initial response from proxy"));
+    }
+    else if (msg[0] != V5_VERSION) {
+        return fail(sock, _("Invalid version in proxy response"));
+    }
+    
+    /* Authenticate, if necessary. */
+    switch (msg[1]) {
+    case V5_AUTH_NONE:
+        break;
+    case V5_AUTH_USER:
+        p = msg;
+        *p++ = 0x01;
+        len = strlen(username) & 0xff;
+        *p++ = len;
+        memcpy(p, username, len);
+        p += len;
+        len = strlen(password) & 0xff;
+        *p++ = len;
+        memcpy(p, password, len);
+        p += len;
+
+        ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+        if (ret) {
+            return sofail(sock, ret, _("Could not send login message"));
+        }
+        
+        n = ne_sock_fullread(sock, (char *)msg, 2);
+        if (n) {
+            return sofail(sock, ret, _("Could not read login reply"));
+        }
+        else if (msg[0] != 1) {
+            return fail(sock, _("Invalid version in login reply"));
+        }
+        else if (msg[1] != 0) {
+            return fail(sock, _("Authentication failed"));
+        }
+        break;
+    case V5_AUTH_NOMETH:
+        return fail(sock, _("No acceptable authentication method"));
+    default:
+        return fail(sock, _("Unexpected authentication method chosen"));
+    }
+    
+    /* Send the CONNECT command. */
+    p = msg;
+    *p++ = V5_VERSION;
+    *p++ = V5_CMD_CONNECT;
+    *p++ = 0; /* reserved */
+    if (addr) {
+        unsigned char raw[16];
+
+        if (ne_iaddr_typeof(addr) == ne_iaddr_ipv4) {
+            len = 4;
+            *p++ = V5_ADDR_IPV4;
+        }
+        else {
+            len = 16;
+            *p++ = V5_ADDR_IPV6;
+        }
+        
+        memcpy(p, ne_iaddr_raw(addr, raw), len);
+        p += len;
+    }
+    else {
+        len = strlen(hostname) & 0xff;
+        *p++ = V5_ADDR_FQDN;
+        *p++ = len;
+        memcpy(p, hostname, len);
+        p += len;
+    }
+
+    *p++ = (port >> 8) & 0xff;
+    *p++ = port & 0xff;
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send connect request"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 4);
+    if (n) {
+        return sofail(sock, n, _("Could not read connect reply"));
+    }
+    if (msg[0] != V5_VERSION) {
+        return fail(sock, _("Invalid version in connect reply"));
+    }
+    if (msg[1] != V5_REPLY_OK) {
+        return v5fail(sock, msg[1], _("Could not connect"));
+    }
+    
+    switch (msg[3]) {
+    case V5_ADDR_IPV4:
+        len = 4;
+        break;
+    case V5_ADDR_IPV6:
+        len = 16;
+        break;
+    case V5_ADDR_FQDN:
+        n = ne_sock_read(sock, (char *)msg, 1);
+        if (n != 1) {
+            return sofail(sock, n, 
+                            _("Could not read FQDN length in connect reply"));
+        }
+        len = msg[0];
+        break;
+    default:
+        return fail(sock, _("Unknown address type in connect reply"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, len + 2);
+    if (n) {
+        return sofail(sock, n, _("Could not read address in connect reply"));
+    }
+
+    return 0;
+}
+
+#define V4_VERSION 0x04
+#define V4_CMD_STREAM 0x01
+
+#define V4_REP_OK      0x5a /* request granted */
+#define V4_REP_FAIL    0x5b /* request rejected or failed */
+#define V4_REP_NOIDENT 0x5c /* request failed, could connect to identd */
+#define V4_REP_IDFAIL  0x5d /* request failed, identd denial */
+
+/* Fail for given SOCKSv4 error code. */
+static int v4fail(ne_socket *sock, unsigned int code, const char *context)
+{
+    const char *err;
+
+    switch (code) {
+    case V4_REP_FAIL:
+        err = _("request rejected or failed");
+        break;
+    case V4_REP_NOIDENT:
+        err = _("could not establish connection to identd");
+        break;
+    case V4_REP_IDFAIL:
+        err = _("rejected due to identd user mismatch");
+        break;
+    default:
+        ne_sock_set_error(sock, _("%s: unrecognized failure (%u)"),
+                          context, code);
+        return NE_SOCK_ERROR;
+    }
+    
+    ne_sock_set_error(sock, "%s: %s", context, err);
+    return NE_SOCK_ERROR;
+}
+
+/* SOCKS v4 or v4A proxy. */
+static int v4_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                    const ne_inet_addr *addr, const char *hostname, 
+                    unsigned int port, const char *username)
+{
+    unsigned char msg[1024], raw[16], *p;
+    ssize_t n;
+    int ret;
+
+    p = msg;
+    *p++ = V4_VERSION;
+    *p++ = V4_CMD_STREAM;
+    *p++ = (port >> 8) & 0xff;
+    *p++ = port & 0xff;
+
+    if (vers == NE_SOCK_SOCKSV4A) {
+        /* A bogus address is used to signify use of the hostname,
+         * 0.0.0.X where X != 0. */
+        memcpy(p, "\x00\x00\x00\xff", 4);
+    } 
+    else {
+        /* API precondition that addr is IPv4; if it's not this will
+         * just copy out the first four bytes of the v6 address;
+         * garbage in => garbage out. */
+        memcpy(p, ne_iaddr_raw(addr, raw), 4);
+    }
+    p += 4;
+
+    if (username) {
+        unsigned int len = strlen(username) & 0xff;
+        memcpy(p, username, len);
+        p += len;
+    }
+    *p++ = '\0';
+    
+    if (vers == NE_SOCK_SOCKSV4A) {
+        unsigned int len = strlen(hostname) & 0xff;
+        memcpy(p, hostname, len);
+        p += len;
+        *p++ = '\0';
+    }    
+
+    ret = ne_sock_fullwrite(sock, (char *)msg, p - msg);
+    if (ret) {
+        return sofail(sock, ret, _("Could not send message to proxy"));
+    }
+
+    n = ne_sock_fullread(sock, (char *)msg, 8);
+    if (n) {
+        return sofail(sock, ret, _("Could not read response from proxy"));
+    }
+    
+    if (msg[1] != V4_REP_OK) {
+        return v4fail(sock, ret, _("Could not connect"));
+    }
+
+    return 0;
+}
+
+int ne_sock_proxy(ne_socket *sock, enum ne_sock_sversion vers,
+                  const ne_inet_addr *addr, const char *hostname, 
+                  unsigned int port,
+                  const char *username, const char *password)
+{
+    if (vers == NE_SOCK_SOCKSV5) {
+        return v5_proxy(sock, addr, hostname, port, username, password);
+    }
+    else {
+        return v4_proxy(sock, vers, addr, hostname, port, username);
+    }
+}
diff --git a/net/mmt/neon/src/ne_ssl.h b/net/mmt/neon/src/ne_ssl.h
new file mode 100644
index 0000000..685b2c9
--- /dev/null
+++ b/net/mmt/neon/src/ne_ssl.h
@@ -0,0 +1,201 @@
+/* 
+   SSL/TLS abstraction layer for neon
+   Copyright (C) 2003-2006, 2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+/* ne_ssl.h defines an interface for loading and accessing the
+ * properties of SSL certificates. */
+
+#ifndef NE_SSL_H
+#define NE_SSL_H 1
+
+#include <sys/types.h>
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* A "distinguished name"; a unique name for some entity. */
+typedef struct ne_ssl_dname_s ne_ssl_dname;
+
+/* Returns a single-line string representation of a distinguished
+ * name, intended to be human-readable (e.g. "Acme Ltd., Norfolk,
+ * GB").  Return value is a UTF-8-encoded malloc-allocated string and
+ * must be free'd by the caller. */
+char *ne_ssl_readable_dname(const ne_ssl_dname *dn);
+
+/* Returns zero if 'dn1' and 'dn2' refer to same name, or non-zero if
+ * they are different. */
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2);
+
+/* An SSL certificate. */
+typedef struct ne_ssl_certificate_s ne_ssl_certificate;
+
+/* Read a certificate from a file in PEM format; returns NULL if the
+ * certificate could not be parsed. */
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename);
+
+/* Write a certificate to a file in PEM format; returns non-zero if
+ * the certificate could not be written. */
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename);
+
+/* Export a certificate to a base64-encoded, NUL-terminated string.
+ * The returned string is malloc-allocated and must be free()d by the
+ * caller. */
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert);
+
+/* Import a certificate from a base64-encoded string as returned by
+ * ne_ssl_cert_export(). Returns a certificate object or NULL if
+ * 'data' was not valid. */
+ne_ssl_certificate *ne_ssl_cert_import(const char *data);
+
+/* Returns the identity of the certificate, or NULL if none is given.
+ * For a server certificate this will be the hostname of the server to
+ * which the cert was issued.  A NUL-terminated UTF-8-encoded string
+ * is returned, which is valid for the lifetime of the certificate
+ * object. */
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert);
+
+/* Return the certificate of the entity which signed certificate
+ * 'cert'.  Returns NULL if 'cert' is self-signed or the issuer
+ * certificate is not available; if non-NULL, the pointer is valid for
+ * the lifetime of the certificate object. */
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert);
+
+/* Returns the distinguished name of the certificate issuer. */
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert);
+
+/* Returns the distinguished name of the certificate subject. */
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert);
+
+#define NE_SSL_DIGESTLEN (60)
+
+/* Calculate the certificate digest ("fingerprint") and format it as a
+ * NUL-terminated hex string in 'digest', of the form "aa:bb:...:ff".
+ * Returns zero on success or non-zero if there was an internal error
+ * whilst calculating the digest.  'digest' must be at least 
+ * NE_SSL_DIGESTLEN bytes in length. */
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char *digest);
+
+/* Copy the validity times for the certificate 'cert' into 'from' and
+ * 'until' (either may be NULL).  If the time cannot be represented by
+ * a time_t value, then (time_t)-1 will be written. */
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until);
+
+#define NE_SSL_VDATELEN (30)
+/* Copy the validity times into buffers 'from' and 'until' as
+ * NUL-terminated human-readable strings, using RFC 1123-style date
+ * formatting (and not localized, so always using English month/week
+ * names).  The buffers must be at least NE_SSL_VDATELEN bytes in
+ * length, and either may be NULL. */
+void ne_ssl_cert_validity(const ne_ssl_certificate *cert,
+                          char *from, char *until);
+
+/* Returns zero if 'c1' and 'c2' refer to the same certificate, or
+ * non-zero otherwise. */
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1,
+                    const ne_ssl_certificate *c2);
+
+/* Deallocate memory associated with certificate. */
+void ne_ssl_cert_free(ne_ssl_certificate *cert);
+
+/* A client certificate (and private key).  A client certificate
+ * object has state; the object is either in the "encrypted" or
+ * "decrypted" state.  */
+typedef struct ne_ssl_client_cert_s ne_ssl_client_cert;
+
+/* Read a client certificate (and private key) in PKCS#12 format from
+ * file 'filename'; returns NULL if the file could not be parsed, or
+ * otherwise returning a client certificate object.  The returned
+ * object may be in either the encrypted or decrypted state. */
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename);
+
+/* Read a client certificate (and private key) in PKCS#12 format from
+ * 'buffer', of length 'buflen', returning NULL if the certificate
+ * could not be parsed, or otherwise returning a client certificate
+ * object.  The returned object may be in either the encrypted or
+ * decrypted state. */
+ne_ssl_client_cert *ne_ssl_clicert_import(const unsigned char *buffer, 
+                                          size_t buflen);
+
+/* Returns non-zero if client cert is in the encrypted state. */
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *ccert);
+
+/* Returns the "friendly name" given for the client cert, or NULL if
+ * none given.  Returns a NUL-terminated, UTF-8-encoded string.  This
+ * function may be used on a ccert object in either encrypted or
+ * decrypted state. */
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert);
+
+/* Decrypt the encrypted client cert using the given password.
+ * Returns non-zero on failure, in which case, the ccert object
+ * remains in the encrypted state and the function may be called again
+ * with a different password.  This function has undefined behaviour
+ * for a ccert object which is in the decrypted state. */
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *ccert, const char *password);
+
+/* Return the actual certificate part of the client certificate (never
+ * returns NULL).  This function has undefined behaviour for a ccert
+ * object which is in the encrypted state. */
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *ccert);
+
+/* Destroy a client certificate object.  This function may be used on
+ * a ccert object in either the encrypted or decrypted state. */
+void ne_ssl_clicert_free(ne_ssl_client_cert *ccert);
+
+
+/* SSL context object.  The interfaces to manipulate an SSL context
+ * are only needed when interfacing directly with ne_socket.h. */
+typedef struct ne_ssl_context_s ne_ssl_context;
+
+/* Context creation modes: */
+#define NE_SSL_CTX_CLIENT (0) /* client context */
+#define NE_SSL_CTX_SERVER (1) /* default server context */
+#define NE_SSL_CTX_SERVERv2 (2) /* SSLv2-specific server context */
+
+/* Create an SSL context. */
+ne_ssl_context *ne_ssl_context_create(int mode);
+
+/* Client mode: trust the given certificate 'cert' in context 'ctx'. */
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert);
+
+/* Server mode: use given cert and key (filenames to PEM certificates). */
+int ne_ssl_context_keypair(ne_ssl_context *ctx,
+                           const char *cert, const char *key);
+
+/* Server mode: set client cert verification options: required is non-zero if 
+ * a client cert is required, if ca_names is non-NULL it is a filename containing
+ * a set of PEM certs from which CA names are sent in the ccert request. */
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, int required,
+                              const char *ca_names, const char *verify_cas);
+
+#define NE_SSL_CTX_SSLv2 (0)
+/* Set a flag for the SSL context. */
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value);
+
+/* Return flag value. */
+int ne_ssl_context_get_flag(ne_ssl_context *ctx, int flag);
+
+/* Destroy an SSL context. */
+void ne_ssl_context_destroy(ne_ssl_context *ctx);
+
+NE_END_DECLS
+
+#endif
diff --git a/net/mmt/neon/src/ne_sspi.c b/net/mmt/neon/src/ne_sspi.c
new file mode 100644
index 0000000..9b40df7
--- /dev/null
+++ b/net/mmt/neon/src/ne_sspi.c
@@ -0,0 +1,606 @@
+/* 
+   Microsoft SSPI based authentication routines
+   Copyright (C) 2004-2005, Vladimir Berezniker @ http://public.xdi.org/=vmpn
+   Copyright (C) 2007, Yves Martin  <ymartin59@free.fr>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include "ne_utils.h"
+#include "ne_string.h"
+#include "ne_socket.h"
+#include "ne_sspi.h"
+
+#ifdef HAVE_SSPI
+
+#define SEC_SUCCESS(Status) ((Status) >= 0)
+
+#ifndef SECURITY_ENTRYPOINT   /* Missing in MingW 3.7 */
+#define SECURITY_ENTRYPOINT "InitSecurityInterfaceA"
+#endif
+
+struct SSPIContextStruct {
+    CtxtHandle context;
+    char *serverName;
+    CredHandle credentials;
+    int continueNeeded;
+    int authfinished;
+    char *mechanism;
+    int ntlm;
+    ULONG maxTokenSize;
+};
+
+typedef struct SSPIContextStruct SSPIContext;
+
+static ULONG negotiateMaxTokenSize = 0;
+static ULONG ntlmMaxTokenSize = 0;
+static HINSTANCE hSecDll = NULL;
+static PSecurityFunctionTable pSFT = NULL;
+static int initialized = 0;
+
+/*
+ * Query specified package for it's maximum token size.
+ */
+static int getMaxTokenSize(char *package, ULONG * maxTokenSize)
+{
+    SECURITY_STATUS status;
+    SecPkgInfo *packageSecurityInfo = NULL;
+
+    status = pSFT->QuerySecurityPackageInfo(package, &packageSecurityInfo);
+    if (status == SEC_E_OK) {
+        *maxTokenSize = packageSecurityInfo->cbMaxToken;
+        if (pSFT->FreeContextBuffer(packageSecurityInfo) != SEC_E_OK) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unable to free security package info.");
+        }
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: QuerySecurityPackageInfo [failed] [%x].", status);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Initialize all the SSPI data
+ */
+static void initDll(HINSTANCE hSecDll)
+{
+    INIT_SECURITY_INTERFACE initSecurityInterface = NULL;
+
+    initSecurityInterface =
+        (INIT_SECURITY_INTERFACE) GetProcAddress(hSecDll,
+                                                 SECURITY_ENTRYPOINT);
+
+    if (initSecurityInterface == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Obtaining security interface [fail].\n");
+        initialized = -1;
+        return;
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Obtaining security interface [ok].\n");
+    }
+
+    pSFT = (initSecurityInterface) ();
+
+    if (pSFT == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Security Function Table [fail].\n");
+        initialized = -2;
+        return;
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Security Function Table [ok].\n");
+    }
+
+    if (getMaxTokenSize("Negotiate", &negotiateMaxTokenSize)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to get negotiate maximum packet size");
+        initialized = -3;
+    }
+
+    if (getMaxTokenSize("NTLM", &ntlmMaxTokenSize)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to get negotiate maximum packet size");
+        initialized = -3;
+    }
+}
+
+/*
+ * This function needs to be called at least once before using any other.
+ */
+int ne_sspi_init(void)
+{
+    if (initialized) {
+        return 0;
+    }
+
+    NE_DEBUG(NE_DBG_SOCKET, "sspiInit\n");
+    NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading security dll.\n");
+    hSecDll = LoadLibrary("security.dll");
+
+    if (hSecDll == NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading of security dll [fail].\n");
+    } else {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Loading of security dll [ok].\n");
+        initDll(hSecDll);
+        if (initialized == 0) {
+            initialized = 1;
+        }
+    }
+
+    NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: sspiInit [%d].\n", initialized);
+    if (initialized < 0) {
+        return initialized;
+    } else {
+        return 0;
+    }
+}
+
+/*
+ * This function can be called to free resources used by SSPI.
+ */
+int ne_sspi_deinit(void)
+{
+    NE_DEBUG(NE_DBG_SOCKET, "sspi: DeInit\n");
+    if (initialized <= 0) {
+        return initialized;
+    }
+
+    pSFT = NULL;
+
+    if (hSecDll != NULL) {
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Unloading security dll.\n");
+        if (FreeLibrary(hSecDll)) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unloading of security dll [ok].\n");
+        } else {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "sspi: Unloading of security dll [fail].\n");
+            return -1;
+        }
+        hSecDll = NULL;
+    }
+
+    initialized = 0;
+    return 0;
+}
+
+/*
+ * Simplification wrapper arround AcquireCredentialsHandle as most of
+ * the parameters do not change.
+ */
+static int acquireCredentialsHandle(CredHandle * credentials, char *package)
+{
+    SECURITY_STATUS status;
+    TimeStamp timestamp;
+
+    status =
+        pSFT->AcquireCredentialsHandle(NULL, package, SECPKG_CRED_OUTBOUND,
+                                       NULL, NULL, NULL, NULL, credentials,
+                                       &timestamp);
+
+    if (status != SEC_E_OK) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: AcquireCredentialsHandle [fail] [%x].\n", status);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Wrapper arround initializeSecurityContext.  Supplies several
+ * default parameters as well as logging in case of errors.
+ */
+static SECURITY_STATUS
+initializeSecurityContext(CredHandle * credentials, CtxtHandle * context,
+                          char *spn, ULONG contextReq,
+                          SecBufferDesc * inBuffer, CtxtHandle * newContext,
+                          SecBufferDesc * outBuffer)
+{
+    ULONG contextAttributes;
+    SECURITY_STATUS status;
+
+    status =
+        pSFT->InitializeSecurityContext(credentials, context, spn, contextReq,
+                                        0, SECURITY_NETWORK_DREP, inBuffer, 0,
+                                        newContext, outBuffer,
+                                        &contextAttributes, NULL);
+
+    if (!SEC_SUCCESS(status)) {
+        if (status == SEC_E_INVALID_TOKEN) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] SEC_E_INVALID_TOKEN.\n");
+        } else if (status == SEC_E_UNSUPPORTED_FUNCTION) {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] SEC_E_UNSUPPORTED_FUNCTION.\n");
+        } else {
+            NE_DEBUG(NE_DBG_HTTPAUTH,
+                     "InitializeSecurityContext [fail] [%x].\n", status);
+        }
+    }
+
+    return status;
+}
+
+/*
+ * Validates that the pointer is not NULL and converts it to its real type.
+ */
+static int getContext(void *context, SSPIContext **sspiContext)
+{
+    if (!context) {
+        return -1;
+    }
+
+    *sspiContext = context;
+    return 0;
+}
+
+/*
+ * Verifies that the buffer descriptor point only to one buffer and
+ * returns the pointer to it.
+ */
+static int getSingleBufferDescriptor(SecBufferDesc *secBufferDesc,
+                                     SecBuffer **secBuffer)
+{
+    if (secBufferDesc->cBuffers != 1) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: fillBufferDescriptor "
+                 "[fail] numbers of descriptor buffers. 1 != [%d].\n",
+                 secBufferDesc->cBuffers);
+        return -1;
+    }
+
+    *secBuffer = secBufferDesc->pBuffers;
+    return 0;
+}
+
+/*
+ * Decodes BASE64 string into SSPI SecBuffer
+ */
+static int base64ToBuffer(const char *token, SecBufferDesc * secBufferDesc)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    buffer->BufferType = SECBUFFER_TOKEN;
+    buffer->cbBuffer =
+        ne_unbase64(token, (unsigned char **) &buffer->pvBuffer);
+
+    if (buffer->cbBuffer == 0) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Unable to decode BASE64 SSPI token.\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * Creates a SecBuffer of a specified size.
+ */
+static int makeBuffer(SecBufferDesc * secBufferDesc, ULONG size)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    buffer->BufferType = SECBUFFER_TOKEN;
+    buffer->cbBuffer = size;
+    buffer->pvBuffer = ne_calloc(size);
+
+    return 0;
+}
+
+/*
+ * Frees data allocated in the buffer.
+ */
+static int freeBuffer(SecBufferDesc * secBufferDesc)
+{
+    SecBuffer *buffer;
+    if (getSingleBufferDescriptor(secBufferDesc, &buffer)) {
+        return -1;
+    }
+
+    if (buffer->cbBuffer > 0 && buffer->pvBuffer) {
+        ne_free(buffer->pvBuffer);
+        buffer->cbBuffer = 0;
+        buffer->pvBuffer = NULL;
+    }
+
+    return 0;
+}
+
+/*
+ * Canonicalize a server host name if possible.
+ * The returned pointer must be freed after usage.
+ */
+static char *canonical_hostname(const char *serverName)
+{
+    const char *hostname;
+    ne_sock_addr *addr;
+    
+    addr = ne_addr_resolve(serverName, NE_ADDR_CANON);
+    if (ne_addr_result(addr) || ne_addr_canonical(addr) == NULL) {
+        /* Lookup failed */
+        char buf[256];
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: Could not resolve IP address for `%s': %s\n",
+                 serverName, ne_addr_error(addr, buf, sizeof buf));
+        hostname = ne_strdup(serverName);
+    }
+    else {
+        hostname = ne_strdup(ne_addr_canonical(addr));
+    }
+
+    ne_addr_destroy(addr);
+
+    return hostname;
+}
+
+/*
+ * Create a context to authenticate to specified server, using either
+ * ntlm or negotiate.
+ */
+int ne_sspi_create_context(void **context, char *serverName, int ntlm)
+{
+    SSPIContext *sspiContext;
+    char *canonicalName;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    sspiContext = ne_calloc(sizeof(SSPIContext));
+    sspiContext->continueNeeded = 0;
+
+    if (ntlm) {
+        sspiContext->mechanism = "NTLM";
+        sspiContext->serverName = ne_strdup(serverName);
+        sspiContext->maxTokenSize = ntlmMaxTokenSize;
+    } else {
+        sspiContext->mechanism = "Negotiate";
+        /* Canonicalize to conform to GSSAPI behavior */
+        canonicalName = canonical_hostname(serverName);
+        sspiContext->serverName = ne_concat("HTTP/", canonicalName, NULL);
+        ne_free(canonicalName);
+        NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Created context with SPN '%s'\n",
+                 sspiContext->serverName);
+        sspiContext->maxTokenSize = negotiateMaxTokenSize;
+    }
+
+    sspiContext->ntlm = ntlm;
+    sspiContext->authfinished = 0;
+    *context = sspiContext;
+    return 0;
+}
+
+/*
+ * Resets the context
+ */
+static void resetContext(SSPIContext * sspiContext)
+{
+    pSFT->DeleteSecurityContext(&(sspiContext->context));
+#if defined(_MSC_VER) && _MSC_VER <= 1200
+    pSFT->FreeCredentialHandle(&(sspiContext->credentials));
+#else
+    pSFT->FreeCredentialsHandle(&(sspiContext->credentials));
+#endif
+    sspiContext->continueNeeded = 0;
+}
+
+/*
+ * Initializes supplied SecBufferDesc to point to supplied SecBuffer
+ * that is also initialized;
+ */
+static void
+initSingleEmptyBuffer(SecBufferDesc * bufferDesc, SecBuffer * buffer)
+{
+    buffer->BufferType = SECBUFFER_EMPTY;
+    buffer->cbBuffer = 0;
+    buffer->pvBuffer = NULL;
+
+    bufferDesc->cBuffers = 1;
+    bufferDesc->ulVersion = SECBUFFER_VERSION;
+    bufferDesc->pBuffers = buffer;
+
+}
+
+/*
+ * Destroyes the supplied context.
+ */
+int ne_sspi_destroy_context(void *context)
+{
+
+    int status;
+    SSPIContext *sspiContext;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+
+    resetContext(sspiContext);
+    if (sspiContext->serverName) {
+        ne_free(sspiContext->serverName);
+        sspiContext->serverName = NULL;
+    }
+
+    ne_free(sspiContext);
+    return 0;
+}
+int ne_sspi_clear_context(void *context)
+{
+    int status;
+    SSPIContext *sspiContext;
+
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+    sspiContext->authfinished = 0;
+    sspiContext->continueNeeded = 0;
+    return 0;
+}
+/*
+ * Processes received authentication tokens as well as supplies the
+ * response token.
+ */
+int ne_sspi_authenticate(void *context, const char *base64Token, char **responseToken)
+{
+    SecBufferDesc outBufferDesc;
+    SecBuffer outBuffer;
+    int status;
+    SECURITY_STATUS securityStatus;
+    ULONG contextFlags;
+
+    SSPIContext *sspiContext;
+    if (initialized <= 0) {
+        return -1;
+    }
+
+    status = getContext(context, &sspiContext);
+    if (status) {
+        return status;
+    }
+
+    /* TODO: Not sure what flags should be set. joe: this needs to be
+     * driven by the ne_auth interface; the GSSAPI code needs similar
+     * flags. */
+    contextFlags = ISC_REQ_CONFIDENTIALITY | ISC_REQ_MUTUAL_AUTH;
+
+    initSingleEmptyBuffer(&outBufferDesc, &outBuffer);
+    status = makeBuffer(&outBufferDesc, sspiContext->maxTokenSize);
+    if (status) {
+        return status;
+    }
+
+    if (base64Token) {
+        SecBufferDesc inBufferDesc;
+        SecBuffer inBuffer;
+
+        if (!sspiContext->continueNeeded) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Got an unexpected token.\n");
+            return -1;
+        }
+
+        initSingleEmptyBuffer(&inBufferDesc, &inBuffer);
+
+        status = base64ToBuffer(base64Token, &inBufferDesc);
+        if (status) {
+            freeBuffer(&outBufferDesc);
+            return status;
+        }
+
+        securityStatus =
+            initializeSecurityContext(&sspiContext->credentials,
+                                      &(sspiContext->context),
+                                      sspiContext->serverName, contextFlags,
+                                      &inBufferDesc, &(sspiContext->context),
+                                      &outBufferDesc);
+        if (securityStatus == SEC_E_OK)
+        {
+            sspiContext->authfinished = 1;
+        }
+        freeBuffer(&inBufferDesc);
+    } else {
+        if (sspiContext->continueNeeded) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: Expected a token from server.\n");
+            return -1;
+        }
+        if (sspiContext->authfinished && (sspiContext->credentials.dwLower || sspiContext->credentials.dwUpper)) {
+            if (sspiContext->authfinished)
+            {
+                freeBuffer(&outBufferDesc);
+                sspiContext->authfinished = 0;
+                NE_DEBUG(NE_DBG_HTTPAUTH,"sspi: failing because starting over from failed try.\n");
+                return -1;
+            }
+            sspiContext->authfinished = 0;
+        }
+
+        /* Reset any existing context since we are starting over */
+        resetContext(sspiContext);
+
+        if (acquireCredentialsHandle
+            (&sspiContext->credentials, sspiContext->mechanism) != SEC_E_OK) {
+                freeBuffer(&outBufferDesc);
+                NE_DEBUG(NE_DBG_HTTPAUTH,
+                    "sspi: acquireCredentialsHandle failed.\n");
+                return -1;
+        }
+
+        securityStatus =
+            initializeSecurityContext(&sspiContext->credentials, NULL,
+                                      sspiContext->serverName, contextFlags,
+                                      NULL, &(sspiContext->context),
+                                      &outBufferDesc);
+    }
+
+    if (securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+        || securityStatus == SEC_I_COMPLETE_NEEDED) {
+        SECURITY_STATUS compleStatus =
+            pSFT->CompleteAuthToken(&(sspiContext->context), &outBufferDesc);
+
+        if (compleStatus != SEC_E_OK) {
+            freeBuffer(&outBufferDesc);
+            NE_DEBUG(NE_DBG_HTTPAUTH, "sspi: CompleteAuthToken failed.\n");
+            return -1;
+        }
+    }
+
+    if (securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+        || securityStatus == SEC_I_CONTINUE_NEEDED) {
+        sspiContext->continueNeeded = 1;
+    } else {
+        sspiContext->continueNeeded = 0;
+    }
+
+    if (!(securityStatus == SEC_I_COMPLETE_AND_CONTINUE
+          || securityStatus == SEC_I_COMPLETE_NEEDED
+          || securityStatus == SEC_I_CONTINUE_NEEDED
+          || securityStatus == SEC_E_OK)) {
+        NE_DEBUG(NE_DBG_HTTPAUTH,
+                 "sspi: initializeSecurityContext [failed] [%x].\n",
+                 securityStatus);
+        freeBuffer(&outBufferDesc);
+        return -1;
+    }
+
+    *responseToken = ne_base64(outBufferDesc.pBuffers->pvBuffer,
+                               outBufferDesc.pBuffers->cbBuffer);
+    freeBuffer(&outBufferDesc);
+
+    return 0;
+}
+#endif /* HAVE_SSPI */
diff --git a/net/mmt/neon/src/ne_sspi.h b/net/mmt/neon/src/ne_sspi.h
new file mode 100644
index 0000000..73f2b17
--- /dev/null
+++ b/net/mmt/neon/src/ne_sspi.h
@@ -0,0 +1,48 @@
+/* 
+   Microsoft SSPI based authentication routines
+   Copyright (C) 2004-2005, Vladimir Berezniker @ http://public.xdi.org/=vmpn
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_SSPI_H
+#define NE_SSPI_H
+
+/* Win32 SSPI-based authentication interfaces.  PRIVATE TO NEON -- NOT
+ * PART OF THE EXTERNAL API. */
+
+#ifdef HAVE_SSPI
+
+#include <windows.h>
+#define SECURITY_WIN32
+#include <security.h>
+
+int ne_sspi_init(void);
+int ne_sspi_deinit(void);
+
+int ne_sspi_create_context(void **context, char * serverName, int ntlm);
+
+int ne_sspi_destroy_context(void *context);
+
+int ne_sspi_clear_context(void *context);
+
+int ne_sspi_authenticate(void *context, const char *base64Token,
+                         char **responseToken);
+
+#endif /* HAVE_SSPI */
+
+#endif /* NE_SSPI_H */
diff --git a/net/mmt/neon/src/ne_string.c b/net/mmt/neon/src/ne_string.c
new file mode 100644
index 0000000..2d222f4
--- /dev/null
+++ b/net/mmt/neon/src/ne_string.c
@@ -0,0 +1,616 @@
+/* 
+   String utility functions
+   Copyright (C) 1999-2007, 2009, Joe Orton <joe@manyfish.co.uk>
+   strcasecmp/strncasecmp implementations are:
+   Copyright (C) 1991, 1992, 1995, 1996, 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+
+#include "ne_alloc.h"
+#include "ne_string.h"
+
+char *ne_token(char **str, char separator)
+{
+    char *ret = *str, *pnt = strchr(*str, separator);
+
+    if (pnt) {
+	*pnt = '\0';
+	*str = pnt + 1;
+    } else {
+	/* no separator found: return end of string. */
+	*str = NULL;
+    }
+    
+    return ret;
+}
+
+char *ne_qtoken(char **str, char separator, const char *quotes)
+{
+    char *pnt, *ret = NULL;
+
+    for (pnt = *str; *pnt != '\0'; pnt++) {
+	char *quot = strchr(quotes, *pnt);
+	
+	if (quot) {
+	    char *qclose = strchr(pnt+1, *quot);
+	    
+	    if (!qclose) {
+		/* no closing quote: invalid string. */
+		return NULL;
+	    }
+	    
+	    pnt = qclose;
+	} else if (*pnt == separator) {
+	    /* found end of token. */
+	    *pnt = '\0';
+	    ret = *str;
+	    *str = pnt + 1;
+	    return ret;
+	}
+    }
+
+    /* no separator found: return end of string. */
+    ret = *str;
+    *str = NULL;
+    return ret;
+}
+
+char *ne_shave(char *str, const char *whitespace)
+{
+    char *pnt, *ret = str;
+
+    while (*ret != '\0' && strchr(whitespace, *ret) != NULL) {
+	ret++;
+    }
+
+    /* pnt points at the NUL terminator. */
+    pnt = &ret[strlen(ret)];
+    
+    while (pnt > ret && strchr(whitespace, *(pnt-1)) != NULL) {
+	pnt--;
+    }
+
+    *pnt = '\0';
+    return ret;
+}
+
+void ne_buffer_clear(ne_buffer *buf) 
+{
+    memset(buf->data, 0, buf->length);
+    buf->used = 1;
+}  
+
+/* Grows for given size, returns 0 on success, -1 on error. */
+void ne_buffer_grow(ne_buffer *buf, size_t newsize) 
+{
+#define NE_BUFFER_GROWTH 512
+    if (newsize > buf->length) {
+	/* If it's not big enough already... */
+	buf->length = ((newsize / NE_BUFFER_GROWTH) + 1) * NE_BUFFER_GROWTH;
+	
+	/* Reallocate bigger buffer */
+	buf->data = ne_realloc(buf->data, buf->length);
+    }
+}
+
+static size_t count_concat(va_list *ap)
+{
+    size_t total = 0;
+    char *next;
+
+    while ((next = va_arg(*ap, char *)) != NULL)
+	total += strlen(next);
+
+    return total;
+}
+
+static void do_concat(char *str, va_list *ap) 
+{
+    char *next;
+
+    while ((next = va_arg(*ap, char *)) != NULL) {
+#ifdef HAVE_STPCPY
+        str = stpcpy(str, next);
+#else
+	size_t len = strlen(next);
+	memcpy(str, next, len);
+	str += len;
+#endif
+    }
+}
+
+void ne_buffer_concat(ne_buffer *buf, ...)
+{
+    va_list ap;
+    ssize_t total;
+
+    va_start(ap, buf);
+    total = buf->used + count_concat(&ap);
+    va_end(ap);    
+
+    /* Grow the buffer */
+    ne_buffer_grow(buf, total);
+    
+    va_start(ap, buf);    
+    do_concat(buf->data + buf->used - 1, &ap);
+    va_end(ap);    
+
+    buf->used = total;
+    buf->data[total - 1] = '\0';
+}
+
+char *ne_concat(const char *str, ...)
+{
+    va_list ap;
+    size_t total, slen = strlen(str);
+    char *ret;
+
+    va_start(ap, str);
+    total = slen + count_concat(&ap);
+    va_end(ap);
+
+    ret = memcpy(ne_malloc(total + 1), str, slen);
+
+    va_start(ap, str);
+    do_concat(ret + slen, &ap);
+    va_end(ap);
+
+    ret[total] = '\0';
+    return ret;    
+}
+
+/* Append zero-terminated string... returns 0 on success or -1 on
+ * realloc failure. */
+void ne_buffer_zappend(ne_buffer *buf, const char *str) 
+{
+    ne_buffer_append(buf, str, strlen(str));
+}
+
+void ne_buffer_append(ne_buffer *buf, const char *data, size_t len) 
+{
+    ne_buffer_grow(buf, buf->used + len);
+    memcpy(buf->data + buf->used - 1, data, len);
+    buf->used += len;
+    buf->data[buf->used - 1] = '\0';
+}
+
+size_t ne_buffer_snprintf(ne_buffer *buf, size_t max, const char *fmt, ...)
+{
+    va_list ap;
+    size_t ret;
+
+    ne_buffer_grow(buf, buf->used + max);
+
+    va_start(ap, fmt);
+    ret = ne_vsnprintf(buf->data + buf->used - 1, max, fmt, ap);
+    va_end(ap);
+    buf->used += ret;
+
+    return ret;    
+}
+
+ne_buffer *ne_buffer_create(void) 
+{
+    return ne_buffer_ncreate(512);
+}
+
+ne_buffer *ne_buffer_ncreate(size_t s) 
+{
+    ne_buffer *buf = ne_malloc(sizeof(*buf));
+    buf->data = ne_malloc(s);
+    buf->data[0] = '\0';
+    buf->length = s;
+    buf->used = 1;
+    return buf;
+}
+
+void ne_buffer_destroy(ne_buffer *buf) 
+{
+    ne_free(buf->data);
+    ne_free(buf);
+}
+
+char *ne_buffer_finish(ne_buffer *buf)
+{
+    char *ret = buf->data;
+    ne_free(buf);
+    return ret;
+}
+
+void ne_buffer_altered(ne_buffer *buf)
+{
+    buf->used = strlen(buf->data) + 1;
+}
+
+
+/* ascii_quote[n] gives the number of bytes needed by
+ * ne_buffer_qappend() to append character 'n'. */
+static const unsigned char ascii_quote[256] = {
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
+};
+
+static const char hex_chars[16] = "0123456789ABCDEF";
+
+/* Return the expected number of bytes needed to append the string
+ * beginning at byte 's', where 'send' points to the last byte after
+ * 's'. */ 
+static size_t qappend_count(const unsigned char *s, const unsigned char *send)
+{
+    const unsigned char *p;
+    size_t ret;
+    
+    for (p = s, ret = 0; p < send; p++) {
+        ret += ascii_quote[*p];
+    }
+
+    return ret;
+}       
+
+/* Append the string 's', up to but not including 'send', to string
+ * 'dest', quoting along the way.  Returns pointer to NUL. */
+static char *quoted_append(char *dest, const unsigned char *s, 
+                           const unsigned char *send)
+{
+    const unsigned char *p;
+    char *q = dest;
+
+    for (p = s; p < send; p++) {
+        if (ascii_quote[*p] == 1) {
+            *q++ = *p;
+        }
+        else {
+            *q++ = '\\';
+            *q++ = 'x';
+            *q++ = hex_chars[(*p >> 4) & 0x0f];
+            *q++ = hex_chars[*p & 0x0f];
+        }
+    }
+
+    /* NUL terminate after the last character */
+    *q = '\0';
+    
+    return q;
+}
+
+void ne_buffer_qappend(ne_buffer *buf, const unsigned char *data, size_t len)
+{
+    const unsigned char *dend = data + len;
+    char *q, *qs;
+
+    ne_buffer_grow(buf, buf->used + qappend_count(data, dend));
+
+    /* buf->used >= 1, so this is safe. */
+    qs = buf->data + buf->used - 1;
+
+    q = quoted_append(qs, data, dend);
+    
+    /* used already accounts for a NUL, so increment by number of
+     * characters appended, *before* the NUL. */
+    buf->used += q - qs;
+}
+
+char *ne_strnqdup(const unsigned char *data, size_t len)
+{
+    const unsigned char *dend = data + len;
+    char *dest = malloc(qappend_count(data, dend) + 1);
+
+    quoted_append(dest, data, dend);
+
+    return dest;
+}
+
+static const char b64_alphabet[] =  
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+    "abcdefghijklmnopqrstuvwxyz"
+    "0123456789+/=";
+    
+char *ne_base64(const unsigned char *text, size_t inlen)
+{
+    /* The tricky thing about this is doing the padding at the end,
+     * doing the bit manipulation requires a bit of concentration only */
+    char *buffer, *point;
+    size_t outlen;
+    
+    /* Use 'buffer' to store the output. Work out how big it should be...
+     * This must be a multiple of 4 bytes */
+
+    outlen = (inlen*4)/3;
+    if ((inlen % 3) > 0) /* got to pad */
+	outlen += 4 - (inlen % 3);
+    
+    buffer = ne_malloc(outlen + 1); /* +1 for the \0 */
+    
+    /* now do the main stage of conversion, 3 bytes at a time,
+     * leave the trailing bytes (if there are any) for later */
+
+    for (point=buffer; inlen>=3; inlen-=3, text+=3) {
+	*(point++) = b64_alphabet[ (*text)>>2 ]; 
+	*(point++) = b64_alphabet[ ((*text)<<4 & 0x30) | (*(text+1))>>4 ]; 
+	*(point++) = b64_alphabet[ ((*(text+1))<<2 & 0x3c) | (*(text+2))>>6 ];
+	*(point++) = b64_alphabet[ (*(text+2)) & 0x3f ];
+    }
+
+    /* Now deal with the trailing bytes */
+    if (inlen > 0) {
+	/* We always have one trailing byte */
+	*(point++) = b64_alphabet[ (*text)>>2 ];
+	*(point++) = b64_alphabet[ (((*text)<<4 & 0x30) |
+				     (inlen==2?(*(text+1))>>4:0)) ]; 
+	*(point++) = (inlen==1?'=':b64_alphabet[ (*(text+1))<<2 & 0x3c ]);
+	*(point++) = '=';
+    }
+
+    /* Null-terminate */
+    *point = '\0';
+
+    return buffer;
+}
+
+/* VALID_B64: fail if 'ch' is not a valid base64 character */
+#define VALID_B64(ch) (((ch) >= 'A' && (ch) <= 'Z') || \
+                       ((ch) >= 'a' && (ch) <= 'z') || \
+                       ((ch) >= '0' && (ch) <= '9') || \
+                       (ch) == '/' || (ch) == '+' || (ch) == '=')
+
+/* DECODE_B64: decodes a valid base64 character. */
+#define DECODE_B64(ch) ((ch) >= 'a' ? ((ch) + 26 - 'a') : \
+                        ((ch) >= 'A' ? ((ch) - 'A') : \
+                         ((ch) >= '0' ? ((ch) + 52 - '0') : \
+                          ((ch) == '+' ? 62 : 63))))
+
+size_t ne_unbase64(const char *data, unsigned char **out)
+{
+    size_t inlen = strlen(data);
+    unsigned char *outp;
+    const unsigned char *in;
+
+    if (inlen == 0 || (inlen % 4) != 0) return 0;
+    
+    outp = *out = ne_malloc(inlen * 3 / 4);
+
+    for (in = (const unsigned char *)data; *in; in += 4) {
+        unsigned int tmp;
+        if (!VALID_B64(in[0]) || !VALID_B64(in[1]) || !VALID_B64(in[2]) ||
+            !VALID_B64(in[3]) || in[0] == '=' || in[1] == '=' ||
+            (in[2] == '=' && in[3] != '=')) {
+            ne_free(*out);
+            return 0;
+        }
+        tmp = (DECODE_B64(in[0]) & 0x3f) << 18 |
+            (DECODE_B64(in[1]) & 0x3f) << 12;
+        *outp++ = (tmp >> 16) & 0xff;
+        if (in[2] != '=') {
+            tmp |= (DECODE_B64(in[2]) & 0x3f) << 6;
+            *outp++ = (tmp >> 8) & 0xff;
+            if (in[3] != '=') {
+                tmp |= DECODE_B64(in[3]) & 0x3f;
+                *outp++ = tmp & 0xff;
+            }
+        }
+    }
+
+    return outp - *out;
+}
+
+/* Character map array; ascii_clean[n] = isprint(n) ? n : 0x20.  Used
+ * by ne_strclean as a locale-independent isprint(). */
+static const unsigned char ascii_clean[256] = {
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 
+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 
+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 
+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
+    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 
+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 
+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 
+    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 
+    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 
+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 
+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 
+    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
+};
+
+char *ne_strclean(char *str)
+{
+    unsigned char *pnt;
+
+    for (pnt = (unsigned char *)str; *pnt; pnt++)
+        *pnt = (char)ascii_clean[*pnt];
+
+    return str;
+}
+
+char *ne_strerror(int errnum, char *buf, size_t buflen)
+{
+#ifdef HAVE_STRERROR_R
+#ifdef STRERROR_R_CHAR_P
+    /* glibc-style strerror_r which may-or-may-not use provided buffer. */
+    char *ret = strerror_r(errnum, buf, buflen);
+    if (ret != buf)
+	ne_strnzcpy(buf, ret, buflen);
+#else /* POSIX-style strerror_r: */
+    char tmp[256];
+
+    if (strerror_r(errnum, tmp, sizeof tmp) == 0)
+        ne_strnzcpy(buf, tmp, buflen);
+    else
+        ne_snprintf(buf, buflen, "Unknown error %d", errnum);
+#endif
+#else /* no strerror_r: */
+    ne_strnzcpy(buf, strerror(errnum), buflen);
+#endif
+    return buf;
+}
+
+
+/* Wrapper for ne_snprintf. */
+size_t ne_snprintf(char *str, size_t size, const char *fmt, ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+#ifdef HAVE_TRIO
+    trio_vsnprintf(str, size, fmt, ap);
+#else
+    vsnprintf(str, size, fmt, ap);
+#endif
+    va_end(ap);
+    str[size-1] = '\0';
+    return strlen(str);
+}
+
+/* Wrapper for ne_vsnprintf. */
+size_t ne_vsnprintf(char *str, size_t size, const char *fmt, va_list ap)
+{
+#ifdef HAVE_TRIO
+    trio_vsnprintf(str, size, fmt, ap);
+#else
+    vsnprintf(str, size, fmt, ap);
+#endif
+    str[size-1] = '\0';
+    return strlen(str);
+}
+
+/* Locale-independent strcasecmp implementations. */
+static const unsigned char ascii_tolower[256] = {
+0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
+0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
+0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
+0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
+0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
+0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
+0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
+0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
+0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
+};    
+
+#define TOLOWER(ch) ascii_tolower[ch]
+
+const unsigned char *ne_tolower_array(void)
+{
+    return ascii_tolower;
+}
+
+int ne_strcasecmp(const char *s1, const char *s2)
+{
+    const unsigned char *p1 = (const unsigned char *) s1;
+    const unsigned char *p2 = (const unsigned char *) s2;
+    unsigned char c1, c2;
+
+    if (p1 == p2)
+        return 0;
+    
+    do {
+        c1 = TOLOWER(*p1++);
+        c2 = TOLOWER(*p2++);
+        if (c1 == '\0')
+            break;
+    } while (c1 == c2);
+    
+    return c1 - c2;
+}
+
+int ne_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    const unsigned char *p1 = (const unsigned char *) s1;
+    const unsigned char *p2 = (const unsigned char *) s2;
+    unsigned char c1, c2;
+    
+    if (p1 == p2 || n == 0)
+        return 0;
+    
+    do {
+        c1 = TOLOWER(*p1++);
+        c2 = TOLOWER(*p2++);
+        if (c1 == '\0' || c1 != c2)
+            return c1 - c2;
+    } while (--n > 0);
+    
+    return c1 - c2;
+}
diff --git a/net/mmt/neon/src/ne_string.h b/net/mmt/neon/src/ne_string.h
new file mode 100644
index 0000000..b48cf3e
--- /dev/null
+++ b/net/mmt/neon/src/ne_string.h
@@ -0,0 +1,189 @@
+/* 
+   String utility functions
+   Copyright (C) 1999-2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_STRING_H
+#define NE_STRING_H
+
+#include "ne_defs.h"
+#include "ne_alloc.h"
+
+#include <stdarg.h>
+
+NE_BEGIN_DECLS
+
+/* ne_token and ne_qtoken return the next token in *str before either
+ * the next separator character 'sep' or the NUL terminator.
+ * ne_qtoken skips over any parts quoted using a pair of any one of
+ * the characters given in 'quotes'.  After returning, *str will point
+ * to the next character after the separator, or NULL if no separator
+ * character was found.
+ * 
+ * ne_qtoken will return NULL if unterminated quotes are found. */
+char *ne_token(char **str, char sep);
+char *ne_qtoken(char **str, char sep, const char *quotes);
+
+/* Return portion of 'str' with any characters in 'whitespace' shaved
+ * off the beginning and end.  Modifies str in-place. */
+char *ne_shave(char *str, const char *whitespace);
+
+/* Cleanse 'str' of non-printable (e.g. control) characters.  'str' is
+ * modified in-place, and returned. */
+char *ne_strclean(char *str);
+
+/* Encode 'len' bytes of 'text' to base64.  Returns malloc-allocated
+ * NUL-terminated buffer which the caller must free(). */
+char *ne_base64(const unsigned char *text, size_t len);
+
+/* Decode NUL-terminated base64-encoded string 'data', placing
+ * malloc-allocated raw decoder output in '*out'.  Returns length, or
+ * zero on decode error (in which case the content of *out is
+ * undefined). */
+size_t ne_unbase64(const char *data, unsigned char **out);
+
+/* Dynamically-allocated string buffer.  A string buffer which grows
+ * dynamically . (Strings are zero-terminated still).  A
+ * string buffer ne_buffer which grows dynamically with the string. */
+typedef struct {
+    char *data; /* contents: NUL-terminated string */
+    size_t used; /* strlen(data) + 1 */
+    size_t length; /* number of bytes allocated */
+} ne_buffer;
+
+/* Create a new string buffer object. */
+ne_buffer *ne_buffer_create(void);
+
+/* Create a new string buffer object with at least 'size' bytes of
+ * allocated space. */
+ne_buffer *ne_buffer_ncreate(size_t size);
+
+/* Returns size of data in buffer, equiv to strlen(ne_buffer_data(buf)) */
+#define ne_buffer_size(buf) ((buf)->used - 1)
+
+/* Concatenate all given strings onto the end of the buffer.  The
+ * strings must all be NUL-terminated, and MUST be followed by a NULL
+ * argument marking the end of the list.  */
+void ne_buffer_concat(ne_buffer *buf, ...)
+    ne_attribute_sentinel;
+
+/* Append a NUL-terminated string 'str' to buf. */
+void ne_buffer_zappend(ne_buffer *buf, const char *str);
+
+/* Append 'len' bytes of 'data' to buf, where 'data' does not contain
+ * a NUL terminator.  (A NUL terminator is appended to buf) */
+void ne_buffer_append(ne_buffer *buf, const char *data, size_t len);
+
+/* Append 'len' bytes of 'data' to buf.  All non-ASCII bytes, and
+ * ASCII control characters, are escaped.  (Note that this includes
+ * the NUL byte). */
+void ne_buffer_qappend(ne_buffer *buf, const unsigned char *data, size_t len);
+
+/* Print a string to the end of the buffer using printf-style format
+ * string 'format' and subsqeuent arguments.  At most 'max' characters
+ * are appended; the number of characters appended (excluding the NUL
+ * terminator) is returned.  Behaviour is undefined if 'max' is passed
+ * as zero. */
+size_t ne_buffer_snprintf(ne_buffer *buf, size_t max, 
+                          const char *format, ...)
+    ne_attribute((format(printf, 3, 4)));
+
+/* Append a literal, NUL-terminated constant string 'str' to buffer
+ * 'buf'. */
+#define ne_buffer_czappend(buf, str) \
+ne_buffer_append((buf), (str), sizeof((str)) - 1)
+
+/* Clear the string buffer 'buf', making it equivalent to the empty
+ * string. */
+void ne_buffer_clear(ne_buffer *buf);
+
+/* Grow the allocated size of string buffer 'buf' to at least 'size'
+ * bytes. */
+void ne_buffer_grow(ne_buffer *buf, size_t size);
+
+/* Re-establish the 'used' invariant if the string buffer data field is
+ * altered directly. */
+void ne_buffer_altered(ne_buffer *buf);
+
+/* Destroy the string buffer object 'buf' without deallocating the
+ * data string.  The data string must subsequently be freed using
+ * ne_free(). */
+char *ne_buffer_finish(ne_buffer *buf);
+
+/* Destroy a string buffer object. */
+void ne_buffer_destroy(ne_buffer *buf);
+
+/* Thread-safe strerror() wrapper; place system error for errno value
+ * 'errnum' in 'buffer', which is of length 'buflen'.  Returns
+ * 'buffer'. */
+char *ne_strerror(int errnum, char *buffer, size_t buflen);
+
+/* ne_strnzcpy copies at most 'n'-1 bytes of 'src' to 'dest', and
+ * ensures that 'dest' is subsequently NUL-terminated. */
+#define ne_strnzcpy(dest, src, n) do { size_t ne__nm1 = (n) - 1;      \
+strncpy(dest, src, ne__nm1); dest[ne__nm1] = '\0'; } while (0)
+
+/* Return a malloc-allocated copy of 'data', of length 'len', with all
+ * non-ASCII bytes, and ASCII control characters escaped.  (Note that
+ * the escaping includes the NUL byte). */
+char *ne_strnqdup(const unsigned char *data, size_t len);
+
+/* Return malloc-allocated concatenation of all NUL-terminated string
+ * arguments, up to a terminating NULL pointer. */
+char *ne_concat(const char *str, ...)
+    ne_attribute_sentinel;
+
+/* Wrapper for snprintf: always NUL-terminates returned buffer, and
+ * returns strlen(str). */
+size_t ne_snprintf(char *str, size_t size, const char *fmt, ...)
+    ne_attribute((format(printf, 3, 4)));
+
+/* Wrapper for vsnprintf. */
+size_t ne_vsnprintf(char *str, size_t size, const char *fmt, va_list ap)
+    ne_attribute((format(printf, 3, 0)));
+
+/* Implementations of strcasecmp and strncasecmp which behave as
+ * defined by the ANSI C strcasecmp() and strncasecmp() when in the
+ * POSIX locale; i.e. ignoring the process locale. */
+
+/* Compares 's1' and 's2', ignoring differences in case. */
+int ne_strcasecmp(const char *s1, const char *s2);
+/* Compares up to 'n' characters of 's1' and 's2', ignoring
+ * differences in case. */
+int ne_strncasecmp(const char *s1, const char *s2, size_t n);
+
+/* Return lowercase 'c' as in POSIX locale; note difference from ANSI
+ * C semantics as both the argument and return value are unsigned
+ * char. */
+#define ne_tolower(c) (ne_tolower_array()[(unsigned char)c])
+
+const unsigned char *ne_tolower_array(void);
+
+/* Convert an ASCII hexadecimal character in the ranges '0'..'9'
+ * 'a'..'f' 'A'..'F' to its numeric equivalent. */
+#define NE_ASC2HEX(x) (((x) <= '9') ? ((x) - '0') : \
+                       (ne_tolower((x)) + 10 - 'a'))
+
+/* Convert an integer in the range 0..15 to the equivalent (lowercase)
+ * ASCII hexadecimal equivalent character, in the range '0..9,'a..f' */
+#define NE_HEX2ASC(x) ((char) ((x) > 9 ? ((x) - 10 + 'a') : ((x) + '0')))
+
+NE_END_DECLS
+
+#endif /* NE_STRING_H */
diff --git a/net/mmt/neon/src/ne_stubssl.c b/net/mmt/neon/src/ne_stubssl.c
new file mode 100644
index 0000000..77f9055
--- /dev/null
+++ b/net/mmt/neon/src/ne_stubssl.c
@@ -0,0 +1,145 @@
+/* 
+   Stubs for SSL support when no SSL library has been configured
+   Copyright (C) 2002-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <stdlib.h> /* for NULL */
+
+#include "ne_ssl.h"
+#include "ne_session.h"
+
+char *ne_ssl_readable_dname(const ne_ssl_dname *dn)
+{
+    return NULL;
+}
+
+ne_ssl_certificate *ne_ssl_cert_read(const char *filename)
+{
+    return NULL;
+}
+
+int ne_ssl_cert_cmp(const ne_ssl_certificate *c1, const ne_ssl_certificate *c2)
+{
+    return 1;
+}
+
+const ne_ssl_certificate *ne_ssl_cert_signedby(const ne_ssl_certificate *cert)
+{ 
+    return NULL;
+}
+
+const ne_ssl_dname *ne_ssl_cert_issuer(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+const ne_ssl_dname *ne_ssl_cert_subject(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+void ne_ssl_cert_free(ne_ssl_certificate *cert) {}
+
+ne_ssl_client_cert *ne_ssl_clicert_read(const char *filename)
+{
+    return NULL;
+}
+
+const ne_ssl_certificate *ne_ssl_clicert_owner(const ne_ssl_client_cert *ccert)
+{
+    return NULL;
+}
+
+int ne_ssl_clicert_encrypted(const ne_ssl_client_cert *ccert)
+{
+    return -1;
+}
+
+int ne_ssl_clicert_decrypt(ne_ssl_client_cert *ccert, const char *password)
+{
+    return -1;
+}
+
+void ne_ssl_clicert_free(ne_ssl_client_cert *ccert) {}
+
+void ne_ssl_trust_default_ca(ne_session *sess) {}
+
+ne_ssl_context *ne_ssl_context_create(int mode)
+{
+    return NULL;
+}
+
+void ne_ssl_context_trustcert(ne_ssl_context *ctx, const ne_ssl_certificate *cert)
+{}
+
+int ne_ssl_context_set_verify(ne_ssl_context *ctx, 
+                              int required,
+                              const char *ca_names,
+                              const char *verify_cas)
+{
+    return -1;
+}
+
+void ne_ssl_context_set_flag(ne_ssl_context *ctx, int flag, int value) {}
+
+void ne_ssl_context_destroy(ne_ssl_context *ctx) {}
+
+int ne_ssl_cert_digest(const ne_ssl_certificate *cert, char digest[60])
+{
+    return -1;
+}
+
+void ne_ssl_cert_validity_time(const ne_ssl_certificate *cert,
+                               time_t *from, time_t *until) {}
+
+const char *ne_ssl_cert_identity(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+
+const char *ne_ssl_clicert_name(const ne_ssl_client_cert *ccert)
+{
+    return NULL;
+}
+
+int ne_ssl_dname_cmp(const ne_ssl_dname *dn1, const ne_ssl_dname *dn2)
+{
+    return -1;
+}
+
+int ne_ssl_cert_write(const ne_ssl_certificate *cert, const char *filename)
+{
+    return -1;
+}
+
+char *ne_ssl_cert_export(const ne_ssl_certificate *cert)
+{
+    return NULL;
+}
+
+ne_ssl_certificate *ne_ssl_cert_import(const char *data)
+{
+    return NULL;
+}
+
+void ne_ssl_set_clicert(ne_session *sess, const ne_ssl_client_cert *cc) 
+{}
diff --git a/net/mmt/neon/src/ne_uri.c b/net/mmt/neon/src/ne_uri.c
new file mode 100644
index 0000000..4d0ab91
--- /dev/null
+++ b/net/mmt/neon/src/ne_uri.c
@@ -0,0 +1,617 @@
+/* 
+   URI manipulation routines.
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#include <stdio.h>
+
+#include <ctype.h>
+
+#include "ne_string.h" /* for ne_buffer */
+#include "ne_alloc.h"
+#include "ne_uri.h"
+
+/* URI ABNF from RFC 3986: */
+
+#define PS (0x0001) /* "+" */
+#define PC (0x0002) /* "%" */
+#define DS (0x0004) /* "-" */
+#define DT (0x0008) /* "." */
+#define US (0x0010) /* "_" */
+#define TD (0x0020) /* "~" */
+#define FS (0x0040) /* "/" */
+#define CL (0x0080) /* ":" */
+#define AT (0x0100) /* "@" */
+#define QU (0x0200) /* "?" */
+
+#define DG (0x0400) /* DIGIT */
+#define AL (0x0800) /* ALPHA */
+
+#define GD (0x1000) /* gen-delims    = "#" / "[" / "]" 
+                     * ... except ":", "/", "@", and "?" */
+
+#define SD (0x2000) /* sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+                     *               / "*" / "+" / "," / ";" / "=" 
+                     * ... except "+" which is PS */
+
+#define OT (0x4000) /* others */
+
+#define URI_ALPHA (AL)
+#define URI_DIGIT (DG)
+
+/* unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~" */
+#define URI_UNRESERVED (AL | DG | DS | DT | US | TD)
+/* scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." ) */
+#define URI_SCHEME (AL | DG | PS | DS | DT)
+/* real sub-delims definition, including "+" */
+#define URI_SUBDELIM (PS | SD)
+/* real gen-delims definition, including ":", "/", "@" and "?" */
+#define URI_GENDELIM (GD | CL | FS | AT | QU)
+/* userinfo = *( unreserved / pct-encoded / sub-delims / ":" ) */
+#define URI_USERINFO (URI_UNRESERVED | PC | URI_SUBDELIM | CL)
+/* pchar = unreserved / pct-encoded / sub-delims / ":" / "@" */
+#define URI_PCHAR (URI_UNRESERVED | PC | URI_SUBDELIM | CL | AT)
+/* invented: segchar = pchar / "/" */
+#define URI_SEGCHAR (URI_PCHAR | FS)
+/* query = *( pchar / "/" / "?" ) */
+#define URI_QUERY (URI_PCHAR | FS | QU)
+/* fragment == query */
+#define URI_FRAGMENT URI_QUERY
+
+/* any characters which should be path-escaped: */
+#define URI_ESCAPE ((URI_GENDELIM & ~(FS)) | URI_SUBDELIM | OT | PC)
+
+static const unsigned int uri_chars[256] = {
+/* 0xXX    x0      x2      x4      x6      x8      xA      xC      xE     */
+/*   0x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT,
+/*   1x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT,
+/*   2x */ OT, SD, OT, GD, SD, PC, SD, SD, SD, SD, SD, PS, SD, DS, DT, FS,
+/*   3x */ DG, DG, DG, DG, DG, DG, DG, DG, DG, DG, CL, SD, OT, SD, OT, QU,
+/*   4x */ AT, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+/*   5x */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, GD, OT, GD, OT, US,
+/*   6x */ OT, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL,
+/*   7x */ AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, AL, OT, OT, OT, TD, OT,
+/*   8x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   9x */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Ax */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Bx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Cx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Dx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Ex */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, 
+/*   Fx */ OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT, OT
+};
+
+#define uri_lookup(ch) (uri_chars[(unsigned char)ch])
+
+char *ne_path_parent(const char *uri) 
+{
+    size_t len = strlen(uri);
+    const char *pnt = uri + len - 1;
+    /* skip trailing slash (parent of "/foo/" is "/") */
+    if (pnt >= uri && *pnt == '/')
+	pnt--;
+    /* find previous slash */
+    while (pnt > uri && *pnt != '/')
+	pnt--;
+    if (pnt < uri || (pnt == uri && *pnt != '/'))
+	return NULL;
+    return ne_strndup(uri, pnt - uri + 1);
+}
+
+int ne_path_has_trailing_slash(const char *uri) 
+{
+    size_t len = strlen(uri);
+    return ((len > 0) &&
+	    (uri[len-1] == '/'));
+}
+
+unsigned int ne_uri_defaultport(const char *scheme)
+{
+    /* RFC2616/3.2.3 says use case-insensitive comparisons here. */
+    if (ne_strcasecmp(scheme, "http") == 0)
+	return 80;
+    else if (ne_strcasecmp(scheme, "https") == 0)
+	return 443;
+    else
+	return 0;
+}
+
+int ne_uri_parse(const char *uri, ne_uri *parsed)
+{
+    const char *p, *s;
+
+    memset(parsed, 0, sizeof *parsed);
+
+    p = s = uri;
+
+    /* => s = p = URI-reference */
+
+    if (uri_lookup(*p) & URI_ALPHA) {
+        while (uri_lookup(*p) & URI_SCHEME)
+            p++;
+        
+        if (*p == ':') {
+            parsed->scheme = ne_strndup(uri, p - s);
+            s = p + 1;
+        }
+    }
+
+    /* => s = heir-part, or s = relative-part */
+
+    if (s[0] == '/' && s[1] == '/') {
+        const char *pa;
+
+        /* => s = "//" authority path-abempty (from expansion of
+         * either heir-part of relative-part)  */
+        
+        /* authority = [ userinfo "@" ] host [ ":" port ] */
+
+        s = pa = s + 2; /* => s = authority */
+
+        while (*pa != '/' && *pa != '\0')
+            pa++;
+        /* => pa = path-abempty */
+        
+        p = s;
+        while (p < pa && uri_lookup(*p) & URI_USERINFO)
+            p++;
+
+        if (*p == '@') {
+            parsed->userinfo = ne_strndup(s, p - s);
+            s = p + 1;
+        }
+        /* => s = host */
+
+        if (s[0] == '[') {
+            p = s + 1;
+
+            while (*p != ']' && p < pa)
+                p++;
+
+            if (p == pa || (p + 1 != pa && p[1] != ':')) {
+                /* Ill-formed IP-literal. */
+                return -1;
+            }
+
+            p++; /* => p = colon */
+        } else {
+            /* Find the colon. */
+            p = pa;
+            while (*p != ':' && p > s)
+                p--;
+        }
+
+        if (p == s) {
+            p = pa;
+            /* No colon; => p = path-abempty */
+        } else if (p + 1 != pa) {
+            /* => p = colon */
+            parsed->port = atoi(p + 1);
+        }
+        parsed->host = ne_strndup(s, p - s);
+        
+        s = pa;        
+
+        if (*s == '\0') {
+            s = "/"; /* FIXME: scheme-specific. */
+        }
+    }
+
+    /* => s = path-abempty / path-absolute / path-rootless
+     *      / path-empty / path-noscheme */
+
+    p = s;
+
+    while (uri_lookup(*p) & URI_SEGCHAR)
+        p++;
+
+    /* => p = [ "?" query ] [ "#" fragment ] */
+
+    parsed->path = ne_strndup(s, p - s);
+
+    if (*p != '\0') {
+        s = p++;
+
+        while (uri_lookup(*p) & URI_QUERY)
+            p++;
+
+        /* => p = [ "#" fragment ] */
+        /* => s = [ "?" query ] [ "#" fragment ] */
+
+        if (*s == '?') {
+            parsed->query = ne_strndup(s + 1, p - s - 1);
+            
+            if (*p != '\0') {
+                s = p++;
+
+                while (uri_lookup(*p) & URI_FRAGMENT)
+                    p++;
+            }
+        }
+
+        /* => p now points to the next character after the
+         * URI-reference; which should be the NUL byte. */
+
+        if (*s == '#') {
+            parsed->fragment = ne_strndup(s + 1, p - s - 1);
+        }
+        else if (*p || *s != '?') {
+            return -1;
+        }
+    }
+    
+    return 0;
+}
+
+/* This function directly implements the "Merge Paths" algorithm
+ * described in RFC 3986 section 5.2.3. */
+static char *merge_paths(const ne_uri *base, const char *path)
+{
+    const char *p;
+
+    if (base->host && base->path[0] == '\0') {
+        return ne_concat("/", path, NULL);
+    }
+    
+    p = strrchr(base->path, '/');
+    if (p == NULL) {
+        return ne_strdup(path);
+    } else {
+        size_t len = p - base->path + 1;
+        char *ret = ne_malloc(strlen(path) + len + 1);
+
+        memcpy(ret, base->path, len);
+        memcpy(ret + len, path, strlen(path) + 1);
+        return ret;
+    }
+}
+
+/* This function directly implements the "Remove Dot Segments"
+ * algorithm described in RFC 3986 section 5.2.4. */
+static char *remove_dot_segments(const char *path)
+{
+    char *in, *inc, *out;
+
+    inc = in = ne_strdup(path);
+    out = ne_malloc(strlen(path) + 1);
+    out[0] = '\0';
+
+    while (in[0]) {
+        /* case 2.A: */
+        if (strncmp(in, "./", 2) == 0) {
+            in += 2;
+        } 
+        else if (strncmp(in, "../", 3) == 0) {
+            in += 3;
+        }
+
+        /* case 2.B: */
+        else if (strncmp(in, "/./", 3) == 0) {
+            in += 2;
+        }
+        else if (strcmp(in, "/.") == 0) {
+            in[1] = '\0';
+        }
+
+        /* case 2.C: */
+        else if (strncmp(in, "/../", 4) == 0 || strcmp(in, "/..") == 0) {
+            char *p;
+
+            /* Make the next character in the input buffer a "/": */
+            if (in[3] == '\0') {
+                /* terminating "/.." case */
+                in += 2;
+                in[0] = '/';
+            } else {
+                /* "/../" prefix case */
+                in += 3;
+            }
+
+            /* Trim the last component from the output buffer, or
+             * empty it. */
+            p = strrchr(out, '/');
+            if (p) {
+                *p = '\0';
+            } else {
+                out[0] = '\0';
+            }
+        }
+
+        /* case 2.D: */
+        else if (strcmp(in, ".") == 0 || strcmp(in, "..") == 0) {
+            in[0] = '\0';
+        }
+
+        /* case 2.E */
+        else {
+            char *p;
+
+            /* Search for the *second* "/" if the leading character is
+             * already "/": */
+            p = strchr(in + (in[0] == '/'), '/');
+            /* Otherwise, copy the whole string */
+            if (p == NULL) p = strchr(in, '\0');
+
+            strncat(out, in, p - in);
+            in = p;
+        }
+    }
+
+    ne_free(inc);
+
+    return out;
+}
+
+/* Copy authority components from 'src' to 'dest' if defined. */
+static void copy_authority(ne_uri *dest, const ne_uri *src)
+{
+    if (src->host) dest->host = ne_strdup(src->host);
+    dest->port = src->port;
+    if (src->userinfo) dest->userinfo = ne_strdup(src->userinfo);
+}
+
+/* This function directly implements the "Transform References"
+ * algorithm described in RFC 3986 section 5.2.2. */
+ne_uri *ne_uri_resolve(const ne_uri *base, const ne_uri *relative,
+                       ne_uri *target)
+{
+    memset(target, 0, sizeof *target);
+
+    if (relative->scheme) {
+        target->scheme = ne_strdup(relative->scheme);
+        copy_authority(target, relative);
+        target->path = remove_dot_segments(relative->path);
+        if (relative->query) target->query = ne_strdup(relative->query);
+    } else {
+        if (relative->host) {
+            copy_authority(target, relative);
+            target->path = remove_dot_segments(relative->path);
+            if (relative->query) target->query = ne_strdup(relative->query);
+        } else {
+            if (relative->path[0] == '\0') {
+                target->path = ne_strdup(base->path);
+                if (relative->query) {
+                    target->query = ne_strdup(relative->query);
+                } else if (base->query) {
+                    target->query = ne_strdup(base->query);
+                }
+            } else {
+                if (relative->path[0] == '/') {
+                    target->path = remove_dot_segments(relative->path);
+                } else {
+                    char *merged = merge_paths(base, relative->path);
+                    target->path = remove_dot_segments(merged);
+                    ne_free(merged);
+                }
+                if (relative->query) target->query = ne_strdup(relative->query);
+            }
+            copy_authority(target, base);
+        }
+        if (base->scheme) target->scheme = ne_strdup(base->scheme);
+    }
+    
+    if (relative->fragment) target->fragment = ne_strdup(relative->fragment);
+
+    return target;
+}
+
+ne_uri *ne_uri_copy(ne_uri *dest, const ne_uri *src)
+{
+    memset(dest, 0, sizeof *dest);
+
+    if (src->scheme) dest->scheme = ne_strdup(src->scheme);
+    copy_authority(dest, src);
+    if (src->path) dest->path = ne_strdup(src->path);
+    if (src->query) dest->query = ne_strdup(src->query);
+    if (src->fragment) dest->fragment = ne_strdup(src->fragment);
+
+    return dest;
+}
+
+void ne_uri_free(ne_uri *u)
+{
+    if (u->host) ne_free(u->host);
+    if (u->path) ne_free(u->path);
+    if (u->scheme) ne_free(u->scheme);
+    if (u->userinfo) ne_free(u->userinfo);
+    if (u->fragment) ne_free(u->fragment);
+    if (u->query) ne_free(u->query);
+    memset(u, 0, sizeof *u);
+}
+
+char *ne_path_unescape(const char *uri) 
+{
+    const char *pnt;
+    char *ret, *retpos, buf[5] = { "0x00" };
+    retpos = ret = ne_malloc(strlen(uri) + 1);
+    for (pnt = uri; *pnt != '\0'; pnt++) {
+	if (*pnt == '%') {
+	    if (!isxdigit((unsigned char) pnt[1]) || 
+		!isxdigit((unsigned char) pnt[2])) {
+		/* Invalid URI */
+                ne_free(ret);
+		return NULL;
+	    }
+	    buf[2] = *++pnt; buf[3] = *++pnt; /* bit faster than memcpy */
+	    *retpos++ = (char)strtol(buf, NULL, 16);
+	} else {
+	    *retpos++ = *pnt;
+	}
+    }
+    *retpos = '\0';
+    return ret;
+}
+
+/* CH must be an unsigned char; evaluates to 1 if CH should be
+ * percent-encoded (note !!x == x ? 1 : 0). */
+#define path_escape_ch(ch) (!!(uri_lookup(ch) & URI_ESCAPE))
+
+char *ne_path_escape(const char *path) 
+{
+    const unsigned char *pnt;
+    char *ret, *p;
+    size_t count = 0;
+
+    for (pnt = (const unsigned char *)path; *pnt != '\0'; pnt++) {
+        count += path_escape_ch(*pnt);
+    }
+
+    if (count == 0) {
+	return ne_strdup(path);
+    }
+
+    p = ret = ne_malloc(strlen(path) + 2 * count + 1);
+    for (pnt = (const unsigned char *)path; *pnt != '\0'; pnt++) {
+	if (path_escape_ch(*pnt)) {
+	    /* Escape it - %<hex><hex> */
+	    sprintf(p, "%%%02x", (unsigned char) *pnt);
+	    p += 3;
+	} else {
+	    *p++ = *pnt;
+	}
+    }
+    *p = '\0';
+    return ret;
+}
+
+#undef path_escape_ch
+
+#define CMPWITH(field, func)                    \
+    do {                                        \
+        if (u1->field) {                        \
+            if (!u2->field) return -1;          \
+            n = func(u1->field, u2->field);     \
+            if (n) return n;                    \
+        } else if (u2->field) {                 \
+            return 1;                           \
+        }                                       \
+    } while (0)
+
+#define CMP(field) CMPWITH(field, strcmp)
+#define CASECMP(field) CMPWITH(field, ne_strcasecmp)
+
+/* As specified by RFC 2616, section 3.2.3. */
+int ne_uri_cmp(const ne_uri *u1, const ne_uri *u2)
+{
+    int n;
+    
+    CMP(path);
+    CASECMP(host);
+    CASECMP(scheme);
+    CMP(query);
+    CMP(fragment);
+    CMP(userinfo);
+
+    return u2->port - u1->port;
+}
+
+#undef CMP
+#undef CASECMP
+#undef CMPWITH
+
+/* TODO: implement properly */
+int ne_path_compare(const char *a, const char *b) 
+{
+    int ret = ne_strcasecmp(a, b);
+    if (ret) {
+	/* This logic says: "If the lengths of the two URIs differ by
+	 * exactly one, and the LONGER of the two URIs has a trailing
+	 * slash and the SHORTER one DOESN'T, then..." */
+	int traila = ne_path_has_trailing_slash(a),
+	    trailb = ne_path_has_trailing_slash(b),
+	    lena = strlen(a), lenb = strlen(b);
+	if (traila != trailb && abs(lena - lenb) == 1 &&
+	    ((traila && lena > lenb) || (trailb && lenb > lena))) {
+	    /* Compare them, ignoring the trailing slash on the longer
+	     * URI */
+	    if (strncasecmp(a, b, lena < lenb ? lena : lenb) == 0)
+		ret = 0;
+	}
+    }
+    return ret;
+}
+
+char *ne_uri_unparse(const ne_uri *uri)
+{
+    ne_buffer *buf = ne_buffer_create();
+
+    if (uri->scheme) {
+        ne_buffer_concat(buf, uri->scheme, ":", NULL);
+    }
+
+    if (uri->host) {
+        ne_buffer_czappend(buf, "//");
+        if (uri->userinfo) {
+            ne_buffer_concat(buf, uri->userinfo, "@", NULL);
+        }
+        ne_buffer_zappend(buf, uri->host);
+        
+        if (uri->port > 0
+            && (!uri->scheme 
+                || ne_uri_defaultport(uri->scheme) != uri->port)) {
+            char str[20];
+            ne_snprintf(str, 20, ":%d", uri->port);
+            ne_buffer_zappend(buf, str);
+        }
+    }
+
+    ne_buffer_zappend(buf, uri->path);
+
+    if (uri->query) {
+        ne_buffer_concat(buf, "?", uri->query, NULL);
+    }
+    
+    if (uri->fragment) {
+        ne_buffer_concat(buf, "#", uri->fragment, NULL);
+    }
+
+    return ne_buffer_finish(buf);
+}
+
+/* Give it a path segment, it returns non-zero if child is 
+ * a child of parent. */
+int ne_path_childof(const char *parent, const char *child) 
+{
+    char *root = ne_strdup(child);
+    int ret;
+    if (strlen(parent) >= strlen(child)) {
+	ret = 0;
+    } else {
+	/* root is the first of child, equal to length of parent */
+	root[strlen(parent)] = '\0';
+	ret = (ne_path_compare(parent, root) == 0);
+    }
+    ne_free(root);
+    return ret;
+}
diff --git a/net/mmt/neon/src/ne_uri.h b/net/mmt/neon/src/ne_uri.h
new file mode 100644
index 0000000..a51a3ee
--- /dev/null
+++ b/net/mmt/neon/src/ne_uri.h
@@ -0,0 +1,103 @@
+/* 
+   URI manipulation routines.
+   Copyright (C) 1999-2008, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_URI_H
+#define NE_URI_H
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* Return a copy of a path string with anything other than
+ * "unreserved" and the forward-slash character percent-encoded
+ * according to the URI encoding rules.  Returns a malloc-allocated
+ * string and never NULL. */
+char *ne_path_escape(const char *path);
+
+/* Return a decoded copy of a percent-encoded path string. Returns
+ * malloc-allocated path on success, or NULL if the string contained
+ * any syntactically invalid percent-encoding sequences. */
+char *ne_path_unescape(const char *epath);
+
+/* Returns malloc-allocated parent of path, or NULL if path has no
+ * parent (such as "/"). */
+char *ne_path_parent(const char *path);
+
+/* Returns strcmp-like value giving comparison between p1 and p2,
+ * ignoring trailing-slashes. */
+int ne_path_compare(const char *p1, const char *p2);
+
+/* Returns non-zero if child is a child of parent */
+int ne_path_childof(const char *parent, const char *child);
+
+/* Returns non-zero if path has a trailing slash character */
+int ne_path_has_trailing_slash(const char *path);
+
+/* Return the default port for the given scheme, or 0 if none is
+ * known. */
+unsigned int ne_uri_defaultport(const char *scheme);
+
+typedef struct {
+    char *scheme;
+    char *host, *userinfo;
+    unsigned int port;
+    char *path, *query, *fragment;
+} ne_uri;
+
+/* Parse a URI-reference 'uri' and place parsed components in *parsed.
+ * Returns zero on success, non-zero on parse error.  On successful or
+ * error return, all the 'char *' fields of *parsed are either set to
+ * NULL, or point to malloc-allocated NUL-terminated strings;
+ * ne_uri_free can be used to free any set fields.  On success,
+ * parsed->path is guaranteed to be non-NULL. */
+int ne_uri_parse(const char *uri, ne_uri *parsed);
+
+/* Turns a URI structure back into a string.  The returned string is
+ * malloc-allocated, and must be freed by the caller. */
+char *ne_uri_unparse(const ne_uri *uri);
+
+/* Resolve a relative URI 'relative', with respect to base URI 'base',
+ * placing the resultant URI in '*result'.  At least both base->path
+ * and relative->path must be non-NULL.  On return, all the 'char *'
+ * fields of *result are either set to NULL or point to
+ * malloc-allocated NUL-terminated strings.  result->path is
+ * guaranteed to be non-NULL.  ne_uri_free can be used to free the
+ * result structure after use.  Returns 'result'. */
+ne_uri *ne_uri_resolve(const ne_uri *base, const ne_uri *relative,
+                       ne_uri *result);
+
+/* Compares URIs u1 and u2, returns non-zero if they are found to be
+ * non-equal.  The sign of the return value is <0 if 'u1' is less than
+ * 'u2', or >0 if 'u2' is greater than 'u1'. */
+int ne_uri_cmp(const ne_uri *u1, const ne_uri *u2);
+
+/* Copy components of URI 'src' to destination 'dest'.  Returns
+ * 'dest'. */
+ne_uri *ne_uri_copy(ne_uri *dest, const ne_uri *src);
+
+/* Frees any non-NULL fields of parsed URI structure *parsed.  All
+ * fields are then zero-initialized. */
+void ne_uri_free(ne_uri *parsed);
+
+NE_END_DECLS
+
+#endif /* NE_URI_H */
+
diff --git a/net/mmt/neon/src/ne_utils.c b/net/mmt/neon/src/ne_utils.c
new file mode 100644
index 0000000..5b120c8
--- /dev/null
+++ b/net/mmt/neon/src/ne_utils.c
@@ -0,0 +1,219 @@
+/* 
+   HTTP utility functions
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <sys/types.h>
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#include <stdio.h>
+#include <ctype.h> /* isdigit() for ne_parse_statusline */
+
+#ifdef NE_HAVE_ZLIB
+#include <zlib.h>
+#endif
+
+#ifdef HAVE_OPENSSL
+#include <openssl/opensslv.h>
+#endif
+
+#ifdef HAVE_GNUTLS
+#include <gnutls/gnutls.h>
+#endif
+
+/* libxml2: pick up the version string. */
+#if defined(HAVE_LIBXML)
+#include <libxml/xmlversion.h>
+#elif defined(HAVE_EXPAT) && !defined(HAVE_XMLPARSE_H)
+#include <expat.h>
+#endif
+
+#include "ne_utils.h"
+#include "ne_string.h" /* for ne_strdup */
+#include "ne_dates.h"
+
+int ne_debug_mask = 0;
+FILE *ne_debug_stream = NULL;
+
+void ne_debug_init(FILE *stream, int mask)
+{
+    ne_debug_stream = stream;
+    ne_debug_mask = mask;
+#if defined(HAVE_SETVBUF) && defined(_IONBF)
+    /* If possible, turn off buffering on the debug log.  this is very
+     * helpful if debugging segfaults. */
+    if (stream) setvbuf(stream, NULL, _IONBF, 0);
+#endif        
+}
+
+void ne_debug(int ch, const char *template, ...) 
+{
+    va_list params;
+    if ((ch & ne_debug_mask) == 0) return;
+    fflush(stdout);
+    va_start(params, template);
+    vfprintf(ne_debug_stream, template, params);
+    va_end(params);
+    if ((ch & NE_DBG_FLUSH) == NE_DBG_FLUSH)
+	fflush(ne_debug_stream);
+}
+
+#define NE_STRINGIFY(x) # x
+#define NE_EXPAT_VER(x,y,z) NE_STRINGIFY(x) "." NE_STRINGIFY(y) "." NE_STRINGIFY(z)
+
+static const char version_string[] = "neon " NEON_VERSION ": " 
+#ifdef NEON_IS_LIBRARY
+  "Library build"
+#else
+  "Bundled build"
+#endif
+#ifdef NE_HAVE_IPV6
+   ", IPv6"
+#endif
+#ifdef HAVE_EXPAT
+  ", Expat"
+/* expat >=1.95.2 exported the version */
+#ifdef XML_MAJOR_VERSION
+" " NE_EXPAT_VER(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION)
+#endif
+#else /* !HAVE_EXPAT */
+#ifdef HAVE_LIBXML
+  ", libxml " LIBXML_DOTTED_VERSION
+#endif /* HAVE_LIBXML */
+#endif /* !HAVE_EXPAT */
+#if defined(NE_HAVE_ZLIB) && defined(ZLIB_VERSION)
+  ", zlib " ZLIB_VERSION
+#endif /* NE_HAVE_ZLIB && ... */
+#ifdef NE_HAVE_SOCKS
+   ", SOCKSv5"
+#endif
+#ifdef HAVE_OPENSSL
+#ifdef OPENSSL_VERSION_TEXT
+    ", " OPENSSL_VERSION_TEXT
+#else
+   "OpenSSL (unknown version)"
+#endif /* OPENSSL_VERSION_TEXT */
+#endif /* HAVE_OPENSSL */
+#ifdef HAVE_GNUTLS
+    ", GNU TLS " LIBGNUTLS_VERSION
+#endif /* HAVE_GNUTLS */
+#ifdef HAVE_SSPI
+    ", SSPI"
+#endif /* HAVE_SSPI */
+   "."
+;
+
+const char *ne_version_string(void)
+{
+    return version_string;
+}
+
+int ne_version_match(int major, int minor)
+{
+    return NE_VERSION_MAJOR != major || NE_VERSION_MINOR < minor
+        || (NE_VERSION_MAJOR == 0 && NE_VERSION_MINOR != minor);
+}
+
+int ne_has_support(int feature)
+{
+    switch (feature) {
+#if defined(NE_HAVE_SSL) || defined(NE_HAVE_ZLIB) || defined(NE_HAVE_IPV6) \
+    || defined(NE_HAVE_SOCKS) || defined(NE_HAVE_LFS) \
+    || defined(NE_HAVE_TS_SSL) || defined(NE_HAVE_I18N) || defined(HAVE_SSPI)
+#ifdef NE_HAVE_SSL
+    case NE_FEATURE_SSL:
+#endif
+#ifdef NE_HAVE_ZLIB
+    case NE_FEATURE_ZLIB:
+#endif
+#ifdef NE_HAVE_IPV6
+    case NE_FEATURE_IPV6:
+#endif
+#ifdef NE_HAVE_SOCKS
+    case NE_FEATURE_SOCKS:
+#endif
+#ifdef NE_HAVE_LFS
+    case NE_FEATURE_LFS:
+#endif
+#ifdef NE_HAVE_TS_SSL
+    case NE_FEATURE_TS_SSL:
+#endif
+#ifdef NE_HAVE_I18N
+    case NE_FEATURE_I18N:
+#endif
+#ifdef HAVE_SSPI
+    case NE_FEATURE_SSPI:
+#endif
+        return 1;
+#endif /* NE_HAVE_* */
+    default:
+        return 0;
+    }
+}
+
+int ne_parse_statusline(const char *status_line, ne_status *st)
+{
+    const char *part;
+    int major, minor, status_code, klass;
+
+    /* skip leading garbage if any. */
+    part = strstr(status_line, "HTTP/");
+    if (part == NULL) return -1;
+
+    minor = major = 0;
+
+    /* Parse version string, skipping leading zeroes. */
+    for (part += 5; *part != '\0' && isdigit(*part); part++)
+	major = major*10 + (*part-'0');
+
+    if (*part++ != '.') return -1;
+
+    for (;*part != '\0' && isdigit(*part); part++)
+	minor = minor*10 + (*part-'0');
+
+    if (*part != ' ') return -1;
+
+    /* Skip any spaces */
+    for (; *part == ' '; part++) /* noop */;
+
+    /* Parse the Status-Code; part now points at the first Y in
+     * "HTTP/x.x YYY". */
+    if (!isdigit(part[0]) || !isdigit(part[1]) || !isdigit(part[2]) ||
+	(part[3] != '\0' && part[3] != ' ')) return -1;
+    status_code = 100*(part[0]-'0') + 10*(part[1]-'0') + (part[2]-'0');
+    klass = part[0]-'0';
+
+    /* Skip whitespace between status-code and reason-phrase */
+    for (part+=3; *part == ' ' || *part == '\t'; part++) /* noop */;
+
+    /* part now may be pointing to \0 if reason phrase is blank */
+
+    /* Fill in the results */
+    st->major_version = major;
+    st->minor_version = minor;
+    st->reason_phrase = ne_strclean(ne_strdup(part));
+    st->code = status_code;
+    st->klass = klass;
+    return 0;
+}
diff --git a/net/mmt/neon/src/ne_utils.h b/net/mmt/neon/src/ne_utils.h
new file mode 100644
index 0000000..c298cf9
--- /dev/null
+++ b/net/mmt/neon/src/ne_utils.h
@@ -0,0 +1,118 @@
+/* 
+   HTTP utility functions
+   Copyright (C) 1999-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_UTILS_H
+#define NE_UTILS_H
+
+#include <sys/types.h>
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#include "ne_defs.h"
+
+#ifdef NEON_TRIO
+#include <trio.h>
+#endif
+
+NE_BEGIN_DECLS
+
+/* Returns a human-readable library version string describing the
+ * version and build information; for example: 
+ *    "neon 0.2.0: Library build, OpenSSL support" */
+const char *ne_version_string(void);
+
+/* Returns non-zero if library version is not of major version
+ * 'major', or if minor version is not greater than or equal to
+ * 'minor'.  For neon versions with major == 0, all minor versions are
+ * presumed to be incompatible.  */
+int ne_version_match(int major, int minor);
+
+/* Feature codes: */
+#define NE_FEATURE_SSL (1) /* SSL/TLS support */
+#define NE_FEATURE_ZLIB (2) /* zlib compression in compress interface */
+#define NE_FEATURE_IPV6 (3) /* IPv6 is supported in resolver */
+#define NE_FEATURE_LFS (4) /* large file support */
+#define NE_FEATURE_SOCKS (5) /* SOCKSv5 support */
+#define NE_FEATURE_TS_SSL (6) /* Thread-safe SSL/TLS support */
+#define NE_FEATURE_I18N (7) /* i18n error message support */
+#define NE_FEATURE_SSPI (8) /* NTLM/Negotiate authentication protocol via SSPI */
+
+/* Returns non-zero if library is built with support for the given
+ * NE_FEATURE_* feature code 'code'. */
+int ne_has_support(int feature);
+
+/* Debugging macro to allow code to be optimized out if debugging is
+ * disabled at build time. */
+#ifndef NE_DEBUGGING
+#define NE_DEBUG if (0) ne_debug
+#else /* DEBUGGING */
+#define NE_DEBUG ne_debug
+#endif /* DEBUGGING */
+
+/* Debugging masks. */
+#define NE_DBG_SOCKET (1<<0) /* raw socket */
+#define NE_DBG_HTTP (1<<1) /* HTTP request/response handling */
+#define NE_DBG_XML (1<<2) /* XML parser */
+#define NE_DBG_HTTPAUTH (1<<3) /* HTTP authentication (hiding credentials) */
+#define NE_DBG_HTTPPLAIN (1<<4) /* plaintext HTTP authentication */
+#define NE_DBG_LOCKS (1<<5) /* WebDAV locking */
+#define NE_DBG_XMLPARSE (1<<6) /* low-level XML parser */
+#define NE_DBG_HTTPBODY (1<<7) /* HTTP response body blocks */
+#define NE_DBG_SSL (1<<8) /* SSL/TLS */
+#define NE_DBG_FLUSH (1<<30) /* always flush debugging */
+
+/* Send debugging output to 'stream', for all of the given debug
+ * channels.  To disable debugging, pass 'stream' as NULL and 'mask'
+ * as 0. */
+void ne_debug_init(FILE *stream, int mask);
+
+/* The current debug mask and stream set by the last call to
+ * ne_debug_init. */
+extern int ne_debug_mask;
+extern FILE *ne_debug_stream;
+
+/* Produce debug output if any of channels 'ch' is enabled for
+ * debugging. */
+void ne_debug(int ch, const char *, ...) ne_attribute((format(printf, 2, 3)));
+
+/* Storing an HTTP status result */
+typedef struct {
+    int major_version;
+    int minor_version;
+    int code; /* Status-Code value */
+    int klass; /* Class of Status-Code (1-5) */
+    char *reason_phrase;
+} ne_status;
+
+/* NB: couldn't use 'class' in ne_status because it would clash with
+ * the C++ reserved word. */
+
+/* Parse 'status_line' using the the RFC2616 Status-Line grammar.
+ * s->reason_phrase is malloc-allocated if non-NULL, and must be
+ * free'd by the caller.  Returns 0 on success, in which case all
+ * fields of '*s' will be set; or -1 on parse error, in which case
+ * '*s' is unmodified. */
+int ne_parse_statusline(const char *status_line, ne_status *s);
+
+NE_END_DECLS
+
+#endif /* NE_UTILS_H */
diff --git a/net/mmt/neon/src/ne_xml.c b/net/mmt/neon/src/ne_xml.c
new file mode 100644
index 0000000..3870701
--- /dev/null
+++ b/net/mmt/neon/src/ne_xml.c
@@ -0,0 +1,716 @@
+/* 
+   Wrapper interface to XML parser
+   Copyright (C) 1999-2007, 2009, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+
+#include "ne_internal.h"
+
+#include "ne_alloc.h"
+#include "ne_xml.h"
+#include "ne_utils.h"
+#include "ne_string.h"
+
+#if defined(HAVE_EXPAT)
+/* expat support: */
+#ifdef HAVE_XMLPARSE_H
+#include "xmlparse.h"
+#else
+#include <expat.h>
+#endif
+typedef XML_Char ne_xml_char;
+
+#if !defined(XML_MAJOR_VERSION)
+#define NEED_BOM_HANDLING
+#elif XML_MAJOR_VERSION < 2 && XML_MINOR_VERSION == 95 && XML_MICRO_VERSION < 2
+#define NEED_BOM_HANDLING
+#endif
+
+#elif defined(HAVE_LIBXML)
+/* libxml2 support: */
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+typedef xmlChar ne_xml_char;
+
+#if LIBXML_VERSION < 20619
+/* 2.6.19 and earlier have broken BOM handling */
+#define NEED_BOM_HANDLING
+#endif
+#else /* not HAVE_LIBXML */
+#  error need an XML parser
+#endif /* not HAVE_EXPAT */
+
+/* Approx. one screen of text: */
+#define ERR_SIZE (2048)
+
+struct handler {
+    ne_xml_startelm_cb *startelm_cb; /* start-element callback */
+    ne_xml_endelm_cb *endelm_cb; /* end-element callback */
+    ne_xml_cdata_cb *cdata_cb; /* character-data callback. */
+    void *userdata; /* userdata for the above. */
+    struct handler *next; /* next handler in stack. */
+};
+
+#ifdef HAVE_LIBXML
+static void sax_error(void *ctx, const char *msg, ...);
+#endif
+
+struct element {
+    const ne_xml_char *nspace;
+    ne_xml_char *name;
+
+    int state; /* opaque state integer */
+    
+    /* Namespaces declared in this element */
+    ne_xml_char *default_ns; /* A default namespace */
+    struct namespace *nspaces; /* List of other namespace scopes */
+
+    struct handler *handler; /* Handler for this element */
+
+    struct element *parent; /* parent element, or NULL */    
+};
+
+/* We pass around a ne_xml_parser as the userdata in the parsing
+ * library.  This maintains the current state of the parse and various
+ * other bits and bobs. Within the parse, we store the current branch
+ * of the tree, i.e., the current element and all its parents, up to
+ * the root, but nothing other than that.  */
+struct ne_xml_parser_s {
+    struct element *root; /* the root of the document */
+    struct element *current; /* current element in the branch */
+    struct handler *top_handlers; /* always points at the 
+					   * handler on top of the stack. */
+    int failure; /* zero whilst parse should continue */
+    int prune; /* if non-zero, depth within a dead branch */
+
+#ifdef NEED_BOM_HANDLING
+    int bom_pos;
+#endif
+
+#ifdef HAVE_EXPAT
+    XML_Parser parser;
+    char *encoding;
+#else
+    xmlParserCtxtPtr parser;
+#endif
+    char error[ERR_SIZE];
+};
+
+/* The callback handlers */
+static void start_element(void *userdata, const ne_xml_char *name, const ne_xml_char **atts);
+static void end_element(void *userdata, const ne_xml_char *name);
+static void char_data(void *userdata, const ne_xml_char *cdata, int len);
+static const char *resolve_nspace(const struct element *elm, 
+                                  const char *prefix, size_t pfxlen);
+
+/* Linked list of namespace scopes */
+struct namespace {
+    ne_xml_char *name;
+    ne_xml_char *uri;
+    struct namespace *next;
+};
+
+#ifdef HAVE_LIBXML
+
+/* Could be const as far as we care, but libxml doesn't want that */
+static xmlSAXHandler sax_handler = {
+    NULL, /* internalSubset */
+    NULL, /* isStandalone */
+    NULL, /* hasInternalSubset */
+    NULL, /* hasExternalSubset */
+    NULL, /* resolveEntity */
+    NULL, /* getEntity */
+    NULL, /* entityDecl */
+    NULL, /* notationDecl */
+    NULL, /* attributeDecl */
+    NULL, /* elementDecl */
+    NULL, /* unparsedEntityDecl */
+    NULL, /* setDocumentLocator */
+    NULL, /* startDocument */
+    NULL, /* endDocument */
+    start_element, /* startElement */
+    end_element, /* endElement */
+    NULL, /* reference */
+    char_data, /* characters */
+    NULL, /* ignorableWhitespace */
+    NULL, /* processingInstruction */
+    NULL, /* comment */
+    NULL, /* xmlParserWarning */
+    sax_error, /* xmlParserError */
+    sax_error, /* fatal error (never called by libxml2?) */
+    NULL, /* getParameterEntity */
+    char_data /* cdataBlock */
+};
+
+/* empty attributes array to mimic expat behaviour */
+static const char *const empty_atts[] = {NULL, NULL};
+
+/* macro for determining the attributes array to pass */
+#define PASS_ATTS(atts) (atts ? (const char **)(atts) : empty_atts)
+
+#else
+
+#define PASS_ATTS(atts) ((const char **)(atts))
+
+/* XML declaration callback for expat. */
+static void decl_handler(void *userdata,
+			 const XML_Char *version, const XML_Char *encoding, 
+			 int standalone)
+{
+    ne_xml_parser *p = userdata;
+    if (encoding) p->encoding = ne_strdup(encoding);    
+}
+
+#endif /* HAVE_LIBXML */
+
+int ne_xml_currentline(ne_xml_parser *p) 
+{
+#ifdef HAVE_EXPAT
+    return XML_GetCurrentLineNumber(p->parser);
+#else
+    return p->parser->input->line;
+#endif
+}
+
+const char *ne_xml_doc_encoding(const ne_xml_parser *p)
+{
+#ifdef HAVE_LIBXML
+    return p->parser->encoding;
+#else
+    return p->encoding;
+#endif
+}
+
+/* The first character of the REC-xml-names "NCName" rule excludes
+ * "Digit | '.' | '-' | '_' | CombiningChar | Extender"; the XML
+ * parser will not enforce this rule in a namespace declaration since
+ * it treats the entire attribute name as a REC-xml "Name" rule.  It's
+ * too hard to check for all of CombiningChar | Digit | Extender here,
+ * but the valid_ncname_ch1 macro catches some of the rest. */
+
+/* Return non-zero if 'ch' is an invalid start character for an NCName: */
+#define invalid_ncname_ch1(ch) ((ch) == '\0' || strchr("-.0123456789", (ch)) != NULL)
+
+/* Subversion repositories have been deployed which use property names
+ * marshalled as NCNames including a colon character; these should
+ * also be rejected but will be allowed for the time being. */
+#define invalid_ncname(xn) (invalid_ncname_ch1((xn)[0]))
+
+/* Extract the namespace prefix declarations from 'atts'. */
+static int declare_nspaces(ne_xml_parser *p, struct element *elm,
+                           const ne_xml_char **atts)
+{
+    int n;
+    
+    for (n = 0; atts && atts[n]; n += 2) {
+        if (strcmp(atts[n], "xmlns") == 0) {
+            /* New default namespace */
+            elm->default_ns = ne_strdup(atts[n+1]);
+        } else if (strncmp(atts[n], "xmlns:", 6) == 0) {
+            struct namespace *ns;
+            
+            /* Reject some invalid NCNames as namespace prefix, and an
+             * empty URI as the namespace URI */
+            if (invalid_ncname(atts[n] + 6) || atts[n+1][0] == '\0') {
+                ne_snprintf(p->error, ERR_SIZE, 
+                            ("XML parse error at line %d: invalid namespace "
+                             "declaration"), ne_xml_currentline(p));
+                return -1;
+            }
+
+            /* New namespace scope */
+            ns = ne_calloc(sizeof(*ns));
+            ns->next = elm->nspaces;
+            elm->nspaces = ns;
+            ns->name = ne_strdup(atts[n]+6); /* skip the xmlns= */
+            ns->uri = ne_strdup(atts[n+1]);
+        }
+    }
+    
+    return 0;
+}
+
+/* Expand an XML qualified name, which may include a namespace prefix
+ * as well as the local part. */
+static int expand_qname(ne_xml_parser *p, struct element *elm,
+                        const ne_xml_char *qname)
+{
+    const ne_xml_char *pfx;
+
+    pfx = strchr(qname, ':');
+    if (pfx == NULL) {
+        struct element *e = elm;
+
+        /* Find default namespace; guaranteed to terminate as the root
+         * element always has default_ns="". */
+        while (e->default_ns == NULL)
+            e = e->parent;
+        
+        elm->name = ne_strdup(qname);
+        elm->nspace = e->default_ns;
+    } else if (invalid_ncname(pfx + 1) || qname == pfx) {
+        ne_snprintf(p->error, ERR_SIZE, 
+                    _("XML parse error at line %d: invalid element name"), 
+                    ne_xml_currentline(p));
+        return -1;
+    } else {
+        const char *uri = resolve_nspace(elm, qname, pfx-qname);
+
+	if (uri) {
+	    elm->name = ne_strdup(pfx+1);
+            elm->nspace = uri;
+	} else {
+	    ne_snprintf(p->error, ERR_SIZE, 
+                        ("XML parse error at line %d: undeclared namespace prefix"),
+                        ne_xml_currentline(p));
+	    return -1;
+	}
+    }
+    return 0;
+}
+
+/* Called with the start of a new element. */
+static void start_element(void *userdata, const ne_xml_char *name,
+			  const ne_xml_char **atts) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm;
+    struct handler *hand;
+    int state = NE_XML_DECLINE;
+
+    if (p->failure) return;
+    
+    if (p->prune) {
+        p->prune++;
+        return;
+    }
+
+    /* Create a new element */
+    elm = ne_calloc(sizeof *elm);
+    elm->parent = p->current;
+    p->current = elm;
+
+    if (declare_nspaces(p, elm, atts) || expand_qname(p, elm, name)) {
+        p->failure = 1;
+        return;
+    }
+
+    /* Find a handler which will accept this element (or abort the parse) */
+    for (hand = elm->parent->handler; hand && state == NE_XML_DECLINE;
+         hand = hand->next) {
+        elm->handler = hand;
+        state = hand->startelm_cb(hand->userdata, elm->parent->state,
+                                  elm->nspace, elm->name, PASS_ATTS(atts));
+    }
+
+    NE_DEBUG(NE_DBG_XML, "XML: start-element (%d, {%s, %s}) => %d\n", 
+             elm->parent->state, elm->nspace, elm->name, state);             
+    
+    if (state > 0)
+        elm->state = state;
+    else if (state == NE_XML_DECLINE)
+        /* prune this branch. */
+        p->prune++;
+    else /* state < 0 => abort parse  */
+        p->failure = state;
+}
+
+/* Destroys an element structure. */
+static void destroy_element(struct element *elm) 
+{
+    struct namespace *this_ns, *next_ns;
+    ne_free(elm->name);
+    /* Free the namespaces */
+    this_ns = elm->nspaces;
+    while (this_ns != NULL) {
+	next_ns = this_ns->next;
+	ne_free(this_ns->name);
+	ne_free(this_ns->uri);
+	ne_free(this_ns);
+	this_ns = next_ns;
+    }
+    if (elm->default_ns)
+        ne_free(elm->default_ns);
+    ne_free(elm);
+}
+
+/* cdata SAX callback */
+static void char_data(void *userdata, const ne_xml_char *data, int len) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm = p->current;
+
+    if (p->failure || p->prune) return;
+    
+    if (elm->handler->cdata_cb) {
+        p->failure = elm->handler->cdata_cb(elm->handler->userdata, elm->state, data, len);
+        NE_DEBUG(NE_DBG_XML, "XML: char-data (%d) returns %d\n", 
+                 elm->state, p->failure);
+    }        
+}
+
+/* Called with the end of an element */
+static void end_element(void *userdata, const ne_xml_char *name) 
+{
+    ne_xml_parser *p = userdata;
+    struct element *elm = p->current;
+
+    if (p->failure) return;
+	
+    if (p->prune) {
+        if (p->prune-- > 1) return;
+    } else if (elm->handler->endelm_cb) {
+        p->failure = elm->handler->endelm_cb(elm->handler->userdata, elm->state,
+                                             elm->nspace, elm->name);
+        if (p->failure) {
+            NE_DEBUG(NE_DBG_XML, "XML: end-element for %d failed with %d.\n", 
+                     elm->state, p->failure);
+        }
+    }
+    
+    NE_DEBUG(NE_DBG_XML, "XML: end-element (%d, {%s, %s})\n",
+             elm->state, elm->nspace, elm->name);
+
+    /* move back up the tree */
+    p->current = elm->parent;
+    p->prune = 0;
+
+    destroy_element(elm);
+}
+
+#if defined(HAVE_EXPAT) && XML_MAJOR_VERSION > 1
+/* Stop the parser if an entity declaration is hit. */
+static void entity_declaration(void *userData, const XML_Char *entityName,
+                              int is_parameter_entity, const XML_Char *value,
+                              int value_length, const XML_Char *base,
+                              const XML_Char *systemId, const XML_Char *publicId,
+                              const XML_Char *notationName)
+{
+    ne_xml_parser *parser = userData;
+    
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: entity declaration [%s]. Failing.\n",
+             entityName);
+
+    XML_StopParser(parser->parser, XML_FALSE);
+}
+#elif defined(HAVE_EXPAT)
+/* A noop default_handler. */
+static void default_handler(void *userData, const XML_Char *s, int len)
+{
+}
+#endif
+
+/* Find a namespace definition for 'prefix' in given element, where
+ * length of prefix is 'pfxlen'.  Returns the URI or NULL. */
+static const char *resolve_nspace(const struct element *elm, 
+                                  const char *prefix, size_t pfxlen)
+{
+    const struct element *s;
+
+    /* Search up the tree. */
+    for (s = elm; s != NULL; s = s->parent) {
+	const struct namespace *ns;
+	/* Iterate over defined spaces on this node. */
+	for (ns = s->nspaces; ns != NULL; ns = ns->next) {
+	    if (strlen(ns->name) == pfxlen && 
+		memcmp(ns->name, prefix, pfxlen) == 0)
+		return ns->uri;
+	}
+    }
+
+    return NULL;
+}
+
+const char *ne_xml_resolve_nspace(ne_xml_parser *parser, 
+                                  const char *prefix, size_t length)
+{
+    if (prefix) {
+        return resolve_nspace(parser->current, prefix, length);
+    }
+    else {
+        struct element *e = parser->current;
+
+        while (e->default_ns == NULL)
+            e = e->parent;
+
+        return e->default_ns;
+    }
+}
+
+ne_xml_parser *ne_xml_create(void) 
+{
+    ne_xml_parser *p = ne_calloc(sizeof *p);
+    /* Placeholder for the root element */
+    p->current = p->root = ne_calloc(sizeof *p->root);
+    p->root->default_ns = "";
+    p->root->state = 0;
+    strcpy(p->error, _("Unknown error"));
+#ifdef HAVE_EXPAT
+    p->parser = XML_ParserCreate(NULL);
+    if (p->parser == NULL) {
+	abort();
+    }
+    XML_SetElementHandler(p->parser, start_element, end_element);
+    XML_SetCharacterDataHandler(p->parser, char_data);
+    XML_SetUserData(p->parser, (void *) p);
+    XML_SetXmlDeclHandler(p->parser, decl_handler);
+
+    /* Prevent the "billion laughs" attack against expat by disabling
+     * internal entity expansion.  With 2.x, forcibly stop the parser
+     * if an entity is declared - this is safer and a more obvious
+     * failure mode.  With older versions, installing a noop
+     * DefaultHandler means that internal entities will be expanded as
+     * the empty string, which is also sufficient to prevent the
+     * attack. */
+#if XML_MAJOR_VERSION > 1
+    XML_SetEntityDeclHandler(p->parser, entity_declaration);
+#else
+    XML_SetDefaultHandler(p->parser, default_handler);
+#endif
+
+#else /* HAVE_LIBXML */
+    p->parser = xmlCreatePushParserCtxt(&sax_handler, 
+					(void *)p, NULL, 0, NULL);
+    if (p->parser == NULL) {
+	abort();
+    }
+#if LIBXML_VERSION < 20602
+    p->parser->replaceEntities = 1;
+#else
+    /* Enable expansion of entities, and disable network access. */
+    xmlCtxtUseOptions(p->parser, XML_PARSE_NOENT | XML_PARSE_NONET);
+#endif
+
+#endif /* HAVE_LIBXML || HAVE_EXPAT */
+    return p;
+}
+
+void ne_xml_push_handler(ne_xml_parser *p,
+			 ne_xml_startelm_cb *startelm_cb, 
+			 ne_xml_cdata_cb *cdata_cb, 
+			 ne_xml_endelm_cb *endelm_cb,
+			 void *userdata)
+{
+    struct handler *hand = ne_calloc(sizeof(struct handler));
+
+    hand->startelm_cb = startelm_cb;
+    hand->cdata_cb = cdata_cb;
+    hand->endelm_cb = endelm_cb;
+    hand->userdata = userdata;
+
+    /* If this is the first handler registered, update the
+     * base pointer too. */
+    if (p->top_handlers == NULL) {
+	p->root->handler = hand;
+	p->top_handlers = hand;
+    } else {
+	p->top_handlers->next = hand;
+	p->top_handlers = hand;
+    }
+}
+
+int ne_xml_parse_v(void *userdata, const char *block, size_t len) 
+{
+    ne_xml_parser *p = userdata;
+    return ne_xml_parse(p, (const ne_xml_char *)block, len);
+}
+
+#define BOM_UTF8 "\xEF\xBB\xBF" /* UTF-8 BOM */
+
+int ne_xml_parse(ne_xml_parser *p, const char *block, size_t len) 
+{
+    int ret, flag;
+    /* duck out if it's broken */
+    if (p->failure) {
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: Failed; ignoring %" NE_FMT_SIZE_T 
+                 " bytes.\n", len);
+	return p->failure;
+    }
+    if (len == 0) {
+	flag = -1;
+	block = "";
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: End of document.\n");
+    } else {	
+	NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parsing %" NE_FMT_SIZE_T " bytes.\n", len);
+	flag = 0;
+    }
+
+#ifdef NEED_BOM_HANDLING
+    if (p->bom_pos < 3) {
+        NE_DEBUG(NE_DBG_XMLPARSE, "Checking for UTF-8 BOM.\n");
+        while (len > 0 && p->bom_pos < 3 && 
+               block[0] == BOM_UTF8[p->bom_pos]) {
+            block++;
+            len--;
+            p->bom_pos++;
+        }
+        if (len == 0)
+            return 0;
+        if (p->bom_pos == 0) {
+            p->bom_pos = 3; /* no BOM */
+        } else if (p->bom_pos > 0 && p->bom_pos < 3) {
+            strcpy(p->error, _("Invalid Byte Order Mark"));
+            return p->failure = 1;
+        }
+    }
+#endif
+
+    /* Note, don't write a parser error if p->failure, since an error
+     * will already have been written in that case. */
+#ifdef HAVE_EXPAT
+    ret = XML_Parse(p->parser, block, len, flag);
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: XML_Parse returned %d\n", ret);
+    if (ret == 0 && p->failure == 0) {
+	ne_snprintf(p->error, ERR_SIZE,
+		    "XML parse error at line %" NE_FMT_XML_SIZE ": %s", 
+		    XML_GetCurrentLineNumber(p->parser),
+		    XML_ErrorString(XML_GetErrorCode(p->parser)));
+	p->failure = 1;
+        NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parse error: %s\n", p->error);
+    }
+#else
+    ret = xmlParseChunk(p->parser, block, len, flag);
+    NE_DEBUG(NE_DBG_XMLPARSE, "XML: xmlParseChunk returned %d\n", ret);
+    /* Parse errors are normally caught by the sax_error() callback,
+     * which clears p->valid. */
+    if (p->parser->errNo && p->failure == 0) {
+	ne_snprintf(p->error, ERR_SIZE, "XML parse error at line %d", 
+		    ne_xml_currentline(p));
+	p->failure = 1;
+        NE_DEBUG(NE_DBG_XMLPARSE, "XML: Parse error: %s\n", p->error);
+    }
+#endif
+    return p->failure;
+}
+
+int ne_xml_failed(ne_xml_parser *p)
+{
+    return p->failure;
+}
+
+void ne_xml_destroy(ne_xml_parser *p) 
+{
+    struct element *elm, *parent;
+    struct handler *hand, *next;
+
+    /* Free up the handlers on the stack: the root element has the
+     * pointer to the base of the handler stack. */
+    for (hand = p->root->handler; hand!=NULL; hand=next) {
+	next = hand->next;
+	ne_free(hand);
+    }
+
+    /* Clean up remaining elements */
+    for (elm = p->current; elm != p->root; elm = parent) {
+	parent = elm->parent;
+	destroy_element(elm);
+    }
+
+    /* free root element */
+    ne_free(p->root);
+
+#ifdef HAVE_EXPAT
+    XML_ParserFree(p->parser);
+    if (p->encoding) ne_free(p->encoding);
+#else
+    xmlFreeParserCtxt(p->parser);
+#endif
+
+    ne_free(p);
+}
+
+void ne_xml_set_error(ne_xml_parser *p, const char *msg)
+{
+    ne_snprintf(p->error, ERR_SIZE, "%s", msg);
+}
+
+#ifdef HAVE_LIBXML
+static void sax_error(void *ctx, const char *msg, ...)
+{
+    ne_xml_parser *p = ctx;
+    va_list ap;
+    char buf[1024];
+
+    va_start(ap, msg);
+    ne_vsnprintf(buf, 1024, msg, ap);
+    va_end(ap);
+
+    if (p->failure == 0) {
+        ne_snprintf(p->error, ERR_SIZE, 
+                    _("XML parse error at line %d: %s"),
+                    p->parser->input->line, buf);
+        p->failure = 1;
+    }
+}
+#endif
+
+const char *ne_xml_get_error(ne_xml_parser *p)
+{
+    return p->error;
+}
+
+const char *
+ne_xml_get_attr(ne_xml_parser *p, const char **attrs, 
+		const char *nspace, const char *name)
+{
+    int n;
+
+    for (n = 0; attrs[n] != NULL; n += 2) {
+	char *pnt = strchr(attrs[n], ':');
+
+	if (!nspace && !pnt && strcmp(attrs[n], name) == 0) {
+	    return attrs[n+1];
+	} else if (nspace && pnt) {
+	    /* If a namespace is given, and the local part matches,
+	     * then resolve the namespace and compare that too. */
+	    if (strcmp(pnt + 1, name) == 0) {
+		const char *uri = resolve_nspace(p->current, 
+						 attrs[n], pnt - attrs[n]);
+		if (uri && strcmp(uri, nspace) == 0)
+		    return attrs[n+1];
+	    }
+	}
+    }
+
+    return NULL;
+}
+
+int ne_xml_mapid(const struct ne_xml_idmap map[], size_t maplen,
+                 const char *nspace, const char *name)
+{
+    size_t n;
+    
+    for (n = 0; n < maplen; n++)
+        if (strcmp(name, map[n].name) == 0 &&
+            strcmp(nspace, map[n].nspace) == 0)
+            return map[n].id;
+    
+    return 0;
+}
diff --git a/net/mmt/neon/src/ne_xml.h b/net/mmt/neon/src/ne_xml.h
new file mode 100644
index 0000000..7fcd477
--- /dev/null
+++ b/net/mmt/neon/src/ne_xml.h
@@ -0,0 +1,165 @@
+/* 
+   neon XML parser interface
+   Copyright (C) 1999-2007, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_XML_H
+#define NE_XML_H
+
+#include <sys/types.h> /* for size_t */
+
+#include "ne_defs.h"
+
+NE_BEGIN_DECLS
+
+/* The neon XML interface filters a streamed XML tree through a stack
+ * of SAX "handlers".  A handler is made up of three callbacks
+ * (start-element, char-data, end-element).  Each start-element event
+ * is passed to each handler in the stack in turn until one until one
+ * accepts the element.  This handler then receives subsequent
+ * char-data and end-element events for the element.
+ *
+ * For each new start-element event, the search up the handler stack
+ * begins with the handler for the parent element (for the root
+ * element, at the base of the stack).
+ *
+ * For each accepted element, a "state" integer is stored, which is
+ * passed to the corresponding char-data and end-element callbacks for
+ * the element.  This integer is also passed to the start-element
+ * callback of child elements so they can determine context.
+ *
+ * If no handler in the stack accepts a particular element, it (and
+ * its children, if any) is ignored. */
+
+#define NE_XML_DECLINE (0)
+#define NE_XML_ABORT (-1)
+
+/* A start-element callback for element with given namespace/name.
+ * The callback may return:
+ *   <0  =>  abort the parse (NE_XML_ABORT)
+ *    0  =>  decline this element (NE_XML_DECLINE)
+ *   >0  =>  accept this element; value is state for this element.
+ *
+ * The 'parent' integer is the state returned by the handler of the 
+ * parent element.   The attributes array gives name/value pairs
+ * in atts[n] and atts[n+1] from n=0 up to atts[n]==NULL. */
+typedef int ne_xml_startelm_cb(void *userdata, int parent,
+                               const char *nspace, const char *name,
+                               const char **atts);
+
+/* state for the root element */
+#define NE_XML_STATEROOT (0)
+
+/* Character data callback; may return non-zero to abort the parse. */
+typedef int ne_xml_cdata_cb(void *userdata, int state,
+                            const char *cdata, size_t len);
+/* End element callback; may return non-zero to abort the parse. */
+typedef int ne_xml_endelm_cb(void *userdata, int state, 
+                             const char *nspace, const char *name);
+
+typedef struct ne_xml_parser_s ne_xml_parser;
+
+/* Create an XML parser. */
+ne_xml_parser *ne_xml_create(void);
+
+/* Push a new handler on the stack of parser 'p'. 'cdata' and/or
+ * 'endelm' may be NULL; startelm must be non-NULL. */
+void ne_xml_push_handler(ne_xml_parser *p,
+                         ne_xml_startelm_cb *startelm, 
+                         ne_xml_cdata_cb *cdata,
+                         ne_xml_endelm_cb *endelm,
+                         void *userdata);
+
+/* ne_xml_failed returns non-zero if there was an error during
+ * parsing, or zero if the parse completed successfully.  The return
+ * value is equal to that of the last ne_xml_parse() call for this
+ * parser object. */
+int ne_xml_failed(ne_xml_parser *p);
+
+/* Set error string for parser.  (The string may be truncated
+ * internally). */
+void ne_xml_set_error(ne_xml_parser *p, const char *msg);
+
+/* Return the error string (and never NULL).  After ne_xml_failed
+ * returns >0, this will describe the parse error.  Otherwise it will
+ * be a default error string. */
+const char *ne_xml_get_error(ne_xml_parser *p);
+
+/* Parse the given block of input of length len.  Parser must be
+ * called with len=0 to signify the end of the document (for that
+ * case, the block argument is ignored).  Returns zero on success, or
+ * non-zero on error: for an XML syntax error, a positive number is
+ * returned; if parsing is aborted by a caller-supplied callback, that
+ * callback's return value is returned. */
+int ne_xml_parse(ne_xml_parser *p, const char *block, size_t len);
+
+/* As ne_xml_parse, casting (ne_xml_parser *)userdata internally.
+ * (This function can be passed to ne_add_response_body_reader) */
+int ne_xml_parse_v(void *userdata, const char *block, size_t len);
+
+/* Return current line of document during parsing or after parsing is
+ * complete. */
+int ne_xml_currentline(ne_xml_parser *p);
+
+/* From a start_element callback which was passed 'attrs' using given
+ * parser, return attribute of given name and namespace.  If nspace is
+ * NULL, no namespace resolution is performed.  Note that this call is
+ * context-specific; if called outside a start_element callback,
+ * behaviour is undefined. */
+const char *ne_xml_get_attr(ne_xml_parser *parser,
+			    const char **attrs, const char *nspace, 
+			    const char *name);
+
+/* From a start_element callback, resolve a given XML Namespace
+ * prefix, if defined.  Given a non-NULL prefix, returns the namespace
+ * URI which corresponds to the prefix 'prefix' (of length 'length'),
+ * or NULL if no such namespace prefix is defined.  Given a NULL
+ * prefix, returns the default namespace URI or the empty string if
+ * none is defined.  Note that this call is context-specific; if
+ * called outside a start_element callback, behaviour is undefined. */
+const char *ne_xml_resolve_nspace(ne_xml_parser *parser, 
+                                  const char *prefix, size_t length);
+
+/* Return the encoding of the document being parsed.  May return NULL
+ * if no encoding is defined or if the XML declaration has not yet
+ * been parsed. */
+const char *ne_xml_doc_encoding(const ne_xml_parser *p);
+
+/* Destroy the parser object. */
+void ne_xml_destroy(ne_xml_parser *p);
+
+/* A utility interface for mapping {nspace, name} onto an integer. */
+struct ne_xml_idmap {
+    const char *nspace, *name;
+    int id;
+};
+
+/* Return the size of an idmap array */
+#define NE_XML_MAPLEN(map) (sizeof(map) / sizeof(struct ne_xml_idmap))
+
+/* Return the 'id' corresponding to {nspace, name}, or zero. */
+int ne_xml_mapid(const struct ne_xml_idmap map[], size_t maplen,
+                 const char *nspace, const char *name);
+
+/* media type, appropriate for adding to a Content-Type header */
+#define NE_XML_MEDIA_TYPE "application/xml"
+
+NE_END_DECLS
+
+#endif /* NE_XML_H */
diff --git a/net/mmt/neon/src/ne_xmlreq.c b/net/mmt/neon/src/ne_xmlreq.c
new file mode 100644
index 0000000..c4fbf5a
--- /dev/null
+++ b/net/mmt/neon/src/ne_xmlreq.c
@@ -0,0 +1,110 @@
+/* 
+   XML/HTTP response handling
+   Copyright (C) 2004-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#include "config.h"
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "ne_internal.h"
+#include "ne_xmlreq.h"
+#include "ne_basic.h"
+#include "ne_string.h"
+
+/* Handle an XML response parse error, setting session error string
+ * and closing the connection. */
+static int parse_error(ne_session *sess, ne_xml_parser *parser)
+{
+    ne_set_error(sess, _("Could not parse response: %s"),
+                 ne_xml_get_error(parser));
+    ne_close_connection(sess);
+    return NE_ERROR;
+}
+
+int ne_xml_parse_response(ne_request *req, ne_xml_parser *parser)
+{
+    char buf[8000];
+    ssize_t bytes;
+    int ret = 0;
+
+    while ((bytes = ne_read_response_block(req, buf, sizeof buf)) > 0) {
+        ret = ne_xml_parse(parser, buf, bytes);
+        if (ret)
+            return parse_error(ne_get_session(req), parser);
+    }
+
+    if (bytes == 0) {
+        /* Tell the parser that end of document was reached: */
+        if (ne_xml_parse(parser, NULL, 0) == 0)
+            return NE_OK;
+        else
+            return parse_error(ne_get_session(req), parser);
+    } else {
+        return NE_ERROR;
+    }    
+}
+
+/* Returns non-zero if given content-type is an XML media type,
+ * following the RFC 3023 rules. */
+static int media_type_is_xml(const ne_content_type *ctype)
+{
+    size_t stlen;
+
+    return 
+        (ne_strcasecmp(ctype->type, "text") == 0
+         && ne_strcasecmp(ctype->subtype, "xml") == 0)
+        || (ne_strcasecmp(ctype->type, "application") == 0
+            && ne_strcasecmp(ctype->subtype, "xml") == 0)
+        || ((stlen = strlen(ctype->subtype)) > 4
+            && ne_strcasecmp(ctype->subtype + stlen - 4, "+xml") == 0);
+}
+
+int ne_xml_dispatch_request(ne_request *req, ne_xml_parser *parser)
+{
+    int ret;
+
+    do {
+        int parseit = 0;
+
+        ret = ne_begin_request(req);
+        if (ret) break;
+        
+        if (ne_get_status(req)->klass == 2) {
+            ne_content_type ctype;
+            
+            if (ne_get_content_type(req, &ctype) == 0) {
+                parseit = media_type_is_xml(&ctype);
+                ne_free(ctype.value);
+            }
+        }
+
+        if (parseit)
+            ret = ne_xml_parse_response(req, parser);
+        else
+            ret = ne_discard_response(req);
+        
+        if (ret == NE_OK)
+            ret = ne_end_request(req);
+    } while (ret == NE_RETRY);
+
+    return ret;
+}
+
diff --git a/net/mmt/neon/src/ne_xmlreq.h b/net/mmt/neon/src/ne_xmlreq.h
new file mode 100644
index 0000000..1bf667d
--- /dev/null
+++ b/net/mmt/neon/src/ne_xmlreq.h
@@ -0,0 +1,51 @@
+/* 
+   XML/HTTP response handling
+   Copyright (C) 2004-2006, Joe Orton <joe@manyfish.co.uk>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+   MA 02111-1307, USA
+
+*/
+
+#ifndef NE_XMLREQ_H
+#define NE_XMLREQ_H
+
+#include "ne_request.h"
+#include "ne_xml.h"
+
+NE_BEGIN_DECLS
+
+/* Read the HTTP response body using calls to ne_read_response_block
+ * (so must be enclosed by ne_begin_request/ne_end_request calls), and
+ * parse it as an XML document, using the given parser.  Returns NE_*
+ * error codes.  If an XML parse error occurs, the session error
+ * string is set to the XML parser's error string, and NE_ERROR is
+ * returned. */
+int ne_xml_parse_response(ne_request *req, ne_xml_parser *parser);
+
+/* Dispatch the HTTP request, parsing the response body as an XML
+ * document using the given parser, if the response status class is
+ * 2xx and an XML media type is specified for the response entity.  If
+ * a non-2xx response code is given, or a non-XML media type is
+ * specified, then the response body will be silently discarded.
+ *
+ * Returns NE_* error codes.  If an XML parse error occurs, the
+ * session error string is set to the XML parser's error string, and
+ * NE_ERROR is returned. */
+int ne_xml_dispatch_request(ne_request *req, ne_xml_parser *parser);
+
+NE_END_DECLS
+
+#endif /* NE_XMLREQ_H */
diff --git a/net/mmt/neon/src/neon.vers b/net/mmt/neon/src/neon.vers
new file mode 100644
index 0000000..bed99c2
--- /dev/null
+++ b/net/mmt/neon/src/neon.vers
@@ -0,0 +1,22 @@
+# GNU linker version script for neon.
+# All symbols in <= 0.28.x use default unversioned.
+
+NEON_0_29 {
+    ne_iaddr_raw;
+    ne_sock_writev;
+    ne_sock_fullwritev;
+    ne_sock_set_error;
+    ne_sock_proxy;
+    ne_session_system_proxy;
+    ne_session_socks_proxy;
+    ne_acl3744_set;
+    ne_buffer_qappend;
+    ne_strnqdup;
+};
+
+NEON_0_30 {
+    ne_ssl_clicert_import;
+    ne_addr_canonical;
+    ne_ssl_context_get_flag;
+    ne_set_addrlist2;
+};
diff --git a/net/net.gyp b/net/net.gyp
index 0305738..75bd21c 100644
--- a/net/net.gyp
+++ b/net/net.gyp
@@ -104,6 +104,7 @@
         '../net/mmt/mpu/mpu.gyp:libmpu',
         '../net/mmt/mmtp/mmtp.gyp:libmmtp',
         '../net/mmt/ntp/ntp.gyp:libntp',
+        '../net/mmt/neon/neon.gyp:libneon',
       ],
       'sources': [
         '<@(net_nacl_common_sources)',
-- 
1.7.9.5


From f7d93d2cf24df50f480d19ee541a2fdbf00bb26a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 19:19:53 +0800
Subject: [PATCH 105/128] [todo] add mmt_http

---
 net/mmt/mmt_http.cc |  216 +++++++++++++++++++++++++++++++++++++++++++++++++++
 net/mmt/mmt_http.h  |   47 +++++++++++
 net/net.gypi        |    1 +
 3 files changed, 264 insertions(+)
 create mode 100644 net/mmt/mmt_http.cc
 create mode 100644 net/mmt/mmt_http.h

diff --git a/net/mmt/mmt_http.cc b/net/mmt/mmt_http.cc
new file mode 100644
index 0000000..4a569e0
--- /dev/null
+++ b/net/mmt/mmt_http.cc
@@ -0,0 +1,216 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include "net/mmt/mmt_http.h"
+#include "net/mmt/mmt_inc.h"
+#include "neon/src/ne_session.h"
+#include "neon/src/ne_request.h"
+#include "neon/src/ne_auth.h"
+
+namespace mmt {
+
+/**
+ * usage: 
+ *  ne_session_create(scheme, hostname, port);
+ *  ne_request_create(session, method, path);
+ *  ne_add_request_header(..); 
+ *   => Host/Accept/User-Agent/Authorization,
+ *      Content-Type/Content-Length/body, 
+ *  ne_request_dispatch(..); => got Content/Content-Length
+ *  ne_get_status(..); => 200
+ *  ne_request_destroy()
+ *  ne_close_connection();
+ *  ne_session_destroy();
+ *
+ */
+
+HttpClient::HttpClient(std::string product) : product_(product){
+    request_ = nullptr;
+    session_ = nullptr;
+    file_ = nullptr;
+    memset(userdata_, 0, sizeof(userdata_));
+}
+
+HttpClient::~HttpClient() {
+    Uninit();
+}
+
+bool HttpClient::Get(GURL url, std::string fname) {
+    std::string scheme = url.scheme();
+    std::string hostname = url.host();
+    int port = atoi(url.port().c_str());
+    std::string method = "GET";
+    std::string path = url.path();
+
+    LOG(INFO) << __func__ << " HttpClient => "
+        << " scheme=" << scheme << " hostname=" << hostname
+        << " port=" << port << " method=" << method << " path=" << path; 
+
+    bool isok = false;
+    do {
+        if (!file_) {
+            file_ = fopen(fname.c_str(), "wb");
+            if (!file_) break;
+        }
+
+        if (!Init(scheme, hostname, port)) break;
+        if (!Request(method, path)) break;
+
+        AddRequestHeader("Host", hostname);
+        AddRequestHeader("Accept", "*/*");
+        AddRequestHeader("User-Agent", product_);
+        AddRequestHeader("Content-Length", 0);
+        RequestDispatch();
+        isok = true;
+    }while(false);
+    Uninit();
+    
+    return isok;
+}
+
+bool HttpClient::Init(std::string scheme, std::string hostname, int port) {
+    ne_session* session = ne_session_create(scheme.c_str(), hostname.c_str(), port);
+    if (!session) return false;
+    session_ = (void*)session;
+
+    if (!product_.empty()) {
+        //ne_set_useragent((ne_session *)session_, product_.c_str());
+    }
+    return true;
+}
+
+int HttpClient::OnReaderCallback(const char *buf, size_t len) {
+    if (!buf || len <= 0) return 0;
+    if (file_) {
+        fwrite(buf, 1, len, file_);
+    }
+    return 0;
+}
+
+static int ne_block_reader_callback(void *userdata, const char *buf, size_t len) {
+    HttpClient* thiz = (HttpClient*)userdata;
+    if (thiz) {
+        thiz->OnReaderCallback(buf, len);
+    }
+    
+    return 0;
+}
+
+bool HttpClient::Request(std::string method, std::string path) {
+    if (!session_) return false;
+    ne_request* request = ne_request_create((ne_session *)session_, method.c_str(), path.c_str());
+    if (!request) return false;
+    request_ = (void*)request;
+    return true;
+}
+
+void HttpClient::Uninit() {
+    if (request_) {
+        ne_request_destroy((ne_request *)request_);
+        request_ = nullptr;
+    }
+
+    if (session_) {
+        ne_close_connection((ne_session *)session_);
+        ne_session_destroy((ne_session *)session_);
+        session_ = nullptr;
+    }
+
+    if (file_) {
+        fclose(file_);
+        file_ = nullptr;
+    }
+}
+
+int HttpClient::RequestDispatch() {
+    if (!request_) return -1;
+    ne_add_response_body_reader((ne_request *)request_, 
+            ne_accept_always, ne_block_reader_callback, (void*)this);
+    int iret = ne_request_dispatch((ne_request *)request_);
+    return iret;
+}
+
+int HttpClient::AddRequestHeader(std::string name, std::string value) {
+    if (!request_ || name.empty()) return -1;
+    ne_add_request_header((ne_request *)request_, name.c_str(), value.c_str());
+    return 0;
+}
+
+int HttpClient::GetResponseHeader(std::string name, std::string& value) {
+    if (!request_ || name.empty()) return -1;
+    const char* pval = ne_get_response_header((ne_request *)request_, name.c_str());
+    if (pval) {
+        value = pval;
+    }
+    return 0;
+}
+
+int HttpClient::SetReadTimeout(int timeout) {
+    if (!session_) return -1;
+    ne_set_read_timeout((ne_session *)session_, timeout);
+    return 0;
+}
+
+int HttpClient::SetConnectTimeout(int timeout) {
+    if (!session_) return -1;
+    ne_set_connect_timeout((ne_session *)session_, timeout);
+    return 0;
+}
+
+/**
+ * void ne_set_request_body_buffer(ne_request *req, const char *buf, size_t count);
+ */
+int HttpClient::SetRequestBodyBuffer(const char* buffer, int count) {
+    if (!buffer || count <= 0) return -1;
+    if (!request_) return -1;
+    ne_set_request_body_buffer((ne_request *)request_, buffer, count);
+    return 0;
+}
+
+/**
+ * const ne_status *ne_get_status(const ne_request *request);
+ */
+int HttpClient::GetStatus(){
+    if (!request_) return -1;
+
+    const ne_status* status = ne_get_status((const ne_request *)request_);
+    if (status) {
+        //status->major_version,status->minor_version, status->code, status->klass,status->reason_phrase 
+        return status->code;
+    }
+    return -1;
+}
+
+static int ne_auth_creds_callback(void *userdata, const char* realm, int attempt, 
+    char *username, char *password)
+{
+    HttpClient* thiz = (HttpClient*) userdata;
+    if (thiz) {
+        thiz->OnAuthCreds(username, password);
+    }
+    return attempt;
+}
+
+int HttpClient::OnAuthCreds(char *username, char *password) {
+    char *sep = strstr((char *)userdata_, ":");
+    if (sep) {
+        int ilen = (int)(sep - (char *)userdata_);
+        int ulen = (ilen <= NE_ABUFSIZ) ? ilen : NE_ABUFSIZ;
+        strncpy(username, userdata_, ulen);
+        strncpy(password, userdata_+(ilen+1), NE_ABUFSIZ);
+    }
+    return 0;
+}
+
+int HttpClient::SetServerAuth(const char* userdata) {
+    if (!session_) return -1;
+    ne_set_server_auth((ne_session*)session_, ne_auth_creds_callback, (void *)this);
+    return 0;
+}
+
+} // namespace mmt
diff --git a/net/mmt/mmt_http.h b/net/mmt/mmt_http.h
new file mode 100644
index 0000000..0f7d898
--- /dev/null
+++ b/net/mmt/mmt_http.h
@@ -0,0 +1,47 @@
+#ifndef NET_MMT_MMT_HTTP_H_
+#define NET_MMT_MMT_HTTP_H_
+
+#include "base/memory/ref_counted.h"
+#include "url/gurl.h"
+
+namespace mmt {
+
+class HttpClient : public base::RefCounted<HttpClient> {
+public:
+    explicit HttpClient(std::string product);
+    bool Get(GURL url, std::string fname);
+
+    bool Init(std::string scheme, std::string hostname, int port);
+    bool Request(std::string method, std::string path);
+    void Uninit();
+
+    int RequestDispatch();
+    int AddRequestHeader(std::string name, std::string value);
+    int GetResponseHeader(std::string name, std::string& value);
+
+    int SetConnectTimeout(int timeout);
+    int SetReadTimeout(int timeout);
+    int SetRequestBodyBuffer(const char* buffer, int count);
+    int GetStatus();
+    int SetServerAuth(const char* userdata);
+
+    int OnReaderCallback(const char *buf, size_t len);
+    int OnAuthCreds(char *username, char *password);
+
+protected:
+    friend class base::RefCounted<HttpClient>;
+    virtual ~HttpClient();
+
+private:
+    std::string product_;
+    char  userdata_[1024];
+
+    void* session_;
+    void* request_;
+    FILE* file_;
+};
+typedef scoped_refptr<HttpClient> HttpClientPtr;
+
+}
+
+#endif
diff --git a/net/net.gypi b/net/net.gypi
index ea5c471..0e84362 100644
--- a/net/net.gypi
+++ b/net/net.gypi
@@ -704,6 +704,7 @@
       'mmt/mmt_parser.cc',
       'mmt/mmt_stream.cc',
       'mmt/mmt_utils.cc',
+      'mmt/mmt_http.cc',
       'ocsp/nss_ocsp.cc',
       'ocsp/nss_ocsp.h',
       'proxy/dhcp_proxy_script_adapter_fetcher_win.cc',
-- 
1.7.9.5


From 932e8108872d9f1c8bb1e7d7f29d95ffdc3bed5a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 21:45:11 +0800
Subject: [PATCH 106/128] [todo] support sub xml

---
 net/mmt/mmt_control.cc |   29 +++++++++++++++++++++++++++--
 net/mmt/mmt_control.h  |    9 +++++++--
 net/mmt/mmt_parser.cc  |   18 +++++++++++++++---
 net/mmt/mmt_parser.h   |    1 +
 4 files changed, 50 insertions(+), 7 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 92e29f2..026f41c 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -176,7 +176,11 @@ void MmtControl::StreamOpen(ctrl_msg_t msg) {
                     // for sub xml
                     if (stream->GetMtype() == kMmtMediaCI) {
                         LOG(INFO) << __func__ << " find one sub xml=" << msg.url.spec();
-                        cixml->subxmls.push_back(msg.url.spec());
+                        xmlinfo_t xml; 
+                        xml.fname = msg.url.spec(); 
+                        xml.timeout = 0;
+                        cixml->subxmls.push_back(xml);
+                        break;
                     }
                 }
             } 
@@ -252,6 +256,7 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
 void MmtControl::CheckEvent() {
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
+        int tabid = iter->first;
         cixmlptr_t cixml = iter->second;
         if (!cixml) continue;
         if (cixml->status == "end") continue;
@@ -293,6 +298,7 @@ void MmtControl::CheckEvent() {
                 int64 timestamp = cixml->parser->GetTimestamp();
                 std::string version = cixml->parser->GetVersion();
                 CiParserPtr parser2 = new CiParser(xml_name);
+                LOG(INFO) << __func__ << " [ParseXML] xml=" << xml_name;
                 if(parser2->ParseXml()) {
                     int64 timestamp2 = parser2->GetTimestamp();
                     std::string version2 = parser2->GetVersion();
@@ -301,7 +307,7 @@ void MmtControl::CheckEvent() {
                         << " new timestamp=" << timestamp2 << " version=" << version2;
 
                     if (ntp >= timestamp2 && timestamp < timestamp2) {
-                        parser2->SetTabId(iter->first);
+                        parser2->SetTabId(tabid);
                         if(parser2->ParseHtml()) {
                             parser2->MergeCI(cixml->parser.get());
                             cixml->parser = parser2;
@@ -315,6 +321,25 @@ void MmtControl::CheckEvent() {
                 parser2 = nullptr;
             }
 
+            if (cixml->parser && !cixml->subxmls.empty()) {
+                std::vector<xmlinfo_t>::iterator iter_sx;
+                for (iter_sx=cixml->subxmls.begin(); iter_sx != cixml->subxmls.end(); iter_sx++) {
+                    if (iter_sx->timeout == 0) {
+                        CiParserPtr parser2 = new CiParser(iter_sx->fname);
+                        LOG(INFO) << __func__ << " [ParseXML] xml=" << iter_sx->fname;
+                        if(parser2->ParseXml()) { // if failed maybe not got this xml, waiting for next time
+                            parser2->SetTabId(tabid); // should be called before ParserHtml
+                            if(parser2->ParseHtml()) {
+                                parser2->MergeCI(cixml->parser.get());
+                                cixml->parser = parser2;
+                            }
+                            iter_sx->timeout = 1;
+                        }
+                        parser2 = nullptr;
+                    }
+                }
+            }
+            
             if (cixml->parser && cixml->postui) {
                 std::string js0, js1;
                 cixml->parser->GetSubXmlJS(ntp, js0);
diff --git a/net/mmt/mmt_control.h b/net/mmt/mmt_control.h
index 443d740..0038e09 100644
--- a/net/mmt/mmt_control.h
+++ b/net/mmt/mmt_control.h
@@ -66,15 +66,20 @@ struct ctrl_msg_t {
 /**
  * Structure for CI XML. 
  */
+struct xmlinfo_t {
+    std::string fname;   //> xml file name, but is url actually
+    int timeout;
+};
+
 struct cixml_t : public base::RefCounted<cixml_t> {
 public:
     cixml_t();
 
-    std::string fname;      //> xml file name
+    std::string fname;      //> xml file name, but is url actually
     std::string status;     //> ci status: initing,loading,loaded
     std::string proto;      //> "local" or "mmtp"
 
-    std::vector<std::string> subxmls; //> sub xmls
+    std::vector<xmlinfo_t> subxmls; //> sub xmls
     int update;             //> check interval of updating xml
     CiParserPtr parser;     //> xml parser for ci
     job_refptr_t job;       //> UrlRequestMmtJob object
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index f230cc6..47815c2 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -512,7 +512,9 @@ nodeptr_t FindSubNode(nodeptr_t node1, nodeptr_t node2) {
     return nullptr;
 }
 
-// merge old pasrer's CI into this new CI
+/**
+ *  only update the status of current xml with another xml's same node.
+ */
 bool CiParser::MergeCI(CiParser* parser) {
     if (!root_ || !parser || !parser->root_) return false;
     nodeptr_t node = root_;
@@ -526,16 +528,26 @@ bool CiParser::MergeCI(CiParser* parser) {
             for(iter2=sub1->nodes.begin(); iter2 != sub1->nodes.end(); iter2++ ){
                 nodeptr_t sub2 = *iter2;
                 nodeptr_t sub3 = FindSubNode(oldnode, sub2);
-                MergeNode(sub2, sub3);
+                if (sub2 && sub3)
+                    MergeNode(sub2, sub3);
             }
         }
         nodeptr_t sub2 = FindSubNode(oldnode, sub1);
-        MergeNode(sub1, sub2);  // merge old into new
+        if (sub1 && sub2)
+            MergeNode(sub1, sub2);  // merge old into new
     }
 
     return true;
 }
 
+/**
+ *  first, update the status of current xml with another xml's same node.
+ *  second, add new node from another xml's same node
+ */
+bool CiParser::MergeCI2(CiParser* parser) {
+    return false;
+}
+
 
 /**
  * To process both @begin and @end
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 7c282c5..7432d78 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -112,6 +112,7 @@ public:
      * To Merge another parser
      */
     bool MergeCI(CiParser* parser);
+    bool MergeCI2(CiParser* parser);
 
     /**
      * To get current js to operate
-- 
1.7.9.5


From fef3b66f6c97bf7f4d3e9a83522663108f365c2a Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 22:36:11 +0800
Subject: [PATCH 107/128] [ok] for support subxml's local and http

---
 net/mmt/mmt_http.cc   |   11 +++++++++--
 net/mmt/mmt_http.h    |    2 +-
 net/mmt/mmt_stream.cc |    8 ++++++++
 3 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/net/mmt/mmt_http.cc b/net/mmt/mmt_http.cc
index 4a569e0..7e320a7 100644
--- a/net/mmt/mmt_http.cc
+++ b/net/mmt/mmt_http.cc
@@ -40,10 +40,12 @@ HttpClient::~HttpClient() {
     Uninit();
 }
 
-bool HttpClient::Get(GURL url, std::string fname) {
+bool HttpClient::Get(GURL& url, std::string fname) {
     std::string scheme = url.scheme();
+    if (scheme == "mmt") scheme = "http";
     std::string hostname = url.host();
     int port = atoi(url.port().c_str());
+    if (port <= 0) port = 80;
     std::string method = "GET";
     std::string path = url.path();
 
@@ -53,18 +55,23 @@ bool HttpClient::Get(GURL url, std::string fname) {
 
     bool isok = false;
     do {
+        LOG(INFO) << __func__ << " open file";
         if (!file_) {
             file_ = fopen(fname.c_str(), "wb");
             if (!file_) break;
         }
 
+        LOG(INFO) << __func__ << " init http lib";
         if (!Init(scheme, hostname, port)) break;
+        LOG(INFO) << __func__ << " request http";
         if (!Request(method, path)) break;
 
+        LOG(INFO) << __func__ << " add header";
         AddRequestHeader("Host", hostname);
         AddRequestHeader("Accept", "*/*");
         AddRequestHeader("User-Agent", product_);
-        AddRequestHeader("Content-Length", 0);
+        AddRequestHeader("Content-Length", "0");
+        LOG(INFO) << __func__ << " request dispatch";
         RequestDispatch();
         isok = true;
     }while(false);
diff --git a/net/mmt/mmt_http.h b/net/mmt/mmt_http.h
index 0f7d898..78f40de 100644
--- a/net/mmt/mmt_http.h
+++ b/net/mmt/mmt_http.h
@@ -9,7 +9,7 @@ namespace mmt {
 class HttpClient : public base::RefCounted<HttpClient> {
 public:
     explicit HttpClient(std::string product);
-    bool Get(GURL url, std::string fname);
+    bool Get(GURL& url, std::string fname);
 
     bool Init(std::string scheme, std::string hostname, int port);
     bool Request(std::string method, std::string path);
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 6b7a9a3..c49d13d 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -3,6 +3,7 @@
 #include "net/mmt/mpu/mp4.h"
 #include "net/mmt/mmtp/mmtp.h"
 #include "net/mmt/mmt_control.h"
+#include "net/mmt/mmt_http.h"
 
 namespace mmt {
 
@@ -388,6 +389,13 @@ void* Stream::Open(const char* filename, int mode) {
         }
     }else if (proto_ == kMmtProtoExtra) {
         // TODO: for extra proto, such as http/ftp. now sub xml will be got by it.
+        base::FilePath cpath;
+        base::GetCurrentDirectory(&cpath);
+        base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
+        fname = fpath.value() + "/" + htmlid_ + ".xml";
+        LOG(INFO) << __func__ << " <extra> fname=" << fname;
+        HttpClientPtr http = new HttpClient("mmtp/1.0");
+        http->Get(url_, fname);
     }else {
         LOG(INFO) << __func__ << " invalid proto=" << proto_;
         return nullptr;
-- 
1.7.9.5


From ae5e94c5e3c4bb710a9c3014ca6c5229bce31c14 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 11 Feb 2015 22:59:38 +0800
Subject: [PATCH 108/128] [ok] add docs and log control

---
 README.md             |   25 +++++++++++++++++++++++++
 net/mmt/mmt_http.cc   |    6 +++---
 net/mmt/mmt_parser.cc |    4 ++++
 net/mmt/mmt_stream.cc |    2 ++
 4 files changed, 34 insertions(+), 3 deletions(-)
 create mode 100644 README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..081bc5f
--- /dev/null
+++ b/README.md
@@ -0,0 +1,25 @@
+mmt documemts
+=============
+
+# all kinds of url formats
+
+## ?proto=mmtp:  
+    for html resource
+
+## ?proto=mmtp&type=audio/video/image[&htmlid=&tabid=]: 
+    for mmtp's media, must have htmlid added by chromium
+    [..] added by chromium.
+
+## mmtp main xml:
+    got by API directly in mmt_control
+
+## ?proto=extra[&type=ci&htmlid=&tabid=]: 
+    for subset ci and get it by neon http
+    [..] added by chromium.
+
+## ?type=ci[&htmlid=&tabid=]
+    for subset ci and get it by local,
+    [..] added by chromium auto.
+
+## default mmt local format
+    mmt://localhost/ + abs path
diff --git a/net/mmt/mmt_http.cc b/net/mmt/mmt_http.cc
index 7e320a7..8699897 100644
--- a/net/mmt/mmt_http.cc
+++ b/net/mmt/mmt_http.cc
@@ -55,7 +55,7 @@ bool HttpClient::Get(GURL& url, std::string fname) {
 
     bool isok = false;
     do {
-        LOG(INFO) << __func__ << " open file";
+        //LOG(INFO) << __func__ << " open file";
         if (!file_) {
             file_ = fopen(fname.c_str(), "wb");
             if (!file_) break;
@@ -63,10 +63,10 @@ bool HttpClient::Get(GURL& url, std::string fname) {
 
         LOG(INFO) << __func__ << " init http lib";
         if (!Init(scheme, hostname, port)) break;
-        LOG(INFO) << __func__ << " request http";
+        //LOG(INFO) << __func__ << " request http";
         if (!Request(method, path)) break;
 
-        LOG(INFO) << __func__ << " add header";
+        //LOG(INFO) << __func__ << " add header";
         AddRequestHeader("Host", hostname);
         AddRequestHeader("Accept", "*/*");
         AddRequestHeader("User-Agent", product_);
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 47815c2..d26a130 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -614,7 +614,9 @@ bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
         }
     }while(true);
 
+#ifdef MMT_LOG_V
     LOG(INFO) << __func__ << " node name=" << end.id << " curtime=" << curtime << " current=" << current;
+#endif
     if (curtime >= 0 && curtime <= current) {
         cnode->time.end.is_timeout = 1;
         return true;
@@ -707,7 +709,9 @@ bool CiParser::GetSubXmlJS(int64 current, std::string& js) {
 }
 
 bool CiParser::AddNode(std::string name) {
+#ifdef MMT_LOG_V
     LOG(INFO) << __func__ << " parent=" << (cur_? cur_->name : "root") << " node=" << name;
+#endif
     nodeptr_t node = new node_t(name);
     if (!root_)  {
         root_ = node;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index c49d13d..ec9fe5d 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -114,8 +114,10 @@ void MmtpRecvCallback(struct mmtp_rinfo_t* rinfo) {
 
     base::FilePath cpath(rinfo->fname);
     base::FilePath fpath = base::MakeAbsoluteFilePath(cpath);
+#ifdef MMT_LOG_V
     LOG(INFO) << __func__ << " fname=" << rinfo->fname << 
         " ftype=" << ftype << " fpath=" << fpath.value() << " seq=" << rinfo->index;
+#endif
 
     mmtp_info_t mmtp;
     mmtp.url = rinfo->url;
-- 
1.7.9.5


From fcbb3f0b1a335c3cbd3f840ac25bac40f9388b3b Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 12 Feb 2015 01:32:27 +0800
Subject: [PATCH 109/128] [todo] add the support of case1

---
 README.md              |    6 ++++++
 net/mmt/mmt_control.cc |    8 ++++++--
 net/mmt/mmt_parser.cc  |   35 ++++++++++++++++++++++++++++++-----
 3 files changed, 42 insertions(+), 7 deletions(-)

diff --git a/README.md b/README.md
index 081bc5f..0330fa4 100644
--- a/README.md
+++ b/README.md
@@ -23,3 +23,9 @@ mmt documemts
 
 ## default mmt local format
     mmt://localhost/ + abs path
+
+## right format
+    <video></video>,  <video /><audio />
+
+## support "click", now not support "Click".
+
diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 026f41c..76c37e7 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -343,9 +343,13 @@ void MmtControl::CheckEvent() {
             if (cixml->parser && cixml->postui) {
                 std::string js0, js1;
                 cixml->parser->GetSubXmlJS(ntp, js0);
-                LOG(INFO) << __func__ << " js0 => " << js0;
+                if (!js0.empty()) {
+                    LOG(INFO) << __func__ << " js0 => " << js0;
+                }
                 cixml->parser->GetHtmlJS(ntp, js1);
-                LOG(INFO) << __func__ << " js1 => " << js1;
+                if (!js1.empty()) {
+                    LOG(INFO) << __func__ << " js1 => " << js1;
+                }
                 std::string js = js0 + js1;
                 if(!js.empty()) {
 #ifdef USE_MMT_NATIVE_MESSAGE
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index d26a130..06cd553 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -126,7 +126,23 @@ inline std::string SetJSEvent(std::string id, std::string name, std::string valu
 inline std::string SetJSEnd() {
     return "}";
 }
-inline std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
+inline std::string SetDivJSClear(std::string id) {
+    return "clearChildNodes(g_"+id+");";
+}
+
+std::string SetDivJSBegin() {
+    std::string js;
+    js += "function clearChildNodes(e0) {";
+    js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
+    js += " if (e1.nodeType == 1) {";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
+    js += "         if (e1.pause != undefined) e1.pause();";
+    js += "         e1.src = '';";
+    js += "         clearChildNodes(e1);";
+    js += "}}}}";
+    return js;
+}
+std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
     std::string js;
     href = href + "&type=" + kMmtMediaCI;
     js = "var div = document.createElement('div');";
@@ -269,6 +285,12 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
         js1 += SetJSAttr(id, "style", style);
     }
 
+    // process div
+    if (node->name == kdivLocation) {
+        // no-op for begin, but have op for end
+        js1 += SetDivJSClear(id);
+    }
+
     // set media src
     if (node->name == kMediaSync) {
         bool bfind = false;
@@ -306,10 +328,10 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
 
     htmlptr_t html = new html_t;
     html->node = node;
-    html->js[EHtmlBegin] = js0;
-    html->js[EHtmlEnd] = js1;
-    html->js[EHtmlClickBegin] = js00;
-    html->js[EHtmlClickEnd] = js11;
+    html->js[EHtmlBegin] = js0;       //> self's begin
+    html->js[EHtmlEnd] = js1;         //> self's end
+    html->js[EHtmlClickBegin] = js00; //> other use this click when time begin.
+    html->js[EHtmlClickEnd] = js11;   //> other use this click when time end. to stop actions started in EHtmlClickBegin.
     htmls[id] = html;
 }
 
@@ -630,6 +652,9 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
 
     std::string js1, js2;
 
+    // add util function
+    js1 = SetDivJSBegin();
+
     // init js object
     htmlmap_t::iterator iter;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
-- 
1.7.9.5


From 19bfbfae976eb095380953ecc28120c3f9e41fab Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 12 Feb 2015 02:38:21 +0800
Subject: [PATCH 110/128] [ok] for case1

---
 net/mmt/mmt_parser.cc |   76 ++++++++++++++++++++++++++++++++-----------------
 net/mmt/mmt_parser.h  |    3 +-
 2 files changed, 51 insertions(+), 28 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 06cd553..f073a81 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -120,8 +120,11 @@ inline std::string SetJSFunc(std::string id, std::string name) {
     std::string func = "g_"+id+"."+name;
     return "if("+func+" != undefined) {" + func + "();}";  
 }
-inline std::string SetJSEvent(std::string id, std::string name, std::string value) {
-    return "g_"+id+"."+name+" = function() {" + value + "}";  
+inline std::string SetJSEventBegin(std::string id, std::string name) {
+    return "g_"+id+"."+name+" = function() {";  
+}
+inline std::string SetJSEventEnd() {
+    return "}";  
 }
 inline std::string SetJSEnd() {
     return "}";
@@ -130,7 +133,7 @@ inline std::string SetDivJSClear(std::string id) {
     return "clearChildNodes(g_"+id+");";
 }
 
-std::string SetDivJSBegin() {
+std::string SetDivJSUtils() {
     std::string js;
     js += "function clearChildNodes(e0) {";
     js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
@@ -275,9 +278,9 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     if (id.empty()) return;
 
     std::string js0, js1;       // for time of begin and end
-    std::string js00, js11;     // for click event of begin and end
-    js0 = js1 = SetJSBegin(id);
-    js00 = js11 = SetJSBegin(id);
+    std::string js2;            // for event, e.g. onclick
+    js0 = js1 = js2 = SetJSBegin(id);
+    js2 += SetJSEventBegin(id, "onclick");
 
     std::string style = node->attrs[kstyle];
     if (!style.empty()) {
@@ -328,10 +331,10 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
 
     htmlptr_t html = new html_t;
     html->node = node;
+    html->id = id;                    //> html tag id
     html->js[EHtmlBegin] = js0;       //> self's begin
     html->js[EHtmlEnd] = js1;         //> self's end
-    html->js[EHtmlClickBegin] = js00; //> other use this click when time begin.
-    html->js[EHtmlClickEnd] = js11;   //> other use this click when time end. to stop actions started in EHtmlClickBegin.
+    html->js[EHtmlClick] = js2;       //> other use this click.
     htmls[id] = html;
 }
 
@@ -361,7 +364,7 @@ bool CiParser::ParseHtml() {
     for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
         nodeptr_t sub1 = *iter1;
         if (sub1->name == kview) {
-            if (sub1->nodes.empty()) { // for subset nodes
+            if (sub1->nodes.empty()) { // for subset xml nodes
                 std::string href, actuate;
                 if(sub1->attrs.find(kxlinkhref) != sub1->attrs.end()) {
                     href = sub1->attrs[kxlinkhref];
@@ -396,9 +399,10 @@ bool CiParser::ParseHtml() {
         }
     }
 
-    // process html js
+    ///===================
+
     htmlmap_t::iterator iter;
-    // end for time
+    // process end of time js
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         if (iter->first == "html") continue;
@@ -414,8 +418,8 @@ bool CiParser::ParseHtml() {
         event_t begin = node->time.begin;
         if (begin.is_event) {
             if (begin.event == kevclick) {
-                std::string js = SetJSEvent(begin.id, "onclick", html->js[EHtmlBegin]);
-                htmls_[begin.id]->js[EHtmlClickBegin] += js;
+                if (htmls_.find(begin.id) != htmls_.end())
+                    htmls_[begin.id]->js[EHtmlClick] += html->js[EHtmlBegin];
             }else if (begin.event == kevbegin || begin.event == kevend) {
                 SetNodeTime(node->time.begin, node);
             }
@@ -424,20 +428,20 @@ bool CiParser::ParseHtml() {
         event_t end = node->time.end;
         if (end.is_event) {
             if (end.event == kevclick) {
-                std::string js = SetJSEvent(end.id, "onclick", html->js[EHtmlEnd]);
-                htmls_[end.id]->js[EHtmlClickEnd] += js;
+                if (htmls_.find(end.id) != htmls_.end())
+                    htmls_[end.id]->js[EHtmlClick] += html->js[EHtmlEnd];
             }else if (end.event == kevbegin || end.event == kevend) {
                 SetNodeTime(node->time.end, node);
             }
         }
     }
 
-    // process end for event click
+    // process end of event click
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
-        html->js[EHtmlClickBegin] += SetJSEnd();
-        html->js[EHtmlClickEnd] += SetJSEnd();
+        html->js[EHtmlClick] += SetJSEventEnd();
+        html->js[EHtmlClick] += SetJSEnd();
     }
     return true;
 }
@@ -582,7 +586,7 @@ bool CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
     if (begin.is_timeout > 0) return false;
 
     if (begin.event == kevclick) {
-        ev = EHtmlClickBegin;
+        ev = EHtmlClick;
         cnode->time.begin.is_timeout = 1;
         return true;
     }else {
@@ -617,7 +621,7 @@ bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
     if (end.is_timeout > 0) return false;
 
     if (end.event == kevclick) {
-        ev = EHtmlClickEnd;
+        ev = EHtmlClick;
         cnode->time.end.is_timeout = 1;
         return true;
     }else {
@@ -646,6 +650,9 @@ bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
     return false;
 }
 
+/**
+ * TODO: try to split js to execute seperately to avoid failure.
+ */
 bool CiParser::GetHtmlJS(int64 current, std::string& js) {
     js = "";
     if (htmls_.empty()) return false;
@@ -653,7 +660,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
     std::string js1, js2;
 
     // add util function
-    js1 = SetDivJSBegin();
+    js1 = SetDivJSUtils();
 
     // init js object
     htmlmap_t::iterator iter;
@@ -662,24 +669,41 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
         js1 += GetJSObject(id);
     }
 
-    // add js process
+    // add js process, TODO: try to remove repeated scripts.
     int ev;
+    std::map<std::string, int> jsmap;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
         if (ShouldEndTime(current, node, ev)) {
-            if (ev == EHtmlClickEnd)
+            if (ev == EHtmlClick)
                 html = htmls_[node->time.end.id];
-            if (html) js2 += html->js[ev];
+            if (html) {
+                std::string key = html->id+"@"+Int2String(ev,2);
+                if (jsmap.find(key) == jsmap.end()) {
+                    js2 += html->js[ev];
+                    jsmap[key] = 1;
+                }else {
+                    LOG(INFO) << __func__ << " begin exist, key=" << key;
+                }
+            }
         }
     }
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
         if (ShouldBeginTime(current, node, ev)) {
-            if (ev == EHtmlClickBegin)
+            if (ev == EHtmlClick)
                 html = htmls_[node->time.begin.id];
-            if (html) js2 += html->js[ev];
+            if (html) {
+                std::string key = html->id+"@"+Int2String(ev,2);
+                if (jsmap.find(key) == jsmap.end()) {
+                    js2 += html->js[ev];
+                    jsmap[key] = 1;
+                }else {
+                    LOG(INFO) << __func__ << " end exist, key=" << key;
+                }
+            }
         }
     }
 
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 7432d78..09db02c 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -24,8 +24,7 @@ typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name =>
 enum EHtmlEvent{
     EHtmlBegin,         //> mmtci:begin
     EHtmlEnd,           //> mmtci:end
-    EHtmlClickBegin,    //> mmtci:begin's .click
-    EHtmlClickEnd,      //> mmtci:end's .click
+    EHtmlClick,
     EHtmlSubXml,
 };
 
-- 
1.7.9.5


From e7b935515b2febf23fab2c18a8f593e3cf8f73b3 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 15 Feb 2015 11:16:34 +0800
Subject: [PATCH 111/128] [todo] update mpu tool

---
 README.md                  |    2 +-
 net/mmt/mpu/stream.h       |   14 ++++++++------
 net/mmt/mpu/test_parser.cc |   32 +++++++++++++++++++++++++++++---
 3 files changed, 38 insertions(+), 10 deletions(-)

diff --git a/README.md b/README.md
index 0330fa4..2af10b9 100644
--- a/README.md
+++ b/README.md
@@ -17,7 +17,7 @@ mmt documemts
     for subset ci and get it by neon http
     [..] added by chromium.
 
-## ?type=ci[&htmlid=&tabid=]
+## ?[type=ci&htmlid=&tabid=]
     for subset ci and get it by local,
     [..] added by chromium auto.
 
diff --git a/net/mmt/mpu/stream.h b/net/mmt/mpu/stream.h
index 9815bb1..6cdbeec 100644
--- a/net/mmt/mpu/stream.h
+++ b/net/mmt/mpu/stream.h
@@ -21,6 +21,10 @@ typedef unsigned long long uint64_t;
 #define MODE_EXISTING         (4)
 #define MODE_CREATE           (8)
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 // .
 typedef struct stream {
    void* (*open)(struct stream *stream_s, const char* filename, int mode);
@@ -51,15 +55,9 @@ uint64_t file_seek(stream_t *stream_s, int64_t offset, int whence);
 uint64_t file_tell(stream_t *stream_s);
 int file_close(stream_t *stream_s);
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 // .
 stream_t* create_file_stream();
 void destory_file_stream(stream_t* stream_s);
-#ifdef __cplusplus
-}
-#endif
 
 
 // stream.
@@ -147,4 +145,8 @@ int write_be32(stream_t *dst, uint32_t value);
 int write_le64(stream_t *dst, uint64_t value);
 int write_be64(stream_t *dst, uint64_t value);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif // NET_MMT_MPU_STREAM_H_
diff --git a/net/mmt/mpu/test_parser.cc b/net/mmt/mpu/test_parser.cc
index 163ef33..db65e88 100644
--- a/net/mmt/mpu/test_parser.cc
+++ b/net/mmt/mpu/test_parser.cc
@@ -4,6 +4,26 @@
 #include "stream.h"
 #include "mp4.h"
 
+void update_mdat(stream_t* s, long pos, uint64_t size) {
+    if (!s) return;
+    uint64_t pre = stream_tell(s);
+    stream_seek(s, 0, SEEK_END);
+    long fsize = stream_tell(s);
+    if (pos + (long)size != fsize) {
+        uint32_t real = fsize - pos;
+        printf("invalid mdat size: pos=%ld, size=%llu, fsize=%ld, real=%u\n", pos, size, fsize, real);
+        stream_seek(s, pos, SEEK_SET);
+        stream_read(s, &real, 4);
+        real = Swap32(real);
+        printf("read size=%u\n", real);
+
+        real = Swap32((uint32_t)(fsize - pos));
+        stream_seek(s, pos, SEEK_SET);
+        stream_write(s, &real, 4);
+        printf("update read size=%ld\n", fsize - pos);
+    }
+}
+
 mp4_box_t* print_traf(mp4_box_t* box) {
     printf("\n");
     do {
@@ -15,18 +35,23 @@ mp4_box_t* print_traf(mp4_box_t* box) {
         if (!box) break;
         else {
             printf("tfhd: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
-            printf("tfhd: version:%d, flags:%d, trackid=%d offset=%llu size=%u\n", 
+            printf("tfhd: version:%d, flags:%d, trackid=%d base offset=%llu smaple idx=%u sample size=%u flags=%u\n", 
                 box->data.p_tfhd->version, box->data.p_tfhd->flags, box->data.p_tfhd->track_ID,
-                box->data.p_tfhd->base_data_offset, box->data.p_tfhd->default_sample_size);
+                box->data.p_tfhd->base_data_offset, 
+                box->data.p_tfhd->sample_description_index,
+                box->data.p_tfhd->default_sample_size,
+                box->data.p_tfhd->default_sample_flags);
         }
 
         box = MP4_BoxSearchBox(box, ATOM_trun);
         if (!box) break;
         else {
             printf("trun: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+            if (box->data.p_trun->flags & MP4_TRUN_DATA_OFFSET)
             printf("trun: version:%d, flags:%d, sample-count=%d offset=%u\n", 
                 box->data.p_trun->version, box->data.p_trun->flags, box->data.p_trun->sample_count,
                 box->data.p_trun->data_offset);
+
         }
     }while(0);
     printf("\n");
@@ -44,7 +69,7 @@ int main(int argc, char* argv[])
     stream_t* s = NULL;
 
     s = create_file_stream();
-    if (stream_open(s, argv[1], MODE_READ) == 0)
+    if (stream_open(s, argv[1], MODE_EXISTING) == 0)
         return -1;
 
     root = MP4_BoxGetRoot(s);
@@ -76,6 +101,7 @@ int main(int argc, char* argv[])
         box = MP4_BoxSearchBox(box, ATOM_mdat);
         if (!box) break;
         printf("mdat: %p pos: %ld size: %llu\n", box, box->i_pos, box->i_size);
+        //update_mdat(s, box->i_pos, box->i_size);
     }while(1);
 
     MP4_BoxFree(s, root);
-- 
1.7.9.5


From ea782ca48272f6298615287c47acc28c811f6e3f Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 15 Feb 2015 11:37:46 +0800
Subject: [PATCH 112/128] [todo] refine mmt_parser's log

---
 net/mmt/mmt_parser.cc |    6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index f073a81..d50b883 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -75,11 +75,13 @@ static void sax_comment(void *x,const xmlChar *value) {
     fprintf(stdout, "[xml][comment] %s\n", value);
 }
 static void sax_error(void *x,const char *msg,...){
+#ifdef MMT_LOG_V
     va_list ap;
     va_start(ap,msg);
     fputs("[xml][error] ",stderr);
     vfprintf(stderr,msg,ap);
     va_end(ap);
+#endif
 }
 
 static void init_sax(xmlSAXHandlerPtr sax) {
@@ -807,11 +809,15 @@ bool ParseTimeEvent(std::string value, event_t& event) {
         event.is_event = true;
         event.id = value.substr(0, pos);
         event.event = value.substr(pos);
+#ifdef MMT_LOG_V
         LOG(INFO) << __func__ << " event.id=" << event.id << " event.event=" << event.event;
+#endif
     }else {
         event.is_event = false;
         event.time = ParseTimeStr(value);
+#ifdef MMT_LOG_V
         LOG(INFO) << __func__ << " event.time=" << event.time;
+#endif
     }
     return true;
 }
-- 
1.7.9.5


From 04a6e74c272cd5ccee48e1cb784007671e8267a3 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 15 Feb 2015 13:01:19 +0800
Subject: [PATCH 113/128] [todo] add fault-tolerant of mpu parse

---
 net/mmt/mmt_inc.h     |    1 +
 net/mmt/mmt_stream.cc |   76 +++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_stream.h  |   11 +++----
 3 files changed, 62 insertions(+), 26 deletions(-)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 0837837..4bb807a 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -5,6 +5,7 @@
 #include <sstream>
 #include <iomanip>
 #include <vector>
+#include <algorithm>
 
 #include "base/logging.h"
 #include "base/values.h"
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index ec9fe5d..548be1e 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -277,39 +277,58 @@ int Stream::Prepare(long *size) {
     if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo) {
         lret = kMmtMediaSize;
     }else {
-        lret = offmap_[idxcur_.second].size; 
+        lret = offmap_[idxcur_.second].total; 
     }
     if (size)   *size = lret;
     LOG(INFO) << __func__ << " lret=" << lret;
     return 0;
 }
 
-long Stream::ParseMpu() {
+long Stream::ParseMpu(long& lret) {
     // TODO: process image of mp4 here
     // check moof box and other
     stream_t* s = InitMpuStream(this);
     mp4_box_t* root = MP4_BoxGetRoot(s);
+    if (!root) return -1;
     mp4_box_t* box0 = MP4_BoxSearchBox(root, ATOM_ftyp);
+    if (!box0) return -1;
 
     long offset = -1;
-    mp4_box_t* box = nullptr;
-    if (mtype_ == kMmtMediaImage) {
-        box = MP4_BoxSearchBox(box0, ATOM_idat);
-        offset = 8;
-    }else {
-        box = MP4_BoxSearchBox(box0, ATOM_moof);
-        offset = 0;
-    }
-    LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
-        << " ftyp-box=" << box0 << " moof/idat-box=" << box;
-
-    // get the pos of the 1st moof-box
-    long ipos = -1;
-    if (box) ipos = box->i_pos;
+    long ipos = -1; //get the pos of the 1st moof-box or idat-box
+    do {
+        mp4_box_t* box = nullptr;
+        if (mtype_ == kMmtMediaImage) {
+            box = MP4_BoxSearchBox(box0, ATOM_idat);
+            offset = 8;
+        }else {
+            box = MP4_BoxSearchBox(box0, ATOM_moof);
+            offset = 0;
+        }
+        LOG(INFO) << __func__ << " mp4 root=" << root << " media-type=" << mtype_
+            << " ftyp-box=" << box0 << " moof/idat-box=" << box;
+        if (!box) break;
+        ipos = box->i_pos;
+
+        if (mtype_ != kMmtMediaImage) { // check mdat, assume only one moof and one mdat
+            box = MP4_BoxSearchBox(box, ATOM_mdat);
+            if (!box) break;
+            long pos1 = box->i_pos;
+            long size1 = box->i_size;
+            if (pos1 + size1 != lret) {
+                LOG(INFO) << __func__ << " invalid mdat, pos="<<pos1<<" size="<<size1<<" total="<<lret;
+#if 0 // one ugly way: fix media file data
+                uint32_t real = Swap32((uint32_t)(lret - pos1));
+                stream_seek(s, pos1, SEEK_SET);
+                stream_write(s, &real, 4);
+#else // another way: fix media file size
+                lret = pos1 + size1;
+#endif
+            }
+        }
+    }while(false);
     MP4_BoxFree(s, root);
     free(s);
 
-    // seek to the 1st moof-box
     if (ipos == -1) return -1;
     offset += ipos;
     return offset;
@@ -415,20 +434,21 @@ void* Stream::Open(const char* filename, int mode) {
     ierr = fseek(file_, 0L, SEEK_SET);
     if (ierr != 0) return nullptr; 
 
+    long total = lret;
     long offset = 0;
     if (mtype_ == kMmtMediaAudio || mtype_ == kMmtMediaVideo || mtype_ == kMmtMediaImage) {
         if (mtype_ == kMmtMediaImage || !first_) {
-            offset = ParseMpu();
+            offset = ParseMpu(lret);
             if (offset == -1) return nullptr;
             ierr = fseek(file_, offset, SEEK_SET);
             if (ierr != 0) return nullptr; 
         }
     }
-    offmap_[index] = offset_t(offset, lret);
+    offmap_[index] = offset_t(offset, total, lret);
     if(first_) first_ = false;
 
     LOG(INFO) << __func__ << " index=" << index
-        << " off=" << offmap_[index].off << " size=" << offmap_[index].size;
+        << " off=" << offmap_[index].off << " total=" << offmap_[index].total << " required=" << lret;
     idxcur_.second = index;
     lasterr_ = 0;
     return (void *)file_;
@@ -438,7 +458,21 @@ int Stream::Read(void *buf, int size) {
     if (!Open(nullptr, 0)) return lasterr_;
 
     int iret = fread(buf, 1, size, file_);
-    if (iret < size) { // read to eof
+    if (iret < 0) iret = 0;
+    offset_t& off = offmap_[idxcur_.second];
+    off.off += iret;
+
+    if (iret < size && off.total < off.required) { // read to eof
+        LOG(INFO) << __func__ << " fix mpu err, total=" << off.total << " required=" << off.required
+            << " off=" << off.off << " iret=" << iret;
+        int imin = std::min(int(off.required-off.off), size-iret);
+        if (imin > 0) {
+            iret += imin;
+            off.off += imin;
+        }
+    }
+
+    if (iret < size) { // go to next file
         Close();
         if (idxcur_.second >= 0) {
             idxcur_.first = idxcur_.second;
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index a765830..b7aa07e 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -118,11 +118,12 @@ struct triple_t {
  * stream read offset/size
  */
 struct offset_t {
-    offset_t() : off(0), size(0) {}
-    offset_t(long off, long size) : off(off), size(size) {}
+    offset_t() : off(0), total(0), required(0) {}
+    offset_t(long off, long total, long required) : off(off), total(total), required(required) {}
 
-    long off;   //> offset of reading 
-    long size;  //> size of reading
+    long off;       //> offset of reading 
+    long total;     //> total size for current media index
+    long required;  //> required size
 };
 
 /**
@@ -165,7 +166,7 @@ public:
     bool Init();
     void Uninit();
     bool IsMmtMedia();
-    long ParseMpu();
+    long ParseMpu(long &lret);
     bool ParseSequence();
     bool CheckIndex(int last, int& index);
 
-- 
1.7.9.5


From b688fb069b828526bef640c4ab6c480dfc9c3154 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 15 Feb 2015 13:24:40 +0800
Subject: [PATCH 114/128] [ok] continue to decode when meets invalid mpu

---
 media/filters/ffmpeg_video_decoder.cc |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/media/filters/ffmpeg_video_decoder.cc b/media/filters/ffmpeg_video_decoder.cc
index 93dcee2..dc75e38 100644
--- a/media/filters/ffmpeg_video_decoder.cc
+++ b/media/filters/ffmpeg_video_decoder.cc
@@ -224,9 +224,10 @@ void FFmpegVideoDecoder::Decode(const scoped_refptr<DecoderBuffer>& buffer,
   do {
     has_produced_frame = false;
     if (!FFmpegDecode(buffer, &has_produced_frame)) {
-      state_ = kError;
-      decode_cb_bound.Run(kDecodeError);
-      return;
+      // FIXME: continue to decode next frame when kDecodeError for invalid mpu
+      //state_ = kError;
+      //decode_cb_bound.Run(kDecodeError);
+      //return;
     }
     // Repeat to flush the decoder after receiving EOS buffer.
   } while (buffer->end_of_stream() && has_produced_frame);
-- 
1.7.9.5


From 97896dd9aedcbb7e4cfd7b6ecf1c4f4c32e75183 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 25 Feb 2015 20:38:01 +0800
Subject: [PATCH 115/128] [todo] use InsertCSS to update css

---
 net/mmt/mmt_control.cc                 |   51 ++++++++++++++++++--------------
 net/mmt/mmt_parser.cc                  |   13 ++++++--
 net/mmt/mmt_parser.h                   |    6 ++--
 net/url_request/url_request_mmt_job.cc |    7 +++--
 4 files changed, 48 insertions(+), 29 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 76c37e7..d1afe9a 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -57,6 +57,17 @@ int PostCtrlTask(std::string head, GURL gurl, stream_info_t& sinfo, job_refptr_t
 }
 
 /**
+ * To generate json data for mmt native message
+ */
+void GetJsonData(int tabid, std::string js, std::string& json) {
+    json += "{";
+    json += "\"tabid\" : " + Int2String(tabid);
+    json += ", ";
+    json += "\"js\" : \"" + js + "\"";
+    json += "}";
+}
+
+/**
  * UnitTest for class CiParser
  */
 void TestXmlParser() {
@@ -64,24 +75,18 @@ void TestXmlParser() {
     CiParserPtr parser = new CiParser(xml);
     parser->ParseXml();
     parser->ParseHtml();
-    std::string js;
-    parser->GetHtmlJS(0, js);
+    std::string js, css;
+    parser->GetHtmlJS(0, js, css);
     LOG(INFO) << __func__ << " js1: " << js;
-    parser->GetHtmlJS(1080, js);
+    parser->GetHtmlJS(1080, js, css);
     LOG(INFO) << __func__ << " js2: " << js;
-    parser->GetHtmlJS(1086, js);
+    parser->GetHtmlJS(1086, js, css);
     LOG(INFO) << __func__ << " js3: " << js;
-}
 
-/**
- * To generate json data for mmt native message
- */
-void GetJsonData(int tabid, std::string js, std::string& json) {
-    json += "{";
-    json += "\"tabid\" : " + Int2String(tabid);
-    json += ", ";
-    json += "\"js\" : \"" + js + "\"";
-    json += "}";
+    std::string json;
+    GetJsonData(2, js, json);
+    LOG(INFO) << __func__ << " json => " << json;
+    SendToHost(json, "127.0.0.1", 54321);
 }
 
 /**
@@ -341,25 +346,27 @@ void MmtControl::CheckEvent() {
             }
             
             if (cixml->parser && cixml->postui) {
+                std::string css;
                 std::string js0, js1;
                 cixml->parser->GetSubXmlJS(ntp, js0);
                 if (!js0.empty()) {
                     LOG(INFO) << __func__ << " js0 => " << js0;
                 }
-                cixml->parser->GetHtmlJS(ntp, js1);
+                cixml->parser->GetHtmlJS(ntp, js1, css);
                 if (!js1.empty()) {
                     LOG(INFO) << __func__ << " js1 => " << js1;
                 }
+
+                // for css
+                if (!css.empty()) {
+                    LOG(INFO) << __func__ << " css => " << css;
+                    cixml->postui(cixml->job, "@css", css);
+                }
+
+                // for js
                 std::string js = js0 + js1;
                 if(!js.empty()) {
-#ifdef USE_MMT_NATIVE_MESSAGE
-                    std::string json;
-                    GetJsonData(iter->first, js, json);
-                    LOG(INFO) << __func__ << " json => " << json;
-                    SendToHost(json, "127.0.0.1", 54321);
-#else
                     cixml->postui(cixml->job, "@js", js);
-#endif
                 }
             }
             //next_status = "end";
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index d50b883..6413274 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -134,6 +134,9 @@ inline std::string SetJSEnd() {
 inline std::string SetDivJSClear(std::string id) {
     return "clearChildNodes(g_"+id+");";
 }
+inline std::string SetCSSStyle(std::string id, std::string value) {
+    return "#"+id+"{"+value+"} ";
+}
 
 std::string SetDivJSUtils() {
     std::string js;
@@ -279,6 +282,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
         id = node->attrs[krefId];
     if (id.empty()) return;
 
+    std::string css;            // for css style
     std::string js0, js1;       // for time of begin and end
     std::string js2;            // for event, e.g. onclick
     js0 = js1 = js2 = SetJSBegin(id);
@@ -286,8 +290,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
 
     std::string style = node->attrs[kstyle];
     if (!style.empty()) {
-        js0 += SetJSAttr(id, "style", style);
-        js1 += SetJSAttr(id, "style", style);
+        css = SetCSSStyle(id, style);
     }
 
     // process div
@@ -334,6 +337,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     htmlptr_t html = new html_t;
     html->node = node;
     html->id = id;                    //> html tag id
+    html->js[EHtmlCSS] = css;         //> html css
     html->js[EHtmlBegin] = js0;       //> self's begin
     html->js[EHtmlEnd] = js1;         //> self's end
     html->js[EHtmlClick] = js2;       //> other use this click.
@@ -655,8 +659,9 @@ bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
 /**
  * TODO: try to split js to execute seperately to avoid failure.
  */
-bool CiParser::GetHtmlJS(int64 current, std::string& js) {
+bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     js = "";
+    css = "";
     if (htmls_.empty()) return false;
 
     std::string js1, js2;
@@ -688,6 +693,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
                 }else {
                     LOG(INFO) << __func__ << " begin exist, key=" << key;
                 }
+                //css += html->js[EHtmlCSS];
             }
         }
     }
@@ -705,6 +711,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js) {
                 }else {
                     LOG(INFO) << __func__ << " end exist, key=" << key;
                 }
+                css += html->js[EHtmlCSS];
             }
         }
     }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 09db02c..e4c06e7 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -22,6 +22,7 @@ typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name =>
  * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
+    EHtmlCSS,
     EHtmlBegin,         //> mmtci:begin
     EHtmlEnd,           //> mmtci:end
     EHtmlClick,
@@ -114,13 +115,14 @@ public:
     bool MergeCI2(CiParser* parser);
 
     /**
-     * To get current js to operate
+     * To get current css/js to operate
      *
      * @param current[in]: current time(ms) (ntp or ntp diff)
      * @param js[out]: returned js 
+     * @param css[out]: returned css 
      * @return true if success.
      */
-    bool GetHtmlJS(int64 current, std::string& js);
+    bool GetHtmlJS(int64 current, std::string& js, std::string& css);
     bool GetSubXmlJS(int64 current, std::string& js);
 
     /**
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 0ffc7bc..4ea0c32 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -326,8 +326,11 @@ void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_stor
     LOG(INFO) << __func__  
         << " main_frame=" << main_frame << ", head=" << content->head
         << " tab id=" << content->tab_id << ", tab url=" << content->tab_url;
-    if (main_frame) {
-        if(content->head == "@js" && !content->body.empty()) { // for js
+
+    if (main_frame && !content->body.empty()) {
+        if (content->head == "@css") { // for css
+            web_contents->InsertCSS(content->body);
+        }else if(content->head == "@js") { // for js
             main_frame->ExecuteJavaScript(base::ASCIIToUTF16(content->body.c_str()));
         }
     }
-- 
1.7.9.5


From e26fc96a46f0ce418cdad5c683fdb1703a60318b Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 25 Feb 2015 20:58:56 +0800
Subject: [PATCH 116/128] [ok] support css style

---
 net/mmt/mmt_control.cc                 |  172 +++++++++++++++++---------------
 net/mmt/mmt_stream.cc                  |    2 -
 net/mmt/mmt_stream.h                   |    4 -
 net/url_request/url_request_mmt_job.cc |   28 +++---
 net/url_request/url_request_mmt_job.h  |    2 +-
 5 files changed, 103 insertions(+), 105 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index d1afe9a..bb2464bf 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -258,6 +258,94 @@ void MmtControl::StreamClose(ctrl_msg_t msg) {
         streams_.erase(iter);
     }
 }
+void ProcCiXml(cixmlptr_t cixml, int tabid) {
+    if (!cixml) return;
+    std::string xml_name = cixml->fname;
+
+    if (!cixml->parser) { // first load
+        cixml->parser = new CiParser(xml_name);
+        cixml->parser->SetTabId(tabid);
+        if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
+            LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
+            cixml->parser = nullptr;
+            cixml->update = 15;
+        }
+    }
+
+    int64 ntp = GetNTPTime();
+    if (cixml->parser && (cixml->update--) <= 0) {
+        // update ci xml
+        int64 timestamp = cixml->parser->GetTimestamp();
+        std::string version = cixml->parser->GetVersion();
+        CiParserPtr parser2 = new CiParser(xml_name);
+        LOG(INFO) << __func__ << " [ParseXML] xml=" << xml_name;
+        if(parser2->ParseXml()) {
+            int64 timestamp2 = parser2->GetTimestamp();
+            std::string version2 = parser2->GetVersion();
+            LOG(INFO) << __func__ << " to update xml, ntp=" << ntp
+                << " old timestamp=" << timestamp << " version=" << version
+                << " new timestamp=" << timestamp2 << " version=" << version2;
+
+            if (ntp >= timestamp2 && timestamp < timestamp2) {
+                parser2->SetTabId(tabid);
+                if(parser2->ParseHtml()) {
+                    parser2->MergeCI(cixml->parser.get());
+                    cixml->parser = parser2;
+                    LOG(INFO) << __func__ << " to update xml, OK";
+                }
+            }
+            cixml->update = 15;
+        }else {
+            LOG(INFO) << __func__ << " fail to parse xml";
+        }
+        parser2 = nullptr;
+    }
+
+    if (cixml->parser && !cixml->subxmls.empty()) {
+        std::vector<xmlinfo_t>::iterator iter_sx;
+        for (iter_sx=cixml->subxmls.begin(); iter_sx != cixml->subxmls.end(); iter_sx++) {
+            if (iter_sx->timeout == 0) {
+                CiParserPtr parser2 = new CiParser(iter_sx->fname);
+                LOG(INFO) << __func__ << " [ParseXML] xml=" << iter_sx->fname;
+                if(parser2->ParseXml()) { // if failed maybe not got this xml, waiting for next time
+                    parser2->SetTabId(tabid); // should be called before ParserHtml
+                    if(parser2->ParseHtml()) {
+                        parser2->MergeCI(cixml->parser.get());
+                        cixml->parser = parser2;
+                    }
+                    iter_sx->timeout = 1;
+                }
+                parser2 = nullptr;
+            }
+        }
+    }
+
+    if (cixml->parser && cixml->postui) {
+        std::string css;
+        std::string js0, js1;
+        cixml->parser->GetSubXmlJS(ntp, js0);
+        if (!js0.empty()) {
+            LOG(INFO) << __func__ << " js0 => " << js0;
+        }
+        cixml->parser->GetHtmlJS(ntp, js1, css);
+        if (!js1.empty()) {
+            LOG(INFO) << __func__ << " js1 => " << js1;
+        }
+
+        // for css
+        if (!css.empty()) {
+            LOG(INFO) << __func__ << " css => " << css;
+            cixml->postui(cixml->job, "@css", css);
+        }
+
+        // for js
+        std::string js = js0 + js1;
+        if(!js.empty()) {
+            cixml->postui(cixml->job, "@js", js);
+        }
+    }
+}
+
 void MmtControl::CheckEvent() {
     std::map<int, cixmlptr_t>::iterator iter;
     for (iter=cixmls_.begin(); iter != cixmls_.end(); iter++) {
@@ -276,7 +364,6 @@ void MmtControl::CheckEvent() {
         }
         if (cixml->fname.empty()) continue;
 
-        std::string xml_name = cixml->fname;
         std::string next_status = cixml->status;
 
         //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
@@ -287,88 +374,7 @@ void MmtControl::CheckEvent() {
             next_status = "loaded";
             Wait(1000);
         }else if (cixml->status == "loaded") {
-            if (!cixml->parser) { // first load
-                cixml->parser = new CiParser(xml_name);
-                cixml->parser->SetTabId(iter->first);
-                if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
-                    LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
-                    cixml->parser = nullptr;
-                    cixml->update = 15;
-                }
-            }
-
-            int64 ntp = GetNTPTime();
-            if (cixml->parser && (cixml->update--) <= 0) {
-                // update ci xml
-                int64 timestamp = cixml->parser->GetTimestamp();
-                std::string version = cixml->parser->GetVersion();
-                CiParserPtr parser2 = new CiParser(xml_name);
-                LOG(INFO) << __func__ << " [ParseXML] xml=" << xml_name;
-                if(parser2->ParseXml()) {
-                    int64 timestamp2 = parser2->GetTimestamp();
-                    std::string version2 = parser2->GetVersion();
-                    LOG(INFO) << __func__ << " to update xml, ntp=" << ntp
-                        << " old timestamp=" << timestamp << " version=" << version
-                        << " new timestamp=" << timestamp2 << " version=" << version2;
-
-                    if (ntp >= timestamp2 && timestamp < timestamp2) {
-                        parser2->SetTabId(tabid);
-                        if(parser2->ParseHtml()) {
-                            parser2->MergeCI(cixml->parser.get());
-                            cixml->parser = parser2;
-                            LOG(INFO) << __func__ << " to update xml, OK";
-                        }
-                    }
-                    cixml->update = 15;
-                }else {
-                    LOG(INFO) << __func__ << " fail to parse xml";
-                }
-                parser2 = nullptr;
-            }
-
-            if (cixml->parser && !cixml->subxmls.empty()) {
-                std::vector<xmlinfo_t>::iterator iter_sx;
-                for (iter_sx=cixml->subxmls.begin(); iter_sx != cixml->subxmls.end(); iter_sx++) {
-                    if (iter_sx->timeout == 0) {
-                        CiParserPtr parser2 = new CiParser(iter_sx->fname);
-                        LOG(INFO) << __func__ << " [ParseXML] xml=" << iter_sx->fname;
-                        if(parser2->ParseXml()) { // if failed maybe not got this xml, waiting for next time
-                            parser2->SetTabId(tabid); // should be called before ParserHtml
-                            if(parser2->ParseHtml()) {
-                                parser2->MergeCI(cixml->parser.get());
-                                cixml->parser = parser2;
-                            }
-                            iter_sx->timeout = 1;
-                        }
-                        parser2 = nullptr;
-                    }
-                }
-            }
-            
-            if (cixml->parser && cixml->postui) {
-                std::string css;
-                std::string js0, js1;
-                cixml->parser->GetSubXmlJS(ntp, js0);
-                if (!js0.empty()) {
-                    LOG(INFO) << __func__ << " js0 => " << js0;
-                }
-                cixml->parser->GetHtmlJS(ntp, js1, css);
-                if (!js1.empty()) {
-                    LOG(INFO) << __func__ << " js1 => " << js1;
-                }
-
-                // for css
-                if (!css.empty()) {
-                    LOG(INFO) << __func__ << " css => " << css;
-                    cixml->postui(cixml->job, "@css", css);
-                }
-
-                // for js
-                std::string js = js0 + js1;
-                if(!js.empty()) {
-                    cixml->postui(cixml->job, "@js", js);
-                }
-            }
+            ProcCiXml(cixml, tabid);
             //next_status = "end";
         }
         cixml->status = next_status;
diff --git a/net/mmt/mmt_stream.cc b/net/mmt/mmt_stream.cc
index 548be1e..7502b75 100644
--- a/net/mmt/mmt_stream.cc
+++ b/net/mmt/mmt_stream.cc
@@ -18,8 +18,6 @@ content_t::content_t() {
     routing_id = 0;
     tab_id = 0;
     //tab_url = "";
-    head = "";
-    body = "";
 }
 content_t::~content_t() {
 }
diff --git a/net/mmt/mmt_stream.h b/net/mmt/mmt_stream.h
index b7aa07e..d7147b4 100644
--- a/net/mmt/mmt_stream.h
+++ b/net/mmt/mmt_stream.h
@@ -36,10 +36,6 @@ struct content_t {
     int routing_id; //> render host routing id 
     int tab_id;     //> chrome's tab id
     GURL tab_url;   //> chrome's tab url
-
-    // for extra message (now for js script)
-    std::string head; //> tag: @js
-    std::string body;
 };
 
 } // namespace mmt
diff --git a/net/url_request/url_request_mmt_job.cc b/net/url_request/url_request_mmt_job.cc
index 4ea0c32..f23c585 100644
--- a/net/url_request/url_request_mmt_job.cc
+++ b/net/url_request/url_request_mmt_job.cc
@@ -50,7 +50,7 @@ URLRequestMmtJob::URLRequestMmtJob(
   read_info_.url = request_->url();
   GetRequestID(&content_, request_);
   content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, false));
+        base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &content_, "", ""));
 }
 
 void URLRequestMmtJob::Start() {
@@ -297,7 +297,7 @@ bool URLRequestMmtJob::GetExtension(mmt::content_t* content, content::BrowserCon
     return true;
 }
 
-void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_storage) {
+void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, const std::string head, const std::string body) {
     if (!content) return;
     content->tab_id = -1;
     //content->tab_url = "";
@@ -324,31 +324,29 @@ void URLRequestMmtJob::GetRenderFrameInfo(mmt::content_t* content, bool has_stor
     content->tab_url = web_contents->GetURL();
     content::RenderFrameHost* main_frame = web_contents->GetMainFrame();
     LOG(INFO) << __func__  
-        << " main_frame=" << main_frame << ", head=" << content->head
+        << " main_frame=" << main_frame << ", head=" << head
         << " tab id=" << content->tab_id << ", tab url=" << content->tab_url;
 
-    if (main_frame && !content->body.empty()) {
-        if (content->head == "@css") { // for css
-            web_contents->InsertCSS(content->body);
-        }else if(content->head == "@js") { // for js
-            main_frame->ExecuteJavaScript(base::ASCIIToUTF16(content->body.c_str()));
+    if (main_frame && !body.empty()) {
+        if (head == "@css") { // for css
+            web_contents->InsertCSS(body);
+        }else if(head == "@js") { // for js
+            main_frame->ExecuteJavaScript(base::ASCIIToUTF16(body.c_str()));
         }
     }
 
+#if 0
     // for extension and chrome.storage
-    if (has_storage) {
-        GetExtension(content, web_contents->GetBrowserContext());
-    }
+    GetExtension(content, web_contents->GetBrowserContext());
+#endif
 }
 
 void URLRequestMmtJob::DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body) {
-    LOG(INFO) << __func__;
+    LOG(INFO) << __func__ << " head=" << head;
     scoped_refptr<URLRequestMmtJob> thiz = (URLRequestMmtJob *)ptr.get();
     if (thiz) {
-        thiz->content_.head = head;
-        thiz->content_.body = body;
         content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-            base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &thiz->content_, false));
+            base::Bind(&URLRequestMmtJob::GetRenderFrameInfo, &thiz->content_, head, body));
     }
 }
 
diff --git a/net/url_request/url_request_mmt_job.h b/net/url_request/url_request_mmt_job.h
index f1f189c..44ef330 100644
--- a/net/url_request/url_request_mmt_job.h
+++ b/net/url_request/url_request_mmt_job.h
@@ -78,7 +78,7 @@ class NET_EXPORT URLRequestMmtJob : public URLRequestJob {
   static void StorageCallback(ValueStore* storage);
   static bool GetRequestID(mmt::content_t* content, const URLRequest* request);
   static bool GetExtension(mmt::content_t* content, content::BrowserContext* context);
-  static void GetRenderFrameInfo(mmt::content_t* content, bool has_storage);
+  static void GetRenderFrameInfo(mmt::content_t* content, const std::string head, const std::string body);
   static void DoPostUI(mmt::job_refptr_t ptr, const std::string head, const std::string& body);
 
  private:
-- 
1.7.9.5


From ded77057151e76a06e0c71677e8055711622843d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Thu, 26 Feb 2015 10:29:53 +0800
Subject: [PATCH 117/128] [todo] prepare for multi-screen

---
 net/mmt/mmt_inc.h     |    2 ++
 net/mmt/mmt_parser.cc |   60 ++++++++++++++++++++++++++++++++++++++++---------
 net/mmt/mmt_parser.h  |    7 +++---
 net/mmt/mmt_utils.cc  |    1 -
 4 files changed, 55 insertions(+), 15 deletions(-)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 4bb807a..9b62cef 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -39,6 +39,8 @@
 
 namespace mmt{
 
+#define USE_NTP_TIME 1
+
 /**
  * Wait millseconds
  */
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 6413274..3843c45 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -6,12 +6,10 @@
 
 namespace mmt {
 
-#define USE_NTP_TIME 1
-
 static const char kNoValue[] = "no-value";
 
 /**
- * String constants for ci xml node
+ * For the node name of ci xml
  */
 static const char kCI[]             = "CI";
 static const char kview[]           = "view";
@@ -20,30 +18,68 @@ static const char kMediaSync[]      = "MediaSync";
 static const char ksourceList[]     = "sourceList";
 
 /**
- * String constants for ci xml attr
+ * For the attr name of ci xml's node
  */
 static const char kversion[]    = "version";
 static const char ktimestamp[]  = "timestamp";
+
 static const char krefId[]      = "refId";
 static const char krefDiv[]     = "refDiv";
 static const char kmediaSrc[]   = "mediaSrc";
+static const char kstyle[]      = "style";
+
 static const char kbegin[]      = "begin";
 static const char kend[]        = "end";
-static const char kstyle[]      = "style";
+static const char kdur[]        = "dur"; // TODO
 static const char kclipBegin[]  = "clipBegin";
 static const char kclipEnd[]    = "clipEnd";
 static const char kclipList[]   = "clipList";
+
 static const char kxlinkhref[]  = "xlink:href";
 static const char kxlinkactuate[] = "xlink:actuate";
 
+// TODO for multi-screen
+#if 0
+static const char kviewRole[]   = "viewRole";
+static const char kplungeOut[]  = "plungeOut";
+static const char kplungeIn[]   = "plungeIn";
+#endif
+
+
+/**
+ * For the value of kviewRole
+ */
+#if 0
+static const char kdefault[]    = "default"; 
+static const char kmultiple[]   = "multiple"; 
+static const char kreceptiple[] = "receptiple";    //>case 7, recv one from another device.
+#endif
+
+/**
+ * For the value of kplungeOut
+ */
+#if 0
+static const char kdisable[]       = "disable";
+static const char kcomplementary[] = "complementary";  //>case5/6, split one to another device.
+static const char ksharable[]      = "sharable";       //>case3, share one to another device.
+static const char kdynamic[]       = "dynamic";        //>case4, move one to another device.
+static const char kuserselect[]    = "userselect";
+#endif
+
 /**
- * Event constatnts for the value of kbegin and kend
+ * For the value of kbegin/kend/kdur
  */
 static const char kevinf[]      = "indefinite";
 static const char kevbegin[]    = ".begin";
 static const char kevend[]      = ".end";
 static const char kevclick[]    = ".click";
-static const char konRequest[]  = "onRequest";
+
+/**
+ * For value of kxlinkactuate
+ */
+static const char konLoad[]     = "onLoad";    //> auto-load when window.document is load
+static const char konRequest[]  = "onRequest"; //> it will be acturated when user click the body of browser.
+
 
 
 /**
@@ -72,9 +108,11 @@ static void sax_pi(void *x,const xmlChar *target,const xmlChar *data){
     fprintf(stdout, "[xml][pi] ? => %s => %s\n", target, data);
 }
 static void sax_comment(void *x,const xmlChar *value) {
+#ifdef MMT_LOG_V
     fprintf(stdout, "[xml][comment] %s\n", value);
+#endif
 }
-static void sax_error(void *x,const char *msg,...){
+static void sax_error(void *x,const char *msg,...) {
 #ifdef MMT_LOG_V
     va_list ap;
     va_start(ap,msg);
@@ -154,7 +192,7 @@ std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
     std::string js;
     href = href + "&type=" + kMmtMediaCI;
     js = "var div = document.createElement('div');";
-    js+= "div.innerHTML=\"<iframe id='"+id+"' width=100 height=100/>\";";
+    js+= "div.innerHTML=\"<iframe id='"+id+"' width=10 height=10/>\";";
     js+= "document.body.appendChild(div);";
 
     js+= GetJSObject(id);
@@ -163,7 +201,7 @@ std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
         js+= "document.onclick = function() {";
         js+= SetJSAttr(id, "src", href);
         js+= "}";
-    }else {
+    }else if (action == konLoad){
         js+= SetJSAttr(id, "src", href);
     }
     js+= SetJSEnd();
@@ -832,7 +870,7 @@ bool ParseTimeEvent(std::string value, event_t& event) {
 bool CiParser::AddAttr(std::string name, std::string value) {
     if (!cur_) return false;
     cur_->attrs[name] = value;
-    if (name == kbegin || name == kend) {
+    if (name == kbegin || name == kend || name == kdur) {
         //LOG(INFO) << __func__ << " current=" << (cur_? cur_->name : "root") 
         //    << " attr: " << name << " => " << value;
     }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index e4c06e7..04d9ac0 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -36,10 +36,10 @@ struct event_t {
     event_t();
 
     bool is_event;      //> event or time
-    int is_timeout;     //> 0: not timeout,
+    int is_timeout;     //> 0 if un-processed, non-0 if processed
     std::string id;     //> event id
     std::string event;  //> event type
-    int64 time;          //> ms, valid if id is empty
+    int64 time;         //> ms, valid if id is empty
 };
 
 /**
@@ -48,6 +48,7 @@ struct event_t {
 struct citime_t {
     event_t begin;
     event_t end;
+    event_t dur;
 };
 
 
@@ -60,7 +61,7 @@ public:
 
     std::string name;   //> node's name
     attrs_t attrs;      //> node's attr
-    citime_t time;      //> for time range(begin/end)
+    citime_t time;      //> for time range(begin/end/dur)
 
     nodeptrs_t nodes;   //> sub nodes
     nodeptr_t parent;   //> parent node
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 4bd0d74..0c2e022 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -4,7 +4,6 @@
 
 namespace mmt {
 
-#define USE_NTP_TIME 1
 const char kMmtNtpServer[] = "time.apple.com";
 
 const char kMmtMediaAudio[] = "audio";
-- 
1.7.9.5


From b3813768e4fe460f482e978a3e4a51f21f91c69c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 27 Feb 2015 13:12:32 +0800
Subject: [PATCH 118/128] [ok] for cast_sender_app

---
 media/cast/cast_sender_impl.cc       |    1 +
 media/cast/sender/video_sender.cc    |    1 +
 media/cast/test/fake_media_source.cc |    8 ++++++++
 media/cast/test/sender.cc            |   14 ++++++++++++--
 4 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/media/cast/cast_sender_impl.cc b/media/cast/cast_sender_impl.cc
index 83048d7..9e1f81e 100644
--- a/media/cast/cast_sender_impl.cc
+++ b/media/cast/cast_sender_impl.cc
@@ -182,6 +182,7 @@ void CastSenderImpl::OnVideoInitialized(
     const CastInitializationCallback& initialization_cb,
     media::cast::CastInitializationStatus result) {
   DCHECK(cast_environment_->CurrentlyOn(CastEnvironment::MAIN));
+  LOG(INFO) << __func__ << " result=" << result;
   if (result == STATUS_VIDEO_INITIALIZED) {
     video_frame_input_ =
         new LocalVideoFrameInput(cast_environment_, video_sender_->AsWeakPtr(),
diff --git a/media/cast/sender/video_sender.cc b/media/cast/sender/video_sender.cc
index 0e9b72f..8213b01 100644
--- a/media/cast/sender/video_sender.cc
+++ b/media/cast/sender/video_sender.cc
@@ -101,6 +101,7 @@ VideoSender::VideoSender(
   }
 #endif  // !defined(OS_IOS)
 
+  LOG(INFO) << __func__ << " cast_initialization_status=" << cast_initialization_status_;
   if (cast_initialization_status_ == STATUS_VIDEO_INITIALIZED) {
     cast_environment->PostTask(
         CastEnvironment::MAIN,
diff --git a/media/cast/test/fake_media_source.cc b/media/cast/test/fake_media_source.cc
index 918f7bb..6e4f054 100644
--- a/media/cast/test/fake_media_source.cc
+++ b/media/cast/test/fake_media_source.cc
@@ -194,6 +194,11 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
   audio_frame_input_ = audio_frame_input;
   video_frame_input_ = video_frame_input;
 
+  LOG(INFO) << __func__ 
+            << " audio_frame_input=" << audio_frame_input
+            << " video_frame_input=" << video_frame_input;
+  if (!audio_frame_input && !video_frame_input) return;
+
   LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
   LOG(INFO) << "Source Frame rate: "
             << video_frame_rate_numerator_ << "/"
@@ -249,6 +254,7 @@ void FakeMediaSource::SendNextFakeFrame() {
   video_frame->set_timestamp(video_time);
   if (keep_frames_)
     inserted_video_frame_queue_.push(video_frame);
+  if (video_frame_input_)
   video_frame_input_->InsertRawVideoFrame(video_frame,
                                           start_time_ + video_time);
 
@@ -325,6 +331,8 @@ bool FakeMediaSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
   video_frame->set_timestamp(ScaleTimestamp(decoded_frame->timestamp()));
   if (keep_frames_)
     inserted_video_frame_queue_.push(video_frame);
+
+  if (video_frame_input_)
   video_frame_input_->InsertRawVideoFrame(
       video_frame, start_time_ + video_frame->timestamp());
 
diff --git a/media/cast/test/sender.cc b/media/cast/test/sender.cc
index b61bd3a..53870ad 100644
--- a/media/cast/test/sender.cc
+++ b/media/cast/test/sender.cc
@@ -153,6 +153,7 @@ void InitializationResult(media::cast::CastInitializationStatus result) {
   bool end_result = result == media::cast::STATUS_AUDIO_INITIALIZED ||
                     result == media::cast::STATUS_VIDEO_INITIALIZED;
   CHECK(end_result) << "Cast sender uninitialized";
+  LOG(INFO) << __func__ << " result=" << result;
 }
 
 net::IPEndPoint CreateUDPAddress(std::string ip_str, uint16 port) {
@@ -245,6 +246,12 @@ void WriteStatsAndDestroySubscribers(
   VLOG(0) << "Audio stats: " << json;
 }
 
+void StartMain(media::cast::FakeMediaSource* source, media::cast::CastSender* sender) {
+  LOG(INFO) << __func__;
+  if (!source || !sender) return;
+  source->Start(sender->audio_frame_input(), sender->video_frame_input());
+}
+
 }  // namespace
 
 int main(int argc, char** argv) {
@@ -405,9 +412,12 @@ int main(int argc, char** argv) {
                  base::Passed(&offset_estimator)),
       base::TimeDelta::FromSeconds(logging_duration_seconds));
 
-  fake_media_source->Start(cast_sender->audio_frame_input(),
-                           cast_sender->video_frame_input());
+  cast_environment->PostTask(
+        media::cast::CastEnvironment::MAIN,
+        FROM_HERE,
+        base::Bind(StartMain, fake_media_source.get(), cast_sender.get()));
 
+  LOG(INFO) << __func__ << " run io_message_loop ..";
   io_message_loop.Run();
   return 0;
 }
-- 
1.7.9.5


From f725719a2b28f0832f0ccfc8417532212fe4e6c0 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Fri, 27 Feb 2015 15:14:18 +0800
Subject: [PATCH 119/128] [ok] fix video sender without audio track

---
 media/cast/test/fake_media_source.cc |   21 +++++++++++++++++++--
 1 file changed, 19 insertions(+), 2 deletions(-)

diff --git a/media/cast/test/fake_media_source.cc b/media/cast/test/fake_media_source.cc
index 6e4f054..b23d3a7 100644
--- a/media/cast/test/fake_media_source.cc
+++ b/media/cast/test/fake_media_source.cc
@@ -219,6 +219,7 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
   }
 
   // Send transcoding streams.
+  if (audio_params_.IsValid()) {
   audio_algo_.Initialize(audio_params_);
   audio_algo_.FlushBuffers();
   audio_fifo_input_bus_ =
@@ -234,6 +235,8 @@ void FakeMediaSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
       kAudioSamplingFrequency,
       audio_params_.frames_per_buffer(),
       base::Bind(&FakeMediaSource::ProvideData, base::Unretained(this))));
+  }
+
   task_runner_->PostTask(
       FROM_HERE,
       base::Bind(
@@ -304,6 +307,11 @@ bool FakeMediaSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
 
   scoped_refptr<VideoFrame> decoded_frame =
       video_frame_queue_.front();
+#if 0
+  LOG(INFO) << __func__ 
+            << " elapsed_time=" << elapsed_time
+            << " video timestamp=" << decoded_frame->timestamp();
+#endif
   if (elapsed_time < decoded_frame->timestamp())
     return false;
 
@@ -368,6 +376,16 @@ void FakeMediaSource::SendNextFrame() {
   // system time.
   while (SendNextTranscodedAudio(clock_->NowTicks() - start_time_));
 
+  // fix video play without audio track
+  if (!is_transcoding_audio()) {
+    if(!audio_sent_ts_) {
+      audio_sent_ts_.reset(new AudioTimestampHelper(30));
+      base::TimeDelta base_ts;
+      audio_sent_ts_->SetBaseTimestamp(base_ts);
+    }
+    audio_sent_ts_->AddFrames(1);
+    //LOG(INFO) << __func__ << " audio timestamp=" << audio_sent_ts_->GetTimestamp();
+  }
   // Video is sync'ed to audio.
   while (SendNextTranscodedVideo(audio_sent_ts_->GetTimestamp()));
 
@@ -401,8 +419,7 @@ base::TimeDelta FakeMediaSource::AudioFrameTime(int frame_number) {
 }
 
 void FakeMediaSource::Rewind() {
-  CHECK(av_seek_frame(av_format_context_, -1, 0, AVSEEK_FLAG_BACKWARD) >= 0)
-      << "Failed to rewind to the beginning.";
+  av_seek_frame(av_format_context_, -1, 0, AVSEEK_FLAG_BACKWARD);
 }
 
 ScopedAVPacket FakeMediaSource::DemuxOnePacket(bool* audio) {
-- 
1.7.9.5


From 837a51efc8336f0852c806a19ea1227650044502 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sat, 28 Feb 2015 11:13:45 +0800
Subject: [PATCH 120/128] [todo] fix cictrl's uninstall script

---
 .../docs/examples/api/cictrl/res/uninstall_host.sh |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
index 52f9909..b03bddc 100755
--- a/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
+++ b/chrome/common/extensions/docs/examples/api/cictrl/res/uninstall_host.sh
@@ -16,7 +16,7 @@ else
   if [ "$(whoami)" == "root" ]; then
     TARGET_DIR="/etc/opt/chromium/native-messaging-hosts"
   else
-    TARGET_DIR='$HOME/.config/chromium/NativeMessagingHosts'
+    TARGET_DIR="$HOME/.config/chromium/NativeMessagingHosts"
   fi
 fi
 
-- 
1.7.9.5


From ff329eab58a309696ab6a5269e346b79f3eeec9e Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Sun, 1 Mar 2015 23:28:38 +0800
Subject: [PATCH 121/128] [todo] testing for internal casting of video/audio
 element

---
 content/renderer/render_frame_impl.cc |    1 +
 media/blink/webmediaplayer_impl.cc    |    4 ++++
 media/blink/webmediaplayer_impl.h     |    1 +
 3 files changed, 6 insertions(+)

diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 27fca3f..ffd7e86 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -1812,6 +1812,7 @@ blink::WebMediaPlayer* RenderFrameImpl::createMediaPlayer(
         *render_thread->GetAudioHardwareConfig()));
   }
 
+  LOG(INFO) << __func__ << " media::WebMediaPlayerImpl";
   return new media::WebMediaPlayerImpl(
       frame, client, weak_factory_.GetWeakPtr(), media_renderer_factory.Pass(),
       cdm_factory.Pass(), params);
diff --git a/media/blink/webmediaplayer_impl.cc b/media/blink/webmediaplayer_impl.cc
index d712f95..8a100fda 100644
--- a/media/blink/webmediaplayer_impl.cc
+++ b/media/blink/webmediaplayer_impl.cc
@@ -406,6 +406,10 @@ void WebMediaPlayerImpl::setPreload(WebMediaPlayer::Preload preload) {
     data_source_->SetPreload(preload_);
 }
 
+void WebMediaPlayerImpl::setCasting(bool enabled) {
+    //TODO: to implement casting
+}
+
 bool WebMediaPlayerImpl::hasVideo() const {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
diff --git a/media/blink/webmediaplayer_impl.h b/media/blink/webmediaplayer_impl.h
index 07f1932..d2987d6 100644
--- a/media/blink/webmediaplayer_impl.h
+++ b/media/blink/webmediaplayer_impl.h
@@ -87,6 +87,7 @@ class MEDIA_EXPORT WebMediaPlayerImpl
   virtual void setRate(double rate);
   virtual void setVolume(double volume);
   virtual void setPreload(blink::WebMediaPlayer::Preload preload);
+  virtual void setCasting(bool enabled);
   virtual blink::WebTimeRanges buffered() const;
   virtual blink::WebTimeRanges seekable() const;
 
-- 
1.7.9.5


From 65544a7597b1b60d55244effa21c398778c7ac9b Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 2 Mar 2015 11:12:40 +0800
Subject: [PATCH 122/128] [todo] add cast_streaming for audio/video elements

---
 media/cast/cast.gyp          |    4 +
 media/cast/cast_source.cc    |  336 +++++++++++++++++++++++++++++++++++++++
 media/cast/cast_source.h     |  132 ++++++++++++++++
 media/cast/cast_streaming.cc |  357 ++++++++++++++++++++++++++++++++++++++++++
 media/cast/cast_streaming.h  |   62 ++++++++
 5 files changed, 891 insertions(+)
 create mode 100644 media/cast/cast_source.cc
 create mode 100644 media/cast/cast_source.h
 create mode 100644 media/cast/cast_streaming.cc
 create mode 100644 media/cast/cast_streaming.h

diff --git a/media/cast/cast.gyp b/media/cast/cast.gyp
index 8962e76..84f99db 100644
--- a/media/cast/cast.gyp
+++ b/media/cast/cast.gyp
@@ -149,6 +149,10 @@
         'cast_sender.h',
         'cast_sender_impl.cc',
         'cast_sender_impl.h',
+        'cast_source.h',
+        'cast_source.cc',
+        'cast_streaming.h',
+        'cast_streaming.cc',
         'sender/audio_encoder.h',
         'sender/audio_encoder.cc',
         'sender/audio_sender.h',
diff --git a/media/cast/cast_source.cc b/media/cast/cast_source.cc
new file mode 100644
index 0000000..17f7d8e
--- /dev/null
+++ b/media/cast/cast_source.cc
@@ -0,0 +1,336 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/cast/cast_source.h"
+
+#include "base/files/memory_mapped_file.h"
+#include "base/files/scoped_file.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "media/audio/audio_parameters.h"
+#include "media/base/audio_buffer.h"
+#include "media/base/audio_bus.h"
+#include "media/base/audio_fifo.h"
+#include "media/base/audio_timestamp_helper.h"
+#include "media/base/media.h"
+#include "media/base/multi_channel_resampler.h"
+#include "media/base/video_frame.h"
+#include "media/base/video_util.h"
+#include "media/cast/cast_sender.h"
+#include "media/cast/test/utility/audio_utility.h"
+#include "media/cast/test/utility/video_utility.h"
+//#include "media/ffmpeg/ffmpeg_common.h"
+//#include "media/ffmpeg/ffmpeg_deleters.h"
+#include "media/filters/audio_renderer_algorithm.h"
+#include "media/filters/ffmpeg_demuxer.h"
+#include "media/filters/ffmpeg_glue.h"
+#include "media/filters/in_memory_url_protocol.h"
+#include "ui/gfx/size.h"
+
+namespace {
+
+static const int kAudioChannels = 2;
+static const int kAudioSamplingFrequency = 48000;
+static const int kSoundFrequency = 1234;  // Frequency of sinusoid wave.
+static const float kSoundVolume = 0.5f;
+static const int kAudioFrameMs = 10;  // Each audio frame is exactly 10ms.
+static const int kAudioPacketsPerSecond = 1000 / kAudioFrameMs;
+
+}  // namespace
+
+namespace media {
+namespace cast {
+
+CastSource::CastSource(
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+    base::TickClock* clock,
+    const VideoSenderConfig& video_config,
+    bool keep_frames)
+    : task_runner_(task_runner),
+      video_config_(video_config),
+      keep_frames_(keep_frames),
+      synthetic_count_(0),
+      clock_(clock),
+      audio_frame_count_(0),
+      video_frame_count_(0),
+      playback_rate_(1.0),
+      video_frame_rate_numerator_(video_config.max_frame_rate),
+      video_frame_rate_denominator_(1),
+      weak_factory_(this) {
+  audio_bus_factory_.reset(new TestAudioBusFactory(kAudioChannels,
+                                                   kAudioSamplingFrequency,
+                                                   kSoundFrequency,
+                                                   kSoundVolume));
+}
+
+CastSource::~CastSource() {
+}
+
+void CastSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
+                       scoped_refptr<VideoFrameInput> video_frame_input) {
+  audio_frame_input_ = audio_frame_input;
+  video_frame_input_ = video_frame_input;
+
+  LOG(INFO) << __func__ 
+            << " audio_frame_input=" << audio_frame_input
+            << " video_frame_input=" << video_frame_input;
+  if (!audio_frame_input && !video_frame_input) return;
+
+  LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
+  LOG(INFO) << "Source Frame rate: "
+            << video_frame_rate_numerator_ << "/"
+            << video_frame_rate_denominator_ << " fps.";
+  LOG(INFO) << "Audio playback rate: " << playback_rate_;
+
+  if (start_time_.is_null())
+    start_time_ = clock_->NowTicks();
+
+  if (!is_transcoding_audio() && !is_transcoding_video()) {
+    // Send fake patterns.
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::Bind(
+            &CastSource::SendNextFakeFrame,
+            base::Unretained(this)));
+    return;
+  }
+
+  // Send transcoding streams.
+  if (audio_params_.IsValid()) {
+    audio_algo_.Initialize(audio_params_);
+    audio_algo_.FlushBuffers();
+    audio_fifo_input_bus_ = AudioBus::Create(
+        audio_params_.channels(), audio_params_.frames_per_buffer());
+    // Audio FIFO can carry all data fron AudioRendererAlgorithm.
+    audio_fifo_.reset(new AudioFifo(audio_params_.channels(),
+        audio_algo_.QueueCapacity()));
+    audio_resampler_.reset(new media::MultiChannelResampler(
+        audio_params_.channels(),
+        static_cast<double>(audio_params_.sample_rate()) / kAudioSamplingFrequency,
+        audio_params_.frames_per_buffer(),
+        base::Bind(&CastSource::ProvideData, base::Unretained(this))));
+  }
+
+  task_runner_->PostTask(
+      FROM_HERE,
+      base::Bind(
+          &CastSource::SendNextFrame,
+          base::Unretained(this)));
+}
+
+void CastSource::SendNextFakeFrame() {
+    gfx::Size size(video_config_.width, video_config_.height);
+    scoped_refptr<VideoFrame> video_frame = VideoFrame::CreateBlackFrame(size);
+    PopulateVideoFrame(video_frame.get(), synthetic_count_);
+    ++synthetic_count_;
+
+    const base::TimeTicks now = clock_->NowTicks();
+
+    base::TimeDelta video_time = VideoFrameTime(++video_frame_count_);
+    video_frame->set_timestamp(video_time);
+    if (keep_frames_)
+        inserted_video_frame_queue_.push(video_frame);
+    if (video_frame_input_)
+        video_frame_input_->InsertRawVideoFrame(video_frame, start_time_ + video_time);
+
+    // Send just enough audio data to match next video frame's time.
+    base::TimeDelta audio_time = AudioFrameTime(audio_frame_count_);
+    while (audio_time < video_time) {
+        if (is_transcoding_audio()) {
+            CHECK(!audio_bus_queue_.empty()) << "No audio decoded.";
+            scoped_ptr<AudioBus> bus(audio_bus_queue_.front());
+            audio_bus_queue_.pop();
+            audio_frame_input_->InsertAudio(bus.Pass(), start_time_ + audio_time);
+        } else {
+            audio_frame_input_->InsertAudio(audio_bus_factory_->NextAudioBus(
+                base::TimeDelta::FromMilliseconds(kAudioFrameMs)), start_time_ + audio_time);
+        }
+        audio_time = AudioFrameTime(++audio_frame_count_);
+    }
+
+    // This is the time since CastSource was started.
+    const base::TimeDelta elapsed_time = now - start_time_;
+
+    // Handle the case when frame generation cannot keep up.
+    // Move the time ahead to match the next frame.
+    while (video_time < elapsed_time) {
+        LOG(WARNING) << "Skipping one frame.";
+        video_time = VideoFrameTime(++video_frame_count_);
+    }
+
+    task_runner_->PostDelayedTask(
+      FROM_HERE,
+      base::Bind(&CastSource::SendNextFakeFrame,
+                 weak_factory_.GetWeakPtr()),
+      video_time - elapsed_time);
+}
+
+bool CastSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
+    if (!is_transcoding_video())
+        return false;
+
+    if (video_frame_queue_.empty())
+        return false;
+
+    scoped_refptr<VideoFrame> decoded_frame = video_frame_queue_.front();
+#if 0
+    LOG(INFO) << __func__ 
+        << " elapsed_time=" << elapsed_time
+        << " video timestamp=" << decoded_frame->timestamp();
+#endif
+    if (elapsed_time < decoded_frame->timestamp())
+        return false;
+
+    gfx::Size size(video_config_.width, video_config_.height);
+    scoped_refptr<VideoFrame> video_frame = VideoFrame::CreateBlackFrame(size);
+    video_frame_queue_.pop();
+    media::CopyPlane(VideoFrame::kYPlane,
+            decoded_frame->data(VideoFrame::kYPlane),
+            decoded_frame->stride(VideoFrame::kYPlane),
+            decoded_frame->rows(VideoFrame::kYPlane),
+            video_frame.get());
+    media::CopyPlane(VideoFrame::kUPlane,
+            decoded_frame->data(VideoFrame::kUPlane),
+            decoded_frame->stride(VideoFrame::kUPlane),
+            decoded_frame->rows(VideoFrame::kUPlane),
+            video_frame.get());
+    media::CopyPlane(VideoFrame::kVPlane,
+            decoded_frame->data(VideoFrame::kVPlane),
+            decoded_frame->stride(VideoFrame::kVPlane),
+            decoded_frame->rows(VideoFrame::kVPlane),
+            video_frame.get());
+
+    // Use the timestamp from the file if we're transcoding.
+    video_frame->set_timestamp(ScaleTimestamp(decoded_frame->timestamp()));
+    if (keep_frames_)
+        inserted_video_frame_queue_.push(video_frame);
+
+    if (video_frame_input_)
+        video_frame_input_->InsertRawVideoFrame(
+                video_frame, start_time_ + video_frame->timestamp());
+
+    return true;
+}
+
+bool CastSource::SendNextTranscodedAudio(base::TimeDelta elapsed_time) {
+    if (!is_transcoding_audio())
+        return false;
+
+    if (audio_bus_queue_.empty())
+        return false;
+
+    base::TimeDelta audio_time = audio_sent_ts_->GetTimestamp();
+    if (elapsed_time < audio_time)
+        return false;
+    scoped_ptr<AudioBus> bus(audio_bus_queue_.front());
+    audio_bus_queue_.pop();
+    audio_sent_ts_->AddFrames(bus->frames());
+    audio_frame_input_->InsertAudio(bus.Pass(), start_time_ + audio_time);
+
+    return true;
+}
+
+void CastSource::SendNextFrame() {
+    // Send as much as possible. Audio is sent according to
+    // system time.
+    while (SendNextTranscodedAudio(clock_->NowTicks() - start_time_));
+
+    // fix video play without audio track
+    if (!is_transcoding_audio()) {
+        if(!audio_sent_ts_) {
+            audio_sent_ts_.reset(new AudioTimestampHelper(30));
+            base::TimeDelta base_ts;
+            audio_sent_ts_->SetBaseTimestamp(base_ts);
+        }
+        audio_sent_ts_->AddFrames(1);
+        //LOG(INFO) << __func__ << " audio timestamp=" << audio_sent_ts_->GetTimestamp();
+    }
+    // Video is sync'ed to audio.
+    while (SendNextTranscodedVideo(audio_sent_ts_->GetTimestamp()));
+
+    if (audio_bus_queue_.empty() && video_frame_queue_.empty()) {
+        LOG(INFO) << "no any audio/video frame.";
+    }
+
+    // Send next send.
+    task_runner_->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(
+                &CastSource::SendNextFrame,
+                base::Unretained(this)),
+            base::TimeDelta::FromMilliseconds(kAudioFrameMs));
+}
+
+base::TimeDelta CastSource::VideoFrameTime(int frame_number) {
+    return frame_number * base::TimeDelta::FromSeconds(1) *
+        video_frame_rate_denominator_ / video_frame_rate_numerator_;
+}
+
+base::TimeDelta CastSource::ScaleTimestamp(base::TimeDelta timestamp) {
+    return base::TimeDelta::FromSecondsD(timestamp.InSecondsF() / playback_rate_);
+}
+
+base::TimeDelta CastSource::AudioFrameTime(int frame_number) {
+    return frame_number * base::TimeDelta::FromMilliseconds(kAudioFrameMs);
+}
+
+void CastSource::InputRawAudio(const scoped_refptr<AudioBuffer> buffer) {
+    audio_algo_.EnqueueBuffer(buffer);
+    int frames_needed_to_scale = 0;
+    while (frames_needed_to_scale <= audio_algo_.frames_buffered()) {
+        if (!audio_algo_.FillBuffer(audio_fifo_input_bus_.get(), 0,
+                    audio_fifo_input_bus_->frames(),
+                    playback_rate_)) {
+            // Nothing can be scaled. Decode some more.
+            return;
+        }
+
+        // Prevent overflow of audio data in the FIFO.
+        if (audio_fifo_input_bus_->frames() + audio_fifo_->frames()
+                <= audio_fifo_->max_frames()) {
+            audio_fifo_->Push(audio_fifo_input_bus_.get());
+        } else {
+            LOG(WARNING) << "Audio FIFO full; dropping samples.";
+        }
+
+        // Make sure there's enough data to resample audio.
+        if (audio_fifo_->frames() <
+                2 * audio_params_.sample_rate() / kAudioPacketsPerSecond) {
+            continue;
+        }
+
+        scoped_ptr<media::AudioBus> resampled_bus(
+                media::AudioBus::Create(audio_params_.channels(),
+                    kAudioSamplingFrequency / kAudioPacketsPerSecond));
+        audio_resampler_->Resample(resampled_bus->frames(),
+                resampled_bus.get());
+        audio_bus_queue_.push(resampled_bus.release());
+    }
+}
+
+void CastSource::InputRawVideo(const scoped_refptr<VideoFrame>& frame) {
+    // TODO: adjusting timestamp
+    video_frame_queue_.push(frame);
+}
+
+void CastSource::ProvideData(int frame_delay, media::AudioBus* output_bus) {
+    if (audio_fifo_->frames() >= output_bus->frames()) {
+        audio_fifo_->Consume(output_bus, 0, output_bus->frames());
+    } else {
+        LOG(WARNING) << "Not enough audio data for resampling.";
+        output_bus->Zero();
+    }
+}
+
+scoped_refptr<media::VideoFrame>
+CastSource::PopOldestInsertedVideoFrame() {
+    CHECK(!inserted_video_frame_queue_.empty());
+    scoped_refptr<media::VideoFrame> video_frame = inserted_video_frame_queue_.front();
+    inserted_video_frame_queue_.pop();
+    return video_frame;
+}
+
+
+}  // namespace cast
+}  // namespace media
diff --git a/media/cast/cast_source.h b/media/cast/cast_source.h
new file mode 100644
index 0000000..6c53cd9
--- /dev/null
+++ b/media/cast/cast_source.h
@@ -0,0 +1,132 @@
+// A fake media source that generates video and audio frames to a cast
+// sender.
+// This class can transcode a WebM file using FFmpeg. It can also
+// generate an animation and audio of fixed frequency.
+
+#ifndef MEDIA_CAST_CAST_SOURCE_H_
+#define MEDIA_CAST_CAST_SOURCE_H_
+
+#include <queue>
+
+#include "base/files/file_path.h"
+#include "base/files/memory_mapped_file.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/single_thread_task_runner.h"
+#include "base/time/tick_clock.h"
+#include "media/audio/audio_parameters.h"
+#include "media/cast/cast_config.h"
+#include "media/filters/audio_renderer_algorithm.h"
+#include "media/filters/ffmpeg_demuxer.h"
+
+struct AVCodecContext;
+struct AVFormatContext;
+
+namespace media {
+
+class AudioBus;
+class AudioFifo;
+class AudioTimestampHelper;
+class FFmpegGlue;
+class InMemoryUrlProtocol;
+class MultiChannelResampler;
+
+namespace cast {
+
+class AudioFrameInput;
+class VideoFrameInput;
+class TestAudioBusFactory;
+
+class CastSource {
+public:
+    // |task_runner| is to schedule decoding tasks.
+    // |clock| is used by this source but is not owned.
+    // |video_config| is the desired video config.
+    // |keep_frames| is true if all VideoFrames are saved in a queue.
+    CastSource(scoped_refptr<base::SingleThreadTaskRunner> task_runner,
+            base::TickClock* clock,
+            const VideoSenderConfig& video_config,
+            bool keep_frames);
+    ~CastSource();
+
+    void Start(scoped_refptr<AudioFrameInput> audio_frame_input,
+            scoped_refptr<VideoFrameInput> video_frame_input);
+
+    void InputRawAudio(const scoped_refptr<AudioBuffer> buffer);
+
+    void InputRawVideo(const scoped_refptr<VideoFrame>& frame);
+
+    const VideoSenderConfig& get_video_config() const { return video_config_; }
+
+    scoped_refptr<media::VideoFrame> PopOldestInsertedVideoFrame();
+
+protected:
+    bool is_transcoding_audio() {return true;}
+    bool is_transcoding_video() {return true;}
+
+    void SendNextFrame();
+    void SendNextFakeFrame();
+
+    // Return true if a frame was sent.
+    bool SendNextTranscodedVideo(base::TimeDelta elapsed_time);
+
+    // Return true if a frame was sent.
+    bool SendNextTranscodedAudio(base::TimeDelta elapsed_time);
+
+    // Helper methods to compute timestamps for the frame number specified.
+    base::TimeDelta VideoFrameTime(int frame_number);
+
+    base::TimeDelta ScaleTimestamp(base::TimeDelta timestamp);
+
+    base::TimeDelta AudioFrameTime(int frame_number);
+
+    void ProvideData(int frame_delay, media::AudioBus* output_bus);
+
+
+private:
+    const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
+    const VideoSenderConfig video_config_;
+    const bool keep_frames_;
+    scoped_refptr<AudioFrameInput> audio_frame_input_;
+    scoped_refptr<VideoFrameInput> video_frame_input_;
+    uint8 synthetic_count_;
+    base::TickClock* const clock_;  // Not owned by this class.
+
+    // Time when the stream starts.
+    base::TimeTicks start_time_;
+
+    // The following three members are used only for fake frames.
+    int audio_frame_count_;  // Each audio frame is exactly 10ms.
+    int video_frame_count_;
+    scoped_ptr<TestAudioBusFactory> audio_bus_factory_;
+
+    AudioParameters audio_params_;
+    double playback_rate_;
+
+    int video_frame_rate_numerator_;
+    int video_frame_rate_denominator_;
+
+    // These are used for audio resampling.
+    scoped_ptr<media::MultiChannelResampler> audio_resampler_;
+    scoped_ptr<media::AudioFifo> audio_fifo_;
+    scoped_ptr<media::AudioBus> audio_fifo_input_bus_;
+    media::AudioRendererAlgorithm audio_algo_;
+
+    // Track the timestamp of audio sent to the receiver.
+    scoped_ptr<media::AudioTimestampHelper> audio_sent_ts_;
+
+    // for transcoding video/audio frame
+    std::queue<scoped_refptr<VideoFrame> > video_frame_queue_;
+    std::queue<scoped_refptr<VideoFrame> > inserted_video_frame_queue_;
+    std::queue<AudioBus*> audio_bus_queue_;
+
+    // NOTE: Weak pointers must be invalidated before all other member variables.
+    base::WeakPtrFactory<CastSource> weak_factory_;
+
+    DISALLOW_COPY_AND_ASSIGN(CastSource);
+};
+
+}  // namespace cast
+}  // namespace media
+
+#endif // MEDIA_CAST_CAST_SOURCE_H_
diff --git a/media/cast/cast_streaming.cc b/media/cast/cast_streaming.cc
new file mode 100644
index 0000000..117a4e5
--- /dev/null
+++ b/media/cast/cast_streaming.cc
@@ -0,0 +1,357 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "media/cast/cast_streaming.h"
+
+#include <functional>
+#include <iterator>
+
+#include "base/logging.h"
+#include "base/values.h"
+#include "base/json/json_writer.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/string_number_conversions.h"
+#include "net/base/host_port_pair.h"
+
+namespace media {
+namespace cast {
+
+static const int kAudioChannels = 2;
+static const int kAudioSamplingFrequency = 48000;
+// The max allowed size of serialized log.
+const int kMaxSerializedLogBytes = 10 * 1000 * 1000;
+
+
+static void CreateVideoEncodeAccelerator(const media::cast::ReceiveVideoEncodeAcceleratorCallback& callback) {
+    // Do nothing.
+}
+
+static void CreateVideoEncodeMemory(size_t size, const media::cast::ReceiveVideoEncodeMemoryCallback& callback) {
+    // Do nothing.
+}
+
+static CreateVideoEncodeAcceleratorCallback CreateDefaultVideoEncodeAcceleratorCallback() {
+    return base::Bind(&CreateVideoEncodeAccelerator);
+}
+
+static CreateVideoEncodeMemoryCallback CreateDefaultVideoEncodeMemoryCallback() {
+  return base::Bind(&CreateVideoEncodeMemory);
+}
+
+static media::cast::AudioSenderConfig GetAudioSenderConfig() {
+    media::cast::AudioSenderConfig audio_config;
+
+    audio_config.use_external_encoder = false;
+    audio_config.frequency = kAudioSamplingFrequency;
+    audio_config.channels = kAudioChannels;
+    audio_config.bitrate = 0;  // Use Opus auto-VBR mode.
+    audio_config.codec = media::cast::CODEC_AUDIO_OPUS;
+    audio_config.ssrc = 1;
+    audio_config.receiver_ssrc = 2;
+    audio_config.rtp_payload_type = 127;
+    // TODO(miu): The default in cast_defines.h is 100.  Should this be 100, and
+    // should receiver.cc's config also be 100?
+    audio_config.max_playout_delay = base::TimeDelta::FromMilliseconds(300);
+    return audio_config;
+}
+
+static media::cast::VideoSenderConfig GetVideoSenderConfig() {
+    media::cast::VideoSenderConfig video_config;
+    video_config.use_external_encoder = false;
+
+    // Resolution.
+    video_config.width = 1280;
+    video_config.height = 720;
+    video_config.max_frame_rate = 30;
+
+    // Bitrates.
+    video_config.max_bitrate = 2500000;
+    video_config.min_bitrate = 100000;
+    video_config.start_bitrate = video_config.min_bitrate;
+
+    // Codec.
+    video_config.codec = media::cast::CODEC_VIDEO_VP8;
+    video_config.max_number_of_video_buffers_used = 1;
+    video_config.number_of_encode_threads = 2;
+
+    // Quality options.
+    video_config.min_qp = 4;
+    video_config.max_qp = 40;
+
+    // SSRCs and payload type. Don't change them.
+    video_config.ssrc = 11;
+    video_config.receiver_ssrc = 12;
+    video_config.rtp_payload_type = 96;
+    // TODO(miu): The default in cast_defines.h is 100.  Should this be 100, and
+    // should receiver.cc's config also be 100?
+    video_config.max_playout_delay = base::TimeDelta::FromMilliseconds(300);
+    return video_config;
+}
+
+static void UpdateCastTransportStatus(media::cast::CastTransportStatus status) {
+    VLOG(1) << "Transport status: " << status;
+}
+
+static void LogRawEvents(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        const std::vector<media::cast::PacketEvent>& packet_events,
+        const std::vector<media::cast::FrameEvent>& frame_events) {
+    VLOG(1) << "Got packet events from transport, size: " << packet_events.size();
+    for (std::vector<media::cast::PacketEvent>::const_iterator it =
+            packet_events.begin();
+            it != packet_events.end();
+            ++it) {
+        cast_environment->Logging()->InsertPacketEvent(it->timestamp,
+                it->type,
+                it->media_type,
+                it->rtp_timestamp,
+                it->frame_id,
+                it->packet_id,
+                it->max_packet_id,
+                it->size);
+    }
+
+    VLOG(1) << "Got frame events from transport, size: " << frame_events.size();
+    for (std::vector<media::cast::FrameEvent>::const_iterator it =
+           frame_events.begin();
+           it != frame_events.end();
+           ++it) {
+        cast_environment->Logging()->InsertFrameEvent(it->timestamp,
+                it->type,
+                it->media_type,
+                it->rtp_timestamp,
+                it->frame_id);
+    }
+}
+
+static void InitializationResult(media::cast::CastInitializationStatus result) {
+  bool end_result = result == media::cast::STATUS_AUDIO_INITIALIZED ||
+                    result == media::cast::STATUS_VIDEO_INITIALIZED;
+  CHECK(end_result) << "Cast sender uninitialized";
+  LOG(INFO) << __func__ << " result=" << result;
+}
+
+static net::IPEndPoint CreateUDPAddress(std::string ip_str, uint16 port) {
+    if (ip_str.empty()) ip_str = "127.0.0.1";
+    if (port < 0 || port > 65535) port = 2344;
+    net::IPAddressNumber ip_number;
+    CHECK(net::ParseIPLiteralToNumber(ip_str, &ip_number));
+    return net::IPEndPoint(ip_number, port);
+}
+
+static void DumpLoggingData(const media::cast::proto::LogMetadata& log_metadata,
+                     const media::cast::FrameEventList& frame_events,
+                     const media::cast::PacketEventList& packet_events,
+                     base::ScopedFILE log_file) {
+    VLOG(0) << "Frame map size: " << frame_events.size();
+    VLOG(0) << "Packet map size: " << packet_events.size();
+    scoped_ptr<char[]> event_log(new char[kMaxSerializedLogBytes]);
+    int event_log_bytes;
+    if (!media::cast::SerializeEvents(log_metadata,
+                frame_events,
+                packet_events,
+                true,
+                kMaxSerializedLogBytes,
+                event_log.get(),
+                &event_log_bytes)) {
+        VLOG(0) << "Failed to serialize events.";
+        return;
+    }
+
+    VLOG(0) << "Events serialized length: " << event_log_bytes;
+    int ret = fwrite(event_log.get(), 1, event_log_bytes, log_file.get());
+    if (ret != event_log_bytes) {
+        VLOG(0) << "Failed to write logs to file.";
+    }
+}
+
+static void WriteLogsToFileAndDestroySubscribers(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        scoped_ptr<media::cast::EncodingEventSubscriber> video_event_subscriber,
+        scoped_ptr<media::cast::EncodingEventSubscriber> audio_event_subscriber,
+        base::ScopedFILE video_log_file,
+        base::ScopedFILE audio_log_file) {
+    cast_environment->Logging()->RemoveRawEventSubscriber(video_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(audio_event_subscriber.get());
+
+    VLOG(0) << "Dumping logging data for video stream.";
+    media::cast::proto::LogMetadata log_metadata;
+    media::cast::FrameEventList frame_events;
+    media::cast::PacketEventList packet_events;
+    video_event_subscriber->GetEventsAndReset(&log_metadata, &frame_events, &packet_events);
+    DumpLoggingData(log_metadata, frame_events, packet_events, video_log_file.Pass());
+
+    VLOG(0) << "Dumping logging data for audio stream.";
+    audio_event_subscriber->GetEventsAndReset(&log_metadata, &frame_events, &packet_events);
+    DumpLoggingData(log_metadata, frame_events, packet_events,audio_log_file.Pass());
+}
+
+static void WriteStatsAndDestroySubscribers(
+        const scoped_refptr<media::cast::CastEnvironment>& cast_environment,
+        scoped_ptr<media::cast::StatsEventSubscriber> video_event_subscriber,
+        scoped_ptr<media::cast::StatsEventSubscriber> audio_event_subscriber,
+        scoped_ptr<media::cast::ReceiverTimeOffsetEstimatorImpl> estimator) {
+    cast_environment->Logging()->RemoveRawEventSubscriber(video_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(audio_event_subscriber.get());
+    cast_environment->Logging()->RemoveRawEventSubscriber(estimator.get());
+
+#if 0
+    scoped_ptr<base::DictionaryValue> stats = video_event_subscriber->GetStats();
+    std::string json;
+    base::JSONWriter::WriteWithOptions(
+            stats.get(), base::JSONWriter::OPTIONS_PRETTY_PRINT, &json);
+    VLOG(0) << "Video stats: " << json;
+
+    stats = audio_event_subscriber->GetStats();
+    json.clear();
+    base::JSONWriter::WriteWithOptions(
+            stats.get(), base::JSONWriter::OPTIONS_PRETTY_PRINT, &json);
+    VLOG(0) << "Audio stats: " << json;
+#endif
+}
+
+static void StartMain(media::cast::CastSource* source, media::cast::CastSender* sender) {
+  LOG(INFO) << __func__;
+  if (!source || !sender) return;
+  source->Start(sender->audio_frame_input(), sender->video_frame_input());
+}
+
+} // namespace cast
+} // namespace media
+
+
+namespace media {
+namespace cast {
+
+CastStreaming::CastStreaming() : weak_factory_(this) {
+}
+
+CastStreaming::~CastStreaming() {
+}
+
+void CastStreaming::Init(std::string ipstr, int port) {
+    LOG(INFO) << __func__ << " init cast streaming ...";
+
+    test_thread_.reset(new base::Thread("Cast sender test app thread"));
+    audio_thread_.reset(new base::Thread("Cast audio encoder thread"));
+    video_thread_.reset(new base::Thread("Cast video encoder thread"));
+    test_thread_->Start();
+    audio_thread_->Start();
+    video_thread_->Start();
+
+    io_message_loop_.reset(new base::MessageLoopForIO());
+
+    // Get default audio/video config
+    media::cast::AudioSenderConfig audio_config = GetAudioSenderConfig();
+    media::cast::VideoSenderConfig video_config = GetVideoSenderConfig();
+
+    // Running transport on the main thread.
+    // Setting up transport config.
+    net::IPEndPoint remote_endpoint = CreateUDPAddress(ipstr, static_cast<uint16>(port));
+
+    // Enable raw event and stats logging.
+    // Running transport on the main thread.
+    cast_environment_ = new media::cast::CastEnvironment(
+            make_scoped_ptr<base::TickClock>(new base::DefaultTickClock()),
+            io_message_loop_->message_loop_proxy(),
+            audio_thread_->message_loop_proxy(),
+            video_thread_->message_loop_proxy());
+
+    // SendProcess initialization.
+    cast_source_.reset(new media::cast::CastSource(
+                test_thread_->message_loop_proxy(),
+                cast_environment_->Clock(),
+                video_config, false));
+
+    // CastTransportSender initialization.
+    transport_sender_ = media::cast::CastTransportSender::Create(
+                NULL,  // net log.
+                cast_environment_->Clock(),
+                net::IPEndPoint(),
+                remote_endpoint,
+                make_scoped_ptr(new base::DictionaryValue),  // options
+                base::Bind(&UpdateCastTransportStatus),
+                base::Bind(&LogRawEvents, cast_environment_),
+                base::TimeDelta::FromSeconds(1),
+                media::cast::PacketReceiverCallback(),
+                io_message_loop_->message_loop_proxy());
+
+    // CastSender initialization.
+    cast_sender_ = media::cast::CastSender::Create(cast_environment_, transport_sender_.get());
+    cast_sender_->InitializeVideo(
+            cast_source_->get_video_config(),
+            base::Bind(&InitializationResult),
+            media::cast::CreateDefaultVideoEncodeAcceleratorCallback(),
+            media::cast::CreateDefaultVideoEncodeMemoryCallback());
+    cast_sender_->InitializeAudio(audio_config, base::Bind(&InitializationResult));
+
+    // Set up event subscribers.
+    video_event_subscriber_.reset(new media::cast::EncodingEventSubscriber(media::cast::VIDEO_EVENT, 10000));
+    audio_event_subscriber_.reset(new media::cast::EncodingEventSubscriber(media::cast::AUDIO_EVENT, 10000));
+    cast_environment_->Logging()->AddRawEventSubscriber(video_event_subscriber_.get());
+    cast_environment_->Logging()->AddRawEventSubscriber(audio_event_subscriber_.get());
+
+    // Subscribers for stats.
+    offset_estimator_.reset(new media::cast::ReceiverTimeOffsetEstimatorImpl());
+    cast_environment_->Logging()->AddRawEventSubscriber(offset_estimator_.get());
+
+    video_stats_subscriber_.reset(new media::cast::StatsEventSubscriber(
+                media::cast::VIDEO_EVENT,
+                cast_environment_->Clock(),
+                offset_estimator_.get()));
+    audio_stats_subscriber_.reset(new media::cast::StatsEventSubscriber(
+                media::cast::AUDIO_EVENT,
+                cast_environment_->Clock(),
+                offset_estimator_.get()));
+    cast_environment_->Logging()->AddRawEventSubscriber(video_stats_subscriber_.get());
+    cast_environment_->Logging()->AddRawEventSubscriber(audio_stats_subscriber_.get());
+}
+
+void CastStreaming::Start() {
+    std::string video_log_file_name("/tmp/video_events.log.gz");
+    std::string audio_log_file_name("/tmp/audio_events.log.gz");
+    LOG(INFO) << "Logging audio events to: " << audio_log_file_name;
+    LOG(INFO) << "Logging video events to: " << video_log_file_name;
+
+    base::ScopedFILE video_log_file(fopen(video_log_file_name.c_str(), "w"));
+    if (!video_log_file) {
+        VLOG(1) << "Failed to open video log file for writing.";
+    }
+
+    base::ScopedFILE audio_log_file(fopen(audio_log_file_name.c_str(), "w"));
+    if (!audio_log_file) {
+        VLOG(1) << "Failed to open audio log file for writing.";
+    }
+
+    LOG(INFO) << __func__ << " run io_message_loop ..";
+    const int logging_duration_seconds = 10;
+    io_message_loop_->message_loop_proxy()->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&WriteLogsToFileAndDestroySubscribers,
+                cast_environment_,
+                base::Passed(&video_event_subscriber_),
+                base::Passed(&audio_event_subscriber_),
+                base::Passed(&video_log_file),
+                base::Passed(&audio_log_file)),
+            base::TimeDelta::FromSeconds(logging_duration_seconds));
+
+    io_message_loop_->message_loop_proxy()->PostDelayedTask(
+            FROM_HERE,
+            base::Bind(&WriteStatsAndDestroySubscribers,
+                cast_environment_,
+                base::Passed(&video_stats_subscriber_),
+                base::Passed(&audio_stats_subscriber_),
+                base::Passed(&offset_estimator_)),
+            base::TimeDelta::FromSeconds(logging_duration_seconds));
+
+    cast_environment_->PostTask(
+            media::cast::CastEnvironment::MAIN,
+            FROM_HERE,
+            base::Bind(StartMain, cast_source_.get(), cast_sender_.get()));
+
+    io_message_loop_->Run();
+}
+
+} // namespace cast
+} // namespace media
diff --git a/media/cast/cast_streaming.h b/media/cast/cast_streaming.h
new file mode 100644
index 0000000..c300385
--- /dev/null
+++ b/media/cast/cast_streaming.h
@@ -0,0 +1,62 @@
+#ifndef MEDIA_CAST_CAST_STREAMING_H_
+#define MEDIA_CAST_CAST_STREAMING_H_
+
+#include <map>
+
+#include "base/memory/linked_ptr.h"
+#include "base/memory/weak_ptr.h"
+
+#include "media/base/media.h"
+#include "media/base/video_frame.h"
+#include "media/cast/cast_config.h"
+#include "media/cast/cast_environment.h"
+#include "media/cast/cast_sender.h"
+#include "media/cast/logging/encoding_event_subscriber.h"
+#include "media/cast/logging/log_serializer.h"
+#include "media/cast/logging/logging_defines.h"
+#include "media/cast/logging/proto/raw_events.pb.h"
+#include "media/cast/logging/receiver_time_offset_estimator_impl.h"
+#include "media/cast/logging/stats_event_subscriber.h"
+#include "media/cast/net/cast_transport_defines.h"
+#include "media/cast/net/cast_transport_sender.h"
+#include "media/cast/net/udp_transport.h"
+#include "media/cast/cast_source.h"
+
+
+namespace media {
+namespace cast {
+
+// Native code that handle <video>/<audio>'s casting.
+class CastStreaming {
+public:
+    explicit CastStreaming();
+    ~CastStreaming();
+
+    void Init(std::string ipstr, int port);
+    void Start();
+
+private:
+    scoped_refptr<media::cast::CastEnvironment> cast_environment_;
+    scoped_ptr<media::cast::CastSource> cast_source_;
+    scoped_ptr<media::cast::CastTransportSender> transport_sender_;
+    scoped_ptr<media::cast::CastSender> cast_sender_;
+
+    scoped_ptr<media::cast::EncodingEventSubscriber> video_event_subscriber_;
+    scoped_ptr<media::cast::EncodingEventSubscriber> audio_event_subscriber_;
+    scoped_ptr<media::cast::ReceiverTimeOffsetEstimatorImpl> offset_estimator_;
+    scoped_ptr<media::cast::StatsEventSubscriber> video_stats_subscriber_;
+    scoped_ptr<media::cast::StatsEventSubscriber> audio_stats_subscriber_;
+
+    scoped_ptr<base::Thread> test_thread_;
+    scoped_ptr<base::Thread> audio_thread_;
+    scoped_ptr<base::Thread> video_thread_;
+    scoped_ptr<base::MessageLoopForIO> io_message_loop_;
+
+    base::WeakPtrFactory<CastStreaming> weak_factory_;
+    DISALLOW_COPY_AND_ASSIGN(CastStreaming);
+};
+
+}  // namespace cast
+}  // namespace media
+
+#endif  // MEDIA_CAST_CAST_STREAMING_H_
-- 
1.7.9.5


From af04282d3c72c28f0c20a6a41659e5695c63b022 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 2 Mar 2015 16:41:37 +0800
Subject: [PATCH 123/128] [todo] simple cast_streaming/cast_source

---
 media/cast/cast_source.cc    |  289 +++++++-----------------------------------
 media/cast/cast_source.h     |   51 ++------
 media/cast/cast_streaming.cc |   15 ++-
 media/cast/cast_streaming.h  |    1 +
 4 files changed, 69 insertions(+), 287 deletions(-)

diff --git a/media/cast/cast_source.cc b/media/cast/cast_source.cc
index 17f7d8e..1024ab3 100644
--- a/media/cast/cast_source.cc
+++ b/media/cast/cast_source.cc
@@ -20,48 +20,28 @@
 #include "media/cast/cast_sender.h"
 #include "media/cast/test/utility/audio_utility.h"
 #include "media/cast/test/utility/video_utility.h"
-//#include "media/ffmpeg/ffmpeg_common.h"
-//#include "media/ffmpeg/ffmpeg_deleters.h"
 #include "media/filters/audio_renderer_algorithm.h"
 #include "media/filters/ffmpeg_demuxer.h"
 #include "media/filters/ffmpeg_glue.h"
 #include "media/filters/in_memory_url_protocol.h"
 #include "ui/gfx/size.h"
 
-namespace {
-
-static const int kAudioChannels = 2;
-static const int kAudioSamplingFrequency = 48000;
-static const int kSoundFrequency = 1234;  // Frequency of sinusoid wave.
-static const float kSoundVolume = 0.5f;
-static const int kAudioFrameMs = 10;  // Each audio frame is exactly 10ms.
-static const int kAudioPacketsPerSecond = 1000 / kAudioFrameMs;
-
-}  // namespace
 
 namespace media {
 namespace cast {
 
+static const int kAudioFrameMs = 10;  // Each audio frame is exactly 10ms.
+
 CastSource::CastSource(
     scoped_refptr<base::SingleThreadTaskRunner> task_runner,
     base::TickClock* clock,
-    const VideoSenderConfig& video_config,
-    bool keep_frames)
+    const AudioSenderConfig& audio_config,
+    const VideoSenderConfig& video_config)
     : task_runner_(task_runner),
+      audio_config_(audio_config),
       video_config_(video_config),
-      keep_frames_(keep_frames),
-      synthetic_count_(0),
       clock_(clock),
-      audio_frame_count_(0),
-      video_frame_count_(0),
-      playback_rate_(1.0),
-      video_frame_rate_numerator_(video_config.max_frame_rate),
-      video_frame_rate_denominator_(1),
       weak_factory_(this) {
-  audio_bus_factory_.reset(new TestAudioBusFactory(kAudioChannels,
-                                                   kAudioSamplingFrequency,
-                                                   kSoundFrequency,
-                                                   kSoundVolume));
 }
 
 CastSource::~CastSource() {
@@ -69,146 +49,40 @@ CastSource::~CastSource() {
 
 void CastSource::Start(scoped_refptr<AudioFrameInput> audio_frame_input,
                        scoped_refptr<VideoFrameInput> video_frame_input) {
-  audio_frame_input_ = audio_frame_input;
-  video_frame_input_ = video_frame_input;
-
-  LOG(INFO) << __func__ 
-            << " audio_frame_input=" << audio_frame_input
-            << " video_frame_input=" << video_frame_input;
-  if (!audio_frame_input && !video_frame_input) return;
+    audio_frame_input_ = audio_frame_input;
+    video_frame_input_ = video_frame_input;
 
-  LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
-  LOG(INFO) << "Source Frame rate: "
-            << video_frame_rate_numerator_ << "/"
-            << video_frame_rate_denominator_ << " fps.";
-  LOG(INFO) << "Audio playback rate: " << playback_rate_;
+    LOG(INFO) << __func__ 
+        << " audio_frame_input=" << audio_frame_input
+        << " video_frame_input=" << video_frame_input;
+    if (!audio_frame_input && !video_frame_input) return;
 
-  if (start_time_.is_null())
-    start_time_ = clock_->NowTicks();
+    LOG(INFO) << "Max Frame rate: " << video_config_.max_frame_rate;
+    if (start_time_.is_null())
+        start_time_ = clock_->NowTicks();
 
-  if (!is_transcoding_audio() && !is_transcoding_video()) {
-    // Send fake patterns.
     task_runner_->PostTask(
-        FROM_HERE,
-        base::Bind(
-            &CastSource::SendNextFakeFrame,
-            base::Unretained(this)));
-    return;
-  }
-
-  // Send transcoding streams.
-  if (audio_params_.IsValid()) {
-    audio_algo_.Initialize(audio_params_);
-    audio_algo_.FlushBuffers();
-    audio_fifo_input_bus_ = AudioBus::Create(
-        audio_params_.channels(), audio_params_.frames_per_buffer());
-    // Audio FIFO can carry all data fron AudioRendererAlgorithm.
-    audio_fifo_.reset(new AudioFifo(audio_params_.channels(),
-        audio_algo_.QueueCapacity()));
-    audio_resampler_.reset(new media::MultiChannelResampler(
-        audio_params_.channels(),
-        static_cast<double>(audio_params_.sample_rate()) / kAudioSamplingFrequency,
-        audio_params_.frames_per_buffer(),
-        base::Bind(&CastSource::ProvideData, base::Unretained(this))));
-  }
-
-  task_runner_->PostTask(
-      FROM_HERE,
-      base::Bind(
-          &CastSource::SendNextFrame,
-          base::Unretained(this)));
-}
-
-void CastSource::SendNextFakeFrame() {
-    gfx::Size size(video_config_.width, video_config_.height);
-    scoped_refptr<VideoFrame> video_frame = VideoFrame::CreateBlackFrame(size);
-    PopulateVideoFrame(video_frame.get(), synthetic_count_);
-    ++synthetic_count_;
-
-    const base::TimeTicks now = clock_->NowTicks();
-
-    base::TimeDelta video_time = VideoFrameTime(++video_frame_count_);
-    video_frame->set_timestamp(video_time);
-    if (keep_frames_)
-        inserted_video_frame_queue_.push(video_frame);
-    if (video_frame_input_)
-        video_frame_input_->InsertRawVideoFrame(video_frame, start_time_ + video_time);
-
-    // Send just enough audio data to match next video frame's time.
-    base::TimeDelta audio_time = AudioFrameTime(audio_frame_count_);
-    while (audio_time < video_time) {
-        if (is_transcoding_audio()) {
-            CHECK(!audio_bus_queue_.empty()) << "No audio decoded.";
-            scoped_ptr<AudioBus> bus(audio_bus_queue_.front());
-            audio_bus_queue_.pop();
-            audio_frame_input_->InsertAudio(bus.Pass(), start_time_ + audio_time);
-        } else {
-            audio_frame_input_->InsertAudio(audio_bus_factory_->NextAudioBus(
-                base::TimeDelta::FromMilliseconds(kAudioFrameMs)), start_time_ + audio_time);
-        }
-        audio_time = AudioFrameTime(++audio_frame_count_);
-    }
-
-    // This is the time since CastSource was started.
-    const base::TimeDelta elapsed_time = now - start_time_;
-
-    // Handle the case when frame generation cannot keep up.
-    // Move the time ahead to match the next frame.
-    while (video_time < elapsed_time) {
-        LOG(WARNING) << "Skipping one frame.";
-        video_time = VideoFrameTime(++video_frame_count_);
-    }
-
-    task_runner_->PostDelayedTask(
-      FROM_HERE,
-      base::Bind(&CastSource::SendNextFakeFrame,
-                 weak_factory_.GetWeakPtr()),
-      video_time - elapsed_time);
+            FROM_HERE,
+            base::Bind(&CastSource::SendNextFrame, base::Unretained(this)));
 }
 
 bool CastSource::SendNextTranscodedVideo(base::TimeDelta elapsed_time) {
     if (!is_transcoding_video())
         return false;
 
-    if (video_frame_queue_.empty())
-        return false;
-
-    scoped_refptr<VideoFrame> decoded_frame = video_frame_queue_.front();
-#if 0
-    LOG(INFO) << __func__ 
-        << " elapsed_time=" << elapsed_time
-        << " video timestamp=" << decoded_frame->timestamp();
-#endif
-    if (elapsed_time < decoded_frame->timestamp())
-        return false;
-
-    gfx::Size size(video_config_.width, video_config_.height);
-    scoped_refptr<VideoFrame> video_frame = VideoFrame::CreateBlackFrame(size);
-    video_frame_queue_.pop();
-    media::CopyPlane(VideoFrame::kYPlane,
-            decoded_frame->data(VideoFrame::kYPlane),
-            decoded_frame->stride(VideoFrame::kYPlane),
-            decoded_frame->rows(VideoFrame::kYPlane),
-            video_frame.get());
-    media::CopyPlane(VideoFrame::kUPlane,
-            decoded_frame->data(VideoFrame::kUPlane),
-            decoded_frame->stride(VideoFrame::kUPlane),
-            decoded_frame->rows(VideoFrame::kUPlane),
-            video_frame.get());
-    media::CopyPlane(VideoFrame::kVPlane,
-            decoded_frame->data(VideoFrame::kVPlane),
-            decoded_frame->stride(VideoFrame::kVPlane),
-            decoded_frame->rows(VideoFrame::kVPlane),
-            video_frame.get());
+    scoped_refptr<VideoFrame> video_frame;
+    video_lock_.Acquire();
+    if (!video_frame_queue_.empty()) {
+        video_frame = video_frame_queue_.front();
+        video_frame_queue_.pop();
+    }
+    video_lock_.Release();
 
-    // Use the timestamp from the file if we're transcoding.
-    video_frame->set_timestamp(ScaleTimestamp(decoded_frame->timestamp()));
-    if (keep_frames_)
-        inserted_video_frame_queue_.push(video_frame);
+    if (!video_frame) return false;
 
-    if (video_frame_input_)
-        video_frame_input_->InsertRawVideoFrame(
-                video_frame, start_time_ + video_frame->timestamp());
+    if (video_frame_input_) {
+        video_frame_input_->InsertRawVideoFrame(video_frame, video_frame->timestamp() + start_time_);
+    }
 
     return true;
 }
@@ -220,117 +94,50 @@ bool CastSource::SendNextTranscodedAudio(base::TimeDelta elapsed_time) {
     if (audio_bus_queue_.empty())
         return false;
 
-    base::TimeDelta audio_time = audio_sent_ts_->GetTimestamp();
-    if (elapsed_time < audio_time)
-        return false;
+    audio_lock_.Acquire();
     scoped_ptr<AudioBus> bus(audio_bus_queue_.front());
     audio_bus_queue_.pop();
-    audio_sent_ts_->AddFrames(bus->frames());
-    audio_frame_input_->InsertAudio(bus.Pass(), start_time_ + audio_time);
+    audio_lock_.Release();
+    audio_frame_input_->InsertAudio(bus.Pass(), start_time_);
 
     return true;
 }
 
 void CastSource::SendNextFrame() {
-    // Send as much as possible. Audio is sent according to
-    // system time.
+    // Send as much as possible. Audio is sent according to system time.
     while (SendNextTranscodedAudio(clock_->NowTicks() - start_time_));
 
-    // fix video play without audio track
-    if (!is_transcoding_audio()) {
-        if(!audio_sent_ts_) {
-            audio_sent_ts_.reset(new AudioTimestampHelper(30));
-            base::TimeDelta base_ts;
-            audio_sent_ts_->SetBaseTimestamp(base_ts);
-        }
-        audio_sent_ts_->AddFrames(1);
-        //LOG(INFO) << __func__ << " audio timestamp=" << audio_sent_ts_->GetTimestamp();
-    }
     // Video is sync'ed to audio.
-    while (SendNextTranscodedVideo(audio_sent_ts_->GetTimestamp()));
-
-    if (audio_bus_queue_.empty() && video_frame_queue_.empty()) {
-        LOG(INFO) << "no any audio/video frame.";
-    }
+    while (SendNextTranscodedVideo(clock_->NowTicks() - start_time_));
 
     // Send next send.
     task_runner_->PostDelayedTask(
             FROM_HERE,
-            base::Bind(
-                &CastSource::SendNextFrame,
-                base::Unretained(this)),
+            base::Bind(&CastSource::SendNextFrame, base::Unretained(this)),
             base::TimeDelta::FromMilliseconds(kAudioFrameMs));
 }
 
-base::TimeDelta CastSource::VideoFrameTime(int frame_number) {
-    return frame_number * base::TimeDelta::FromSeconds(1) *
-        video_frame_rate_denominator_ / video_frame_rate_numerator_;
-}
-
-base::TimeDelta CastSource::ScaleTimestamp(base::TimeDelta timestamp) {
-    return base::TimeDelta::FromSecondsD(timestamp.InSecondsF() / playback_rate_);
-}
-
-base::TimeDelta CastSource::AudioFrameTime(int frame_number) {
-    return frame_number * base::TimeDelta::FromMilliseconds(kAudioFrameMs);
-}
-
 void CastSource::InputRawAudio(const scoped_refptr<AudioBuffer> buffer) {
-    audio_algo_.EnqueueBuffer(buffer);
-    int frames_needed_to_scale = 0;
-    while (frames_needed_to_scale <= audio_algo_.frames_buffered()) {
-        if (!audio_algo_.FillBuffer(audio_fifo_input_bus_.get(), 0,
-                    audio_fifo_input_bus_->frames(),
-                    playback_rate_)) {
-            // Nothing can be scaled. Decode some more.
-            return;
-        }
-
-        // Prevent overflow of audio data in the FIFO.
-        if (audio_fifo_input_bus_->frames() + audio_fifo_->frames()
-                <= audio_fifo_->max_frames()) {
-            audio_fifo_->Push(audio_fifo_input_bus_.get());
-        } else {
-            LOG(WARNING) << "Audio FIFO full; dropping samples.";
-        }
-
-        // Make sure there's enough data to resample audio.
-        if (audio_fifo_->frames() <
-                2 * audio_params_.sample_rate() / kAudioPacketsPerSecond) {
-            continue;
-        }
-
-        scoped_ptr<media::AudioBus> resampled_bus(
-                media::AudioBus::Create(audio_params_.channels(),
-                    kAudioSamplingFrequency / kAudioPacketsPerSecond));
-        audio_resampler_->Resample(resampled_bus->frames(),
-                resampled_bus.get());
-        audio_bus_queue_.push(resampled_bus.release());
-    }
+    LOG(INFO) << __func__ << " Add one audio buffer";
+    int frame_count = buffer->frame_count();
+    int channel_count = buffer->channel_count();
+    //int sample_rate = buffer->sample_rate();
+    //int timestamp = buffer->timestamp();
+
+    scoped_ptr<media::AudioBus> resampled_bus = media::AudioBus::Create(channel_count, frame_count);
+    buffer->ReadFrames(frame_count, 0, 0, resampled_bus.get());
+
+    audio_lock_.Acquire();
+    audio_bus_queue_.push(resampled_bus.release());
+    audio_lock_.Release();
 }
 
 void CastSource::InputRawVideo(const scoped_refptr<VideoFrame>& frame) {
-    // TODO: adjusting timestamp
+    LOG(INFO) << __func__ << " Add one video frame";
+    video_lock_.Acquire();
     video_frame_queue_.push(frame);
+    video_lock_.Release();
 }
 
-void CastSource::ProvideData(int frame_delay, media::AudioBus* output_bus) {
-    if (audio_fifo_->frames() >= output_bus->frames()) {
-        audio_fifo_->Consume(output_bus, 0, output_bus->frames());
-    } else {
-        LOG(WARNING) << "Not enough audio data for resampling.";
-        output_bus->Zero();
-    }
-}
-
-scoped_refptr<media::VideoFrame>
-CastSource::PopOldestInsertedVideoFrame() {
-    CHECK(!inserted_video_frame_queue_.empty());
-    scoped_refptr<media::VideoFrame> video_frame = inserted_video_frame_queue_.front();
-    inserted_video_frame_queue_.pop();
-    return video_frame;
-}
-
-
 }  // namespace cast
 }  // namespace media
diff --git a/media/cast/cast_source.h b/media/cast/cast_source.h
index 6c53cd9..bb3dcff 100644
--- a/media/cast/cast_source.h
+++ b/media/cast/cast_source.h
@@ -14,6 +14,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/single_thread_task_runner.h"
 #include "base/time/tick_clock.h"
+#include "media/base/channel_layout.h"
 #include "media/audio/audio_parameters.h"
 #include "media/cast/cast_config.h"
 #include "media/filters/audio_renderer_algorithm.h"
@@ -42,11 +43,10 @@ public:
     // |task_runner| is to schedule decoding tasks.
     // |clock| is used by this source but is not owned.
     // |video_config| is the desired video config.
-    // |keep_frames| is true if all VideoFrames are saved in a queue.
     CastSource(scoped_refptr<base::SingleThreadTaskRunner> task_runner,
             base::TickClock* clock,
-            const VideoSenderConfig& video_config,
-            bool keep_frames);
+            const AudioSenderConfig& audio_config,
+            const VideoSenderConfig& video_config);
     ~CastSource();
 
     void Start(scoped_refptr<AudioFrameInput> audio_frame_input,
@@ -56,68 +56,37 @@ public:
 
     void InputRawVideo(const scoped_refptr<VideoFrame>& frame);
 
+    const AudioSenderConfig& get_audio_config() const { return audio_config_; }
     const VideoSenderConfig& get_video_config() const { return video_config_; }
 
-    scoped_refptr<media::VideoFrame> PopOldestInsertedVideoFrame();
 
 protected:
     bool is_transcoding_audio() {return true;}
     bool is_transcoding_video() {return true;}
 
     void SendNextFrame();
-    void SendNextFakeFrame();
-
     // Return true if a frame was sent.
     bool SendNextTranscodedVideo(base::TimeDelta elapsed_time);
-
     // Return true if a frame was sent.
     bool SendNextTranscodedAudio(base::TimeDelta elapsed_time);
 
-    // Helper methods to compute timestamps for the frame number specified.
-    base::TimeDelta VideoFrameTime(int frame_number);
-
-    base::TimeDelta ScaleTimestamp(base::TimeDelta timestamp);
-
-    base::TimeDelta AudioFrameTime(int frame_number);
-
-    void ProvideData(int frame_delay, media::AudioBus* output_bus);
-
 
 private:
     const scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-    const VideoSenderConfig video_config_;
-    const bool keep_frames_;
+    AudioSenderConfig audio_config_;
+    VideoSenderConfig video_config_;
+
     scoped_refptr<AudioFrameInput> audio_frame_input_;
     scoped_refptr<VideoFrameInput> video_frame_input_;
-    uint8 synthetic_count_;
-    base::TickClock* const clock_;  // Not owned by this class.
 
+    base::TickClock* const clock_;  // Not owned by this class.
     // Time when the stream starts.
     base::TimeTicks start_time_;
 
-    // The following three members are used only for fake frames.
-    int audio_frame_count_;  // Each audio frame is exactly 10ms.
-    int video_frame_count_;
-    scoped_ptr<TestAudioBusFactory> audio_bus_factory_;
-
-    AudioParameters audio_params_;
-    double playback_rate_;
-
-    int video_frame_rate_numerator_;
-    int video_frame_rate_denominator_;
-
-    // These are used for audio resampling.
-    scoped_ptr<media::MultiChannelResampler> audio_resampler_;
-    scoped_ptr<media::AudioFifo> audio_fifo_;
-    scoped_ptr<media::AudioBus> audio_fifo_input_bus_;
-    media::AudioRendererAlgorithm audio_algo_;
-
-    // Track the timestamp of audio sent to the receiver.
-    scoped_ptr<media::AudioTimestampHelper> audio_sent_ts_;
-
     // for transcoding video/audio frame
+    base::Lock audio_lock_;
+    base::Lock video_lock_;
     std::queue<scoped_refptr<VideoFrame> > video_frame_queue_;
-    std::queue<scoped_refptr<VideoFrame> > inserted_video_frame_queue_;
     std::queue<AudioBus*> audio_bus_queue_;
 
     // NOTE: Weak pointers must be invalidated before all other member variables.
diff --git a/media/cast/cast_streaming.cc b/media/cast/cast_streaming.cc
index 117a4e5..5d02e1e 100644
--- a/media/cast/cast_streaming.cc
+++ b/media/cast/cast_streaming.cc
@@ -212,9 +212,9 @@ static void WriteStatsAndDestroySubscribers(
 }
 
 static void StartMain(media::cast::CastSource* source, media::cast::CastSender* sender) {
-  LOG(INFO) << __func__;
-  if (!source || !sender) return;
-  source->Start(sender->audio_frame_input(), sender->video_frame_input());
+    LOG(INFO) << __func__;
+    if (!source || !sender) return;
+    source->Start(sender->audio_frame_input(), sender->video_frame_input());
 }
 
 } // namespace cast
@@ -262,7 +262,8 @@ void CastStreaming::Init(std::string ipstr, int port) {
     cast_source_.reset(new media::cast::CastSource(
                 test_thread_->message_loop_proxy(),
                 cast_environment_->Clock(),
-                video_config, false));
+                audio_config,
+                video_config));
 
     // CastTransportSender initialization.
     transport_sender_ = media::cast::CastTransportSender::Create(
@@ -276,7 +277,9 @@ void CastStreaming::Init(std::string ipstr, int port) {
                 base::TimeDelta::FromSeconds(1),
                 media::cast::PacketReceiverCallback(),
                 io_message_loop_->message_loop_proxy());
+}
 
+void CastStreaming::Preload() {
     // CastSender initialization.
     cast_sender_ = media::cast::CastSender::Create(cast_environment_, transport_sender_.get());
     cast_sender_->InitializeVideo(
@@ -284,7 +287,9 @@ void CastStreaming::Init(std::string ipstr, int port) {
             base::Bind(&InitializationResult),
             media::cast::CreateDefaultVideoEncodeAcceleratorCallback(),
             media::cast::CreateDefaultVideoEncodeMemoryCallback());
-    cast_sender_->InitializeAudio(audio_config, base::Bind(&InitializationResult));
+    cast_sender_->InitializeAudio(
+            cast_source_->get_audio_config(),
+            base::Bind(&InitializationResult));
 
     // Set up event subscribers.
     video_event_subscriber_.reset(new media::cast::EncodingEventSubscriber(media::cast::VIDEO_EVENT, 10000));
diff --git a/media/cast/cast_streaming.h b/media/cast/cast_streaming.h
index c300385..505f3d4 100644
--- a/media/cast/cast_streaming.h
+++ b/media/cast/cast_streaming.h
@@ -33,6 +33,7 @@ public:
     ~CastStreaming();
 
     void Init(std::string ipstr, int port);
+    void Preload();
     void Start();
 
 private:
-- 
1.7.9.5


From cb7e0d55844310e4af4744f300dddade1a1c1f78 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Mon, 2 Mar 2015 21:15:10 +0800
Subject: [PATCH 124/128] [ok] fix case1 of processing click events

---
 net/mmt/mmt_control.cc |    2 ++
 net/mmt/mmt_parser.cc  |   67 +++++++++++++++++++++++++++++++++---------------
 net/mmt/mmt_parser.h   |   13 +++++++---
 3 files changed, 59 insertions(+), 23 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index bb2464bf..0075e00 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -269,6 +269,8 @@ void ProcCiXml(cixmlptr_t cixml, int tabid) {
             LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
             cixml->parser = nullptr;
             cixml->update = 15;
+        }else {
+            cixml->parser->PrintHtmlJS();
         }
     }
 
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 3843c45..35b229e 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -262,7 +262,7 @@ node_t::~node_t() {
     parent = nullptr;
 }
 
-html_t::html_t() : node(nullptr) {
+html_t::html_t() : node(nullptr), icss(0) {
 }
 html_t::~html_t() {
     js.clear();
@@ -323,8 +323,11 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     std::string css;            // for css style
     std::string js0, js1;       // for time of begin and end
     std::string js2;            // for event, e.g. onclick
-    js0 = js1 = js2 = SetJSBegin(id);
+    std::string js3;            // for EHtmlClear
+    js0 = js1 = js2 = js3 = SetJSBegin(id);
+    js0 += SetJSAttr(id, "style.display", "block");
     js2 += SetJSEventBegin(id, "onclick");
+    js3 += SetJSAttr(id, "style.display", "none");
 
     std::string style = node->attrs[kstyle];
     if (!style.empty()) {
@@ -379,6 +382,7 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
     html->js[EHtmlBegin] = js0;       //> self's begin
     html->js[EHtmlEnd] = js1;         //> self's end
     html->js[EHtmlClick] = js2;       //> other use this click.
+    html->js[EHtmlClear] = js3;
     htmls[id] = html;
 }
 
@@ -445,8 +449,8 @@ bool CiParser::ParseHtml() {
 
     ///===================
 
-    htmlmap_t::iterator iter;
     // process end of time js
+    htmlmap_t::iterator iter;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         if (iter->first == "html") continue;
@@ -480,16 +484,31 @@ bool CiParser::ParseHtml() {
         }
     }
 
-    // process end of event click
+    // process end of event click, EHtmlClear
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         html->js[EHtmlClick] += SetJSEventEnd();
         html->js[EHtmlClick] += SetJSEnd();
+        html->js[EHtmlClear] += SetJSEnd();
     }
     return true;
 }
 
+void CiParser::PrintHtmlJS() {
+    htmlmap_t::iterator iter;
+    for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
+        htmlptr_t html = iter->second;
+        LOG(INFO) << __func__ << " node=" << html->node->name << " id=" << html->id
+            << " css=" << html->js[EHtmlCSS]
+            << " begin=" << html->js[EHtmlBegin]
+            << " end=" << html->js[EHtmlEnd]
+            << " click=" << html->js[EHtmlClick]
+            << " clear=" << html->js[EHtmlClear];
+    }
+}
+
 // merge ev2 into ev1
 void MergeEvent(event_t& ev1, event_t& ev2) {
     LOG(INFO) << __func__ << " event update, time1=" << ev1.time << " time2="<<ev2.time;
@@ -622,17 +641,17 @@ bool CiParser::MergeCI2(CiParser* parser) {
 /**
  * To process both @begin and @end
  */
-bool CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
+int CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
     int64 curtime = -1;
-    if (!cnode) return false;
+    if (!cnode) return -2;
 
     event_t begin = cnode->time.begin;
-    if (begin.is_timeout > 0) return false;
+    if (begin.is_timeout > 0) return 1;
 
     if (begin.event == kevclick) {
         ev = EHtmlClick;
         cnode->time.begin.is_timeout = 1;
-        return true;
+        return 0;
     }else {
         ev = EHtmlBegin;
         curtime = begin.time;
@@ -652,22 +671,22 @@ bool CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
     LOG(INFO) << __func__ << " node name=" << begin.id << " curtime=" << curtime << " current=" << current;
     if (curtime < 0 || curtime <= current) {
         cnode->time.begin.is_timeout = 1;
-        return true;
+        return 0;
     }
-    return false;
+    return -1;
 }
 
-bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
+int CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
     int64 curtime = -1;
-    if (!cnode) return false;
+    if (!cnode) return -2;
 
     event_t end = cnode->time.end;
-    if (end.is_timeout > 0) return false;
+    if (end.is_timeout > 0) return 1;
 
     if (end.event == kevclick) {
         ev = EHtmlClick;
         cnode->time.end.is_timeout = 1;
-        return true;
+        return 0;
     }else {
         ev = EHtmlEnd;
         curtime = end.time;
@@ -689,9 +708,9 @@ bool CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
 #endif
     if (curtime >= 0 && curtime <= current) {
         cnode->time.end.is_timeout = 1;
-        return true;
+        return 0;
     }
-    return false;
+    return -1;
 }
 
 /**
@@ -720,7 +739,8 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
-        if (ShouldEndTime(current, node, ev)) {
+        int iret = ShouldEndTime(current, node, ev);
+        if (iret == 0) {
             if (ev == EHtmlClick)
                 html = htmls_[node->time.end.id];
             if (html) {
@@ -731,14 +751,22 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
                 }else {
                     LOG(INFO) << __func__ << " begin exist, key=" << key;
                 }
-                //css += html->js[EHtmlCSS];
             }
         }
     }
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
-        if (ShouldBeginTime(current, node, ev)) {
+        int iret = ShouldBeginTime(current, node, ev);
+        if (iret >= -1 && html->icss <= 0) {
+            css += html->js[EHtmlCSS];
+            html->icss = 1;
+        }
+        if (iret == -1 || (iret == 0 && ev == EHtmlClick)) {
+            js2 += html->js[EHtmlClear];
+            //LOG(INFO) << __func__ << " set js clear=" << html->js[EHtmlClear];
+        }
+        if (iret == 0) {
             if (ev == EHtmlClick)
                 html = htmls_[node->time.begin.id];
             if (html) {
@@ -749,7 +777,6 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
                 }else {
                     LOG(INFO) << __func__ << " end exist, key=" << key;
                 }
-                css += html->js[EHtmlCSS];
             }
         }
     }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 04d9ac0..789d8fd 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -22,6 +22,7 @@ typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name =>
  * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
+    EHtmlClear,
     EHtmlCSS,
     EHtmlBegin,         //> mmtci:begin
     EHtmlEnd,           //> mmtci:end
@@ -81,6 +82,7 @@ public:
     std::string id;     //> html tag id
     jsmap_t js;         //> key/value: EHtmlEvent => js
     nodeptr_t node;     //> xml node
+    int icss;           //> used count of css
 
 protected:
     friend class base::RefCounted<html_t>;
@@ -106,8 +108,9 @@ public:
      * To parse html tags based on parsed xml nodes.
      *  So it should be called after ParseXml().
      */
-    bool ParseHtml();
     void SetTabId(int tabid) {tabid_=tabid;}
+    bool ParseHtml();
+    void PrintHtmlJS();
 
     /**
      * To Merge another parser
@@ -146,8 +149,12 @@ public:
 
 protected:
     void SetNodeTime(event_t& event, nodeptr_t node);
-    bool ShouldBeginTime(int64 current, nodeptr_t node, int& ev);
-    bool ShouldEndTime(int64 current, nodeptr_t node, int& ev);
+
+    /**
+     * @return: invalid node if -2, too early if -1, doing if 0, done if 1.
+     */
+    int ShouldBeginTime(int64 current, nodeptr_t node, int& ev);
+    int ShouldEndTime(int64 current, nodeptr_t node, int& ev);
     
 protected:
     friend class base::RefCounted<CiParser>;
-- 
1.7.9.5


From 0c322323751082b848ad1628f5806763f1d64672 Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 3 Mar 2015 00:53:12 +0800
Subject: [PATCH 125/128] [todo] process click events of <view>

---
 net/mmt/mmt_inc.h     |    1 +
 net/mmt/mmt_parser.cc |  165 ++++++++++++++++++++++++++++++++++++++-----------
 net/mmt/mmt_parser.h  |    3 +
 net/mmt/mmt_utils.cc  |    1 +
 4 files changed, 135 insertions(+), 35 deletions(-)

diff --git a/net/mmt/mmt_inc.h b/net/mmt/mmt_inc.h
index 9b62cef..c141f0b 100644
--- a/net/mmt/mmt_inc.h
+++ b/net/mmt/mmt_inc.h
@@ -102,6 +102,7 @@ extern const char kMmtDefaultUrl[];
 // for url query
 extern const char kMmtHtmlId[];
 extern const char kMmtXmlIdPrefix[];
+extern const char kMmtDivIdPrefix[];
 
 }
 
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 35b229e..79eb491 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -147,6 +147,15 @@ static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
     url = url + kMmtHtmlId+"="+id + "&tabid="+Int2String(tabid);
     return url;
 }
+inline std::string CreateJSObject(std::string id, std::string name) {
+    std::string str;
+    str += "if(g_"+id+" == undefined) {";
+    str += "g_"+id+"=document.createElement('"+name+"');";
+    str += "g_"+id+".id='"+id+"';";
+    str += "document.body.appendChild(g_"+id+");";
+    str += "}";
+    return str;
+}
 inline std::string GetJSObject(std::string id) {
     return "g_"+id+" = document.getElementById('"+id+"');";
 }
@@ -203,6 +212,8 @@ std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
         js+= "}";
     }else if (action == konLoad){
         js+= SetJSAttr(id, "src", href);
+    }else { // auto load
+        js+= SetJSAttr(id, "src", href);
     }
     js+= SetJSEnd();
     return js;
@@ -253,6 +264,17 @@ event_t::event_t() {
     is_timeout = 0;     // default non-timeout, that will be processed next time
     time = -1;          // default infinite
 }
+std::string event_t::str() {
+    std::string str;
+    std::stringstream ss;
+    ss << "@is_event=" << is_event;
+    ss << "@is_timeout=" << is_timeout;
+    ss << "@id=" << id;
+    ss << "@event=" << event;
+    ss << "@time=" << time;
+    ss >> str;
+    return str;
+}
 
 node_t::node_t(std::string name) 
     : name(name), parent(nullptr) {
@@ -310,31 +332,50 @@ bool CiParser::ParseXml() {
     return true;
 }
 
-static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
-    if (!node) return;
-
+static std::string GetHtmlId(nodeptr_t node) {
+    if (!node) return "";
     std::string id;
     if (node->name == kdivLocation)     // div
         id = node->attrs[krefDiv];
     else if (node->name == kMediaSync)  // <audio><video><image>
         id = node->attrs[krefId];
+    else if (node->name == kview) {
+        if (node->attrs.find(krefDiv) != node->attrs.end())
+            id = node->attrs[krefDiv];
+        else {
+            id = node->name;
+            if (node->attrs.find("id") != node->attrs.end())
+                id = node->attrs["id"];
+            id = kMmtDivIdPrefix + id + "_";
+            id = id + Int2String(GetLocalTime()%100000);
+            node->attrs[krefDiv] = id;
+        }
+    }
+    return id;
+}
+
+static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
+    std::string id = GetHtmlId(node);
     if (id.empty()) return;
 
     std::string css;            // for css style
     std::string js0, js1;       // for time of begin and end
     std::string js2;            // for event, e.g. onclick
     std::string js3;            // for EHtmlClear
-    js0 = js1 = js2 = js3 = SetJSBegin(id);
-    js0 += SetJSAttr(id, "style.display", "block");
-    js2 += SetJSEventBegin(id, "onclick");
-    js3 += SetJSAttr(id, "style.display", "none");
 
     std::string style = node->attrs[kstyle];
-    if (!style.empty()) {
-        css = SetCSSStyle(id, style);
+    js0 = js1 = js2 = js3 = SetJSBegin(id);
+    if (node->name != kview) {
+        js0 += SetJSAttr(id, "style.display", "block");
+        js2 += SetJSEventBegin(id, "onclick");
+        js3 += SetJSAttr(id, "style.display", "none");
+        if (!style.empty()) css = SetCSSStyle(id, style);
+    }else {
+        //if (!style.empty()) style += ";";
+        //style += "filter:alpha(opacity=100);opacity:1.0;z-index:100;background-color:#ffffff;";
+        //css = SetCSSStyle(id, style);
     }
 
-    // process div
     if (node->name == kdivLocation) {
         // no-op for begin, but have op for end
         js1 += SetDivJSClear(id);
@@ -402,6 +443,54 @@ void CiParser::SetNodeTime(event_t& event, nodeptr_t node) {
     }
 }
 
+void CiParser::ProcEvent(htmlptr_t html, nodeptr_t node) {
+    event_t begin = node->time.begin;
+    if (begin.is_event) {
+        if (begin.event == kevclick) { // for event click
+            if (htmls_.find(begin.id) != htmls_.end()) {
+                if (node->name == kview) {
+                    nodeptrs_t::iterator iter1;
+                    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+                        nodeptr_t sub1 = *iter1;
+                        std::string id = GetHtmlId(sub1);
+                        if (htmls_.find(id) != htmls_.end()) {
+                            htmlptr_t html2 = htmls_[id];
+                            htmls_[begin.id]->js[EHtmlClick] += html2->js[EHtmlBegin];
+                        }
+                    }
+                }else {
+                    htmls_[begin.id]->js[EHtmlClick] += html->js[EHtmlBegin];
+                }
+            }
+        }else if (begin.event == kevbegin || begin.event == kevend) {
+            SetNodeTime(node->time.begin, node); // for event begin/end
+        }
+    }
+
+    event_t end = node->time.end;
+    if (end.is_event) {
+        if (end.event == kevclick) {
+            if (htmls_.find(end.id) != htmls_.end()) {
+                if (node->name == kview) {
+                    nodeptrs_t::iterator iter1;
+                    for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+                        nodeptr_t sub1 = *iter1;
+                        std::string id = GetHtmlId(sub1);
+                        if (htmls_.find(id) != htmls_.end()) {
+                            htmlptr_t html2 = htmls_[id];
+                            htmls_[end.id]->js[EHtmlClick] += html2->js[EHtmlEnd];
+                        }
+                    }
+                }else {
+                    htmls_[end.id]->js[EHtmlClick] += html->js[EHtmlEnd];
+                }
+            }
+        }else if (end.event == kevbegin || end.event == kevend) {
+            SetNodeTime(node->time.end, node);
+        }
+    }
+}
+
 bool CiParser::ParseHtml() {
     nodeptr_t node = root_;
     if (!node) return false;
@@ -412,6 +501,9 @@ bool CiParser::ParseHtml() {
     for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
         nodeptr_t sub1 = *iter1;
         if (sub1->name == kview) {
+            // To create one new <div> for kview
+            InitHtmlJS(sub1, htmls_, tabid_);
+            
             if (sub1->nodes.empty()) { // for subset xml nodes
                 std::string href, actuate;
                 if(sub1->attrs.find(kxlinkhref) != sub1->attrs.end()) {
@@ -447,41 +539,24 @@ bool CiParser::ParseHtml() {
         }
     }
 
+
     ///===================
 
     // process end of time js
     htmlmap_t::iterator iter;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
-        htmlptr_t html = iter->second;
         if (iter->first == "html") continue;
+        htmlptr_t html = iter->second;
         html->js[EHtmlBegin] += SetJSEnd();
         html->js[EHtmlEnd] += SetJSEnd();
     }
 
-    // process interaction events
+    // process interaction events: begin/end/click
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
-        event_t begin = node->time.begin;
-        if (begin.is_event) {
-            if (begin.event == kevclick) {
-                if (htmls_.find(begin.id) != htmls_.end())
-                    htmls_[begin.id]->js[EHtmlClick] += html->js[EHtmlBegin];
-            }else if (begin.event == kevbegin || begin.event == kevend) {
-                SetNodeTime(node->time.begin, node);
-            }
-        }
-
-        event_t end = node->time.end;
-        if (end.is_event) {
-            if (end.event == kevclick) {
-                if (htmls_.find(end.id) != htmls_.end())
-                    htmls_[end.id]->js[EHtmlClick] += html->js[EHtmlEnd];
-            }else if (end.event == kevbegin || end.event == kevend) {
-                SetNodeTime(node->time.end, node);
-            }
-        }
+        ProcEvent(html, node);
     }
 
     // process end of event click, EHtmlClear
@@ -500,12 +575,21 @@ void CiParser::PrintHtmlJS() {
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
-        LOG(INFO) << __func__ << " node=" << html->node->name << " id=" << html->id
+        LOG(INFO) << __func__ 
+            << " node=" << html->node->name 
+            << " id=" << html->id
+            << " time1=" << html->node->time.begin.str()
+            << " time2=" << html->node->time.end.str()
+            << " parent time1=" << html->node->parent->time.begin.str()
+            << " parent time2=" << html->node->parent->time.end.str();
+#ifdef MMT_LOG_V
+        LOG(INFO) << __func__ 
             << " css=" << html->js[EHtmlCSS]
             << " begin=" << html->js[EHtmlBegin]
             << " end=" << html->js[EHtmlEnd]
             << " click=" << html->js[EHtmlClick]
             << " clear=" << html->js[EHtmlClear];
+#endif
     }
 }
 
@@ -643,6 +727,7 @@ bool CiParser::MergeCI2(CiParser* parser) {
  */
 int CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
     int64 curtime = -1;
+    ev = EHtmlNone;
     if (!cnode) return -2;
 
     event_t begin = cnode->time.begin;
@@ -692,7 +777,7 @@ int CiParser::ShouldEndTime(int64 current, nodeptr_t cnode, int& ev) {
         curtime = end.time;
     }
 
-    // search cnode's parent
+    // search cnode's parent and process it
     nodeptr_t node = cnode;
     do {
         if (!node->parent) break;
@@ -729,14 +814,23 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     // init js object
     htmlmap_t::iterator iter;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
         std::string id = iter->first;
-        js1 += GetJSObject(id);
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        if (node->name == kview) { // create this extra div
+            //js1 += GetJSObject(id);
+            //js1 += CreateJSObject(id, "div");
+        }else {
+            js1 += GetJSObject(id);
+        }
     }
 
     // add js process, TODO: try to remove repeated scripts.
     int ev;
     std::map<std::string, int> jsmap;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
         int iret = ShouldEndTime(current, node, ev);
@@ -755,10 +849,11 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
         }
     }
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
         int iret = ShouldBeginTime(current, node, ev);
-        if (iret >= -1 && html->icss <= 0) {
+        if (iret >= -1 && html->icss <= 0) { // process css only once at frist
             css += html->js[EHtmlCSS];
             html->icss = 1;
         }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 789d8fd..269c950 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -22,6 +22,7 @@ typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name =>
  * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
+    EHtmlNone,
     EHtmlClear,
     EHtmlCSS,
     EHtmlBegin,         //> mmtci:begin
@@ -35,6 +36,7 @@ enum EHtmlEvent{
  */
 struct event_t {
     event_t();
+    std::string str();
 
     bool is_event;      //> event or time
     int is_timeout;     //> 0 if un-processed, non-0 if processed
@@ -149,6 +151,7 @@ public:
 
 protected:
     void SetNodeTime(event_t& event, nodeptr_t node);
+    void ProcEvent(htmlptr_t html, nodeptr_t node);
 
     /**
      * @return: invalid node if -2, too early if -1, doing if 0, done if 1.
diff --git a/net/mmt/mmt_utils.cc b/net/mmt/mmt_utils.cc
index 0c2e022..6f3ac285 100644
--- a/net/mmt/mmt_utils.cc
+++ b/net/mmt/mmt_utils.cc
@@ -19,6 +19,7 @@ const char kMmtDefaultUrl[] = "mmt://localhost";
 
 const char kMmtHtmlId[] = "htmlid";
 const char kMmtXmlIdPrefix[] = "id_subxml_";
+const char kMmtDivIdPrefix[] = "id_div_";
 
 
 void Wait(int ms) {
-- 
1.7.9.5


From eaeae4e4884c66ccdaf5cbbc5799014c3af7694c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 3 Mar 2015 02:15:30 +0800
Subject: [PATCH 126/128] [todo] for event of click

---
 net/mmt/mmt_parser.cc |   67 +++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_parser.h  |    3 ++-
 2 files changed, 50 insertions(+), 20 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 79eb491..2c2705e 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -162,6 +162,9 @@ inline std::string GetJSObject(std::string id) {
 inline std::string SetJSBegin(std::string id) {
     return "if(g_"+id+" != undefined) {";
 }
+inline std::string SetJSBegin2(std::string id) {
+    return "if(1 == 1) {";
+}
 inline std::string SetJSAttr(std::string id, std::string name, std::string value) {
     return "g_"+id+"."+name+" = '"+value+"';";
 }
@@ -179,7 +182,10 @@ inline std::string SetJSEnd() {
     return "}";
 }
 inline std::string SetDivJSClear(std::string id) {
-    return "clearChildNodes(g_"+id+");";
+    return "procChildNodes(g_"+id+", 0);";
+}
+inline std::string SetDivJSPlay(std::string id) {
+    return "procChildNodes(g_"+id+", 1);";
 }
 inline std::string SetCSSStyle(std::string id, std::string value) {
     return "#"+id+"{"+value+"} ";
@@ -187,13 +193,13 @@ inline std::string SetCSSStyle(std::string id, std::string value) {
 
 std::string SetDivJSUtils() {
     std::string js;
-    js += "function clearChildNodes(e0) {";
+    js += "function procChildNodes(e0, st) {";
     js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
     js += " if (e1.nodeType == 1) {";
     js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
-    js += "         if (e1.pause != undefined) e1.pause();";
-    js += "         e1.src = '';";
-    js += "         clearChildNodes(e1);";
+    js += "         if (st == 0) {if (e1.pause != undefined) e1.pause();e1.style.display = 'none';}";
+    js += "         if (st == 1) {if (e1.play != undefined) e1.play();e1.style.display = 'block';}";
+    js += "         procChildNodes(e1, st);";
     js += "}}}}";
     return js;
 }
@@ -365,19 +371,30 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
 
     std::string style = node->attrs[kstyle];
     js0 = js1 = js2 = js3 = SetJSBegin(id);
-    if (node->name != kview) {
-        js0 += SetJSAttr(id, "style.display", "block");
-        js2 += SetJSEventBegin(id, "onclick");
-        js3 += SetJSAttr(id, "style.display", "none");
-        if (!style.empty()) css = SetCSSStyle(id, style);
-    }else {
-        //if (!style.empty()) style += ";";
-        //style += "filter:alpha(opacity=100);opacity:1.0;z-index:100;background-color:#ffffff;";
-        //css = SetCSSStyle(id, style);
+    js0 += SetJSAttr(id, "style.display", "block");
+    js2 += SetJSEventBegin(id, "onclick");
+    js3 += SetJSAttr(id, "style.display", "none");
+    if (!style.empty()) css = SetCSSStyle(id, style);
+
+    if (node->name == kview) {
+        js0 = js1 = js2 = js3 = SetJSBegin2(id);
+        css = "";
+        nodeptrs_t::iterator iter1;
+        for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
+            nodeptr_t sub1 = *iter1;
+            std::string id2 = GetHtmlId(sub1);
+            if (id2.empty()) continue;
+            js0 += SetJSAttr(id2, "style.display", "block");    // begin
+            js0 += SetDivJSPlay(id2);                           // begin
+            js1 += SetDivJSClear(id2);                          // end
+            js3 += SetJSAttr(id2, "style.display", "none");     // clear
+            js3 += SetDivJSClear(id2);                          // clear 
+        }
     }
 
     if (node->name == kdivLocation) {
         // no-op for begin, but have op for end
+        js0 += SetDivJSPlay(id);
         js1 += SetDivJSClear(id);
     }
 
@@ -806,7 +823,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     css = "";
     if (htmls_.empty()) return false;
 
-    std::string js1, js2;
+    std::string js1;
 
     // add util function
     js1 = SetDivJSUtils();
@@ -827,12 +844,19 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     }
 
     // add js process, TODO: try to remove repeated scripts.
+    std::vector<std::string> js2;
+    js2.resize(3);
+
     int ev;
     std::map<std::string, int> jsmap;
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
+        int index = 0;
+        if (node->name == kdivLocation) index = 1;
+        else if (node->name == kview) index = 2;
+
         int iret = ShouldEndTime(current, node, ev);
         if (iret == 0) {
             if (ev == EHtmlClick)
@@ -840,7 +864,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             if (html) {
                 std::string key = html->id+"@"+Int2String(ev,2);
                 if (jsmap.find(key) == jsmap.end()) {
-                    js2 += html->js[ev];
+                    js2[index] += html->js[ev];
                     jsmap[key] = 1;
                 }else {
                     LOG(INFO) << __func__ << " begin exist, key=" << key;
@@ -852,13 +876,17 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
         nodeptr_t node = html->node;
+        int index = 0;
+        if (node->name == kdivLocation) index = 1;
+        else if (node->name == kview) index = 2;
+
         int iret = ShouldBeginTime(current, node, ev);
         if (iret >= -1 && html->icss <= 0) { // process css only once at frist
             css += html->js[EHtmlCSS];
             html->icss = 1;
         }
         if (iret == -1 || (iret == 0 && ev == EHtmlClick)) {
-            js2 += html->js[EHtmlClear];
+            js2[index] += html->js[EHtmlClear];
             //LOG(INFO) << __func__ << " set js clear=" << html->js[EHtmlClear];
         }
         if (iret == 0) {
@@ -867,7 +895,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             if (html) {
                 std::string key = html->id+"@"+Int2String(ev,2);
                 if (jsmap.find(key) == jsmap.end()) {
-                    js2 += html->js[ev];
+                    js2[index] += html->js[ev];
                     jsmap[key] = 1;
                 }else {
                     LOG(INFO) << __func__ << " end exist, key=" << key;
@@ -876,7 +904,8 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
         }
     }
 
-    if (!js2.empty()) js = js1 + js2;
+    std::string js0 = js2[0] + js2[1] + js2[2];
+    if (!js0.empty()) js = js1 + js0;
 
     return true;
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 269c950..20f5eb2 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -22,13 +22,14 @@ typedef std::map<std::string, std::string> attrs_t; // xml node's attr: name =>
  * Event type for the value of mmtci:begin or mmtci:end
  */
 enum EHtmlEvent{
-    EHtmlNone,
+    EHtmlNone = 0,
     EHtmlClear,
     EHtmlCSS,
     EHtmlBegin,         //> mmtci:begin
     EHtmlEnd,           //> mmtci:end
     EHtmlClick,
     EHtmlSubXml,
+    EHtmlAll
 };
 
 /**
-- 
1.7.9.5


From 5f1c4af742e363e72e424e1308275fc27487840d Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Tue, 3 Mar 2015 10:03:28 +0800
Subject: [PATCH 127/128] [todo] for case2

---
 net/mmt/mmt_parser.cc |  107 +++++++++++++++++++++++++++++++++++--------------
 net/mmt/mmt_parser.h  |    1 +
 2 files changed, 79 insertions(+), 29 deletions(-)

diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index 2c2705e..b107451 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -148,21 +148,22 @@ static std::string GetMediaSrc(std::string src, std::string id, int tabid) {
     return url;
 }
 inline std::string CreateJSObject(std::string id, std::string name) {
-    std::string str;
-    str += "if(g_"+id+" == undefined) {";
-    str += "g_"+id+"=document.createElement('"+name+"');";
-    str += "g_"+id+".id='"+id+"';";
-    str += "document.body.appendChild(g_"+id+");";
-    str += "}";
-    return str;
+    std::string js;
+    js += "if(g_"+id+" == undefined) {";
+    js += "g_"+id+" = document.createElement('"+name+"');"; // create element
+    js += "g_"+id+".id='"+id+"';";                          // set element id
+    js += "document.body.appendChild(g_"+id+");";
+    js += "}";
+    return js;
 }
 inline std::string GetJSObject(std::string id) {
-    return "g_"+id+" = document.getElementById('"+id+"');";
+    //return "g_"+id+" = document.getElementById('"+id+"');";
+    return "g_"+id+" = getNode('"+id+"');";
 }
 inline std::string SetJSBegin(std::string id) {
     return "if(g_"+id+" != undefined) {";
 }
-inline std::string SetJSBegin2(std::string id) {
+inline std::string SetJSBeginTrue(std::string id) {
     return "if(1 == 1) {";
 }
 inline std::string SetJSAttr(std::string id, std::string name, std::string value) {
@@ -181,6 +182,13 @@ inline std::string SetJSEventEnd() {
 inline std::string SetJSEnd() {
     return "}";
 }
+
+inline std::string ProcMediaJS(std::string id) {
+    return "procMediaNode(g_"+id+");";
+}
+inline std::string SetDivJSStatus(std::string id, std::string st) {
+    return "procChildNodes(g_"+id+", "+st+");";
+}
 inline std::string SetDivJSClear(std::string id) {
     return "procChildNodes(g_"+id+", 0);";
 }
@@ -191,16 +199,49 @@ inline std::string SetCSSStyle(std::string id, std::string value) {
     return "#"+id+"{"+value+"} ";
 }
 
+inline std::string AddJSAttr(std::string id, std::string name, std::string value) {
+    std::string js;
+    js += "if(g_"+id+" != undefined && g_"+id+"."+name+" == undefined) {";
+    js += SetJSAttr(id, name, value);
+    js += "}";
+    return js;
+}
+
+std::string SetJSUtils() {
+    std::string js;
+    js += "function getNode(eid) {return document.getElementById(eid);}";
+    return js;
+}
+std::string SetMediaJSUtils() {
+    std::string js;
+    js += "function procMediaNode(e1) {";
+    js += "if (e1 == undefined || e1.mstate == undefined) return;";
+    js += "if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
+    js += "    if (e1.mstate == 2) {";      // played
+    js += "        e1.style.display = 'block';";
+    js += "    }else if (e1.mstate == 1) {";      // playing
+    js += "        if (e1.play != undefined) e1.play();e1.style.display = 'block'; e1.mstate = 2;";
+    js += "    }else if(e1.mstate == 0) {";  // pause
+    js += "        if (e1.pause != undefined) e1.pause();e1.style.display = 'none';";
+    js += "    }";
+    js += "}}";
+    return js;
+}
 std::string SetDivJSUtils() {
     std::string js;
+    js += "var domedia = 0;";
     js += "function procChildNodes(e0, st) {";
+    js += "if(e0)";
+    js += "{if(st >= 1) {e0.style.display = 'block';} else {e0.style.display = 'none';}}";
     js += "for (var k=0,e1; e1=e0.childNodes[k++];) {";
     js += " if (e1.nodeType == 1) {";
     js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'IMG') {";
-    js += "         if (st == 0) {if (e1.pause != undefined) e1.pause();e1.style.display = 'none';}";
-    js += "         if (st == 1) {if (e1.play != undefined) e1.play();e1.style.display = 'block';}";
+    js += "         if (st != -1) {e1.mstate = st; if (domedia == 1) procMediaNode(e1);}";
+    js += "     }";
+    js += "     if (e1.nodeName == 'VIDEO' || e1.nodeName == 'AUDIO' || e1.nodeName == 'DIV') {";
     js += "         procChildNodes(e1, st);";
-    js += "}}}}";
+    js += "     }";
+    js += "}}}";
     return js;
 }
 std::string SetSubXmlJS(std::string id, std::string href, std::string action) {
@@ -371,23 +412,24 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
 
     std::string style = node->attrs[kstyle];
     js0 = js1 = js2 = js3 = SetJSBegin(id);
-    js0 += SetJSAttr(id, "style.display", "block");
+    //js0 += SetJSAttr(id, "style.display", "block");
     js2 += SetJSEventBegin(id, "onclick");
+    js2 += "domedia = 1;";
     js3 += SetJSAttr(id, "style.display", "none");
     if (!style.empty()) css = SetCSSStyle(id, style);
 
     if (node->name == kview) {
-        js0 = js1 = js2 = js3 = SetJSBegin2(id);
+        js0 = js1 = js2 = js3 = SetJSBeginTrue(id);
         css = "";
         nodeptrs_t::iterator iter1;
         for(iter1=node->nodes.begin(); iter1 != node->nodes.end(); iter1++ ){
             nodeptr_t sub1 = *iter1;
             std::string id2 = GetHtmlId(sub1);
             if (id2.empty()) continue;
-            js0 += SetJSAttr(id2, "style.display", "block");    // begin
-            js0 += SetDivJSPlay(id2);                           // begin
-            js1 += SetDivJSClear(id2);                          // end
-            js3 += SetJSAttr(id2, "style.display", "none");     // clear
+            //js0 += SetJSAttr(id2, "style.display", "block");    // begin
+            //js0 += SetDivJSStatus(id2, "-1");                     // begin
+            //js1 += SetDivJSStatus(id2, "-1");                     // end
+            //js3 += SetJSAttr(id2, "style.display", "none");     // clear
             js3 += SetDivJSClear(id2);                          // clear 
         }
     }
@@ -428,8 +470,8 @@ static void InitHtmlJS(nodeptr_t node, htmlmap_t& htmls, int tabid) {
         }
 
         if (bfind) {
-            js0 += SetJSFunc(id, "play");
-            js1 += SetJSFunc(id, "pause");
+            js0 += SetJSAttr(id, "mstate", "1");  // playing
+            js1 += SetJSAttr(id, "mstate", "0");  // pause
         }
     }
 
@@ -580,6 +622,7 @@ bool CiParser::ParseHtml() {
     for (iter=htmls_.begin(); iter != htmls_.end(); iter++) {
         if (iter->first == "html") continue;
         htmlptr_t html = iter->second;
+        html->js[EHtmlClick] += "domedia=0;";
         html->js[EHtmlClick] += SetJSEventEnd();
         html->js[EHtmlClick] += SetJSEnd();
         html->js[EHtmlClear] += SetJSEnd();
@@ -823,10 +866,12 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
     css = "";
     if (htmls_.empty()) return false;
 
-    std::string js1;
+    std::string js1, js2, js3;
 
     // add util function
-    js1 = SetDivJSUtils();
+    js1 += SetJSUtils(); js1 += "\n";
+    js1 += SetMediaJSUtils(); js1 += "\n";
+    js1 += SetDivJSUtils(); js1 += "\n";
 
     // init js object
     htmlmap_t::iterator iter;
@@ -840,12 +885,16 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             //js1 += CreateJSObject(id, "div");
         }else {
             js1 += GetJSObject(id);
+            if (node->name == kMediaSync) { // add new attr
+                js1 += AddJSAttr(id, "mstate", "0"); // 0 - uninit, 1 - playing, 2 - paused
+                js3 += ProcMediaJS(id);
+            }
         }
     }
 
     // add js process, TODO: try to remove repeated scripts.
-    std::vector<std::string> js2;
-    js2.resize(3);
+    std::vector<std::string> js2vec;
+    js2vec.resize(3);
 
     int ev;
     std::map<std::string, int> jsmap;
@@ -864,7 +913,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             if (html) {
                 std::string key = html->id+"@"+Int2String(ev,2);
                 if (jsmap.find(key) == jsmap.end()) {
-                    js2[index] += html->js[ev];
+                    js2vec[index] += html->js[ev];
                     jsmap[key] = 1;
                 }else {
                     LOG(INFO) << __func__ << " begin exist, key=" << key;
@@ -886,7 +935,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             html->icss = 1;
         }
         if (iret == -1 || (iret == 0 && ev == EHtmlClick)) {
-            js2[index] += html->js[EHtmlClear];
+            js2vec[index] += html->js[EHtmlClear];
             //LOG(INFO) << __func__ << " set js clear=" << html->js[EHtmlClear];
         }
         if (iret == 0) {
@@ -895,7 +944,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             if (html) {
                 std::string key = html->id+"@"+Int2String(ev,2);
                 if (jsmap.find(key) == jsmap.end()) {
-                    js2[index] += html->js[ev];
+                    js2vec[index] += html->js[ev];
                     jsmap[key] = 1;
                 }else {
                     LOG(INFO) << __func__ << " end exist, key=" << key;
@@ -903,9 +952,9 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             }
         }
     }
+    js2 = js2vec[0] + js2vec[1] + js2vec[2];
 
-    std::string js0 = js2[0] + js2[1] + js2[2];
-    if (!js0.empty()) js = js1 + js0;
+    if (!js2.empty()) js = js1 + "\n" + js2 + "\n" + js3;
 
     return true;
 }
diff --git a/net/mmt/mmt_parser.h b/net/mmt/mmt_parser.h
index 20f5eb2..5f8bab0 100644
--- a/net/mmt/mmt_parser.h
+++ b/net/mmt/mmt_parser.h
@@ -29,6 +29,7 @@ enum EHtmlEvent{
     EHtmlEnd,           //> mmtci:end
     EHtmlClick,
     EHtmlSubXml,
+    EHtmlLast,
     EHtmlAll
 };
 
-- 
1.7.9.5


From 093af91afa448e3741877f5c4c3884cfbaf4f86c Mon Sep 17 00:00:00 2001
From: Yongze Xu <yongzxu@ubuntu.(none)>
Date: Wed, 4 Mar 2015 00:24:21 +0800
Subject: [PATCH 128/128] [ok] for case 1/2/8/9

---
 net/mmt/mmt_control.cc |   13 +++++++------
 net/mmt/mmt_parser.cc  |   27 +++++++++++++++++++++++++--
 2 files changed, 32 insertions(+), 8 deletions(-)

diff --git a/net/mmt/mmt_control.cc b/net/mmt/mmt_control.cc
index 0075e00..28c099f 100644
--- a/net/mmt/mmt_control.cc
+++ b/net/mmt/mmt_control.cc
@@ -268,15 +268,15 @@ void ProcCiXml(cixmlptr_t cixml, int tabid) {
         if(!cixml->parser->ParseXml() || !cixml->parser->ParseHtml()) {
             LOG(INFO) << __func__ << " fail to parse xml first fname=" << xml_name;
             cixml->parser = nullptr;
-            cixml->update = 15;
+            cixml->update = 30;
         }else {
             cixml->parser->PrintHtmlJS();
         }
     }
 
     int64 ntp = GetNTPTime();
+    // Porcess update of ci xml
     if (cixml->parser && (cixml->update--) <= 0) {
-        // update ci xml
         int64 timestamp = cixml->parser->GetTimestamp();
         std::string version = cixml->parser->GetVersion();
         CiParserPtr parser2 = new CiParser(xml_name);
@@ -296,13 +296,14 @@ void ProcCiXml(cixmlptr_t cixml, int tabid) {
                     LOG(INFO) << __func__ << " to update xml, OK";
                 }
             }
-            cixml->update = 15;
+            cixml->update = 30;
         }else {
             LOG(INFO) << __func__ << " fail to parse xml";
         }
         parser2 = nullptr;
     }
 
+    // Process subset xml
     if (cixml->parser && !cixml->subxmls.empty()) {
         std::vector<xmlinfo_t>::iterator iter_sx;
         for (iter_sx=cixml->subxmls.begin(); iter_sx != cixml->subxmls.end(); iter_sx++) {
@@ -312,7 +313,7 @@ void ProcCiXml(cixmlptr_t cixml, int tabid) {
                 if(parser2->ParseXml()) { // if failed maybe not got this xml, waiting for next time
                     parser2->SetTabId(tabid); // should be called before ParserHtml
                     if(parser2->ParseHtml()) {
-                        parser2->MergeCI(cixml->parser.get());
+                        parser2->MergeCI2(cixml->parser.get());
                         cixml->parser = parser2;
                     }
                     iter_sx->timeout = 1;
@@ -371,10 +372,10 @@ void MmtControl::CheckEvent() {
         //LOG(INFO) << __func__ << " tabid=" << iter->first << " status=" << next_status;
         if (cixml->status == "initing") {
             next_status = "loading";
-            Wait(100);
+            Wait(300);
         }else if (cixml->status == "loading") {
             next_status = "loaded";
-            Wait(1000);
+            Wait(500);
         }else if (cixml->status == "loaded") {
             ProcCiXml(cixml, tabid);
             //next_status = "end";
diff --git a/net/mmt/mmt_parser.cc b/net/mmt/mmt_parser.cc
index b107451..fd6ea83 100644
--- a/net/mmt/mmt_parser.cc
+++ b/net/mmt/mmt_parser.cc
@@ -571,6 +571,7 @@ bool CiParser::ParseHtml() {
                 if (sub1->attrs.find(kxlinkactuate) != sub1->attrs.end()) {
                     actuate = sub1->attrs[kxlinkactuate];
                 }
+                if (actuate.empty()) actuate = konLoad;
 
                 if (href.empty() || actuate.empty()) continue;
                 htmlptr_t html = new html_t;
@@ -778,7 +779,28 @@ bool CiParser::MergeCI(CiParser* parser) {
  *  second, add new node from another xml's same node
  */
 bool CiParser::MergeCI2(CiParser* parser) {
-    return false;
+    if (!parser) return false;
+
+    nodeptr_t oldroot = parser->root_;
+    htmlmap_t::iterator iter;
+    for (iter=parser->htmls_.begin(); iter != parser->htmls_.end(); iter++) {
+        if (iter->first == "html") continue;
+        std::string id = iter->first;
+        htmlptr_t html = iter->second;
+        nodeptr_t node = html->node;
+        if (htmls_.find(id) == htmls_.end()) {
+            htmls_[id] = html;
+            do{
+                if (!node || !node->parent) break;
+                if (node->parent.get() == oldroot.get()) {
+                    node->parent = root_;
+                    break;
+                }
+                node = node->parent;
+            }while(true);
+        }
+    }
+    return true;
 }
 
 
@@ -814,6 +836,7 @@ int CiParser::ShouldBeginTime(int64 current, nodeptr_t cnode, int& ev) {
     }while(true);
 
     LOG(INFO) << __func__ << " node name=" << begin.id << " curtime=" << curtime << " current=" << current;
+
     if (curtime < 0 || curtime <= current) {
         cnode->time.begin.is_timeout = 1;
         return 0;
@@ -887,7 +910,7 @@ bool CiParser::GetHtmlJS(int64 current, std::string& js, std::string& css) {
             js1 += GetJSObject(id);
             if (node->name == kMediaSync) { // add new attr
                 js1 += AddJSAttr(id, "mstate", "0"); // 0 - uninit, 1 - playing, 2 - paused
-                js3 += ProcMediaJS(id);
+                js3 = ProcMediaJS(id) + js3;
             }
         }
     }
-- 
1.7.9.5

